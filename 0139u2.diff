diff -Nru src-old/emu/addrmap.c src/emu/addrmap.c
--- src-old/emu/addrmap.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/addrmap.c	2010-08-30 08:20:58.000000000 -0700
@@ -41,31 +41,22 @@
 
 
 //**************************************************************************
-//  MACROS
+//  ADDRESS MAP ENTRY
 //**************************************************************************
 
-// maps a full 64-bit mask down to an 8-bit byte mask
-#define UNITMASK8(x) \
-	((((UINT64)(x) >> (63-7)) & 0x80) | \
-	 (((UINT64)(x) >> (55-6)) & 0x40) | \
-	 (((UINT64)(x) >> (47-5)) & 0x20) | \
-	 (((UINT64)(x) >> (39-4)) & 0x10) | \
-	 (((UINT64)(x) >> (31-3)) & 0x08) | \
-	 (((UINT64)(x) >> (23-2)) & 0x04) | \
-	 (((UINT64)(x) >> (15-1)) & 0x02) | \
-	 (((UINT64)(x) >> ( 7-0)) & 0x01))
-
-// maps a full 64-bit mask down to a 4-bit word mask
-#define UNITMASK16(x) \
-	((((UINT64)(x) >> (63-3)) & 0x08) | \
-	 (((UINT64)(x) >> (47-2)) & 0x04) | \
-	 (((UINT64)(x) >> (31-1)) & 0x02) | \
-	 (((UINT64)(x) >> (15-0)) & 0x01))
-
-// maps a full 64-bit mask down to a 2-bit dword mask
-#define UNITMASK32(x) \
-	((((UINT64)(x) >> (63-1)) & 0x02) | \
-	 (((UINT64)(x) >> (31-0)) & 0x01))
+//-------------------------------------------------
+//  set_tag - set the appropriate tag for a device
+//-------------------------------------------------
+
+inline void map_handler_data::set_tag(const device_config &devconfig, const char *tag)
+{
+	if (tag == NULL)
+		m_tag = NULL;
+	else if (strcmp(tag, DEVICE_SELF) == 0)
+		m_tag = devconfig.tag();
+	else
+		m_tag = devconfig.siblingtag(m_derived_tag, tag);
+}
 
 
 
@@ -93,6 +84,22 @@
 	  m_gensizeptroffs_plus1(0),
 	  m_region(NULL),
 	  m_rgnoffs(0),
+	  m_rspace8(NULL),
+	  m_rspace16(NULL),
+	  m_rspace32(NULL),
+	  m_rspace64(NULL),
+	  m_rdevice8(NULL),
+	  m_rdevice16(NULL),
+	  m_rdevice32(NULL),
+	  m_rdevice64(NULL),
+	  m_wspace8(NULL),
+	  m_wspace16(NULL),
+	  m_wspace32(NULL),
+	  m_wspace64(NULL),
+	  m_wdevice8(NULL),
+	  m_wdevice16(NULL),
+	  m_wdevice32(NULL),
+	  m_wdevice64(NULL),
 	  m_memory(NULL),
 	  m_bytestart(0),
 	  m_byteend(0),
@@ -121,8 +128,8 @@
 
 void address_map_entry::set_read_port(const device_config &devconfig, const char *tag)
 {
-	m_read.type = AMH_PORT;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_PORT;
+	m_read.set_tag(devconfig, tag);
 }
 
 
@@ -133,8 +140,8 @@
 
 void address_map_entry::set_write_port(const device_config &devconfig, const char *tag)
 {
-	m_write.type = AMH_PORT;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_PORT;
+	m_write.set_tag(devconfig, tag);
 }
 
 
@@ -145,10 +152,10 @@
 
 void address_map_entry::set_readwrite_port(const device_config &devconfig, const char *tag)
 {
-	m_read.type = AMH_PORT;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
-	m_write.type = AMH_PORT;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_read.m_type = AMH_PORT;
+	m_read.set_tag(devconfig, tag);
+	m_write.m_type = AMH_PORT;
+	m_write.set_tag(devconfig, tag);
 }
 
 
@@ -159,8 +166,8 @@
 
 void address_map_entry::set_read_bank(const device_config &devconfig, const char *tag)
 {
-	m_read.type = AMH_BANK;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_BANK;
+	m_read.set_tag(devconfig, tag);
 }
 
 
@@ -171,8 +178,8 @@
 
 void address_map_entry::set_write_bank(const device_config &devconfig, const char *tag)
 {
-	m_write.type = AMH_BANK;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_BANK;
+	m_write.set_tag(devconfig, tag);
 }
 
 
@@ -183,10 +190,10 @@
 
 void address_map_entry::set_readwrite_bank(const device_config &devconfig, const char *tag)
 {
-	m_read.type = AMH_BANK;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
-	m_write.type = AMH_BANK;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_read.m_type = AMH_BANK;
+	m_read.set_tag(devconfig, tag);
+	m_write.m_type = AMH_BANK;
+	m_write.set_tag(devconfig, tag);
 }
 
 
@@ -197,23 +204,25 @@
 
 void address_map_entry::internal_set_handler(read8_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(8, unitmask, string));
-	m_read.type = AMH_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 8;
-	m_read.mask = UNITMASK8(unitmask);
-	m_read.handler.read.shandler8 = func;
-	m_read.name = string;
+	m_read.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_read.m_bits = 8;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_rspace8 = func;
 }
 
 
 void address_map_entry::internal_set_handler(write8_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(8, unitmask, string));
-	m_write.type = AMH_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 8;
-	m_write.mask = UNITMASK8(unitmask);
-	m_write.handler.write.shandler8 = func;
-	m_write.name = string;
+	m_write.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_write.m_bits = 8;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_wspace8 = func;
 }
 
 
@@ -226,25 +235,27 @@
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(8, unitmask, string));
-	m_read.type = AMH_DEVICE_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 8;
-	m_read.mask = UNITMASK8(unitmask);
-	m_read.handler.read.dhandler8 = func;
-	m_read.name = string;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_read.m_bits = 8;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_read.set_tag(devconfig, tag);
+	m_rdevice8 = func;
 }
 
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(8, unitmask, string));
-	m_write.type = AMH_DEVICE_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 8;
-	m_write.mask = UNITMASK8(unitmask);
-	m_write.handler.write.dhandler8 = func;
-	m_write.name = string;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_write.m_bits = 8;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_write.set_tag(devconfig, tag);
+	m_wdevice8 = func;
 }
 
 
@@ -255,6 +266,39 @@
 }
 
 
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(8, unitmask, func.name()));
+	m_read.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;
+	m_read.m_bits = 8;
+	m_read.m_mask = unitmask;
+	m_read.m_name = func.name();
+	m_read.set_tag(devconfig, tag);
+	m_rproto8 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(8, unitmask, func.name()));
+	m_write.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_write.m_bits = 8;
+	m_write.m_mask = unitmask;
+	m_write.m_name = func.name();
+	m_write.set_tag(devconfig, tag);
+	m_wproto8 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc, UINT64 unitmask)
+{
+	internal_set_handler(devconfig, tag, rfunc, unitmask);
+	internal_set_handler(devconfig, tag, wfunc, unitmask);
+}
+
+
 //-------------------------------------------------
 //  internal_set_handler - handler setters for
 //  16-bit read/write handlers
@@ -262,23 +306,25 @@
 
 void address_map_entry::internal_set_handler(read16_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(16, unitmask, string));
-	m_read.type = AMH_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 16;
-	m_read.mask = UNITMASK16(unitmask);
-	m_read.handler.read.shandler16 = func;
-	m_read.name = string;
+	m_read.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_read.m_bits = 16;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_rspace16 = func;
 }
 
 
 void address_map_entry::internal_set_handler(write16_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(16, unitmask, string));
-	m_write.type = AMH_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 16;
-	m_write.mask = UNITMASK16(unitmask);
-	m_write.handler.write.shandler16 = func;
-	m_write.name = string;
+	m_write.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_write.m_bits = 16;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_wspace16 = func;
 }
 
 
@@ -291,25 +337,27 @@
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read16_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(16, unitmask, string));
-	m_read.type = AMH_DEVICE_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 16;
-	m_read.mask = UNITMASK16(unitmask);
-	m_read.handler.read.dhandler16 = func;
-	m_read.name = string;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_read.m_bits = 16;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_read.set_tag(devconfig, tag);
+	m_rdevice16 = func;
 }
 
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write16_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(16, unitmask, string));
-	m_write.type = AMH_DEVICE_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 16;
-	m_write.mask = UNITMASK16(unitmask);
-	m_write.handler.write.dhandler16 = func;
-	m_write.name = string;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_write.m_bits = 16;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_write.set_tag(devconfig, tag);
+	m_wdevice16 = func;
 }
 
 
@@ -320,6 +368,39 @@
 }
 
 
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(16, unitmask, func.name()));
+	m_read.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_read.m_bits = 16;
+	m_read.m_mask = unitmask;
+	m_read.m_name = func.name();
+	m_read.set_tag(devconfig, tag);
+	m_rproto16 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write16_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(16, unitmask, func.name()));
+	m_write.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_write.m_bits = 16;
+	m_write.m_mask = unitmask;
+	m_write.m_name = func.name();
+	m_write.set_tag(devconfig, tag);
+	m_wproto16 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate rfunc, write16_proto_delegate wfunc, UINT64 unitmask)
+{
+	internal_set_handler(devconfig, tag, rfunc, unitmask);
+	internal_set_handler(devconfig, tag, wfunc, unitmask);
+}
+
+
 //-------------------------------------------------
 //  internal_set_handler - handler setters for
 //  32-bit read/write handlers
@@ -327,23 +408,25 @@
 
 void address_map_entry::internal_set_handler(read32_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(32, unitmask, string));
-	m_read.type = AMH_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 32;
-	m_read.mask = UNITMASK32(unitmask);
-	m_read.handler.read.shandler32 = func;
-	m_read.name = string;
+	m_read.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_read.m_bits = 32;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_rspace32 = func;
 }
 
 
 void address_map_entry::internal_set_handler(write32_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(32, unitmask, string));
-	m_write.type = AMH_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 32;
-	m_write.mask = UNITMASK32(unitmask);
-	m_write.handler.write.shandler32 = func;
-	m_write.name = string;
+	m_write.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_write.m_bits = 32;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_wspace32 = func;
 }
 
 
@@ -356,25 +439,27 @@
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read32_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(32, unitmask, string));
-	m_read.type = AMH_DEVICE_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 32;
-	m_read.mask = UNITMASK32(unitmask);
-	m_read.handler.read.dhandler32 = func;
-	m_read.name = string;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_read.m_bits = 32;
+	m_read.m_mask = unitmask;
+	m_read.m_name = string;
+	m_read.set_tag(devconfig, tag);
+	m_rdevice32 = func;
 }
 
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write32_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(32, unitmask, string));
-	m_write.type = AMH_DEVICE_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 32;
-	m_write.mask = UNITMASK32(unitmask);
-	m_write.handler.write.dhandler32 = func;
-	m_write.name = string;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_write.m_bits = 32;
+	m_write.m_mask = unitmask;
+	m_write.m_name = string;
+	m_write.set_tag(devconfig, tag);
+	m_wdevice32 = func;
 }
 
 
@@ -385,6 +470,39 @@
 }
 
 
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(32, unitmask, func.name()));
+	m_read.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_read.m_bits = 32;
+	m_read.m_mask = unitmask;
+	m_read.m_name = func.name();
+	m_read.set_tag(devconfig, tag);
+	m_rproto32 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write32_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(32, unitmask, func.name()));
+	m_write.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_write.m_bits = 32;
+	m_write.m_mask = unitmask;
+	m_write.m_name = func.name();
+	m_write.set_tag(devconfig, tag);
+	m_wproto32 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate rfunc, write32_proto_delegate wfunc, UINT64 unitmask)
+{
+	internal_set_handler(devconfig, tag, rfunc, unitmask);
+	internal_set_handler(devconfig, tag, wfunc, unitmask);
+}
+
+
 //-------------------------------------------------
 //  internal_set_handler - handler setters for
 //  64-bit read/write handlers
@@ -392,23 +510,25 @@
 
 void address_map_entry::internal_set_handler(read64_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(64, unitmask, string));
-	m_read.type = AMH_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 64;
-	m_read.mask = 0;
-	m_read.handler.read.shandler64 = func;
-	m_read.name = string;
+	m_read.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_read.m_bits = 64;
+	m_read.m_mask = 0;
+	m_read.m_name = string;
+	m_rspace64 = func;
 }
 
 
 void address_map_entry::internal_set_handler(write64_space_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(64, unitmask, string));
-	m_write.type = AMH_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 64;
-	m_write.mask = 0;
-	m_write.handler.write.shandler64 = func;
-	m_write.name = string;
+	m_write.m_type = AMH_LEGACY_SPACE_HANDLER;
+	m_write.m_bits = 64;
+	m_write.m_mask = 0;
+	m_write.m_name = string;
+	m_wspace64 = func;
 }
 
 
@@ -421,25 +541,27 @@
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read64_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(64, unitmask, string));
-	m_read.type = AMH_DEVICE_HANDLER;
-	m_read.bits = (unitmask == 0) ? 0 : 64;
-	m_read.mask = 0;
-	m_read.handler.read.dhandler64 = func;
-	m_read.name = string;
-	m_read.tag = devconfig.siblingtag(m_read.derived_tag, tag);
+	m_read.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_read.m_bits = 64;
+	m_read.m_mask = 0;
+	m_read.m_name = string;
+	m_read.set_tag(devconfig, tag);
+	m_rdevice64 = func;
 }
 
 
 void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write64_device_func func, const char *string, UINT64 unitmask)
 {
+	assert(func != NULL);
 	assert(unitmask_is_appropriate(64, unitmask, string));
-	m_write.type = AMH_DEVICE_HANDLER;
-	m_write.bits = (unitmask == 0) ? 0 : 64;
-	m_write.mask = 0;
-	m_write.handler.write.dhandler64 = func;
-	m_write.name = string;
-	m_write.tag = devconfig.siblingtag(m_write.derived_tag, tag);
+	m_write.m_type = AMH_LEGACY_DEVICE_HANDLER;
+	m_write.m_bits = 64;
+	m_write.m_mask = 0;
+	m_write.m_name = string;
+	m_write.set_tag(devconfig, tag);
+	m_wdevice64 = func;
 }
 
 
@@ -450,6 +572,39 @@
 }
 
 
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(64, unitmask, func.name()));
+	m_read.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_read.m_bits = 64;
+	m_read.m_mask = 0;
+	m_read.m_name = func.name();
+	m_read.set_tag(devconfig, tag);
+	m_rproto64 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, write64_proto_delegate func, UINT64 unitmask)
+{
+	assert(!func.isnull());
+	assert(unitmask_is_appropriate(64, unitmask, func.name()));
+	m_write.m_type = (tag == NULL) ? AMH_DRIVER_DELEGATE : AMH_DEVICE_DELEGATE;;
+	m_write.m_bits = 64;
+	m_write.m_mask = 0;
+	m_write.m_name = func.name();
+	m_write.set_tag(devconfig, tag);
+	m_wproto64 = func;
+}
+
+
+void address_map_entry::internal_set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate rfunc, write64_proto_delegate wfunc, UINT64 unitmask)
+{
+	internal_set_handler(devconfig, tag, rfunc, unitmask);
+	internal_set_handler(devconfig, tag, wfunc, unitmask);
+}
+
+
 //-------------------------------------------------
 //  unitmask_is_appropriate - verify that the
 //  provided unitmask is valid and expected
@@ -540,9 +695,7 @@
 	: m_spacenum(spacenum),
 	  m_databits(0xff),
 	  m_unmapval(0),
-	  m_globalmask(0),
-	  m_entrylist(NULL),
-	  m_tailptr(&m_entrylist)
+	  m_globalmask(0)
 {
 	// get our memory interface
 	const device_config_memory_interface *memintf;
@@ -574,13 +727,6 @@
 
 address_map::~address_map()
 {
-	// free all entries */
-	while (m_entrylist != NULL)
-	{
-		address_map_entry *entry = m_entrylist;
-		m_entrylist = entry->m_next;
-		global_free(entry);
-	}
 }
 
 
@@ -621,8 +767,7 @@
 address_map_entry8 *address_map::add(offs_t start, offs_t end, address_map_entry8 *ptr)
 {
 	ptr = global_alloc(address_map_entry8(*this, start, end));
-	*m_tailptr = ptr;
-	m_tailptr = &ptr->m_next;
+	m_entrylist.append(*ptr);
 	return ptr;
 }
 
@@ -630,8 +775,7 @@
 address_map_entry16 *address_map::add(offs_t start, offs_t end, address_map_entry16 *ptr)
 {
 	ptr = global_alloc(address_map_entry16(*this, start, end));
-	*m_tailptr = ptr;
-	m_tailptr = &ptr->m_next;
+	m_entrylist.append(*ptr);
 	return ptr;
 }
 
@@ -639,8 +783,7 @@
 address_map_entry32 *address_map::add(offs_t start, offs_t end, address_map_entry32 *ptr)
 {
 	ptr = global_alloc(address_map_entry32(*this, start, end));
-	*m_tailptr = ptr;
-	m_tailptr = &ptr->m_next;
+	m_entrylist.append(*ptr);
 	return ptr;
 }
 
@@ -648,244 +791,6 @@
 address_map_entry64 *address_map::add(offs_t start, offs_t end, address_map_entry64 *ptr)
 {
 	ptr = global_alloc(address_map_entry64(*this, start, end));
-	*m_tailptr = ptr;
-	m_tailptr = &ptr->m_next;
+	m_entrylist.append(*ptr);
 	return ptr;
 }
-
-
-
-#if 0
-
-// old code for reference
-
-/***************************************************************************
-    ADDRESS MAP HELPERS
-***************************************************************************/
-
-/*-------------------------------------------------
-    map_detokenize - detokenize an array of
-    address map tokens
--------------------------------------------------*/
-
-#define check_map(field) do { \
-	if (map->field != 0 && map->field != tmap.field) \
-		fatalerror("%s: %s included a mismatched address map (%s %d) for an existing map with %s %d!\n", driver->source_file, driver->name, #field, tmap.field, #field, map->field); \
-	} while (0)
-
-#define check_entry_handler(row) do { \
-	if (entry->row.type != AMH_NONE) \
-		fatalerror("%s: %s AM_RANGE(0x%x, 0x%x) %s handler already set!\n", driver->source_file, driver->name, entry->addrstart, entry->addrend, #row); \
-	} while (0)
-
-#define check_entry_field(field) do { \
-	if (entry->field != 0) \
-		fatalerror("%s: %s AM_RANGE(0x%x, 0x%x) setting %s already set!\n", driver->source_file, driver->name, entry->addrstart, entry->addrend, #field); \
-	} while (0)
-
-static void map_detokenize(memory_private *memdata, address_map *map, const game_driver *driver, const device_config *devconfig, const addrmap_token *tokens)
-{
-	address_map_entry **firstentryptr;
-	address_map_entry **entryptr;
-	address_map_entry *entry;
-	address_map tmap = {0};
-	UINT32 entrytype;
-	int maptype;
-
-	/* check the first token */
-	TOKEN_GET_UINT32_UNPACK3(tokens, entrytype, 8, tmap.spacenum, 8, tmap.databits, 8);
-	if (entrytype != ADDRMAP_TOKEN_START)
-		fatalerror("%s: %s Address map missing ADDRMAP_TOKEN_START!\n", driver->source_file, driver->name);
-	if (tmap.spacenum >= ADDRESS_SPACES)
-		fatalerror("%s: %s Invalid address space %d for memory map!\n", driver->source_file, driver->name, tmap.spacenum);
-	if (tmap.databits != 8 && tmap.databits != 16 && tmap.databits != 32 && tmap.databits != 64)
-		fatalerror("%s: %s Invalid data bits %d for memory map!\n", driver->source_file, driver->name, tmap.databits);
-	check_map(spacenum);
-	check_map(databits);
-
-	/* fill in the map values */
-	map->spacenum = tmap.spacenum;
-	map->databits = tmap.databits;
-
-	/* find the end of the list */
-	for (entryptr = &map->entrylist; *entryptr != NULL; entryptr = &(*entryptr)->next) ;
-	firstentryptr = entryptr;
-	entry = NULL;
-
-	/* loop over tokens until we hit the end */
-	while (entrytype != ADDRMAP_TOKEN_END)
-	{
-		/* unpack the token from the first entry */
-		TOKEN_GET_UINT32_UNPACK1(tokens, entrytype, 8);
-		switch (entrytype)
-		{
-			/* end */
-			case ADDRMAP_TOKEN_END:
-				break;
-
-			/* including */
-			case ADDRMAP_TOKEN_INCLUDE:
-				map_detokenize(memdata, map, driver, devconfig, TOKEN_GET_PTR(tokens, tokenptr));
-				for (entryptr = &map->entrylist; *entryptr != NULL; entryptr = &(*entryptr)->next) ;
-				entry = NULL;
-				break;
-
-			/* global flags */
-			case ADDRMAP_TOKEN_GLOBAL_MASK:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, tmap.globalmask, 32);
-				check_map(globalmask);
-				map->globalmask = tmap.globalmask;
-				break;
-
-			case ADDRMAP_TOKEN_UNMAP_VALUE:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, tmap.unmapval, 1);
-				check_map(unmapval);
-				map->unmapval = tmap.unmapval;
-				break;
-
-			/* start a new range */
-			case ADDRMAP_TOKEN_RANGE:
-				entry = *entryptr = global_alloc_clear(address_map_entry);
-				entryptr = &entry->next;
-				TOKEN_GET_UINT64_UNPACK2(tokens, entry->addrstart, 32, entry->addrend, 32);
-				break;
-
-			case ADDRMAP_TOKEN_MASK:
-				check_entry_field(addrmask);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, entry->addrmask, 32);
-				break;
-
-			case ADDRMAP_TOKEN_MIRROR:
-				check_entry_field(addrmirror);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, entry->addrmirror, 32);
-				if (entry->addrmirror != 0)
-				{
-					entry->addrstart &= ~entry->addrmirror;
-					entry->addrend &= ~entry->addrmirror;
-				}
-				break;
-
-			case ADDRMAP_TOKEN_READ:
-				check_entry_handler(read);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK4(tokens, entrytype, 8, maptype, 8, entry->read.bits, 8, entry->read.mask, 8);
-				entry->read.type = (map_handler_type)maptype;
-				if (entry->read.type == AMH_HANDLER || entry->read.type == AMH_DEVICE_HANDLER)
-				{
-					entry->read.handler.read = TOKEN_GET_PTR(tokens, read);
-					entry->read.name = TOKEN_GET_STRING(tokens);
-				}
-				if (entry->read.type == AMH_DEVICE_HANDLER || entry->read.type == AMH_PORT || entry->read.type == AMH_BANK)
-					entry->read.tag = devconfig->siblingtag(entry->read.derived_tag, TOKEN_GET_STRING(tokens));
-				break;
-
-			case ADDRMAP_TOKEN_WRITE:
-				check_entry_handler(write);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK4(tokens, entrytype, 8, maptype, 8, entry->write.bits, 8, entry->write.mask, 8);
-				entry->write.type = (map_handler_type)maptype;
-				if (entry->write.type == AMH_HANDLER || entry->write.type == AMH_DEVICE_HANDLER)
-				{
-					entry->write.handler.write = TOKEN_GET_PTR(tokens, write);
-					entry->write.name = TOKEN_GET_STRING(tokens);
-				}
-				if (entry->write.type == AMH_DEVICE_HANDLER || entry->write.type == AMH_PORT || entry->write.type == AMH_BANK)
-					entry->write.tag = devconfig->siblingtag(entry->write.derived_tag, TOKEN_GET_STRING(tokens));
-				break;
-
-			case ADDRMAP_TOKEN_READWRITE:
-				check_entry_handler(read);
-				check_entry_handler(write);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK4(tokens, entrytype, 8, maptype, 8, entry->read.bits, 8, entry->read.mask, 8);
-				entry->write.type = entry->read.type = (map_handler_type)maptype;
-				entry->write.bits = entry->read.bits;
-				entry->write.mask = entry->read.mask;
-				if (entry->read.type == AMH_HANDLER || entry->read.type == AMH_DEVICE_HANDLER)
-				{
-					entry->read.handler.read = TOKEN_GET_PTR(tokens, read);
-					entry->read.name = TOKEN_GET_STRING(tokens);
-					entry->write.handler.write = TOKEN_GET_PTR(tokens, write);
-					entry->write.name = TOKEN_GET_STRING(tokens);
-				}
-				if (entry->read.type == AMH_DEVICE_HANDLER || entry->read.type == AMH_PORT || entry->read.type == AMH_BANK)
-				{
-					const char *basetag = TOKEN_GET_STRING(tokens);
-					entry->read.tag = devconfig->siblingtag(entry->read.derived_tag, basetag);
-					entry->write.tag = devconfig->siblingtag(entry->write.derived_tag, basetag);
-				}
-				break;
-
-			case ADDRMAP_TOKEN_REGION:
-				check_entry_field(region);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, entry->rgnoffs, 32);
-				entry->region = devconfig->siblingtag(entry->region_string, TOKEN_GET_STRING(tokens));
-				break;
-
-			case ADDRMAP_TOKEN_SHARE:
-				check_entry_field(share);
-				entry->share = TOKEN_GET_STRING(tokens);
-				if (memdata != NULL)
-					memdata->sharemap.add(entry->share, UNMAPPED_SHARE_PTR, FALSE);
-				break;
-
-			case ADDRMAP_TOKEN_BASEPTR:
-				check_entry_field(baseptr);
-				entry->baseptr = (void **)TOKEN_GET_PTR(tokens, voidptr);
-				break;
-
-			case ADDRMAP_TOKEN_BASE_MEMBER:
-				check_entry_field(baseptroffs_plus1);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, entry->baseptroffs_plus1, 24);
-				entry->baseptroffs_plus1++;
-				break;
-
-			case ADDRMAP_TOKEN_BASE_GENERIC:
-				check_entry_field(genbaseptroffs_plus1);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, entry->genbaseptroffs_plus1, 24);
-				entry->genbaseptroffs_plus1++;
-				break;
-
-			case ADDRMAP_TOKEN_SIZEPTR:
-				check_entry_field(sizeptr);
-				entry->sizeptr = TOKEN_GET_PTR(tokens, sizeptr);
-				break;
-
-			case ADDRMAP_TOKEN_SIZE_MEMBER:
-				check_entry_field(sizeptroffs_plus1);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, entry->sizeptroffs_plus1, 24);
-				entry->sizeptroffs_plus1++;
-				break;
-
-			case ADDRMAP_TOKEN_SIZE_GENERIC:
-				check_entry_field(gensizeptroffs_plus1);
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, entry->gensizeptroffs_plus1, 24);
-				entry->gensizeptroffs_plus1++;
-				break;
-
-			default:
-				fatalerror("Invalid token %d in address map\n", entrytype);
-				break;
-		}
-	}
-
-	/* post-process to apply the global mask */
-	if (map->globalmask != 0)
-		for (entry = map->entrylist; entry != NULL; entry = entry->next)
-		{
-			entry->addrstart &= map->globalmask;
-			entry->addrend &= map->globalmask;
-			entry->addrmask &= map->globalmask;
-		}
-}
-
-#endif
diff -Nru src-old/emu/addrmap.h src/emu/addrmap.h
--- src-old/emu/addrmap.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/addrmap.h	2010-08-30 08:20:58.000000000 -0700
@@ -60,8 +60,10 @@
 	AMH_ROM,
 	AMH_NOP,
 	AMH_UNMAP,
-	AMH_HANDLER,
-	AMH_DEVICE_HANDLER,
+	AMH_DRIVER_DELEGATE,
+	AMH_DEVICE_DELEGATE,
+	AMH_LEGACY_SPACE_HANDLER,
+	AMH_LEGACY_DEVICE_HANDLER,
 	AMH_PORT,
 	AMH_BANK
 };
@@ -72,67 +74,25 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-// address map constructors are functions generated by tokens
-typedef void (*address_map_constructor)(address_map &map, const device_config &devconfig);
-
-
-// read_handler is a union of all the different read handler types
-union read_handler
-{
-	genf *					generic;			// generic function pointer
-	read8_space_func		shandler8;			// 8-bit space read handler
-	read16_space_func		shandler16;			// 16-bit space read handler
-	read32_space_func		shandler32;			// 32-bit space read handler
-	read64_space_func		shandler64;			// 64-bit space read handler
-	read8_device_func		dhandler8;			// 8-bit device read handler
-	read16_device_func		dhandler16;			// 16-bit device read handler
-	read32_device_func		dhandler32;			// 32-bit device read handler
-	read64_device_func		dhandler64;			// 64-bit device read handler
-};
-
-
-// write_handler is a union of all the different write handler types
-union write_handler
-{
-	genf *					generic;			// generic function pointer
-	write8_space_func		shandler8;			// 8-bit space write handler
-	write16_space_func		shandler16;			// 16-bit space write handler
-	write32_space_func		shandler32;			// 32-bit space write handler
-	write64_space_func		shandler64;			// 64-bit space write handler
-	write8_device_func		dhandler8;			// 8-bit device write handler
-	write16_device_func		dhandler16;			// 16-bit device write handler
-	write32_device_func		dhandler32;			// 32-bit device write handler
-	write64_device_func		dhandler64;			// 64-bit device write handler
-};
-
-
-// memory_handler is a union of all read and write handler types
-union memory_handler
-{
-	genf *					generic;			// generic function pointer
-	read_handler			read;				// read handler union
-	write_handler			write;				// write handler union
-};
-
-
 // address map handler data
 class map_handler_data
 {
 public:
 	map_handler_data()
-		: type(AMH_NONE),
-		  bits(0),
-		  mask(0),
-		  name(NULL),
-		  tag(NULL) { handler.generic = NULL; }
-
-	map_handler_type		type;				// type of the handler
-	UINT8					bits;				// width of the handler in bits, or 0 for default
-	UINT8					mask;				// mask for which lanes apply
-	memory_handler			handler;			// a memory handler
-	const char *			name;				// name of the handler
-	const char *			tag;				// tag pointing to a reference
-	astring					derived_tag;		// string used to hold derived names
+		: m_type(AMH_NONE),
+		  m_bits(0),
+		  m_mask(0),
+		  m_name(NULL),
+		  m_tag(NULL) { }
+
+	map_handler_type		m_type;				// type of the handler
+	UINT8					m_bits;				// width of the handler in bits, or 0 for default
+	UINT64					m_mask;				// mask for which lanes apply
+	const char *			m_name;				// name of the handler
+	const char *			m_tag;				// tag pointing to a reference
+	astring					m_derived_tag;		// string used to hold derived names
+
+	void set_tag(const device_config &devconfig, const char *tag);
 };
 
 
@@ -146,10 +106,13 @@
 	// construction/destruction
 	address_map_entry(address_map &map, offs_t start, offs_t end);
 
+	// getters
+	address_map_entry *next() const { return m_next; }
+
 	// simple inline setters
 	void set_mirror(offs_t _mirror) { m_addrmirror = _mirror; }
-	void set_read_type(map_handler_type _type) { m_read.type = _type; }
-	void set_write_type(map_handler_type _type) { m_write.type = _type; }
+	void set_read_type(map_handler_type _type) { m_read.m_type = _type; }
+	void set_write_type(map_handler_type _type) { m_write.m_type = _type; }
 	void set_region(const char *tag, offs_t offset) { m_region = tag; m_rgnoffs = offset; }
 	void set_share(const char *tag) { m_share = tag; }
 	void set_sizeptr(size_t *_sizeptr) { m_sizeptr = _sizeptr; }
@@ -172,31 +135,59 @@
 	void set_readwrite_bank(const device_config &devconfig, const char *tag);
 
 	// public state
-	address_map_entry *	m_next;					// pointer to the next entry
-	address_map &		m_map;					// reference to our owning map
-	astring				m_region_string;		// string used to hold derived names
-
-	offs_t				m_addrstart;			// start address
-	offs_t				m_addrend;				// end address
-	offs_t				m_addrmirror;			// mirror bits
-	offs_t				m_addrmask;				// mask bits
-	map_handler_data	m_read;					// data for read handler
-	map_handler_data	m_write;				// data for write handler
-	const char *		m_share;				// tag of a shared memory block
-	void **				m_baseptr;				// receives pointer to memory (optional)
-	size_t *			m_sizeptr;				// receives size of area in bytes (optional)
-	UINT32				m_baseptroffs_plus1;	// offset of base pointer within driver_data, plus 1
-	UINT32				m_sizeptroffs_plus1;	// offset of size pointer within driver_data, plus 1
-	UINT32				m_genbaseptroffs_plus1;	// offset of base pointer within generic_pointers, plus 1
-	UINT32				m_gensizeptroffs_plus1;	// offset of size pointer within generic_pointers, plus 1
-	const char *		m_region;				// tag of region containing the memory backing this entry
-	offs_t				m_rgnoffs;				// offset within the region
-
-	void *				m_memory;				// pointer to memory backing this entry
-	offs_t				m_bytestart;			// byte-adjusted start address
-	offs_t				m_byteend;				// byte-adjusted end address
-	offs_t				m_bytemirror;			// byte-adjusted mirror bits
-	offs_t				m_bytemask;				// byte-adjusted mask bits
+	address_map_entry *		m_next;					// pointer to the next entry
+	address_map &			m_map;					// reference to our owning map
+	astring					m_region_string;		// string used to hold derived names
+
+	// basic information
+	offs_t					m_addrstart;			// start address
+	offs_t					m_addrend;				// end address
+	offs_t					m_addrmirror;			// mirror bits
+	offs_t					m_addrmask;				// mask bits
+	map_handler_data		m_read;					// data for read handler
+	map_handler_data		m_write;				// data for write handler
+	const char *			m_share;				// tag of a shared memory block
+	void **					m_baseptr;				// receives pointer to memory (optional)
+	size_t *				m_sizeptr;				// receives size of area in bytes (optional)
+	UINT32					m_baseptroffs_plus1;	// offset of base pointer within driver_data, plus 1
+	UINT32					m_sizeptroffs_plus1;	// offset of size pointer within driver_data, plus 1
+	UINT32					m_genbaseptroffs_plus1;	// offset of base pointer within generic_pointers, plus 1
+	UINT32					m_gensizeptroffs_plus1;	// offset of size pointer within generic_pointers, plus 1
+	const char *			m_region;				// tag of region containing the memory backing this entry
+	offs_t					m_rgnoffs;				// offset within the region
+
+	// handlers
+	read8_proto_delegate	m_rproto8;				// 8-bit read proto-delegate
+	read16_proto_delegate	m_rproto16;				// 16-bit read proto-delegate
+	read32_proto_delegate	m_rproto32;				// 32-bit read proto-delegate
+	read64_proto_delegate	m_rproto64;				// 64-bit read proto-delegate
+	read8_space_func		m_rspace8;				// 8-bit legacy address space handler
+	read16_space_func		m_rspace16;				// 16-bit legacy address space handler
+	read32_space_func		m_rspace32;				// 32-bit legacy address space handler
+	read64_space_func		m_rspace64;				// 64-bit legacy address space handler
+	read8_device_func		m_rdevice8;				// 8-bit legacy device handler
+	read16_device_func		m_rdevice16;			// 16-bit legacy device handler
+	read32_device_func		m_rdevice32;			// 32-bit legacy device handler
+	read64_device_func		m_rdevice64;			// 64-bit legacy device handler
+	write8_proto_delegate	m_wproto8;				// 8-bit write proto-delegate
+	write16_proto_delegate	m_wproto16;				// 16-bit write proto-delegate
+	write32_proto_delegate	m_wproto32;				// 32-bit write proto-delegate
+	write64_proto_delegate	m_wproto64;				// 64-bit write proto-delegate
+	write8_space_func		m_wspace8;				// 8-bit legacy address space handler
+	write16_space_func		m_wspace16;				// 16-bit legacy address space handler
+	write32_space_func		m_wspace32;				// 32-bit legacy address space handler
+	write64_space_func		m_wspace64;				// 64-bit legacy address space handler
+	write8_device_func		m_wdevice8;				// 8-bit legacy device handler
+	write16_device_func		m_wdevice16;			// 16-bit legacy device handler
+	write32_device_func		m_wdevice32;			// 32-bit legacy device handler
+	write64_device_func		m_wdevice64;			// 64-bit legacy device handler
+
+	// information used during processing
+	void *					m_memory;				// pointer to memory backing this entry
+	offs_t					m_bytestart;			// byte-adjusted start address
+	offs_t					m_byteend;				// byte-adjusted end address
+	offs_t					m_bytemirror;			// byte-adjusted mirror bits
+	offs_t					m_bytemask;				// byte-adjusted mask bits
 
 protected:
 	// internal base pointer setting (derived classes provide typed versions)
@@ -205,10 +196,13 @@
 	// internal handler setters for 8-bit functions
 	void internal_set_handler(read8_space_func func, const char *string, UINT64 mask);
 	void internal_set_handler(write8_space_func func, const char *string, UINT64 mask);
-	void internal_set_handler(read8_space_func rfunc, const char *rstring,write8_space_func wfunc,  const char *wstring, UINT64 mask);
+	void internal_set_handler(read8_space_func rfunc, const char *rstring, write8_space_func wfunc,  const char *wstring, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, read8_device_func rfunc, const char *rstring, write8_device_func wfunc, const char *wstring, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc, UINT64 mask);
 
 	// internal handler setters for 16-bit functions
 	void internal_set_handler(read16_space_func func, const char *string, UINT64 mask);
@@ -217,6 +211,9 @@
 	void internal_set_handler(const device_config &devconfig, const char *tag, read16_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, write16_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, read16_device_func rfunc, const char *rstring, write16_device_func wfunc, const char *wstring, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, write16_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate rfunc, write16_proto_delegate wfunc, UINT64 mask);
 
 	// internal handler setters for 32-bit functions
 	void internal_set_handler(read32_space_func func, const char *string, UINT64 mask);
@@ -225,6 +222,9 @@
 	void internal_set_handler(const device_config &devconfig, const char *tag, read32_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, write32_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, read32_device_func rfunc, const char *rstring, write32_device_func wfunc, const char *wstring, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, write32_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate rfunc, write32_proto_delegate wfunc, UINT64 mask);
 
 	// internal handler setters for 64-bit functions
 	void internal_set_handler(read64_space_func func, const char *string, UINT64 mask);
@@ -233,6 +233,9 @@
 	void internal_set_handler(const device_config &devconfig, const char *tag, read64_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, write64_device_func func, const char *string, UINT64 mask);
 	void internal_set_handler(const device_config &devconfig, const char *tag, read64_device_func rfunc, const char *rstring, write64_device_func wfunc, const char *wstring, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, write64_proto_delegate func, UINT64 mask);
+	void internal_set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate rfunc, write64_proto_delegate wfunc, UINT64 mask);
 
 private:
 	// helper functions
@@ -257,6 +260,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func rfunc, const char *rstring, write8_device_func wfunc, const char *wstring) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc) { internal_set_handler(devconfig, tag, rfunc, wfunc, 0); }
 };
 
 
@@ -277,6 +283,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, write16_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func rfunc, const char *rstring, write16_device_func wfunc, const char *wstring) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, write16_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate rfunc, write16_proto_delegate wfunc) { internal_set_handler(devconfig, tag, rfunc, wfunc, 0); }
 
 	// 8-bit handlers
 	void set_handler(read8_space_func func, const char *string, UINT16 mask) { internal_set_handler(func, string, mask); }
@@ -285,6 +294,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string, UINT16 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string, UINT16 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func rfunc, const char *rstring, write8_device_func wfunc, const char *wstring, UINT16 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func, UINT16 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func, UINT16 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc, UINT16 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 };
 
 
@@ -305,6 +317,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read32_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, write32_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, read32_device_func rfunc, const char *rstring, write32_device_func wfunc, const char *wstring) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, write32_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate rfunc, write32_proto_delegate wfunc) { internal_set_handler(devconfig, tag, rfunc, wfunc, 0); }
 
 	// 16-bit handlers
 	void set_handler(read16_space_func func, const char *string, UINT32 mask) { internal_set_handler(func, string, mask); }
@@ -313,6 +328,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func func, const char *string, UINT32 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write16_device_func func, const char *string, UINT32 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func rfunc, const char *rstring, write16_device_func wfunc, const char *wstring, UINT32 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate func, UINT32 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write16_proto_delegate func, UINT32 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate rfunc, write16_proto_delegate wfunc, UINT32 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 
 	// 8-bit handlers
 	void set_handler(read8_space_func func, const char *string, UINT32 mask) { internal_set_handler(func, string, mask); }
@@ -321,6 +339,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string, UINT32 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string, UINT32 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func rfunc, const char *rstring, write8_device_func wfunc, const char *wstring, UINT32 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func, UINT32 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func, UINT32 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc, UINT32 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 };
 
 
@@ -341,6 +362,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read64_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, write64_device_func func, const char *string) { internal_set_handler(devconfig, tag, func, string, 0); }
 	void set_handler(const device_config &devconfig, const char *tag, read64_device_func rfunc, const char *rstring, write64_device_func wfunc, const char *wstring) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, write64_proto_delegate func) { internal_set_handler(devconfig, tag, func, 0); }
+	void set_handler(const device_config &devconfig, const char *tag, read64_proto_delegate rfunc, write64_proto_delegate wfunc) { internal_set_handler(devconfig, tag, rfunc, wfunc, 0); }
 
 	// 32-bit handlers
 	void set_handler(read32_space_func func, const char *string, UINT64 mask) { internal_set_handler(func, string, mask); }
@@ -349,6 +373,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read32_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write32_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read32_device_func rfunc, const char *rstring, write32_device_func wfunc, const char *wstring, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write32_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read32_proto_delegate rfunc, write32_proto_delegate wfunc, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 
 	// 16-bit handlers
 	void set_handler(read16_space_func func, const char *string, UINT64 mask) { internal_set_handler(func, string, mask); }
@@ -357,6 +384,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write16_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read16_device_func rfunc, const char *rstring, write16_device_func wfunc, const char *wstring, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write16_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read16_proto_delegate rfunc, write16_proto_delegate wfunc, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 
 	// 8-bit handlers
 	void set_handler(read8_space_func func, const char *string, UINT64 mask) { internal_set_handler(func, string, mask); }
@@ -365,6 +395,9 @@
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, write8_device_func func, const char *string, UINT64 mask) { internal_set_handler(devconfig, tag, func, string, mask); }
 	void set_handler(const device_config &devconfig, const char *tag, read8_device_func rfunc, const char *rstring, write8_device_func wfunc, const char *wstring, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, rstring, wfunc, wstring, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, write8_proto_delegate func, UINT64 mask) { internal_set_handler(devconfig, tag, func, mask); }
+	void set_handler(const device_config &devconfig, const char *tag, read8_proto_delegate rfunc, write8_proto_delegate wfunc, UINT64 mask) { internal_set_handler(devconfig, tag, rfunc, wfunc, mask); }
 };
 
 
@@ -396,11 +429,7 @@
 	UINT8					m_databits;			// data bits represented by the map
 	UINT8					m_unmapval;			// unmapped memory value
 	offs_t					m_globalmask;		// global mask
-	address_map_entry *		m_entrylist;		// list of entries
-
-private:
-	// internal data
-	address_map_entry **	m_tailptr;
+	simple_list<address_map_entry> m_entrylist;	// list of entries
 };
 
 
@@ -409,16 +438,31 @@
 //  ADDRESS MAP MACROS
 //**************************************************************************
 
+//
+// There are two versions of the macros below
+//
+// By default, the legacy forms are enabled; however, if ADDRESS_MAP_MODERN is #defined
+// prior to including this file, the new format are enabled instead.
+//
+
 // so that "0" can be used for unneeded address maps
 #define construct_address_map_0 NULL
 
 
+#ifndef ADDRESS_MAP_MODERN
+
+//
+// Legacy ADDRESS_MAPs
+//
+
 // start/end tags for the address map
 #define ADDRESS_MAP_NAME(_name) construct_address_map_##_name
 
 #define ADDRESS_MAP_START(_name, _space, _bits) \
 void ADDRESS_MAP_NAME(_name)(address_map &map, const device_config &devconfig) \
 { \
+	typedef read##_bits##_proto_delegate read_proto_delegate; \
+	typedef write##_bits##_proto_delegate write_proto_delegate; \
 	address_map_entry##_bits *curentry = NULL; \
 	(void)curentry; \
 	map.configure(_space, _bits); \
@@ -458,7 +502,7 @@
 	curentry->set_mirror(_mirror); \
 
 
-// space reads
+// legacy space reads
 #define AM_READ(_handler) \
 	curentry->set_handler(_handler, #_handler); \
 
@@ -472,7 +516,7 @@
 	curentry->set_handler(_handler, #_handler, _unitmask); \
 
 
-// space writes
+// legacy space writes
 #define AM_WRITE(_handler) \
 	curentry->set_handler(_handler, #_handler); \
 
@@ -486,7 +530,7 @@
 	curentry->set_handler(_handler, #_handler, _unitmask); \
 
 
-// space reads/writes
+// legacy space reads/writes
 #define AM_READWRITE(_rhandler, _whandler) \
 	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler); \
 
@@ -500,7 +544,7 @@
 	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
 
 
-// device reads
+// legacy device reads
 #define AM_DEVREAD(_tag, _handler) \
 	curentry->set_handler(devconfig, _tag, _handler, #_handler); \
 
@@ -514,7 +558,7 @@
 	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
 
 
-// device writes
+// legacy device writes
 #define AM_DEVWRITE(_tag, _handler) \
 	curentry->set_handler(devconfig, _tag, _handler, #_handler); \
 
@@ -528,7 +572,7 @@
 	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
 
 
-// device reads/writes
+// legacy device reads/writes
 #define AM_DEVREADWRITE(_tag, _rhandler, _whandler) \
 	curentry->set_handler(devconfig, _tag, _rhandler, #_rhandler, _whandler, #_whandler); \
 
@@ -625,11 +669,334 @@
 #define AM_RAMBANK(_bank)					AM_READWRITE_BANK(_bank)
 #define AM_RAM_READ(_read)					AM_READ(_read) AM_WRITEONLY
 #define AM_RAM_WRITE(_write)				AM_READONLY AM_WRITE(_write)
-#define AM_RAM_DEVREAD(_tag, _read)			AM_DEVREAD(_tag, _read) AM_WRITEONLY
+#define AM_RAM_DEVREAD(_tag, _read) 		AM_DEVREAD(_tag, _read) AM_WRITEONLY
 #define AM_RAM_DEVWRITE(_tag, _write)		AM_READONLY AM_DEVWRITE(_tag, _write)
 
 #define AM_BASE_SIZE_MEMBER(_struct, _base, _size)	AM_BASE_MEMBER(_struct, _base) AM_SIZE_MEMBER(_struct, _size)
 #define AM_BASE_SIZE_GENERIC(_member)		AM_BASE_GENERIC(_member) AM_SIZE_GENERIC(_member)
 
 
+#else
+
+//
+// Modern ADDRESS_MAPs
+//
+
+// start/end tags for the address map
+#define ADDRESS_MAP_NAME(_name) construct_address_map_##_name
+
+#define ADDRESS_MAP_START(_name, _space, _bits, _class) \
+void ADDRESS_MAP_NAME(_name)(address_map &map, const device_config &devconfig) \
+{ \
+	typedef read##_bits##_proto_delegate read_proto_delegate; \
+	typedef write##_bits##_proto_delegate write_proto_delegate; \
+	address_map_entry##_bits *curentry = NULL; \
+	(void)curentry; \
+	map.configure(_space, _bits); \
+	typedef _class drivdata_class; \
+
+#define ADDRESS_MAP_END \
+}
+
+// use this to declare external references to an address map
+#define ADDRESS_MAP_EXTERN(_name, _bits) \
+	extern void ADDRESS_MAP_NAME(_name)(address_map &map, const device_config &devconfig)
+
+
+// global controls
+#define ADDRESS_MAP_GLOBAL_MASK(_mask) \
+	map.set_global_mask(_mask); \
+
+#define ADDRESS_MAP_UNMAP_LOW \
+	map.set_unmap_value(0); \
+
+#define ADDRESS_MAP_UNMAP_HIGH \
+	map.set_unmap_value(~0); \
+
+
+// importing data from other address maps
+#define AM_IMPORT_FROM(_name) \
+	ADDRESS_MAP_NAME(_name)(map, devconfig); \
+
+
+// address ranges
+#define AM_RANGE(_start, _end) \
+	curentry = map.add(_start, _end, curentry); \
+
+#define AM_MASK(_mask) \
+	curentry->set_mask(_mask); \
+
+#define AM_MIRROR(_mirror) \
+	curentry->set_mirror(_mirror); \
+
+
+// legacy space reads
+#define AM_READ_LEGACY(_handler) \
+	curentry->set_handler(_handler, #_handler); \
+
+#define AM_READ8_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+#define AM_READ16_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+#define AM_READ32_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+
+// legacy space writes
+#define AM_WRITE_LEGACY(_handler) \
+	curentry->set_handler(_handler, #_handler); \
+
+#define AM_WRITE8_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+#define AM_WRITE16_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+#define AM_WRITE32_LEGACY(_handler, _unitmask) \
+	curentry->set_handler(_handler, #_handler, _unitmask); \
+
+
+// legacy space reads/writes
+#define AM_READWRITE_LEGACY(_rhandler, _whandler) \
+	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler); \
+
+#define AM_READWRITE8_LEGACY(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+#define AM_READWRITE16_LEGACY(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+#define AM_READWRITE32_LEGACY(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(_rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+
+// legacy device reads
+#define AM_DEVREAD_LEGACY(_tag, _handler) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler); \
+
+#define AM_DEVREAD8_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+#define AM_DEVREAD16_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+#define AM_DEVREAD32_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+
+// legacy device writes
+#define AM_DEVWRITE_LEGACY(_tag, _handler) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler); \
+
+#define AM_DEVWRITE8_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+#define AM_DEVWRITE16_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+#define AM_DEVWRITE32_LEGACY(_tag, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _handler, #_handler, _unitmask); \
+
+
+// legacy device reads/writes
+#define AM_DEVREADWRITE_LEGACY(_tag, _rhandler, _whandler) \
+	curentry->set_handler(devconfig, _tag, _rhandler, #_rhandler, _whandler, #_whandler); \
+
+#define AM_DEVREADWRITE8_LEGACY(_tag, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+#define AM_DEVREADWRITE16_LEGACY(_tag, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+#define AM_DEVREADWRITE32_LEGACY(_tag, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, _rhandler, #_rhandler, _whandler, #_whandler, _unitmask); \
+
+
+// driver data reads
+#define AM_READ(_handler) \
+	curentry->set_handler(devconfig, NULL, read_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler)); \
+
+#define AM_READ8(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read8_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+#define AM_READ16(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read16_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+#define AM_READ32(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read32_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+
+// driver data writes
+#define AM_WRITE(_handler) \
+	curentry->set_handler(devconfig, NULL, write_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler)); \
+
+#define AM_WRITE8(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, write8_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+#define AM_WRITE16(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, write16_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+#define AM_WRITE32(_handler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, write32_proto_delegate::_create_member<drivdata_class, &drivdata_class::_handler>("driver_data::" #_handler), _unitmask); \
+
+
+// driver data reads/writes
+#define AM_READWRITE(_rhandler, _whandler) \
+	curentry->set_handler(devconfig, NULL, read_proto_delegate::_create_member<drivdata_class, &drivdata_class::_rhandler>("driver_data::" #_rhandler), write_proto_delegate::_create_member<drivdata_class, &drivdata_class::_whandler>("driver_data::" #_whandler)); \
+
+#define AM_READWRITE8(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read8_proto_delegate::_create_member<drivdata_class, &drivdata_class::_rhandler>("driver_data::" #_rhandler), write8_proto_delegate::_create_member<drivdata_class, &drivdata_class::_whandler>("driver_data::" #_whandler), _unitmask); \
+
+#define AM_READWRITE16(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read16_proto_delegate::_create_member<drivdata_class, &drivdata_class::_rhandler>("driver_data::" #_rhandler), write16_proto_delegate::_create_member<drivdata_class, &drivdata_class::_whandler>("driver_data::" #_whandler), _unitmask); \
+
+#define AM_READWRITE32(_rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, NULL, read32_proto_delegate::_create_member<drivdata_class, &drivdata_class::_rhandler>("driver_data::" #_rhandler), write32_proto_delegate::_create_member<drivdata_class, &drivdata_class::_whandler>("driver_data::" #_whandler), _unitmask); \
+
+
+// device reads
+#define AM_DEVREAD(_tag, _class, _handler) \
+	curentry->set_handler(devconfig, _tag, read_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler)); \
+
+#define AM_DEVREAD8(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read8_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+#define AM_DEVREAD16(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read16_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+#define AM_DEVREAD32(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read32_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+
+// device writes
+#define AM_DEVWRITE(_tag, _class, _handler) \
+	curentry->set_handler(devconfig, _tag, write_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler)); \
+
+#define AM_DEVWRITE8(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, write8_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+#define AM_DEVWRITE16(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, write16_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+#define AM_DEVWRITE32(_tag, _class, _handler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, write32_proto_delegate::_create_member<_class, &_class::_handler>(#_class "::" #_handler), _unitmask); \
+
+
+// device reads/writes
+#define AM_DEVREADWRITE(_tag, _class, _rhandler, _whandler) \
+	curentry->set_handler(devconfig, _tag, read_proto_delegate::_create_member<_class, &_class::_rhandler>(#_class "::" #_rhandler), write_proto_delegate::_create_member<_class, &_class::_whandler>(#_class "::" #_whandler)); \
+
+#define AM_DEVREADWRITE8(_tag, _class, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read8_proto_delegate::_create_member<_class, &_class::_rhandler>(#_class "::" #_rhandler), write8_proto_delegate::_create_member<_class, &_class::_whandler>(#_class "::" #_whandler), _unitmask); \
+
+#define AM_DEVREADWRITE16(_tag, _class, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read16_proto_delegate::_create_member<_class, &_class::_rhandler>(#_class "::" #_rhandler), write16_proto_delegate::_create_member<_class, &_class::_whandler>(#_class "::" #_whandler), _unitmask); \
+
+#define AM_DEVREADWRITE32(_tag, _class, _rhandler, _whandler, _unitmask) \
+	curentry->set_handler(devconfig, _tag, read32_proto_delegate::_create_member<_class, &_class::_rhandler>(#_class "::" #_rhandler), write32_proto_delegate::_create_member<_class, &_class::_whandler>(#_class "::" #_whandler), _unitmask); \
+
+
+// special-case accesses
+#define AM_ROM \
+	curentry->set_read_type(AMH_ROM); \
+
+#define AM_RAM \
+	curentry->set_read_type(AMH_RAM); \
+	curentry->set_write_type(AMH_RAM); \
+
+#define AM_READONLY \
+	curentry->set_read_type(AMH_RAM); \
+
+#define AM_WRITEONLY \
+	curentry->set_write_type(AMH_RAM); \
+
+#define AM_UNMAP \
+	curentry->set_read_type(AMH_UNMAP); \
+	curentry->set_write_type(AMH_UNMAP); \
+
+#define AM_NOP \
+	curentry->set_read_type(AMH_NOP); \
+	curentry->set_write_type(AMH_NOP); \
+
+#define AM_READNOP \
+	curentry->set_read_type(AMH_NOP); \
+
+#define AM_WRITENOP \
+	curentry->set_write_type(AMH_NOP); \
+
+
+// port accesses
+#define AM_READ_PORT(_tag) \
+	curentry->set_read_port(devconfig, _tag); \
+
+#define AM_WRITE_PORT(_tag) \
+	curentry->set_write_port(devconfig, _tag); \
+
+#define AM_READWRITE_PORT(_tag) \
+	curentry->set_readwrite_port(devconfig, _tag); \
+
+
+// bank accesses
+#define AM_READ_BANK(_tag) \
+	curentry->set_read_bank(devconfig, _tag); \
+
+#define AM_WRITE_BANK(_tag) \
+	curentry->set_write_bank(devconfig, _tag); \
+
+#define AM_READWRITE_BANK(_tag) \
+	curentry->set_readwrite_bank(devconfig, _tag); \
+
+
+// attributes for accesses
+#define AM_REGION(_tag, _offs) \
+	curentry->set_region(_tag, _offs); \
+
+#define AM_SHARE(_tag) \
+	curentry->set_share(_tag); \
+
+#define AM_BASE_LEGACY(_base) \
+	curentry->set_baseptr(_base); \
+
+#define myoffsetof(_struct, _member)  ((FPTR)&((_struct *)0x1000)->_member - 0x1000)
+#define AM_BASE(_member) \
+	curentry->set_member_baseptr(myoffsetof(drivdata_class, _member)); \
+
+#define AM_BASE_GENERIC(_member) \
+	curentry->set_generic_baseptr(myoffsetof(generic_pointers, _member)); \
+
+#define AM_SIZE_LEGACY(_size) \
+	curentry->set_sizeptr(_size); \
+
+#define AM_SIZE(_struct, _member) \
+	curentry->set_member_sizeptr(myoffsetof(drivdata_class, _member)); \
+
+#define AM_SIZE_GENERIC(_member) \
+	curentry->set_generic_sizeptr(myoffsetof(generic_pointers, _member##_size)); \
+
+
+// common shortcuts
+#define AM_ROMBANK(_bank)					AM_READ_BANK(_bank)
+#define AM_RAMBANK(_bank)					AM_READWRITE_BANK(_bank)
+#define AM_RAM_READ(_read)					AM_READ(_read) AM_WRITEONLY
+#define AM_RAM_WRITE(_write)				AM_READONLY AM_WRITE(_write)
+#define AM_RAM_DEVREAD(_tag, _class, _read) AM_DEVREAD(_tag, _class, _read) AM_WRITEONLY
+#define AM_RAM_DEVWRITE(_tag, _class, _write) AM_READONLY AM_DEVWRITE(_tag, _class, _write)
+
+#define AM_BASE_SIZE(_base, _size)			AM_BASE_MEMBER(_base) AM_SIZE_MEMBER(_size)
+#define AM_BASE_SIZE_GENERIC(_member)		AM_BASE_GENERIC(_member) AM_SIZE_GENERIC(_member)
+
+#endif
+
+
+
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
+
+// use this to refer to the owning device when providing a device tag
+static const char DEVICE_SELF[] = "";
+
+
 #endif	/* __ADDRMAP_H__ */
diff -Nru src-old/emu/audio/generic.c src/emu/audio/generic.c
--- src-old/emu/audio/generic.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/audio/generic.c	2010-08-19 00:26:14.000000000 -0700
@@ -85,7 +85,7 @@
     latch_w - handle a write to a given latch
 -------------------------------------------------*/
 
-INLINE void latch_w(const address_space *space, int which, UINT16 value)
+INLINE void latch_w(address_space *space, int which, UINT16 value)
 {
 	timer_call_after_resynch(space->machine, NULL, which | (value << 8), latch_callback);
 }
@@ -95,7 +95,7 @@
     latch_r - handle a read from a given latch
 -------------------------------------------------*/
 
-INLINE UINT16 latch_r(const address_space *space, int which)
+INLINE UINT16 latch_r(address_space *space, int which)
 {
 	generic_audio_private *state = space->machine->generic_audio_data;
 	state->latch_read[which] = 1;
@@ -107,7 +107,7 @@
     latch_clear - clear a given latch
 -------------------------------------------------*/
 
-INLINE void latch_clear(const address_space *space, int which)
+INLINE void latch_clear(address_space *space, int which)
 {
 	generic_audio_private *state = space->machine->generic_audio_data;
 	state->latched_value[which] = state->latch_clear_value;
diff -Nru src-old/emu/cheat.c src/emu/cheat.c
--- src-old/emu/cheat.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/cheat.c	2010-08-21 12:23:48.000000000 -0700
@@ -411,22 +411,20 @@
        and MAME will load gamename.xml */
 	device_image_interface *image = NULL;
 	for (bool gotone = machine->m_devicelist.first(image); gotone; gotone = image->next(image))
-	{
 		if (image->exists())
 		{
-			char mess_cheat_filename[9];
-			UINT32	crc = image->crc();
-			sprintf(mess_cheat_filename, "%08X", crc);
-			if (crc!=0) {
-				cheatinfo->cheatlist = cheat_list_load(machine, mess_cheat_filename);
+			UINT32 crc = image->crc();
+			if (crc != 0)
+			{
+				astring filename;
+				filename.printf("%08X", crc);
+				cheatinfo->cheatlist = cheat_list_load(machine, filename);
 				break;
 			}
 		}
-	}
+
 	if (cheatinfo->cheatlist == NULL)
-	{
 		cheatinfo->cheatlist = cheat_list_load(machine, machine->basename());
-	}
 
 	/* temporary: save the file back out as output.xml for comparison */
 	if (cheatinfo->cheatlist != NULL)
@@ -458,9 +456,7 @@
 	cheat_private *cheatinfo = machine->cheat_data;
 
 	if (cheatinfo != NULL)
-	{
 		return !cheatinfo->disabled;
-	}
 
 	return 0;
 }
@@ -522,7 +518,7 @@
 
 		/* render any text and free it along the way */
 		for (linenum = 0; linenum < ARRAY_LENGTH(cheatinfo->output); linenum++)
-			if (cheatinfo->output[linenum].len() != 0)
+			if (cheatinfo->output[linenum])
 			{
 				/* output the text */
 				ui_draw_text_full(container, cheatinfo->output[linenum],
@@ -960,7 +956,7 @@
 		}
 
 		/* if there is a string to display, compute it */
-		if (entry->format.len() != 0)
+		if (entry->format)
 		{
 			UINT64 params[MAX_ARGUMENTS];
 			output_argument *arg;
@@ -1077,7 +1073,7 @@
 			scannode = NULL;
 			if (REMOVE_DUPLICATE_CHEATS)
 				for (scannode = cheatlist; scannode != NULL; scannode = scannode->next)
-					if (scannode->description.cmp(curcheat->description) == 0)
+					if (scannode->description == curcheat->description)
 					{
 						mame_printf_verbose("Ignoring duplicate cheat '%s' from file %s\n", curcheat->description.cstr(), mame_file_full_name(cheatfile).cstr());
 						break;
@@ -1193,7 +1189,7 @@
 		mame_printf_error("%s.xml(%d): empty or missing desc attribute on cheat\n", filename, cheatnode->line);
 		return NULL;
 	}
-	cheat->description.cpy(description);
+	cheat->description = description;
 
 	/* create the symbol table */
 	cheat->symbols = symtable_alloc(NULL, machine);
@@ -1213,7 +1209,7 @@
 	if (commentnode != NULL)
 	{
 		if (commentnode->value != NULL && commentnode->value[0] != 0)
-			cheat->comment.cpy(commentnode->value);
+			cheat->comment = commentnode->value;
 
 		/* only one comment is kept */
 		commentnode = xml_get_sibling(commentnode->next, "comment");
@@ -1287,14 +1283,14 @@
 	mame_fprintf(cheatfile, "\t<cheat desc=\"%s\"", cheat->description.cstr());
 	if (cheat->numtemp != DEFAULT_TEMP_VARIABLES)
 		mame_fprintf(cheatfile, " tempvariables=\"%d\"", cheat->numtemp);
-	if (cheat->comment.len() == 0 && cheat->parameter == NULL && scriptcount == 0)
+	if (!cheat->comment && cheat->parameter == NULL && scriptcount == 0)
 		mame_fprintf(cheatfile, " />\n");
 	else
 	{
 		mame_fprintf(cheatfile, ">\n");
 
 		/* save the comment */
-		if (cheat->comment.len() != 0)
+		if (cheat->comment)
 			mame_fprintf(cheatfile, "\t\t<comment><![CDATA[\n%s\n\t\t]]></comment>\n", cheat->comment.cstr());
 
 		/* output the parameter, if present */
@@ -1708,7 +1704,7 @@
 	astring tempstring;
 
 	/* output an action */
-	if (entry->format == NULL)
+	if (!entry->format)
 	{
 		mame_fprintf(cheatfile, "\t\t\t<action");
 		if (entry->condition != NULL)
diff -Nru src-old/emu/cpu/adsp2100/2100dasm.c src/emu/cpu/adsp2100/2100dasm.c
--- src-old/emu/cpu/adsp2100/2100dasm.c	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/cpu/adsp2100/2100dasm.c	2010-08-16 18:00:44.000000000 -0700
@@ -10,7 +10,7 @@
 
 static const char *const mac_xop[] = { "MX0", "MX1", "AR", "MR0", "MR1", "MR2", "SR0", "SR1" };
 static const char *const mac_yop[] = { "MY0", "MY1", "MF", "0" };
-static const char *const mac_dst[] = { "MR", "MF" };
+static const char *const mac_dst[] = { "MR", "MF", "NONE" };
 
 static const char *const shift_xop[] = { "SI", "??", "AR", "MR0", "MR1", "MR2", "SR0", "SR1" };
 
diff -Nru src-old/emu/cpu/adsp2100/adsp2100.c src/emu/cpu/adsp2100/adsp2100.c
--- src-old/emu/cpu/adsp2100/adsp2100.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/adsp2100/adsp2100.c	2010-08-19 09:10:19.000000000 -0700
@@ -263,9 +263,10 @@
 	adsp21xx_timer_func timer_fired;
 
 	/* memory spaces */
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
 } adsp2100_state;
 
@@ -318,35 +319,35 @@
 
 INLINE UINT16 RWORD_DATA(adsp2100_state *adsp, UINT32 addr)
 {
-	return memory_read_word_16le(adsp->data, addr << 1);
+	return adsp->data->read_word(addr << 1);
 }
 
 INLINE void WWORD_DATA(adsp2100_state *adsp, UINT32 addr, UINT16 data)
 {
-	memory_write_word_16le(adsp->data, addr << 1, data);
+	adsp->data->write_word(addr << 1, data);
 }
 
 INLINE UINT16 RWORD_IO(adsp2100_state *adsp, UINT32 addr)
 {
-	return memory_read_word_16le(adsp->io, addr << 1);
+	return adsp->io->read_word(addr << 1);
 }
 
 INLINE void WWORD_IO(adsp2100_state *adsp, UINT32 addr, UINT16 data)
 {
-	memory_write_word_16le(adsp->io, addr << 1, data);
+	adsp->io->write_word(addr << 1, data);
 }
 
 INLINE UINT32 RWORD_PGM(adsp2100_state *adsp, UINT32 addr)
 {
-	return memory_read_dword_32le(adsp->program, addr << 2);
+	return adsp->program->read_dword(addr << 2);
 }
 
 INLINE void WWORD_PGM(adsp2100_state *adsp, UINT32 addr, UINT32 data)
 {
-	memory_write_dword_32le(adsp->program, addr << 2, data & 0xffffff);
+	adsp->program->write_dword(addr << 2, data & 0xffffff);
 }
 
-#define ROPCODE(a) memory_decrypted_read_dword((a)->program, (a)->pc << 2)
+#define ROPCODE(a) (a)->direct->read_decrypted_dword((a)->pc << 2)
 
 
 /***************************************************************************
@@ -578,6 +579,7 @@
 	/* fetch device parameters */
 	adsp->device = device;
 	adsp->program = device->space(AS_PROGRAM);
+	adsp->direct = &adsp->program->direct();
 	adsp->data = device->space(AS_DATA);
 	adsp->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/alph8201/alph8201.c src/emu/cpu/alph8201/alph8201.c
--- src-old/emu/cpu/alph8201/alph8201.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/alph8201/alph8201.c	2010-08-19 09:10:19.000000000 -0700
@@ -165,10 +165,10 @@
 /* MAME is unnecessary */
 #define HANDLE_HALT_LINE 0
 
-#define M_RDMEM(A)		memory_read_byte_8le(cpustate->program, A)
-#define M_WRMEM(A,V)	memory_write_byte_8le(cpustate->program, A, V)
-#define M_RDOP(A)		memory_decrypted_read_byte(cpustate->program, A)
-#define M_RDOP_ARG(A)	memory_raw_read_byte(cpustate->program, A)
+#define M_RDMEM(A)		cpustate->program->read_byte(A)
+#define M_WRMEM(A,V)	cpustate->program->write_byte(A, V)
+#define M_RDOP(A)		cpustate->direct->read_decrypted_byte(A)
+#define M_RDOP_ARG(A)	cpustate->direct->read_raw_byte(A)
 
 typedef struct _alpha8201_state alpha8201_state;
 struct _alpha8201_state
@@ -198,7 +198,8 @@
 #endif
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 	int inst_cycles;
 };
@@ -669,6 +670,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	state_save_register_device_item_array(device, 0, cpustate->RAM);
 	state_save_register_device_item(device, 0, cpustate->PREVPC);
diff -Nru src-old/emu/cpu/am29000/am29000.c src/emu/cpu/am29000/am29000.c
--- src-old/emu/cpu/am29000/am29000.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/am29000/am29000.c	2010-08-19 09:10:19.000000000 -0700
@@ -131,9 +131,11 @@
 	UINT32			exec_pc;
 	UINT32			next_pc;
 
-	const address_space *program;
-	const address_space *data;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	direct_read_data *datadirect;
+	address_space *io;
 } am29000_state;
 
 
@@ -153,7 +155,9 @@
 	am29000_state *am29000 = get_safe_token(device);
 
 	am29000->program = device->space(AS_PROGRAM);
+	am29000->direct = &am29000->program->direct();
 	am29000->data = device->space(AS_DATA);
+	am29000->datadirect = &am29000->data->direct();
 	am29000->io = device->space(AS_IO);
 	am29000->cfg = (PRL_AM29000 | PRL_REV_D) << CFG_PRL_SHIFT;
 
@@ -267,7 +271,7 @@
 {
 	/* TODO: ROM enable? */
 	if (state->cps & CPS_PI || state->cps & CPS_RE)
-		return memory_decrypted_read_dword(state->program, address);
+		return state->direct->read_decrypted_dword(address);
 	else
 	{
 		fatalerror("Am29000 instruction MMU translation enabled!");
@@ -414,7 +418,7 @@
 			if (am29000->cfg & CFG_VF)
 			{
 				UINT32 vaddr = am29000->vab | am29000->exception_queue[0] * 4;
-				UINT32 vect = memory_decrypted_read_dword(am29000->data, vaddr);
+				UINT32 vect = am29000->datadirect->read_decrypted_dword(vaddr);
 
 				am29000->pc = vect & ~3;
 				am29000->next_pc = am29000->pc;
diff -Nru src-old/emu/cpu/am29000/am29ops.h src/emu/cpu/am29000/am29ops.h
--- src-old/emu/cpu/am29000/am29ops.h	2010-01-28 01:03:44.000000000 -0800
+++ src/emu/cpu/am29000/am29ops.h	2010-08-19 01:27:05.000000000 -0700
@@ -956,7 +956,7 @@
 				return;
 			}
 
-			r = memory_read_dword_32be(am29000->data, addr);
+			r = am29000->data->read_dword(addr);
 		}
 	}
 
@@ -1020,7 +1020,7 @@
 				return;
 			}
 
-			r = memory_read_dword_32be(am29000->data, addr);
+			r = am29000->data->read_dword(addr);
 		}
 	}
 
@@ -1045,7 +1045,7 @@
 		int cnt;
 		for (cnt = 0; cnt <= GET_CHC_CR; ++cnt)
 		{
-			am29000->r[r] = memory_read_dword_32be(am29000->data, addr);
+			am29000->r[r] = am29000->data->read_dword(addr);
 
 //          SET_CHC_CR(cnt - 1);
 			addr += 4;
@@ -1086,7 +1086,7 @@
 		}
 	}
 
-	memory_write_dword_32be(am29000->data, addr, am29000->r[RA]);
+	am29000->data->write_dword(addr, am29000->r[RA]);
 
 	if (!FREEZE_MODE)
 	{
@@ -1159,7 +1159,7 @@
 		int cnt;
 		for (cnt = 0; cnt <= GET_CHC_CR; ++cnt)
 		{
-			memory_write_dword_32be(am29000->data, addr, am29000->r[r]);
+			am29000->data->write_dword(addr, am29000->r[r]);
 
 //          SET_CHC_CR(cnt - 1);
 			addr += 4;
diff -Nru src-old/emu/cpu/apexc/apexc.c src/emu/cpu/apexc/apexc.c
--- src-old/emu/cpu/apexc/apexc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/apexc/apexc.c	2010-08-19 01:27:05.000000000 -0700
@@ -328,8 +328,8 @@
 #include "apexc.h"
 
 #ifndef SUPPORT_ODD_WORD_SIZES
-#define apexc_readmem(address)	memory_read_dword_32be(cpustate->program, (address)<<2)
-#define apexc_writemem(address, data)	memory_write_dword_32be(cpustate->program, (address)<<2, (data))
+#define apexc_readmem(address)	cpustate->program->read_dword((address)<<2)
+#define apexc_writemem(address, data)	cpustate->program->write_dword((address)<<2, (data))
 /* eewww ! - Fortunately, there is no memory mapped I/O, so we can simulate masked write
 without danger */
 #define apexc_writemem_masked(address, data, mask)										\
@@ -359,8 +359,8 @@
 	UINT32 pc;	/* address of next instruction for the disassembler */
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	address_space *io;
 	int icount;
 };
 
@@ -474,12 +474,12 @@
 
 static int papertape_read(apexc_state *cpustate)
 {
-	return memory_read_byte_8be(cpustate->io, 0) & 0x1f;
+	return cpustate->io->read_byte(0) & 0x1f;
 }
 
 static void papertape_punch(apexc_state *cpustate, int data)
 {
-	memory_write_byte_8be(cpustate->io, 0, data);
+	cpustate->io->write_byte(0, data);
 }
 
 /*
diff -Nru src-old/emu/cpu/arm/arm.c src/emu/cpu/arm/arm.c
--- src-old/emu/cpu/arm/arm.c	2010-07-25 06:42:34.000000000 -0700
+++ src/emu/cpu/arm/arm.c	2010-08-19 09:10:19.000000000 -0700
@@ -236,7 +236,8 @@
 	UINT8 pendingFiq;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	endianness_t endian;
 } ARM_REGS;
 
@@ -263,18 +264,18 @@
 {
 	/* Unaligned writes are treated as normal writes */
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		memory_write_dword_32be(cpustate->program, addr&ADDRESS_MASK,data);
+		cpustate->program->write_dword(addr&ADDRESS_MASK,data);
 	else
-		memory_write_dword_32le(cpustate->program, addr&ADDRESS_MASK,data);
+		cpustate->program->write_dword(addr&ADDRESS_MASK,data);
 	if (ARM_DEBUG_CORE && addr&3) logerror("%08x: Unaligned write %08x\n",R15,addr);
 }
 
 INLINE void cpu_write8( ARM_REGS* cpustate, int addr, UINT8 data )
 {
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		memory_write_byte_32be(cpustate->program,addr,data);
+		cpustate->program->write_byte(addr,data);
 	else
-		memory_write_byte_32le(cpustate->program,addr,data);
+		cpustate->program->write_byte(addr,data);
 }
 
 INLINE UINT32 cpu_read32( ARM_REGS* cpustate, int addr )
@@ -282,9 +283,9 @@
 	UINT32 result;
 
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		result = memory_read_dword_32be(cpustate->program,addr&ADDRESS_MASK);
+		result = cpustate->program->read_dword(addr&ADDRESS_MASK);
 	else
-		result = memory_read_dword_32le(cpustate->program,addr&ADDRESS_MASK);
+		result = cpustate->program->read_dword(addr&ADDRESS_MASK);
 
 	/* Unaligned reads rotate the word, they never combine words */
 	if (addr&3) {
@@ -305,9 +306,9 @@
 INLINE UINT8 cpu_read8( ARM_REGS* cpustate, int addr )
 {
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		return memory_read_byte_32be(cpustate->program, addr);
+		return cpustate->program->read_byte(addr);
 	else
-		return memory_read_byte_32le(cpustate->program, addr);
+		return cpustate->program->read_byte(addr);
 }
 
 INLINE UINT32 GetRegister( ARM_REGS* cpustate, int rIndex )
@@ -334,6 +335,7 @@
 	cpustate->endian = save_endian;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* start up in SVC mode with interrupts disabled. */
 	R15 = eARM_MODE_SVC|I_MASK|F_MASK;
@@ -356,7 +358,7 @@
 
 		/* load instruction */
 		pc = R15;
-		insn = memory_decrypted_read_dword( cpustate->program, pc & ADDRESS_MASK );
+		insn = cpustate->direct->read_decrypted_dword( pc & ADDRESS_MASK );
 
 		switch (insn >> INSN_COND_SHIFT)
 		{
diff -Nru src-old/emu/cpu/arm7/arm7.c src/emu/cpu/arm7/arm7.c
--- src-old/emu/cpu/arm7/arm7.c	2010-07-26 09:02:45.000000000 -0700
+++ src/emu/cpu/arm7/arm7.c	2010-08-19 09:10:19.000000000 -0700
@@ -104,7 +104,7 @@
 INLINE UINT32 arm7_tlb_get_first_level_descriptor( arm_state *cpustate, UINT32 vaddr )
 {
     UINT32 entry_paddr = ( COPRO_TLB_BASE & COPRO_TLB_BASE_MASK ) | ( ( vaddr & COPRO_TLB_VADDR_FLTI_MASK ) >> COPRO_TLB_VADDR_FLTI_MASK_SHIFT );
-    return memory_read_dword_32le( cpustate->program, entry_paddr );
+    return cpustate->program->read_dword( entry_paddr );
 }
 
 INLINE UINT32 arm7_tlb_get_second_level_descriptor( arm_state *cpustate, UINT32 granularity, UINT32 first_desc, UINT32 vaddr )
@@ -125,7 +125,7 @@
             break;
     }
 
-    return memory_read_dword_32le( cpustate->program, desc_lvl2 );
+    return cpustate->program->read_dword( desc_lvl2 );
 }
 
 INLINE UINT32 arm7_tlb_translate(arm_state *cpustate, UINT32 vaddr)
@@ -216,6 +216,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	// setup co-proc callbacks
 	arm7_coproc_do_callback = arm7_do_callback;
diff -Nru src-old/emu/cpu/arm7/arm7core.c src/emu/cpu/arm7/arm7core.c
--- src-old/emu/cpu/arm7/arm7core.c	2010-07-26 09:02:45.000000000 -0700
+++ src/emu/cpu/arm7/arm7core.c	2010-08-20 10:29:10.000000000 -0700
@@ -136,9 +136,9 @@
 
     addr &= ~3;
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		memory_write_dword_32be(cpustate->program, addr, data);
+		cpustate->program->write_dword(addr, data);
 	else
-	    memory_write_dword_32le(cpustate->program, addr, data);
+	    cpustate->program->write_dword(addr, data);
 }
 
 
@@ -151,9 +151,9 @@
 
     addr &= ~1;
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		memory_write_word_32be(cpustate->program, addr, data);
+		cpustate->program->write_word(addr, data);
 	else
-		memory_write_word_32le(cpustate->program, addr, data);
+		cpustate->program->write_word(addr, data);
 }
 
 INLINE void arm7_cpu_write8(arm_state *cpustate, UINT32 addr, UINT8 data)
@@ -164,9 +164,9 @@
     }
 
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		memory_write_byte_32be(cpustate->program, addr, data);
+		cpustate->program->write_byte(addr, data);
 	else
-		memory_write_byte_32le(cpustate->program, addr, data);
+		cpustate->program->write_byte(addr, data);
 }
 
 INLINE UINT32 arm7_cpu_read32(arm_state *cpustate, offs_t addr)
@@ -181,17 +181,17 @@
     if (addr & 3)
     {
 		if ( cpustate->endian == ENDIANNESS_BIG )
-			result = memory_read_dword_32be(cpustate->program, addr & ~3);
+			result = cpustate->program->read_dword(addr & ~3);
 		else
-			result = memory_read_dword_32le(cpustate->program, addr & ~3);
+			result = cpustate->program->read_dword(addr & ~3);
         result = (result >> (8 * (addr & 3))) | (result << (32 - (8 * (addr & 3))));
     }
     else
     {
 		if ( cpustate->endian == ENDIANNESS_BIG )
-			result = memory_read_dword_32be(cpustate->program, addr);
+			result = cpustate->program->read_dword(addr);
 		else
-			result = memory_read_dword_32le(cpustate->program, addr);
+			result = cpustate->program->read_dword(addr);
     }
 
     return result;
@@ -207,9 +207,9 @@
     }
 
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		result = memory_read_word_32be(cpustate->program, addr & ~1);
+		result = cpustate->program->read_word(addr & ~1);
 	else
-		result = memory_read_word_32le(cpustate->program, addr & ~1);
+		result = cpustate->program->read_word(addr & ~1);
 
     if (addr & 1)
     {
@@ -228,9 +228,9 @@
 
     // Handle through normal 8 bit handler (for 32 bit cpu)
 	if ( cpustate->endian == ENDIANNESS_BIG )
-		return memory_read_byte_32be(cpustate->program, addr);
+		return cpustate->program->read_byte(addr);
 	else
-		return memory_read_byte_32le(cpustate->program, addr);
+		return cpustate->program->read_byte(addr);
 }
 
 /***************
@@ -575,6 +575,7 @@
     cpustate->device = device;
     cpustate->program = device->space(AS_PROGRAM);
 	cpustate->endian = ENDIANNESS_LITTLE;
+	cpustate->direct = &cpustate->program->direct();
 
     /* start up in SVC mode with interrupts disabled. */
     SwitchMode(cpustate, eARM7_MODE_SVC);
diff -Nru src-old/emu/cpu/arm7/arm7core.h src/emu/cpu/arm7/arm7core.h
--- src-old/emu/cpu/arm7/arm7core.h	2010-07-26 09:02:45.000000000 -0700
+++ src/emu/cpu/arm7/arm7core.h	2010-08-19 09:10:19.000000000 -0700
@@ -163,7 +163,8 @@
 	endianness_t endian;				\
     device_irq_callback irq_callback;		\
     legacy_cpu_device *device;		\
-    const address_space *program;
+    address_space *program;			\
+    direct_read_data *direct;
 
 
 /* CPU state struct */
diff -Nru src-old/emu/cpu/arm7/arm7exec.c src/emu/cpu/arm7/arm7exec.c
--- src-old/emu/cpu/arm7/arm7exec.c	2010-06-09 09:20:50.000000000 -0700
+++ src/emu/cpu/arm7/arm7exec.c	2010-08-19 09:10:19.000000000 -0700
@@ -62,7 +62,7 @@
 	    {
 	    	raddr = arm7_tlb_translate(cpustate, raddr);
 	    }
-            insn = memory_decrypted_read_word(cpustate->program, raddr);
+            insn = cpustate->direct->read_decrypted_word(raddr);
             ARM7_ICOUNT -= (3 - thumbCycles[insn >> 8]);
             switch ((insn & THUMB_INSN_TYPE) >> THUMB_INSN_TYPE_SHIFT)
             {
@@ -1172,7 +1172,7 @@
 	    {
 	    	pc = arm7_tlb_translate(cpustate, pc);
 	    }
-            insn = memory_decrypted_read_dword(cpustate->program, pc);
+            insn = cpustate->direct->read_decrypted_dword(pc);
 
             /* process condition codes for this instruction */
             switch (insn >> INSN_COND_SHIFT)
diff -Nru src-old/emu/cpu/asap/asap.c src/emu/cpu/asap/asap.c
--- src-old/emu/cpu/asap/asap.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/asap/asap.c	2010-08-19 09:10:19.000000000 -0700
@@ -86,7 +86,8 @@
 	UINT8		irq_state;
 	int			icount;
 	device_irq_callback irq_callback;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	legacy_cpu_device *device;
 
 	/* src2val table, registers are at the end */
@@ -281,39 +282,39 @@
     MEMORY ACCESSORS
 ***************************************************************************/
 
-#define ROPCODE(A,pc)	memory_decrypted_read_dword((A)->program, pc)
+#define ROPCODE(A,pc)	(A)->direct->read_decrypted_dword(pc)
 
 
 INLINE UINT8 READBYTE(asap_state *asap, offs_t address)
 {
 	/* no alignment issues with bytes */
-	return memory_read_byte_32le(asap->program, address);
+	return asap->program->read_byte(address);
 }
 
 INLINE UINT16 READWORD(asap_state *asap, offs_t address)
 {
 	/* aligned reads are easy */
 	if (!(address & 1))
-		return memory_read_word_32le(asap->program, address);
+		return asap->program->read_word(address);
 
 	/* misaligned reads are tricky */
-	return memory_read_dword_32le(asap->program, address & ~3) >> (address & 3);
+	return asap->program->read_dword(address & ~3) >> (address & 3);
 }
 
 INLINE UINT32 READLONG(asap_state *asap, offs_t address)
 {
 	/* aligned reads are easy */
 	if (!(address & 3))
-		return memory_read_dword_32le(asap->program, address);
+		return asap->program->read_dword(address);
 
 	/* misaligned reads are tricky */
-	return memory_read_dword_32le(asap->program, address & ~3) >> (address & 3);
+	return asap->program->read_dword(address & ~3) >> (address & 3);
 }
 
 INLINE void WRITEBYTE(asap_state *asap, offs_t address, UINT8 data)
 {
 	/* no alignment issues with bytes */
-	memory_write_byte_32le(asap->program, address, data);
+	asap->program->write_byte(address, data);
 }
 
 INLINE void WRITEWORD(asap_state *asap, offs_t address, UINT16 data)
@@ -321,18 +322,18 @@
 	/* aligned writes are easy */
 	if (!(address & 1))
 	{
-		memory_write_word_32le(asap->program, address, data);
+		asap->program->write_word(address, data);
 		return;
 	}
 
 	/* misaligned writes are tricky */
 	if (!(address & 2))
 	{
-		memory_write_byte_32le(asap->program, address + 1, data);
-		memory_write_byte_32le(asap->program, address + 2, data >> 8);
+		asap->program->write_byte(address + 1, data);
+		asap->program->write_byte(address + 2, data >> 8);
 	}
 	else
-		memory_write_byte_32le(asap->program, address + 1, data);
+		asap->program->write_byte(address + 1, data);
 }
 
 INLINE void WRITELONG(asap_state *asap, offs_t address, UINT32 data)
@@ -340,7 +341,7 @@
 	/* aligned writes are easy */
 	if (!(address & 3))
 	{
-		memory_write_dword_32le(asap->program, address, data);
+		asap->program->write_dword(address, data);
 		return;
 	}
 
@@ -348,14 +349,14 @@
 	switch (address & 3)
 	{
 		case 1:
-			memory_write_byte_32le(asap->program, address, data);
-			memory_write_word_32le(asap->program, address + 1, data >> 8);
+			asap->program->write_byte(address, data);
+			asap->program->write_word(address + 1, data >> 8);
 			break;
 		case 2:
-			memory_write_word_32le(asap->program, address, data);
+			asap->program->write_word(address, data);
 			break;
 		case 3:
-			memory_write_byte_32le(asap->program, address, data);
+			asap->program->write_byte(address, data);
 			break;
 	}
 }
@@ -446,6 +447,7 @@
 	asap->irq_callback = irqcallback;
 	asap->device = device;
 	asap->program = device->space(AS_PROGRAM);
+	asap->direct = &asap->program->direct();
 
 
 	state_save_register_device_item(device, 0, asap->pc);
diff -Nru src-old/emu/cpu/avr8/avr8.c src/emu/cpu/avr8/avr8.c
--- src-old/emu/cpu/avr8/avr8.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/avr8/avr8.c	2010-08-19 01:27:05.000000000 -0700
@@ -27,8 +27,8 @@
     UINT32 pc;
 
     legacy_cpu_device *device;
-    const address_space *program;
-    const address_space *io;
+    address_space *program;
+    address_space *io;
     int icount;
 };
 
@@ -115,32 +115,32 @@
 
 INLINE UINT8 READ_PRG_8(avr8_state *cpustate, UINT32 address)
 {
-    return memory_read_byte_16le(cpustate->program, address);
+    return cpustate->program->read_byte(address);
 }
 
 INLINE UINT16 READ_PRG_16(avr8_state *cpustate, UINT32 address)
 {
-    return memory_read_word_16le(cpustate->program, address << 1);
+    return cpustate->program->read_word(address << 1);
 }
 
 INLINE void WRITE_PRG_8(avr8_state *cpustate, UINT32 address, UINT8 data)
 {
-    memory_write_byte_16le(cpustate->program, address, data);
+    cpustate->program->write_byte(address, data);
 }
 
 INLINE void WRITE_PRG_16(avr8_state *cpustate, UINT32 address, UINT16 data)
 {
-    memory_write_word_16le(cpustate->program, address, data);
+    cpustate->program->write_word(address, data);
 }
 
 INLINE UINT8 READ_IO_8(avr8_state *cpustate, UINT16 address)
 {
-    return memory_read_byte(cpustate->io, address);
+    return cpustate->io->read_byte(address);
 }
 
 INLINE void WRITE_IO_8(avr8_state *cpustate, UINT16 address, UINT8 data)
 {
-    memory_write_byte(cpustate->io, address, data);
+    cpustate->io->write_byte(address, data);
 }
 
 INLINE void PUSH(avr8_state *cpustate, UINT8 val)
diff -Nru src-old/emu/cpu/ccpu/ccpu.c src/emu/cpu/ccpu/ccpu.c
--- src-old/emu/cpu/ccpu/ccpu.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/ccpu/ccpu.c	2010-08-19 09:10:19.000000000 -0700
@@ -44,9 +44,10 @@
 	int					icount;
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 };
 
 
@@ -62,13 +63,13 @@
     MACROS
 ***************************************************************************/
 
-#define READOP(C,a)			(memory_decrypted_read_byte((C)->program, a))
+#define READOP(C,a)			((C)->direct->read_decrypted_byte(a))
 
-#define RDMEM(C,a)			(memory_read_word_16be((C)->data, (a) * 2) & 0xfff)
-#define WRMEM(C,a,v)		(memory_write_word_16be((C)->data, (a) * 2, (v)))
+#define RDMEM(C,a)			((C)->data->read_word((a) * 2) & 0xfff)
+#define WRMEM(C,a,v)		((C)->data->write_word((a) * 2, (v)))
 
-#define READPORT(C,a)		(memory_read_byte_8be((C)->io, a))
-#define WRITEPORT(C,a,v)	(memory_write_byte_8be((C)->io, (a), (v)))
+#define READPORT(C,a)		((C)->io->read_byte(a))
+#define WRITEPORT(C,a,v)	((C)->io->write_byte((a), (v)))
 
 #define SET_A0(C)			do { (C)->a0flag = (C)->A; } while (0)
 #define SET_CMP_VAL(C,x)	do { (C)->cmpacc = *(C)->acc; (C)->cmpval = (x) & 0xfff; } while (0)
@@ -131,6 +132,7 @@
 	cpustate->vector_callback = configdata->vector_callback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/cdp1802/cdp1802.c src/emu/cpu/cdp1802/cdp1802.c
--- src-old/emu/cpu/cdp1802/cdp1802.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/cdp1802/cdp1802.c	2010-08-19 09:10:19.000000000 -0700
@@ -26,8 +26,9 @@
 {
 	const cdp1802_interface *intf;
 
-    const address_space *program;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *io;
 
 	devcb_resolved_write_line	out_q_func;
 	devcb_resolved_read8		in_dma_func;
@@ -74,11 +75,11 @@
 	return (cdp1802_state *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-#define OPCODE_R(addr)		memory_decrypted_read_byte(cpustate->program, addr)
-#define RAM_R(addr)			memory_read_byte_8be(cpustate->program, addr)
-#define RAM_W(addr, data)	memory_write_byte_8be(cpustate->program, addr, data)
-#define IO_R(addr)			memory_read_byte_8be(cpustate->io, addr)
-#define IO_W(addr, data)	memory_write_byte_8be(cpustate->io, addr, data)
+#define OPCODE_R(addr)		cpustate->direct->read_decrypted_byte(addr)
+#define RAM_R(addr)			cpustate->program->read_byte(addr)
+#define RAM_W(addr, data)	cpustate->program->write_byte(addr, data)
+#define IO_R(addr)			cpustate->io->read_byte(addr)
+#define IO_W(addr, data)	cpustate->io->write_byte(addr, data)
 
 #define P	cpustate->p
 #define X	cpustate->x
@@ -988,6 +989,7 @@
 
 	/* find address spaces */
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* set initial values */
diff -Nru src-old/emu/cpu/cop400/cop400.c src/emu/cpu/cop400/cop400.c
--- src-old/emu/cpu/cop400/cop400.c	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/cpu/cop400/cop400.c	2010-08-19 09:10:19.000000000 -0700
@@ -89,9 +89,10 @@
 {
 	const cop400_interface *intf;
 
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
     UINT8 featuremask;
 
@@ -160,11 +161,11 @@
     MACROS
 ***************************************************************************/
 
-#define ROM(a)			memory_decrypted_read_byte(cpustate->program, a)
-#define RAM_R(a)		memory_read_byte_8le(cpustate->data, a)
-#define RAM_W(a, v)		memory_write_byte_8le(cpustate->data, a, v)
-#define IN(a)			memory_read_byte_8le(cpustate->io, a)
-#define OUT(a, v)		memory_write_byte_8le(cpustate->io, a, v)
+#define ROM(a)			cpustate->direct->read_decrypted_byte(a)
+#define RAM_R(a)		cpustate->data->read_byte(a)
+#define RAM_W(a, v)		cpustate->data->write_byte(a, v)
+#define IN(a)			cpustate->io->read_byte(a)
+#define OUT(a, v)		cpustate->io->write_byte(a, v)
 
 #define IN_G()			(IN(COP400_PORT_G) & cpustate->g_mask)
 #define IN_L()			IN(COP400_PORT_L)
@@ -873,6 +874,7 @@
 	/* find address spaces */
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/cp1610/cp1610.c src/emu/cpu/cp1610/cp1610.c
--- src-old/emu/cpu/cp1610/cp1610.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/cp1610/cp1610.c	2010-08-19 01:27:05.000000000 -0700
@@ -47,7 +47,7 @@
 	int		intrm_pending;
 	int		mask_interrupts;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 };
 
@@ -58,9 +58,9 @@
 	return (cp1610_state *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-#define cp1610_readop(A) memory_read_word_16be(cpustate->program, (A)<<1)
-#define cp1610_readmem16(A) memory_read_word_16be(cpustate->program, (A)<<1)
-#define cp1610_writemem16(A,B) memory_write_word_16be(cpustate->program, (A)<<1,B)
+#define cp1610_readop(A) cpustate->program->read_word((A)<<1)
+#define cp1610_readmem16(A) cpustate->program->read_word((A)<<1)
+#define cp1610_writemem16(A,B) cpustate->program->write_word((A)<<1,B)
 
 /* clear all flags */
 #define CLR_SZOC                \
diff -Nru src-old/emu/cpu/cpu.mak src/emu/cpu/cpu.mak
--- src-old/emu/cpu/cpu.mak	2010-08-07 11:42:59.000000000 -0700
+++ src/emu/cpu/cpu.mak	2010-08-21 11:40:01.000000000 -0700
@@ -658,7 +658,6 @@
 
 $(CPUOBJ)/i86/i86.o:	$(CPUSRC)/i86/i86.c \
 						$(CPUSRC)/i86/i86.h \
-						$(CPUSRC)/i86/i86mem.c \
 						$(CPUSRC)/i86/i86time.c \
 						$(CPUSRC)/i86/instr86.c \
 						$(CPUSRC)/i86/instr186.c \
@@ -666,7 +665,6 @@
 
 $(CPUOBJ)/i86/i286.o:	$(CPUSRC)/i86/i286.c \
 						$(CPUSRC)/i86/i286.h \
-						$(CPUSRC)/i86/i86mem.c \
 						$(CPUSRC)/i86/i86time.c \
 						$(CPUSRC)/i86/instr86.c \
 						$(CPUSRC)/i86/instr186.c \
@@ -1199,7 +1197,6 @@
 						$(CPUSRC)/v60/optable.c \
 						$(CPUSRC)/v60/v60.c \
 						$(CPUSRC)/v60/v60.h \
-						$(CPUSRC)/v60/v60mem.c \
 						$(CPUSRC)/v60/v60d.c
 
 
diff -Nru src-old/emu/cpu/cubeqcpu/cubeqcpu.c src/emu/cpu/cubeqcpu/cubeqcpu.c
--- src-old/emu/cpu/cubeqcpu/cubeqcpu.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/cubeqcpu/cubeqcpu.c	2010-08-19 09:10:19.000000000 -0700
@@ -98,7 +98,8 @@
 	UINT16 *sound_data;
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 } cquestsnd_state;
 
@@ -139,7 +140,8 @@
 
 	legacy_cpu_device *device;
 	legacy_cpu_device *lindevice;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 } cquestrot_state;
 
@@ -185,7 +187,8 @@
 
 	legacy_cpu_device *device;
 	legacy_cpu_device *rotdevice;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 } cquestlin_state;
 
@@ -287,6 +290,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* Allocate RAM shared with 68000 */
 	cpustate->sram = auto_alloc_array(device->machine, UINT16, 4096/2);
@@ -361,6 +365,7 @@
 	cpustate->device = device;
 	cpustate->lindevice = device->machine->device<legacy_cpu_device>(rotconfig->lin_cpu_tag);
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	cquestrot_state_register(device);
 }
@@ -446,6 +451,7 @@
 	cpustate->device = device;
 	cpustate->rotdevice = device->machine->device<legacy_cpu_device>(linconfig->rot_cpu_tag);
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	cquestlin_state_register(device);
 }
@@ -503,7 +509,7 @@
 	do
 	{
 		/* Decode the instruction */
-		UINT64 inst = memory_decrypted_read_qword(cpustate->program, SND_PC << 3);
+		UINT64 inst = cpustate->direct->read_decrypted_qword(SND_PC << 3);
 		UINT32 inslow = inst & 0xffffffff;
 		UINT32 inshig = inst >> 32;
 
@@ -764,7 +770,7 @@
 	do
 	{
 		/* Decode the instruction */
-		UINT64 inst = memory_decrypted_read_qword(cpustate->program, ROT_PC << 3);
+		UINT64 inst = cpustate->direct->read_decrypted_qword(ROT_PC << 3);
 
 		UINT32 inslow = inst & 0xffffffff;
 		UINT32 inshig = inst >> 32;
@@ -1193,7 +1199,7 @@
 		/* Are we executing the foreground or backgroud program? */
 		int prog = (cpustate->clkcnt & 3) ? BACKGROUND : FOREGROUND;
 
-		UINT64 inst = memory_decrypted_read_qword(cpustate->program, LINE_PC << 3);
+		UINT64 inst = cpustate->direct->read_decrypted_qword(LINE_PC << 3);
 
 		UINT32 inslow = inst & 0xffffffff;
 		UINT32 inshig = inst >> 32;
diff -Nru src-old/emu/cpu/drcbec.c src/emu/cpu/drcbec.c
--- src-old/emu/cpu/drcbec.c	2010-06-08 10:35:49.000000000 -0700
+++ src/emu/cpu/drcbec.c	2010-08-19 01:27:05.000000000 -0700
@@ -213,7 +213,7 @@
 struct _drcbe_state
 {
 	running_device *	device;					/* CPU device we are associated with */
-	const address_space *	space[ADDRESS_SPACES];	/* pointers to CPU's address space */
+	address_space *	space[ADDRESS_SPACES];	/* pointers to CPU's address space */
 	drcuml_state *			drcuml;					/* pointer back to our owner */
 	drccache *				cache;					/* pointer to the cache */
 	drcuml_machine_state	state;					/* state of the machine */
@@ -903,43 +903,43 @@
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ1, 4, 0):		/* READ    dst,src1,space_BYTE    */
-				PARAM0 = memory_read_byte(drcbe->space[PARAM2 / 16], PARAM1);
+				PARAM0 = drcbe->space[PARAM2 / 16]->read_byte(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ2, 4, 0):		/* READ    dst,src1,space_WORD    */
-				PARAM0 = memory_read_word(drcbe->space[PARAM2 / 16], PARAM1);
+				PARAM0 = drcbe->space[PARAM2 / 16]->read_word(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ4, 4, 0):		/* READ    dst,src1,space_DWORD   */
-				PARAM0 = memory_read_dword(drcbe->space[PARAM2 / 16], PARAM1);
+				PARAM0 = drcbe->space[PARAM2 / 16]->read_dword(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READM2, 4, 0):		/* READM   dst,src1,mask,space_WORD */
-				PARAM0 = memory_read_word_masked(drcbe->space[PARAM3 / 16], PARAM1, PARAM2);
+				PARAM0 = drcbe->space[PARAM3 / 16]->read_word(PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READM4, 4, 0):		/* READM   dst,src1,mask,space_DWORD */
-				PARAM0 = memory_read_dword_masked(drcbe->space[PARAM3 / 16], PARAM1, PARAM2);
+				PARAM0 = drcbe->space[PARAM3 / 16]->read_dword(PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE1, 4, 0):		/* WRITE   dst,src1,space_BYTE     */
-				memory_write_byte(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_byte(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE2, 4, 0):		/* WRITE   dst,src1,space_WORD     */
-				memory_write_word(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_word(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE4, 4, 0):		/* WRITE   dst,src1,space_DWORD    */
-				memory_write_dword(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_dword(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITEM2, 4, 0):	/* WRITEM  dst,src1,mask,space_WORD */
-				memory_write_word_masked(drcbe->space[PARAM3 / 16], PARAM0, PARAM1, PARAM2);
+				drcbe->space[PARAM3 / 16]->write_word(PARAM0, PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITEM4, 4, 0):	/* WRITEM  dst,src1,mask,space_DWORD */
-				memory_write_dword_masked(drcbe->space[PARAM3 / 16], PARAM0, PARAM1, PARAM2);
+				drcbe->space[PARAM3 / 16]->write_dword(PARAM0, PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_CARRY, 4, 1):		/* CARRY   src,bitnum             */
@@ -1482,59 +1482,59 @@
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ1, 8, 0):		/* DREAD   dst,src1,space_BYTE    */
-				DPARAM0 = memory_read_byte(drcbe->space[PARAM2 / 16], PARAM1);
+				DPARAM0 = drcbe->space[PARAM2 / 16]->read_byte(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ2, 8, 0):		/* DREAD   dst,src1,space_WORD    */
-				DPARAM0 = memory_read_word(drcbe->space[PARAM2 / 16], PARAM1);
+				DPARAM0 = drcbe->space[PARAM2 / 16]->read_word(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ4, 8, 0):		/* DREAD   dst,src1,space_DWORD   */
-				DPARAM0 = memory_read_dword(drcbe->space[PARAM2 / 16], PARAM1);
+				DPARAM0 = drcbe->space[PARAM2 / 16]->read_dword(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READ8, 8, 0):		/* DREAD   dst,src1,space_QOWRD   */
-				DPARAM0 = memory_read_qword(drcbe->space[PARAM2 / 16], PARAM1);
+				DPARAM0 = drcbe->space[PARAM2 / 16]->read_qword(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READM2, 8, 0):		/* DREADM  dst,src1,mask,space_WORD */
-				DPARAM0 = memory_read_word_masked(drcbe->space[PARAM3 / 16], PARAM1, PARAM2);
+				DPARAM0 = drcbe->space[PARAM3 / 16]->read_word(PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READM4, 8, 0):		/* DREADM  dst,src1,mask,space_DWORD */
-				DPARAM0 = memory_read_dword_masked(drcbe->space[PARAM3 / 16], PARAM1, PARAM2);
+				DPARAM0 = drcbe->space[PARAM3 / 16]->read_dword(PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_READM8, 8, 0):		/* DREADM  dst,src1,mask,space_QWORD */
-				DPARAM0 = memory_read_qword_masked(drcbe->space[PARAM3 / 16], PARAM1, PARAM2);
+				DPARAM0 = drcbe->space[PARAM3 / 16]->read_qword(PARAM1, PARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE1, 8, 0):		/* DWRITE  dst,src1,space_BYTE    */
-				memory_write_byte(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_byte(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE2, 8, 0):		/* DWRITE  dst,src1,space_WORD    */
-				memory_write_word(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_word(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE4, 8, 0):		/* DWRITE  dst,src1,space_DWORD   */
-				memory_write_dword(drcbe->space[PARAM2 / 16], PARAM0, PARAM1);
+				drcbe->space[PARAM2 / 16]->write_dword(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITE8, 8, 0):		/* DWRITE  dst,src1,space_QWORD   */
-				memory_write_qword(drcbe->space[PARAM2 / 16], PARAM0, DPARAM1);
+				drcbe->space[PARAM2 / 16]->write_qword(PARAM0, DPARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITEM2, 8, 0):	/* DWRITEM dst,src1,mask,space_WORD */
-				memory_write_word_masked(drcbe->space[PARAM3 / 16], PARAM0, DPARAM1, DPARAM2);
+				drcbe->space[PARAM3 / 16]->write_word(PARAM0, DPARAM1, DPARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITEM4, 8, 0):	/* DWRITEM dst,src1,mask,space_DWORD */
-				memory_write_dword_masked(drcbe->space[PARAM3 / 16], PARAM0, DPARAM1, DPARAM2);
+				drcbe->space[PARAM3 / 16]->write_dword(PARAM0, DPARAM1, DPARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_WRITEM8, 8, 0):	/* DWRITEM dst,src1,mask,space_QWORD */
-				memory_write_qword_masked(drcbe->space[PARAM3 / 16], PARAM0, DPARAM1, DPARAM2);
+				drcbe->space[PARAM3 / 16]->write_qword(PARAM0, DPARAM1, DPARAM2);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_CARRY, 8, 0):		/* DCARRY  src,bitnum             */
@@ -1895,11 +1895,11 @@
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FREAD, 4, 0):		/* FSREAD  dst,src1,space         */
-				PARAM0 = memory_read_dword(drcbe->space[PARAM2], PARAM1);
+				PARAM0 = drcbe->space[PARAM2]->read_dword(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FWRITE, 4, 0):		/* FSWRITE dst,src1,space         */
-				memory_write_dword(drcbe->space[PARAM2], PARAM0, PARAM1);
+				drcbe->space[PARAM2]->write_dword(PARAM0, PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FMOV, 4, 1):		/* FSMOV   dst,src[,c]            */
@@ -2030,11 +2030,11 @@
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FREAD, 8, 0):		/* FDREAD  dst,src1,space         */
-				DPARAM0 = memory_read_qword(drcbe->space[PARAM2], PARAM1);
+				DPARAM0 = drcbe->space[PARAM2]->read_qword(PARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FWRITE, 8, 0):		/* FDWRITE dst,src1,space         */
-				memory_write_qword(drcbe->space[PARAM2], PARAM0, DPARAM1);
+				drcbe->space[PARAM2]->write_qword(PARAM0, DPARAM1);
 				break;
 
 			case MAKE_OPCODE_SHORT(DRCUML_OP_FMOV, 8, 1):		/* FDMOV   dst,src[,c]            */
diff -Nru src-old/emu/cpu/drcbex64.c src/emu/cpu/drcbex64.c
--- src-old/emu/cpu/drcbex64.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/cpu/drcbex64.c	2010-08-19 00:26:14.000000000 -0700
@@ -277,8 +277,8 @@
 	x86code *				debug_cpu_instruction_hook;/* debugger callback */
 	x86code *				debug_log_hashjmp;		/* hashjmp debugging */
 	x86code *				drcmap_get_value;		/* map lookup helper */
-	data_accessors			accessors[ADDRESS_SPACES];/* memory accessors */
-	const address_space *	space[ADDRESS_SPACES];	/* address spaces */
+	data_accessors			accessors[ADDRESS_SPACES];	/* memory accessors */
+	address_space *	space[ADDRESS_SPACES];	/* address spaces */
 
 	UINT8					sse41;					/* do we have SSE4.1 support? */
 	UINT32					ssemode;				/* saved SSE mode */
@@ -388,7 +388,6 @@
 };
 
 
-
 /***************************************************************************
     TABLES
 ***************************************************************************/
@@ -716,7 +715,7 @@
 	{
 		drcbe->space[spacenum] = downcast<cpu_device *>(device)->space(spacenum);
 		if (drcbe->space[spacenum] != NULL)
-			drcbe->accessors[spacenum] = drcbe->space[spacenum]->accessors;
+			drcbe->space[spacenum]->accessors(drcbe->accessors[spacenum]);
 	}
 
 	/* build up necessary arrays */
diff -Nru src-old/emu/cpu/drcbex86.c src/emu/cpu/drcbex86.c
--- src-old/emu/cpu/drcbex86.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/cpu/drcbex86.c	2010-08-19 00:26:14.000000000 -0700
@@ -178,7 +178,8 @@
 	UINT32 *				last_upper_addr;		/* address where we last stored an upper register */
 	double					fptemp;					/* temporary storage for floating point */
 
-	const address_space *	space[ADDRESS_SPACES];	/* address spaces */
+	data_accessors			accessors[ADDRESS_SPACES];	/* memory accessors */
+	address_space *	space[ADDRESS_SPACES];	/* address spaces */
 
 	UINT8					sse3;					/* do we have SSE3 support? */
 	UINT16					fpumode;				/* saved FPU mode */
@@ -629,9 +630,13 @@
 	drcbe->drcuml = drcuml;
 	drcbe->cache = cache;
 
-	/* get address spaces */
+	/* get address spaces and accessors */
 	for (spacenum = 0; spacenum < ADDRESS_SPACES; spacenum++)
+	{
 		drcbe->space[spacenum] = downcast<cpu_device *>(device)->space(spacenum);
+		if (drcbe->space[spacenum] != NULL)
+			drcbe->space[spacenum]->accessors(drcbe->accessors[spacenum]);
+	}
 
 	/* allocate hash tables */
 	drcbe->hash = drchash_alloc(cache, modes, addrbits, ignorebits);
@@ -4262,25 +4267,25 @@
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacesizep.value / 16]);// mov    [esp],space
 	if ((spacesizep.value & 3) == DRCUML_SIZE_BYTE)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_byte);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_byte);
 																						// call   read_byte
 		emit_movzx_r32_r8(&dst, dstreg, REG_AL);										// movzx  dstreg,al
 	}
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_WORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_word);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_word);
 																						// call   read_word
 		emit_movzx_r32_r16(&dst, dstreg, REG_AX);										// movzx  dstreg,ax
 	}
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_DWORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_dword);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_dword);
 																						// call   read_dword
 		emit_mov_r32_r32(&dst, dstreg, REG_EAX);										// mov    dstreg,eax
 	}
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_QWORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_qword);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_qword);
 																						// call   read_qword
 		emit_mov_r32_r32(&dst, dstreg, REG_EAX);										// mov    dstreg,eax
 	}
@@ -4342,19 +4347,19 @@
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacesizep.value / 16]);// mov    [esp],space
 	if ((spacesizep.value & 3) == DRCUML_SIZE_WORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_word_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_word_masked);
 																						// call   read_word_masked
 		emit_movzx_r32_r16(&dst, dstreg, REG_AX);										// movzx  dstreg,ax
 	}
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_DWORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_dword_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_dword_masked);
 																						// call   read_dword_masked
 		emit_mov_r32_r32(&dst, dstreg, REG_EAX);										// mov    dstreg,eax
 	}
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_QWORD)
 	{
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.read_qword_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].read_qword_masked);
 																						// call   read_qword_masked
 		emit_mov_r32_r32(&dst, dstreg, REG_EAX);										// mov    dstreg,eax
 	}
@@ -4411,16 +4416,16 @@
 	emit_mov_m32_p32(drcbe, &dst, MBD(REG_ESP, 4), &addrp);								// mov    [esp+4],addrp
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacesizep.value / 16]);// mov    [esp],space
 	if ((spacesizep.value & 3) == DRCUML_SIZE_BYTE)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_byte);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_byte);
 																						// call   write_byte
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_WORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_word);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_word);
 																						// call   write_word
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_DWORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_dword);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_dword);
 																						// call   write_dword
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_QWORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_qword);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_qword);
 																						// call   write_qword
 	return dst;
 }
@@ -4456,13 +4461,13 @@
 	emit_mov_m32_p32(drcbe, &dst, MBD(REG_ESP, 4), &addrp);								// mov    [esp+4],addrp
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacesizep.value / 16]);// mov    [esp],space
 	if ((spacesizep.value & 3) == DRCUML_SIZE_WORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_word_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_word_masked);
 																						// call   write_word_masked
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_DWORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_dword_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_dword_masked);
 																						// call   write_dword_masked
 	else if ((spacesizep.value & 3) == DRCUML_SIZE_QWORD)
-		emit_call(&dst, (x86code *)drcbe->space[spacesizep.value / 16]->accessors.write_qword_masked);
+		emit_call(&dst, (x86code *)drcbe->accessors[spacesizep.value / 16].write_qword_masked);
 																						// call   write_qword_masked
 	return dst;
 }
@@ -6411,9 +6416,9 @@
 	emit_mov_m32_p32(drcbe, &dst, MBD(REG_ESP, 4), &addrp);								// mov    [esp+4],addrp
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacep.value]);		// mov    [esp],space
 	if (inst->size == 4)
-		emit_call(&dst, (x86code *)drcbe->space[spacep.value]->accessors.read_dword);	// call   read_dword
+		emit_call(&dst, (x86code *)drcbe->accessors[spacep.value].read_dword);	// call   read_dword
 	else if (inst->size == 8)
-		emit_call(&dst, (x86code *)drcbe->space[spacep.value]->accessors.read_qword);	// call   read_qword
+		emit_call(&dst, (x86code *)drcbe->accessors[spacep.value].read_qword);	// call   read_qword
 
 	/* store result */
 	if (inst->size == 4)
@@ -6449,9 +6454,9 @@
 	emit_mov_m32_p32(drcbe, &dst, MBD(REG_ESP, 4), &addrp);								// mov    [esp+4],addrp
 	emit_mov_m32_imm(&dst, MBD(REG_ESP, 0), (UINT32)drcbe->space[spacep.value]);		// mov    [esp],space
 	if (inst->size == 4)
-		emit_call(&dst, (x86code *)drcbe->space[spacep.value]->accessors.write_dword);	// call   write_dword
+		emit_call(&dst, (x86code *)drcbe->accessors[spacep.value].write_dword);	// call   write_dword
 	else if (inst->size == 8)
-		emit_call(&dst, (x86code *)drcbe->space[spacep.value]->accessors.write_qword);	// call   write_qword
+		emit_call(&dst, (x86code *)drcbe->accessors[spacep.value].write_qword);	// call   write_qword
 
 	return dst;
 }
diff -Nru src-old/emu/cpu/drcfe.c src/emu/cpu/drcfe.c
--- src-old/emu/cpu/drcfe.c	2010-06-08 10:35:49.000000000 -0700
+++ src/emu/cpu/drcfe.c	2010-08-19 00:26:14.000000000 -0700
@@ -55,7 +55,7 @@
 
 	/* CPU parameters */
 	cpu_device *		cpudevice;					/* CPU device object */
-	const address_space *program;					/* program address space for this CPU */
+	address_space *program;					/* program address space for this CPU */
 	offs_t				pageshift;					/* shift to convert address to a page index */
 
 	/* opcode descriptor arrays */
diff -Nru src-old/emu/cpu/dsp32/dsp32.c src/emu/cpu/dsp32/dsp32.c
--- src-old/emu/cpu/dsp32/dsp32.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/dsp32/dsp32.c	2010-08-19 09:10:19.000000000 -0700
@@ -185,7 +185,8 @@
 	UINT32			ppc;
 	void			(*output_pins_changed)(running_device *device, UINT32 pins);
 	legacy_cpu_device *	device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 };
 
 
@@ -215,17 +216,17 @@
     MEMORY ACCESSORS
 ***************************************************************************/
 
-#define ROPCODE(cs,pc)			memory_decrypted_read_dword((cs)->program, pc)
+#define ROPCODE(cs,pc)			(cs)->direct->read_decrypted_dword(pc)
 
-#define RBYTE(cs,addr)			memory_read_byte_32le((cs)->program, addr)
-#define WBYTE(cs,addr,data)		memory_write_byte_32le((cs)->program, (addr), data)
+#define RBYTE(cs,addr)			(cs)->program->read_byte(addr)
+#define WBYTE(cs,addr,data)		(cs)->program->write_byte((addr), data)
 
 #if (!DETECT_MISALIGNED_MEMORY)
 
-#define RWORD(cs,addr)			memory_read_word_32le((cs)->program, addr)
-#define WWORD(cs,addr,data)		memory_write_word_32le((cs)->program, (addr), data)
-#define RLONG(cs,addr)			memory_read_dword_32le((cs)->program, addr)
-#define WLONG(cs,addr,data)		memory_write_dword_32le((cs)->program, (addr), data)
+#define RWORD(cs,addr)			(cs)->program->read_word(addr)
+#define WWORD(cs,addr,data)		(cs)->program->write_word((addr), data)
+#define RLONG(cs,addr)			(cs)->program->read_dword(addr)
+#define WLONG(cs,addr,data)		(cs)->program->write_dword((addr), data)
 
 #else
 
@@ -233,7 +234,7 @@
 {
 	UINT16 data;
 	if (addr & 1) fprintf(stderr, "Unaligned word read @ %06X, PC=%06X\n", addr, cpustate->PC);
-	data = memory_read_word_32le(cpustate->program, addr);
+	data = cpustate->program->read_word(addr);
 	return data;
 }
 
@@ -241,20 +242,20 @@
 {
 	UINT32 data;
 	if (addr & 3) fprintf(stderr, "Unaligned long read @ %06X, PC=%06X\n", addr, cpustate->PC);
-	data = memory_write_word_32le(cpustate->program, addr);
+	data = cpustate->program->write_word(addr);
 	return data;
 }
 
 INLINE void WWORD(dsp32_state *cpustate, offs_t addr, UINT16 data)
 {
 	if (addr & 1) fprintf(stderr, "Unaligned word write @ %06X, PC=%06X\n", addr, cpustate->PC);
-	memory_read_dword_32le(cpustate->program, (addr), data);
+	cpustate->program->read_dword((addr), data);
 }
 
 INLINE void WLONG(dsp32_state *cpustate, offs_t addr, UINT32 data)
 {
 	if (addr & 3) fprintf(stderr, "Unaligned long write @ %06X, PC=%06X\n", addr, cpustate->PC);
-	memory_write_dword_32le(cpustate->program, (addr), data);
+	cpustate->program->write_dword((addr), data);
 }
 
 #endif
@@ -359,6 +360,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	dsp32_register_save(device);
 }
diff -Nru src-old/emu/cpu/dsp56k/dsp56k.c src/emu/cpu/dsp56k/dsp56k.c
--- src-old/emu/cpu/dsp56k/dsp56k.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/dsp56k.c	2010-08-30 08:20:58.000000000 -0700
@@ -67,12 +67,12 @@
 /***************************************************************************
     Direct Update Handler
 ***************************************************************************/
-static DIRECT_UPDATE_HANDLER( dsp56k_direct_handler )
+DIRECT_UPDATE_HANDLER( dsp56k_direct_handler )
 {
 	if (address >= (0x0000<<1) && address <= (0x07ff<<1))
 	{
-		dsp56k_core* cpustate = get_safe_token(space->cpu);
-		direct->raw = direct->decrypted = (UINT8 *)(cpustate->program_ram - (0x0000<<1));
+		dsp56k_core* cpustate = get_safe_token(direct.space().cpu);
+		direct.explicit_configure(0x0000<<1, 0x07ff<<1, 0x07ff<<1, cpustate->program_ram);
 		return ~0;
 	}
 
@@ -83,7 +83,7 @@
 /***************************************************************************
     MEMORY ACCESSORS
 ***************************************************************************/
-#define ROPCODE(pc)   memory_decrypted_read_word(cpustate->program, pc)
+#define ROPCODE(pc)   cpustate->direct->read_decrypted_word(pc)
 
 
 /***************************************************************************
@@ -233,11 +233,12 @@
 	//cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 
 	/* Setup the direct memory handler for this CPU */
 	/* NOTE: Be sure to grab this guy and call him if you ever install another direct_update_hander in a driver! */
-	memory_set_direct_update_handler(cpustate->program, dsp56k_direct_handler);
+	const_cast<address_space *>(cpustate->program)->set_direct_update_handler(direct_update_delegate_create_static(dsp56k_direct_handler, *device->machine));
 }
 
 
@@ -290,7 +291,7 @@
 	alu_reset(cpustate);
 
 	/* HACK - Put a jump to 0x0000 at 0x0000 - this keeps the CPU locked to the instruction at address 0x0000 */
-	memory_write_word_16le(cpustate->program, 0x0000, 0x0124);
+	cpustate->program->write_word(0x0000, 0x0124);
 }
 
 
@@ -381,6 +382,46 @@
 /**************************************************************************
  * Generic set_info/get_info
  **************************************************************************/
+enum
+{
+	// PCU
+	DSP56K_PC=1,
+	DSP56K_SR,
+	DSP56K_LC,
+	DSP56K_LA,
+	DSP56K_SP,
+	DSP56K_OMR,
+
+	// ALU
+	DSP56K_X, DSP56K_Y,
+	DSP56K_A, DSP56K_B,
+
+	// AGU
+	DSP56K_R0,DSP56K_R1,DSP56K_R2,DSP56K_R3,
+	DSP56K_N0,DSP56K_N1,DSP56K_N2,DSP56K_N3,
+	DSP56K_M0,DSP56K_M1,DSP56K_M2,DSP56K_M3,
+	DSP56K_TEMP,
+	DSP56K_STATUS,
+
+	// CPU STACK
+	DSP56K_ST0,
+	DSP56K_ST1,
+	DSP56K_ST2,
+	DSP56K_ST3,
+	DSP56K_ST4,
+	DSP56K_ST5,
+	DSP56K_ST6,
+	DSP56K_ST7,
+	DSP56K_ST8,
+	DSP56K_ST9,
+	DSP56K_ST10,
+	DSP56K_ST11,
+	DSP56K_ST12,
+	DSP56K_ST13,
+	DSP56K_ST14,
+	DSP56K_ST15
+};
+
 static CPU_SET_INFO( dsp56k )
 {
 	dsp56k_core* cpustate = get_safe_token(device);
diff -Nru src-old/emu/cpu/dsp56k/dsp56k.h src/emu/cpu/dsp56k/dsp56k.h
--- src-old/emu/cpu/dsp56k/dsp56k.h	2010-08-09 22:25:22.000000000 -0700
+++ src/emu/cpu/dsp56k/dsp56k.h	2010-08-19 09:10:19.000000000 -0700
@@ -14,48 +14,6 @@
 
 #include "emu.h"
 
-/***************************************************************************
-    REGISTER ENUMERATION
-***************************************************************************/
-enum
-{
-	// PCU
-	DSP56K_PC=1,
-	DSP56K_SR,
-	DSP56K_LC,
-	DSP56K_LA,
-	DSP56K_SP,
-	DSP56K_OMR,
-
-	// ALU
-	DSP56K_X, DSP56K_Y,
-	DSP56K_A, DSP56K_B,
-
-	// AGU
-	DSP56K_R0,DSP56K_R1,DSP56K_R2,DSP56K_R3,
-	DSP56K_N0,DSP56K_N1,DSP56K_N2,DSP56K_N3,
-	DSP56K_M0,DSP56K_M1,DSP56K_M2,DSP56K_M3,
-	DSP56K_TEMP,
-	DSP56K_STATUS,
-
-	// CPU STACK
-	DSP56K_ST0,
-	DSP56K_ST1,
-	DSP56K_ST2,
-	DSP56K_ST3,
-	DSP56K_ST4,
-	DSP56K_ST5,
-	DSP56K_ST6,
-	DSP56K_ST7,
-	DSP56K_ST8,
-	DSP56K_ST9,
-	DSP56K_ST10,
-	DSP56K_ST11,
-	DSP56K_ST12,
-	DSP56K_ST13,
-	DSP56K_ST14,
-	DSP56K_ST15
-};
 
 // IRQ Lines
 // MODA and MODB are also known as IRQA and IRQB
@@ -233,8 +191,9 @@
 	int				interrupt_cycles;
 	void			(*output_pins_changed)(UINT32 pins);
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
 
 	UINT16 peripheral_ram[0x40];
 	UINT16 program_ram[0x800];
diff -Nru src-old/emu/cpu/dsp56k/dsp56ops.c src/emu/cpu/dsp56k/dsp56ops.c
--- src-old/emu/cpu/dsp56k/dsp56ops.c	2010-08-07 11:42:59.000000000 -0700
+++ src/emu/cpu/dsp56k/dsp56ops.c	2010-08-19 08:40:06.000000000 -0700
@@ -41,7 +41,7 @@
 };
 typedef struct _typed_pointer typed_pointer;
 
-#define ADDRESS(X) (X<<1)
+//#define ADDRESS(X) (X<<1)
 #define BITS(CUR,MASK) (Dsp56kOpMask(CUR,MASK))
 
 /*********************/
@@ -2306,7 +2306,7 @@
 	decode_BBB_bitmask(cpustate, BITS(op2,0xe000), &iVal);
 
 	workAddr = assemble_address_from_Pppppp_table(cpustate, BITS(op,0x0020), BITS(op,0x001f));
-	previousValue = memory_read_word_16le(cpustate->data, ADDRESS(workAddr));
+	previousValue = cpustate->data->read_word(ADDRESS(workAddr));
 	workingWord = previousValue;
 
 	switch(BITS(op2, 0x1f00))
@@ -2372,7 +2372,7 @@
 	decode_RR_table(cpustate, BITS(op,0x0003), &R);
 
 	workAddr = *((UINT16*)R.addr);
-	previousValue = memory_read_word_16le(cpustate->data, ADDRESS(workAddr));
+	previousValue = cpustate->data->read_word(ADDRESS(workAddr));
 	workingWord = previousValue;
 
 	switch(BITS(op2, 0x1f00))
@@ -3280,7 +3280,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 value = memory_read_word_16le(cpustate->data, ADDRESS(*((UINT16*)R.addr))) ;
+		UINT16 value = cpustate->data->read_word(ADDRESS(*((UINT16*)R.addr))) ;
 		typed_pointer temp_src = { &value, DT_WORD };
 		SetDestinationValue(temp_src, SD);
 	}
@@ -3322,7 +3322,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 tempData = memory_read_word_16le(cpustate->data, ADDRESS(memOffset));
+		UINT16 tempData = cpustate->data->read_word(ADDRESS(memOffset));
 		typed_pointer temp_src = { (void*)&tempData, DT_WORD };
 		SetDestinationValue(temp_src, SD);
 	}
@@ -3366,7 +3366,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 tempData = memory_read_word_16le(cpustate->data, ADDRESS(memOffset));
+		UINT16 tempData = cpustate->data->read_word(ADDRESS(memOffset));
 		typed_pointer temp_src = { (void*)&tempData, DT_WORD };
 		SetDestinationValue(temp_src, SD);
 	}
@@ -3417,7 +3417,7 @@
 		else
 		{
 			/* 16-bit long address */
-			UINT16 tempD = memory_read_word_16le(cpustate->data, ADDRESS(op2));
+			UINT16 tempD = cpustate->data->read_word(ADDRESS(op2));
 			typed_pointer tempTP = {&tempD, DT_WORD};
 			SetDestinationValue(tempTP, SD);
 		}
@@ -3495,7 +3495,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 tempData = memory_read_word_16le(cpustate->data, ADDRESS(memOffset));
+		UINT16 tempData = cpustate->data->read_word(ADDRESS(memOffset));
 		typed_pointer temp_src = { (void*)&tempData, DT_WORD };
 		SetDestinationValue(temp_src, SD);
 	}
@@ -3558,7 +3558,7 @@
 	{
 		/* Read from Program Memory */
 		typed_pointer data;
-		UINT16 ldata = memory_read_word_16le(cpustate->program, ADDRESS(*((UINT16*)R.addr)));
+		UINT16 ldata = cpustate->program->read_word(ADDRESS(*((UINT16*)R.addr)));
 
 		data.addr = &ldata;
 		data.data_type = DT_WORD;
@@ -3612,7 +3612,7 @@
 
 	if (W)
 	{
-		UINT16 data = memory_read_word_16le(cpustate->data, ADDRESS(pp));
+		UINT16 data = cpustate->data->read_word(ADDRESS(pp));
 
 		typed_pointer tempTP;
 		tempTP.addr = &data;
@@ -3651,7 +3651,7 @@
 	/* A little different than most W if's - opposite read and write */
 	if (W)
 	{
-		UINT16 data = memory_read_word_16le(cpustate->data, ADDRESS(*((UINT16*)SD.addr)));
+		UINT16 data = cpustate->data->read_word(ADDRESS(*((UINT16*)SD.addr)));
 
 		typed_pointer tempTP;
 		tempTP.addr = &data;
@@ -4681,7 +4681,7 @@
 	if (W)
 	{
 		/* From X:<ea> to SD */
-		UINT16 data = memory_read_word_16le(cpustate->data, ADDRESS(*((UINT16*)R.addr)));
+		UINT16 data = cpustate->data->read_word(ADDRESS(*((UINT16*)R.addr)));
 
 		typed_pointer tempTP;
 		tempTP.addr = &data;
@@ -4729,7 +4729,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 value = memory_read_word_16le(cpustate->data, ADDRESS(*mem_offset));
+		UINT16 value = cpustate->data->read_word(ADDRESS(*mem_offset));
 		typed_pointer tempV = {&value, DT_WORD};
 		SetDestinationValue(tempV, SD);
 	}
@@ -4757,7 +4757,7 @@
 	if (W)
 	{
 		/* Write D */
-		UINT16 tempData = memory_read_word_16le(cpustate->data, ADDRESS(memOffset));
+		UINT16 tempData = cpustate->data->read_word(ADDRESS(memOffset));
 		typed_pointer temp_src = { (void*)&tempData, DT_WORD };
 		SetDestinationValue(temp_src, SD);
 	}
@@ -4793,13 +4793,13 @@
 		fatalerror("Dsp56k: Unimplemented access to external X Data Memory >= 0xffc0 in Dual X Memory Data Read.");
 
 	/* First memmove */
-	srcVal1 = memory_read_word_16le(cpustate->data, ADDRESS(*((UINT16*)R.addr)));
+	srcVal1 = cpustate->data->read_word(ADDRESS(*((UINT16*)R.addr)));
 	tempV.addr = &srcVal1;
 	tempV.data_type = DT_WORD;
 	SetDestinationValue(tempV, D1);
 
 	/* Second memmove */
-	srcVal2 = memory_read_word_16le(cpustate->data, ADDRESS(R3));
+	srcVal2 = cpustate->data->read_word(ADDRESS(R3));
 	tempV.addr = &srcVal2;
 	tempV.data_type = DT_WORD;
 	SetDestinationValue(tempV, D2);
@@ -4895,13 +4895,13 @@
 {
 	switch(source.data_type)
 	{
-		case DT_BYTE:        memory_write_word_16le(cpustate->data, destinationAddr, (UINT16)( (*((UINT8*) source.addr) & 0xff)               ) ) ; break ;
-		case DT_WORD:        memory_write_word_16le(cpustate->data, destinationAddr, (UINT16)( (*((UINT16*)source.addr) & 0xffff)             ) ) ; break ;
-		case DT_DOUBLE_WORD: memory_write_word_16le(cpustate->data, destinationAddr, (UINT16)( (*((UINT32*)source.addr) & 0x0000ffff)         ) ) ; break ;
+		case DT_BYTE:        cpustate->data->write_word(destinationAddr, (UINT16)( (*((UINT8*) source.addr) & 0xff)               ) ) ; break ;
+		case DT_WORD:        cpustate->data->write_word(destinationAddr, (UINT16)( (*((UINT16*)source.addr) & 0xffff)             ) ) ; break ;
+		case DT_DOUBLE_WORD: cpustate->data->write_word(destinationAddr, (UINT16)( (*((UINT32*)source.addr) & 0x0000ffff)         ) ) ; break ;
 
 		/* !!! Is this universal ??? */
 		/* !!! Forget not, yon shift-limiter !!! */
-		case DT_LONG_WORD:   memory_write_word_16le(cpustate->data, destinationAddr, (UINT16)( ((*((UINT64*)source.addr)) & U64(0x00000000ffff0000)) >> 16) ) ; break ;
+		case DT_LONG_WORD:   cpustate->data->write_word(destinationAddr, (UINT16)( ((*((UINT64*)source.addr)) & U64(0x00000000ffff0000)) >> 16) ) ; break ;
 	}
 }
 
@@ -4910,13 +4910,13 @@
 {
 	switch(source.data_type)
 	{
-		case DT_BYTE:        memory_write_word_16le(cpustate->program, destinationAddr, (UINT16)( (*((UINT8*) source.addr) & 0xff)               ) ) ; break ;
-		case DT_WORD:        memory_write_word_16le(cpustate->program, destinationAddr, (UINT16)( (*((UINT16*)source.addr) & 0xffff)             ) ) ; break ;
-		case DT_DOUBLE_WORD: memory_write_word_16le(cpustate->program, destinationAddr, (UINT16)( (*((UINT32*)source.addr) & 0x0000ffff)         ) ) ; break ;
+		case DT_BYTE:        cpustate->program->write_word(destinationAddr, (UINT16)( (*((UINT8*) source.addr) & 0xff)               ) ) ; break ;
+		case DT_WORD:        cpustate->program->write_word(destinationAddr, (UINT16)( (*((UINT16*)source.addr) & 0xffff)             ) ) ; break ;
+		case DT_DOUBLE_WORD: cpustate->program->write_word(destinationAddr, (UINT16)( (*((UINT32*)source.addr) & 0x0000ffff)         ) ) ; break ;
 
 		/* !!! Is this universal ??? */
 		/* !!! Forget not, yon shift-limiter !!! */
-		case DT_LONG_WORD:   memory_write_word_16le(cpustate->program, destinationAddr, (UINT16)( ((*((UINT64*)source.addr)) & U64(0x00000000ffff0000)) >> 16) ) ; break ;
+		case DT_LONG_WORD:   cpustate->program->write_word(destinationAddr, (UINT16)( ((*((UINT64*)source.addr)) & U64(0x00000000ffff0000)) >> 16) ) ; break ;
 	}
 }
 
diff -Nru src-old/emu/cpu/dsp56k/dsp56pcu.c src/emu/cpu/dsp56k/dsp56pcu.c
--- src-old/emu/cpu/dsp56k/dsp56pcu.c	2010-08-09 22:25:22.000000000 -0700
+++ src/emu/cpu/dsp56k/dsp56pcu.c	2010-08-19 01:27:05.000000000 -0700
@@ -144,8 +144,8 @@
 				/* ... */
 				/* P:$cffe -> Internal P:$07ff low byte */
 				/* P:$cfff -> Internal P:$07ff high byte */
-				UINT8 mem_value_low  = memory_read_byte_16le(cpustate->program, mem_offset);		/* TODO: IS THIS READING RIGHT? */
-				UINT8 mem_value_high = memory_read_byte_16be(cpustate->program, mem_offset);
+				UINT8 mem_value_low  = cpustate->program->read_byte(mem_offset);		/* TODO: IS THIS READING RIGHT? */
+				UINT8 mem_value_high = cpustate->program->read_byte(mem_offset);
 				cpustate->program_ram[i] = (mem_value_high << 8) || mem_value_low;
 			}
 
@@ -166,7 +166,7 @@
 			/*        they need.  Once they've had their fill, they turn bootstrap mode off */
 			/*        and the CPU begins execution at 0x0000; */
 			/* HACK - Read bit 15 at 0xc000 to see if we're working with the SSIO or host interface. */
-			if (memory_read_word_16le(cpustate->program, 0xc000<<1) & 0x8000)
+			if (cpustate->program->read_word(0xc000<<1) & 0x8000)
 			{
 				cpustate->bootstrap_mode = BOOTSTRAP_SSIX;
 				logerror("DSP56k : Currently in (hacked) bootstrap mode - reading from SSIx.\n");
diff -Nru src-old/emu/cpu/dsp56k/inst.c src/emu/cpu/dsp56k/inst.c
--- src-old/emu/cpu/dsp56k/inst.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/inst.c	2010-08-30 08:20:58.000000000 -0700
@@ -333,12 +333,12 @@
 	else if (((w0 & 0xfff0) == 0x14b0) && ((w1 & 0x1f00) == 0x1200))
 	// NEW // else if (((w0 & 0xffe0) == 0x14a0) && ((w1 & 0x1f00) == 0x1200))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_2(opc, w0, w1));
 	}
 	/* BFCHG : 0001 0100 100D DDDD BBB1 0010 iiii iiii : A-38 */
 	else if (((w0 & 0xffe0) == 0x1480) && ((w1 & 0x1f00) == 0x1200))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_3(opc, w0, w1));
 	}
 	/* BFCLR : 0001 0100 11Pp pppp BBB0 0100 iiii iiii : A-40 */
 	else if (((w0 & 0xffc0) == 0x14c0) && ((w1 & 0x1f00) == 0x0400))
@@ -349,12 +349,12 @@
 	else if (((w0 & 0xfff0) == 0x14b0) && ((w1 & 0x1f00) == 0x0400))
 	// NEW // else if (((w0 & 0xffe0) == 0x14a0) && ((w1 & 0x1f00) == 0x0400))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_2(opc, w0, w1));
 	}
 	/* BFCLR : 0001 0100 100D DDDD BBB0 0100 iiii iiii : A-40 */
 	else if (((w0 & 0xffe0) == 0x1480) && ((w1 & 0x1f00) == 0x0400))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_3(opc, w0, w1));
 	}
 	/* BFSET : 0001 0100 11Pp pppp BBB1 1000 iiii iiii : A-42 */
 	else if (((w0 & 0xffc0) == 0x14c0) && ((w1 & 0x1f00) == 0x1800))
@@ -365,12 +365,12 @@
 	else if (((w0 & 0xfff0) == 0x14b0) && ((w1 & 0x1f00) == 0x1800))
 	// NEW // else if (((w0 & 0xffe0) == 0x14a0) && ((w1 & 0x1f00) == 0x1800))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_2(opc, w0, w1));
 	}
 	/* BFSET : 0001 0100 100D DDDD BBB1 1000 iiii iiii : A-42 */
 	else if (((w0 & 0xffe0) == 0x1480) && ((w1 & 0x1f00) == 0x1800))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_3(opc, w0, w1));
 	}
 	/* BFTSTH : 0001 0100 01Pp pppp BBB1 0000 iiii iiii : A-44 */
 	else if (((w0 & 0xffc0) == 0x1440) && ((w1 & 0x1f00) == 0x1000))
@@ -381,12 +381,12 @@
 	else if (((w0 & 0xfff0) == 0x1430) && ((w1 & 0x1f00) == 0x1000))
 	// NEW // else if (((w0 & 0xffe0) == 0x1420) && ((w1 & 0x1f00) == 0x1000))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_2(opc, w0, w1));
 	}
 	/* BFTSTH : 0001 0100 000D DDDD BBB1 0000 iiii iiii : A-44 */
 	else if (((w0 & 0xffe0) == 0x1400) && ((w1 & 0x1f00) == 0x1000))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_3(opc, w0, w1));
 	}
 	/* BFTSTL : 0001 0100 01Pp pppp BBB0 0000 iiii iiii : A-46 */
 	else if (((w0 & 0xffc0) == 0x1440) && ((w1 & 0x1f00) == 0x0000))
@@ -397,12 +397,12 @@
 	else if (((w0 & 0xfff0) == 0x1430) && ((w1 & 0x1f00) == 0x0000))
 	// NEW // else if (((w0 & 0xffe0) == 0x1420) && ((w1 & 0x1f00) == 0x0000))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_2(opc, w0, w1));
 	}
 	/* BFTSTL : 0001 0100 000D DDDD BBB0 0000 iiii iiii : A-46 */
 	else if (((w0 & 0xffe0) == 0x1400) && ((w1 & 0x1f00) == 0x0000))
 	{
-		return global_alloc(BfInstruction(opc, w0, w1));
+		return global_alloc(BfInstruction_3(opc, w0, w1));
 	}
 	/* Bcc : 0000 0111 --11 cccc xxxx xxxx xxxx xxxx : A-48 */
 	else if (((w0 & 0xff30) == 0x0730) && ((w1 & 0x0000) == 0x0000))
@@ -548,6 +548,9 @@
 	/* JMP : 0000 0001 0010 01RR : A-110 */
 	else if ((w0 & 0xfffc) == 0x0124)
 	{
+		//JMP2->m_oco = opc;
+		//JMP2->decode(w0, w1);
+		//return JMP2;
 		return global_alloc(Jmp_2(opc, w0, w1));
 	}
 	/* JScc : 0000 0110 --01 cccc xxxx xxxx xxxx xxxx : A-112 */
diff -Nru src-old/emu/cpu/dsp56k/inst.h src/emu/cpu/dsp56k/inst.h
--- src-old/emu/cpu/dsp56k/inst.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/inst.h	2010-08-30 08:20:58.000000000 -0700
@@ -7,6 +7,7 @@
 #include "tables.h"
 
 #include "dsp56k.h"
+#include "dsp56def.h"
 #include "dsp56pcu.h"
 
 //
@@ -15,6 +16,8 @@
 namespace DSP56K
 {
 
+#define ADDRESS(X) ((X)<<1)
+
 class Opcode;
 
 class Instruction
@@ -23,9 +26,8 @@
 	Instruction(const Opcode* oco) : m_valid(false),
 									 m_oco(oco),
 									 m_sizeIncrement(0),
-									 m_opcode(""),
-									 m_source(""),
-									 m_destination("") { }
+									 m_source(iINVALID),
+									 m_destination(iINVALID) { }
 	virtual ~Instruction() {}
 
 	virtual bool decode(const UINT16 word0, const UINT16 word1) = 0;
@@ -44,9 +46,8 @@
 
 	const bool valid() const { return m_valid; }
 
-	const std::string& opcode() const { return m_opcode; }
-	const std::string& source() const { return m_source; }
-	const std::string& destination() const { return m_destination; }
+	const reg_id& source() const { return m_source; }
+	const reg_id& destination() const { return m_destination; }
 
 	size_t sizeIncrement() const { return m_sizeIncrement; }
 
@@ -56,9 +57,8 @@
 	size_t m_sizeIncrement;
 
 	// Parameters nearly everyone has
-	std::string m_opcode;
-	std::string m_source;
-	std::string m_destination;
+	reg_id m_source;
+	reg_id m_destination;
 };
 
 
@@ -77,12 +77,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "abs";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "abs " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -101,12 +100,11 @@
 	{
 		decode_JF_table(BITSn(word0,0x0001), BITSn(word0,0x0008),
 						m_source, m_destination);
-		m_opcode = "adc";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "adc " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -125,12 +123,11 @@
 	{
 		decode_JJJF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_destination);
-		m_opcode = "add";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "add " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -145,6 +142,7 @@
 	Add_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
 		m_arg = "";
+        m_opcode = "";
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -156,13 +154,14 @@
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = m_opcode + " " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
+    std::string m_opcode;
 	std::string m_arg;  // TODO: get rid of this Add|Sub thing.
 };
 
@@ -178,12 +177,11 @@
 	{
 		decode_JJF_table(BITSn(word0,0x03),BITSn(word0,0x08),
 						 m_source, m_destination);
-		m_opcode = "and";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "and " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -203,16 +201,14 @@
 	{
 		m_immediate = BITSn(word0,0x00ff);
 		decode_EE_table(BITSn(word0,0x0600), m_destination);
-
-		m_opcode = "andi";
-		// NEW // sprintf(opcode_str, "and(i)");
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
 		char temp[32];
-		sprintf(temp, "#$%x,%s", m_immediate, m_destination.c_str());
-		retString = m_opcode + " " + std::string(temp);
+		sprintf(temp, "#$%x,%s", m_immediate, regIdAsString(m_destination).c_str());
+		retString = "andi " + std::string(temp);
+		// NEW // sprintf(opcode_str, "and(i)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -233,12 +229,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "asl";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "asl " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -256,12 +251,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-		m_opcode = "asl4";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "asl4 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -279,12 +273,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "asr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "asr " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -302,12 +295,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-		m_opcode = "asr4";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "asr4 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -325,12 +317,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-		m_opcode = "asr16";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "asr16 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -338,69 +329,166 @@
 };
 
 /* BFCHG  : 0001 0100 11Pp pppp BBB1 0010 iiii iiii : A-38 */
-/* BFCHG  : 0001 0100 101- --RR BBB1 0010 iiii iiii : A-38 */
-/* BFCHG  : 0001 0100 100D DDDD BBB1 0010 iiii iiii : A-38 */
 /* BFCLR  : 0001 0100 11Pp pppp BBB0 0100 iiii iiii : A-40 */
-/* BFCLR  : 0001 0100 101- --RR BBB0 0100 iiii iiii : A-40 */
-/* BFCLR  : 0001 0100 100D DDDD BBB0 0100 iiii iiii : A-40 */
 /* BFSET  : 0001 0100 11Pp pppp BBB1 1000 iiii iiii : A-42 */
-/* BFSET  : 0001 0100 101- --RR BBB1 1000 iiii iiii : A-42 */
-/* BFSET  : 0001 0100 100D DDDD BBB1 1000 iiii iiii : A-42 */
 /* BFTSTH : 0001 0100 01Pp pppp BBB1 0000 iiii iiii : A-44 */
-/* BFTSTH : 0001 0100 001- --RR BBB1 0000 iiii iiii : A-44 */
-/* BFTSTH : 0001 0100 000D DDDD BBB1 0000 iiii iiii : A-44 */
 /* BFTSTL : 0001 0100 01Pp pppp BBB0 0000 iiii iiii : A-46 */
-/* BFTSTL : 0001 0100 001- --RR BBB0 0000 iiii iiii : A-46 */
-/* BFTSTL : 0001 0100 000D DDDD BBB0 0000 iiii iiii : A-46 */
 class BfInstruction: public Instruction
 {
 public:
 	BfInstruction(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        dString = "";
+        m_opcode = "";
+        m_iVal = 0x0000;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		/* Decode the common parts */
-		UINT16 iVal = 0x0000;
-		iVal = BITSn(word1,0x00ff);
-
-		int upperMiddleLower = -1;
-		upperMiddleLower = decode_BBB_table(BITSn(word1,0xe000));
+		m_iVal = BITSn(word1,0x00ff);
 
+		bfShift upperMiddleLower = decode_BBB_table(BITSn(word1,0xe000));
 		switch(upperMiddleLower)
 		{
-			case BBB_UPPER:  iVal <<= 8; break;
-			case BBB_MIDDLE: iVal <<= 4; break;
-			case BBB_LOWER:  iVal <<= 0; break;
+			case BBB_UPPER:  m_iVal <<= 8; break;
+			case BBB_MIDDLE: m_iVal <<= 4; break;
+			case BBB_LOWER:  m_iVal <<= 0; break;
 
 			case BBB_INVALID: return false; break;
 		}
 
-		switch(BITSn(word0,0x00e0))
+		assemble_D_from_P_table(BITSn(word0,0x0020), BITSn(word0,0x001f), dString);
+
+		if (dString == "!!")
+			return false;
+
+		switch(BITSn(word1,0x1f00))
 		{
-			case 0x6: case 0x7: case 0x2: case 0x3:
-				assemble_D_from_P_table(BITSn(word0,0x0020), BITSn(word0,0x001f), m_destination);
-				break;
-			case 0x5: case 0x1:
-				INT8 rNum;
-				char temp[32];
-				decode_RR_table(BITSn(word0,0x0003), rNum);
-				sprintf(temp, "X:(R%d)", rNum);
-				m_destination = temp;
-				break;
-			case 0x4: case 0x0:
-				decode_DDDDD_table(BITSn(word0,0x001f), m_destination);
-				break;
+			case 0x12: m_opcode = "bfchg";  break;
+			case 0x04: m_opcode = "bfclr";  break;
+			case 0x18: m_opcode = "bfset";  break;
+			case 0x10: m_opcode = "bftsth"; break;
+			case 0x00: m_opcode = "bftstl"; break;
 		}
+		return true;
+	}
+	void disassemble(std::string& retString) const
+	{
+		char temp[32];
+		sprintf(temp, "#$%x", m_iVal);
+		retString = m_opcode + " " + std::string(temp) + "," + dString;
+		// NEW // sprintf(temp, "#$%04x", iVal);
+	}
+	void evaluate(dsp56k_core* cpustate) {}
+	size_t size() const { return 2; }
+	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+private:
+    UINT16 m_iVal;
+    std::string m_opcode;
+    std::string dString;
+};
 
-		if (m_destination == "!!")
+/* BFCHG  : 0001 0100 101- --RR BBB1 0010 iiii iiii : A-38 */
+/* BFCLR  : 0001 0100 101- --RR BBB0 0100 iiii iiii : A-40 */
+/* BFSET  : 0001 0100 101- --RR BBB1 1000 iiii iiii : A-42 */
+/* BFTSTH : 0001 0100 001- --RR BBB1 0000 iiii iiii : A-44 */
+/* BFTSTL : 0001 0100 001- --RR BBB0 0000 iiii iiii : A-46 */
+class BfInstruction_2: public Instruction
+{
+public:
+	BfInstruction_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
+	{
+        m_opcode = "";
+        m_r = iINVALID;
+        m_iVal = 0x0000;
+		m_valid = decode(word0, word1);
+	}
+	bool decode(const UINT16 word0, const UINT16 word1)
+	{
+		/* Decode the common parts */
+		m_iVal = BITSn(word1,0x00ff);
+
+		bfShift upperMiddleLower = decode_BBB_table(BITSn(word1,0xe000));
+		switch(upperMiddleLower)
+		{
+			case BBB_UPPER:  m_iVal <<= 8; break;
+			case BBB_MIDDLE: m_iVal <<= 4; break;
+			case BBB_LOWER:  m_iVal <<= 0; break;
+
+			case BBB_INVALID: return false; break;
+		}
+
+		decode_RR_table(BITSn(word0,0x0003), m_r);
+
+		if (m_r == iINVALID)
 			return false;
 
+		switch(BITSn(word1,0x1f00))
+		{
+			case 0x12: m_opcode = "bfchg";  break;
+			case 0x04: m_opcode = "bfclr";  break;
+			case 0x18: m_opcode = "bfset";  break;
+			case 0x10: m_opcode = "bftsth"; break;
+			case 0x00: m_opcode = "bftstl"; break;
+		}
+		return true;
+	}
+	void disassemble(std::string& retString) const
+	{
 		char temp[32];
-		sprintf(temp, "#$%x", iVal);
-		// NEW // sprintf(temp, "#$%04x", iVal);
-		m_source = temp;
+		sprintf(temp, "#$%x", m_iVal);
+		std::string source = temp;
+
+		sprintf(temp, "X:(%s)", regIdAsString(m_r).c_str());
+		std::string destination = temp;
+
+		retString = m_opcode + " " + source + "," + destination;
+		// NEW // sprintf(temp, "#$%04x", m_iVal);
+	}
+	void evaluate(dsp56k_core* cpustate) {}
+	size_t size() const { return 2; }
+	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    reg_id m_r;
+    UINT16 m_iVal;
+    std::string m_opcode;
+};
+
+/* BFCHG  : 0001 0100 100D DDDD BBB1 0010 iiii iiii : A-38 */
+/* BFCLR  : 0001 0100 100D DDDD BBB0 0100 iiii iiii : A-40 */
+/* BFSET  : 0001 0100 100D DDDD BBB1 1000 iiii iiii : A-42 */
+/* BFTSTH : 0001 0100 000D DDDD BBB1 0000 iiii iiii : A-44 */
+/* BFTSTL : 0001 0100 000D DDDD BBB0 0000 iiii iiii : A-46 */
+class BfInstruction_3: public Instruction
+{
+public:
+	BfInstruction_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
+	{
+        m_opcode = "";
+        m_iVal = 0x0000;
+		m_valid = decode(word0, word1);
+	}
+	bool decode(const UINT16 word0, const UINT16 word1)
+	{
+		/* Decode the common parts */
+		m_iVal = BITSn(word1,0x00ff);
+
+		bfShift upperMiddleLower = decode_BBB_table(BITSn(word1,0xe000));
+		switch(upperMiddleLower)
+		{
+			case BBB_UPPER:  m_iVal <<= 8; break;
+			case BBB_MIDDLE: m_iVal <<= 4; break;
+			case BBB_LOWER:  m_iVal <<= 0; break;
+
+			case BBB_INVALID: return false; break;
+		}
+
+		decode_DDDDD_table(BITSn(word0,0x001f), m_destination);
+
+		if (m_destination == iINVALID)
+			return false;
 
 		switch(BITSn(word1,0x1f00))
 		{
@@ -414,11 +502,20 @@
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		char temp[32];
+		sprintf(temp, "#$%x", m_iVal);
+		std::string source = temp;
+
+		retString = m_opcode + " " + source + "," + regIdAsString(m_destination);
+		// NEW // sprintf(temp, "#$%04x", m_iVal);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    UINT16 m_iVal;
+    std::string m_opcode;
 };
 
 // Bcc : 0000 0111 --11 cccc xxxx xxxx xxxx xxxx : A-48 ////////////////////////
@@ -427,31 +524,32 @@
 public:
 	Bcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_immediate = 0;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT16)word1;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "b" + M;
-		// NEW // sprintf(opcode_str, "b.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
+        std::string opcode = "b" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "b.%s", M);
+
 		char temp[32];
 		sprintf(temp, ">*+$%x", 2 + m_immediate);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 2 + (INT16)word1, (INT16)word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = opcode + " " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
+    op_mnem m_mnem;
 	INT16 m_immediate;
 };
 
@@ -462,30 +560,33 @@
 	Bcc_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
 		m_immediate = 0;
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x3c0), M);
+		decode_cccc_table(BITSn(word0,0x3c0), m_mnem);
 		m_immediate = get_6_bit_signed_value(BITSn(word0,0x003f));
-		m_opcode = "b" + M;
-		// NEW // sprintf(opcode_str, "b.%s", M);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
+        std::string opcode = "b" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "b.%s", M);
+
 		char temp[32];
 		if (m_immediate >= 0) sprintf(temp, "<*+$%x", m_immediate + 1);
 		else                  sprintf(temp, "<*-$%x", 1 - m_immediate - 2);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 1 + relativeInt, relativeInt);
-		retString = m_opcode + " " + std::string(temp);
+
+		retString = opcode + " " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
+    op_mnem m_mnem;
 	INT8 m_immediate;
 };
 
@@ -495,29 +596,27 @@
 public:
 	Bcc_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "b" + M;
-		// NEW // sprintf(opcode_str, "b.%s", M);
+		decode_RR_table(BITSn(word0,0x00c0), m_destination);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+        std::string opcode = "b" + opMnemonicAsString(m_mnem);
+		retString = opcode + " " + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "b.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // BRA : 0000 0001 0011 11-- xxxx xxxx xxxx xxxx : A-50 ////////////////////////
@@ -532,8 +631,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT16)word1;
-
-		m_opcode = "bra";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -541,7 +638,7 @@
 		char temp[32];
 		sprintf(temp, ">*+$%x", 2 + m_immediate);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 2 + word1, (INT16)word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "bra " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -563,7 +660,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT8)BITSn(word0,0x00ff);
-		m_opcode = "bra";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -572,7 +668,7 @@
 		if (m_immediate >= 0) sprintf(temp, "<*+$%x", 1 + m_immediate);
 		else                  sprintf(temp, "<*-$%x", 1 - m_immediate - 2);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 1 + iVal, iVal);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "bra " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -592,18 +688,12 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		m_opcode = "bra";
+		decode_RR_table(BITSn(word0,0x0003), m_destination);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "bra " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -616,23 +706,26 @@
 public:
 	Brkcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "brk" + M;
-		// NEW // sprintf(opcode_str, "brk.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+        std::string opcode = "brk" + opMnemonicAsString(m_mnem);
+		retString = opcode;
+		// NEW // sprintf(opcode_str, "brk.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // BScc : 0000 0111 --01 cccc xxxx xxxx xxxx xxxx : A-54 ///////////////////////
@@ -642,26 +735,26 @@
 	Bscc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
 		m_immediate = 0;
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT16)word1;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "bs" + M;
-		// NEW // sprintf(opcode_str, "bs.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
+        std::string opcode = "bs" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "bs.%s", M);
+
 		char temp[32];
 		if (m_immediate >= 0) sprintf(temp, ">*+$%x", 2 + m_immediate);
 		else                  sprintf(temp, ">*-$%x", 1 - m_immediate - 1 - 2);
 		//sprintf(temp, ">*+$%x", 2 + m_immediate);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 2 + (INT16)word1, (INT16)word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = opcode + " " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -669,6 +762,7 @@
 	size_t flags() { return DASMFLAG_STEP_OVER; }
 
 private:
+    op_mnem m_mnem;
 	INT16 m_immediate;
 };
 
@@ -678,31 +772,28 @@
 public:
 	Bscc_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-		sprintf(temp, "R%d", rNum);
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_destination = temp;
-
-		m_opcode = "bs" + M;
-		// NEW // sprintf(opcode_str, "bs.%s", M);
+		decode_RR_table(BITSn(word0,0x00c0), m_destination);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+        std::string opcode = "bs" + opMnemonicAsString(m_mnem);
+		retString = opcode + " " + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "bs.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 	size_t flags() { return DASMFLAG_STEP_OVER; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // BSR : 0000 0001 0011 10-- xxxx xxxx xxxx xxxx : A-56 ////////////////////////
@@ -717,8 +808,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT16)word1;
-
-		m_opcode = "bsr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -727,7 +816,7 @@
 		if (m_immediate >= 0) sprintf(temp, ">*+$%x", 2 + m_immediate);
 		else                  sprintf(temp, ">*-$%x", 1 - m_immediate - 1 - 2);
 		// NEW // sprintf(temp, "$%04x (%d)", pc + 2 + (INT16)word1, (INT16)word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "bsr " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -748,18 +837,12 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		m_opcode = "bsr";
+		decode_RR_table(BITSn(word0,0x0003), m_destination);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "bsr " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -777,12 +860,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "chkaau";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "chkaau";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -800,12 +882,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "clr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "clr " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -823,12 +904,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "clr24";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "clr24 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -849,12 +929,11 @@
                  in before cmp, so the same decode function can be used. */
 		decode_JJJF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_destination);
-		m_opcode = "cmp";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "cmp " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -875,12 +954,11 @@
                  in before cmp, so the same decode function can be used. */
 		decode_JJJF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_destination);
-		m_opcode = "cmpm";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "cmpm " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -897,12 +975,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "debug";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "debug";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -915,23 +992,26 @@
 public:
 	Debugcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "debug" + M;
-		// NEW // sprintf(opcode_str, "debug.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+        std::string opcode = "debug" + opMnemonicAsString(m_mnem);
+		retString = opcode;
+		// NEW // sprintf(opcode_str, "debug.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // DEC : .... .... 0110 F010 : A-72 ////////////////////////////////////////////
@@ -945,12 +1025,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "dec";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "dec " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -968,12 +1047,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "dec24";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "dec24 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -992,12 +1070,11 @@
 	{
 		decode_DDF_table(BITSn(word0,0x0003), BITSn(word0,0x0008),
 						 m_source, m_destination);
-		m_opcode = "div";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "div " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1010,7 +1087,8 @@
 public:
 	Dmac(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_mnem = oINVALID;
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -1018,26 +1096,26 @@
 		decode_QQF_special_table(BITSn(word0,0x0003), BITSn(word0,0x0008),
 								 m_source, m_source2, m_destination);
 
-		std::string a;
-		decode_ss_table(BITSn(word0,0x0024), a);
-		if (a == "!!") return false;
-
-		m_opcode = "dmac" + a;
-		// NEW // sprintf(opcode_str, "dmac(%s)", A);
+		decode_ss_table(BITSn(word0,0x0024), m_mnem);
+		if (m_mnem == oINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string opcode = "dmac" + opMnemonicAsString(m_mnem);
+
+		retString = opcode + " " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "dmac(%s)", A);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    op_mnem m_mnem;
+	reg_id m_source2;
 };
 
 // DO : 0000 0000 110- --RR xxxx xxxx xxxx xxxx : A-82 /////////////////////////
@@ -1052,22 +1130,20 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = word1;
-
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "X:(R%d)", rNum);
-		m_source = temp;
-
-		m_opcode = "do";
+		decode_RR_table(BITSn(word0,0x0003), m_source);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
 		char temp[32];
 		sprintf(temp, "*+$%x", 2 + m_immediate);
+        std::string destination = temp;
 		// NEW // sprintf(temp, "X:(R%d),$%02x", Rnum, pc + 2 + word1);
-		retString = m_opcode + " " + m_source + "," + std::string(temp);
+
+		sprintf(temp, "X:(%s)", regIdAsString(m_source).c_str());
+		std::string source = temp;
+
+		retString = "do " + source + "," + destination;
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1091,8 +1167,6 @@
 	{
 		m_immediate = BITSn(word0,0x00ff);
 		m_displacement = word1;
-
-		m_opcode = "do";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1100,7 +1174,7 @@
 		char temp[32];
 		sprintf(temp, "#<$%x,*+$%x", m_immediate, 2 + m_displacement);
 		// NEW // sprintf(temp, "#$%02x,$%04x", BITSn(word0,0x00ff), pc + 2 + word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "do " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1125,9 +1199,8 @@
 		m_displacement = word1;
 
 		decode_DDDDD_table(BITSn(word0,0x001f), m_source);
-		if (m_source == "SSH") return false; // NEW //
-		if (m_source == "!!") return false;  // NEW //
-		m_opcode = "do";
+		if (m_source == iSSH) return false;
+		if (m_source == iINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1135,7 +1208,7 @@
 		char temp[32];
 		sprintf(temp, "*+$%x", 2 + m_displacement);
 		// NEW // sprintf(temp, "%s,$%04x", S1, pc + 2 + word1);
-		retString = m_opcode + " " + m_source + "," + std::string(temp);
+		retString = "do " + regIdAsString(m_source) + "," + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1157,7 +1230,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_displacement = word1;
-		m_opcode = "do forever";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1166,7 +1238,7 @@
 		sprintf(temp, "*+$%x", m_displacement + 2);
 		// NEW // sprintf(temp, "*+$%x", pc + word1);
 		// NEW // sprintf(temp, "$%04x", pc + 2 + word1);
-		retString = m_opcode + ", " + std::string(temp);
+		retString = "do forever, " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1186,12 +1258,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "enddo";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "enddo";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1210,12 +1281,11 @@
 	{
 		decode_JJF_table(BITSn(word0,0x03),BITSn(word0,0x08),
 						 m_source, m_destination);
-		m_opcode = "eor";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "eor " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1233,12 +1303,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-		m_opcode = "ext";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "ext " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1255,12 +1324,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "illegal";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "illegal";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1273,28 +1341,27 @@
 public:
 	Imac(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQQF_table(BITSn(word0,0x0007), BITSn(word0,0x0008),
 						  m_source, m_source2, m_destination);
-		m_opcode = "imac";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "imac " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // IMPY : 0001 0101 1000 FQQQ : A-102 //////////////////////////////////////////
@@ -1303,28 +1370,27 @@
 public:
 	Impy(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQQF_table(BITSn(word0,0x0007), BITSn(word0,0x0008),
 						  m_source, m_source2, m_destination);
-		m_opcode = "impy";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "impy " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // INC : .... .... 0010 F010 : A-104 ///////////////////////////////////////////
@@ -1338,12 +1404,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "inc";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "inc " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1361,12 +1426,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "inc24";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "inc24 " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1379,31 +1443,32 @@
 public:
 	Jcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_displacement = 0;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_displacement = word1;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "j" + M;
-		// NEW // sprintf(opcode_str, "j.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
+        std::string opcode = "j" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "j.%s", M);
+
 		char temp[32];
 		sprintf(temp, ">$%x", m_displacement);
 		// NEW // sprintf(temp, "$%04x", word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = opcode + " " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
+    op_mnem m_mnem;
 	UINT16 m_displacement;
 };
 
@@ -1413,29 +1478,27 @@
 public:
 	Jcc_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "j" + M;
-		// NEW // sprintf(opcode_str, "j.%s", M);
+		decode_RR_table(BITSn(word0,0x00c0), m_destination);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+        std::string opcode = "j" + opMnemonicAsString(m_mnem);
+		retString = opcode + " " + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "j.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // JMP : 0000 0001 0011 01-- xxxx xxxx xxxx xxxx : A-110 ///////////////////////
@@ -1450,8 +1513,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_displacement = word1;
-
-		m_opcode = "jmp";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1459,10 +1520,18 @@
 		char temp[32];
 		sprintf(temp, ">$%x", m_displacement);
 		// NEW // sprintf(temp, "$%04x", word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "jmp " + std::string(temp);
+	}
+	void evaluate(dsp56k_core* cpustate)
+	{
+		cpustate->ppc = PC;
+		PC = m_displacement;
+
+		/* S L E U N Z V C */
+		/* - - - - - - - - */
 	}
-	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
+    size_t evalSize() const { return 0; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
@@ -1479,59 +1548,53 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		m_opcode = "jmp";
+		decode_RR_table(BITSn(word0,0x0003), m_destination);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "jmp " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate)
 	{
-		// Get value from source
+		cpustate->ppc = PC;
+		PC = regValue16(cpustate, m_destination);
 
-        // Set the PC
-		PC = 0;
-
-	    /* S L E U N Z V C */
-	    /* - - - - - - - - */
+		/* S L E U N Z V C */
+		/* - - - - - - - - */
 	}
 	size_t size() const { return 1; }
     size_t evalSize() const { return 0; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 };
 
+//static Jmp_2* JMP2 = new Jmp_2(NULL, 0x0000, 0x0000);
+
 // JScc : 0000 0110 --01 cccc xxxx xxxx xxxx xxxx : A-112 //////////////////////
 class Jscc: public Instruction
 {
 public:
 	Jscc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_displacement = 0;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_displacement = word1;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "js" + M;
-		// NEW // sprintf(opcode_str, "js.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
+        std::string opcode = "js" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "js.%s", M);
+
 		char temp[32];
 		sprintf(temp, ">$%x", m_displacement);
 		// NEW // sprintf(temp, "$%04x", word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = opcode + " " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1539,6 +1602,7 @@
 	size_t flags() { return DASMFLAG_STEP_OVER; }
 
 private:
+    op_mnem m_mnem;
 	UINT16 m_displacement;
 };
 
@@ -1548,30 +1612,28 @@
 public:
 	Jscc_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "js" + M;
-		// NEW // sprintf(opcode_str, "js.%s", M);
+		decode_RR_table(BITSn(word0,0x00c0), m_destination);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+        std::string opcode = "js" + opMnemonicAsString(m_mnem);
+		retString = opcode + " " + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "js.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 	size_t flags() { return DASMFLAG_STEP_OVER; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // JSR : 0000 0001 0011 00-- xxxx xxxx xxxx xxxx : A-114 ///////////////////////
@@ -1586,8 +1648,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_displacement = word1;
-
-		m_opcode = "jsr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1595,7 +1655,7 @@
 		char temp[32];
 		sprintf(temp, ">$%x", m_displacement);
 		// NEW // sprintf(temp, "$%04x", word1);
-		retString = m_opcode + " " + std::string(temp);
+		retString = "jsr " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -1618,8 +1678,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_bAddr = BITSn(word0,0x00ff);
-
-		m_opcode = "jsr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -1627,7 +1685,7 @@
 		char temp[32];
 		sprintf(temp, "<$%x", m_bAddr);
 		// NEW // sprintf(temp, "#$%02x", BITSn(word0,0x00ff));
-		retString = m_opcode + " " + std::string(temp);
+		retString = "jsr " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1648,18 +1706,12 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination = temp;
-
-		m_opcode = "jsr";
+		decode_RR_table(BITSn(word0,0x0003), m_destination);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "jsr " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1673,35 +1725,31 @@
 public:
 	Lea(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+		m_ea = "";
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		if ((word0 & 0x000c) == 0) return false;  // NEW TODO //
 
-		char temp[32];
-
-		INT8 tNum;
-		decode_TT_table(BITSn(word0,0x0030), tNum);
-		sprintf(temp, "R%d", tNum);
-		m_destination = temp;
+		decode_TT_table(BITSn(word0,0x0030), m_destination);
 
-		INT8 rNum;
-		std::string ea;
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, ea);
-		m_source = ea;
+		INT8 rNum = BITSn(word0,0x0003);
+		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, m_ea);
 
-		m_opcode = "lea";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        // HACK
+		retString = "lea " + m_ea + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    std::string m_ea;
 };
 
 // LEA : 0000 0001 10NN MMRR : A-116 ///////////////////////////////////////////
@@ -1716,30 +1764,24 @@
 	{
 		if ((word0 & 0x000c) == 0) return false;  // NEW TODO //
 
-		char temp[32];
-
-		INT8 nNum;
-		decode_NN_table(BITSn(word0,0x0030), nNum);
-		sprintf(temp, "N%d", nNum);
-		m_destination = temp;
-
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x0003), rNum);
+		decode_NN_table(BITSn(word0,0x0030), m_destination);
 
-		std::string ea;
-		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, ea);
-		m_source = ea;
+		INT8 rNum = BITSn(word0,0x0003);
+		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, m_ea);
 
-		m_opcode = "lea";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        // HACK
+		retString = "lea " + m_ea + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    std::string m_ea;
 };
 
 // LSL : .... .... 0011 F011 : A-118 ///////////////////////////////////////////
@@ -1753,12 +1795,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "lsl";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "lsl " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1776,12 +1817,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-		m_opcode = "lsr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "lsr " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -1794,7 +1834,8 @@
 public:
 	Mac(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_sign = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -1802,26 +1843,25 @@
 		decode_QQQF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_source2, m_destination);
 
-		std::string sign;
-		decode_kSign_table(BITSn(word0,0x40), sign);
-		if (sign == "-")
-			m_source = sign + m_source; // TODO: Probably silly for Instruction
-
-		m_opcode = "mac";
+		decode_kSign_table(BITSn(word0,0x40), m_sign);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string ts = m_sign;
+        if (ts != "-") ts = "";
+		retString = "mac " +
+                	ts +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
+	std::string m_sign;
 };
 
 // MAC : 011m mKKK 1xx0 F1QQ : A-122 ///////////////////////////////////////////
@@ -1830,29 +1870,27 @@
 public:
 	Mac_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQF_table(BITSn(word0,0x03), BITSn(word0,0x08),
 						 m_source, m_source2, m_destination);
-
-		m_opcode = "mac";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "mac " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MAC : 0001 0111 RRDD FQQQ : A-122 ///////////////////////////////////////////
@@ -1861,28 +1899,27 @@
 public:
 	Mac_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQQF_table(BITSn(word0,0x0007), BITSn(word0,0x0008),
 						  m_source, m_source2, m_destination);
-		m_opcode = "mac";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "mac " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MACR : .... .... 1k11 FQQQ : A-124 //////////////////////////////////////////
@@ -1891,7 +1928,8 @@
 public:
 	Macr(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_sign = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -1899,26 +1937,25 @@
 		decode_QQQF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_source2, m_destination);
 
-		std::string sign;
-		decode_kSign_table(BITSn(word0,0x40), sign);
-		if (sign == "-")
-			m_source = sign + m_source; // TODO: Probably silly for Instruction
-
-		m_opcode = "macr";
+		decode_kSign_table(BITSn(word0,0x40), m_sign);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string ts = m_sign;
+        if (ts != "-") ts = "";
+		retString = "macr " +
+                	ts +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    std::string m_sign;
+	reg_id m_source2;
 };
 
 // MACR : 011m mKKK 1--1 F1QQ : A-124 //////////////////////////////////////////
@@ -1927,28 +1964,27 @@
 public:
 	Macr_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQF_table(BITSn(word0,0x03), BITSn(word0,0x08),
 						 m_source, m_source2, m_destination);
-		m_opcode = "macr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "macr " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MAC(su,uu) : 0001 0101 1110 FsQQ : A-126 ////////////////////////////////////
@@ -1957,7 +1993,8 @@
 public:
 	Macsuuu(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_mnem = oINVALID;
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -1966,24 +2003,25 @@
 		decode_QQF_special_table(BITSn(word0,0x0003), BITSn(word0,0x0008),
 								 m_source, m_source2, m_destination);
 
-		std::string a;
-		decode_s_table(BITSn(word0,0x0004), a);
-		m_opcode = "mac" + a;
-		// NEW // sprintf(opcode_str, "mac(%s)", A);
+		decode_s_table(BITSn(word0,0x0004), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string opcode = "mac" + opMnemonicAsString(m_mnem);
+
+		retString = opcode + " " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "mac(%s)", A);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    op_mnem m_mnem;
+	reg_id m_source2;
 };
 
 // MOVE : .... .... 0001 0001 : A-128 //////////////////////////////////////////
@@ -2002,16 +2040,15 @@
 		// This insures the debugger matches the reference disassembler
 		// for the undocumented .... .... 0001 1001 Instruction.
 		if(BITSn(word0, 0x000f) == 0x0001)
-			m_destination = "A";
+			m_destination = iA;
 		else
-			m_destination = "B";
+			m_destination = iB;
 
 		// Hack to match reference disassembler
 		UINT8 BITSn = (word0 & 0xff00) >> 8;
 		if (BITSn == 0x4a || BITSn == 0x4b)
 			m_isNop = true;
 
-		m_opcode = "move";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -2019,7 +2056,7 @@
 		if (m_isNop)
 			retString = "nop";
 		else
-			retString = m_opcode;
+			retString = "move";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2042,16 +2079,15 @@
 		// Amounts to a nop with two parallel moves.
 		// This insures the debugger matches the reference disassembler
 		if((word0 & 0x0008) == 0x0008)
-			m_destination = "B";
+			m_destination = iB;
 		else
-			m_destination = "A";
+			m_destination = iA;
 
-		m_opcode = "move";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "move";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2064,24 +2100,24 @@
 public:
 	Move_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
 		m_b = 0;
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_b = BITSn(word0,0x00ff);
-
-		std::string SD;
-		decode_HHH_table(BITSn(word1,0x0e00), SD);
-		assemble_reg_from_W_table(BITSn(word1,0x0100), 'X', SD, m_b,
-								  m_source, m_destination);
-
-		m_opcode = "move";
+        m_W = BITSn(word1,0x0100);
+		decode_HHH_table(BITSn(word1,0x0e00), m_SD);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_reg_from_W_table(m_W, 'X', m_SD, m_b, source, destination);
+		retString = "move " + source + "," + destination;
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -2089,6 +2125,8 @@
 
 private:
 	INT8 m_b;
+    UINT8 m_W;
+    reg_id m_SD;
 };
 
 // MOVE(C) : 0011 1WDD DDD0 MMRR : A-144 ///////////////////////////////////////
@@ -2097,33 +2135,37 @@
 public:
 	Movec(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		std::string ea;
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, ea);
-
-		std::string SD;
-		decode_DDDDD_table(BITSn(word0,0x03e0), SD);
-		assemble_arguments_from_W_table(BITSn(word0,0x0400), 'X', SD, ea,
-										m_source, m_destination);
+		INT8 rNum = BITSn(word0,0x0003);
+		assemble_ea_from_MM_table(BITSn(word0,0x000c), rNum, m_ea);
 
-		if (SD == "!!") return false;
-
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(c)");
+        m_W = BITSn(word0,0x0400);
+		decode_DDDDD_table(BITSn(word0,0x03e0), m_SD);
+		if (m_SD == iINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(c)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MOVE(C) : 0011 1WDD DDD1 q0RR : A-144 ///////////////////////////////////////
@@ -2132,33 +2174,37 @@
 public:
 	Movec_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		std::string ea;
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		assemble_ea_from_q_table(BITSn(word0,0x0008), rNum, ea);
-
-		std::string SD;
-		decode_DDDDD_table(BITSn(word0,0x03e0), SD);
-		assemble_arguments_from_W_table(BITSn(word0,0x0400), 'X', SD, ea,
-										m_source, m_destination);
+		INT8 rNum = BITSn(word0,0x0003);
+		assemble_ea_from_q_table(BITSn(word0,0x0008), rNum, m_ea);
 
-		if (SD == "!!") return false;
-
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(c)");
+		decode_DDDDD_table(BITSn(word0,0x03e0), m_SD);
+        m_W = BITSn(word0,0x0400);
+		if (m_SD == iINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(c)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MOVE(C) : 0011 1WDD DDD1 Z11- : A-144 ///////////////////////////////////////
@@ -2167,31 +2213,36 @@
 public:
 	Movec_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string ea;
-		decode_Z_table(BITSn(word0,0x0008), ea);
-
-		std::string SD;
-		decode_DDDDD_table(BITSn(word0,0x03e0), SD);
-		assemble_arguments_from_W_table(BITSn(word0,0x0400), 'X', SD, ea,
-										m_source, m_destination);
-
-		if (SD == "!!") return false;
+		decode_Z_table(BITSn(word0,0x0008), m_ea);
 
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(c)");
+		decode_DDDDD_table(BITSn(word0,0x03e0), m_SD);
+        m_W = BITSn(word0,0x0400);
+		if (m_SD == iINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(c)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MOVE(C) : 0011 1WDD DDD1 t10- xxxx xxxx xxxx xxxx : A-144 ///////////////////
@@ -2200,43 +2251,77 @@
 public:
 	Movec_4(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_args = "";
+        m_t = 0;
+        m_W = 0;
+        m_sd = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		char temp[128];
-		std::string SD;
-		decode_DDDDD_table(BITSn(word0,0x03e0), SD);
-		if (SD == "!!") return false;
+		m_value = word1;
+		m_t = BITSn(word0,0x0008);
+		m_W = BITSn(word0,0x0400);
 
-		std::string ea;
-		assemble_ea_from_t_table(BITSn(word0,0x0008), word1, ea);
+		decode_DDDDD_table(BITSn(word0,0x03e0), m_sd);
+		if (m_sd == iINVALID) return false;
 
 		// TODO: Figure out what this means, exactly.
 		if ((word0 & 0x000c) == 0x000c && (word0 & 0x0400) == 0x0000)
 			return false;
 
-		if (BITSn(word0,0x0400))
-			sprintf(temp, "%s,%s", ea.c_str(), SD.c_str());
-		else
-			sprintf(temp, "%s,%s", SD.c_str(), ea.c_str());
-		m_args = temp;  // TODO
-
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(c)");
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_args;	// TODO
+        std::string ea;
+        assemble_ea_from_t_table(m_t, m_value, ea);
+
+        retString = "move ";
+        if (m_W) retString += ea + "," + regIdAsString(m_sd);
+        else	 retString += regIdAsString(m_sd) + "," + ea;
+		// NEW // sprintf(opcode_str, "move(c)");
 	}
-	void evaluate(dsp56k_core* cpustate) {}
+	void evaluate(dsp56k_core* cpustate)
+    {
+        if (m_W)
+        {
+            if (m_t)
+            {
+                setReg16(cpustate, m_value, m_sd);
+            }
+            else
+            {
+                //UINT16 memValue = memory_read_word_16le(cpustate->data, ADDRESS(m_value));
+                //setReg16(cpustate, memValue, m_sd);
+            }
+        }
+        else
+        {
+            if (m_t)
+            {
+                logerror("DSP561xx|Movec_4: This sure seems like it can't happen.");
+            }
+            else
+            {
+                //UINT16 regValue = regValue16(cpustate, m_sd);
+                //memory_write_word_16le(cpustate->data, m_value, regValue);
+            }
+        }
+
+	    /* S L E U N Z V C */
+	    /* * ? ? ? ? ? ? ? */
+	    // All ? bits - If SR is specified as a destination operand, set according to the corresponding
+        // bit of the source operand. If SR is not specified as a destination operand, L is set if data
+        // limiting occurred. All ? bits are not affected otherwise.
+    }
 	size_t size() const { return 2; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_args;
+    UINT8 m_t;
+	UINT8 m_W;
+    UINT16 m_value;
+    reg_id m_sd;
 };
 
 // MOVE(C) : 0010 10dd dddD DDDD : A-144 ///////////////////////////////////////
@@ -2252,16 +2337,14 @@
 		decode_DDDDD_table(BITSn(word0,0x03e0), m_source);
 		decode_DDDDD_table(BITSn(word0,0x001f), m_destination);
 
-		if (m_source == "!!"  || m_destination == "!!") return false;
-		if (m_source == "SSH" && m_destination == "SSH") return false;
-
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(c)");
+		if (m_source == iINVALID || m_destination == iINVALID) return false;
+		if (m_source == iSSH && m_destination == iSSH) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "move " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "move(c)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2274,25 +2357,26 @@
 public:
 	Movec_6(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
 		m_b = 0;
+        m_SD = iINVALID;
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_b = BITSn(word0,0x00ff);
-
-		std::string SD;
-		decode_DDDDD_table(BITSn(word1,0x03e0), SD);
-		assemble_reg_from_W_table(BITSn(word1,0x0400), 'X', SD, m_b,
-								  m_source, m_destination);
-
-		m_opcode = "move";
-		// NEW // m_opcode = "move(c)";
+        m_W = BITSn(word1,0x0400);
+		decode_DDDDD_table(BITSn(word1,0x03e0), m_SD);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_reg_from_W_table(m_W, 'X', m_SD, m_b, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // opcode = "move(c)";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
@@ -2300,6 +2384,9 @@
 
 private:
 	INT8 m_b;
+    UINT8 m_W;
+    reg_id m_SD;
+    op_mnem m_mnem;
 };
 
 // MOVE(I) : 0010 00DD BBBB BBBB : A-150 ///////////////////////////////////////
@@ -2314,11 +2401,7 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = (INT8)BITSn(word0,0x00ff);
-
 		decode_DD_table(BITSn(word0,0x0300), m_destination);
-
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(i)");
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -2328,8 +2411,9 @@
 		else                  sprintf(temp, "#<-$%x", 1 - m_immediate - 1);
 		// NEW // sprintf(temp, "#$%02x,%s", BITSn(word0,0x00ff), D1);
 
-		retString = m_opcode + " " +
-					std::string(temp) + "," + m_destination;
+		retString = "move " +
+					std::string(temp) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "move(i)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2345,31 +2429,36 @@
 public:
 	Movem(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-
-		std::string SD;
-		std::string ea;
-		decode_HHH_table(BITSn(word0,0x0007), SD);
-		assemble_ea_from_MM_table(BITSn(word0,0x0018), rNum, ea);
-		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'P', SD, ea,
-										m_source, m_destination);
+		INT8 rNum = BITSn(word0,0x00c0);
 
-		m_opcode = "move";
-		// NEW // sprintf(opcode_str, "move(m)");
+		decode_HHH_table(BITSn(word0,0x0007), m_SD);
+		assemble_ea_from_MM_table(BITSn(word0,0x0018), rNum, m_ea);
+        m_W = BITSn(word0,0x0100);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'P', m_SD, m_ea, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(m)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MOVE(M) : 0000 001W RR11 mmRR : A-152 ///////////////////////////////////////
@@ -2378,35 +2467,42 @@
 public:
 	Movem_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_ea2 = "";
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string ea;
-		std::string ea2;
-		assemble_eas_from_mm_table(BITSn(word0,0x000c), BITSn(word0,0x00c0), BITSn(word0,0x0003), ea, ea2);
-		if (BITSn(word0,0x0100))
+        m_W = BITSn(word0,0x0100);
+		assemble_eas_from_mm_table(BITSn(word0,0x000c), BITSn(word0,0x00c0), BITSn(word0,0x0003), m_ea, m_ea2);
+		return true;
+	}
+	void disassemble(std::string& retString) const
+	{
+        std::string source;
+        std::string destination;
+		if (m_W)
 		{
-			m_source = "X:" + ea;
-			m_destination = "P:" + ea2;
+			source = "X:" + m_ea;
+			destination = "P:" + m_ea2;
 		}
 		else
 		{
-			m_source = "P:" + ea;
-			m_destination = "X:" + ea2;
+			source = "P:" + m_ea;
+			destination = "X:" + m_ea2;
 		}
-
-		m_opcode = "move";
+		retString = "move " + source + "," + destination;
 		// NEW // sprintf(opcode_str, "move(m)*");
-		return true;
-	}
-	void disassemble(std::string& retString) const
-	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    UINT8 m_W;
+    std::string m_ea;
+    std::string m_ea2;
 };
 
 // MOVE(M) : 0000 0101 BBBB BBBB 0000 001W --0- -HHH : A-152 ///////////////////
@@ -2415,29 +2511,35 @@
 public:
 	Movem_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_b = 0;
+        m_SD = iINVALID;
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 b;
-		b = BITSn(word0,0x00ff);
-
-		std::string SD;
-		decode_HHH_table(BITSn(word1,0x0007), SD);
-		assemble_reg_from_W_table(BITSn(word1,0x0100), 'P', SD, b,
-								  m_source, m_destination);
-
-		m_opcode = "move";
-		// NEW // m_opcode = "move(m)";
+		m_b = BITSn(word0,0x00ff);
+        m_W = BITSn(word1,0x0100);
+		decode_HHH_table(BITSn(word1,0x0007), m_SD);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_reg_from_W_table(m_W, 'P', m_SD, m_b, source, destination);
+		retString = "move " + source + "," + destination;
+		// NEW // opcode = "move(m)";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 2; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    INT8 m_b;
+    UINT8 m_W;
+    reg_id m_SD;
+    op_mnem m_mnem;
 };
 
 // MOVE(P) : 0001 100W HH1p pppp : A-156 ///////////////////////////////////////
@@ -2446,31 +2548,37 @@
 public:
 	Movep(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string SD;
-		decode_HH_table(BITSn(word0,0x00c0), SD);
-
-		std::string fullAddy;
-		assemble_address_from_IO_short_address(BITSn(word0,0x001f), fullAddy);
-		fullAddy = "<<$" + fullAddy;
+		decode_HH_table(BITSn(word0,0x00c0), m_SD);
 
-		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, fullAddy,
-										m_source, m_destination);
+		assemble_address_from_IO_short_address(BITSn(word0,0x001f), m_ea);
+		m_ea = "<<$" + m_ea;
 
-		m_opcode = "movep";
-		// NEW // sprintf(opcode_str, "move(p)");
+		m_W = BITSn(word0,0x0100);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "movep " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(p)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MOVE(P) : 0000 110W RRmp pppp : A-156 ///////////////////////////////////////
@@ -2479,37 +2587,41 @@
 public:
 	Movep_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
+		INT8 rNum = BITSn(word0,0x00c0);
 
-		std::string ea;
-		assemble_ea_from_m_table(BITSn(word0,0x0020), rNum, ea);
+		assemble_ea_from_m_table(BITSn(word0,0x0020), rNum, m_ea);
 
 		std::string fullAddy;	 /* Convert Short Absolute Address to full 16-bit */
 		assemble_address_from_IO_short_address(BITSn(word0,0x001f), fullAddy);
 
-		std::string SD;
-		SD = "X:<<$" + fullAddy;
+        m_W = BITSn(word0,0x0100);
+		m_SD = "X:<<$" + fullAddy;
 		// NEW // sprintf(SD, "X:$%s", fullAddy);
-
-		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, ea,
-										m_source, m_destination);
-
-		m_opcode = "movep";
-		// NEW // sprintf(opcode_str, "move(p)*");
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "movep " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(p)*");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	std::string m_SD;
+    std::string m_ea;
 };
 
 // MOVE(S) : 0001 100W HH0a aaaa : A-158 ///////////////////////////////////////
@@ -2518,32 +2630,38 @@
 public:
 	Moves(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string SD;
-		decode_HH_table(BITSn(word0,0x00c0), SD);
+		decode_HH_table(BITSn(word0,0x00c0), m_SD);
 
 		char temp[32];
-		std::string a;
 		sprintf(temp, "<$%x", BITSn(word0,0x001f));
-		a = temp;
+		m_ea = temp;
 
-		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, a,
-										m_source, m_destination);
-
-		m_opcode = "moves";
-		// NEW // sprintf(opcode_str, "move(s)");
+        m_W = BITSn(word0,0x0100);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+        std::string source;
+        std::string destination;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source, destination);
+		retString = "moves " + source + "," + destination;
+		// NEW // sprintf(opcode_str, "move(s)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
 };
 
 // MPY : .... .... 1k00 FQQQ : A-160 ///////////////////////////////////////////
@@ -2552,7 +2670,8 @@
 public:
 	Mpy(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_sign = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -2562,26 +2681,25 @@
 		decode_QQQF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_source2, m_destination);
 
-		std::string sign;
-		decode_kSign_table(BITSn(word0,0x40), sign);
-		if (sign == "-")
-			m_source = sign + m_source; // TODO: Probably silly for Instruction
-
-		m_opcode = "mpy";
+		decode_kSign_table(BITSn(word0,0x40), m_sign);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string ts = m_sign;
+        if (ts != "-") ts = "";
+		retString = "mpy " +
+                	ts +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    std::string m_sign;
+	reg_id m_source2;
 };
 
 // MPY : 011m mKKK 1xx0 F0QQ : A-160 ///////////////////////////////////////////
@@ -2590,29 +2708,27 @@
 public:
 	Mpy_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQF_table(BITSn(word0,0x03), BITSn(word0,0x08),
 						 m_source, m_source2, m_destination);
-
-		m_opcode = "mpy";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "mpy " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MPY : 0001 0110 RRDD FQQQ : A-160 ///////////////////////////////////////////
@@ -2621,29 +2737,27 @@
 public:
 	Mpy_3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQQF_table(BITSn(word0,0x0007), BITSn(word0,0x0008),
 						  m_source, m_source2, m_destination);
-
-		m_opcode = "mpy";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "mpy " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MPYR : .... .... 1k01 FQQQ : A-162 //////////////////////////////////////////
@@ -2652,7 +2766,8 @@
 public:
 	Mpyr(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_sign = "-";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -2662,26 +2777,25 @@
 		decode_QQQF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_source2, m_destination);
 
-		std::string sign;
-		decode_kSign_table(BITSn(word0,0x40), sign);
-		if (sign == "-")
-			m_source = sign + m_source; // TODO: Probably silly for Instruction
-
-		m_opcode = "mpyr";
+		decode_kSign_table(BITSn(word0,0x40), m_sign);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string ts = m_sign;
+        if (ts != "-") ts = "";
+		retString = "mpyr " +
+					ts +
+                	regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    std::string m_sign;
+	reg_id m_source2;
 };
 
 // MPYR : 011m mKKK 1--1 F0QQ : A-162 //////////////////////////////////////////
@@ -2690,29 +2804,27 @@
 public:
 	Mpyr_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_QQF_table(BITSn(word0,0x03), BITSn(word0,0x08),
 						 m_source, m_source2, m_destination);
-
-		m_opcode = "mpyr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "mpyr " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // MPY(su,uu) : 0001 0101 1100 FsQQ : A-164 ////////////////////////////////////
@@ -2721,7 +2833,8 @@
 public:
 	Mpysuuu(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+        m_mnem = oINVALID;
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -2729,24 +2842,25 @@
 		decode_QQF_special_table(BITSn(word0,0x0003), BITSn(word0,0x0008),
 								 m_source, m_source2, m_destination);
 
-		std::string a;
-		decode_s_table(BITSn(word0,0x0004), a);
-		m_opcode = "mpy" + a;
-		// NEW // sprintf(opcode_str, "mpy(%s)", A);
+		decode_s_table(BITSn(word0,0x0004), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+        std::string opcode = "mpy" + opMnemonicAsString(m_mnem);
+
+		retString = opcode + " " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "mpy(%s)", A);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+    op_mnem m_mnem;
+	reg_id m_source2;
 };
 
 // NEG : .... .... 0110 F000 : A-166 ///////////////////////////////////////////
@@ -2760,13 +2874,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "neg";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "neg " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2784,12 +2896,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-		m_opcode = "negc";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "negc " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2806,12 +2917,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "nop";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "nop";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2830,18 +2940,12 @@
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
 
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_source = temp;
-
-		m_opcode = "norm";
+		decode_RR_table(BITSn(word0,0x0003), m_source);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "norm " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2859,13 +2963,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "not";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "not " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2884,12 +2986,11 @@
 	{
 		decode_JJF_table(BITSn(word0,0x03),BITSn(word0,0x08),
 						 m_source, m_destination);
-		m_opcode = "or";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "or " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2908,10 +3009,7 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = BITSn(word0,0x00ff);
-
 		decode_EE_table(BITSn(word0,0x0600), m_destination);
-		m_opcode = "ori";
-		// NEW // sprintf(opcode_str, "or(i)");
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -2919,7 +3017,8 @@
 		char temp[32];
 		sprintf(temp, "#$%x", m_immediate);
 		// NEW // sprintf(temp, "#$%02x", BITSn(word0,0x00ff));
-		retString = m_opcode + " " + std::string(temp) + "," + m_destination;
+		retString = "ori " + std::string(temp) + "," + regIdAsString(m_destination);
+		// NEW // sprintf(opcode_str, "or(i)");
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2939,20 +3038,14 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0003), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_source = temp;
-
-		m_opcode = "rep";
+		decode_RR_table(BITSn(word0,0x0003), m_source);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
 		char temp[32];
-		sprintf(temp, "X:(%s)", m_source.c_str());
-		retString = m_opcode + " " + std::string(temp);
+		sprintf(temp, "X:(%s)", regIdAsString(m_source).c_str());
+		retString = "rep " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -2971,7 +3064,6 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		m_immediate = BITSn(word0,0x00ff);
-		m_opcode = "rep";
 		return true;
 	}
 	void disassemble(std::string& retString) const
@@ -2979,7 +3071,7 @@
 		char temp[32];
 		sprintf(temp, "#$%x", m_immediate);
 		// NEW // sprintf(temp, "#$%02x (%d)", BITSn(word0,0x00ff), BITSn(word0,0x00ff));
-		retString = m_opcode + " " + std::string(temp);
+		retString = "rep " + std::string(temp);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3000,14 +3092,12 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_DDDDD_table(BITSn(word0,0x001f), m_source);
-		if (m_source == "!!") return false;
-
-		m_opcode = "rep";
+		if (m_source == iINVALID) return false;
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source;
+		retString = "rep " + regIdAsString(m_source);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3020,23 +3110,26 @@
 public:
 	Repcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_mnem = oINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x000f), M);
-		m_opcode = "rep" + M;
-		// NEW // sprintf(opcode_str, "rep.%s", M);
+		decode_cccc_table(BITSn(word0,0x000f), m_mnem);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+        std::string opcode = "rep" + opMnemonicAsString(m_mnem);
+		retString = opcode;
+		// NEW // sprintf(opcode_str, "rep.%s", M);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    op_mnem m_mnem;
 };
 
 // RESET : 0000 0000 0000 1000 : A-186 /////////////////////////////////////////
@@ -3049,12 +3142,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "reset";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "reset";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3072,13 +3164,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "rnd";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "rnd " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3096,13 +3186,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "rol";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "rol " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3120,13 +3208,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "ror";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "ror " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3143,12 +3229,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "rti";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "rti";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3166,12 +3251,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "rts";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "rts";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3191,13 +3275,11 @@
 	{
 		decode_JF_table(BITSn(word0,0x01), BITSn(word0,0x08),
 						m_source, m_destination);
-
-		m_opcode = "sbc";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "sbc " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3214,12 +3296,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "stop";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "stop";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3238,12 +3319,11 @@
 	{
 		decode_JJJF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_destination);
-		m_opcode = "sub";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "sub " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3256,6 +3336,7 @@
 public:
 	Sub_2(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
+        m_opcode = "";
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -3268,11 +3349,14 @@
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = m_opcode + " " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
+
+private:
+    std::string m_opcode;
 };
 
 // SUBL : .... .... 0100 F001 : A-204 //////////////////////////////////////////
@@ -3288,21 +3372,19 @@
 		/* There is only one option for the F table.  This is a very strange opcode. */
 		if (!BITSn(word0,0x0008))
 		{
-			m_source = "B";
-			m_destination = "A";
+			m_source = iB;
+			m_destination = iA;
 		}
 		else
 		{
-			m_source = "A";
-			m_destination = "B";
+			m_source = iA;
+			m_destination = iB;
 		}
-
-		m_opcode = "subl";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "subl " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3320,13 +3402,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-
-		m_opcode = "swap";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "swap " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3343,12 +3423,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "swi";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "swi";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3361,7 +3440,8 @@
 public:
 	Tcc(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_destination2 = "";
+        m_mnem = oINVALID;
+		m_destination2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -3369,38 +3449,35 @@
 		decode_h0hF_table(BITSn(word0,0x0007),BITSn(word0,0x0008),
 						  m_source, m_destination);
 
-		INT8 rNum;
-		char temp[32];
-		decode_RR_table(BITSn(word0,0x0030), rNum);
-		sprintf(temp, "R%d", rNum);
-		m_destination2 = temp;
-
-		std::string M;
-		decode_cccc_table(BITSn(word0,0x03c0), M);
-		m_opcode = "t" + M;
-		// NEW // sprintf(opcode_str, "t.%s", M);
+		decode_RR_table(BITSn(word0,0x0030), m_destination2);
+
+		decode_cccc_table(BITSn(word0,0x03c0), m_mnem);
 		if (m_source != m_destination)
 			return true;
-		if (m_destination2 != "R0")
+		if (m_destination2 != iR0)
 			return true;
 
 		return false;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+        std::string opcode = "t" + opMnemonicAsString(m_mnem);
+		// NEW // sprintf(opcode_str, "t.%s", M);
+
+		retString = opcode;
 		if (m_source != m_destination)
-			retString += std::string(" ") + m_source + "," + m_destination;
+			retString += std::string(" ") + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 
-		if (m_destination2 != "R0")
-			retString += std::string(" R0,") + m_destination2;
+		if (m_destination2 != iR0)
+			retString += std::string(" R0,") + regIdAsString(m_destination2);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_destination2;
+    op_mnem m_mnem;
+	reg_id m_destination2;
 };
 
 // TFR : .... .... 0001 FJJJ : A-212 ///////////////////////////////////////////
@@ -3415,13 +3492,11 @@
 	{
 		decode_JJJF_table(BITSn(word0,0x07), BITSn(word0,0x08),
 						  m_source, m_destination);
-
-		m_opcode = "tfr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "tfr " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3440,13 +3515,11 @@
 	{
 		decode_DDF_table(BITSn(word0,0x03), BITSn(word0,0x08),
 						 m_source, m_destination);
-
-		m_opcode = "tfr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "tfr " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3465,13 +3538,11 @@
 	{
 		decode_JF_table(BITSn(word0,0x0001),BITSn(word0,0x0008),
 						m_destination, m_source);
-
-		m_opcode = "tfr2";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source + "," + m_destination;
+		retString = "tfr2 " + regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3484,8 +3555,11 @@
 public:
 	Tfr3(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
-		m_destination2 = "";
+        m_W = 0;
+        m_ea = "";
+        m_SD = iINVALID;
+		m_source2 = iINVALID;
+		m_destination2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -3493,37 +3567,35 @@
 		decode_DDF_table(BITSn(word0,0x0030), BITSn(word0,0x0008),
 						 m_destination, m_source);
 
-		std::string SD;
-		decode_HHH_table(BITSn(word0,0x0007), SD);
+		decode_HHH_table(BITSn(word0,0x0007), m_SD);
 		// If the destination of the second move is the same as the first, you're invalid
-		if (SD == m_destination && BITSn(word0,0x100)) return false;
-
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
-
-		std::string ea;
-		assemble_ea_from_m_table(BITSn(word0,0x0200), rNum, ea);
+		if (m_SD == m_destination && BITSn(word0,0x0100)) return false;
 
-		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, ea,
-										m_source2, m_destination2);
+		INT8 rNum = BITSn(word0,0x00c0);
+		assemble_ea_from_m_table(BITSn(word0,0x0200), rNum, m_ea);
 
-		m_opcode = "tfr3";
+        m_W = BITSn(word0,0x0100);
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_destination + " " +
-					m_source2 + "," + m_destination2;
+        std::string source2;
+        std::string destination2;
+		assemble_arguments_from_W_table(m_W, 'X', m_SD, m_ea, source2, destination2);
+		retString = "tfr3 " +
+					regIdAsString(m_source) + "," + regIdAsString(m_destination) + " " +
+                    source2 + "," + destination2;
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
-	std::string m_destination2;
+	INT8 m_W;
+	reg_id m_SD;
+    std::string m_ea;
+	reg_id m_source2;
+	reg_id m_destination2;
 };
 
 // TST : .... .... 0010 F001 : A-218 ///////////////////////////////////////////
@@ -3537,13 +3609,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x08), m_destination);
-
-		m_opcode = "tst";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "tst " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3561,13 +3631,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_DD_table(BITSn(word0,0x0003), m_source);
-
-		m_opcode = "tst2";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_source;
+		retString = "tst2 " + regIdAsString(m_source);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3584,12 +3652,11 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		m_opcode = "wait";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode;
+		retString = "wait";
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3607,13 +3674,11 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		decode_F_table(BITSn(word0,0x0008), m_destination);
-
-		m_opcode = "zero";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " + m_destination;
+		retString = "zero " + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
@@ -3626,7 +3691,7 @@
 public:
 	Shfl(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -3635,35 +3700,33 @@
 						  m_source, m_source2, m_destination);
 
 		// This hackery amounts to a very strange QQQF table...
-		if (m_source == "X0" && m_source2 == "X0") return false;
-		if (m_source == "X1" && m_source2 == "X0") return false;
+		if (m_source == iX0 && m_source2 == iX0) return false;
+		if (m_source == iX1 && m_source2 == iX0) return false;
 
-		if (m_source == "Y0" && m_source2 == "X1")
+		if (m_source == iY0 && m_source2 == iX1)
 		{
-			m_source  = "X1";
-			m_source2 = "Y0";
+			m_source  = iX1;
+			m_source2 = iY0;
 		}
-		if (m_source == "Y1" && m_source2 == "X1")
+		if (m_source == iY1 && m_source2 == iX1)
 		{
-			m_source  = "X1";
-			m_source2 = "Y1";
+			m_source  = iX1;
+			m_source2 = iY1;
 		}
-
-		m_opcode = "shfl";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "shfl " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 // SHFR : 0001 0101 1111 FQQQ : !!UNDOCUMENTED!! ///////////////////////////////
@@ -3672,7 +3735,7 @@
 public:
 	Shfr(const Opcode* oco, const UINT16 word0, const UINT16 word1) : Instruction(oco)
 	{
-		m_source2 = "";
+		m_source2 = iINVALID;
 		m_valid = decode(word0, word1);
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
@@ -3681,35 +3744,33 @@
 						  m_source, m_source2, m_destination);
 
 		// This hackery amounts to a very strange QQQF table...
-		if (m_source == "X0" && m_source2 == "X0") return false;
-		if (m_source == "X1" && m_source2 == "X0") return false;
+		if (m_source == iX0 && m_source2 == iX0) return false;
+		if (m_source == iX1 && m_source2 == iX0) return false;
 
-		if (m_source == "Y0" && m_source2 == "X1")
+		if (m_source == iY0 && m_source2 == iX1)
 		{
-			m_source  = "X1";
-			m_source2 = "Y0";
+			m_source  = iX1;
+			m_source2 = iY0;
 		}
-		if (m_source == "Y1" && m_source2 == "X1")
+		if (m_source == iY1 && m_source2 == iX1)
 		{
-			m_source  = "X1";
-			m_source2 = "Y1";
+			m_source  = iX1;
+			m_source2 = iY1;
 		}
-
-		m_opcode = "shfr";
 		return true;
 	}
 	void disassemble(std::string& retString) const
 	{
-		retString = m_opcode + " " +
-					m_source + "," +
-					m_source2 + "," + m_destination;
+		retString = "shfr " +
+					regIdAsString(m_source) + "," +
+					regIdAsString(m_source2) + "," + regIdAsString(m_destination);
 	}
 	void evaluate(dsp56k_core* cpustate) {}
 	size_t size() const { return 1; }
 	size_t accumulatorBitsModified() const { return BM_HIGH | BM_MIDDLE | BM_LOW; }
 
 private:
-	std::string m_source2;
+	reg_id m_source2;
 };
 
 }
diff -Nru src-old/emu/cpu/dsp56k/opcode.c src/emu/cpu/dsp56k/opcode.c
--- src-old/emu/cpu/dsp56k/opcode.c	2010-08-07 11:42:59.000000000 -0700
+++ src/emu/cpu/dsp56k/opcode.c	2010-08-19 08:40:06.000000000 -0700
@@ -67,8 +67,8 @@
 }
 
 
-const std::string& Opcode::instSource() const { return m_instruction->source(); }
-const std::string& Opcode::instDestination() const { return m_instruction->destination(); }
+const reg_id& Opcode::instSource() const { return m_instruction->source(); }
+const reg_id& Opcode::instDestination() const { return m_instruction->destination(); }
 const size_t Opcode::instAccumulatorBitsModified() const { return m_instruction->accumulatorBitsModified(); }
 
 std::string Opcode::dcString() const
diff -Nru src-old/emu/cpu/dsp56k/opcode.h src/emu/cpu/dsp56k/opcode.h
--- src-old/emu/cpu/dsp56k/opcode.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/opcode.h	2010-08-30 08:20:58.000000000 -0700
@@ -30,8 +30,8 @@
 	size_t evalSize() const;
 
 	// Peek through to the instruction
-	const std::string& instSource() const;
-	const std::string& instDestination() const;
+	const reg_id& instSource() const;
+	const reg_id& instDestination() const;
 	const size_t instAccumulatorBitsModified() const;
 
 private:
diff -Nru src-old/emu/cpu/dsp56k/pmove.c src/emu/cpu/dsp56k/pmove.c
--- src-old/emu/cpu/dsp56k/pmove.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/pmove.c	2010-08-30 08:20:58.000000000 -0700
@@ -3,8 +3,8 @@
 namespace DSP56K
 {
 
-const std::string& ParallelMove::opSource() const { return m_oco->instSource(); }
-const std::string& ParallelMove::opDestination() const { return m_oco->instDestination(); }
+const reg_id& ParallelMove::opSource() const { return m_oco->instSource(); }
+const reg_id& ParallelMove::opDestination() const { return m_oco->instDestination(); }
 const size_t ParallelMove::opAccumulatorBitsModified() const { return m_oco->instAccumulatorBitsModified(); }
 
 
diff -Nru src-old/emu/cpu/dsp56k/pmove.h src/emu/cpu/dsp56k/pmove.h
--- src-old/emu/cpu/dsp56k/pmove.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/pmove.h	2010-08-30 08:20:58.000000000 -0700
@@ -30,8 +30,8 @@
 	const bool valid() const { return m_valid; }
 
 	// Peek through the opcode to see the instruction
-	const std::string& opSource() const;
-	const std::string& opDestination() const;
+	const reg_id& opSource() const;
+	const reg_id& opDestination() const;
 	const size_t opAccumulatorBitsModified() const;
 
 protected:
@@ -54,20 +54,20 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x3000), rNum);
+		reg_id r;
+		decode_RR_table(BITSn(word0,0x3000), r);
 
-		std::string SD;
+		reg_id SD;
 		decode_HHH_table(BITSn(word0,0x0e00), SD);
 
 		std::string ea;
-		assemble_ea_from_m_table(BITSn(word0,0x4000), rNum, ea);
+		assemble_ea_from_m_table(BITSn(word0,0x4000), regIDAsNum(r), ea);
 
 		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, ea,
 										m_source, m_destination);
 
 		// If the destination of the instruction overlaps with our destination, abort.
-		if (registerOverlap(opDestination(), opAccumulatorBitsModified(), m_destination))
+		if (registerOverlap(opDestination(), opAccumulatorBitsModified(), stringAsRegID(m_destination)))
 			return false;
 
 		return true;
@@ -95,21 +95,21 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		std::string ea;
-		if (opDestination() == "B")
+		if (opDestination() == iB)
 			ea = "(A1)";
-		else if (opDestination() == "A")
+		else if (opDestination() == iA)
 			ea = "(B1)";
 		else
 			ea = "(A1)";
 
-		std::string SD;
+		reg_id SD;
 		decode_HHH_table(BITSn(word0,0x0e00), SD);
 
 		assemble_arguments_from_W_table(BITSn(word0,0x0100), 'X', SD, ea,
 										m_source, m_destination);
 
 		// If the destination of the instruction overlaps with our destination, abort.
-		if (registerOverlap(opDestination(), opAccumulatorBitsModified(), m_destination))
+		if (registerOverlap(opDestination(), opAccumulatorBitsModified(), stringAsRegID(m_destination)))
 			return false;
 
 		return true;
@@ -136,34 +136,34 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		std::string D1 = "";
-		std::string D2 = "";
+		reg_id r;
+		reg_id D1;
+		reg_id D2;
 		std::string ea1 = "";
 		std::string ea2 = "";
 
-		decode_rr_table(BITSn(word0,0x0060), rNum);
+		decode_rr_table(BITSn(word0,0x0060), r);
 		decode_KKK_table(BITSn(word0,0x0700), D1, D2);
-		assemble_eas_from_mm_table(BITSn(word0,0x1800), rNum, 3, ea1, ea2);
+		assemble_eas_from_mm_table(BITSn(word0,0x1800), regIDAsNum(r), 3, ea1, ea2);
 
 		/* Not documented, but extrapolated from docs on page A-133 */
-		if (D1 == "^F")
+		if (D1 == iFHAT)
 		{
-			if (opDestination() == "B")
-				D1 = "A";
-			else if (opDestination() == "A")
-				D1 = "B";
+			if (opDestination() == iB)
+				D1 = iA;
+			else if (opDestination() == iA)
+				D1 = iB;
 			else
-				D1 = "A";   /* In the case of no data ALU instruction */
+				D1 = iA;   /* In the case of no data ALU instruction */
 		}
 
 		/* D1 and D2 may not specify the same register : A-142 */
-		if (rNum == 3) return false;
+		if (r == iR3) return false;
 
 		char temp[32];
-		sprintf(temp,  "X:%s,%s", ea1.c_str(), D1.c_str());
+		sprintf(temp,  "X:%s,%s", ea1.c_str(), regIdAsString(D1).c_str());
 		parallelMove = temp;
-		sprintf(temp, "X:%s,%s", ea2.c_str(), D2.c_str());
+		sprintf(temp, "X:%s,%s", ea2.c_str(), regIdAsString(D2).c_str());
 		parallelMove2 = temp;
 
 		return true;
@@ -193,20 +193,20 @@
 		decode_IIIIx_table(BITSn(word0,0x0f00), BITSn(word0,0x0008),
 						   m_source, m_destination);
 
-		if (m_source == "!")
+		if (m_source == iINVALID)
 			return false;
 
-		if (m_source == "F")
+		if (m_source == iF)
 			m_source = opDestination();
 
-		if (m_destination == "^F")
+		if (m_destination == iFHAT)
 		{
-			if (opDestination() == "B")
-				m_destination = "A";
-			else if (opDestination() == "A")
-				m_destination = "B";
+			if (opDestination() == iB)
+				m_destination = iA;
+			else if (opDestination() == iA)
+				m_destination = iB;
 			else
-				m_destination = "A";	/* In the case of no data ALU instruction */
+				m_destination = iA;	/* In the case of no data ALU instruction */
 		}
 
 		// Don't return a failure, just let everything fall through (nop).
@@ -218,16 +218,16 @@
 	void disassemble(std::string& retString) const
 	{
 		// (?,?) is a parallel nop
-		if (m_source == "?" && m_destination == "?")
+		if (m_source == iWEIRD && m_destination == iWEIRD)
 			retString = "";
 		else
-			retString = m_source + "," + m_destination;
+			retString = regIdAsString(m_source) + "," + regIdAsString(m_destination);
 	}
 	void evaluate() {}
 
 private:
-	std::string m_source;
-	std::string m_destination;
+	reg_id m_source;
+	reg_id m_destination;
 };
 
 
@@ -243,21 +243,21 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		std::string S;
-		std::string Dnot;
+		reg_id r;
+		reg_id S;
+		reg_id Dnot;
 		char parallel_move_str[128];
 		char parallel_move_str2[128];
 
-		if (opDestination() == "A") Dnot = "B";
-		else                        Dnot = "A";
+		if (opDestination() == iA) Dnot = iB;
+		else                       Dnot = iA;
 
 		// NEW // decode_k_table(BITSn(word0,0x0100), Dnot);
-		decode_RR_table(BITSn(word0,0x00c0), rNum);
+		decode_RR_table(BITSn(word0,0x00c0), r);
 		decode_DD_table(BITSn(word0,0x0030), S);
 
-		sprintf(parallel_move_str,  "%s,X:(R%d)+N%d", Dnot.c_str(), rNum, rNum);
-		sprintf(parallel_move_str2, "%s,%s", S.c_str(), Dnot.c_str());
+		sprintf(parallel_move_str,  "%s,X:(R%d)+N%d", regIdAsString(Dnot).c_str(), regIDAsNum(r), regIDAsNum(r));
+		sprintf(parallel_move_str2, "%s,%s", regIdAsString(S).c_str(), regIdAsString(Dnot).c_str());
 		pms = parallel_move_str;
 		pms2 = parallel_move_str2;
 		return true;
@@ -285,9 +285,9 @@
 	}
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
-		INT8 rNum;
-		decode_RR_table(BITSn(word0,0x0300), rNum);
-		assemble_ea_from_z_table(BITSn(word0,0x0400), rNum, m_ea);
+		reg_id r;
+		decode_RR_table(BITSn(word0,0x0300), r);
+		assemble_ea_from_z_table(BITSn(word0,0x0400), regIDAsNum(r), m_ea);
 
 		return true;
 	}
@@ -315,7 +315,7 @@
 	bool decode(const UINT16 word0, const UINT16 word1)
 	{
 		INT8 b;
-		std::string SD;
+		reg_id SD;
 		std::string args;
 
 		b = (char)(word0 & 0x00ff);
diff -Nru src-old/emu/cpu/dsp56k/tables.c src/emu/cpu/dsp56k/tables.c
--- src-old/emu/cpu/dsp56k/tables.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/tables.c	2010-08-30 08:20:58.000000000 -0700
@@ -4,6 +4,7 @@
 #include <cstdlib>
 
 #include "tables.h"
+#include "dsp56def.h"
 
 namespace DSP56K
 {
@@ -11,7 +12,7 @@
 /******************/
 /* Table decoding */
 /******************/
-int decode_BBB_table(UINT16 BBB)
+bfShift decode_BBB_table(UINT16 BBB)
 {
 	switch(BBB)
 	{
@@ -23,26 +24,26 @@
 	return BBB_INVALID;
 }
 
-void decode_cccc_table(const UINT16 cccc, std::string& mnemonic)
+void decode_cccc_table(const UINT16 cccc, op_mnem& mnemonic)
 {
 	switch (cccc)
 	{
-		case 0x0: mnemonic = "cc"; break;
-		case 0x1: mnemonic = "ge"; break;
-		case 0x2: mnemonic = "ne"; break;
-		case 0x3: mnemonic = "pl"; break;
-		case 0x4: mnemonic = "nn"; break;
-		case 0x5: mnemonic = "ec"; break;
-		case 0x6: mnemonic = "lc"; break;
-		case 0x7: mnemonic = "gt"; break;
-		case 0x8: mnemonic = "cs"; break;
-		case 0x9: mnemonic = "lt"; break;
-		case 0xa: mnemonic = "eq"; break;
-		case 0xb: mnemonic = "mi"; break;
-		case 0xc: mnemonic = "nr"; break;
-		case 0xd: mnemonic = "es"; break;
-		case 0xe: mnemonic = "ls"; break;
-		case 0xf: mnemonic = "le"; break;
+		case 0x0: mnemonic = oCC; break;
+		case 0x1: mnemonic = oGE; break;
+		case 0x2: mnemonic = oNE; break;
+		case 0x3: mnemonic = oPL; break;
+		case 0x4: mnemonic = oNN; break;
+		case 0x5: mnemonic = oEC; break;
+		case 0x6: mnemonic = oLC; break;
+		case 0x7: mnemonic = oGT; break;
+		case 0x8: mnemonic = oCS; break;
+		case 0x9: mnemonic = oLT; break;
+		case 0xa: mnemonic = oEQ; break;
+		case 0xb: mnemonic = oMI; break;
+		case 0xc: mnemonic = oNR; break;
+		case 0xd: mnemonic = oES; break;
+		case 0xe: mnemonic = oLS; break;
+		case 0xf: mnemonic = oLE; break;
 	}
 
 // NEW //   switch (cccc)
@@ -66,212 +67,212 @@
 // NEW //   }
 }
 
-void decode_DDDDD_table(const UINT16 DDDDD, std::string& SD)
+void decode_DDDDD_table(const UINT16 DDDDD, reg_id& SD)
 {
 	switch(DDDDD)
 	{
-		case 0x00: SD = "X0";  break;
-		case 0x01: SD = "Y0";  break;
-		case 0x02: SD = "X1";  break;
-		case 0x03: SD = "Y1";  break;
-		case 0x04: SD = "A";   break;
-		case 0x05: SD = "B";   break;
-		case 0x06: SD = "A0";  break;
-		case 0x07: SD = "B0";  break;
-		case 0x08: SD = "LC";  break;
-		case 0x09: SD = "SR";  break;
-		case 0x0a: SD = "OMR"; break;
-		case 0x0b: SD = "SP";  break;
-		case 0x0c: SD = "A1";  break;
-		case 0x0d: SD = "B1";  break;
-		case 0x0e: SD = "A2";  break;
-		case 0x0f: SD = "B2";  break;
-
-		case 0x10: SD = "R0";  break;
-		case 0x11: SD = "R1";  break;
-		case 0x12: SD = "R2";  break;
-		case 0x13: SD = "R3";  break;
-		case 0x14: SD = "M0";  break;
-		case 0x15: SD = "M1";  break;
-		case 0x16: SD = "M2";  break;
-		case 0x17: SD = "M3";  break;
-		case 0x18: SD = "SSH"; break;
-		case 0x19: SD = "SSL"; break;
-		case 0x1a: SD = "LA";  break;
-		case 0x1b: SD = "!!";  break; /* no 0x1b */
-		case 0x1c: SD = "N0";  break;
-		case 0x1d: SD = "N1";  break;
-		case 0x1e: SD = "N2";  break;
-		case 0x1f: SD = "N3";  break;
+		case 0x00: SD = iX0;  break;
+		case 0x01: SD = iY0;  break;
+		case 0x02: SD = iX1;  break;
+		case 0x03: SD = iY1;  break;
+		case 0x04: SD = iA;   break;
+		case 0x05: SD = iB;   break;
+		case 0x06: SD = iA0;  break;
+		case 0x07: SD = iB0;  break;
+		case 0x08: SD = iLC;  break;
+		case 0x09: SD = iSR;  break;
+		case 0x0a: SD = iOMR; break;
+		case 0x0b: SD = iSP;  break;
+		case 0x0c: SD = iA1;  break;
+		case 0x0d: SD = iB1;  break;
+		case 0x0e: SD = iA2;  break;
+		case 0x0f: SD = iB2;  break;
+
+		case 0x10: SD = iR0;  break;
+		case 0x11: SD = iR1;  break;
+		case 0x12: SD = iR2;  break;
+		case 0x13: SD = iR3;  break;
+		case 0x14: SD = iM0;  break;
+		case 0x15: SD = iM1;  break;
+		case 0x16: SD = iM2;  break;
+		case 0x17: SD = iM3;  break;
+		case 0x18: SD = iSSH; break;
+		case 0x19: SD = iSSL; break;
+		case 0x1a: SD = iLA;  break;
+		case 0x1b: SD = iINVALID;  break; /* no 0x1b */
+		case 0x1c: SD = iN0;  break;
+		case 0x1d: SD = iN1;  break;
+		case 0x1e: SD = iN2;  break;
+		case 0x1f: SD = iN3;  break;
 	}
 }
 
-void decode_DD_table(const UINT16 DD, std::string& SD)
+void decode_DD_table(const UINT16 DD, reg_id& SD)
 {
 	switch (DD)
 	{
-		case 0x0: SD = "X0"; break;
-		case 0x1: SD = "Y0"; break;
-		case 0x2: SD = "X1"; break;
-		case 0x3: SD = "Y1"; break;
+		case 0x0: SD = iX0; break;
+		case 0x1: SD = iY0; break;
+		case 0x2: SD = iX1; break;
+		case 0x3: SD = iY1; break;
 	}
 }
 
-void decode_DDF_table(const UINT16 DD, const UINT16 F, std::string& S, std::string& D)
+void decode_DDF_table(const UINT16 DD, const UINT16 F, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (DD << 1) | F;
 
 	switch (switchVal)
 	{
-		case 0x0: S = "X0"; D = "A"; break;
-		case 0x1: S = "X0"; D = "B"; break;
-		case 0x2: S = "Y0"; D = "A"; break;
-		case 0x3: S = "Y0"; D = "B"; break;
-		case 0x4: S = "X1"; D = "A"; break;
-		case 0x5: S = "X1"; D = "B"; break;
-		case 0x6: S = "Y1"; D = "A"; break;
-		case 0x7: S = "Y1"; D = "B"; break;
+		case 0x0: S = iX0; D = iA; break;
+		case 0x1: S = iX0; D = iB; break;
+		case 0x2: S = iY0; D = iA; break;
+		case 0x3: S = iY0; D = iB; break;
+		case 0x4: S = iX1; D = iA; break;
+		case 0x5: S = iX1; D = iB; break;
+		case 0x6: S = iY1; D = iA; break;
+		case 0x7: S = iY1; D = iB; break;
 	}
 }
 
-void decode_EE_table(const UINT16 EE, std::string& D)
+void decode_EE_table(const UINT16 EE, reg_id& D)
 {
 	switch(EE)
 	{
-		case 0x1: D = "MR";  break;
-		case 0x3: D = "CCR"; break;
-		case 0x2: D = "OMR"; break;
+		case 0x1: D = iMR;  break;
+		case 0x3: D = iCCR; break;
+		case 0x2: D = iOMR; break;
 	}
 }
 
-void decode_F_table(const UINT16 F, std::string& SD)
+void decode_F_table(const UINT16 F, reg_id& SD)
 {
 	switch(F)
 	{
-		case 0x0: SD = "A"; break;
-		case 0x1: SD = "B"; break;
+		case 0x0: SD = iA; break;
+		case 0x1: SD = iB; break;
 	}
 }
 
-void decode_h0hF_table(const UINT16 h0h, UINT16 F, std::string& S, std::string& D)
+void decode_h0hF_table(const UINT16 h0h, UINT16 F, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (h0h << 1) | F;
 
 	switch (switchVal)
 	{
-		case 0x8: S = "X0"; D = "A"; break;
-		case 0x9: S = "X0"; D = "B"; break;
-		case 0xa: S = "Y0"; D = "A"; break;
-		case 0xb: S = "Y0"; D = "B"; break;
-		case 0x2: S = "A";  D = "A"; break;
-		case 0x1: S = "A";  D = "B"; break;
-		case 0x0: S = "B";  D = "A"; break;
-		case 0x3: S = "B";  D = "B"; break;
+		case 0x8: S = iX0; D = iA; break;
+		case 0x9: S = iX0; D = iB; break;
+		case 0xa: S = iY0; D = iA; break;
+		case 0xb: S = iY0; D = iB; break;
+		case 0x2: S = iA;  D = iA; break;
+		case 0x1: S = iA;  D = iB; break;
+		case 0x0: S = iB;  D = iA; break;
+		case 0x3: S = iB;  D = iB; break;
 	}
 }
 
-void decode_HH_table(const UINT16 HH, std::string& SD)
+void decode_HH_table(const UINT16 HH, reg_id& SD)
 {
 	switch(HH)
 	{
-		case 0x0: SD = "X0"; break;
-		case 0x1: SD = "Y0"; break;
-		case 0x2: SD = "A";  break;
-		case 0x3: SD = "B";  break;
+		case 0x0: SD = iX0; break;
+		case 0x1: SD = iY0; break;
+		case 0x2: SD = iA;  break;
+		case 0x3: SD = iB;  break;
 	}
 }
 
-void decode_HHH_table(const UINT16 HHH, std::string& SD)
+void decode_HHH_table(const UINT16 HHH, reg_id& SD)
 {
 	switch(HHH)
 	{
-		case 0x0: SD = "X0"; break;
-		case 0x1: SD = "Y0"; break;
-		case 0x2: SD = "X1"; break;
-		case 0x3: SD = "Y1"; break;
-		case 0x4: SD = "A";  break;
-		case 0x5: SD = "B";  break;
-		case 0x6: SD = "A0"; break;
-		case 0x7: SD = "B0"; break;
+		case 0x0: SD = iX0; break;
+		case 0x1: SD = iY0; break;
+		case 0x2: SD = iX1; break;
+		case 0x3: SD = iY1; break;
+		case 0x4: SD = iA;  break;
+		case 0x5: SD = iB;  break;
+		case 0x6: SD = iA0; break;
+		case 0x7: SD = iB0; break;
 	}
 }
 
-void decode_IIIIx_table(const UINT16 IIII, const UINT16 x, std::string& S, std::string& D)
+void decode_IIIIx_table(const UINT16 IIII, const UINT16 x, reg_id& S, reg_id& D)
 {
-	S = D = "!";
+	S = D = iINVALID;
 	switch(IIII)
 	{
-		case 0x0: S = "X0"; D = "^F"; break;
-		case 0x1: S = "Y0"; D = "^F"; break;
-		case 0x2: S = "X1"; D = "^F"; break;
-		case 0x3: S = "Y1"; D = "^F"; break;
-		case 0x4: S = "A";  D = "X0"; break;
-		case 0x5: S = "B";  D = "Y0"; break;
-		case 0x6: S = "A0"; D = "X0"; break;
-		case 0x7: S = "B0"; D = "Y0"; break;
-		case 0x8: if ( x) S = "F";  D = "^F"; break;
-		case 0x9: if (!x) S = "F";  D = "^F"; break;
-		case 0xa: S = "?";  D = "?";  break;
-		case 0xb: S = "?";  D = "?";  break;
-		case 0xc: S = "A";  D = "X1"; break;
-		case 0xd: S = "B";  D = "Y1"; break;
-		case 0xe: S = "A0"; D = "X1"; break;
-		case 0xf: S = "B0"; D = "Y1"; break;
+		case 0x0: S = iX0; D = iFHAT; break;
+		case 0x1: S = iY0; D = iFHAT; break;
+		case 0x2: S = iX1; D = iFHAT; break;
+		case 0x3: S = iY1; D = iFHAT; break;
+		case 0x4: S = iA;  D = iX0; break;
+		case 0x5: S = iB;  D = iY0; break;
+		case 0x6: S = iA0; D = iX0; break;
+		case 0x7: S = iB0; D = iY0; break;
+		case 0x8: if ( x) S = iF;  D = iFHAT; break;
+		case 0x9: if (!x) S = iF;  D = iFHAT; break;
+		case 0xa: S = iWEIRD;  D = iWEIRD; break;
+		case 0xb: S = iWEIRD;  D = iWEIRD; break;
+		case 0xc: S = iA;  D = iX1; break;
+		case 0xd: S = iB;  D = iY1; break;
+		case 0xe: S = iA0; D = iX1; break;
+		case 0xf: S = iB0; D = iY1; break;
 	}
 }
 
-void decode_JJJF_table(const UINT16 JJJ, const UINT16 F, std::string& S, std::string& D)
+void decode_JJJF_table(const UINT16 JJJ, const UINT16 F, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (JJJ << 1) | F;
 
 	switch(switchVal)
 	{
-		case 0x0: S = "B";  D = "A"; break;
-		case 0x1: S = "A";  D = "B"; break;
-		case 0x2: S = "!";  D = "!"; break;
-		case 0x3: S = "!";  D = "!"; break;
-		case 0x4: S = "X";  D = "A"; break;
-		case 0x5: S = "X";  D = "B"; break;
-		case 0x6: S = "Y";  D = "A"; break;
-		case 0x7: S = "Y";  D = "B"; break;
-		case 0x8: S = "X0"; D = "A"; break;
-		case 0x9: S = "X0"; D = "B"; break;
-		case 0xa: S = "Y0"; D = "A"; break;
-		case 0xb: S = "Y0"; D = "B"; break;
-		case 0xc: S = "X1"; D = "A"; break;
-		case 0xd: S = "X1"; D = "B"; break;
-		case 0xe: S = "Y1"; D = "A"; break;
-		case 0xf: S = "Y1"; D = "B"; break;
+		case 0x0: S = iB;  D = iA; break;
+		case 0x1: S = iA;  D = iB; break;
+		case 0x2: S = iINVALID; D = iINVALID; break;
+		case 0x3: S = iINVALID; D = iINVALID; break;
+		case 0x4: S = iX;  D = iA; break;
+		case 0x5: S = iX;  D = iB; break;
+		case 0x6: S = iY;  D = iA; break;
+		case 0x7: S = iY;  D = iB; break;
+		case 0x8: S = iX0; D = iA; break;
+		case 0x9: S = iX0; D = iB; break;
+		case 0xa: S = iY0; D = iA; break;
+		case 0xb: S = iY0; D = iB; break;
+		case 0xc: S = iX1; D = iA; break;
+		case 0xd: S = iX1; D = iB; break;
+		case 0xe: S = iY1; D = iA; break;
+		case 0xf: S = iY1; D = iB; break;
 	}
 }
 
-void decode_JJF_table(const UINT16 JJ, const UINT16 F, std::string& S, std::string& D)
+void decode_JJF_table(const UINT16 JJ, const UINT16 F, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (JJ << 1) | F;
 
 	switch (switchVal)
 	{
-		case 0x0: S = "X0"; D = "A"; break;
-		case 0x1: S = "X0"; D = "B"; break;
-		case 0x2: S = "Y0"; D = "A"; break;
-		case 0x3: S = "Y0"; D = "B"; break;
-		case 0x4: S = "X1"; D = "A"; break;
-		case 0x5: S = "X1"; D = "B"; break;
-		case 0x6: S = "Y1"; D = "A"; break;
-		case 0x7: S = "Y1"; D = "B"; break;
+		case 0x0: S = iX0; D = iA; break;
+		case 0x1: S = iX0; D = iB; break;
+		case 0x2: S = iY0; D = iA; break;
+		case 0x3: S = iY0; D = iB; break;
+		case 0x4: S = iX1; D = iA; break;
+		case 0x5: S = iX1; D = iB; break;
+		case 0x6: S = iY1; D = iA; break;
+		case 0x7: S = iY1; D = iB; break;
 	}
 }
 
-void decode_JF_table(const UINT16 J, const UINT16 F, std::string& S, std::string& D)
+void decode_JF_table(const UINT16 J, const UINT16 F, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (J << 1) | F;
 
 	switch(switchVal)
 	{
-		case 0x0: S = "X"; D = "A"; break;
-		case 0x1: S = "X"; D = "B"; break;
-		case 0x2: S = "Y"; D = "A"; break;
-		case 0x3: S = "Y"; D = "B"; break;
+		case 0x0: S = iX; D = iA; break;
+		case 0x1: S = iX; D = iB; break;
+		case 0x2: S = iY; D = iA; break;
+		case 0x3: S = iY; D = iB; break;
 	}
 }
 
@@ -293,160 +294,184 @@
 	}
 }
 
-void decode_KKK_table(const UINT16 KKK, std::string& D1, std::string& D2)
+void decode_KKK_table(const UINT16 KKK, reg_id& D1, reg_id& D2)
 {
 	switch(KKK)
 	{
-		case 0x0: D1 = "^F"; D2 = "X0"; break;
-		case 0x1: D1 = "Y0"; D2 = "X0"; break;
-		case 0x2: D1 = "X1"; D2 = "X0"; break;
-		case 0x3: D1 = "Y1"; D2 = "X0"; break;
-		case 0x4: D1 = "X0"; D2 = "X1"; break;
-		case 0x5: D1 = "Y0"; D2 = "X1"; break;
-		case 0x6: D1 = "^F"; D2 = "Y0"; break;
-		case 0x7: D1 = "Y1"; D2 = "X1"; break;
+		case 0x0: D1 = iFHAT; D2 = iX0; break;
+		case 0x1: D1 = iY0;   D2 = iX0; break;
+		case 0x2: D1 = iX1;   D2 = iX0; break;
+		case 0x3: D1 = iY1;   D2 = iX0; break;
+		case 0x4: D1 = iX0;   D2 = iX1; break;
+		case 0x5: D1 = iY0;   D2 = iX1; break;
+		case 0x6: D1 = iFHAT; D2 = iY0; break;
+		case 0x7: D1 = iY1;   D2 = iX1; break;
 	}
 }
 
-void decode_NN_table(UINT16 NN, INT8& ret)
+void decode_NN_table(UINT16 NN, reg_id& ret)
 {
-	ret = NN;
+	switch(NN)
+    {
+        case 0x0: ret = iN0; break;
+        case 0x1: ret = iN1; break;
+        case 0x2: ret = iN2; break;
+        case 0x3: ret = iN3; break;
+    }
 }
 
-void decode_TT_table(UINT16 TT, INT8& ret)
+void decode_TT_table(UINT16 TT, reg_id& ret)
 {
-	ret = TT;
+	switch(TT)
+    {
+        case 0x0: ret = iR0; break;
+        case 0x1: ret = iR1; break;
+        case 0x2: ret = iR2; break;
+        case 0x3: ret = iR3; break;
+    }
 }
 
-void decode_QQF_table(const UINT16 QQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D)
+void decode_QQF_table(const UINT16 QQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D)
 {
 	const UINT16 switchVal = (QQ << 1) | F;
 
 	switch(switchVal)
 	{
-		case 0x0: S1 = "Y0"; S2 = "X0"; D = "A"; break;
-		case 0x1: S1 = "Y0"; S2 = "X0"; D = "B"; break;
-		case 0x2: S1 = "Y1"; S2 = "X0"; D = "A"; break;
-		case 0x3: S1 = "Y1"; S2 = "X0"; D = "B"; break;
-		case 0x4: S1 = "Y0"; S2 = "X1"; D = "A"; break;
-		case 0x5: S1 = "Y0"; S2 = "X1"; D = "B"; break;
-		case 0x6: S1 = "Y1"; S2 = "X1"; D = "A"; break;
-		case 0x7: S1 = "Y1"; S2 = "X1"; D = "B"; break;
+		case 0x0: S1 = iY0; S2 = iX0; D = iA; break;
+		case 0x1: S1 = iY0; S2 = iX0; D = iB; break;
+		case 0x2: S1 = iY1; S2 = iX0; D = iA; break;
+		case 0x3: S1 = iY1; S2 = iX0; D = iB; break;
+		case 0x4: S1 = iY0; S2 = iX1; D = iA; break;
+		case 0x5: S1 = iY0; S2 = iX1; D = iB; break;
+		case 0x6: S1 = iY1; S2 = iX1; D = iA; break;
+		case 0x7: S1 = iY1; S2 = iX1; D = iB; break;
 	}
 }
 
-void decode_QQF_special_table(const UINT16 QQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D)
+void decode_QQF_special_table(const UINT16 QQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D)
 {
 	const UINT16 switchVal = (QQ << 1) | F;
 
 	switch(switchVal)
 	{
-		case 0x0: S1 = "Y0"; S2 = "X0"; D = "A"; break;
-		case 0x1: S1 = "Y0"; S2 = "X0"; D = "B"; break;
-		case 0x2: S1 = "Y1"; S2 = "X0"; D = "A"; break;
-		case 0x3: S1 = "Y1"; S2 = "X0"; D = "B"; break;
-		case 0x4: S1 = "X1"; S2 = "Y0"; D = "A"; break;
-		case 0x5: S1 = "X1"; S2 = "Y0"; D = "B"; break;
-		case 0x6: S1 = "X1"; S2 = "Y1"; D = "A"; break;
-		case 0x7: S1 = "X1"; S2 = "Y1"; D = "B"; break;
+		case 0x0: S1 = iY0; S2 = iX0; D = iA; break;
+		case 0x1: S1 = iY0; S2 = iX0; D = iB; break;
+		case 0x2: S1 = iY1; S2 = iX0; D = iA; break;
+		case 0x3: S1 = iY1; S2 = iX0; D = iB; break;
+		case 0x4: S1 = iX1; S2 = iY0; D = iA; break;
+		case 0x5: S1 = iX1; S2 = iY0; D = iB; break;
+		case 0x6: S1 = iX1; S2 = iY1; D = iA; break;
+		case 0x7: S1 = iX1; S2 = iY1; D = iB; break;
 	}
 }
 
-void decode_QQQF_table(const UINT16 QQQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D)
+void decode_QQQF_table(const UINT16 QQQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D)
 {
 	const UINT16 switchVal = (QQQ << 1) | F;
 
 	switch(switchVal)
 	{
-		case 0x0: S1 = "X0"; S2 = "X0"; D = "A"; break;
-		case 0x1: S1 = "X0"; S2 = "X0"; D = "B"; break;
-		case 0x2: S1 = "X1"; S2 = "X0"; D = "A"; break;
-		case 0x3: S1 = "X1"; S2 = "X0"; D = "B"; break;
-		case 0x4: S1 = "A1"; S2 = "Y0"; D = "A"; break;
-		case 0x5: S1 = "A1"; S2 = "Y0"; D = "B"; break;
-		case 0x6: S1 = "B1"; S2 = "X0"; D = "A"; break;
-		case 0x7: S1 = "B1"; S2 = "X0"; D = "B"; break;
-		case 0x8: S1 = "Y0"; S2 = "X0"; D = "A"; break;
-		case 0x9: S1 = "Y0"; S2 = "X0"; D = "B"; break;
-		case 0xa: S1 = "Y1"; S2 = "X0"; D = "A"; break;
-		case 0xb: S1 = "Y1"; S2 = "X0"; D = "B"; break;
-		case 0xc: S1 = "Y0"; S2 = "X1"; D = "A"; break;
-		case 0xd: S1 = "Y0"; S2 = "X1"; D = "B"; break;
-		case 0xe: S1 = "Y1"; S2 = "X1"; D = "A"; break;
-		case 0xf: S1 = "Y1"; S2 = "X1"; D = "B"; break;
+		case 0x0: S1 = iX0; S2 = iX0; D = iA; break;
+		case 0x1: S1 = iX0; S2 = iX0; D = iB; break;
+		case 0x2: S1 = iX1; S2 = iX0; D = iA; break;
+		case 0x3: S1 = iX1; S2 = iX0; D = iB; break;
+		case 0x4: S1 = iA1; S2 = iY0; D = iA; break;
+		case 0x5: S1 = iA1; S2 = iY0; D = iB; break;
+		case 0x6: S1 = iB1; S2 = iX0; D = iA; break;
+		case 0x7: S1 = iB1; S2 = iX0; D = iB; break;
+		case 0x8: S1 = iY0; S2 = iX0; D = iA; break;
+		case 0x9: S1 = iY0; S2 = iX0; D = iB; break;
+		case 0xa: S1 = iY1; S2 = iX0; D = iA; break;
+		case 0xb: S1 = iY1; S2 = iX0; D = iB; break;
+		case 0xc: S1 = iY0; S2 = iX1; D = iA; break;
+		case 0xd: S1 = iY0; S2 = iX1; D = iB; break;
+		case 0xe: S1 = iY1; S2 = iX1; D = iA; break;
+		case 0xf: S1 = iY1; S2 = iX1; D = iB; break;
 	}
 }
 
-void decode_RR_table(UINT16 RR, INT8& ret)
-{
-	ret = RR;
+void decode_RR_table(UINT16 RR, reg_id& ret)
+{
+	switch(RR)
+    {
+        case 0x0: ret = iR0; break;
+        case 0x1: ret = iR1; break;
+        case 0x2: ret = iR2; break;
+        case 0x3: ret = iR3; break;
+    }
+}
+
+void decode_rr_table(UINT16 rr, reg_id& ret)
+{
+	switch(rr)
+    {
+        case 0x0: ret = iR0; break;
+        case 0x1: ret = iR1; break;
+        case 0x2: ret = iR2; break;
+        case 0x3: ret = iR3; break;
+    }
 }
 
-void decode_rr_table(UINT16 rr, INT8& ret)
-{
-	ret = rr;
-}
-
-void decode_s_table(const UINT16 s, std::string& arithmetic)
+void decode_s_table(const UINT16 s, op_mnem& arithmetic)
 {
 	switch(s)
 	{
-		case 0x0: arithmetic = "su"; break;
-		case 0x1: arithmetic = "uu"; break;
+		case 0x0: arithmetic = oSU; break;
+		case 0x1: arithmetic = oUU; break;
 	}
 }
 
-void decode_ss_table(const UINT16 ss, std::string& arithmetic)
+void decode_ss_table(const UINT16 ss, op_mnem& arithmetic)
 {
 	switch(ss)
 	{
-		case 0x0: arithmetic = "ss"; break;
-		case 0x1: arithmetic = "!!"; break;
-	  //case 0x1: arithmetic = "ss"; break;
-		case 0x2: arithmetic = "su"; break;
-		case 0x3: arithmetic = "uu"; break;
+		case 0x0: arithmetic = oSS; break;
+		case 0x1: arithmetic = oINVALID; break;
+		// NEW // case 0x1: arithmetic = "ss"; break;
+		case 0x2: arithmetic = oSU; break;
+		case 0x3: arithmetic = oUU; break;
 	}
 }
 
-void decode_uuuuF_table(const UINT16 uuuu, const UINT16 F, std::string& arg, std::string& S, std::string& D)
+void decode_uuuuF_table(const UINT16 uuuu, const UINT16 F, std::string& arg, reg_id& S, reg_id& D)
 {
 	const UINT16 switchVal = (uuuu << 1) | F;
 
-	D = "sub?";
-	S = "add";
+	//D = "sub?";
+	//S = "add";
 	arg = "invalid";
 
 	switch(switchVal)
 	{
-		case 0x00: arg = "add"; S = "X0"; D = "A"; break;
-		case 0x01: arg = "add"; S = "X0"; D = "B"; break;
-		case 0x02: arg = "add"; S = "Y0"; D = "A"; break;
-		case 0x03: arg = "add"; S = "Y0"; D = "B"; break;
-		case 0x04: arg = "add"; S = "X1"; D = "A"; break;
-		case 0x05: arg = "add"; S = "X1"; D = "B"; break;
-		case 0x06: arg = "add"; S = "Y1"; D = "A"; break;
-		case 0x07: arg = "add"; S = "Y1"; D = "B"; break;
-
-		case 0x08: arg = "sub"; S = "X0"; D = "A"; break;
-		case 0x09: arg = "sub"; S = "X0"; D = "B"; break;
-		case 0x0a: arg = "sub"; S = "Y0"; D = "A"; break;
-		case 0x0b: arg = "sub"; S = "Y0"; D = "B"; break;
-		case 0x0c: arg = "sub"; S = "X1"; D = "A"; break;
-		case 0x0d: arg = "sub"; S = "X1"; D = "B"; break;
-		case 0x0e: arg = "sub"; S = "Y1"; D = "A"; break;
-		case 0x0f: arg = "sub"; S = "Y1"; D = "B"; break;
-
-		case 0x18: arg = "add"; S = "B";  D = "A"; break;
-		case 0x19: arg = "add"; S = "A";  D = "B"; break;
+		case 0x00: arg = "add"; S = iX0; D = iA; break;
+		case 0x01: arg = "add"; S = iX0; D = iB; break;
+		case 0x02: arg = "add"; S = iY0; D = iA; break;
+		case 0x03: arg = "add"; S = iY0; D = iB; break;
+		case 0x04: arg = "add"; S = iX1; D = iA; break;
+		case 0x05: arg = "add"; S = iX1; D = iB; break;
+		case 0x06: arg = "add"; S = iY1; D = iA; break;
+		case 0x07: arg = "add"; S = iY1; D = iB; break;
+
+		case 0x08: arg = "sub"; S = iX0; D = iA; break;
+		case 0x09: arg = "sub"; S = iX0; D = iB; break;
+		case 0x0a: arg = "sub"; S = iY0; D = iA; break;
+		case 0x0b: arg = "sub"; S = iY0; D = iB; break;
+		case 0x0c: arg = "sub"; S = iX1; D = iA; break;
+		case 0x0d: arg = "sub"; S = iX1; D = iB; break;
+		case 0x0e: arg = "sub"; S = iY1; D = iA; break;
+		case 0x0f: arg = "sub"; S = iY1; D = iB; break;
+
+		case 0x18: arg = "add"; S = iB;  D = iA; break;
+		case 0x19: arg = "add"; S = iA;  D = iB; break;
 
-		case 0x1a: arg = "sub"; S = "B";  D = "A"; break;
-		case 0x1b: arg = "sub"; S = "A";  D = "B"; break;
+		case 0x1a: arg = "sub"; S = iB;  D = iA; break;
+		case 0x1b: arg = "sub"; S = iA;  D = iB; break;
 
-		case 0x1c: arg = "tfr"; S = "B";  D = "A"; break;
-		case 0x1d: arg = "tfr"; S = "A";  D = "B"; break;
+		case 0x1c: arg = "tfr"; S = iB;  D = iA; break;
+		case 0x1d: arg = "tfr"; S = iA;  D = iB; break;
 
-		case 0x1e: arg = "move"; S = "";  D = ""; break;
-		case 0x1f: arg = "move"; S = "";  D = ""; break;
+		case 0x1e: arg = "move"; S = iINVALID;  D = iINVALID; break;
+		case 0x1f: arg = "move"; S = iINVALID;  D = iINVALID; break;
 	}
 }
 
@@ -465,7 +490,7 @@
 	char temp[32];
 	switch(m)
 	{
-		case 0x0: sprintf(temp, "(R%d)+",n)	   ; break;
+		case 0x0: sprintf(temp, "(R%d)+",n)	      ; break;
 		case 0x1: sprintf(temp, "(R%d)+N%d", n, n); break;
 	}
 	ea = temp;
@@ -514,7 +539,7 @@
 	ea = temp;
 }
 
-void assemble_ea_from_t_table(UINT16 t,  UINT16 val, std::string& ea)
+void assemble_ea_from_t_table(UINT16 t, UINT16 val, std::string& ea)
 {
 	char temp[32];
 	switch(t)
@@ -558,6 +583,18 @@
 	D = temp;
 }
 
+void assemble_arguments_from_W_table(UINT16 W, char ma, const reg_id& SD, const std::string& ea,
+									 std::string& source, std::string& destination)
+{
+	char temp[32];
+	sprintf(temp, "%c:%s", ma, ea.c_str());
+	switch(W)
+	{
+		case 0x0: source = regIdAsString(SD); destination = temp; break;
+		case 0x1: source = temp; destination = regIdAsString(SD); break;
+	}
+}
+
 void assemble_arguments_from_W_table(UINT16 W, char ma, const std::string& SD, const std::string& ea,
 									 std::string& source, std::string& destination)
 {
@@ -570,7 +607,7 @@
 	}
 }
 
-void assemble_reg_from_W_table(UINT16 W, char ma, const std::string& SD, const INT8 xx, std::string& S, std::string& D)
+void assemble_reg_from_W_table(UINT16 W, char ma, const reg_id& SD, const INT8 xx, std::string& S, std::string& D)
 {
 	UINT8 abs_xx;
 	char temp[32];
@@ -587,8 +624,8 @@
 	// NEW // sprintf(temp, "%c:(R2%s$%02x)", ma, operation, abs_xx);
 	switch(W)
 	{
-		case 0x0: S = SD; D = temp; break;
-		case 0x1: S = temp; D = SD; break;
+		case 0x0: S = regIdAsString(SD); D = temp; break;
+		case 0x1: S = temp; D = regIdAsString(SD); break;
 	}
 }
 
@@ -613,9 +650,9 @@
 }
 
 
-/*******************/
-/* HELPER FUNCTION */
-/*******************/
+/********************/
+/* HELPER FUNCTIONS */
+/********************/
 
 UINT16 dsp56k_op_maskn(UINT16 cur, UINT16 mask)
 {
@@ -638,7 +675,7 @@
 	return temp;
 }
 
-bool registerOverlap(const std::string& r0, const size_t bmd, const std::string& r1)
+bool registerOverlap(const reg_id& r0, const size_t bmd, const reg_id& r1)
 {
 	if (bmd == BM_NONE)
 		return false;
@@ -646,16 +683,218 @@
 	if (r0 == r1)
 		return true;
 
-	if (r0 == "A" && (bmd & BM_LOW)	&& r1 == "A0") return true;
-	if (r0 == "A" && (bmd & BM_MIDDLE) && r1 == "A1") return true;
-	if (r0 == "A" && (bmd & BM_HIGH)   && r1 == "A2") return true;
-
-	if (r0 == "B" && (bmd & BM_LOW)	&& r1 == "B0") return true;
-	if (r0 == "B" && (bmd & BM_MIDDLE) && r1 == "B1") return true;
-	if (r0 == "B" && (bmd & BM_HIGH)   && r1 == "B2") return true;
+	if (r0 == iA && (bmd & BM_LOW)    && r1 == iA0) return true;
+	if (r0 == iA && (bmd & BM_MIDDLE) && r1 == iA1) return true;
+	if (r0 == iA && (bmd & BM_HIGH)   && r1 == iA2) return true;
+
+	if (r0 == iB && (bmd & BM_LOW)    && r1 == iB0) return true;
+	if (r0 == iB && (bmd & BM_MIDDLE) && r1 == iB1) return true;
+	if (r0 == iB && (bmd & BM_HIGH)   && r1 == iB2) return true;
 
 	return false;
 }
 
+UINT16 regValue16(dsp56k_core* cpustate, const reg_id& reg)
+{
+    if (reg == iX0) return X0;
+    if (reg == iX1) return X1;
+    if (reg == iY0) return Y0;
+    if (reg == iY1) return Y1;
+
+    if (reg == iA0) return A0;
+    if (reg == iA1) return A1;
+    if (reg == iB0) return B0;
+    if (reg == iB1) return B1;
+
+    if (reg == iR0) return R0;
+    if (reg == iR1) return R1;
+    if (reg == iR2) return R2;
+    if (reg == iR3) return R3;
+
+    if (reg == iN0) return N0;
+    if (reg == iN1) return N1;
+    if (reg == iN2) return N2;
+    if (reg == iN3) return N3;
+
+    if (reg == iM0) return M0;
+    if (reg == iM1) return M1;
+    if (reg == iM2) return M2;
+    if (reg == iM3) return M3;
+
+    mame_printf_debug("The dsp561xx core is requesting a 16 bit value from non-16 bit register!");
+    return 0xdead;
+}
+
+void setReg16(dsp56k_core* cpustate, const UINT16& value, const reg_id& reg)
+{
+    if (reg == iX0) X0 = value;
+    if (reg == iX1) X1 = value;
+    if (reg == iY0) Y0 = value;
+    if (reg == iY1) Y1 = value;
+
+    if (reg == iA0) A0 = value;
+    if (reg == iA1) A1 = value;
+    if (reg == iB0) B0 = value;
+    if (reg == iB1) B1 = value;
+
+    if (reg == iR0) R0 = value;
+    if (reg == iR1) R1 = value;
+    if (reg == iR2) R2 = value;
+    if (reg == iR3) R3 = value;
+
+    if (reg == iN0) N0 = value;
+    if (reg == iN1) N1 = value;
+    if (reg == iN2) N2 = value;
+    if (reg == iN3) N3 = value;
+
+    if (reg == iM0) M0 = value;
+    if (reg == iM1) M1 = value;
+    if (reg == iM2) M2 = value;
+    if (reg == iM3) M3 = value;
+}
+
+std::string regIdAsString(const reg_id& regId)
+{
+    switch(regId)
+    {
+        case iX:  return "X"; break;
+        case iX0: return "X0"; break;
+        case iX1: return "X1"; break;
+        case iY:  return "Y"; break;
+        case iY0: return "Y0"; break;
+        case iY1: return "Y1"; break;
+        case iA:  return "A"; break;
+        case iA0: return "A0"; break;
+        case iA1: return "A1"; break;
+        case iA2: return "A2"; break;
+        case iB:  return "B"; break;
+        case iB0: return "B0"; break;
+        case iB1: return "B1"; break;
+        case iB2: return "B2"; break;
+        case iR0: return "R0"; break;
+        case iR1: return "R1"; break;
+        case iR2: return "R2"; break;
+        case iR3: return "R3"; break;
+        case iN0: return "N0"; break;
+        case iN1: return "N1"; break;
+        case iN2: return "N2"; break;
+        case iN3: return "N3"; break;
+        case iM0: return "M0"; break;
+        case iM1: return "M1"; break;
+        case iM2: return "M2"; break;
+        case iM3: return "M3"; break;
+        case iLC: return "LC"; break;
+        case iSR: return "SR"; break;
+        case iOMR: return "OMR"; break;
+        case iSP:  return "SP"; break;
+        case iSSH: return "SSH"; break;
+        case iSSL: return "SSL"; break;
+        case iLA:  return "LA"; break;
+        case iMR:  return "MR"; break;
+        case iCCR: return "CCR"; break;
+        case iF:   return "F"; break;
+        case iFHAT: return "^F"; break;
+        case iINVALID: return "!!"; break;
+        case iWEIRD: return "?"; break;
+    }
+
+    return "INVALID_REG_ID";
+}
+
+std::string opMnemonicAsString(const op_mnem& mnem)
+{
+    switch(mnem)
+    {
+        case oCC: return "cc"; break;
+        case oGE: return "ge"; break;
+        case oNE: return "ne"; break;
+        case oPL: return "pl"; break;
+        case oNN: return "nn"; break;
+        case oEC: return "ec"; break;
+        case oLC: return "lc"; break;
+        case oGT: return "gt"; break;
+        case oCS: return "cs"; break;
+        case oLT: return "lt"; break;
+        case oEQ: return "eq"; break;
+        case oMI: return "mi"; break;
+        case oNR: return "nr"; break;
+        case oES: return "es"; break;
+        case oLS: return "ls"; break;
+        case oLE: return "le"; break;
+
+        case oSS: return "ss"; break;
+        case oSU: return "su"; break;
+        case oUU: return "uu"; break;
+        case oINVALID: return "!!"; break;
+    }
+
+    return "INVALID_OPCODE_MNEMONIC";
+}
+
+reg_id stringAsRegID(const std::string& str)
+{
+    if (str == "X") return iX;
+    if (str == "X0") return iX0;
+    if (str == "X1") return iX1;
+    if (str == "Y") return iY;
+    if (str == "Y0") return iY0;
+    if (str == "Y1") return iY1;
+    if (str == "A") return iA;
+    if (str == "A0") return iA0;
+    if (str == "A1") return iA1;
+    if (str == "A2") return iA2;
+    if (str == "B") return iB;
+    if (str == "B0") return iB0;
+    if (str == "B1") return iB1;
+    if (str == "B2") return iB2;
+    if (str == "R0") return iR0;
+    if (str == "R1") return iR1;
+    if (str == "R2") return iR2;
+    if (str == "R3") return iR3;
+    if (str == "N0") return iN0;
+    if (str == "N1") return iN1;
+    if (str == "N2") return iN2;
+    if (str == "N3") return iN3;
+    if (str == "M0") return iM0;
+    if (str == "M1") return iM1;
+    if (str == "M2") return iM2;
+    if (str == "M3") return iM3;
+    if (str == "LC") return iLC;
+    if (str == "SR") return iSR;
+    if (str == "OMR") return iOMR;
+    if (str == "SP") return iSP;
+    if (str == "SSH") return iSSH;
+    if (str == "SSL") return iSSL;
+    if (str == "LA") return iLA;
+    if (str == "MR") return iMR;
+    if (str == "CCR") return iCCR;
+    if (str == "F") return iF;
+    if (str == "^F") return iFHAT;
+    if (str == "!!") return iINVALID;
+    if (str == "?") return iWEIRD;
+
+    return iINVALID;
+}
+
+UINT8 regIDAsNum(const reg_id& regId)
+{
+    if (regId == iR0) return 0;
+    if (regId == iR1) return 1;
+    if (regId == iR2) return 2;
+    if (regId == iR3) return 3;
+
+    if (regId == iN0) return 0;
+    if (regId == iN1) return 1;
+    if (regId == iN2) return 2;
+    if (regId == iN3) return 3;
+
+    if (regId == iM0) return 0;
+    if (regId == iM1) return 1;
+    if (regId == iM2) return 2;
+    if (regId == iM3) return 3;
+
+    return 255;
+}
+
 }
 
diff -Nru src-old/emu/cpu/dsp56k/tables.h src/emu/cpu/dsp56k/tables.h
--- src-old/emu/cpu/dsp56k/tables.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/cpu/dsp56k/tables.h	2010-08-30 08:20:58.000000000 -0700
@@ -6,44 +6,60 @@
 #include <cstdlib>
 
 #include "emu.h"
+#include "dsp56k.h"
 
 namespace DSP56K
 {
 
 #define BITSn(CUR,MASK) (dsp56k_op_maskn(CUR,MASK))
 
-enum bbbType {BBB_UPPER, BBB_MIDDLE, BBB_LOWER, BBB_INVALID};
-enum bitsModified {BM_NONE = 0x0,
-                   BM_LOW = 0x1,
-                   BM_MIDDLE = 0x2,
-                   BM_HIGH = 0x4};
-
-int  decode_BBB_table(UINT16 BBB);
-void decode_cccc_table(const UINT16 cccc, std::string& mnemonic);
-void decode_DDDDD_table(const UINT16 DDDDD, std::string& SD);
-void decode_DD_table(const UINT16 DD, std::string& SD);
-void decode_DDF_table(const UINT16 DD, const UINT16 F, std::string& S, std::string& D);
-void decode_EE_table(const UINT16 EE, std::string& D);
-void decode_F_table(const UINT16 F, std::string& SD);
-void decode_h0hF_table(const UINT16 h0h, UINT16 F, std::string& S, std::string& D);
-void decode_HH_table(const UINT16 HH, std::string& SD);
-void decode_HHH_table(const UINT16 HHH, std::string& SD);
-void decode_IIIIx_table(const UINT16 IIII, const UINT16 x, std::string& S, std::string& D);
-void decode_JJJF_table(const UINT16 JJJ, const UINT16 F, std::string& S, std::string& D);
-void decode_JJF_table(const UINT16 JJ, const UINT16 F, std::string& S, std::string& D);
-void decode_JF_table(const UINT16 J, const UINT16 F, std::string& S, std::string& D);
+enum bitsModified {BM_NONE = 0x0, BM_LOW = 0x1, BM_MIDDLE = 0x2, BM_HIGH = 0x4};
+
+enum bfShift {BBB_UPPER, BBB_MIDDLE, BBB_LOWER, BBB_INVALID};
+enum reg_id {iX,  iX0, iX1,
+             iY,  iY0, iY1,
+             iA,  iA0, iA1, iA2,
+             iB,  iB0, iB1, iB2,
+             iR0, iR1, iR2, iR3,
+             iN0, iN1, iN2, iN3,
+             iM0, iM1, iM2, iM3,
+             iLC, iSR, iOMR, iSP, iSSH, iSSL, iLA, iMR, iCCR,
+             iF, iFHAT,
+             iINVALID, iWEIRD};
+
+enum op_mnem {oCC, oGE, oNE, oPL,
+              oNN, oEC, oLC, oGT,
+              oCS, oLT, oEQ, oMI,
+              oNR, oES, oLS, oLE,
+              oSS, oSU, oUU, oINVALID};
+
+
+bfShift decode_BBB_table(UINT16 BBB);
+void decode_cccc_table(const UINT16 cccc, op_mnem& mnemonic);
+void decode_DDDDD_table(const UINT16 DDDDD, reg_id& SD);
+void decode_DD_table(const UINT16 DD, reg_id& SD);
+void decode_DDF_table(const UINT16 DD, const UINT16 F, reg_id& S, reg_id& D);
+void decode_EE_table(const UINT16 EE, reg_id& D);
+void decode_F_table(const UINT16 F, reg_id& SD);
+void decode_h0hF_table(const UINT16 h0h, UINT16 F, reg_id& S, reg_id& D);
+void decode_HH_table(const UINT16 HH, reg_id& SD);
+void decode_HHH_table(const UINT16 HHH, reg_id& SD);
+void decode_IIIIx_table(const UINT16 IIII, const UINT16 x, reg_id& S, reg_id& D);
+void decode_JJJF_table(const UINT16 JJJ, const UINT16 F, reg_id& S, reg_id& D);
+void decode_JJF_table(const UINT16 JJ, const UINT16 F, reg_id& S, reg_id& D);
+void decode_JF_table(const UINT16 J, const UINT16 F, reg_id& S, reg_id& D);
 void decode_kSign_table(const UINT16 k, std::string& plusMinus);
-void decode_KKK_table(const UINT16 KKK, std::string& D1, std::string& D2);
-void decode_NN_table(UINT16 NN, INT8& ret);
-void decode_TT_table(UINT16 TT, INT8& ret);
-void decode_QQF_table(const UINT16 QQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D);
-void decode_QQF_special_table(const UINT16 QQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D);
-void decode_QQQF_table(const UINT16 QQQ, const UINT16 F, std::string& S1, std::string& S2, std::string& D);
-void decode_RR_table(UINT16 RR, INT8& ret);
-void decode_rr_table(UINT16 rr, INT8& ret);
-void decode_s_table(const UINT16 s, std::string& arithmetic);
-void decode_ss_table(const UINT16 ss, std::string& arithmetic);
-void decode_uuuuF_table(const UINT16 uuuu, const UINT16 F, std::string& arg, std::string& S, std::string& D);
+void decode_KKK_table(const UINT16 KKK, reg_id& D1, reg_id& D2);
+void decode_NN_table(UINT16 NN, reg_id& ret);
+void decode_TT_table(UINT16 TT, reg_id& ret);
+void decode_QQF_table(const UINT16 QQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D);
+void decode_QQF_special_table(const UINT16 QQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D);
+void decode_QQQF_table(const UINT16 QQQ, const UINT16 F, reg_id& S1, reg_id& S2, reg_id& D);
+void decode_RR_table(UINT16 RR, reg_id& ret);
+void decode_rr_table(UINT16 rr, reg_id& ret);
+void decode_s_table(const UINT16 s, op_mnem& arithmetic);
+void decode_ss_table(const UINT16 ss, op_mnem& arithmetic);
+void decode_uuuuF_table(const UINT16 uuuu, const UINT16 F, std::string& arg, reg_id& S, reg_id& D);
 void decode_Z_table(const UINT16 Z, std::string& ea);
 
 void assemble_ea_from_m_table(const UINT16 m, const int n, std::string& ea);
@@ -53,8 +69,9 @@
 void assemble_ea_from_t_table(UINT16 t,  UINT16 val, std::string& ea);
 void assemble_ea_from_z_table(UINT16 z, int n, std::string& ea);
 void assemble_D_from_P_table(UINT16 P, UINT16 ppppp, std::string& D);
+void assemble_arguments_from_W_table(UINT16 W, char ma, const reg_id& SD, const std::string& ea, std::string& S, std::string& D);
 void assemble_arguments_from_W_table(UINT16 W, char ma, const std::string& SD, const std::string& ea, std::string& S, std::string& D);
-void assemble_reg_from_W_table(UINT16 W, char ma, const std::string& SD, const INT8 xx, std::string& S, std::string& D);
+void assemble_reg_from_W_table(UINT16 W, char ma, const reg_id& SD, const INT8 xx, std::string& S, std::string& D);
 void assemble_address_from_IO_short_address(UINT16 pp, std::string& ea);
 
 INT8 get_6_bit_signed_value(UINT16 bits);
@@ -62,7 +79,16 @@
 // Helpers
 UINT16 dsp56k_op_maskn(UINT16 cur, UINT16 mask);
 
-bool registerOverlap(const std::string& r0, const size_t bmd, const std::string& r1);
+bool registerOverlap(const reg_id& r0, const size_t bmd, const reg_id& r1);
+
+UINT16 regValue16(dsp56k_core* cpustate, const reg_id& reg);
+void setReg16(dsp56k_core* cpustate, const UINT16& value, const reg_id& reg);
+
+std::string regIdAsString(const reg_id& regId);
+std::string opMnemonicAsString(const op_mnem& mnem);
+reg_id stringAsRegID(const std::string& str);
+UINT8 regIDAsNum(const reg_id& regId);
+
 
 }
 #endif
diff -Nru src-old/emu/cpu/e132xs/e132xs.c src/emu/cpu/e132xs/e132xs.c
--- src-old/emu/cpu/e132xs/e132xs.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/e132xs/e132xs.c	2010-08-19 09:10:19.000000000 -0700
@@ -320,8 +320,9 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	UINT32 opcodexor;
 
 	INT32 instruction_length;
@@ -1543,6 +1544,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 	cpustate->timer = timer_alloc(device->machine, e132xs_timer_callback, (void *)device);
 	cpustate->clock_scale_mask = scale_mask;
@@ -1650,6 +1652,7 @@
 	cpustate->opcodexor = save_opcodexor;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 	cpustate->timer = save_timer;
 
diff -Nru src-old/emu/cpu/e132xs/e132xs.h src/emu/cpu/e132xs/e132xs.h
--- src-old/emu/cpu/e132xs/e132xs.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/e132xs/e132xs.h	2010-08-19 09:10:19.000000000 -0700
@@ -42,28 +42,28 @@
 
 /* Memory access */
 /* read byte */
-#define READ_B(H,addr)         memory_read_byte((H)->program, (addr))
+#define READ_B(H,addr)         (H)->program->read_byte((addr))
 /* read half-word */
-#define READ_HW(H,addr)        memory_read_word((H)->program, (addr) & ~1)
+#define READ_HW(H,addr)        (H)->program->read_word((addr) & ~1)
 /* read word */
-#define READ_W(H,addr)         memory_read_dword((H)->program, (addr) & ~3)
+#define READ_W(H,addr)         (H)->program->read_dword((addr) & ~3)
 
 /* write byte */
-#define WRITE_B(H,addr, data)  memory_write_byte((H)->program, addr, data)
+#define WRITE_B(H,addr, data)  (H)->program->write_byte(addr, data)
 /* write half-word */
-#define WRITE_HW(H,addr, data) memory_write_word((H)->program, (addr) & ~1, data)
+#define WRITE_HW(H,addr, data) (H)->program->write_word((addr) & ~1, data)
 /* write word */
-#define WRITE_W(H,addr, data)  memory_write_dword((H)->program, (addr) & ~3, data)
+#define WRITE_W(H,addr, data)  (H)->program->write_dword((addr) & ~3, data)
 
 
 /* I/O access */
 /* read word */
-#define IO_READ_W(H,addr)      memory_read_dword((H)->io, ((addr) >> 11) & 0x7ffc)
+#define IO_READ_W(H,addr)      (H)->io->read_dword(((addr) >> 11) & 0x7ffc)
 /* write word */
-#define IO_WRITE_W(H,addr, data) memory_write_dword((H)->io, ((addr) >> 11) & 0x7ffc, data)
+#define IO_WRITE_W(H,addr, data) (H)->io->write_dword(((addr) >> 11) & 0x7ffc, data)
 
 
-#define READ_OP(H,addr)	       memory_decrypted_read_word((H)->program, (addr) ^ (H)->opcodexor)
+#define READ_OP(H,addr)	       (H)->direct->read_decrypted_word((addr) ^ (H)->opcodexor)
 
 
 /* Registers Number */
diff -Nru src-old/emu/cpu/esrip/esrip.c src/emu/cpu/esrip/esrip.c
--- src-old/emu/cpu/esrip/esrip.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/esrip/esrip.c	2010-08-19 09:10:19.000000000 -0700
@@ -110,7 +110,8 @@
 	UINT8	*lbrm;
 
 	legacy_cpu_device *device;
-	const	address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int		icount;
 
 	read16_device_func	fdt_r;
@@ -264,6 +265,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* Create the instruction decode lookup table */
 	cpustate->optable = auto_alloc_array(device->machine, UINT8, 65536);
@@ -1777,7 +1779,7 @@
 		cpustate->pl7 = cpustate->l7;
 
 		/* Latch instruction */
-		inst = memory_decrypted_read_qword(cpustate->program, RIP_PC << 3);
+		inst = cpustate->direct->read_decrypted_qword(RIP_PC << 3);
 
 		in_h = inst >> 32;
 		in_l = inst & 0xffffffff;
diff -Nru src-old/emu/cpu/f8/f8.c src/emu/cpu/f8/f8.c
--- src-old/emu/cpu/f8/f8.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/f8/f8.c	2010-08-19 09:10:19.000000000 -0700
@@ -54,8 +54,9 @@
 	UINT16  irq_vector;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *iospace;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *iospace;
 	int icount;
 	UINT8   r[64];  /* scratchpad RAM */
 	int     irq_request;
@@ -118,7 +119,7 @@
      * of PC0.
      */
 
-	cpustate->dbus = memory_decrypted_read_byte(cpustate->program, cpustate->pc0);
+	cpustate->dbus = cpustate->direct->read_decrypted_byte(cpustate->pc0);
     cpustate->pc0 += 1;
     cpustate->icount -= insttim;	/* SKR - ROMC00 is usually short, not short+long, */
                             /* but DS is long */
@@ -132,7 +133,7 @@
      * location addressed by PC0; then all devices add the 8-bit value
      * on the data bus as signed binary number to PC0.
      */
-	cpustate->dbus = memory_raw_read_byte(cpustate->program, cpustate->pc0);
+	cpustate->dbus = cpustate->direct->read_raw_byte(cpustate->pc0);
 	cpustate->pc0 += (INT8)cpustate->dbus;
     cpustate->icount -= cL;
 }
@@ -145,7 +146,7 @@
      * the memory location addressed by DC0; then all devices increment
      * DC0.
      */
-    cpustate->dbus = memory_read_byte_8be(cpustate->program, cpustate->dc0);
+    cpustate->dbus = cpustate->program->read_byte(cpustate->dc0);
     cpustate->dc0 += 1;
     cpustate->icount -= cL;
 }
@@ -156,7 +157,7 @@
      * Similiar to 0x00, except that it is used for immediate operands
      * fetches (using PC0) instead of instruction fetches.
      */
-    cpustate->dbus = cpustate->io = memory_raw_read_byte(cpustate->program, cpustate->pc0);
+    cpustate->dbus = cpustate->io = cpustate->direct->read_raw_byte(cpustate->pc0);
     cpustate->pc0 += 1;
     cpustate->icount -= insttim;
 }
@@ -176,7 +177,7 @@
      * Store the data bus contents into the memory location pointed
      * to by DC0; increment DC0.
      */
-    memory_write_byte_8be(cpustate->program, cpustate->dc0, cpustate->dbus);
+    cpustate->program->write_byte(cpustate->dc0, cpustate->dbus);
     cpustate->dc0 += 1;
     cpustate->icount -= cL;
 }
@@ -250,7 +251,7 @@
      * by PC0 into the data bus; then all devices move the value that
      * has just been placed on the data bus into the low order byte of PC0.
      */
-    cpustate->dbus = memory_raw_read_byte(cpustate->program, cpustate->pc0);
+    cpustate->dbus = cpustate->direct->read_raw_byte(cpustate->pc0);
     cpustate->pc0 = (cpustate->pc0 & 0xff00) | cpustate->dbus;
     cpustate->icount -= cL;
 }
@@ -273,7 +274,7 @@
      * The value on the data bus is then moved to the low order byte
      * of DC0 by all devices.
      */
-    cpustate->dbus = memory_raw_read_byte(cpustate->program, cpustate->pc0);
+    cpustate->dbus = cpustate->direct->read_raw_byte(cpustate->pc0);
     cpustate->dc0 = (cpustate->dc0 & 0xff00) | cpustate->dbus;
     cpustate->icount -= cL;
 }
@@ -313,7 +314,7 @@
      * data bus. All devices must then move the contents of the
      * data bus to the upper byte of DC0.
      */
-    cpustate->dbus = memory_raw_read_byte(cpustate->program, cpustate->pc0);
+    cpustate->dbus = cpustate->direct->read_raw_byte(cpustate->pc0);
 	cpustate->dc0 = (cpustate->dc0 & 0x00ff) | (cpustate->dbus << 8);
     cpustate->icount -= cL;
 }
@@ -412,7 +413,7 @@
      * register was addressed; the device containing the addressed port
      * must place the contents of the data bus into the address port.
      */
-    memory_write_byte_8be(cpustate->iospace, cpustate->io, cpustate->dbus);
+    cpustate->iospace->write_byte(cpustate->io, cpustate->dbus);
     cpustate->icount -= cL;
 }
 
@@ -425,7 +426,7 @@
      * contents of timer and interrupt control registers cannot be read
      * back onto the data bus).
      */
-	cpustate->dbus = memory_read_byte_8be(cpustate->iospace, cpustate->io);
+	cpustate->dbus = cpustate->iospace->read_byte(cpustate->io);
     cpustate->icount -= cL;
 }
 
@@ -1267,7 +1268,7 @@
 {
     ROMC_1C(cpustate, cS);
     CLR_OZCS;
-    cpustate->a = memory_read_byte_8be(cpustate->iospace, n);
+    cpustate->a = cpustate->iospace->read_byte(n);
     SET_SZ(cpustate->a);
 }
 
@@ -1292,7 +1293,7 @@
 static void f8_outs_0(f8_Regs *cpustate, int n)
 {
     ROMC_1C(cpustate, cS);
-    memory_write_byte_8be(cpustate->iospace, n, cpustate->a);
+    cpustate->iospace->write_byte(n, cpustate->a);
 }
 
 /***************************************************
@@ -1551,6 +1552,7 @@
 	cpustate->irq_callback = save_callback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->iospace = device->space(AS_IO);
 	cpustate->w&=~I;
 
@@ -1898,6 +1900,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->iospace = device->space(AS_IO);
 
 	state_save_register_device_item(device, 0, cpustate->pc0);
@@ -1923,14 +1926,14 @@
 	case CPUINFO_INT_SP:			cpustate->pc1 = info->i;						break;
 	case CPUINFO_INT_PC:
 		cpustate->pc0 = info->i;
-		cpustate->dbus = memory_decrypted_read_byte(cpustate->program, cpustate->pc0);
+		cpustate->dbus = cpustate->direct->read_decrypted_byte(cpustate->pc0);
     	cpustate->pc0 += 1;
 		break;
 	case CPUINFO_INT_PREVIOUSPC:	break;	/* TODO? */
 	case CPUINFO_INT_INPUT_STATE:		cpustate->irq_request = info->i;				break;
 	case CPUINFO_INT_REGISTER + F8_PC0:
 		cpustate->pc0 = info->i;
-		cpustate->dbus = memory_decrypted_read_byte(cpustate->program, cpustate->pc0);
+		cpustate->dbus = cpustate->direct->read_decrypted_byte(cpustate->pc0);
     	cpustate->pc0 += 1;
 		break;
 	case CPUINFO_INT_REGISTER + F8_PC1: cpustate->pc1 = info->i; break;
diff -Nru src-old/emu/cpu/g65816/g65816cm.h src/emu/cpu/g65816/g65816cm.h
--- src-old/emu/cpu/g65816/g65816cm.h	2010-06-16 20:33:24.000000000 -0700
+++ src/emu/cpu/g65816/g65816cm.h	2010-08-19 01:27:05.000000000 -0700
@@ -11,9 +11,9 @@
 #undef G65816_CALL_DEBUGGER
 #define G65816_CALL_DEBUGGER(x) debugger_instruction_hook(cpustate->device, x)
 
-#define g65816_read_8(addr) 			memory_read_byte_8be(cpustate->program, addr)
-#define g65816_write_8(addr,data)		memory_write_byte_8be(cpustate->program, addr,data)
-#define g65816_read_8_immediate(A)		memory_read_byte_8be(cpustate->program, A)
+#define g65816_read_8(addr) 			cpustate->program->read_byte(addr)
+#define g65816_write_8(addr,data)		cpustate->program->write_byte(addr,data)
+#define g65816_read_8_immediate(A)		cpustate->program->read_byte(A)
 #define g65816_jumping(A)
 #define g65816_branching(A)
 
@@ -95,7 +95,7 @@
 	uint irq_delay;		/* delay 1 instruction before checking irq */
 	device_irq_callback int_ack; /* Interrupt Acknowledge */
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	read8_space_func read_vector;	/* Read vector override */
 	uint stopped;		/* Sets how the CPU is stopped */
 	void (*const *opcodes)(g65816i_cpu_struct *cpustate);
diff -Nru src-old/emu/cpu/h6280/h6280.c src/emu/cpu/h6280/h6280.c
--- src-old/emu/cpu/h6280/h6280.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/h6280/h6280.c	2010-08-19 09:10:19.000000000 -0700
@@ -162,6 +162,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 }
 
@@ -178,6 +179,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* set I and B flags */
diff -Nru src-old/emu/cpu/h6280/h6280.h src/emu/cpu/h6280/h6280.h
--- src-old/emu/cpu/h6280/h6280.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/h6280/h6280.h	2010-08-19 09:10:19.000000000 -0700
@@ -62,8 +62,9 @@
 	UINT8 irq_pending;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 
 #if LAZY_FLAGS
     INT32 NZ;			/* last value (lazy N and Z flag) */
diff -Nru src-old/emu/cpu/h6280/h6280ops.h src/emu/cpu/h6280/h6280ops.h
--- src-old/emu/cpu/h6280/h6280ops.h	2009-12-29 07:35:54.000000000 -0800
+++ src/emu/cpu/h6280/h6280ops.h	2010-08-19 09:10:19.000000000 -0700
@@ -125,7 +125,7 @@
  ***************************************************************/
 INLINE UINT8 RDMEM(h6280_Regs* cpustate, offs_t addr) {
 	CHECK_VDC_VCE_PENALTY(addr);
-	return memory_read_byte_8le(cpustate->program, TRANSLATED(addr));
+	return cpustate->program->read_byte(TRANSLATED(addr));
 }
 
 /***************************************************************
@@ -133,60 +133,60 @@
  ***************************************************************/
 INLINE void WRMEM(h6280_Regs* cpustate, offs_t addr, UINT8 data) {
 	CHECK_VDC_VCE_PENALTY(addr);
-	memory_write_byte_8le(cpustate->program, TRANSLATED(addr),data);
+	cpustate->program->write_byte(TRANSLATED(addr),data);
 }
 
 /***************************************************************
  *  RDMEMZ   read memory - zero page
  ***************************************************************/
 #define RDMEMZ(addr)											\
-	memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr)&0x1fff));
+	cpustate->program->read_byte((cpustate->mmr[1] << 13) | ((addr)&0x1fff));
 
 /***************************************************************
  *  WRMEMZ   write memory - zero page
  ***************************************************************/
 #define WRMEMZ(addr,data)										\
-	memory_write_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr)&0x1fff),data);
+	cpustate->program->write_byte((cpustate->mmr[1] << 13) | ((addr)&0x1fff),data);
 
 /***************************************************************
  *  RDMEMW   read word from memory
  ***************************************************************/
 #define RDMEMW(addr)											\
-	memory_read_byte_8le(cpustate->program, TRANSLATED(addr)) \
-| ( memory_read_byte_8le(cpustate->program, TRANSLATED(addr+1)) << 8 )
+	cpustate->program->read_byte(TRANSLATED(addr)) \
+| ( cpustate->program->read_byte(TRANSLATED(addr+1)) << 8 )
 
 /***************************************************************
  *  RDZPWORD    read a word from a zero page address
  ***************************************************************/
 #define RDZPWORD(addr)											\
 	((addr&0xff)==0xff) ?										\
-		memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr)&0x1fff))				\
-		+(memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr-0xff)&0x1fff))<<8) : \
-		memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr)&0x1fff))				\
-		+(memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | ((addr+1)&0x1fff))<<8)
+		cpustate->program->read_byte((cpustate->mmr[1] << 13) | ((addr)&0x1fff))				\
+		+(cpustate->program->read_byte((cpustate->mmr[1] << 13) | ((addr-0xff)&0x1fff))<<8) : \
+		cpustate->program->read_byte((cpustate->mmr[1] << 13) | ((addr)&0x1fff))				\
+		+(cpustate->program->read_byte((cpustate->mmr[1] << 13) | ((addr+1)&0x1fff))<<8)
 
 
 /***************************************************************
  * push a register onto the stack
  ***************************************************************/
-#define PUSH(Rg) memory_write_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | cpustate->sp.d,Rg); S--
+#define PUSH(Rg) cpustate->program->write_byte((cpustate->mmr[1] << 13) | cpustate->sp.d,Rg); S--
 
 /***************************************************************
  * pull a register from the stack
  ***************************************************************/
-#define PULL(Rg) S++; Rg = memory_read_byte_8le(cpustate->program, (cpustate->mmr[1] << 13) | cpustate->sp.d)
+#define PULL(Rg) S++; Rg = cpustate->program->read_byte((cpustate->mmr[1] << 13) | cpustate->sp.d)
 
 /***************************************************************
  *  RDOP    read an opcode
  ***************************************************************/
 #define RDOP()													\
-	memory_decrypted_read_byte(cpustate->program, TRANSLATED(PCW))
+	cpustate->direct->read_decrypted_byte(TRANSLATED(PCW))
 
 /***************************************************************
  *  RDOPARG read an opcode argument
  ***************************************************************/
 #define RDOPARG()												\
-	memory_raw_read_byte(cpustate->program, TRANSLATED(PCW))
+	cpustate->direct->read_raw_byte(TRANSLATED(PCW))
 
 /***************************************************************
  *  BRA  branch relative
@@ -1111,21 +1111,21 @@
  ***************************************************************/
 #define ST0                                                     \
 	CLEAR_T;													\
-    memory_write_byte_8le(cpustate->io,0x0000,tmp)
+    cpustate->io->write_byte(0x0000,tmp)
 
 /* 6280 ********************************************************
  *  ST1 Store at hardware address 2
  ***************************************************************/
 #define ST1                                                     \
 	CLEAR_T;													\
-    memory_write_byte_8le(cpustate->io,0x0002,tmp)
+    cpustate->io->write_byte(0x0002,tmp)
 
 /* 6280 ********************************************************
  *  ST2 Store at hardware address 3
  ***************************************************************/
 #define ST2                                                     \
 	CLEAR_T;													\
-    memory_write_byte_8le(cpustate->io,0x0003,tmp)
+    cpustate->io->write_byte(0x0003,tmp)
 
 /* 6280 ********************************************************
  *  STA Store accumulator
diff -Nru src-old/emu/cpu/h83002/h8_16.c src/emu/cpu/h83002/h8_16.c
--- src-old/emu/cpu/h83002/h8_16.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/h83002/h8_16.c	2010-08-19 09:10:19.000000000 -0700
@@ -23,11 +23,11 @@
 
 #define H8_SP	(7)
 
-#define h8_mem_read8(x) memory_read_byte(h8->program, x)
-#define h8_mem_read16(z, x) memory_read_word(h8->program, x)
-#define h8_mem_write8(x, y)  memory_write_byte(h8->program, x, y)
-#define h8_mem_write16(z, x, y) memory_write_word(h8->program, x, y)
-#define h8_readop16(x, y) memory_decrypted_read_word(x->program, y)
+#define h8_mem_read8(x) h8->program->read_byte(x)
+#define h8_mem_read16(z, x) h8->program->read_word(x)
+#define h8_mem_write8(x, y)  h8->program->write_byte(x, y)
+#define h8_mem_write16(z, x, y) h8->program->write_word(x, y)
+#define h8_readop16(x, y) x->direct->read_decrypted_word(y)
 
 // timing macros
 // note: we assume a system 12 - type setup where external access is 3+1 states
@@ -41,14 +41,14 @@
 
 INLINE UINT32 h8_mem_read32(h83xx_state *h8, offs_t address)
 {
-	UINT32 result = memory_read_word_16be(h8->program, address) << 16;
-	return result | memory_read_word_16be(h8->program, address + 2);
+	UINT32 result = h8->program->read_word(address) << 16;
+	return result | h8->program->read_word(address + 2);
 }
 
 INLINE void h8_mem_write32(h83xx_state *h8, offs_t address, UINT32 data)
 {
-	memory_write_word_16be(h8->program, address, data >> 16);
-	memory_write_word_16be(h8->program, address + 2, data);
+	h8->program->write_word(address, data >> 16);
+	h8->program->write_word(address + 2, data);
 }
 
 static void h8_check_irqs(h83xx_state *h8);
@@ -221,6 +221,7 @@
 	h8->mode_8bit = 0;
 
 	h8->program = device->space(AS_PROGRAM);
+	h8->direct = &h8->program->direct();
 	h8->io = device->space(AS_IO);
 
 	state_save_register_device_item(device, 0, h8->h8err);
diff -Nru src-old/emu/cpu/h83002/h8_8.c src/emu/cpu/h83002/h8_8.c
--- src-old/emu/cpu/h83002/h8_8.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/cpu/h83002/h8_8.c	2010-08-19 09:10:19.000000000 -0700
@@ -18,8 +18,8 @@
 
 #define H8_SP	(7)
 
-#define h8_mem_read8(x)		memory_read_byte(h8->program, x)
-#define h8_mem_write8(x, y)	memory_write_byte(h8->program, x, y)
+#define h8_mem_read8(x)		h8->program->read_byte(x)
+#define h8_mem_write8(x, y)	h8->program->write_byte(x, y)
 
 // timing macros
 #define H8_IFETCH_TIMING(x)	h8->cyccnt -= (x) * 4;
@@ -36,38 +36,38 @@
 
 INLINE UINT16 h8_mem_read16(h83xx_state *h8, offs_t address)
 {
-	UINT16 result =  memory_read_byte(h8->program, address)<<8;
-	return result | memory_read_byte(h8->program, address+1);
+	UINT16 result =  h8->program->read_byte(address)<<8;
+	return result | h8->program->read_byte(address+1);
 }
 
 INLINE UINT16 h8_readop16(h83xx_state *h8, offs_t address)
 {
-	UINT16 result =  memory_decrypted_read_byte(h8->program, address)<<8;
-	return result | memory_decrypted_read_byte(h8->program, address+1);
+	UINT16 result =  h8->direct->read_decrypted_byte(address)<<8;
+	return result | h8->direct->read_decrypted_byte(address+1);
 }
 
 INLINE void h8_mem_write16(h83xx_state *h8, offs_t address, UINT16 data)
 {
-	memory_write_byte(h8->program, address, data >> 8);
-	memory_write_byte(h8->program, address+1, data);
+	h8->program->write_byte(address, data >> 8);
+	h8->program->write_byte(address+1, data);
 }
 
 INLINE UINT32 h8_mem_read32(h83xx_state *h8, offs_t address)
 {
-	UINT32 result = memory_read_byte(h8->program, address) << 24;
-	result |= memory_read_byte(h8->program, address+1) << 16;
-	result |= memory_read_byte(h8->program, address+2) << 8;
-	result |= memory_read_byte(h8->program, address+3);
+	UINT32 result = h8->program->read_byte(address) << 24;
+	result |= h8->program->read_byte(address+1) << 16;
+	result |= h8->program->read_byte(address+2) << 8;
+	result |= h8->program->read_byte(address+3);
 
 	return result;
 }
 
 INLINE void h8_mem_write32(h83xx_state *h8, offs_t address, UINT32 data)
 {
-	memory_write_byte(h8->program, address, data >> 24);
-	memory_write_byte(h8->program, address+1, data >> 16);
-	memory_write_byte(h8->program, address+2, data >> 8);
-	memory_write_byte(h8->program, address+3, data);
+	h8->program->write_byte(address, data >> 24);
+	h8->program->write_byte(address+1, data >> 16);
+	h8->program->write_byte(address+2, data >> 8);
+	h8->program->write_byte(address+3, data);
 }
 
 static void h8_check_irqs(h83xx_state *h8);
@@ -238,6 +238,7 @@
 	h8->mode_8bit = 1;
 
 	h8->program = device->space(AS_PROGRAM);
+	h8->direct = &h8->program->direct();
 	h8->io = device->space(AS_IO);
 
 	h8->timer[0] = timer_alloc(h8->device->machine, h8_timer_0_cb, h8);
@@ -522,7 +523,7 @@
 	switch(reg)
 	{
 	case 0x8d:		// serial Rx 1
-		val = memory_read_byte(h8->io, H8_SERIAL_1);
+		val = h8->io->read_byte(H8_SERIAL_1);
 		break;
 	case 0x92:  		// FRC H
 		frc = h8->device->total_cycles() / divider[h8->per_regs[0x96]];
@@ -533,61 +534,61 @@
 		frc %= 65536;
 		return frc&0xff;
 	case 0xb2:  		// port 1 data
-		val = memory_read_byte(h8->io, H8_PORT_1);
+		val = h8->io->read_byte(H8_PORT_1);
 		break;
 	case 0xb3:  		// port 2 data
-		val = memory_read_byte(h8->io, H8_PORT_2);
+		val = h8->io->read_byte(H8_PORT_2);
 		break;
 	case 0xb6:		// port 3 data
-		val = memory_read_byte(h8->io, H8_PORT_3);
+		val = h8->io->read_byte(H8_PORT_3);
 		break;
 	case 0xb7:		// port 4 data
-		val = memory_read_byte(h8->io, H8_PORT_4);
+		val = h8->io->read_byte(H8_PORT_4);
 		break;
 	case 0xba:		// port 5 data
-		val = memory_read_byte(h8->io, H8_PORT_5);
+		val = h8->io->read_byte(H8_PORT_5);
 		break;
 	case 0xbb:		// port 6 data
-		val = memory_read_byte(h8->io, H8_PORT_6);
+		val = h8->io->read_byte(H8_PORT_6);
 		break;
 	case 0xbe:		// port 7 data
-		val = memory_read_byte(h8->io, H8_PORT_7);
+		val = h8->io->read_byte(H8_PORT_7);
 		break;
 	case 0xbf:		// port 8 data
-		val = memory_read_byte(h8->io, H8_PORT_8);
+		val = h8->io->read_byte(H8_PORT_8);
 		break;
 	case 0xc1:		// port 9 data
-		val = memory_read_byte(h8->io, H8_PORT_9);
+		val = h8->io->read_byte(H8_PORT_9);
 		break;
 	case 0xdc:	// serial status
 		val = 0x87;
 		break;
 	case 0xdd:		// serial Rx 0
-		val = memory_read_byte(h8->io, H8_SERIAL_0);
+		val = h8->io->read_byte(H8_SERIAL_0);
 		break;
 	case 0xe0:	// ADC 0 low byte
-		val = memory_read_byte(h8->io, H8_ADC_0_L);
+		val = h8->io->read_byte(H8_ADC_0_L);
 		break;
 	case 0xe1:	// ADC 0 high byte
-		val = memory_read_byte(h8->io, H8_ADC_0_H);
+		val = h8->io->read_byte(H8_ADC_0_H);
 		break;
 	case 0xe2:	// ADC 1 low byte
-		val = memory_read_byte(h8->io, H8_ADC_1_L);
+		val = h8->io->read_byte(H8_ADC_1_L);
 		break;
 	case 0xe3:	// ADC 1 high byte
-		val = memory_read_byte(h8->io, H8_ADC_1_H);
+		val = h8->io->read_byte(H8_ADC_1_H);
 		break;
 	case 0xe4:	// ADC 2 low byte
-		val = memory_read_byte(h8->io, H8_ADC_2_L);
+		val = h8->io->read_byte(H8_ADC_2_L);
 		break;
 	case 0xe5:	// ADC 2 high byte
-		val = memory_read_byte(h8->io, H8_ADC_2_H);
+		val = h8->io->read_byte(H8_ADC_2_H);
 		break;
 	case 0xe6:	// ADC 3 low byte
-		val = memory_read_byte(h8->io, H8_ADC_3_L);
+		val = h8->io->read_byte(H8_ADC_3_L);
 		break;
 	case 0xe7:	// ADC 3 high byte
-		val = memory_read_byte(h8->io, H8_ADC_3_H);
+		val = h8->io->read_byte(H8_ADC_3_H);
 		break;
 	case 0xe8:	// ADCSR: A/D control/status
 		val = 0x80;	// return conversion completed
@@ -613,37 +614,37 @@
 		printf("%02x to flash control or external\n", data);
 		break;
 	case 0x8b:		// serial Tx 1
-		memory_write_byte(h8->io, H8_SERIAL_1, data);
+		h8->io->write_byte(H8_SERIAL_1, data);
 		break;
 	case 0xb2:  		// port 1 data
-		memory_write_byte(h8->io, H8_PORT_1, data);
+		h8->io->write_byte(H8_PORT_1, data);
 		break;
 	case 0xb3:  		// port 2 data
-		memory_write_byte(h8->io, H8_PORT_2, data);
+		h8->io->write_byte(H8_PORT_2, data);
 		break;
 	case 0xb6:		// port 3 data
-		memory_write_byte(h8->io, H8_PORT_3, data);
+		h8->io->write_byte(H8_PORT_3, data);
 		break;
 	case 0xb7:		// port 4 data
-		memory_write_byte(h8->io, H8_PORT_4, data);
+		h8->io->write_byte(H8_PORT_4, data);
 		break;
 	case 0xba:		// port 5 data
-		memory_write_byte(h8->io, H8_PORT_5, data);
+		h8->io->write_byte(H8_PORT_5, data);
 		break;
 	case 0xbb:		// port 6 data
-		memory_write_byte(h8->io, H8_PORT_6, data);
+		h8->io->write_byte(H8_PORT_6, data);
 		break;
 	case 0xbe:		// port 7 data
-		memory_write_byte(h8->io, H8_PORT_7, data);
+		h8->io->write_byte(H8_PORT_7, data);
 		break;
 	case 0xbf:		// port 8 data
-		memory_write_byte(h8->io, H8_PORT_8, data);
+		h8->io->write_byte(H8_PORT_8, data);
 		break;
 	case 0xc1:		// port 9 data
-		memory_write_byte(h8->io, H8_PORT_9, data);
+		h8->io->write_byte(H8_PORT_9, data);
 		break;
 	case 0xdb:		// serial Tx 0
-		memory_write_byte(h8->io, H8_SERIAL_0, data);
+		h8->io->write_byte(H8_SERIAL_0, data);
 		break;
 
 	case 0xd8:
diff -Nru src-old/emu/cpu/h83002/h8periph.c src/emu/cpu/h83002/h8periph.c
--- src-old/emu/cpu/h83002/h8periph.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/cpu/h83002/h8periph.c	2010-08-19 01:27:05.000000000 -0700
@@ -328,62 +328,62 @@
 			val |= 0xc4;		// transmit finished, receive ready, no errors
 			break;
 		case 0xb5: // serial port A receive
-			val = memory_read_byte(h8->io, H8_SERIAL_0);
+			val = h8->io->read_byte(H8_SERIAL_0);
 			break;
 		case 0xbc: // serial port B status
 			val = h8->per_regs[reg];
 			val |= 0xc4;		// transmit finished, receive ready, no errors
 			break;
 		case 0xbd: // serial port B receive
-			val = memory_read_byte(h8->io, H8_SERIAL_1);
+			val = h8->io->read_byte(H8_SERIAL_1);
 			break;
 		case 0xe0:
-			val = memory_read_byte(h8->io, H8_ADC_0_H);
+			val = h8->io->read_byte(H8_ADC_0_H);
 			break;
 		case 0xe1:
-			val = memory_read_byte(h8->io, H8_ADC_0_L);
+			val = h8->io->read_byte(H8_ADC_0_L);
 			break;
 		case 0xe2:
-			val = memory_read_byte(h8->io, H8_ADC_1_H);
+			val = h8->io->read_byte(H8_ADC_1_H);
 			break;
 		case 0xe3:
-			val = memory_read_byte(h8->io, H8_ADC_1_L);
+			val = h8->io->read_byte(H8_ADC_1_L);
 			break;
 		case 0xe4:
-			val = memory_read_byte(h8->io, H8_ADC_2_H);
+			val = h8->io->read_byte(H8_ADC_2_H);
 			break;
 		case 0xe5:
-			val = memory_read_byte(h8->io, H8_ADC_2_L);
+			val = h8->io->read_byte(H8_ADC_2_L);
 			break;
 		case 0xe6:
-			val = memory_read_byte(h8->io, H8_ADC_3_H);
+			val = h8->io->read_byte(H8_ADC_3_H);
 			break;
 		case 0xe7:
-			val = memory_read_byte(h8->io, H8_ADC_3_L);
+			val = h8->io->read_byte(H8_ADC_3_L);
 			break;
 		case 0xe8:		// adc status
 			val = 0x80;
 			break;
 		case 0xc7:  		// port 4 data
-			val = memory_read_byte(h8->io, H8_PORT_4);
+			val = h8->io->read_byte(H8_PORT_4);
 			break;
 		case 0xcb:  		// port 6 data
-			val = memory_read_byte(h8->io, H8_PORT_6);
+			val = h8->io->read_byte(H8_PORT_6);
 			break;
 		case 0xce:		// port 7 data
-			val = memory_read_byte(h8->io, H8_PORT_7);
+			val = h8->io->read_byte(H8_PORT_7);
 			break;
 		case 0xcf:		// port 8 data
-			val = memory_read_byte(h8->io, H8_PORT_8);
+			val = h8->io->read_byte(H8_PORT_8);
 			break;
 		case 0xd2:		// port 9 data
-			val = memory_read_byte(h8->io, H8_PORT_9);
+			val = h8->io->read_byte(H8_PORT_9);
 			break;
 		case 0xd3:		// port a data
-			val = memory_read_byte(h8->io, H8_PORT_A);
+			val = h8->io->read_byte(H8_PORT_A);
 			break;
 		case 0xd6:		// port b data
-			val = memory_read_byte(h8->io, H8_PORT_B);
+			val = h8->io->read_byte(H8_PORT_B);
 			break;
 		case 0xf6:
 			val = h8_ISR_r(h8);
@@ -414,35 +414,35 @@
 	switch (reg)
 	{
 		case 0xb3:	// serial 0 send
-			memory_write_byte(h8->io, H8_SERIAL_0, val);
+			h8->io->write_byte(H8_SERIAL_0, val);
 			h8_3002_InterruptRequest(h8, 54, 1);
 			h8_3002_InterruptRequest(h8, 55, 1);
 			break;
 		case 0xbb:	// serial 1 send
-			memory_write_byte(h8->io, H8_SERIAL_1, val);
+			h8->io->write_byte(H8_SERIAL_1, val);
 			h8_3002_InterruptRequest(h8, 58, 1);
 			h8_3002_InterruptRequest(h8, 59, 1);
 			break;
 		case 0xc7:
-			memory_write_byte(h8->io, H8_PORT_4, val);
+			h8->io->write_byte(H8_PORT_4, val);
 			break;
 		case 0xcb:  		// port 6 data
-			memory_write_byte(h8->io, H8_PORT_6, val);
+			h8->io->write_byte(H8_PORT_6, val);
 			break;
 		case 0xce:		// port 7 data
-			memory_write_byte(h8->io, H8_PORT_7, val);
+			h8->io->write_byte(H8_PORT_7, val);
 			break;
 		case 0xcf:		// port 8 data
-			memory_write_byte(h8->io, H8_PORT_8, val);
+			h8->io->write_byte(H8_PORT_8, val);
 			break;
 		case 0xd2:		// port 9 data
-			memory_write_byte(h8->io, H8_PORT_9, val);
+			h8->io->write_byte(H8_PORT_9, val);
 			break;
 		case 0xd3:		// port a data
-			memory_write_byte(h8->io, H8_PORT_A, val);
+			h8->io->write_byte(H8_PORT_A, val);
 			break;
 		case 0xd6:		// port b data
-			memory_write_byte(h8->io, H8_PORT_B, val);
+			h8->io->write_byte(H8_PORT_B, val);
 			break;
 		case 0xf6:
 			h8_ISR_w(h8, val);
@@ -624,63 +624,63 @@
 			val |= 0xc4;		// transmit finished, receive ready, no errors
 			break;
 		case 0xb5: // serial port A receive
-			val = memory_read_byte(h8->io, H8_SERIAL_0);
+			val = h8->io->read_byte(H8_SERIAL_0);
 			break;
 		case 0xbc: // serial port B status
 			val = h8->per_regs[reg];
 			val |= 0xc4;		// transmit finished, receive ready, no errors
 			break;
 		case 0xbd: // serial port B receive
-			val = memory_read_byte(h8->io, H8_SERIAL_1);
+			val = h8->io->read_byte(H8_SERIAL_1);
 			break;
 		case 0xe0:
-			val = memory_read_byte(h8->io, H8_ADC_0_H);
+			val = h8->io->read_byte(H8_ADC_0_H);
 			break;
 		case 0xe1:
-			val = memory_read_byte(h8->io, H8_ADC_0_L);
+			val = h8->io->read_byte(H8_ADC_0_L);
 			break;
 		case 0xe2:
-			val = memory_read_byte(h8->io, H8_ADC_1_H);
+			val = h8->io->read_byte(H8_ADC_1_H);
 			break;
 		case 0xe3:
-			val = memory_read_byte(h8->io, H8_ADC_1_L);
+			val = h8->io->read_byte(H8_ADC_1_L);
 			break;
 		case 0xe4:
-			val = memory_read_byte(h8->io, H8_ADC_2_H);
+			val = h8->io->read_byte(H8_ADC_2_H);
 			break;
 		case 0xe5:
-			val = memory_read_byte(h8->io, H8_ADC_2_L);
+			val = h8->io->read_byte(H8_ADC_2_L);
 			break;
 		case 0xe6:
-			val = memory_read_byte(h8->io, H8_ADC_3_H);
+			val = h8->io->read_byte(H8_ADC_3_H);
 			break;
 		case 0xe7:
-			val = memory_read_byte(h8->io, H8_ADC_3_L);
+			val = h8->io->read_byte(H8_ADC_3_L);
 			break;
 		case 0xe8:		// adc status
 			val = 0x80;
 			break;
 
 		case 0xd3:  		// port 4 data
-			val = memory_read_byte(h8->io, H8_PORT_4);
+			val = h8->io->read_byte(H8_PORT_4);
 			break;
 		case 0xd5:  		// port 6 data
-			val = memory_read_byte(h8->io, H8_PORT_6);
+			val = h8->io->read_byte(H8_PORT_6);
 			break;
 		case 0xd6:		// port 7 data
-			val = memory_read_byte(h8->io, H8_PORT_7);
+			val = h8->io->read_byte(H8_PORT_7);
 			break;
 		case 0xd7:		// port 8 data
-			val = memory_read_byte(h8->io, H8_PORT_8);
+			val = h8->io->read_byte(H8_PORT_8);
 			break;
 		case 0xd8:		// port 9 data
-			val = memory_read_byte(h8->io, H8_PORT_9);
+			val = h8->io->read_byte(H8_PORT_9);
 			break;
 		case 0xd9:		// port a data
-			val = memory_read_byte(h8->io, H8_PORT_A);
+			val = h8->io->read_byte(H8_PORT_A);
 			break;
 		case 0xda:		// port b data
-			val = memory_read_byte(h8->io, H8_PORT_B);
+			val = h8->io->read_byte(H8_PORT_B);
 			break;
 		default:
 			val = h8->per_regs[reg];
@@ -710,31 +710,31 @@
 		switch (reg)
 		{
 			case 0xb3:
-				memory_write_byte(h8->io, H8_SERIAL_0, val);
+				h8->io->write_byte(H8_SERIAL_0, val);
 				break;
 			case 0xbb:
-				memory_write_byte(h8->io, H8_SERIAL_1, val);
+				h8->io->write_byte(H8_SERIAL_1, val);
 				break;
 			case 0xd3:
-				memory_write_byte(h8->io, H8_PORT_4, val);
+				h8->io->write_byte(H8_PORT_4, val);
 				break;
 			case 0xd5:		// port 6 data
-				memory_write_byte(h8->io, H8_PORT_6, val);
+				h8->io->write_byte(H8_PORT_6, val);
 				break;
 			case 0xd6:		// port 7 data
-				memory_write_byte(h8->io, H8_PORT_7, val);
+				h8->io->write_byte(H8_PORT_7, val);
 				break;
 			case 0xd7:		// port 8 data
-				memory_write_byte(h8->io, H8_PORT_8, val);
+				h8->io->write_byte(H8_PORT_8, val);
 				break;
 			case 0xd8:		// port 9 data
-				memory_write_byte(h8->io, H8_PORT_9, val);
+				h8->io->write_byte(H8_PORT_9, val);
 				break;
 			case 0xd9:		// port a data
-				memory_write_byte(h8->io, H8_PORT_A, val);
+				h8->io->write_byte(H8_PORT_A, val);
 				break;
 			case 0xda:		// port b data
-				memory_write_byte(h8->io, H8_PORT_B, val);
+				h8->io->write_byte(H8_PORT_B, val);
 				break;
 		}
 	}
diff -Nru src-old/emu/cpu/h83002/h8priv.h src/emu/cpu/h83002/h8priv.h
--- src-old/emu/cpu/h83002/h8priv.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/h83002/h8priv.h	2010-08-19 09:10:19.000000000 -0700
@@ -28,8 +28,9 @@
 	device_irq_callback irq_cb;
 	legacy_cpu_device *device;
 
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 
 	// onboard peripherals stuff
 	UINT8 per_regs[256];
@@ -45,7 +46,6 @@
 
 	int mode_8bit;
 };
-extern h83xx_state h8;
 
 INLINE h83xx_state *get_safe_token(running_device *device)
 {
diff -Nru src-old/emu/cpu/hcd62121/hcd62121.c src/emu/cpu/hcd62121/hcd62121.c
--- src-old/emu/cpu/hcd62121/hcd62121.c	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/cpu/hcd62121/hcd62121.c	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,505 @@
+/**********************************************************************
+
+    Hitachi hcd62121 cpu core emulation.
+
+The Hitachi hcd62121 is the custom cpu which was used in the Casio
+CFX-9850 (and maybe some other things too).
+
+This CPU core is based on the information provided by Martin Poupe.
+Martin Poupe's site can be found at http://prg.rkk.cz/~mpoupe/
+
+**********************************************************************/
+
+#include "emu.h"
+#include "debugger.h"
+#include "hcd62121.h"
+
+
+struct _hcd62121_state
+{
+	UINT32 prev_pc;
+	UINT16 sp;
+	UINT16 ip;
+	UINT8 dsize;
+	UINT8 cseg;
+	UINT8 dseg;
+	UINT8 sseg;
+	UINT8 f;
+	UINT16 lar;
+	UINT8 reg[0x80];
+	UINT8 temp1[0x10];
+	UINT8 temp2[0x10];
+	device_irq_callback irq_callback;
+	legacy_cpu_device *device;
+	address_space *program;
+	address_space *io;
+	int icount;
+};
+
+typedef struct _hcd62121_state hcd62121_state;
+
+
+/* From the battery check routine at 20:e874 it looks like
+   bit 3 of the flag register should be the Zero flag. */
+#define _FLAG_Z		0x08
+#define _FLAG_C		0x02
+#define _FLAG_ZL	0x04
+#define _FLAG_CL	0x01
+#define _FLAG_ZH	0x10
+
+
+#define mem_readbyte(cs,A)		((UINT8)(cs)->program->read_byte(A))
+#define mem_writebyte(cs,A,V)	((cs)->program->write_byte(A,V))
+#define io_readbyte(cs,A)		((UINT8)(cs)->io->read_byte(A))
+#define io_writebyte(cs,A,V)	((cs)->io->write_byte(A,V))
+
+
+INLINE UINT8 read_op(hcd62121_state *cpustate)
+{
+	UINT8 d = mem_readbyte(cpustate, ( cpustate->cseg << 16 ) | cpustate->ip );
+	cpustate->ip++;
+	return d;
+}
+
+
+INLINE UINT8 datasize( hcd62121_state *cpustate, UINT8 op )
+{
+	switch( op & 0x03 )
+	{
+	case 0:
+		return 1;
+	case 1:
+		return 2;
+	case 2:
+		return ( cpustate->dsize >> 4 ) + 1;
+	case 3:
+		return ( cpustate->dsize & 0x0f ) + 1;
+	}
+	return 1;
+}
+
+
+INLINE void read_reg( hcd62121_state *cpustate, int size, UINT8 op1 )
+{
+	int i;
+
+	if ( op1 & 0x80 )
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->temp1[i] = cpustate->reg[ ( op1 - i ) & 0x7f ];
+	}
+	else
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->temp1[i] = cpustate->reg[ ( op1 + i ) & 0x7f ];
+	}
+}
+
+
+INLINE void write_reg( hcd62121_state *cpustate, int size, UINT8 op1 )
+{
+	int i;
+
+	if ( op1 & 0x80 )
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ ( op1 - i ) & 0x7f ] = cpustate->temp1[i];
+	}
+	else
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ ( op1 + i ) & 0x7f ] = cpustate->temp1[i];
+	}
+}
+
+
+INLINE void read_regreg( hcd62121_state *cpustate, int size, UINT8 op1, UINT8 op2 )
+{
+	int i;
+
+	for ( i = 0; i < size; i++ )
+		cpustate->temp1[i] = cpustate->reg[ (op1 + i) & 0x7f];
+
+	if ( op1 & 0x80 )
+	{
+		cpustate->temp2[0] = op2;
+		for ( i = 1; i < size; i++ )
+			cpustate->temp2[i] = 0;
+	}
+	else
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->temp2[i] = cpustate->reg[ (op2 + i) & 0x7f ];
+	}
+
+	if ( ! ( op1 & 0x80 ) && ! ( op2 & 0x80 ) )
+	{
+		/* We need to swap parameters */
+		for ( i = 0; i < size; i++ )
+		{
+			UINT8 v = cpustate->temp1[i];
+			cpustate->temp1[i] = cpustate->temp2[i];
+			cpustate->temp2[i] = v;
+		}
+	}
+}
+
+
+INLINE void write_regreg( hcd62121_state *cpustate, int size, UINT8 op1, UINT8 op2 )
+{
+	int i;
+
+	if ( ( op1 & 0x80 ) || ( op2 & 0x80 ) )
+	{
+		/* store in reg1 */
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ (op1 + i) & 0x7f] = cpustate->temp1[i];
+	}
+	else
+	{
+		/* store in reg2 */
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ (op2 + i) & 0x7f] = cpustate->temp1[i];
+	}
+}
+
+
+INLINE void read_iregreg( hcd62121_state *cpustate, int size, UINT8 op1, UINT8 op2 )
+{
+	int i;
+	UINT16 ad;
+
+	ad = cpustate->reg[ ( 0x40 | op1 ) & 0x7f ] | ( cpustate->reg[ ( 0x40 | ( op1 + 1 ) ) & 0x7f ] << 8 );
+
+	for ( i = 0; i < size; i++ )
+	{
+		cpustate->temp1[i] = mem_readbyte( cpustate, ( cpustate->dseg << 16 ) | ad );
+		ad += ( op1 & 0x40 ) ? -1 : 1;
+	}
+	cpustate->lar = ad;
+
+	if ( op1 & 0x80 )
+	{
+		cpustate->temp2[0] = op2;
+		for ( i = 1; i < size; i++ )
+			cpustate->temp2[i] = 0;
+	}
+	else
+	{
+		for ( i = 0; i < size; i++ )
+			cpustate->temp2[i] = cpustate->reg[ (op2 + i) & 0x7f ];
+	}
+
+	if ( ! ( op1 & 0x80 ) && ! ( op2 & 0x80 ) )
+	{
+		/* We need to swap parameters */
+		for ( i = 0; i < size; i++ )
+		{
+			UINT8 v = cpustate->temp1[i];
+			cpustate->temp1[i] = cpustate->temp2[i];
+			cpustate->temp2[i] = v;
+		}
+	}
+}
+
+
+INLINE void write_iregreg( hcd62121_state *cpustate, int size, UINT8 op1, UINT8 op2 )
+{
+	int i;
+
+	if ( ( op1 & 0x80 ) || ( op2 & 0x80 ) )
+	{
+		/* store in (reg1) */
+		UINT16 ad = cpustate->reg[ ( 0x40 | op1 ) & 0x7f ] | ( cpustate->reg[ ( 0x40 | ( op1 + 1 ) ) & 0x7f ] << 8 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			mem_writebyte( cpustate, ( cpustate->dseg << 16 ) | ad, cpustate->temp1[i] );
+			ad += ( op1 & 0x40 ) ? -1 : 1;
+		}
+		cpustate->lar = ad;
+	}
+	else
+	{
+		/* store in reg2 */
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ (op2 + i) & 0x7f] = cpustate->temp1[i];
+	}
+}
+
+
+INLINE void write_iregreg2( hcd62121_state *cpustate, int size, UINT8 op1, UINT8 op2 )
+{
+	int i;
+
+	if ( ( op1 & 0x80 ) || ( op2 & 0x80 ) )
+	{
+		/* store in reg2 */
+		for ( i = 0; i < size; i++ )
+			cpustate->reg[ (op2 + i) & 0x7f] = cpustate->temp2[i];
+	}
+	else
+	{
+		/* store in (reg1) */
+		UINT16 ad = cpustate->reg[ ( 0x40 | op1 ) & 0x7f ] | ( cpustate->reg[ ( 0x40 | ( op1 + 1 ) ) & 0x7f ] << 8 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			mem_writebyte( cpustate, ( cpustate->dseg << 16 ) | ad, cpustate->temp2[i] );
+			ad += ( op1 & 0x40 ) ? -1 : 1;
+		}
+		cpustate->lar = ad;
+	}
+}
+
+
+INLINE int check_cond( hcd62121_state *cpustate, UINT8 op )
+{
+	switch ( op & 0x07 )
+	{
+	case 0x00:	/* ZH set */
+		if ( cpustate->f & _FLAG_ZH )
+			return 1;
+		break;
+
+	case 0x01:	/* ZL set */
+		if ( cpustate->f & _FLAG_ZL )
+			return 1;
+		break;
+
+	case 0x02:	/* C set */
+		if ( cpustate->f & _FLAG_C )
+			return 1;
+		break;
+
+	case 0x03:	/* Z set */
+		if ( cpustate->f & _FLAG_Z )
+			return 1;
+		break;
+
+	case 0x04:	/* Z or C set */
+		if ( cpustate->f & ( _FLAG_Z | _FLAG_C ) )
+			return 1;
+		break;
+
+	case 0x05:	/* CL set */
+		if ( cpustate->f & _FLAG_CL )
+			return 1;
+		break;
+
+	case 0x06:	/* C clear */
+		if ( ! ( cpustate->f & _FLAG_C ) )
+			return 1;
+		break;
+
+	case 0x07:	/* Z clear */
+		if ( ! ( cpustate->f & _FLAG_Z ) )
+			return 1;
+		break;
+	}
+
+	return 0;
+}
+
+
+INLINE hcd62121_state *get_safe_token(running_device *device)
+{
+	assert(device != NULL);
+	assert(device->type() == HCD62121);
+	return (hcd62121_state *)downcast<legacy_cpu_device *>(device)->token();
+}
+
+
+static CPU_INIT( hcd62121 )
+{
+	hcd62121_state *cpustate = get_safe_token(device);
+
+	cpustate->irq_callback = irqcallback;
+	cpustate->device = device;
+	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->io = device->space(AS_IO);
+}
+
+
+static CPU_RESET( hcd62121 )
+{
+	hcd62121_state *cpustate = get_safe_token(device);
+
+	cpustate->sp = 0x0000;
+	cpustate->ip = 0x0000;
+	cpustate->cseg = 0;
+	cpustate->dseg = 0;
+	cpustate->sseg = 0;
+	cpustate->lar = 0;
+	cpustate->f = 0;
+	cpustate->dsize = 0;
+
+	for( int i = 0; i < 0x80; i++ )
+	{
+		cpustate->reg[i] = 0;
+	}
+}
+
+
+static CPU_EXECUTE( hcd62121 )
+{
+	hcd62121_state *cpustate = get_safe_token(device);
+
+	do
+	{
+		UINT32 pc = ( cpustate->cseg << 16 ) | cpustate->ip;
+		UINT8 op;
+
+		debugger_instruction_hook(device, pc);
+		cpustate->prev_pc = pc;
+
+		op = read_op( cpustate );
+
+		cpustate->icount -= 4;
+
+		switch ( op )
+		{
+#include "hcd62121_ops.h"
+		};
+
+	} while (cpustate->icount > 0);
+}
+
+
+static CPU_SET_INFO( hcd62121 )
+{
+	hcd62121_state *cpustate = get_safe_token(device);
+
+	switch (state)
+	{
+	/* --- the following bits of info are set as 64-bit signed integers --- */
+	case CPUINFO_INT_INPUT_STATE + 0:
+	case CPUINFO_INT_INPUT_STATE + 1:
+												break;
+
+	case CPUINFO_INT_SP:						cpustate->sp = info->i;							break;
+	case CPUINFO_INT_PC:						cpustate->ip = info->i;							break;
+
+	case CPUINFO_INT_REGISTER + HCD62121_IP:	cpustate->ip = info->i;							break;
+	case CPUINFO_INT_REGISTER + HCD62121_SP:	cpustate->sp = info->i;							break;
+//  case CPUINFO_INT_REGISTER + HCD62121_R00:   break;
+//  case CPUINFO_INT_REGISTER + HCD62121_R02:   break;
+	}
+}
+
+
+CPU_GET_INFO( hcd62121 )
+{
+	hcd62121_state *cpustate = (device != NULL && device->token() != NULL) ? get_safe_token(device) : NULL;
+
+	switch (state)
+	{
+	/* --- the following bits of info are returned as 64-bit signed integers --- */
+	case CPUINFO_INT_CONTEXT_SIZE:					info->i = sizeof(hcd62121_state);					break;
+	case CPUINFO_INT_INPUT_LINES:						info->i = 2;							break;
+	case CPUINFO_INT_DEFAULT_IRQ_VECTOR:			info->i = 0xff;							break;
+	case DEVINFO_INT_ENDIANNESS:					info->i = ENDIANNESS_BIG;				break;
+	case CPUINFO_INT_CLOCK_MULTIPLIER:				info->i = 1;							break;
+	case CPUINFO_INT_CLOCK_DIVIDER:					info->i = 1;							break;
+	case CPUINFO_INT_MIN_INSTRUCTION_BYTES:			info->i = 1;							break;
+	case CPUINFO_INT_MAX_INSTRUCTION_BYTES:			info->i = 18;							break;
+	case CPUINFO_INT_MIN_CYCLES:					info->i = 4;	/* right? */			break;
+	case CPUINFO_INT_MAX_CYCLES:					info->i = 48;	/* right? */			break;
+
+	case DEVINFO_INT_DATABUS_WIDTH + ADDRESS_SPACE_PROGRAM:	info->i = 8;					break;
+	case DEVINFO_INT_ADDRBUS_WIDTH + ADDRESS_SPACE_PROGRAM: info->i = 24;					break;
+	case DEVINFO_INT_ADDRBUS_SHIFT + ADDRESS_SPACE_PROGRAM: info->i = 0;					break;
+	case DEVINFO_INT_DATABUS_WIDTH + ADDRESS_SPACE_DATA:	info->i = 0;					break;
+	case DEVINFO_INT_ADDRBUS_WIDTH + ADDRESS_SPACE_DATA:	info->i = 0;					break;
+	case DEVINFO_INT_ADDRBUS_SHIFT + ADDRESS_SPACE_DATA:	info->i = 0;					break;
+	case DEVINFO_INT_DATABUS_WIDTH + ADDRESS_SPACE_IO:		info->i = 8;					break;
+	case DEVINFO_INT_ADDRBUS_WIDTH + ADDRESS_SPACE_IO:		info->i = 8;					break;
+	case DEVINFO_INT_ADDRBUS_SHIFT + ADDRESS_SPACE_IO:		info->i = 0;					break;
+
+	case CPUINFO_INT_SP:							info->i = cpustate->sp;					break;
+	case CPUINFO_INT_PC:							info->i = ( cpustate->cseg << 16 ) | cpustate->ip; break;
+	case CPUINFO_INT_PREVIOUSPC:					info->i = cpustate->prev_pc;			break;
+
+	case CPUINFO_INT_INPUT_STATE + 0:
+	case CPUINFO_INT_INPUT_STATE + 1:
+													/* TODO */									break;
+
+	case CPUINFO_INT_REGISTER + HCD62121_IP:			info->i = cpustate->ip;					break;
+	case CPUINFO_INT_REGISTER + HCD62121_SP:			info->i = cpustate->sp;					break;
+	case CPUINFO_INT_REGISTER + HCD62121_LAR:			info->i = cpustate->lar;				break;
+	case CPUINFO_INT_REGISTER + HCD62121_CS:			info->i = cpustate->cseg;				break;
+	case CPUINFO_INT_REGISTER + HCD62121_DS:			info->i = cpustate->dseg;				break;
+	case CPUINFO_INT_REGISTER + HCD62121_SS:			info->i = cpustate->sseg;				break;
+	case CPUINFO_INT_REGISTER + HCD62121_DSIZE:			info->i = cpustate->dsize;				break;
+	case CPUINFO_INT_REGISTER + HCD62121_R00:			info->i = ( cpustate->reg[0x00] << 24 ) | ( cpustate->reg[0x01] << 16 ) | ( cpustate->reg[0x02] << 8 ) | cpustate->reg[0x03]; break;
+//  case CPUINFO_INT_REGISTER + HCD62121_R02:           info->i = cpustate->;                   break;
+
+	/* --- the following bits of info are returned as pointers to data or functions --- */
+	case CPUINFO_FCT_SET_INFO:						info->setinfo = CPU_SET_INFO_NAME(hcd62121);		break;
+	case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(hcd62121);				break;
+	case CPUINFO_FCT_RESET:							info->reset = CPU_RESET_NAME(hcd62121);			break;
+	case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(hcd62121);		break;
+	case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(hcd62121);		break;
+	case CPUINFO_PTR_INSTRUCTION_COUNTER:			info->icount = &cpustate->icount;			break;
+
+	/* --- the following bits of info are returned as NULL-terminated strings --- */
+	case DEVINFO_STR_NAME:							strcpy(info->s, "HCD62121"); break;
+	case DEVINFO_STR_FAMILY:						strcpy(info->s, "Hitachi HCD62121"); break;
+	case DEVINFO_STR_VERSION:						strcpy(info->s, "0.1"); break;
+	case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__); break;
+	case DEVINFO_STR_CREDITS:						strcpy(info->s, "Copyright The MESS Team."); break;
+
+	case CPUINFO_STR_FLAGS:
+		sprintf(info->s, "%s-%s-%s-%c-%c",
+			cpustate->f & _FLAG_ZH ? "ZH":"__",
+			cpustate->f & _FLAG_CL ? "CL":"__",
+			cpustate->f & _FLAG_ZL ? "ZL":"__",
+			cpustate->f & _FLAG_C ? 'C':'_',
+			cpustate->f & _FLAG_Z ? 'Z':'_'
+			);
+		break;
+
+	case CPUINFO_STR_REGISTER + HCD62121_IP: sprintf(info->s, "IP:%04X", cpustate->ip); break;
+	case CPUINFO_STR_REGISTER + HCD62121_SP: sprintf(info->s, "SP:%04X", cpustate->sp); break;
+	case CPUINFO_STR_REGISTER + HCD62121_LAR: sprintf(info->s, "LAR:%04X", cpustate->lar); break;
+	case CPUINFO_STR_REGISTER + HCD62121_CS: sprintf(info->s, "CS:%02X", cpustate->cseg); break;
+	case CPUINFO_STR_REGISTER + HCD62121_DS: sprintf(info->s, "DS:%02X", cpustate->dseg); break;
+	case CPUINFO_STR_REGISTER + HCD62121_SS: sprintf(info->s, "SS:%02X", cpustate->sseg); break;
+	case CPUINFO_STR_REGISTER + HCD62121_DSIZE: sprintf(info->s, "DSIZE:%02X", cpustate->dsize); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R00: sprintf(info->s, "R00:%02X%02X%02X%02X", cpustate->reg[0x00], cpustate->reg[0x01], cpustate->reg[0x02], cpustate->reg[0x03]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R04: sprintf(info->s, "R04:%02X%02X%02X%02X", cpustate->reg[0x04], cpustate->reg[0x05], cpustate->reg[0x06], cpustate->reg[0x07]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R08: sprintf(info->s, "R08:%02X%02X%02X%02X", cpustate->reg[0x08], cpustate->reg[0x09], cpustate->reg[0x0a], cpustate->reg[0x0b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R0C: sprintf(info->s, "R0C:%02X%02X%02X%02X", cpustate->reg[0x0c], cpustate->reg[0x0d], cpustate->reg[0x0e], cpustate->reg[0x0f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R10: sprintf(info->s, "R10:%02X%02X%02X%02X", cpustate->reg[0x10], cpustate->reg[0x11], cpustate->reg[0x12], cpustate->reg[0x13]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R14: sprintf(info->s, "R14:%02X%02X%02X%02X", cpustate->reg[0x14], cpustate->reg[0x15], cpustate->reg[0x16], cpustate->reg[0x17]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R18: sprintf(info->s, "R18:%02X%02X%02X%02X", cpustate->reg[0x18], cpustate->reg[0x19], cpustate->reg[0x1a], cpustate->reg[0x1b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R1C: sprintf(info->s, "R1C:%02X%02X%02X%02X", cpustate->reg[0x1c], cpustate->reg[0x1d], cpustate->reg[0x1e], cpustate->reg[0x1f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R20: sprintf(info->s, "R20:%02X%02X%02X%02X", cpustate->reg[0x20], cpustate->reg[0x21], cpustate->reg[0x22], cpustate->reg[0x23]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R24: sprintf(info->s, "R24:%02X%02X%02X%02X", cpustate->reg[0x24], cpustate->reg[0x25], cpustate->reg[0x26], cpustate->reg[0x27]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R28: sprintf(info->s, "R28:%02X%02X%02X%02X", cpustate->reg[0x28], cpustate->reg[0x29], cpustate->reg[0x2a], cpustate->reg[0x2b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R2C: sprintf(info->s, "R2C:%02X%02X%02X%02X", cpustate->reg[0x2c], cpustate->reg[0x2d], cpustate->reg[0x2e], cpustate->reg[0x2f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R30: sprintf(info->s, "R30:%02X%02X%02X%02X", cpustate->reg[0x30], cpustate->reg[0x31], cpustate->reg[0x32], cpustate->reg[0x33]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R34: sprintf(info->s, "R34:%02X%02X%02X%02X", cpustate->reg[0x34], cpustate->reg[0x35], cpustate->reg[0x36], cpustate->reg[0x37]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R38: sprintf(info->s, "R38:%02X%02X%02X%02X", cpustate->reg[0x38], cpustate->reg[0x39], cpustate->reg[0x3a], cpustate->reg[0x3b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R3C: sprintf(info->s, "R3C:%02X%02X%02X%02X", cpustate->reg[0x3c], cpustate->reg[0x3d], cpustate->reg[0x3e], cpustate->reg[0x3f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R40: sprintf(info->s, "R40:%02X%02X%02X%02X", cpustate->reg[0x40], cpustate->reg[0x41], cpustate->reg[0x42], cpustate->reg[0x43]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R44: sprintf(info->s, "R44:%02X%02X%02X%02X", cpustate->reg[0x44], cpustate->reg[0x45], cpustate->reg[0x46], cpustate->reg[0x47]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R48: sprintf(info->s, "R48:%02X%02X%02X%02X", cpustate->reg[0x48], cpustate->reg[0x49], cpustate->reg[0x4a], cpustate->reg[0x4b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R4C: sprintf(info->s, "R4C:%02X%02X%02X%02X", cpustate->reg[0x4c], cpustate->reg[0x4d], cpustate->reg[0x4e], cpustate->reg[0x4f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R50: sprintf(info->s, "R50:%02X%02X%02X%02X", cpustate->reg[0x50], cpustate->reg[0x51], cpustate->reg[0x52], cpustate->reg[0x53]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R54: sprintf(info->s, "R54:%02X%02X%02X%02X", cpustate->reg[0x54], cpustate->reg[0x55], cpustate->reg[0x56], cpustate->reg[0x57]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R58: sprintf(info->s, "R58:%02X%02X%02X%02X", cpustate->reg[0x58], cpustate->reg[0x59], cpustate->reg[0x5a], cpustate->reg[0x5b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R5C: sprintf(info->s, "R5C:%02X%02X%02X%02X", cpustate->reg[0x5c], cpustate->reg[0x5d], cpustate->reg[0x5e], cpustate->reg[0x5f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R60: sprintf(info->s, "R60:%02X%02X%02X%02X", cpustate->reg[0x60], cpustate->reg[0x61], cpustate->reg[0x62], cpustate->reg[0x63]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R64: sprintf(info->s, "R64:%02X%02X%02X%02X", cpustate->reg[0x64], cpustate->reg[0x65], cpustate->reg[0x66], cpustate->reg[0x67]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R68: sprintf(info->s, "R68:%02X%02X%02X%02X", cpustate->reg[0x68], cpustate->reg[0x69], cpustate->reg[0x6a], cpustate->reg[0x6b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R6C: sprintf(info->s, "R6C:%02X%02X%02X%02X", cpustate->reg[0x6c], cpustate->reg[0x6d], cpustate->reg[0x6e], cpustate->reg[0x6f]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R70: sprintf(info->s, "R70:%02X%02X%02X%02X", cpustate->reg[0x70], cpustate->reg[0x71], cpustate->reg[0x72], cpustate->reg[0x73]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R74: sprintf(info->s, "R74:%02X%02X%02X%02X", cpustate->reg[0x74], cpustate->reg[0x75], cpustate->reg[0x76], cpustate->reg[0x77]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R78: sprintf(info->s, "R78:%02X%02X%02X%02X", cpustate->reg[0x78], cpustate->reg[0x79], cpustate->reg[0x7a], cpustate->reg[0x7b]); break;
+	case CPUINFO_STR_REGISTER + HCD62121_R7C: sprintf(info->s, "R7C:%02X%02X%02X%02X", cpustate->reg[0x7c], cpustate->reg[0x7d], cpustate->reg[0x7e], cpustate->reg[0x7f]); break;
+	}
+}
+
+DEFINE_LEGACY_CPU_DEVICE(HCD62121, hcd62121);
+
diff -Nru src-old/emu/cpu/hcd62121/hcd62121.h src/emu/cpu/hcd62121/hcd62121.h
--- src-old/emu/cpu/hcd62121/hcd62121.h	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/cpu/hcd62121/hcd62121.h	2010-08-20 10:32:03.000000000 -0700
@@ -0,0 +1,38 @@
+#ifndef __HCD62121_H__
+#define __HCD62121_H__
+
+
+enum
+{
+	HCD62121_IP=1, HCD62121_SP, HCD62121_F, HCD62121_LAR,
+	HCD62121_CS, HCD62121_DS, HCD62121_SS, HCD62121_DSIZE,
+	/* 128 byte register file */
+	HCD62121_R00, HCD62121_R04, HCD62121_R08, HCD62121_R0C,
+	HCD62121_R10, HCD62121_R14, HCD62121_R18, HCD62121_R1C,
+	HCD62121_R20, HCD62121_R24, HCD62121_R28, HCD62121_R2C,
+	HCD62121_R30, HCD62121_R34, HCD62121_R38, HCD62121_R3C,
+	HCD62121_R40, HCD62121_R44, HCD62121_R48, HCD62121_R4C,
+	HCD62121_R50, HCD62121_R54, HCD62121_R58, HCD62121_R5C,
+	HCD62121_R60, HCD62121_R64, HCD62121_R68, HCD62121_R6C,
+	HCD62121_R70, HCD62121_R74, HCD62121_R78, HCD62121_R7C,
+};
+
+
+/* I/O ports */
+enum
+{
+	/* Output ports */
+	HCD62121_KOL=0x00,
+	HCD62121_KOH,
+	/* Input ports */
+	HCD62121_KI,
+};
+
+
+DECLARE_LEGACY_CPU_DEVICE(HCD62121, hcd62121);
+
+
+extern CPU_DISASSEMBLE( hcd62121 );
+
+#endif /* __HCD62121_H__ */
+
diff -Nru src-old/emu/cpu/hcd62121/hcd62121_ops.h src/emu/cpu/hcd62121/hcd62121_ops.h
--- src-old/emu/cpu/hcd62121/hcd62121_ops.h	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/cpu/hcd62121/hcd62121_ops.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,972 @@
+
+#define HCD62121_MSK																		\
+		{																					\
+			int i;																			\
+			UINT8 mskres = 1;																\
+																							\
+			for ( i = 0; i < size; i++ )													\
+			{																				\
+				if ( ( cpustate->temp1[i] & cpustate->temp2[i] ) != cpustate->temp2[i] )	\
+					mskres = 0;																\
+			}																				\
+																							\
+			if ( mskres )																	\
+				cpustate->f &= ~_FLAG_Z;													\
+			else																			\
+				cpustate->f |= _FLAG_Z;														\
+		}
+
+#define HCD62121_IMSK																		\
+		{																					\
+			int i;																			\
+			UINT8 mskres = 1;																\
+			UINT8 set_zero = 0;																\
+																							\
+			for ( i = 0; i < size; i++ )													\
+			{																				\
+				if ( ( cpustate->temp1[i] & ~cpustate->temp2[i] ) != ~cpustate->temp2[i] )	\
+					mskres = 0;																\
+				if ( cpustate->temp1[i] | cpustate->temp2[i] )								\
+					set_zero = 1;															\
+			}																				\
+																							\
+			if ( set_zero )																	\
+				cpustate->f |= _FLAG_Z;														\
+			else																			\
+				cpustate->f &= ~_FLAG_Z;													\
+																							\
+			if ( mskres )																	\
+				cpustate->f &= ~_FLAG_C;													\
+			else																			\
+				cpustate->f |= _FLAG_C;														\
+		}
+
+
+#define HCD62121_AND															\
+		{																		\
+			int i;																\
+			UINT8 is_zero = 1;													\
+																				\
+			for ( i = 0; i < size; i++ )										\
+			{																	\
+				cpustate->temp1[i] = cpustate->temp1[i] & cpustate->temp2[i];	\
+				if ( cpustate->temp1[i] )										\
+					is_zero = 0;												\
+			}																	\
+																				\
+			if ( is_zero )														\
+				cpustate->f |= _FLAG_Z;											\
+			else																\
+				cpustate->f &= ~_FLAG_Z;										\
+																				\
+			if ( cpustate->temp1[0] & 0x0f )									\
+				cpustate->f &= ~_FLAG_ZL;										\
+			else																\
+				cpustate->f |= _FLAG_ZL;										\
+																				\
+			if ( cpustate->temp1[0] & 0xf0 )									\
+				cpustate->f &= ~_FLAG_ZH;										\
+			else																\
+				cpustate->f |= _FLAG_ZH;										\
+		}
+
+#define HCD62121_OR																\
+		{																		\
+			int i;																\
+			UINT8 is_zero = 1;													\
+																				\
+			for ( i = 0; i < size; i++ )										\
+			{																	\
+				cpustate->temp1[i] = cpustate->temp1[i] | cpustate->temp2[i];	\
+				if ( cpustate->temp1[i] )										\
+					is_zero = 0;												\
+			}																	\
+																				\
+			if ( is_zero )														\
+				cpustate->f |= _FLAG_Z;											\
+			else																\
+				cpustate->f &= ~_FLAG_Z;										\
+																				\
+			if ( cpustate->temp1[0] & 0x0f )									\
+				cpustate->f &= ~_FLAG_ZL;										\
+			else																\
+				cpustate->f |= _FLAG_ZL;										\
+																				\
+			if ( cpustate->temp1[0] & 0xf0 )									\
+				cpustate->f &= ~_FLAG_ZH;										\
+			else																\
+				cpustate->f |= _FLAG_ZH;										\
+		}
+
+#define HCD62121_ADD																	\
+		{																				\
+			int i;																		\
+			UINT8 is_zero = 1, carry = 0;												\
+																						\
+			if ( ( cpustate->temp1[0] & 0x0f ) + ( cpustate->temp2[0] & 0x0f ) > 15 )	\
+				cpustate->f |= _FLAG_CL;												\
+			else																		\
+				cpustate->f &= ~_FLAG_CL;												\
+																						\
+			for ( i = 0; i < size; i++ )												\
+			{																			\
+				UINT16 res = cpustate->temp1[i] + cpustate->temp2[i] + carry;			\
+																						\
+				cpustate->temp1[i] = res & 0xff;										\
+				if ( cpustate->temp1[i] )												\
+					is_zero = 0;														\
+																						\
+				carry = ( res & 0xff00 ) ? 1 : 0;										\
+			}																			\
+																						\
+			if ( is_zero )																\
+				cpustate->f |= _FLAG_Z;													\
+			else																		\
+				cpustate->f &= ~_FLAG_Z;												\
+																						\
+			if ( carry )																\
+				cpustate->f |= _FLAG_C;													\
+			else																		\
+				cpustate->f &= ~_FLAG_C;												\
+																						\
+			if ( cpustate->temp1[0] & 0x0f )											\
+				cpustate->f &= ~_FLAG_ZL;												\
+			else																		\
+				cpustate->f |= _FLAG_ZL;												\
+																						\
+			if ( cpustate->temp1[0] & 0xf0 )											\
+				cpustate->f &= ~_FLAG_ZH;												\
+			else																		\
+				cpustate->f |= _FLAG_ZH;												\
+		}
+
+/* BCD ADD */
+#define HCD62121_ADDB																	\
+		{																				\
+			int i;																		\
+			UINT8 is_zero = 1, carry = 0;												\
+																						\
+			if ( ( cpustate->temp1[0] & 0x0f ) + ( cpustate->temp2[0] & 0x0f ) > 9 )	\
+				cpustate->f |= _FLAG_CL;												\
+			else																		\
+				cpustate->f &= ~_FLAG_CL;												\
+																						\
+			for ( i = 0; i < size; i++ )												\
+			{																			\
+				UINT16 res = ( cpustate->temp1[i] & 0x0f ) + ( cpustate->temp2[i] & 0x0f ) + carry;	\
+																						\
+				carry = 0;																\
+				if ( res > 9 )															\
+				{																		\
+					res += 6;															\
+				}																		\
+				res += ( cpustate->temp1[i] & 0xf0 ) + ( cpustate->temp2[i] & 0xf0 );	\
+				if ( res > 0x9f )														\
+				{																		\
+					res += 0x60;														\
+				}																		\
+				cpustate->temp1[i] = res & 0xff;										\
+				if ( cpustate->temp1[i] )												\
+					is_zero = 0;														\
+																						\
+				carry = ( res & 0xff00 ) ? 1 : 0;										\
+			}																			\
+																						\
+			if ( is_zero )																\
+				cpustate->f |= _FLAG_Z;													\
+			else																		\
+				cpustate->f &= ~_FLAG_Z;												\
+																						\
+			if ( carry )																\
+				cpustate->f |= _FLAG_C;													\
+			else																		\
+				cpustate->f &= ~_FLAG_C;												\
+																						\
+			if ( cpustate->temp1[0] & 0x0f )											\
+				cpustate->f &= ~_FLAG_ZL;												\
+			else																		\
+				cpustate->f |= _FLAG_ZL;												\
+																						\
+			if ( cpustate->temp1[0] & 0xf0 )											\
+				cpustate->f &= ~_FLAG_ZH;												\
+			else																		\
+				cpustate->f |= _FLAG_ZH;												\
+		}
+
+#define HCD62121_SUB															\
+		{																		\
+			int i;																\
+			UINT8 is_zero = 1, carry = 0;										\
+																				\
+			if ( ( cpustate->temp1[0] & 0x0f ) < ( cpustate->temp2[0] & 0x0f ) )	\
+				cpustate->f |= _FLAG_CL;										\
+			else																\
+				cpustate->f &= ~_FLAG_CL;										\
+																				\
+			for ( i = 0; i < size; i++ )										\
+			{																	\
+				UINT16 res = cpustate->temp1[i] - cpustate->temp2[i] - carry;	\
+																				\
+				cpustate->temp1[i] = res & 0xff;								\
+				if ( cpustate->temp1[i] )										\
+					is_zero = 0;												\
+																				\
+				carry = ( res & 0xff00 ) ? 1 : 0;								\
+			}																	\
+																				\
+			if ( is_zero )														\
+				cpustate->f |= _FLAG_Z;											\
+			else																\
+				cpustate->f &= ~_FLAG_Z;										\
+																				\
+			if ( carry )														\
+				cpustate->f |= _FLAG_C;											\
+			else																\
+				cpustate->f &= ~_FLAG_C;										\
+																				\
+			if ( cpustate->temp1[0] & 0x0f )									\
+				cpustate->f &= ~_FLAG_ZL;										\
+			else																\
+				cpustate->f |= _FLAG_ZL;										\
+																				\
+			if ( cpustate->temp1[0] & 0xf0 )									\
+				cpustate->f &= ~_FLAG_ZH;										\
+			else																\
+				cpustate->f |= _FLAG_ZH;										\
+		}
+
+#define HCD62121_PUSHW(source)																		\
+		{																							\
+			UINT16 address = source;																\
+			mem_writebyte( cpustate, ( cpustate->sseg << 16 ) | cpustate->sp, ( address ) & 0xff );	\
+			cpustate->sp--;																			\
+			mem_writebyte( cpustate, ( cpustate->sseg << 16 ) | cpustate->sp, ( address ) >> 8 );	\
+			cpustate->sp--;																			\
+		}
+
+#define HCD62121_POPW(dest)																			\
+		{																							\
+			UINT16 res;																				\
+			cpustate->sp++;																			\
+			res = mem_readbyte( cpustate, ( cpustate->sseg << 16 ) | cpustate->sp ) << 8;			\
+			cpustate->sp++;																			\
+			res |= mem_readbyte( cpustate, ( cpustate->sseg << 16 ) | cpustate->sp );				\
+			dest = res;																				\
+		}
+
+case 0x04:		/* mskb r1,r2 */
+case 0x05:		/* mskw r1,r2 */
+case 0x06:		/* mskq r1,r2 */
+case 0x07:		/* mskt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_MSK;
+	}
+	break;
+
+case 0x08:		/* shrb r1 */
+case 0x09:		/* shrb r1 */
+case 0x0A:		/* shrq r1 */
+case 0x0B:		/* shrt r1 */
+	/* Shift is a nibble shift! */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 d1 = 0, d2 = 0;
+
+		read_reg( cpustate, size, reg1 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			d1 = ( cpustate->temp1[i] & 0x0f ) << 4;
+			cpustate->temp1[i] = ( cpustate->temp1[i] >> 4 ) | d2;
+			d2 = d1;
+		}
+
+		write_reg( cpustate, size, reg1 );
+	}
+	break;
+
+case 0x0C:		/* testb r1,r2 */
+case 0x0D:		/* testw r1,r2 */
+case 0x0E:		/* testq r1,r2 */
+case 0x0F:		/* testt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_AND;
+	}
+	break;
+
+case 0x14:		/* cmpb r1,r2 */
+case 0x15:		/* cmpw r1,r2 */
+case 0x16:		/* cmpq r1,r2 */
+case 0x17:		/* cmpt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_SUB;
+	}
+	break;
+
+case 0x18:		/* movb r1,r2 */
+case 0x19:		/* movw r1,r2 */
+case 0x1A:		/* movq r1,r2 */
+case 0x1B:		/* movt r1,r2 */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		for ( i = 0; i < size; i++ )
+			cpustate->temp1[i] = cpustate->temp2[i];
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x1C:		/* imskb r1,r2 */
+case 0x1D:		/* imskw r1,r2 */
+case 0x1E:		/* imskq r1,r2 */
+case 0x1F:		/* imskt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_IMSK;
+	}
+	break;
+
+case 0x20:		/* shrb r1 */
+case 0x21:		/* shrw r1 */
+case 0x22:		/* shrq r1 */
+case 0x23:		/* shrt r1 */
+	/* Shift is a single shift! */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 d1 = 0, d2 = 0;
+
+		read_reg( cpustate, size, reg1 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			d1 = ( cpustate->temp1[i] & 0x01 ) << 7;
+			cpustate->temp1[i] = ( cpustate->temp1[i] >> 1 ) | d2;
+			d2 = d1;
+		}
+
+		write_reg( cpustate, size, reg1 );
+	}
+	break;
+
+case 0x24:		/* orb r1,r2 */
+case 0x25:		/* orb r1,r2 */
+case 0x26:		/* orb r1,r2 */
+case 0x27:		/* orb r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_OR;
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x28:		/* shlb r1 */
+case 0x29:		/* shlw r1 */
+case 0x2A:		/* shlq r1 */
+case 0x2B:		/* shlt r1 */
+	/* Shift is a single shift! */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 d1 = 0, d2 = 0;
+
+		read_reg( cpustate, size, reg1 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			d1 = ( cpustate->temp1[i] & 0x80 ) >> 7;
+			cpustate->temp1[i] = ( cpustate->temp1[i] << 1 ) | d2;
+			d2 = d1;
+		}
+
+		write_reg( cpustate, size, reg1 );
+	}
+	break;
+
+case 0x2C:		/* andb r1,r2 */
+case 0x2D:		/* andw r1,r2 */
+case 0x2E:		/* andq r1,r2 */
+case 0x2F:		/* andt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_AND;
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x34:		/* subb r1,r2 */
+case 0x35:		/* subw r1,r2 */
+case 0x36:		/* subq r1,r2 */
+case 0x37:		/* subt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_SUB;
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x38:		/* adbb r1,r2 */
+case 0x39:		/* adbw r1,r2 */
+case 0x3A:		/* adbq r1,r2 */
+case 0x3B:		/* adbt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_ADDB;
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x3C:		/* addb r1,r2 */
+case 0x3D:		/* addw r1,r2 */
+case 0x3E:		/* addq r1,r2 */
+case 0x3F:		/* addt r1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_regreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_ADD;
+
+		write_regreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x4C:		/* testb ir1,r2 */
+case 0x4D:		/* testw ir1,r2 */
+case 0x4E:		/* testq ir1,r2 */
+case 0x4F:		/* testt ir1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_AND;
+	}
+	break;
+
+case 0x54:		/* cmpb ir1,r2 */
+case 0x55:		/* cmpw ir1,r2 */
+case 0x56:		/* cmpq ir1,r2 */
+case 0x57:		/* cmpt ir1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_SUB;
+	}
+	break;
+
+case 0x58:		/* movb ir1,r2 */
+case 0x59:		/* movw ir1,r2 */
+case 0x5A:		/* movq ir1,r2 */
+case 0x5B:		/* movt ir1,r2 */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		for ( i = 0; i < size; i++ )
+			cpustate->temp1[i] = cpustate->temp2[i];
+
+		write_iregreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x64:		/* orb ir1,r2 */
+case 0x65:		/* orb ir1,r2 */
+case 0x66:		/* orb ir1,r2 */
+case 0x67:		/* orb ir1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_OR;
+
+		write_iregreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x6C:		/* andb ir1,r2 */
+case 0x6D:		/* andw ir1,r2 */
+case 0x6E:		/* andq ir1,r2 */
+case 0x6F:		/* andt ir1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_AND;
+
+		write_iregreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x7C:      /* addb ir1,r2 */
+case 0x7D:      /* addw ir1,r2 */
+case 0x7E:      /* addq ir1,r2 */
+case 0x7F:      /* addt ir1,r2 */
+	{
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		HCD62121_ADD;
+
+		write_iregreg( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0x88:		/* jump _a16 */
+	cpustate->ip = ( read_op( cpustate ) << 8 ) | read_op( cpustate );
+	break;
+
+case 0x89:		/* jumpf cs:a16 */
+	{
+		UINT8 cs = read_op( cpustate );
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		cpustate->cseg = cs;
+		cpustate->ip = ( a1 << 8 ) | a2;
+	}
+	break;
+
+case 0x8A:		/* call a16 */
+	{
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		HCD62121_PUSHW( cpustate->ip );
+
+		cpustate->ip = ( a1 << 8 ) | a2;
+	}
+	break;
+
+case 0x8C:		/* unk_8C */
+case 0x8D:		/* unk_8D */
+case 0x8E:		/* unk_8E */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	break;
+
+case 0x90:		/* retzh */
+case 0x91:		/* retzl */
+case 0x92:		/* retc */
+case 0x93:		/* retz */
+case 0x94:		/* retzc */
+case 0x95:		/* retcl */
+case 0x96:		/* retnc */
+case 0x97:		/* retnz */
+	if ( check_cond( cpustate, op ) )
+		HCD62121_POPW( cpustate->ip );
+	break;
+
+case 0x98:		/* jump (r1) */
+	{
+		UINT8 reg1 = read_op( cpustate );
+		UINT16 ad = cpustate->reg[ ( reg1 | 0x40 ) & 0x7f ] << 8;
+
+		if ( reg1 & 0x40 )
+			ad |= cpustate->reg[ ( ( reg1 - 1 ) | 0x40 ) & 0x7f ];
+		else
+			ad |= cpustate->reg[ ( ( reg1 + 1 ) | 0x40 ) & 0x7f ];
+
+		cpustate->ip = ad;
+	}
+	break;
+
+case 0x9F:		/* ret */
+	HCD62121_POPW( cpustate->ip );
+	break;
+
+case 0xA0:		/* jmpzh a16 */
+case 0xA1:		/* jmpzl a16 */
+case 0xA2:		/* jmpc a16 */
+case 0xA3:		/* jmpz a16 */
+case 0xA4:		/* jmpzc a16 */
+case 0xA5:		/* jmpcl a16 */
+case 0xA6:		/* jmpnc a16 */
+case 0xA7:		/* jmpnz a16 */
+	{
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		if ( check_cond( cpustate, op ) )
+			cpustate->ip = ( a1 << 8 ) | a2;
+	}
+	break;
+
+case 0xA8:		/* callzh a16 */
+case 0xA9:		/* callzl a16 */
+case 0xAA:		/* callc a16 */
+case 0xAB:		/* callz a16 */
+case 0xAC:		/* callzc a16 */
+case 0xAD:		/* callcl a16 */
+case 0xAE:		/* callnc a16 */
+case 0xAF:		/* callnz a16 */
+	{
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		if ( check_cond( cpustate, op ) )
+		{
+			HCD62121_PUSHW( cpustate->ip );
+
+			cpustate->ip = ( a1 << 8 ) | a2;
+		}
+	}
+	break;
+
+case 0xB1:		/* unk_B1 reg/i8 */
+case 0xB3:		/* unk_B3 reg/i8 */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	read_op( cpustate );
+	break;
+
+case 0xB4:		/* out koh,reg */
+	io_writebyte( cpustate, HCD62121_KOH, cpustate->reg[ read_op( cpustate ) & 0x7f ] );
+	break;
+
+case 0xB5:		/* out koh,i8 */
+	io_writebyte( cpustate, HCD62121_KOH, read_op( cpustate ) );
+	break;
+
+case 0xB6:		/* out kol,reg */
+	io_writebyte( cpustate, HCD62121_KOL, cpustate->reg[ read_op( cpustate ) & 0x7f ] );
+	break;
+
+case 0xB7:		/* out kol,i8 */
+	io_writebyte( cpustate, HCD62121_KOL, read_op( cpustate ) );
+	break;
+
+case 0xB9:		/* unk_B9 reg/i8 */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	read_op( cpustate );
+	break;
+
+case 0xBB:		/* jmpcl? a16 */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	{
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		if ( cpustate->f & _FLAG_CL )
+			cpustate->ip = ( a1 << 8 ) | a2;
+	}
+	break;
+
+case 0xBF:		/* jmpncl? a16 */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	{
+		UINT8 a1 = read_op( cpustate );
+		UINT8 a2 = read_op( cpustate );
+
+		if ( ! ( cpustate->f & _FLAG_CL ) )
+			cpustate->ip = ( a1 << 8 ) | a2;
+	}
+	break;
+
+case 0xC0:		/* movb reg,i8 */
+case 0xC1:		/* movw reg,i16 */
+case 0xC2:		/* movw reg,i64 */
+case 0xC3:		/* movw reg,i80 */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg = read_op( cpustate );
+
+		for( i = 0; i < size; i++ )
+		{
+			cpustate->reg[(reg + i) & 0x7f] = read_op( cpustate );
+		}
+	}
+	break;
+
+case 0xC4:		/* movb (lar),r1 / r1,(lar) */
+case 0xC5:		/* movw (lar),r1 / r1,(lar) */
+case 0xC6:		/* movq (lar),r1 / r1,(lar) */
+case 0xC7:		/* movt (lar),r1 / r1,(lar) */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+		int pre_inc = 0;
+		int post_inc = 1;
+
+		switch( reg1 & 0x60 )
+		{
+		case 0x00:
+			pre_inc = 0;
+			post_inc = 1;
+			break;
+		case 0x20:
+			pre_inc = 1;
+			post_inc = 0;
+			break;
+		case 0x40:
+			pre_inc = 0;
+			post_inc = -1;
+			break;
+		case 0x60:
+			pre_inc = -1;
+			post_inc = 0;
+			break;
+		}
+
+		if ( reg1 & 0x80 )
+		{
+			/* (lar) <- r1 */
+			for ( i = 0; i < size; i++ )
+			{
+				cpustate->lar += pre_inc;
+				mem_writebyte( cpustate, ( cpustate->dseg << 16 ) | cpustate->lar, cpustate->reg[ ( reg2 + i ) & 0x7f ] );
+				cpustate->lar += post_inc;
+			}
+		}
+		else
+		{
+			/* r1 <- (lar) */
+			for ( i = 0; i < size; i++ )
+			{
+				cpustate->lar += pre_inc;
+				cpustate->reg[ ( reg2 + i ) & 0x7f ] = mem_readbyte( cpustate, ( cpustate->dseg << 16 ) | cpustate->lar );
+				cpustate->lar += post_inc;
+			}
+		}
+	}
+	break;
+
+case 0xCC:		/* swapb ir1,r2 */
+case 0xCD:		/* swapw ir1,r2 */
+case 0xCE:		/* swapq ir1,r2 */
+case 0xCF:		/* swapt ir1,r2? */
+	{
+		int i;
+		int size = datasize( cpustate, op );
+		UINT8 reg1 = read_op( cpustate );
+		UINT8 reg2 = read_op( cpustate );
+
+		read_iregreg( cpustate, size, reg1, reg2 );
+
+		for ( i = 0; i < size; i++ )
+		{
+			UINT8 d = cpustate->temp1[i];
+			cpustate->temp1[i] = cpustate->temp2[i];
+			cpustate->temp2[i] = d;
+		}
+
+		write_iregreg( cpustate, size, reg1, reg2 );
+		write_iregreg2( cpustate, size, reg1, reg2 );
+	}
+	break;
+
+case 0xD0:		/* movb cs,reg */
+	cpustate->cseg = cpustate->reg[ read_op( cpustate ) & 0x7f ];
+	break;
+
+case 0xD1:		/* movb cs,i8 */
+	cpustate->cseg = read_op( cpustate );
+	break;
+
+case 0xD2:		/* movb dsize,reg */
+	cpustate->dsize = cpustate->reg[ read_op( cpustate ) & 0x7f ];
+	break;
+
+case 0xD3:		/* movb dsize,i8 */
+	cpustate->dsize = read_op( cpustate );
+	break;
+
+case 0xD4:		/* movb ss,reg */
+	cpustate->sseg = cpustate->reg[ read_op( cpustate ) & 0x7f ];
+	break;
+
+case 0xD5:		/* movb ss,i8 */
+	cpustate->sseg = read_op( cpustate );
+	break;
+
+case 0xD6:		/* movw sp,reg */
+	{
+		UINT8 reg1 = read_op( cpustate );
+
+		cpustate->sp = cpustate->reg[ reg1 & 0x7f ] | ( cpustate->reg[ ( reg1 + 1 ) & 0x7f ] << 8 );
+	}
+	break;
+
+case 0xD7:		/* movw sp,i16 */
+	cpustate->sp = read_op( cpustate) << 8;
+	cpustate->sp |= read_op( cpustate );
+	break;
+
+case 0xD8:		/* movb f,reg */
+	cpustate->f = cpustate->reg[ read_op( cpustate ) & 0x7f ];
+	break;
+
+case 0xD9:		/* movb f,i8 */
+	cpustate->f = read_op( cpustate );
+	break;
+
+case 0xDC:		/* movb ds,reg */
+	cpustate->dseg = cpustate->reg[ read_op( cpustate ) & 0x7f ];
+	break;
+
+case 0xDD:		/* movb ds,i8 */
+	cpustate->dseg = read_op( cpustate );
+	break;
+
+case 0xDE:		/* movw lar,reg */
+	{
+		UINT8 reg1 = read_op( cpustate );
+
+		cpustate->lar = cpustate->reg[ reg1 & 0x7f ] | ( cpustate->reg[ ( reg1 + 1 ) & 0x7f ] << 8 );
+	}
+	break;
+
+case 0xE0:		/* ld0,b? reg (in?) */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	{
+		UINT8 reg1 = read_op( cpustate );
+
+		/* This is incorrect. _Something_ gets stored to the register */
+		/* This is to hack around the testb instruction at 001039. */
+		cpustate->reg[ reg1 & 0x7f ] = 0x10;
+	}
+	break;
+
+case 0xE1:		/* unk_E1 reg/i8 (in?) */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	break;
+
+case 0xE2:		/* in kb, reg */
+	cpustate->reg[ read_op( cpustate ) & 0x7f ] = io_readbyte( cpustate, HCD62121_KI );
+	break;
+
+case 0xE3:		/* unk_e3 reg/i8 (in?) */
+case 0xE4:		/* unk_e4 reg/i8 (in?) */
+case 0xE5:		/* unk_e5 reg/i8 (in?) */
+case 0xE6:		/* unk_e6 reg/i8 (in?) */
+case 0xE7:		/* unk_e7 reg/i8 (in?) */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	read_op( cpustate );
+	break;
+
+case 0xE8:		/* movw r1,lar */
+	{
+		UINT8 reg1 = read_op( cpustate );
+
+		cpustate->reg[ reg1 & 0x7f ] = cpustate->lar & 0xff;
+		cpustate->reg[ ( reg1 + 1 ) & 0x7f ] = cpustate->lar >> 8;
+	}
+	break;
+
+case 0xEB:		/* movw reg,ss */
+	{
+		UINT8 reg1 = read_op( cpustate );
+
+		cpustate->reg[ reg1 & 0x7f ] = cpustate->sp & 0xff;
+		cpustate->reg[ ( reg1 + 1 ) & 0x7f ] = cpustate->sp >> 8;
+	}
+	break;
+
+case 0xEF:		/* movb reg,ss */
+	cpustate->reg[ read_op( cpustate ) & 0x7f ] = cpustate->sseg;
+	break;
+
+case 0xF0:		/* unk_F0 reg/i8 (out?) */
+case 0xF1:		/* unk_F1 reg/i8 (out?) */
+case 0xF2:		/* unk_F2 reg/i8 (out?) */
+case 0xF3:		/* unk_F3 reg/i8 (out?) */
+case 0xF4:		/* unk_F4 reg/i8 (out?) */
+case 0xF5:		/* unk_F5 reg/i8 (out?) */
+case 0xF6:		/* unk_F6 reg/i8 (out?) */
+case 0xF7:		/* unk_F7 reg/i8 (out?) */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	read_op( cpustate );
+	break;
+
+case 0xFC:		/* unk_FC */
+case 0xFD:		/* unk_FD */
+case 0xFE:		/* unk_FE */
+	logerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	break;
+
+case 0xFF:		/* nop */
+	break;
+
+default:
+	/*logerror*/fatalerror( "%02x:%04x: unimplemented instruction %02x encountered\n", cpustate->cseg, cpustate->ip-1, op );
+	break;
+
diff -Nru src-old/emu/cpu/hcd62121/hcd62121d.c src/emu/cpu/hcd62121/hcd62121d.c
--- src-old/emu/cpu/hcd62121/hcd62121d.c	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/cpu/hcd62121/hcd62121d.c	2010-08-20 10:32:03.000000000 -0700
@@ -0,0 +1,348 @@
+
+#include "emu.h"
+#include "debugger.h"
+#include "hcd62121.h"
+
+
+enum
+{
+	_REG=1,		/* register */
+	_REGREG,	/* register1, register2, or register2, register1 or register1, imm byte */
+	_IRG,		/* register indirect */
+	_IRGREG,	/* 2 register indirect */
+	_A16,		/* 16bit address */
+	_A24,		/* seg:address */
+	_F,			/* flag register */
+	_CS,		/* cs register */
+	_DS,		/* ds register */
+	_SS,		/* ss register */
+	_PC,		/* program counter */
+	_SP,		/* stack pointer */
+	_I8,		/* immediate 8 bit value */
+	_I16,		/* immediate 16 bit value */
+	_I64,		/* immediate 64 bit value */
+	_I80,		/* immediate 80 bit value */
+	_ILR,		/* indirect last address register access */
+	_LAR,		/* last address register */
+	_DSZ,		/* dsize register? */
+	_TIM,		/* timing related register? */
+	_KLO,		/* KO1 - KO8 output lines */
+	_KHI,		/* KO9 - KO14(?) output lines */
+	_KI,		/* K input lines */
+	_4,			/* for nibble shifts */
+};
+
+typedef struct
+{
+	const char *str;
+	UINT8		arg1;
+	UINT8		arg2;
+} hcd62121_dasm;
+
+
+static const hcd62121_dasm hcd62121_ops[256] =
+{
+	/* 0x00 */
+	{ "shlb",  _REG,   _4 }, { "shlw",  _REG,   _4 }, { "shlq",  _REG,   _4 }, { "shlt",  _REG,   _4 },
+	{ "mskb",  _REGREG, 0 }, { "mskw",  _REGREG, 0 }, { "mskq",  _REGREG, 0 }, { "mskt",  _REGREG, 0 },
+	{ "shrb",  _REG,   _4 }, { "shrw",  _REG,   _4 }, { "shrq",  _REG,   _4 }, { "shrt",  _REG,   _4 },
+	{ "tstb",  _REGREG, 0 }, { "tstw",  _REGREG, 0 }, { "tstq",  _REGREG, 0 }, { "tstt",  _REGREG, 0 },
+	{ "xorb",  _REGREG, 0 }, { "xorw",  _REGREG, 0 }, { "xorq",  _REGREG, 0 }, { "xort",  _REGREG, 0 },
+	{ "cmpb",  _REGREG, 0 }, { "cmpw",  _REGREG, 0 }, { "cmpq",  _REGREG, 0 }, { "cmpt",  _REGREG, 0 },
+	{ "movb",  _REGREG, 0 }, { "movw",  _REGREG, 0 }, { "movq",  _REGREG, 0 }, { "movt",  _REGREG, 0 },
+	{ "imskb", _REGREG, 0 }, { "imskw", _REGREG, 0 }, { "imskq", _REGREG, 0 }, { "imskt", _REGREG, 0 },
+
+	/* 0x20 */
+	{ "shrb",  _REG,    0 }, { "shrw",  _REG,    0 }, { "shrq",  _REG,    0 }, { "shrt",  _REG,    0 },
+	{ "orb",   _REGREG, 0 }, { "orw",   _REGREG, 0 }, { "orq",   _REGREG, 0 }, { "ort",   _REGREG, 0 },
+	{ "shlb",  _REG,    0 }, { "shlw",  _REG,    0 }, { "shlq",  _REG,    0 }, { "shlt",  _REG,    0 },
+	{ "andb",  _REGREG, 0 }, { "andw",  _REGREG, 0 }, { "andq",  _REGREG, 0 }, { "andt",  _REGREG, 0 },
+	{ "sbbb",  _REGREG, 0 }, { "sbbw",  _REGREG, 0 }, { "sbbq",  _REGREG, 0 }, { "sbbt",  _REGREG, 0 },		/* BCD SUB */
+	{ "subb",  _REGREG, 0 }, { "subw",  _REGREG, 0 }, { "subq",  _REGREG, 0 }, { "subt",  _REGREG, 0 },
+	{ "adbb",  _REGREG, 0 }, { "adbw",  _REGREG, 0 }, { "adbq",  _REGREG, 0 }, { "adbt",  _REGREG, 0 },		/* BCD ADD */
+	{ "addb",  _REGREG, 0 }, { "addw",  _REGREG, 0 }, { "addq",  _REGREG, 0 }, { "addt",  _REGREG, 0 },
+
+	/* 0x40 */
+	{ "shrb?", _IRG,    0 }, { "shrw?", _IRG,    0 }, { "shrq?", _IRG,    0 }, { "shrt?", _IRG,    0 },
+	{ "mskb",  _IRGREG, 0 }, { "mskw",  _IRGREG, 0 }, { "mskq",  _IRGREG, 0 }, { "mskt",  _IRGREG, 0 },
+	{ "shrb",  _IRG,    0 }, { "shrw",  _IRG,    0 }, { "shrq",  _IRG,    0 }, { "shrt",  _IRG,    0 },
+	{ "tstb",  _IRGREG, 0 }, { "tstw",  _IRGREG, 0 }, { "tstq",  _IRGREG, 0 }, { "tstt",  _IRGREG, 0 },
+	{ "xorb",  _IRGREG, 0 }, { "xorw",  _IRGREG, 0 }, { "xorq",  _IRGREG, 0 }, { "xort",  _IRGREG, 0 },
+	{ "cmpb",  _IRGREG, 0 }, { "cmpw",  _IRGREG, 0 }, { "cmpq",  _IRGREG, 0 }, { "cmpt",  _IRGREG, 0 },
+	{ "movb",  _IRGREG, 0 }, { "movw",  _IRGREG, 0 }, { "movq",  _IRGREG, 0 }, { "movt",  _IRGREG, 0 },
+	{ "imskb", _IRGREG, 0 }, { "imskw", _IRGREG, 0 }, { "imskq", _IRGREG, 0 }, { "imskt", _IRGREG, 0 },
+
+	/* 0x60 */
+	{ "shrb",  _IRG,    0 }, { "shrw",  _IRG,    0 }, { "shrq",  _IRG,    0 }, { "shrt",  _IRG,    0 },
+	{ "orb",   _IRGREG, 0 }, { "orw",   _IRGREG, 0 }, { "orq",   _IRGREG, 0 }, { "ort",   _IRGREG, 0 },
+	{ "shlb",  _IRG,    0 }, { "shlw",  _IRG,    0 }, { "shlq",  _IRG,    0 }, { "shlt",  _IRG,    0 },
+	{ "andb",  _IRGREG, 0 }, { "andw",  _IRGREG, 0 }, { "andq",  _IRGREG, 0 }, { "andt",  _IRGREG, 0 },
+	{ "sbbb",  _IRGREG, 0 }, { "sbbw",  _IRGREG, 0 }, { "sbbq",  _IRGREG, 0 }, { "sbbt",  _IRGREG, 0 },     /* BCD SUB */
+	{ "subb",  _IRGREG, 0 }, { "subw",  _IRGREG, 0 }, { "subq",  _IRGREG, 0 }, { "subt",  _IRGREG, 0 },
+	{ "adbb",  _IRGREG, 0 }, { "adbw",  _IRGREG, 0 }, { "adbq",  _IRGREG, 0 }, { "adbt",  _IRGREG, 0 },     /* BCD ADD */
+	{ "addb",  _IRGREG, 0 }, { "addw",  _IRGREG, 0 }, { "addq",  _IRGREG, 0 }, { "addt",  _IRGREG, 0 },
+
+	/* 0x80 */
+	{ "un80?",    0,    0 }, { "un81?",    0,    0 }, { "un82?",    0,    0 }, { "un83?",    0,    0 },
+	{ "un84?",    0,    0 }, { "un85?",    0,    0 }, { "un86?",    0,    0 }, { "un87?",    0,    0 },
+	{ "jump",  _A16,    0 }, { "jump",  _A24,    0 }, { "call",  _A16,    0 }, { "un8b?",    0,    0 },
+	{ "un8C?",    0,    0 }, { "un8D?",    0,    0 }, { "un8E?",    0,    0 }, { "un8F?",    0,    0 },
+	{ "retzh",    0,    0 }, { "retzl",    0,    0 }, { "retc",     0,    0 }, { "retz",     0,    0 },
+	{ "retzc",    0,    0 }, { "retcl",    0,    0 }, { "retnc",    0,    0 }, { "retnz",    0,    0 },
+	{ "jump",  _IRG,    0 }, { "un99?",    0,    0 }, { "un9A?",    0,    0 }, { "un9b?",    0,    0 },
+	{ "un9C?",    0,    0 }, { "un9D?",    0,    0 }, { "reti",     0,    0 }, { "ret",      0,    0 },
+
+	/* 0xa0 */
+	{ "jmpzh",  _A16,   0 }, { "jmpzl",  _A16,   0 }, { "jmpc",   _A16,   0 }, { "jmpz",   _A16,   0 },
+	{ "jmpzc",  _A16,   0 }, { "jmpcl",  _A16,   0 }, { "jmpnc",  _A16,   0 }, { "jmpnz",  _A16,   0 },
+	{ "callzh", _A16,   0 }, { "callzl", _A16,   0 }, { "callc",  _A16,   0 }, { "callz",  _A16,   0 },
+	{ "callzc", _A16,   0 }, { "callcl", _A16,   0 }, { "callnc", _A16,   0 }, { "callnz", _A16,   0 },
+	{ "unB0?",     0,   0 }, { "unB1?",   _I8,   0 }, { "unB2?",     0,   0 }, { "unB3?",   _I8,   0 },
+	{ "out",   _KHI, _REG }, { "out",    _KHI, _I8 }, { "out",   _KLO, _REG }, { "out",    _KLO, _I8 },
+	{ "unB8?",     0,   0 }, { "unB9?",   _I8,   0 }, { "unBA?",     0,   0 }, { "jmpcl?", _A16,   0 },
+	{ "unBC?",     0,   0 }, { "unBD?",     0,   0 }, { "unBE?",     0,   0 }, { "jmpncl?", _A16,  0 },
+
+	/* 0xc0 */
+	{ "movb",  _REG,  _I8 }, { "movw",  _REG, _I16 }, { "movq",  _REG, _I64 }, { "movt",  _REG, _I80 },
+	{ "movb",  _ILR, _ILR }, { "movw",  _ILR, _ILR }, { "movq",  _ILR, _ILR }, { "movt",  _ILR, _ILR },
+	{ "unC8?",    0,    0 }, { "unC9?",    0,    0 }, { "unCA?",    0,    0 }, { "unCb?",    0,    0 },
+	{ "swapb", _IRGREG, 0 }, { "swapw", _IRGREG, 0 }, { "swapq", _IRGREG, 0 }, { "swapt", _IRGREG, 0 },
+	{ "movb",   _CS, _REG }, { "movb",   _CS,  _I8 }, { "movb",  _DSZ, _REG }, { "movb",  _DSZ,  _I8 },
+	{ "movb",   _SS, _REG }, { "movb",   _SS,  _I8 }, { "movw",   _SP, _REG }, { "movw",   _SP, _I16 },
+	{ "movb",    _F, _REG }, { "movb",    _F,  _I8 }, { "unDA?",    0,    0 }, { "unDb?",    0,    0 },
+	{ "movb",   _DS, _REG }, { "movb",   _DS,  _I8 }, { "movw",  _LAR, _REG }, { "movw?",  _LAR, _I16 },
+
+	/* 0xe0 */
+	{ "unE0?",  _I8,    0 }, { "unE1?",  _I8,    0 }, { "in",    _REG,  _KI }, { "movb",  _REG, _DSZ },
+	{ "movb",  _REG,   _F }, { "movb",  _REG, _TIM }, { "unE6?",  _I8,    0 }, { "unE7?",  _I8,    0 },
+	{ "movw",  _REG, _LAR }, { "movw?", _REG, _LAR }, { "movw",  _REG,  _PC }, { "movw",  _REG,  _SP },
+	{ "unEC?",    0,    0 }, { "movb",  _REG,  _DS }, { "movb",  _REG,  _CS }, { "movb",  _REG,  _SS },
+	{ "unF0?",  _I8,    0 }, { "unF1?",  _I8,    0 }, { "unF2?",  _I8,    0 }, { "unF3?",  _I8,    0 },
+	{ "unF4?",  _I8,    0 }, { "unF5?",  _I8,    0 }, { "unF6?",  _I8,    0 }, { "unF7?",  _I8,    0 },
+	{ "unF8?",    0,    0 }, { "unF9?",    0,    0 }, { "unFA?",    0,    0 }, { "unFb?",    0,    0 },
+	{ "unFC?",    0,    0 }, { "unFD?",    0,    0 }, { "unFE?",    0,    0 }, { "nop",      0,    0 }
+};
+
+
+CPU_DISASSEMBLE( hcd62121 )
+{
+	UINT8 op, op1=0, op2=0;
+	int pos = 0;
+	const hcd62121_dasm *inst;
+
+	op = oprom[pos++];
+
+	inst = &hcd62121_ops[op];
+
+	buffer += sprintf(buffer,"%-8s", inst->str);
+
+	switch( inst->arg1 )
+	{
+	case _REGREG:
+		op1 = oprom[pos++];
+		op2 = oprom[pos++];
+		if ( op1 & 0x80 )
+		{
+			buffer += sprintf( buffer, "r%02x,0x%02x", op1 & 0x7f, op2 );
+		}
+		else
+		{
+			if ( op2 & 0x80 )
+				buffer += sprintf( buffer, "r%02x,r%02x", op1 & 0x7f, op2 & 0x7f );
+			else
+				buffer += sprintf( buffer, "r%02x,r%02x", op2 & 0x7f, op1 & 0x7f );
+		}
+		break;
+	case _REG:
+		buffer += sprintf( buffer, "r%02x", oprom[pos++] & 0x7f );
+		break;
+	case _IRGREG:
+		/* bit 6 = direction. 0 - regular, 1 - reverse */
+		op1 = oprom[pos++];
+		op2 = oprom[pos++];
+		if ( op1 & 0x80 )
+		{
+			buffer += sprintf( buffer, "(r%02x),0x%02x", 0x40 | ( op1 & 0x3f ), op2 );
+		}
+		else
+		{
+			if ( op2 & 0x80 )
+				buffer += sprintf( buffer, "(r%02x%s),r%02x", 0x40 | ( op1 & 0x3f ), (op1 & 0x40) ? ".r" : "", op2 & 0x7f );
+			else
+				buffer += sprintf( buffer, "r%02x,(r%02x%s)", op2 & 0x7f, 0x40 | ( op1 & 0x3f ), (op1 & 0x40) ? ".r" : "" );
+		}
+		break;
+	case _IRG:
+		/* bit 6 = direction. 0 - regular, 1 - reverse */
+		op1 = oprom[pos++];
+		buffer += sprintf( buffer, "(r%02x%s)", 0x40 | ( op1 & 0x3f ), (op1 & 0x40) ? ".r" : "" );
+		break;
+	case _F:
+		buffer += sprintf( buffer, "F" );
+		break;
+	case _CS:
+		buffer += sprintf( buffer, "CS" );
+		break;
+	case _DS:
+		buffer += sprintf( buffer, "DS" );
+		break;
+	case _SS:
+		buffer += sprintf( buffer, "SS" );
+		break;
+	case _PC:
+		buffer += sprintf( buffer, "PC" );
+		break;
+	case _SP:
+		buffer += sprintf( buffer, "SP" );
+		break;
+	case _I8:
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		break;
+	case _I16:
+	case _A16:
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _I64:
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _I80:
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _A24:
+		buffer += sprintf( buffer, "0x%02x:", oprom[pos++] );
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _ILR:
+		op1 = oprom[pos++];
+		op2 = oprom[pos++];
+		if ( op1 & 0x80 )
+		{
+			/* (lar),reg */
+			 buffer += sprintf( buffer, "(%slar%s),r%02x", (op1 & 0x20) ? ( (op1 & 0x40) ? "--" : "++" ) : "", (op1 & 0x20) ? "" : ( (op1 & 0x40) ? "--" : "++" ), op2 & 0x7f );
+		}
+		else
+		{
+			/* reg,(lar) */
+			buffer += sprintf( buffer, "r%02x,(%slar%s)", op2 & 0x7f, (op1 & 0x20) ? ( (op1 & 0x40) ? "--" : "++" ) : "", (op1 & 0x20) ? "" : ( (op1 & 0x40) ? "--" : "++" ) );
+		}
+		break;
+	case _LAR:
+		buffer += sprintf( buffer, "lar" );
+		break;
+	case _DSZ:
+		buffer += sprintf( buffer, "dsize" );
+		break;
+	case _TIM:
+		buffer += sprintf( buffer, "TIM?" );
+		break;
+	case _KLO:
+		buffer += sprintf( buffer, "KOL" );
+		break;
+	case _KHI:
+		buffer += sprintf( buffer, "KOH" );
+		break;
+	default:
+		break;
+	}
+
+	switch( inst->arg2 )
+	{
+	case _REG:
+		buffer += sprintf( buffer, ",r%02x", oprom[pos++] & 0x7f );
+		break;
+	case _F:
+		buffer += sprintf( buffer, ",F" );
+		break;
+	case _CS:
+		buffer += sprintf( buffer, ",CS" );
+		break;
+	case _DS:
+		buffer += sprintf( buffer, ",DS" );
+		break;
+	case _SS:
+		buffer += sprintf( buffer, ",SS" );
+		break;
+	case _PC:
+		buffer += sprintf( buffer, ",PC" );
+		break;
+	case _SP:
+		buffer += sprintf( buffer, ",SP" );
+		break;
+	case _I8:
+		buffer += sprintf( buffer, ",0x%02x", oprom[pos++] );
+		break;
+	case _I16:
+	case _A16:
+		buffer += sprintf( buffer, ",0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _I64:
+		buffer += sprintf( buffer, ",0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _I80:
+		buffer += sprintf( buffer, ",0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _A24:
+		buffer += sprintf( buffer, ",0x%02x:", oprom[pos++] );
+		buffer += sprintf( buffer, "0x%02x", oprom[pos++] );
+		buffer += sprintf( buffer, "%02x", oprom[pos++] );
+		break;
+	case _ILR:
+		/* Implemented by _ILR section for arg1 */
+		break;
+	case _LAR:
+		buffer += sprintf( buffer, ",lar" );
+		break;
+	case _DSZ:
+		buffer += sprintf( buffer, ",dsize" );
+		break;
+	case _TIM:
+		buffer += sprintf( buffer, ",TIM?" );
+		break;
+	case _KI:
+		buffer += sprintf( buffer, ",KI" );
+		break;
+	case _4:
+		buffer += sprintf( buffer, ",4" );
+		break;
+	default:
+		break;
+	}
+
+	return pos | DASMFLAG_SUPPORTED;
+}
+
diff -Nru src-old/emu/cpu/hd6309/hd6309.c src/emu/cpu/hd6309/hd6309.c
--- src-old/emu/cpu/hd6309/hd6309.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/hd6309/hd6309.c	2010-08-19 09:10:19.000000000 -0700
@@ -137,7 +137,8 @@
 	PAIR	ea; 		/* effective address */
 
 	/* Memory spaces */
-    const address_space *program;
+    address_space *program;
+    direct_read_data *direct;
 
 	UINT8	int_state;	/* SYNC and CWAI flags */
 	UINT8	nmi_state;
@@ -229,26 +230,26 @@
 /****************************************************************************/
 /* Read a byte from given memory location                                   */
 /****************************************************************************/
-#define RM(Addr) ((unsigned)memory_read_byte_8be(m68_state->program, Addr))
+#define RM(Addr) ((unsigned)m68_state->program->read_byte(Addr))
 
 /****************************************************************************/
 /* Write a byte to given memory location                                    */
 /****************************************************************************/
-#define WM(Addr,Value) (memory_write_byte_8be(m68_state->program, Addr,Value))
+#define WM(Addr,Value) (m68_state->program->write_byte(Addr,Value))
 
 /****************************************************************************/
 /* Z80_RDOP() is identical to Z80_RDMEM() except it is used for reading     */
 /* opcodes. In case of system with memory mapped I/O, this function can be  */
 /* used to greatly speed up emulation                                       */
 /****************************************************************************/
-#define ROP(Addr) ((unsigned)memory_decrypted_read_byte(m68_state->program, Addr))
+#define ROP(Addr) ((unsigned)m68_state->direct->read_decrypted_byte(Addr))
 
 /****************************************************************************/
 /* Z80_RDOP_ARG() is identical to Z80_RDOP() except it is used for reading  */
 /* opcode arguments. This difference can be used to support systems that    */
 /* use different encoding mechanisms for opcodes and opcode arguments       */
 /****************************************************************************/
-#define ROP_ARG(Addr) ((unsigned)memory_raw_read_byte(m68_state->program, Addr))
+#define ROP_ARG(Addr) ((unsigned)m68_state->direct->read_raw_byte(Addr))
 
 /* macros to access memory */
 #define IMMBYTE(b)	b = ROP_ARG(PCD); PC++
@@ -522,6 +523,7 @@
 	m68_state->device = device;
 
 	m68_state->program = device->space(AS_PROGRAM);
+	m68_state->direct = &m68_state->program->direct();
 
 	/* setup regtable */
 
diff -Nru src-old/emu/cpu/i386/i386.c src/emu/cpu/i386/i386.c
--- src-old/emu/cpu/i386/i386.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/cpu/i386/i386.c	2010-08-19 09:10:19.000000000 -0700
@@ -549,6 +549,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	state_save_register_device_item_array(device, 0,	cpustate->reg.d);
@@ -648,6 +649,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sreg[CS].selector = 0xf000;
@@ -1103,6 +1105,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sreg[CS].selector = 0xf000;
@@ -1219,6 +1222,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sreg[CS].selector = 0xf000;
@@ -1350,6 +1354,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sreg[CS].selector = 0xf000;
diff -Nru src-old/emu/cpu/i386/i386priv.h src/emu/cpu/i386/i386priv.h
--- src-old/emu/cpu/i386/i386priv.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i386/i386priv.h	2010-08-19 09:10:19.000000000 -0700
@@ -228,8 +228,9 @@
 	UINT8 irq_state;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	UINT32 a20_mask;
 
 	int cpuid_max_input_value_eax;
@@ -349,15 +350,15 @@
 	UINT32 page_entry;
 
 	// TODO: 4MB pages
-	UINT32 page_dir = memory_read_dword_32le(cpustate->program, pdbr + directory * 4);
+	UINT32 page_dir = cpustate->program->read_dword(pdbr + directory * 4);
 	if (!(cpustate->cr[4] & 0x10)) {
-		page_entry = memory_read_dword_32le(cpustate->program, (page_dir & 0xfffff000) + (table * 4));
+		page_entry = cpustate->program->read_dword((page_dir & 0xfffff000) + (table * 4));
 		*address = (page_entry & 0xfffff000) | offset;
 	} else {
 		if (page_dir & 0x80)
 			*address = (page_dir & 0xffc00000) | (a & 0x003fffff);
 		else {
-			page_entry = memory_read_dword_32le(cpustate->program, (page_dir & 0xfffff000) + (table * 4));
+			page_entry = cpustate->program->read_dword((page_dir & 0xfffff000) + (table * 4));
 			*address = (page_entry & 0xfffff000) | offset;
 		}
 	}
@@ -402,7 +403,7 @@
 		translate_address(cpustate,&address);
 	}
 
-	value = memory_decrypted_read_byte(cpustate->program, address & cpustate->a20_mask);
+	value = cpustate->direct->read_decrypted_byte(address & cpustate->a20_mask);
 	cpustate->eip++;
 	cpustate->pc++;
 	return value;
@@ -421,7 +422,7 @@
 			translate_address(cpustate,&address);
 		}
 		address &= cpustate->a20_mask;
-		value = memory_decrypted_read_word(cpustate->program, address);
+		value = cpustate->direct->read_decrypted_word(address);
 		cpustate->eip += 2;
 		cpustate->pc += 2;
 	}
@@ -444,7 +445,7 @@
 		}
 
 		address &= cpustate->a20_mask;
-		value = memory_decrypted_read_dword(cpustate->program, address);
+		value = cpustate->direct->read_decrypted_dword(address);
 		cpustate->eip += 4;
 		cpustate->pc += 4;
 	}
@@ -461,7 +462,7 @@
 	}
 
 	address &= cpustate->a20_mask;
-	return memory_read_byte_32le(cpustate->program, address);
+	return cpustate->program->read_byte(address);
 }
 INLINE UINT16 READ16(i386_state *cpustate,UINT32 ea)
 {
@@ -478,7 +479,7 @@
 		}
 
 		address &= cpustate->a20_mask;
-		value = memory_read_word_32le( cpustate->program, address );
+		value = cpustate->program->read_word( address );
 	}
 	return value;
 }
@@ -499,7 +500,7 @@
 		}
 
 		address &= cpustate->a20_mask;
-		value = memory_read_dword_32le( cpustate->program, address );
+		value = cpustate->program->read_dword( address );
 	}
 	return value;
 }
@@ -525,8 +526,8 @@
 		}
 
 		address &= cpustate->a20_mask;
-		value = (((UINT64) memory_read_dword_32le( cpustate->program, address+0 )) << 0) |
-				(((UINT64) memory_read_dword_32le( cpustate->program, address+4 )) << 32);
+		value = (((UINT64) cpustate->program->read_dword( address+0 )) << 0) |
+				(((UINT64) cpustate->program->read_dword( address+4 )) << 32);
 	}
 	return value;
 }
@@ -541,7 +542,7 @@
 	}
 
 	address &= cpustate->a20_mask;
-	memory_write_byte_32le(cpustate->program, address, value);
+	cpustate->program->write_byte(address, value);
 }
 INLINE void WRITE16(i386_state *cpustate,UINT32 ea, UINT16 value)
 {
@@ -557,7 +558,7 @@
 		}
 
 		address &= cpustate->a20_mask;
-		memory_write_word_32le(cpustate->program, address, value);
+		cpustate->program->write_word(address, value);
 	}
 }
 INLINE void WRITE32(i386_state *cpustate,UINT32 ea, UINT32 value)
@@ -576,7 +577,7 @@
 		}
 
 		ea &= cpustate->a20_mask;
-		memory_write_dword_32le(cpustate->program, address, value);
+		cpustate->program->write_dword(address, value);
 	}
 }
 
@@ -600,8 +601,8 @@
 		}
 
 		ea &= cpustate->a20_mask;
-		memory_write_dword_32le(cpustate->program, address+0, value & 0xffffffff);
-		memory_write_dword_32le(cpustate->program, address+4, (value >> 32) & 0xffffffff);
+		cpustate->program->write_dword(address+0, value & 0xffffffff);
+		cpustate->program->write_dword(address+4, (value >> 32) & 0xffffffff);
 	}
 }
 
@@ -892,11 +893,11 @@
 
 /***********************************************************************************/
 
-#define READPORT8(port)		    	(memory_read_byte_32le(cpustate->io, port))
-#define READPORT16(port)	    	(memory_read_word_32le(cpustate->io, port))
-#define READPORT32(port)	    	(memory_read_dword_32le(cpustate->io, port))
-#define WRITEPORT8(port, value)		(memory_write_byte_32le(cpustate->io, port, value))
-#define WRITEPORT16(port, value)	(memory_write_word_32le(cpustate->io, port, value))
-#define WRITEPORT32(port, value)	(memory_write_dword_32le(cpustate->io, port, value))
+#define READPORT8(port)		    	(cpustate->io->read_byte(port))
+#define READPORT16(port)	    	(cpustate->io->read_word(port))
+#define READPORT32(port)	    	(cpustate->io->read_dword(port))
+#define WRITEPORT8(port, value)		(cpustate->io->write_byte(port, value))
+#define WRITEPORT16(port, value)	(cpustate->io->write_word(port, value))
+#define WRITEPORT32(port, value)	(cpustate->io->write_dword(port, value))
 
 #endif /* __I386_H__ */
diff -Nru src-old/emu/cpu/i4004/i4004.c src/emu/cpu/i4004/i4004.c
--- src-old/emu/cpu/i4004/i4004.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i4004/i4004.c	2010-08-19 09:10:19.000000000 -0700
@@ -34,9 +34,10 @@
 	UINT8	flags; // used for I/O only
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 	int					icount;
 	int 				pc_pos; // PC possition in ADDR
 	int					addr_mask;
@@ -60,7 +61,7 @@
 
 INLINE UINT8 ROP(i4004_state *cpustate)
 {
-	UINT8 retVal = memory_decrypted_read_byte(cpustate->program, GET_PC.w.l);
+	UINT8 retVal = cpustate->direct->read_decrypted_byte(GET_PC.w.l);
 	GET_PC.w.l = (GET_PC.w.l + 1) & 0x0fff;
 	cpustate->PC = GET_PC;
 	return retVal;
@@ -68,19 +69,19 @@
 
 INLINE UINT8 READ_ROM(i4004_state *cpustate)
 {
-	return memory_decrypted_read_byte(cpustate->program, (GET_PC.w.l & 0x0f00) | cpustate->R[0]);
+	return cpustate->direct->read_decrypted_byte((GET_PC.w.l & 0x0f00) | cpustate->R[0]);
 }
 
 INLINE void WPM(i4004_state *cpustate)
 {
-	UINT8 t =  (memory_read_byte_8le(cpustate->program, cpustate->RAM.d) << 4) | cpustate->A;
-	memory_write_byte_8le(cpustate->program, (GET_PC.w.l & 0x0f00) | cpustate->RAM.d, t);
+	UINT8 t =  (cpustate->program->read_byte(cpustate->RAM.d) << 4) | cpustate->A;
+	cpustate->program->write_byte((GET_PC.w.l & 0x0f00) | cpustate->RAM.d, t);
 }
 
 
 INLINE UINT8 ARG(i4004_state *cpustate)
 {
-	UINT8 retVal = memory_raw_read_byte(cpustate->program, GET_PC.w.l);
+	UINT8 retVal = cpustate->direct->read_raw_byte(GET_PC.w.l);
 	GET_PC.w.l = (GET_PC.w.l + 1) & 0x0fff;
 	cpustate->PC = GET_PC;
 	return retVal;
@@ -88,40 +89,40 @@
 
 INLINE UINT8 RM(i4004_state *cpustate)
 {
-	return memory_read_byte_8le(cpustate->data, cpustate->RAM.d) & 0x0f;
+	return cpustate->data->read_byte(cpustate->RAM.d) & 0x0f;
 }
 
 INLINE UINT8 RMS(i4004_state *cpustate, UINT32 a)
 {
-	return memory_read_byte_8le(cpustate->data, (cpustate->RAM.d & 0xff0) + a) >> 4;
+	return cpustate->data->read_byte((cpustate->RAM.d & 0xff0) + a) >> 4;
 }
 
 INLINE void WM(i4004_state *cpustate, UINT8 v)
 {
-	UINT8 t =  memory_read_byte_8le(cpustate->data, cpustate->RAM.d);
-	memory_write_byte_8le(cpustate->data, cpustate->RAM.d, (t & 0xf0) | v);
+	UINT8 t =  cpustate->data->read_byte(cpustate->RAM.d);
+	cpustate->data->write_byte(cpustate->RAM.d, (t & 0xf0) | v);
 }
 
 
 INLINE void WMP(i4004_state *cpustate, UINT8 v)
 {
-	memory_write_byte_8le(cpustate->io, (cpustate->RAM.d >> 6) | 0x10, v & 0x0f);
+	cpustate->io->write_byte((cpustate->RAM.d >> 6) | 0x10, v & 0x0f);
 }
 
 INLINE void WMS(i4004_state *cpustate, UINT32 a, UINT8 v)
 {
-	UINT8 t =  memory_read_byte_8le(cpustate->data, (cpustate->RAM.d & 0xff0) + a);
-	memory_write_byte_8le(cpustate->data,(cpustate->RAM.d & 0xff0) + a, (t & 0x0f) | (v<<4));
+	UINT8 t =  cpustate->data->read_byte((cpustate->RAM.d & 0xff0) + a);
+	cpustate->data->write_byte((cpustate->RAM.d & 0xff0) + a, (t & 0x0f) | (v<<4));
 }
 
 INLINE UINT8 RIO(i4004_state *cpustate)
 {
-	return memory_read_byte_8le(cpustate->io, cpustate->RAM.b.l >> 4) & 0x0f;
+	return cpustate->io->read_byte(cpustate->RAM.b.l >> 4) & 0x0f;
 }
 
 INLINE void WIO(i4004_state *cpustate, UINT8 v)
 {
-	memory_write_byte_8le(cpustate->io, cpustate->RAM.b.l >> 4, v & 0x0f);
+	cpustate->io->write_byte(cpustate->RAM.b.l >> 4, v & 0x0f);
 }
 
 INLINE UINT8 GET_REG(i4004_state *cpustate, UINT8 num)
@@ -463,6 +464,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/i8008/i8008.c src/emu/cpu/i8008/i8008.c
--- src-old/emu/cpu/i8008/i8008.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i8008/i8008.c	2010-08-19 09:10:19.000000000 -0700
@@ -34,8 +34,9 @@
 	UINT8	HALT;
 	UINT8	flags; // temporary I/O only
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int					icount;
 	int 				pc_pos; // PC possition in ADDR
 
@@ -74,7 +75,7 @@
 
 INLINE UINT8 ROP(i8008_state *cpustate)
 {
-	UINT8 retVal = memory_decrypted_read_byte(cpustate->program, GET_PC.w.l);
+	UINT8 retVal = cpustate->direct->read_decrypted_byte(GET_PC.w.l);
 	GET_PC.w.l = (GET_PC.w.l + 1) & 0x3fff;
 	cpustate->PC = GET_PC;
 	return retVal;
@@ -91,7 +92,7 @@
 		case 4 : retVal = cpustate->E; break;
 		case 5 : retVal = cpustate->H; break;
 		case 6 : retVal = cpustate->L; break;
-		default: retVal = memory_read_byte_8le(cpustate->program, (cpustate->H << 8) + cpustate->L); break;
+		default: retVal = cpustate->program->read_byte((cpustate->H << 8) + cpustate->L); break;
 	}
 	return retVal;
 }
@@ -106,13 +107,13 @@
 		case 4 : cpustate->E = val; break;
 		case 5 : cpustate->H = val; break;
 		case 6 : cpustate->L = val; break;
-		default: memory_write_byte_8le(cpustate->program, (cpustate->H << 8) + cpustate->L, val); break;
+		default: cpustate->program->write_byte((cpustate->H << 8) + cpustate->L, val); break;
 	}
 }
 
 INLINE UINT8 ARG(i8008_state *cpustate)
 {
-	UINT8 retVal = memory_raw_read_byte(cpustate->program, GET_PC.w.l);
+	UINT8 retVal = cpustate->direct->read_raw_byte(GET_PC.w.l);
 	GET_PC.w.l = (GET_PC.w.l + 1) & 0x3fff;
 	cpustate->PC = GET_PC;
 	return retVal;
@@ -391,11 +392,11 @@
 							if (((opcode>>4)&3)==0) {
 								// INP
 								cpustate->icount -= 8;
-								cpustate->A = memory_read_byte_8le(cpustate->io, (opcode >> 1) & 0x1f);
+								cpustate->A = cpustate->io->read_byte((opcode >> 1) & 0x1f);
 							} else {
 								// OUT
 								cpustate->icount -= 6;
-								memory_write_byte_8le(cpustate->io, (opcode >> 1) & 0x1f, cpustate->A);
+								cpustate->io->write_byte((opcode >> 1) & 0x1f, cpustate->A);
 							}
 							break;
 					}
@@ -543,6 +544,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->irq_callback = irqcallback;
diff -Nru src-old/emu/cpu/i8085/i8085.c src/emu/cpu/i8085/i8085.c
--- src-old/emu/cpu/i8085/i8085.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i8085/i8085.c	2010-08-19 09:10:19.000000000 -0700
@@ -184,8 +184,9 @@
 
 	device_irq_callback	irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int					icount;
 };
 
@@ -353,20 +354,20 @@
 INLINE UINT8 ROP(i8085_state *cpustate)
 {
 	set_status(cpustate, 0xa2); // instruction fetch
-	return memory_decrypted_read_byte(cpustate->program, cpustate->PC.w.l++);
+	return cpustate->direct->read_decrypted_byte(cpustate->PC.w.l++);
 }
 
 INLINE UINT8 ARG(i8085_state *cpustate)
 {
-	return memory_raw_read_byte(cpustate->program, cpustate->PC.w.l++);
+	return cpustate->direct->read_raw_byte(cpustate->PC.w.l++);
 }
 
 INLINE UINT16 ARG16(i8085_state *cpustate)
 {
 	UINT16 w;
-	w  = memory_raw_read_byte(cpustate->program, cpustate->PC.d);
+	w  = cpustate->direct->read_raw_byte(cpustate->PC.d);
 	cpustate->PC.w.l++;
-	w += memory_raw_read_byte(cpustate->program, cpustate->PC.d) << 8;
+	w += cpustate->direct->read_raw_byte(cpustate->PC.d) << 8;
 	cpustate->PC.w.l++;
 	return w;
 }
@@ -374,13 +375,13 @@
 INLINE UINT8 RM(i8085_state *cpustate, UINT32 a)
 {
 	set_status(cpustate, 0x82); // memory read
-	return memory_read_byte_8le(cpustate->program, a);
+	return cpustate->program->read_byte(a);
 }
 
 INLINE void WM(i8085_state *cpustate, UINT32 a, UINT8 v)
 {
 	set_status(cpustate, 0x00); // memory write
-	memory_write_byte_8le(cpustate->program, a, v);
+	cpustate->program->write_byte(a, v);
 }
 
 
@@ -1006,6 +1007,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* resolve callbacks */
diff -Nru src-old/emu/cpu/i8085/i8085cpu.h src/emu/cpu/i8085/i8085cpu.h
--- src-old/emu/cpu/i8085/i8085cpu.h	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/i8085/i8085cpu.h	2010-08-19 01:27:05.000000000 -0700
@@ -125,24 +125,24 @@
 #define M_IN																		\
 	cpustate->STATUS = 0x42;														\
 	cpustate->WZ.d=ARG(cpustate);													\
-	cpustate->AF.b.h=memory_read_byte_8le(cpustate->io, cpustate->WZ.d);
+	cpustate->AF.b.h=cpustate->io->read_byte(cpustate->WZ.d);
 
 #define M_OUT																		\
 	cpustate->STATUS = 0x10;														\
 	cpustate->WZ.d=ARG(cpustate);													\
-	memory_write_byte_8le(cpustate->io, cpustate->WZ.d,cpustate->AF.b.h)
+	cpustate->io->write_byte(cpustate->WZ.d,cpustate->AF.b.h)
 
 /* stack */
 #define M_PUSH(R) {                                             					\
 	cpustate->STATUS = 0x04;														\
-	memory_write_byte_8le(cpustate->program, --cpustate->SP.w.l, cpustate->R.b.h);	\
-	memory_write_byte_8le(cpustate->program, --cpustate->SP.w.l, cpustate->R.b.l);	\
+	cpustate->program->write_byte(--cpustate->SP.w.l, cpustate->R.b.h);	\
+	cpustate->program->write_byte(--cpustate->SP.w.l, cpustate->R.b.l);	\
 }
 
 #define M_POP(R) {																	\
 	cpustate->STATUS = 0x86;														\
-	cpustate->R.b.l = memory_read_byte_8le(cpustate->program, cpustate->SP.w.l++);	\
-	cpustate->R.b.h = memory_read_byte_8le(cpustate->program, cpustate->SP.w.l++);	\
+	cpustate->R.b.l = cpustate->program->read_byte(cpustate->SP.w.l++);	\
+	cpustate->R.b.h = cpustate->program->read_byte(cpustate->SP.w.l++);	\
 }
 
 /* jumps */
diff -Nru src-old/emu/cpu/i86/i286.c src/emu/cpu/i86/i286.c
--- src-old/emu/cpu/i86/i286.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i86/i286.c	2010-08-21 11:40:01.000000000 -0700
@@ -22,7 +22,6 @@
 
 
 #include "i86time.c"
-#include "i86mem.h"
 
 /***************************************************************************/
 /* cpu state                                                               */
@@ -38,6 +37,7 @@
 struct _i80286_state
 {
     i80286basicregs regs;
+    offs_t fetch_xor;
 	UINT32	amask;			/* address mask */
     UINT32  pc;
     UINT32  prevpc;
@@ -59,8 +59,9 @@
 	} ldtr, tr;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	INT32	AuxVal, OverVal, SignVal, ZeroVal, CarryVal, DirVal; /* 0 or non-0 valued flags */
 	UINT8	ParityVal;
 	UINT8	TF, IF; 	/* 0 or 1 valued flags */
@@ -73,7 +74,6 @@
 
 	int halted;         /* Is the CPU halted ? */
 
-	memory_interface	mem;
 	int icount;
 	unsigned prefix_base;
 	char seg_prefix;
@@ -113,7 +113,6 @@
 #include "instr86.c"
 #include "instr186.c"
 #include "instr286.c"
-#include "i86mem.c"
 
 static void i80286_urinit(void)
 {
@@ -294,6 +293,7 @@
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
 	cpustate->io = device->space(AS_IO);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* If a reset parameter is given, take it as pointer to an address mask */
 	if( device->baseconfig().static_config() )
@@ -301,7 +301,7 @@
 	else
 		cpustate->amask = 0x00ffff;
 
-	configure_memory_16bit(cpustate);
+	cpustate->fetch_xor = BYTE_XOR_LE(0);
 }
 
 
diff -Nru src-old/emu/cpu/i86/i86.c src/emu/cpu/i86/i86.c
--- src-old/emu/cpu/i86/i86.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i86/i86.c	2010-08-21 11:40:01.000000000 -0700
@@ -11,8 +11,6 @@
 #include "i86priv.h"
 #include "i86.h"
 
-#include "i86mem.h"
-
 extern int i386_dasm_one(char *buffer, UINT32 eip, const UINT8 *oprom, int mode);
 
 #define VERBOSE 0
@@ -35,6 +33,7 @@
 struct _i8086_state
 {
 	i8086basicregs regs;
+	offs_t fetch_xor;
 	UINT32 pc;
 	UINT32 prevpc;
 	UINT32 base[4];
@@ -57,11 +56,10 @@
 	UINT16 ip;
 	UINT32 sp;
 
-	memory_interface	mem;
-
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int icount;
 
 	unsigned prefix_base;		   /* base address of the latest prefix segment */
@@ -105,7 +103,6 @@
 #include "table86.h"
 
 #include "instr86.c"
-#include "i86mem.c"
 #undef I8086
 
 
@@ -167,6 +164,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* set up the state table */
@@ -201,29 +199,27 @@
 	}
 
 	i8086_state_register(device);
-	configure_memory_16bit(cpustate);
+	cpustate->fetch_xor = BYTE_XOR_LE(0);
 }
 
 static CPU_INIT( i8088 )
 {
 	i8086_state *cpustate = get_safe_token(device);
 	CPU_INIT_CALL(i8086);
-	configure_memory_8bit(cpustate);
+	cpustate->fetch_xor = 0;
 }
 
 static CPU_RESET( i8086 )
 {
 	i8086_state *cpustate = get_safe_token(device);
 	device_irq_callback save_irqcallback;
-	memory_interface save_mem;
 
 	save_irqcallback = cpustate->irq_callback;
-	save_mem = cpustate->mem;
 	memset(cpustate, 0, sizeof(*cpustate));
 	cpustate->irq_callback = save_irqcallback;
-	cpustate->mem = save_mem;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sregs[CS] = 0xf000;
diff -Nru src-old/emu/cpu/i86/i86mem.c src/emu/cpu/i86/i86mem.c
--- src-old/emu/cpu/i86/i86mem.c	2009-03-25 12:39:41.000000000 -0700
+++ src/emu/cpu/i86/i86mem.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,52 +0,0 @@
-/*****************************************************************************
-    8-bit memory accessors
- *****************************************************************************/
-
-#ifdef I8086
-static void configure_memory_8bit(i8086_state *cpustate)
-{
-	cpustate->mem.fetch_xor = 0;
-
-	cpustate->mem.rbyte = memory_read_byte_8le;
-	cpustate->mem.rword = memory_read_word_8le;
-	cpustate->mem.wbyte = memory_write_byte_8le;
-	cpustate->mem.wword = memory_write_word_8le;
-}
-#endif
-
-
-/*****************************************************************************
-    16-bit memory accessors
- *****************************************************************************/
-
-static UINT16 read_word_16le(const address_space *space, offs_t addr)
-{
-	if (!(addr & 1))
-		return memory_read_word_16le(space, addr);
-	else
-	{
-		UINT16 result = memory_read_byte_16le(space, addr);
-		return result | (memory_read_byte_16le(space, addr + 1) << 8);
-	}
-}
-
-static void write_word_16le(const address_space *space, offs_t addr, UINT16 data)
-{
-	if (!(addr & 1))
-		memory_write_word_16le(space, addr, data);
-	else
-	{
-		memory_write_byte_16le(space, addr, data);
-		memory_write_byte_16le(space, addr + 1, data >> 8);
-	}
-}
-
-static void configure_memory_16bit(i8086_state *cpustate)
-{
-	cpustate->mem.fetch_xor = BYTE_XOR_LE(0);
-
-	cpustate->mem.rbyte = memory_read_byte_16le;
-	cpustate->mem.rword = read_word_16le;
-	cpustate->mem.wbyte = memory_write_byte_16le;
-	cpustate->mem.wword = write_word_16le;
-}
diff -Nru src-old/emu/cpu/i86/i86mem.h src/emu/cpu/i86/i86mem.h
--- src-old/emu/cpu/i86/i86mem.h	2008-11-22 11:38:41.000000000 -0800
+++ src/emu/cpu/i86/i86mem.h	1969-12-31 16:00:00.000000000 -0800
@@ -1,10 +0,0 @@
-typedef struct _memory_interface memory_interface;
-struct _memory_interface
-{
-	offs_t	fetch_xor;
-
-	UINT8	(*rbyte)(const address_space *, offs_t);
-	UINT16	(*rword)(const address_space *, offs_t);
-	void	(*wbyte)(const address_space *, offs_t, UINT8);
-	void	(*wword)(const address_space *, offs_t, UINT16);
-};
diff -Nru src-old/emu/cpu/i86/i86priv.h src/emu/cpu/i86/i86priv.h
--- src-old/emu/cpu/i86/i86priv.h	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/i86/i86priv.h	2010-08-21 11:40:01.000000000 -0700
@@ -84,15 +84,15 @@
 
 /************************************************************************/
 
-#define read_byte(a)			(*cpustate->mem.rbyte)(cpustate->program, a)
-#define read_word(a)			(*cpustate->mem.rword)(cpustate->program, a)
-#define write_byte(a,d)			(*cpustate->mem.wbyte)(cpustate->program, (a),(d))
-#define write_word(a,d)			(*cpustate->mem.wword)(cpustate->program, (a),(d))
-
-#define read_port_byte(a)		(*cpustate->mem.rbyte)(cpustate->io, a)
-#define read_port_word(a)		(*cpustate->mem.rword)(cpustate->io, a)
-#define write_port_byte(a,d)	(*cpustate->mem.wbyte)(cpustate->io, (a),(d))
-#define write_port_word(a,d)	(*cpustate->mem.wword)(cpustate->io, (a),(d))
+#define read_mem_byte(a)			cpustate->program->read_byte(a)
+#define read_mem_word(a)			cpustate->program->read_word_unaligned(a)
+#define write_mem_byte(a,d)			cpustate->program->write_byte((a),(d))
+#define write_mem_word(a,d)			cpustate->program->write_word_unaligned((a),(d))
+
+#define read_port_byte(a)		cpustate->io->read_byte(a)
+#define read_port_word(a)		cpustate->io->read_word_unaligned(a)
+#define write_port_byte(a,d)	cpustate->io->write_byte((a),(d))
+#define write_port_word(a,d)	cpustate->io->write_word_unaligned((a),(d))
 
 /************************************************************************/
 
@@ -100,22 +100,22 @@
 
 #define DefaultBase(Seg)		((cpustate->seg_prefix && (Seg == DS || Seg == SS)) ? cpustate->prefix_base : cpustate->base[Seg])
 
-#define GetMemB(Seg,Off)		(read_byte((DefaultBase(Seg) + (Off)) & AMASK))
-#define GetMemW(Seg,Off)		(read_word((DefaultBase(Seg) + (Off)) & AMASK))
-#define PutMemB(Seg,Off,x)		write_byte((DefaultBase(Seg) + (Off)) & AMASK, (x))
-#define PutMemW(Seg,Off,x)		write_word((DefaultBase(Seg) + (Off)) & AMASK, (x))
-
-#define PEEKBYTE(ea)			(read_byte((ea) & AMASK))
-#define ReadByte(ea)			(read_byte((ea) & AMASK))
-#define ReadWord(ea)			(read_word((ea) & AMASK))
-#define WriteByte(ea,val)		write_byte((ea) & AMASK, val);
-#define WriteWord(ea,val)		write_word((ea) & AMASK, val);
-
-#define FETCH_XOR(a)			((a) ^ cpustate->mem.fetch_xor)
-#define FETCH					(memory_raw_read_byte(cpustate->program, FETCH_XOR(cpustate->pc++)))
-#define FETCHOP					(memory_decrypted_read_byte(cpustate->program, FETCH_XOR(cpustate->pc++)))
-#define PEEKOP(addr)			(memory_decrypted_read_byte(cpustate->program, FETCH_XOR(addr)))
-#define FETCHWORD(var)			{ var = memory_raw_read_byte(cpustate->program, FETCH_XOR(cpustate->pc)); var += (memory_raw_read_byte(cpustate->program, FETCH_XOR(cpustate->pc + 1)) << 8); cpustate->pc += 2; }
+#define GetMemB(Seg,Off)		(read_mem_byte((DefaultBase(Seg) + (Off)) & AMASK))
+#define GetMemW(Seg,Off)		(read_mem_word((DefaultBase(Seg) + (Off)) & AMASK))
+#define PutMemB(Seg,Off,x)		write_mem_byte((DefaultBase(Seg) + (Off)) & AMASK, (x))
+#define PutMemW(Seg,Off,x)		write_mem_word((DefaultBase(Seg) + (Off)) & AMASK, (x))
+
+#define PEEKBYTE(ea)			(read_mem_byte((ea) & AMASK))
+#define ReadByte(ea)			(read_mem_byte((ea) & AMASK))
+#define ReadWord(ea)			(read_mem_word((ea) & AMASK))
+#define WriteByte(ea,val)		write_mem_byte((ea) & AMASK, val);
+#define WriteWord(ea,val)		write_mem_word((ea) & AMASK, val);
+
+#define FETCH_XOR(a)			((a) ^ cpustate->fetch_xor)
+#define FETCH					(cpustate->direct->read_raw_byte(FETCH_XOR(cpustate->pc++)))
+#define FETCHOP					(cpustate->direct->read_decrypted_byte(FETCH_XOR(cpustate->pc++)))
+#define PEEKOP(addr)			(cpustate->direct->read_decrypted_byte(FETCH_XOR(addr)))
+#define FETCHWORD(var)			{ var = cpustate->direct->read_raw_byte(FETCH_XOR(cpustate->pc)); var += (cpustate->direct->read_raw_byte(FETCH_XOR(cpustate->pc + 1)) << 8); cpustate->pc += 2; }
 #define CHANGE_PC(addr)
 #define PUSH(val)				{ cpustate->regs.w[SP] -= 2; WriteWord(((cpustate->base[SS] + cpustate->regs.w[SP]) & AMASK), val); }
 #define POP(var)				{ var = ReadWord(((cpustate->base[SS] + cpustate->regs.w[SP]) & AMASK)); cpustate->regs.w[SP] += 2; }
diff -Nru src-old/emu/cpu/i860/i860.h src/emu/cpu/i860/i860.h
--- src-old/emu/cpu/i860/i860.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i860/i860.h	2010-08-19 00:26:14.000000000 -0700
@@ -169,7 +169,7 @@
      * MAME-specific stuff.
      */
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	UINT32 ppc;
 	int icount;
 
diff -Nru src-old/emu/cpu/i860/i860dec.c src/emu/cpu/i860/i860dec.c
--- src-old/emu/cpu/i860/i860dec.c	2010-06-09 09:20:50.000000000 -0700
+++ src/emu/cpu/i860/i860dec.c	2010-08-19 01:27:05.000000000 -0700
@@ -369,7 +369,7 @@
 
 	/* Since i860 instructions are always stored LSB first (regardless of
        the BE bit), we need to adjust the instruction below on MSB hosts.  */
-	w1 = memory_read_dword_64le(cpustate->program, phys_pc);
+	w1 = cpustate->program->read_dword(phys_pc);
 #ifdef HOST_MSB
 	BYTE_REV32 (w1);
 #endif /* HOST_MSB.  */
@@ -407,7 +407,7 @@
 
 	/* Get page directory entry at DTB:DIR:00.  */
 	pg_dir_entry_a = dtb | (vdir << 2);
-	pg_dir_entry = memory_read_dword_64le(cpustate->program, pg_dir_entry_a);
+	pg_dir_entry = cpustate->program->read_dword(pg_dir_entry_a);
 #ifdef HOST_MSB
 	BYTE_REV32 (pg_dir_entry);
 #endif
@@ -455,7 +455,7 @@
 	/* Get page table entry at PFA1:PAGE:00.  */
 	pfa1 = pg_dir_entry & 0xfffff000;
 	pg_tbl_entry_a = pfa1 | (vpage << 2);
-	pg_tbl_entry = memory_read_dword_64le(cpustate->program, pg_tbl_entry_a);
+	pg_tbl_entry = cpustate->program->read_dword(pg_tbl_entry_a);
 #ifdef HOST_MSB
 	BYTE_REV32 (pg_tbl_entry);
 #endif
@@ -505,8 +505,8 @@
 	BYTE_REV32 (ttpde);
 	BYTE_REV32 (ttpte);
 #endif
-	memory_write_dword_64le(cpustate->program, pg_dir_entry_a, ttpde);
-	memory_write_dword_64le(cpustate->program, pg_tbl_entry_a, ttpte);
+	cpustate->program->write_dword(pg_dir_entry_a, ttpde);
+	cpustate->program->write_dword(pg_tbl_entry_a, ttpte);
 
 	if (is_write && is_dataref && (pg_tbl_entry & 0x40) == 0)
 	{
@@ -567,12 +567,12 @@
 	/* Now do the actual read.  */
 	if (size == 1)
 	{
-		UINT32 ret = memory_read_byte_64le(cpustate->program, addr);
+		UINT32 ret = cpustate->program->read_byte(addr);
 		return ret & 0xff;
 	}
 	else if (size == 2)
 	{
-		UINT32 ret = memory_read_word_64le(cpustate->program, addr);
+		UINT32 ret = cpustate->program->read_word(addr);
 #ifdef HOST_MSB
 		BYTE_REV16 (ret);
 #endif
@@ -580,7 +580,7 @@
 	}
 	else if (size == 4)
 	{
-		UINT32 ret = memory_read_dword_64le(cpustate->program, addr);
+		UINT32 ret = cpustate->program->read_dword(addr);
 #ifdef HOST_MSB
 		BYTE_REV32 (ret);
 #endif
@@ -630,20 +630,20 @@
 
 	/* Now do the actual write.  */
 	if (size == 1)
-		memory_write_byte_64le(cpustate->program, addr, data);
+		cpustate->program->write_byte(addr, data);
 	else if (size == 2)
 	{
 #ifdef HOST_MSB
 		BYTE_REV16 (data);
 #endif
-		memory_write_word_64le(cpustate->program, addr, data);
+		cpustate->program->write_word(addr, data);
 	}
 	else if (size == 4)
 	{
 #ifdef HOST_MSB
 		BYTE_REV32 (data);
 #endif
-		memory_write_dword_64le(cpustate->program, addr, data);
+		cpustate->program->write_dword(addr, data);
 	}
 	else
 		assert (0);
@@ -689,28 +689,28 @@
 
 	if (size == 4)
 	{
-		dest[0] = memory_read_byte_64le(cpustate->program, addr+3);
-		dest[1] = memory_read_byte_64le(cpustate->program, addr+2);
-		dest[2] = memory_read_byte_64le(cpustate->program, addr+1);
-		dest[3] = memory_read_byte_64le(cpustate->program, addr+0);
+		dest[0] = cpustate->program->read_byte(addr+3);
+		dest[1] = cpustate->program->read_byte(addr+2);
+		dest[2] = cpustate->program->read_byte(addr+1);
+		dest[3] = cpustate->program->read_byte(addr+0);
 	}
 	else if (size == 8)
 	{
-		dest[0] = memory_read_byte_64le(cpustate->program, addr+7);
-		dest[1] = memory_read_byte_64le(cpustate->program, addr+6);
-		dest[2] = memory_read_byte_64le(cpustate->program, addr+5);
-		dest[3] = memory_read_byte_64le(cpustate->program, addr+4);
-		dest[4] = memory_read_byte_64le(cpustate->program, addr+3);
-		dest[5] = memory_read_byte_64le(cpustate->program, addr+2);
-		dest[6] = memory_read_byte_64le(cpustate->program, addr+1);
-		dest[7] = memory_read_byte_64le(cpustate->program, addr+0);
+		dest[0] = cpustate->program->read_byte(addr+7);
+		dest[1] = cpustate->program->read_byte(addr+6);
+		dest[2] = cpustate->program->read_byte(addr+5);
+		dest[3] = cpustate->program->read_byte(addr+4);
+		dest[4] = cpustate->program->read_byte(addr+3);
+		dest[5] = cpustate->program->read_byte(addr+2);
+		dest[6] = cpustate->program->read_byte(addr+1);
+		dest[7] = cpustate->program->read_byte(addr+0);
 	}
 	else if (size == 16)
 	{
 		int i;
 		for (i = 0; i < 16; i++)
 		{
-			dest[i] = memory_read_byte_64le(cpustate->program, addr+15-i);
+			dest[i] = cpustate->program->read_byte(addr+15-i);
 		}
 	}
 }
@@ -757,13 +757,13 @@
 	if (size == 4)
 	{
 #if 1
-		memory_write_byte_64le(cpustate->program, addr+3, data[0]);
-		memory_write_byte_64le(cpustate->program, addr+2, data[1]);
-		memory_write_byte_64le(cpustate->program, addr+1, data[2]);
-		memory_write_byte_64le(cpustate->program, addr+0, data[3]);
+		cpustate->program->write_byte(addr+3, data[0]);
+		cpustate->program->write_byte(addr+2, data[1]);
+		cpustate->program->write_byte(addr+1, data[2]);
+		cpustate->program->write_byte(addr+0, data[3]);
 #else
 		UINT32 ddd = (data[3]) | (data[2] << 8) | (data[1] << 16) |(data[0] << 24);
-		memory_write_dword_64le(cpustate->program, addr+0, ddd);
+		cpustate->program->write_dword(addr+0, ddd);
 #endif
 	}
 	else if (size == 8)
@@ -771,25 +771,25 @@
 		/* Special: watch for wmask != 0xff, which means we're doing pst.d.  */
 		if (wmask == 0xff)
 		{
-			memory_write_byte_64le(cpustate->program, addr+7, data[0]);
-			memory_write_byte_64le(cpustate->program, addr+6, data[1]);
-			memory_write_byte_64le(cpustate->program, addr+5, data[2]);
-			memory_write_byte_64le(cpustate->program, addr+4, data[3]);
-			memory_write_byte_64le(cpustate->program, addr+3, data[4]);
-			memory_write_byte_64le(cpustate->program, addr+2, data[5]);
-			memory_write_byte_64le(cpustate->program, addr+1, data[6]);
-			memory_write_byte_64le(cpustate->program, addr+0, data[7]);
+			cpustate->program->write_byte(addr+7, data[0]);
+			cpustate->program->write_byte(addr+6, data[1]);
+			cpustate->program->write_byte(addr+5, data[2]);
+			cpustate->program->write_byte(addr+4, data[3]);
+			cpustate->program->write_byte(addr+3, data[4]);
+			cpustate->program->write_byte(addr+2, data[5]);
+			cpustate->program->write_byte(addr+1, data[6]);
+			cpustate->program->write_byte(addr+0, data[7]);
 		}
 		else
 		{
-			if (wmask & 0x80) memory_write_byte_64le(cpustate->program, addr+7, data[0]);
-			if (wmask & 0x40) memory_write_byte_64le(cpustate->program, addr+6, data[1]);
-			if (wmask & 0x20) memory_write_byte_64le(cpustate->program, addr+5, data[2]);
-			if (wmask & 0x10) memory_write_byte_64le(cpustate->program, addr+4, data[3]);
-			if (wmask & 0x08) memory_write_byte_64le(cpustate->program, addr+3, data[4]);
-			if (wmask & 0x04) memory_write_byte_64le(cpustate->program, addr+2, data[5]);
-			if (wmask & 0x02) memory_write_byte_64le(cpustate->program, addr+1, data[6]);
-			if (wmask & 0x01) memory_write_byte_64le(cpustate->program, addr+0, data[7]);
+			if (wmask & 0x80) cpustate->program->write_byte(addr+7, data[0]);
+			if (wmask & 0x40) cpustate->program->write_byte(addr+6, data[1]);
+			if (wmask & 0x20) cpustate->program->write_byte(addr+5, data[2]);
+			if (wmask & 0x10) cpustate->program->write_byte(addr+4, data[3]);
+			if (wmask & 0x08) cpustate->program->write_byte(addr+3, data[4]);
+			if (wmask & 0x04) cpustate->program->write_byte(addr+2, data[5]);
+			if (wmask & 0x02) cpustate->program->write_byte(addr+1, data[6]);
+			if (wmask & 0x01) cpustate->program->write_byte(addr+0, data[7]);
 		}
 	}
 	else if (size == 16)
@@ -797,7 +797,7 @@
 		int i;
 		for (i = 0; i < 16; i++)
 		{
-			memory_write_byte_64le(cpustate->program, addr+15-i, data[i]);
+			cpustate->program->write_byte(addr+15-i, data[i]);
 		}
 	}
 
@@ -4552,7 +4552,7 @@
 		/* Note that we print the incoming (possibly virtual) address as the
            PC rather than the translated address.  */
 		fprintf (stderr, "  (%s) 0x%08x: ", cpustate->device->tag(), addr);
-		insn = memory_read_dword_64le(cpustate->program, phys_addr);
+		insn = cpustate->program->read_dword(phys_addr);
 #ifdef HOST_MSB
 		BYTE_REV32 (insn);
 #endif /* HOST_MSB.  */
@@ -4584,7 +4584,7 @@
 			if (GET_DIRBASE_ATE ())
 				phys_addr = get_address_translation (cpustate, addr, 1	/* is_dataref */, 0	/* is_write */);
 
-			b[i] = memory_read_byte_64le(cpustate->program, phys_addr);
+			b[i] = cpustate->program->read_byte(phys_addr);
 			fprintf (stderr, "%02x ", b[i]);
 			addr++;
 		}
diff -Nru src-old/emu/cpu/i960/i960.c src/emu/cpu/i960/i960.c
--- src-old/emu/cpu/i960/i960.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/i960/i960.c	2010-08-19 09:10:19.000000000 -0700
@@ -35,7 +35,8 @@
 
 	device_irq_callback irq_cb;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 
 	int icount;
 };
@@ -52,31 +53,31 @@
 INLINE UINT32 i960_read_dword_unaligned(i960_state_t *i960, UINT32 address)
 {
 	if (address & 3)
-		return memory_read_byte_32le(i960->program, address) | memory_read_byte_32le(i960->program, address+1)<<8 | memory_read_byte_32le(i960->program, address+2)<<16 | memory_read_byte_32le(i960->program, address+3)<<24;
+		return i960->program->read_byte(address) | i960->program->read_byte(address+1)<<8 | i960->program->read_byte(address+2)<<16 | i960->program->read_byte(address+3)<<24;
 	else
-		return memory_read_dword_32le(i960->program, address);
+		return i960->program->read_dword(address);
 }
 
 INLINE UINT16 i960_read_word_unaligned(i960_state_t *i960, UINT32 address)
 {
 	if (address & 1)
-		return memory_read_byte_32le(i960->program, address) | memory_read_byte_32le(i960->program, address+1)<<8;
+		return i960->program->read_byte(address) | i960->program->read_byte(address+1)<<8;
 	else
-		return memory_read_word_32le(i960->program, address);
+		return i960->program->read_word(address);
 }
 
 INLINE void i960_write_dword_unaligned(i960_state_t *i960, UINT32 address, UINT32 data)
 {
 	if (address & 3)
 	{
-		memory_write_byte_32le(i960->program, address, data & 0xff);
-		memory_write_byte_32le(i960->program, address+1, (data>>8)&0xff);
-		memory_write_byte_32le(i960->program, address+2, (data>>16)&0xff);
-		memory_write_byte_32le(i960->program, address+3, (data>>24)&0xff);
+		i960->program->write_byte(address, data & 0xff);
+		i960->program->write_byte(address+1, (data>>8)&0xff);
+		i960->program->write_byte(address+2, (data>>16)&0xff);
+		i960->program->write_byte(address+3, (data>>24)&0xff);
 	}
 	else
 	{
-		memory_write_dword_32le(i960->program, address, data);
+		i960->program->write_dword(address, data);
 	}
 }
 
@@ -84,22 +85,22 @@
 {
 	if (address & 1)
 	{
-		memory_write_byte_32le(i960->program, address, data & 0xff);
-		memory_write_byte_32le(i960->program, address+1, (data>>8)&0xff);
+		i960->program->write_byte(address, data & 0xff);
+		i960->program->write_byte(address+1, (data>>8)&0xff);
 	}
 	else
 	{
-		memory_write_word_32le(i960->program, address, data);
+		i960->program->write_word(address, data);
 	}
 }
 
 INLINE void send_iac(i960_state_t *i960, UINT32 adr)
 {
 	UINT32 iac[4];
-	iac[0] = memory_read_dword_32le(i960->program, adr);
-	iac[1] = memory_read_dword_32le(i960->program, adr+4);
-	iac[2] = memory_read_dword_32le(i960->program, adr+8);
-	iac[3] = memory_read_dword_32le(i960->program, adr+12);
+	iac[0] = i960->program->read_dword(adr);
+	iac[1] = i960->program->read_dword(adr+4);
+	iac[2] = i960->program->read_dword(adr+8);
+	iac[3] = i960->program->read_dword(adr+12);
 
 	switch(iac[0]>>24) {
 	case 0x93: // reinit
@@ -136,22 +137,22 @@
 			return i960->r[abase] + (i960->r[index] << scale);
 
 		case 0xc:
-			ret = memory_decrypted_read_dword(i960->program, i960->IP);
+			ret = i960->direct->read_decrypted_dword(i960->IP);
 			i960->IP += 4;
 			return ret;
 
 		case 0xd:
-			ret = memory_decrypted_read_dword(i960->program, i960->IP) + i960->r[abase];
+			ret = i960->direct->read_decrypted_dword(i960->IP) + i960->r[abase];
 			i960->IP += 4;
 			return ret;
 
 		case 0xe:
-			ret = memory_decrypted_read_dword(i960->program, i960->IP) + (i960->r[index] << scale);
+			ret = i960->direct->read_decrypted_dword(i960->IP) + (i960->r[index] << scale);
 			i960->IP += 4;
 			return ret;
 
 		case 0xf:
-			ret = memory_decrypted_read_dword(i960->program, i960->IP) + i960->r[abase] + (i960->r[index] << scale);
+			ret = i960->direct->read_decrypted_dword(i960->IP) + i960->r[abase] + (i960->r[index] << scale);
 			i960->IP += 4;
 			return ret;
 
@@ -415,12 +416,12 @@
 // interrupt dispatch
 static void take_interrupt(i960_state_t *i960, int vector, int lvl)
 {
-	int int_tab =  memory_read_dword_32le(i960->program, i960->PRCB+20);	// interrupt table
-	int int_SP  =  memory_read_dword_32le(i960->program, i960->PRCB+24);	// interrupt stack
+	int int_tab =  i960->program->read_dword(i960->PRCB+20);	// interrupt table
+	int int_SP  =  i960->program->read_dword(i960->PRCB+24);	// interrupt stack
 	int SP;
 	UINT32 IRQV;
 
-	IRQV = memory_read_dword_32le(i960->program, int_tab + 36 + (vector-8)*4);
+	IRQV = i960->program->read_dword(int_tab + 36 + (vector-8)*4);
 
 	// start the process
 	if(!(i960->PC & 0x2000))	// if this is a nested interrupt, don't re-get int_SP
@@ -438,10 +439,10 @@
 	do_call(i960, IRQV, 7, SP);
 
 	// save the processor state
-	memory_write_dword_32le(i960->program, i960->r[I960_FP]-16, i960->PC);
-	memory_write_dword_32le(i960->program, i960->r[I960_FP]-12, i960->AC);
+	i960->program->write_dword(i960->r[I960_FP]-16, i960->PC);
+	i960->program->write_dword(i960->r[I960_FP]-12, i960->AC);
 	// store the vector
-	memory_write_dword_32le(i960->program, i960->r[I960_FP]-8, vector-8);
+	i960->program->write_dword(i960->r[I960_FP]-8, vector-8);
 
 	i960->PC &= ~0x1f00;	// clear priority, state, trace-fault pending, and trace enable
 	i960->PC |= (lvl<<16);	// set CPU level to current IRQ level
@@ -450,14 +451,14 @@
 
 static void check_irqs(i960_state_t *i960)
 {
-	int int_tab =  memory_read_dword_32le(i960->program, i960->PRCB+20);	// interrupt table
+	int int_tab =  i960->program->read_dword(i960->PRCB+20);	// interrupt table
 	int cpu_pri = (i960->PC>>16)&0x1f;
 	int pending_pri;
 	int lvl, irq, take = -1;
 	int vword;
 	static const UINT32 lvlmask[4] = { 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000 };
 
-	pending_pri = memory_read_dword_32le(i960->program, int_tab);		// read pending priorities
+	pending_pri = i960->program->read_dword(int_tab);		// read pending priorities
 
 	if ((i960->immediate_irq) && ((cpu_pri < i960->immediate_pri) || (i960->immediate_pri == 31)))
 	{
@@ -475,14 +476,14 @@
 				wordl = (lvl % 4) * 8;
 				wordh = (wordl + 8) - 1;
 
-				vword = memory_read_dword_32le(i960->program, int_tab + word);
+				vword = i960->program->read_dword(int_tab + word);
 
 				// take the first vector we find for this level
 				for (irq = wordh; irq >= wordl; irq--) {
 					if(vword & (1 << irq)) {
 						// clear pending bit
 						vword &= ~(1 << irq);
-						memory_write_dword_32le(i960->program, int_tab + word, vword);
+						i960->program->write_dword(int_tab + word, vword);
 						take = irq;
 						break;
 					}
@@ -494,14 +495,14 @@
 
 					// try to recover...
 					pending_pri &= ~(1 << lvl);
-					memory_write_dword_32le(i960->program, int_tab, pending_pri);
+					i960->program->write_dword(int_tab, pending_pri);
 					return;
 				}
 
 				// if no vectors are waiting for this level, clear the level bit
 				if(!(vword & lvlmask[lvl % 4])) {
 					pending_pri &= ~(1 << lvl);
-					memory_write_dword_32le(i960->program, int_tab, pending_pri);
+					i960->program->write_dword(int_tab, pending_pri);
 				}
 
 				take += ((lvl/4) * 32);
@@ -530,7 +531,7 @@
 		// flush the current register set to the current frame
 		FP = i960->r[I960_FP] & ~0x3f;
 		for (i = 0; i < 16; i++) {
-			memory_write_dword_32le(i960->program, FP + (i*4), i960->r[i]);
+			i960->program->write_dword(FP + (i*4), i960->r[i]);
 		}
 	}
 	else	// a cache entry is available, use it
@@ -569,7 +570,7 @@
 	{
 		int i;
 		for(i=0; i<0x10; i++)
-			i960->r[i] = memory_read_dword_32le(i960->program, i960->r[I960_FP]+4*i);
+			i960->r[i] = i960->program->read_dword(i960->r[I960_FP]+4*i);
 
 		if (i960->rcache_pos < 0)
 		{
@@ -595,8 +596,8 @@
 		break;
 
 	case 7:
-		x = memory_read_dword(i960->program, i960->r[I960_FP]-16);
-		y = memory_read_dword(i960->program, i960->r[I960_FP]-12);
+		x = i960->program->read_dword(i960->r[I960_FP]-16);
+		y = i960->program->read_dword(i960->r[I960_FP]-12);
 		do_ret_0(i960);
 		i960->AC = y;
 		// #### test supervisor
@@ -1235,9 +1236,9 @@
 				t2 = get_2_ri(i960, opcode);
 				// interrupt control register
 				if(t1 == 0xff000004)
-					i960->ICR = memory_read_dword_32le(i960->program, t2);
+					i960->ICR = i960->program->read_dword(t2);
 				else
-					memory_write_dword_32le(i960->program, t1,    memory_read_dword_32le(i960->program, t2));
+					i960->program->write_dword(t1,    i960->program->read_dword(t2));
 				i960->AC = (i960->AC & ~7) | 2;
 				break;
 
@@ -1248,10 +1249,10 @@
 				if(t1 == 0xff000010)
 					send_iac(i960, t2);
 				else {
-					memory_write_dword_32le(i960->program, t1,    memory_read_dword_32le(i960->program, t2));
-					memory_write_dword_32le(i960->program, t1+4,  memory_read_dword_32le(i960->program, t2+4));
-					memory_write_dword_32le(i960->program, t1+8,  memory_read_dword_32le(i960->program, t2+8));
-					memory_write_dword_32le(i960->program, t1+12, memory_read_dword_32le(i960->program, t2+12));
+					i960->program->write_dword(t1,    i960->program->read_dword(t2));
+					i960->program->write_dword(t1+4,  i960->program->read_dword(t2+4));
+					i960->program->write_dword(t1+8,  i960->program->read_dword(t2+8));
+					i960->program->write_dword(t1+12, i960->program->read_dword(t2+12));
 				}
 				i960->AC = (i960->AC & ~7) | 2;
 				break;
@@ -1352,7 +1353,7 @@
 
 					for (i = 0; i < 0x10; i++)
 					{
-						memory_write_dword_32le(i960->program, i960->rcache_frame_addr[t1] + (i * sizeof(UINT32)), i960->rcache[t1][i]);
+						i960->program->write_dword(i960->rcache_frame_addr[t1] + (i * sizeof(UINT32)), i960->rcache[t1][i]);
 					}
 				}
 				i960->rcache_pos = 0;
@@ -1792,12 +1793,12 @@
 
 		case 0x80: // ldob
 			i960->icount -= 4;
-			i960->r[(opcode>>19)&0x1f] = memory_read_byte_32le(i960->program, get_ea(i960, opcode));
+			i960->r[(opcode>>19)&0x1f] = i960->program->read_byte(get_ea(i960, opcode));
 			break;
 
 		case 0x82: // stob
 			i960->icount -= 2;
-			memory_write_byte_32le(i960->program, get_ea(i960, opcode), i960->r[(opcode>>19)&0x1f]);
+			i960->program->write_byte(get_ea(i960, opcode), i960->r[(opcode>>19)&0x1f]);
 			break;
 
 		case 0x84: // bx
@@ -1928,12 +1929,12 @@
 
 		case 0xc0: // ldib
 			i960->icount -= 4;
-			i960->r[(opcode>>19)&0x1f] = (INT8)memory_read_byte_32le(i960->program, get_ea(i960, opcode));
+			i960->r[(opcode>>19)&0x1f] = (INT8)i960->program->read_byte(get_ea(i960, opcode));
 			break;
 
 		case 0xc2: // stib
 			i960->icount -= 2;
-			memory_write_byte_32le(i960->program, get_ea(i960, opcode), i960->r[(opcode>>19)&0x1f]);
+			i960->program->write_byte(get_ea(i960, opcode), i960->r[(opcode>>19)&0x1f]);
 			break;
 
 		case 0xc8: // ldis
@@ -1964,7 +1965,7 @@
 
 		i960->bursting = 0;
 
-		opcode = memory_decrypted_read_dword(i960->program, i960->IP);
+		opcode = i960->direct->read_decrypted_dword(i960->IP);
 		i960->IP += 4;
 
 		execute_op(i960, opcode);
@@ -1973,7 +1974,7 @@
 
 static void set_irq_line(i960_state_t *i960, int irqline, int state)
 {
-	int int_tab =  memory_read_dword_32le(i960->program, i960->PRCB+20);	// interrupt table
+	int int_tab =  i960->program->read_dword(i960->PRCB+20);	// interrupt table
 	int cpu_pri = (i960->PC>>16)&0x1f;
 	int vector =0;
 	int priority;
@@ -2022,16 +2023,16 @@
 		else
 		{
 			// store the interrupt in the "pending" table
-			pend = memory_read_dword_32le(i960->program, int_tab);
+			pend = i960->program->read_dword(int_tab);
 			pend |= (1 << priority);
-			memory_write_dword_32le(i960->program, int_tab, pend);
+			i960->program->write_dword(int_tab, pend);
 
 			// now bitfield-ize the vector
 			word = ((vector / 32) * 4) + 4;
 			wordofs = vector % 32;
-			pend = memory_read_dword_32le(i960->program, int_tab + word);
+			pend = i960->program->read_dword(int_tab + word);
 			pend |= (1 << wordofs);
-			memory_write_dword_32le(i960->program, int_tab + word, pend);
+			i960->program->write_dword(int_tab + word, pend);
 		}
 
 		// and ack it to the core now that it's queued
@@ -2068,6 +2069,7 @@
 	i960->irq_cb = irqcallback;
 	i960->device = device;
 	i960->program = device->space(AS_PROGRAM);
+	i960->direct = &i960->program->direct();
 
 	state_save_register_device_item(device, 0, i960->PIP);
 	state_save_register_device_item(device, 0, i960->SAT);
@@ -2085,9 +2087,9 @@
 {
 	i960_state_t *i960 = get_safe_token(device);
 
-	i960->SAT        = memory_read_dword_32le(i960->program, 0);
-	i960->PRCB       = memory_read_dword_32le(i960->program, 4);
-	i960->IP         = memory_read_dword_32le(i960->program, 12);
+	i960->SAT        = i960->program->read_dword(0);
+	i960->PRCB       = i960->program->read_dword(4);
+	i960->IP         = i960->program->read_dword(12);
 	i960->PC         = 0x001f2002;
 	i960->AC         = 0;
 	i960->ICR	    = 0xff000000;
@@ -2097,7 +2099,7 @@
 	memset(i960->r, 0, sizeof(i960->r));
 	memset(i960->rcache, 0, sizeof(i960->rcache));
 
-	i960->r[I960_FP] = memory_read_dword_32le(i960->program, i960->PRCB+24);
+	i960->r[I960_FP] = i960->program->read_dword(i960->PRCB+24);
 	i960->r[I960_SP] = i960->r[I960_FP] + 64;
 	i960->rcache_pos = 0;
 }
diff -Nru src-old/emu/cpu/jaguar/jaguar.c src/emu/cpu/jaguar/jaguar.c
--- src-old/emu/cpu/jaguar/jaguar.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/jaguar/jaguar.c	2010-08-20 04:43:07.000000000 -0700
@@ -64,13 +64,13 @@
 
 #define CONDITION(x)		condition_table[(x) + ((jaguar->FLAGS & 7) << 5)]
 
-#define READBYTE(J,a)		memory_read_byte_32be((J)->program, a)
-#define READWORD(J,a)		memory_read_word_32be((J)->program, a)
-#define READLONG(J,a)		memory_read_dword_32be((J)->program, a)
-
-#define WRITEBYTE(J,a,v)	memory_write_byte_32be((J)->program, a, v)
-#define WRITEWORD(J,a,v)	memory_write_word_32be((J)->program, a, v)
-#define WRITELONG(J,a,v)	memory_write_dword_32be((J)->program, a, v)
+#define READBYTE(J,a)		(J)->program->read_byte(a)
+#define READWORD(J,a)		(J)->program->read_word(a)
+#define READLONG(J,a)		(J)->program->read_dword(a)
+
+#define WRITEBYTE(J,a,v)	(J)->program->write_byte(a, v)
+#define WRITEWORD(J,a,v)	(J)->program->write_word(a, v)
+#define WRITELONG(J,a,v)	(J)->program->write_dword(a, v)
 
 
 
@@ -101,7 +101,8 @@
 	device_irq_callback irq_callback;
 	jaguar_int_func cpu_interrupt;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 };
 
 
@@ -240,7 +241,7 @@
     MEMORY ACCESSORS
 ***************************************************************************/
 
-#define ROPCODE(J,pc)		(memory_decrypted_read_word((J)->program, WORD_XOR_BE((UINT32)(pc))))
+#define ROPCODE(J,pc)		((J)->direct->read_decrypted_word(WORD_XOR_BE((UINT32)(pc))))
 
 
 
@@ -421,6 +422,7 @@
 	jaguar->irq_callback = irqcallback;
 	jaguar->device = device;
 	jaguar->program = device->space(AS_PROGRAM);
+	jaguar->direct = &jaguar->program->direct();
 	if (configdata != NULL)
 		jaguar->cpu_interrupt = configdata->cpu_int_callback;
 
@@ -480,7 +482,7 @@
 	/* if we're halted, we shouldn't be here */
 	if (!(jaguar->ctrl[G_CTRL] & 1))
 	{
-		cpu_set_input_line(device, INPUT_LINE_HALT, ASSERT_LINE);
+		//cpu_set_input_line(device, INPUT_LINE_HALT, ASSERT_LINE);
 		jaguar->icount = 0;
 		return;
 	}
@@ -519,7 +521,7 @@
 	/* if we're halted, we shouldn't be here */
 	if (!(jaguar->ctrl[G_CTRL] & 1))
 	{
-		cpu_set_input_line(device, INPUT_LINE_HALT, ASSERT_LINE);
+		//cpu_set_input_line(device, INPUT_LINE_HALT, ASSERT_LINE);
 		jaguar->icount = 0;
 		return;
 	}
diff -Nru src-old/emu/cpu/konami/konami.c src/emu/cpu/konami/konami.c
--- src-old/emu/cpu/konami/konami.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/konami/konami.c	2010-08-19 09:10:19.000000000 -0700
@@ -62,7 +62,8 @@
 	UINT8	nmi_pending;
 	int		icount;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	konami_set_lines_func setlines_callback;
 };
 
@@ -118,10 +119,10 @@
 #define KONAMI_SYNC		16	/* set when SYNC is waiting for an interrupt */
 #define KONAMI_LDS		32	/* set when LDS occured at least once */
 
-#define RM(cs,Addr)				memory_read_byte_8be((cs)->program, Addr)
-#define WM(cs,Addr,Value)		memory_write_byte_8be((cs)->program, Addr,Value)
-#define ROP(cs,Addr)			memory_decrypted_read_byte((cs)->program, Addr)
-#define ROP_ARG(cs,Addr)		memory_raw_read_byte((cs)->program, Addr)
+#define RM(cs,Addr)				(cs)->program->read_byte(Addr)
+#define WM(cs,Addr,Value)		(cs)->program->write_byte(Addr,Value)
+#define ROP(cs,Addr)			(cs)->direct->read_decrypted_byte(Addr)
+#define ROP_ARG(cs,Addr)		(cs)->direct->read_raw_byte(Addr)
 
 #define SIGNED(a)	(UINT16)(INT16)(INT8)(a)
 
@@ -404,6 +405,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	state_save_register_device_item(device, 0, PC);
 	state_save_register_device_item(device, 0, U);
diff -Nru src-old/emu/cpu/lh5801/5801tbl.c src/emu/cpu/lh5801/5801tbl.c
--- src-old/emu/cpu/lh5801/5801tbl.c	2008-12-10 10:40:54.000000000 -0800
+++ src/emu/cpu/lh5801/5801tbl.c	2010-08-19 09:10:19.000000000 -0700
@@ -24,8 +24,8 @@
 INLINE UINT16 lh5801_readop_word(lh5801_state *cpustate)
 {
 	UINT16 r;
-	r=memory_decrypted_read_byte(cpustate->program,P++)<<8;
-	r|=memory_decrypted_read_byte(cpustate->program,P++);
+	r=cpustate->direct->read_decrypted_byte(P++)<<8;
+	r|=cpustate->direct->read_decrypted_byte(P++);
 	return r;
 }
 
@@ -37,8 +37,8 @@
 
 INLINE void lh5801_add_mem(lh5801_state *cpustate, int addr, UINT8 data)
 {
-	int v=lh5801_add_generic(cpustate,memory_read_byte(cpustate->program,addr),data,0);
-	memory_write_byte(cpustate->program,addr,v);
+	int v=lh5801_add_generic(cpustate,cpustate->program->read_byte(addr),data,0);
+	cpustate->program->write_byte(addr,v);
 }
 
 INLINE void lh5801_adr(lh5801_state *cpustate, PAIR *reg)
@@ -97,10 +97,10 @@
 
 INLINE void lh5801_and_mem(lh5801_state *cpustate, int addr, UINT8 data)
 {
-	data&=memory_read_byte(cpustate->program,addr);
+	data&=cpustate->program->read_byte(addr);
 	cpustate->t&=~Z;
 	if (!data) cpustate->t|=Z;
-	memory_write_byte(cpustate->program,addr,data);
+	cpustate->program->write_byte(addr,data);
 }
 
 INLINE void lh5801_bit(lh5801_state *cpustate, UINT8 a, UINT8 b)
@@ -125,10 +125,10 @@
 
 INLINE void lh5801_ora_mem(lh5801_state *cpustate, int addr, UINT8 data)
 {
-	data|=memory_read_byte(cpustate->program,addr);
+	data|=cpustate->program->read_byte(addr);
 	cpustate->t&=~Z;
 	if (!data) cpustate->t|=Z;
-	memory_write_byte(cpustate->program,addr,data);
+	cpustate->program->write_byte(addr,data);
 }
 
 INLINE void lh5801_lda(lh5801_state *cpustate, UINT8 data)
@@ -141,27 +141,27 @@
 INLINE void lh5801_lde(lh5801_state *cpustate, PAIR *reg)
 {
 	// or z flag depends on reg
-	cpustate->a=memory_read_byte(cpustate->program,reg->w.l--);
+	cpustate->a=cpustate->program->read_byte(reg->w.l--);
 	cpustate->t&=~Z;
 	if (!cpustate->a) cpustate->t|=Z;
 }
 
 INLINE void lh5801_sde(lh5801_state *cpustate, PAIR *reg)
 {
-	memory_write_byte(cpustate->program,reg->w.l--, cpustate->a);
+	cpustate->program->write_byte(reg->w.l--, cpustate->a);
 }
 
 INLINE void lh5801_lin(lh5801_state *cpustate, PAIR *reg)
 {
 	// or z flag depends on reg
-	cpustate->a=memory_read_byte(cpustate->program,reg->w.l++);
+	cpustate->a=cpustate->program->read_byte(reg->w.l++);
 	cpustate->t&=~Z;
 	if (!cpustate->a) cpustate->t|=Z;
 }
 
 INLINE void lh5801_sin(lh5801_state *cpustate, PAIR *reg)
 {
-	memory_write_byte(cpustate->program,reg->w.l++, cpustate->a);
+	cpustate->program->write_byte(reg->w.l++, cpustate->a);
 }
 
 INLINE void lh5801_dec(lh5801_state *cpustate, UINT8 *adr)
@@ -176,40 +176,40 @@
 
 INLINE void lh5801_pop(lh5801_state *cpustate)
 {
-	cpustate->a=memory_read_byte(cpustate->program,++S);
+	cpustate->a=cpustate->program->read_byte(++S);
 	cpustate->t&=~Z;
 	if (!cpustate->a) cpustate->t|=Z;
 }
 
 INLINE void lh5801_pop_word(lh5801_state *cpustate, PAIR *reg)
 {
-	reg->b.h=memory_read_byte(cpustate->program,++S);
-	reg->b.l=memory_read_byte(cpustate->program,++S);
+	reg->b.h=cpustate->program->read_byte(++S);
+	reg->b.l=cpustate->program->read_byte(++S);
 	// z flag?
 }
 
 INLINE void lh5801_rtn(lh5801_state *cpustate)
 {
-	P=memory_read_byte(cpustate->program,++S)<<8;
-	P|=memory_read_byte(cpustate->program,++S);
+	P=cpustate->program->read_byte(++S)<<8;
+	P|=cpustate->program->read_byte(++S);
 }
 
 INLINE void lh5801_rti(lh5801_state *cpustate)
 {
-	P=memory_read_byte(cpustate->program,++S)<<8;
-	P|=memory_read_byte(cpustate->program,++S);
-	cpustate->t=memory_read_byte(cpustate->program,++S);
+	P=cpustate->program->read_byte(++S)<<8;
+	P|=cpustate->program->read_byte(++S);
+	cpustate->t=cpustate->program->read_byte(++S);
 }
 
 INLINE void lh5801_push(lh5801_state *cpustate, UINT8 data)
 {
-	memory_write_byte(cpustate->program,S--, data);
+	cpustate->program->write_byte(S--, data);
 }
 
 INLINE void lh5801_push_word(lh5801_state *cpustate, UINT16 data)
 {
-	memory_write_byte(cpustate->program,S--, data&0xff);
-	memory_write_byte(cpustate->program,S--, data>>8);
+	cpustate->program->write_byte(S--, data&0xff);
+	cpustate->program->write_byte(S--, data>>8);
 }
 
 INLINE void lh5801_jmp(lh5801_state *cpustate, UINT16 adr)
@@ -219,7 +219,7 @@
 
 INLINE void lh5801_branch_plus(lh5801_state *cpustate, int doit)
 {
-	UINT8 t=memory_decrypted_read_byte(cpustate->program,P++);
+	UINT8 t=cpustate->direct->read_decrypted_byte(P++);
 	if (doit) {
 		cpustate->icount-=3;
 		P+=t;
@@ -228,7 +228,7 @@
 
 INLINE void lh5801_branch_minus(lh5801_state *cpustate, int doit)
 {
-	UINT8 t=memory_decrypted_read_byte(cpustate->program,P++);
+	UINT8 t=cpustate->direct->read_decrypted_byte(P++);
 	if (doit) {
 		cpustate->icount-=3;
 		P-=t;
@@ -237,7 +237,7 @@
 
 INLINE void lh5801_lop(lh5801_state *cpustate)
 {
-	UINT8 t=memory_decrypted_read_byte(cpustate->program,P++);
+	UINT8 t=cpustate->direct->read_decrypted_byte(P++);
 	cpustate->icount-=8;
 	if (UL--) {
 		cpustate->icount-=3;
@@ -256,8 +256,8 @@
 {
 	if (doit) {
 		lh5801_push_word(cpustate,P);
-		P=memory_read_byte(cpustate->program,0xff00+nr)<<8;
-		P|=memory_read_byte(cpustate->program,0xff00+nr+1);
+		P=cpustate->program->read_byte(0xff00+nr)<<8;
+		P|=cpustate->program->read_byte(0xff00+nr+1);
 		cpustate->icount-=21-8;
 	}
 	cpustate->t&=~Z; // after the jump!?
@@ -272,18 +272,18 @@
 
 INLINE void lh5801_drl(lh5801_state *cpustate, int adr)
 {
-	UINT16 t=cpustate->a|(memory_read_byte(cpustate->program,adr)<<8);
+	UINT16 t=cpustate->a|(cpustate->program->read_byte(adr)<<8);
 
 	cpustate->a=t>>8;
-	memory_write_byte(cpustate->program,adr,t>>4);
+	cpustate->program->write_byte(adr,t>>4);
 }
 
 INLINE void lh5801_drr(lh5801_state *cpustate, int adr)
 {
-	UINT16 t=memory_read_byte(cpustate->program,adr)|(cpustate->a<<8);
+	UINT16 t=cpustate->program->read_byte(adr)|(cpustate->a<<8);
 
 	cpustate->a=t;
-	memory_write_byte(cpustate->program,adr,t>>4);
+	cpustate->program->write_byte(adr,t>>4);
 }
 
 INLINE void lh5801_rol(lh5801_state *cpustate)
@@ -349,89 +349,89 @@
 	int oper;
 	int adr;
 
-	oper=memory_decrypted_read_byte(cpustate->program,P++);
+	oper=cpustate->direct->read_decrypted_byte(P++);
 	switch (oper) {
-	case 0x01: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
-	case 0x03: lh5801_adc(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
-	case 0x05: lh5801_lda(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=10;break;
-	case 0x07: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
+	case 0x01: lh5801_sbc(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
+	case 0x03: lh5801_adc(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
+	case 0x05: lh5801_lda(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=10;break;
+	case 0x07: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
 	case 0x08: X=X;cpustate->icount-=11;break; //!!!
-	case 0x09: lh5801_and(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
+	case 0x09: lh5801_and(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
 	case 0x0a: lh5801_pop_word(cpustate,&cpustate->x); cpustate->icount-=15;break;
-	case 0x0b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
-	case 0x0c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=17; break;
-	case 0x0d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=11;break;
-	case 0x0e: memory_write_byte(cpustate->program,0x10000|X,cpustate->a); cpustate->icount-=10;break;
-	case 0x0f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,0x10000|X),cpustate->a); cpustate->icount-=11;break;
-	case 0x11: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
-	case 0x13: lh5801_adc(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
-	case 0x15: lh5801_lda(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=10;break;
-	case 0x17: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
+	case 0x0b: lh5801_ora(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
+	case 0x0c: lh5801_dcs(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=17; break;
+	case 0x0d: lh5801_eor(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=11;break;
+	case 0x0e: cpustate->program->write_byte(0x10000|X,cpustate->a); cpustate->icount-=10;break;
+	case 0x0f: lh5801_bit(cpustate,cpustate->program->read_byte(0x10000|X),cpustate->a); cpustate->icount-=11;break;
+	case 0x11: lh5801_sbc(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
+	case 0x13: lh5801_adc(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
+	case 0x15: lh5801_lda(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=10;break;
+	case 0x17: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
 	case 0x18: X=Y;cpustate->icount-=11;break;
-	case 0x19: lh5801_and(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
+	case 0x19: lh5801_and(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
 	case 0x1a: lh5801_pop_word(cpustate,&cpustate->y); cpustate->icount-=15;break;
-	case 0x1b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
-	case 0x1c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=17; break;
-	case 0x1d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=11;break;
-	case 0x1e: memory_write_byte(cpustate->program,0x10000|Y,cpustate->a); cpustate->icount-=10;break;
-	case 0x1f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,0x10000|Y),cpustate->a); cpustate->icount-=11;break;
-	case 0x21: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
-	case 0x23: lh5801_adc(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
-	case 0x25: lh5801_lda(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=10;break;
-	case 0x27: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
+	case 0x1b: lh5801_ora(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
+	case 0x1c: lh5801_dcs(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=17; break;
+	case 0x1d: lh5801_eor(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=11;break;
+	case 0x1e: cpustate->program->write_byte(0x10000|Y,cpustate->a); cpustate->icount-=10;break;
+	case 0x1f: lh5801_bit(cpustate,cpustate->program->read_byte(0x10000|Y),cpustate->a); cpustate->icount-=11;break;
+	case 0x21: lh5801_sbc(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
+	case 0x23: lh5801_adc(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
+	case 0x25: lh5801_lda(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=10;break;
+	case 0x27: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
 	case 0x28: X=U;cpustate->icount-=11;break;
-	case 0x29: lh5801_and(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
+	case 0x29: lh5801_and(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
 	case 0x2a: lh5801_pop_word(cpustate,&cpustate->u); cpustate->icount-=15;break;
-	case 0x2b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
-	case 0x2c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=17; break;
-	case 0x2d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=11;break;
-	case 0x2e: memory_write_byte(cpustate->program,0x10000|U,cpustate->a); cpustate->icount-=10;break;
-	case 0x2f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,0x10000|U),cpustate->a); cpustate->icount-=11;break;
+	case 0x2b: lh5801_ora(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
+	case 0x2c: lh5801_dcs(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=17; break;
+	case 0x2d: lh5801_eor(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=11;break;
+	case 0x2e: cpustate->program->write_byte(0x10000|U,cpustate->a); cpustate->icount-=10;break;
+	case 0x2f: lh5801_bit(cpustate,cpustate->program->read_byte(0x10000|U),cpustate->a); cpustate->icount-=11;break;
 	case 0x40: lh5801_inc(cpustate,&XH);cpustate->icount-=9;break;
 	case 0x42: lh5801_dec(cpustate,&XH);cpustate->icount-=9;break;
 	case 0x48: X=S;cpustate->icount-=11;break;
-	case 0x49: lh5801_and_mem(cpustate,0x10000|X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x49: lh5801_and_mem(cpustate,0x10000|X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x4a: X=X;cpustate->icount-=11;break; //!!!
-	case 0x4b: lh5801_ora_mem(cpustate,0x10000|X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x4b: lh5801_ora_mem(cpustate,0x10000|X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x4c: cpustate->bf=0;/*off !*/ cpustate->icount-=8;break;
-	case 0x4d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,X|0x10000), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=14;break;
+	case 0x4d: lh5801_bit(cpustate,cpustate->program->read_byte(X|0x10000), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=14;break;
 	case 0x4e: S=X;cpustate->icount-=11;break;
-	case 0x4f: lh5801_add_mem(cpustate,0x10000|X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x4f: lh5801_add_mem(cpustate,0x10000|X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x50: lh5801_inc(cpustate,&YH);cpustate->icount-=9;break;
 	case 0x52: lh5801_dec(cpustate,&YH);cpustate->icount-=9;break;
 	case 0x58: X=P;cpustate->icount-=11;break;
-	case 0x59: lh5801_and_mem(cpustate,0x10000|Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x59: lh5801_and_mem(cpustate,0x10000|Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x5a: Y=X;cpustate->icount-=11;break;
-	case 0x5b: lh5801_ora_mem(cpustate,0x10000|Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
-	case 0x5d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,Y|0x10000), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=14;break;
+	case 0x5b: lh5801_ora_mem(cpustate,0x10000|Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
+	case 0x5d: lh5801_bit(cpustate,cpustate->program->read_byte(Y|0x10000), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=14;break;
 	case 0x5e: lh5801_jmp(cpustate,X);cpustate->icount-=11;break; // P=X
-	case 0x5f: lh5801_add_mem(cpustate,0x10000|Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x5f: lh5801_add_mem(cpustate,0x10000|Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x60: lh5801_inc(cpustate,&UH);cpustate->icount-=9;break;
 	case 0x62: lh5801_dec(cpustate,&UH);cpustate->icount-=9;break;
-	case 0x69: lh5801_and_mem(cpustate,0x10000|U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x69: lh5801_and_mem(cpustate,0x10000|U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x6a: U=X;cpustate->icount-=11;break;
-	case 0x6b: lh5801_ora_mem(cpustate,0x10000|U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
-	case 0x6d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,X|0x10000), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=14;break;
-	case 0x6f: lh5801_add_mem(cpustate,0x10000|U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=17;break;
+	case 0x6b: lh5801_ora_mem(cpustate,0x10000|U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
+	case 0x6d: lh5801_bit(cpustate,cpustate->program->read_byte(X|0x10000), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=14;break;
+	case 0x6f: lh5801_add_mem(cpustate,0x10000|U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=17;break;
 	case 0x81: cpustate->t|=IE; /*sie !*/cpustate->icount-=8;break;
 	case 0x88: lh5801_push_word(cpustate,X); cpustate->icount-=14;break;
 	case 0x8a: lh5801_pop(cpustate); cpustate->icount-=12; break;
-	case 0x8c: lh5801_dca(cpustate,memory_read_byte(cpustate->program,0x10000|X)); cpustate->icount-=19; break;
+	case 0x8c: lh5801_dca(cpustate,cpustate->program->read_byte(0x10000|X)); cpustate->icount-=19; break;
 	case 0x8e: /*cdv clears internal devider*/cpustate->icount-=8;break;
 	case 0x98: lh5801_push_word(cpustate,Y); cpustate->icount-=14;break;
-	case 0x9c: lh5801_dca(cpustate,memory_read_byte(cpustate->program,0x10000|Y)); cpustate->icount-=19; break;
-	case 0xa1: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
-	case 0xa3: lh5801_adc(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
-	case 0xa5: lh5801_lda(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=16;break;
-	case 0xa7: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0x9c: lh5801_dca(cpustate,cpustate->program->read_byte(0x10000|Y)); cpustate->icount-=19; break;
+	case 0xa1: lh5801_sbc(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0xa3: lh5801_adc(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0xa5: lh5801_lda(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=16;break;
+	case 0xa7: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
 	case 0xa8: lh5801_push_word(cpustate,U); cpustate->icount-=14;break;
-	case 0xa9: lh5801_and(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0xa9: lh5801_and(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
 	case 0xaa: lh5801_lda(cpustate,cpustate->t); cpustate->icount-=9;break;
-	case 0xab: lh5801_ora(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
-	case 0xac: lh5801_dca(cpustate,memory_read_byte(cpustate->program,0x10000|U)); cpustate->icount-=19; break;
-	case 0xad: lh5801_eor(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
-	case 0xae: memory_write_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate),cpustate->a); cpustate->icount-=16;break;
-	case 0xaf: lh5801_bit(cpustate,memory_read_byte(cpustate->program,0x10000|lh5801_readop_word(cpustate)),cpustate->a); cpustate->icount-=17;break;
+	case 0xab: lh5801_ora(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0xac: lh5801_dca(cpustate,cpustate->program->read_byte(0x10000|U)); cpustate->icount-=19; break;
+	case 0xad: lh5801_eor(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate))); cpustate->icount-=17;break;
+	case 0xae: cpustate->program->write_byte(0x10000|lh5801_readop_word(cpustate),cpustate->a); cpustate->icount-=16;break;
+	case 0xaf: lh5801_bit(cpustate,cpustate->program->read_byte(0x10000|lh5801_readop_word(cpustate)),cpustate->a); cpustate->icount-=17;break;
 	case 0xb1: /*hlt*/cpustate->icount-=8;break;
 	case 0xba: lh5801_ita(cpustate);cpustate->icount-=9;break;
 	case 0xbe: cpustate->t&=~IE; /*rie !*/cpustate->icount-=8;break;
@@ -448,19 +448,19 @@
 	case 0xea: lh5801_adr(cpustate,&cpustate->u);cpustate->icount-=11;break;
 	case 0xe9:
 		adr=lh5801_readop_word(cpustate)|0x10000;
-		lh5801_and_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=23;
+		lh5801_and_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=23;
 		break;
 	case 0xeb:
 		adr=lh5801_readop_word(cpustate)|0x10000;
-		lh5801_ora_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=23;
+		lh5801_ora_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=23;
 		break;
 	case 0xec: cpustate->t=cpustate->a; cpustate->icount-=9;break;
 	case 0xed:
-		adr=lh5801_readop_word(cpustate)|0x10000;lh5801_bit(cpustate,memory_read_byte(cpustate->program,adr), memory_decrypted_read_byte(cpustate->program,P++));
+		adr=lh5801_readop_word(cpustate)|0x10000;lh5801_bit(cpustate,cpustate->program->read_byte(adr), cpustate->direct->read_decrypted_byte(P++));
 		cpustate->icount-=20;break;
 	case 0xef:
 		adr=lh5801_readop_word(cpustate)|0x10000;
-		lh5801_add_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=23;
+		lh5801_add_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=23;
 		break;
 
 	default:
@@ -473,56 +473,56 @@
 	int oper;
 	int adr;
 
-	oper=memory_decrypted_read_byte(cpustate->program,P++);
+	oper=cpustate->direct->read_decrypted_byte(P++);
 	switch (oper) {
 	case 0x00: lh5801_sbc(cpustate,XL); cpustate->icount-=6;break;
-	case 0x01: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
+	case 0x01: lh5801_sbc(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=7;break;
 	case 0x02: lh5801_adc(cpustate,XL); cpustate->icount-=6;break;
-	case 0x03: lh5801_adc(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
+	case 0x03: lh5801_adc(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=7;break;
 	case 0x04: lh5801_lda(cpustate,XL); cpustate->icount-=5;break;
-	case 0x05: lh5801_lda(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=6;break;
+	case 0x05: lh5801_lda(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=6;break;
 	case 0x06: lh5801_cpa(cpustate,cpustate->a, XL); cpustate->icount-=6;break;
-	case 0x07: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
+	case 0x07: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(X)); cpustate->icount-=7;break;
 	case 0x08: XH=cpustate->a; cpustate->icount-=5; break;
-	case 0x09: lh5801_and(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
+	case 0x09: lh5801_and(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=7;break;
 	case 0x0a: XL=cpustate->a; cpustate->icount-=5; break;
-	case 0x0b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
-	case 0x0c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=13; break;
-	case 0x0d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=7;break;
-	case 0x0e: memory_write_byte(cpustate->program,X,cpustate->a); cpustate->icount-=6;break;
-	case 0x0f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,X),cpustate->a); cpustate->icount-=7;break;
+	case 0x0b: lh5801_ora(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=7;break;
+	case 0x0c: lh5801_dcs(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=13; break;
+	case 0x0d: lh5801_eor(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=7;break;
+	case 0x0e: cpustate->program->write_byte(X,cpustate->a); cpustate->icount-=6;break;
+	case 0x0f: lh5801_bit(cpustate,cpustate->program->read_byte(X),cpustate->a); cpustate->icount-=7;break;
 	case 0x10: lh5801_sbc(cpustate,YL); cpustate->icount-=6;break;
-	case 0x11: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
+	case 0x11: lh5801_sbc(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
 	case 0x12: lh5801_adc(cpustate,YL); cpustate->icount-=6;break;
-	case 0x13: lh5801_adc(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
+	case 0x13: lh5801_adc(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
 	case 0x14: lh5801_lda(cpustate,YL); cpustate->icount-=5;break;
-	case 0x15: lh5801_lda(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=6;break;
+	case 0x15: lh5801_lda(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=6;break;
 	case 0x16: lh5801_cpa(cpustate,cpustate->a, YL); cpustate->icount-=6;break;
-	case 0x17: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
+	case 0x17: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
 	case 0x18: YH=cpustate->a; cpustate->icount-=5; break;
-	case 0x19: lh5801_and(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
+	case 0x19: lh5801_and(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
 	case 0x1a: YL=cpustate->a; cpustate->icount-=5; break;
-	case 0x1b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
-	case 0x1c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=13; break;
-	case 0x1d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=7;break;
-	case 0x1e: memory_write_byte(cpustate->program,Y,cpustate->a); cpustate->icount-=6;break;
-	case 0x1f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,Y),cpustate->a); cpustate->icount-=7;break;
+	case 0x1b: lh5801_ora(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
+	case 0x1c: lh5801_dcs(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=13; break;
+	case 0x1d: lh5801_eor(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=7;break;
+	case 0x1e: cpustate->program->write_byte(Y,cpustate->a); cpustate->icount-=6;break;
+	case 0x1f: lh5801_bit(cpustate,cpustate->program->read_byte(Y),cpustate->a); cpustate->icount-=7;break;
 	case 0x20: lh5801_sbc(cpustate,UL); cpustate->icount-=6;break;
-	case 0x21: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
+	case 0x21: lh5801_sbc(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=7;break;
 	case 0x22: lh5801_adc(cpustate,UL); cpustate->icount-=6;break;
-	case 0x23: lh5801_adc(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
+	case 0x23: lh5801_adc(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=7;break;
 	case 0x24: lh5801_lda(cpustate,UL); cpustate->icount-=5;break;
-	case 0x25: lh5801_lda(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=6;break;
+	case 0x25: lh5801_lda(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=6;break;
 	case 0x26: lh5801_cpa(cpustate,cpustate->a, UL); cpustate->icount-=6;break;
-	case 0x27: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
+	case 0x27: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(U)); cpustate->icount-=7;break;
 	case 0x28: UH=cpustate->a; cpustate->icount-=5; break;
-	case 0x29: lh5801_and(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
+	case 0x29: lh5801_and(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=7;break;
 	case 0x2a: UL=cpustate->a; cpustate->icount-=5; break;
-	case 0x2b: lh5801_ora(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
-	case 0x2c: lh5801_dcs(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=13; break;
-	case 0x2d: lh5801_eor(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=7;break;
-	case 0x2e: memory_write_byte(cpustate->program,U,cpustate->a); cpustate->icount-=6;break;
-	case 0x2f: lh5801_bit(cpustate,memory_read_byte(cpustate->program,U),cpustate->a); cpustate->icount-=7;break;
+	case 0x2b: lh5801_ora(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=7;break;
+	case 0x2c: lh5801_dcs(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=13; break;
+	case 0x2d: lh5801_eor(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=7;break;
+	case 0x2e: cpustate->program->write_byte(U,cpustate->a); cpustate->icount-=6;break;
+	case 0x2f: lh5801_bit(cpustate,cpustate->program->read_byte(U),cpustate->a); cpustate->icount-=7;break;
 	case 0x38: /*nop*/cpustate->icount-=5;break;
 	case 0x40: lh5801_inc(cpustate,&XL);cpustate->icount-=5;break;
 	case 0x41: lh5801_sin(cpustate,&cpustate->x); cpustate->icount-=6;break;
@@ -532,14 +532,14 @@
 	case 0x45: lh5801_lin(cpustate,&cpustate->x);cpustate->icount-=6;break;
 	case 0x46: X--;cpustate->icount-=5;break;
 	case 0x47: lh5801_lde(cpustate,&cpustate->x);cpustate->icount-=6;break;
-	case 0x48: XH=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x49: lh5801_and_mem(cpustate,X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x4a: XL=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x4b: lh5801_ora_mem(cpustate,X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x4c: lh5801_cpa(cpustate,XH, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x4d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,X), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=10;break;
-	case 0x4e: lh5801_cpa(cpustate,XL, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x4f: lh5801_add_mem(cpustate,X, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
+	case 0x48: XH=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x49: lh5801_and_mem(cpustate,X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x4a: XL=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x4b: lh5801_ora_mem(cpustate,X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x4c: lh5801_cpa(cpustate,XH, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x4d: lh5801_bit(cpustate,cpustate->program->read_byte(X), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=10;break;
+	case 0x4e: lh5801_cpa(cpustate,XL, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x4f: lh5801_add_mem(cpustate,X, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
 	case 0x50: lh5801_inc(cpustate,&YL);cpustate->icount-=5;break;
 	case 0x51: lh5801_sin(cpustate,&cpustate->y); cpustate->icount-=6;break;
 	case 0x52: lh5801_dec(cpustate,&YL);cpustate->icount-=5;break;
@@ -548,14 +548,14 @@
 	case 0x55: lh5801_lin(cpustate,&cpustate->y);cpustate->icount-=6;break;
 	case 0x56: Y--;cpustate->icount-=5;break;
 	case 0x57: lh5801_lde(cpustate,&cpustate->y);cpustate->icount-=6;break;
-	case 0x58: YH=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x59: lh5801_and_mem(cpustate,Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x5a: YL=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x5b: lh5801_ora_mem(cpustate,Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x5c: lh5801_cpa(cpustate,YH, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x5d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,Y), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=10;break;
-	case 0x5e: lh5801_cpa(cpustate,YL, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x5f: lh5801_add_mem(cpustate,Y, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
+	case 0x58: YH=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x59: lh5801_and_mem(cpustate,Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x5a: YL=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x5b: lh5801_ora_mem(cpustate,Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x5c: lh5801_cpa(cpustate,YH, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x5d: lh5801_bit(cpustate,cpustate->program->read_byte(Y), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=10;break;
+	case 0x5e: lh5801_cpa(cpustate,YL, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x5f: lh5801_add_mem(cpustate,Y, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
 	case 0x60: lh5801_inc(cpustate,&UL);cpustate->icount-=5;break;
 	case 0x61: lh5801_sin(cpustate,&cpustate->u); cpustate->icount-=6;break;
 	case 0x62: lh5801_dec(cpustate,&UL);cpustate->icount-=5;break;
@@ -564,14 +564,14 @@
 	case 0x65: lh5801_lin(cpustate,&cpustate->u);cpustate->icount-=6;break;
 	case 0x66: U--;cpustate->icount-=5;break;
 	case 0x67: lh5801_lde(cpustate,&cpustate->u);cpustate->icount-=6;break;
-	case 0x68: UH=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x69: lh5801_and_mem(cpustate,U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x6a: UL=memory_decrypted_read_byte(cpustate->program,P++);cpustate->icount-=6;break;
-	case 0x6b: lh5801_ora_mem(cpustate,U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
-	case 0x6c: lh5801_cpa(cpustate,UH, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x6d: lh5801_bit(cpustate,memory_read_byte(cpustate->program,U), memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=10;break;
-	case 0x6e: lh5801_cpa(cpustate,UL, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0x6f: lh5801_add_mem(cpustate,U, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=13;break;
+	case 0x68: UH=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x69: lh5801_and_mem(cpustate,U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x6a: UL=cpustate->direct->read_decrypted_byte(P++);cpustate->icount-=6;break;
+	case 0x6b: lh5801_ora_mem(cpustate,U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
+	case 0x6c: lh5801_cpa(cpustate,UH, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x6d: lh5801_bit(cpustate,cpustate->program->read_byte(U), cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=10;break;
+	case 0x6e: lh5801_cpa(cpustate,UL, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0x6f: lh5801_add_mem(cpustate,U, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=13;break;
 	case 0x80: lh5801_sbc(cpustate,XH); cpustate->icount-=6;break;
 	case 0x81: lh5801_branch_plus(cpustate,!(cpustate->t&C)); cpustate->icount-=8; break;
 	case 0x82: lh5801_adc(cpustate,XH); cpustate->icount-=6;break;
@@ -584,7 +584,7 @@
 	case 0x89: lh5801_branch_plus(cpustate,!(cpustate->t&Z)); cpustate->icount-=8; break;
 	case 0x8a: lh5801_rti(cpustate); cpustate->icount-=14; break;
 	case 0x8b: lh5801_branch_plus(cpustate,cpustate->t&Z); cpustate->icount-=8; break;
-	case 0x8c: lh5801_dca(cpustate,memory_read_byte(cpustate->program,X)); cpustate->icount-=15; break;
+	case 0x8c: lh5801_dca(cpustate,cpustate->program->read_byte(X)); cpustate->icount-=15; break;
 	case 0x8d: lh5801_branch_plus(cpustate,!(cpustate->t&V)); cpustate->icount-=8; break;
 	case 0x8e: lh5801_branch_plus(cpustate,1); cpustate->icount-=5; break;
 	case 0x8f: lh5801_branch_plus(cpustate,cpustate->t&V); cpustate->icount-=8; break;
@@ -599,45 +599,45 @@
 	case 0x99: lh5801_branch_minus(cpustate,!(cpustate->t&Z)); cpustate->icount-=8; break;
 	case 0x9a: lh5801_rtn(cpustate); cpustate->icount-=11; break;
 	case 0x9b: lh5801_branch_minus(cpustate,cpustate->t&Z); cpustate->icount-=8; break;
-	case 0x9c: lh5801_dca(cpustate,memory_read_byte(cpustate->program,Y)); cpustate->icount-=15; break;
+	case 0x9c: lh5801_dca(cpustate,cpustate->program->read_byte(Y)); cpustate->icount-=15; break;
 	case 0x9d: lh5801_branch_minus(cpustate,!(cpustate->t&V)); cpustate->icount-=8; break;
 	case 0x9e: lh5801_branch_minus(cpustate,1); cpustate->icount-=6; break;
 	case 0x9f: lh5801_branch_minus(cpustate,cpustate->t&V); cpustate->icount-=8; break;
 	case 0xa0: lh5801_sbc(cpustate,UH); cpustate->icount-=6;break;
 	case 0xa2: lh5801_adc(cpustate,UH); cpustate->icount-=6;break;
-	case 0xa1: lh5801_sbc(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
-	case 0xa3: lh5801_adc(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xa1: lh5801_sbc(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xa3: lh5801_adc(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
 	case 0xa4: lh5801_lda(cpustate,UH); cpustate->icount-=5;break;
-	case 0xa5: lh5801_lda(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=12;break;
+	case 0xa5: lh5801_lda(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=12;break;
 	case 0xa6: lh5801_cpa(cpustate,cpustate->a, UH); cpustate->icount-=6;break;
-	case 0xa7: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xa7: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
 	case 0xa8: cpustate->pv=1;/*spv!*/ cpustate->icount-=4; break;
-	case 0xa9: lh5801_and(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xa9: lh5801_and(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
 	case 0xaa: S=lh5801_readop_word(cpustate);cpustate->icount-=6;break;
-	case 0xab: lh5801_ora(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
-	case 0xac: lh5801_dca(cpustate,memory_read_byte(cpustate->program,U)); cpustate->icount-=15; break;
-	case 0xad: lh5801_eor(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
-	case 0xae: memory_write_byte(cpustate->program,lh5801_readop_word(cpustate),cpustate->a); cpustate->icount-=12;break;
-	case 0xaf: lh5801_bit(cpustate,memory_read_byte(cpustate->program,lh5801_readop_word(cpustate)),cpustate->a); cpustate->icount-=13;break;
-	case 0xb1: lh5801_sbc(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0xb3: lh5801_adc(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0xb5: lh5801_lda(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=6;break;
-	case 0xb7: lh5801_cpa(cpustate,cpustate->a, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
+	case 0xab: lh5801_ora(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xac: lh5801_dca(cpustate,cpustate->program->read_byte(U)); cpustate->icount-=15; break;
+	case 0xad: lh5801_eor(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate))); cpustate->icount-=13;break;
+	case 0xae: cpustate->program->write_byte(lh5801_readop_word(cpustate),cpustate->a); cpustate->icount-=12;break;
+	case 0xaf: lh5801_bit(cpustate,cpustate->program->read_byte(lh5801_readop_word(cpustate)),cpustate->a); cpustate->icount-=13;break;
+	case 0xb1: lh5801_sbc(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0xb3: lh5801_adc(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0xb5: lh5801_lda(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=6;break;
+	case 0xb7: lh5801_cpa(cpustate,cpustate->a, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
 	case 0xb8: cpustate->pv=0;/*rpv!*/ cpustate->icount-=4; break;
-	case 0xb9: lh5801_and(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
+	case 0xb9: lh5801_and(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
 	case 0xba: lh5801_jmp(cpustate,lh5801_readop_word(cpustate)); cpustate->icount-=12;break;
-	case 0xbb: lh5801_ora(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0xbd: lh5801_eor(cpustate,memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
+	case 0xbb: lh5801_ora(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0xbd: lh5801_eor(cpustate,cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
 	case 0xbe: lh5801_sjp(cpustate); cpustate->icount-=19; break;
-	case 0xbf: lh5801_bit(cpustate,cpustate->a, memory_decrypted_read_byte(cpustate->program,P++));cpustate->icount-=7;break;
-	case 0xc1: lh5801_vector(cpustate,!(cpustate->t&C), memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xc3: lh5801_vector(cpustate,cpustate->t&C, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xc5: lh5801_vector(cpustate,!(cpustate->t&H), memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xc7: lh5801_vector(cpustate,cpustate->t&H, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xc9: lh5801_vector(cpustate,!(cpustate->t&Z), memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xcb: lh5801_vector(cpustate,cpustate->t&Z, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
-	case 0xcd: lh5801_vector(cpustate,1, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=7;break;
-	case 0xcf: lh5801_vector(cpustate,cpustate->t&V, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=8;break;
+	case 0xbf: lh5801_bit(cpustate,cpustate->a, cpustate->direct->read_decrypted_byte(P++));cpustate->icount-=7;break;
+	case 0xc1: lh5801_vector(cpustate,!(cpustate->t&C), cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xc3: lh5801_vector(cpustate,cpustate->t&C, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xc5: lh5801_vector(cpustate,!(cpustate->t&H), cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xc7: lh5801_vector(cpustate,cpustate->t&H, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xc9: lh5801_vector(cpustate,!(cpustate->t&Z), cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xcb: lh5801_vector(cpustate,cpustate->t&Z, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
+	case 0xcd: lh5801_vector(cpustate,1, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=7;break;
+	case 0xcf: lh5801_vector(cpustate,cpustate->t&V, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=8;break;
 	case 0xd1: lh5801_ror(cpustate); cpustate->icount-=6; break;
 	case 0xd3: lh5801_drr(cpustate,X); cpustate->icount-=12; break;
 	case 0xd5: lh5801_shr(cpustate); cpustate->icount-=6; break;
@@ -649,21 +649,21 @@
 	case 0xe1: cpustate->pu=1;/*spu!*/ cpustate->icount-=4; break;
 	case 0xe3: cpustate->pu=0;/*rpu!*/ cpustate->icount-=4; break;
 	case 0xe9:
-		adr=lh5801_readop_word(cpustate);lh5801_and_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++));
+		adr=lh5801_readop_word(cpustate);lh5801_and_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++));
 		cpustate->icount-=19;break;
 	case 0xeb:
-		adr=lh5801_readop_word(cpustate);lh5801_ora_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++));
+		adr=lh5801_readop_word(cpustate);lh5801_ora_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++));
 		cpustate->icount-=19;break;
 	case 0xed:
-		adr=lh5801_readop_word(cpustate);lh5801_bit(cpustate,memory_read_byte(cpustate->program,adr), memory_decrypted_read_byte(cpustate->program,P++));
+		adr=lh5801_readop_word(cpustate);lh5801_bit(cpustate,cpustate->program->read_byte(adr), cpustate->direct->read_decrypted_byte(P++));
 		cpustate->icount-=16;break;
 	case 0xef:
 		adr=lh5801_readop_word(cpustate);
-		lh5801_add_mem(cpustate,adr, memory_decrypted_read_byte(cpustate->program,P++)); cpustate->icount-=19;
+		lh5801_add_mem(cpustate,adr, cpustate->direct->read_decrypted_byte(P++)); cpustate->icount-=19;
 		break;
 	case 0xf1: lh5801_aex(cpustate); cpustate->icount-=6; break;
-	case 0xf5: memory_write_byte(cpustate->program,Y++, memory_read_byte(cpustate->program,X++)); cpustate->icount-=7; break; //tin
-	case 0xf7: lh5801_cpa(cpustate,cpustate->a, memory_read_byte(cpustate->program,X++));cpustate->icount-=7; break; //cin
+	case 0xf5: cpustate->program->write_byte(Y++, cpustate->program->read_byte(X++)); cpustate->icount-=7; break; //tin
+	case 0xf7: lh5801_cpa(cpustate,cpustate->a, cpustate->program->read_byte(X++));cpustate->icount-=7; break; //cin
 	case 0xf9: cpustate->t&=~C;cpustate->icount-=4;break;
 	case 0xfb: cpustate->t|=C;cpustate->icount-=4;break;
 	case 0xfd: lh5801_instruction_fd(cpustate);break;
diff -Nru src-old/emu/cpu/lh5801/lh5801.c src/emu/cpu/lh5801/lh5801.c
--- src-old/emu/cpu/lh5801/lh5801.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/lh5801/lh5801.c	2010-08-19 09:10:19.000000000 -0700
@@ -51,7 +51,8 @@
 {
 	const lh5801_cpu_core *config;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 
 	PAIR s, p, u, x, y;
 	int tm; //9 bit
@@ -106,13 +107,14 @@
 	cpustate->config = (const lh5801_cpu_core *) device->baseconfig().static_config();
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 }
 
 static CPU_RESET( lh5801 )
 {
 	lh5801_state *cpustate = get_safe_token(device);
 
-	P = (memory_read_byte(cpustate->program, 0xfffe)<<8) | memory_read_byte(cpustate->program, 0xffff);
+	P = (cpustate->program->read_byte(0xfffe)<<8) | cpustate->program->read_byte(0xffff);
 
 	cpustate->idle=0;
 }
diff -Nru src-old/emu/cpu/lr35902/lr35902.c src/emu/cpu/lr35902/lr35902.c
--- src-old/emu/cpu/lr35902/lr35902.c	2010-07-17 06:04:04.000000000 -0700
+++ src/emu/cpu/lr35902/lr35902.c	2010-08-19 01:27:05.000000000 -0700
@@ -66,7 +66,7 @@
 	int	ei_delay;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 	/* Timer stuff */
 	lr35902_timer_fired_func timer_fired_func;
@@ -129,8 +129,8 @@
 /* Memory functions                                                         */
 /****************************************************************************/
 
-#define mem_ReadByte(cs,A)		((UINT8)memory_read_byte_8le((cs)->w.program,A))
-#define mem_WriteByte(cs,A,V)	(memory_write_byte_8le((cs)->w.program,A,V))
+#define mem_ReadByte(cs,A)		((UINT8)(cs)->w.program->read_byte(A))
+#define mem_WriteByte(cs,A,V)	((cs)->w.program->write_byte(A,V))
 
 INLINE UINT16 mem_ReadWord (lr35902_state *cpustate, UINT32 address)
 {
diff -Nru src-old/emu/cpu/m37710/m37710.c src/emu/cpu/m37710/m37710.c
--- src-old/emu/cpu/m37710/m37710.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/cpu/m37710/m37710.c	2010-08-19 01:27:05.000000000 -0700
@@ -405,56 +405,56 @@
 	switch (offset)
 	{
 		case 2: // p0
-			return memory_read_byte_8le(cpustate->io, M37710_PORT0);
+			return cpustate->io->read_byte(M37710_PORT0);
 		case 3: // p1
-			return memory_read_byte_8le(cpustate->io, M37710_PORT1);
+			return cpustate->io->read_byte(M37710_PORT1);
 		case 6: // p2
-			return memory_read_byte_8le(cpustate->io, M37710_PORT2);
+			return cpustate->io->read_byte(M37710_PORT2);
 		case 7: // p3
-			return memory_read_byte_8le(cpustate->io, M37710_PORT3);
+			return cpustate->io->read_byte(M37710_PORT3);
 		case 0xa: // p4
-			return memory_read_byte_8le(cpustate->io, M37710_PORT4);
+			return cpustate->io->read_byte(M37710_PORT4);
 		case 0xb: // p5
-			return memory_read_byte_8le(cpustate->io, M37710_PORT5);
+			return cpustate->io->read_byte(M37710_PORT5);
 		case 0xe: // p6
-			return memory_read_byte_8le(cpustate->io, M37710_PORT6);
+			return cpustate->io->read_byte(M37710_PORT6);
 		case 0xf: // p7
-			return memory_read_byte_8le(cpustate->io, M37710_PORT7);
+			return cpustate->io->read_byte(M37710_PORT7);
 		case 0x12: // p8
-			return memory_read_byte_8le(cpustate->io, M37710_PORT8);
+			return cpustate->io->read_byte(M37710_PORT8);
 
 		case 0x20:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC0_L);
+			return cpustate->io->read_byte(M37710_ADC0_L);
 		case 0x21:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC0_H);
+			return cpustate->io->read_byte(M37710_ADC0_H);
 		case 0x22:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC1_L);
+			return cpustate->io->read_byte(M37710_ADC1_L);
 		case 0x23:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC1_H);
+			return cpustate->io->read_byte(M37710_ADC1_H);
 		case 0x24:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC2_L);
+			return cpustate->io->read_byte(M37710_ADC2_L);
 		case 0x25:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC2_H);
+			return cpustate->io->read_byte(M37710_ADC2_H);
 		case 0x26:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC3_L);
+			return cpustate->io->read_byte(M37710_ADC3_L);
 		case 0x27:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC3_H);
+			return cpustate->io->read_byte(M37710_ADC3_H);
 		case 0x28:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC4_L);
+			return cpustate->io->read_byte(M37710_ADC4_L);
 		case 0x29:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC4_H);
+			return cpustate->io->read_byte(M37710_ADC4_H);
 		case 0x2a:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC5_L);
+			return cpustate->io->read_byte(M37710_ADC5_L);
 		case 0x2b:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC5_H);
+			return cpustate->io->read_byte(M37710_ADC5_H);
 		case 0x2c:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC6_L);
+			return cpustate->io->read_byte(M37710_ADC6_L);
 		case 0x2d:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC6_H);
+			return cpustate->io->read_byte(M37710_ADC6_H);
 		case 0x2e:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC7_L);
+			return cpustate->io->read_byte(M37710_ADC7_L);
 		case 0x2f:
-			return memory_read_byte_8le(cpustate->io, M37710_ADC7_H);
+			return cpustate->io->read_byte(M37710_ADC7_H);
 		case 0x35:
 			return 0xff;	// UART control
 
@@ -472,31 +472,31 @@
 	switch(offset)
 	{
 		case 2: // p0
-			memory_write_byte_8le(cpustate->io, M37710_PORT0, data);
+			cpustate->io->write_byte(M37710_PORT0, data);
 			return;
 		case 3: // p1
-			memory_write_byte_8le(cpustate->io, M37710_PORT1, data);
+			cpustate->io->write_byte(M37710_PORT1, data);
 			return;
 		case 6: // p2
-			memory_write_byte_8le(cpustate->io, M37710_PORT2, data);
+			cpustate->io->write_byte(M37710_PORT2, data);
 			return;
 		case 7: // p3
-			memory_write_byte_8le(cpustate->io, M37710_PORT3, data);
+			cpustate->io->write_byte(M37710_PORT3, data);
 			return;
 		case 0xa: // p4
-			memory_write_byte_8le(cpustate->io, M37710_PORT4, data);
+			cpustate->io->write_byte(M37710_PORT4, data);
 			return;
 		case 0xb: // p5
-			memory_write_byte_8le(cpustate->io, M37710_PORT5, data);
+			cpustate->io->write_byte(M37710_PORT5, data);
 			return;
 		case 0xe: // p6
-			memory_write_byte_8le(cpustate->io, M37710_PORT6, data);
+			cpustate->io->write_byte(M37710_PORT6, data);
 			return;
 		case 0xf: // p7
-			memory_write_byte_8le(cpustate->io, M37710_PORT7, data);
+			cpustate->io->write_byte(M37710_PORT7, data);
 			return;
 		case 0x12: // p8
-			memory_write_byte_8le(cpustate->io, M37710_PORT8, data);
+			cpustate->io->write_byte(M37710_PORT8, data);
 			return;
 
 		case 0x40:	// count start
diff -Nru src-old/emu/cpu/m37710/m37710cm.h src/emu/cpu/m37710/m37710cm.h
--- src-old/emu/cpu/m37710/m37710cm.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m37710/m37710cm.h	2010-08-19 01:27:05.000000000 -0700
@@ -22,11 +22,11 @@
 #undef M37710_CALL_DEBUGGER
 
 #define M37710_CALL_DEBUGGER(x) 		debugger_instruction_hook(cpustate->device, x)
-#define m37710_read_8(addr) 			memory_read_byte_16le(cpustate->program, addr)
-#define m37710_write_8(addr,data)		memory_write_byte_16le(cpustate->program, addr,data)
-#define m37710_read_8_immediate(A)		memory_read_byte_16le(cpustate->program, A)
-#define m37710_read_16(addr)			memory_read_word_16le(cpustate->program, addr)
-#define m37710_write_16(addr,data)		memory_write_word_16le(cpustate->program, addr,data)
+#define m37710_read_8(addr) 			cpustate->program->read_byte(addr)
+#define m37710_write_8(addr,data)		cpustate->program->write_byte(addr,data)
+#define m37710_read_8_immediate(A)		cpustate->program->read_byte(A)
+#define m37710_read_16(addr)			cpustate->program->read_word(addr)
+#define m37710_write_16(addr,data)		cpustate->program->write_word(addr,data)
 #define m37710_jumping(A)
 #define m37710_branching(A)
 
@@ -110,8 +110,8 @@
 	uint destination;	/* temp register */
 	device_irq_callback int_ack;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	address_space *io;
 	uint stopped;		/* Sets how the CPU is stopped */
 	void (*const *opcodes)(m37710i_cpu_struct *cpustate);		/* opcodes with no prefix */
 	void (*const *opcodes42)(m37710i_cpu_struct *cpustate);	/* opcodes with 0x42 prefix */
diff -Nru src-old/emu/cpu/m6502/ill02.h src/emu/cpu/m6502/ill02.h
--- src-old/emu/cpu/m6502/ill02.h	2009-12-28 02:09:20.000000000 -0800
+++ src/emu/cpu/m6502/ill02.h	2010-08-19 09:10:19.000000000 -0700
@@ -235,7 +235,7 @@
 #if 0
 #define SSH 													\
 	tmp = S = A & X;											\
-	tmp &= (UINT8)(memory_raw_read_byte(cpustate->space, (PCW + 1) & 0xffff) + 1)
+	tmp &= (UINT8)(cpustate->direct->read_raw_byte((PCW + 1) & 0xffff) + 1)
 #endif
 
 /* 6510 ********************************************************
@@ -264,7 +264,7 @@
 #define KIL 													\
 	PCW--;														\
 	logerror("M6510 KILL opcode %04x: %02x\n",                  \
-				PCW, memory_decrypted_read_byte(cpustate->space, PCW))
+				PCW, cpustate->direct->read_decrypted_byte(PCW))
 
 /* N2A03 *******************************************************
  *  ARR logical and, rotate right - no decimal mode
diff -Nru src-old/emu/cpu/m6502/m4510.c src/emu/cpu/m6502/m4510.c
--- src-old/emu/cpu/m6502/m4510.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6502/m4510.c	2010-08-19 09:10:19.000000000 -0700
@@ -144,7 +144,8 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *space;
+	address_space *space;
+	direct_read_data *direct;
 	int 	icount;
 
 	read8_space_func rdmem_id;					/* readmem callback for indexed instructions */
@@ -170,27 +171,27 @@
 INLINE int m4510_cpu_readop(m4510_Regs *cpustate)
 {
 	register UINT16 t=cpustate->pc.w.l++;
-	return memory_decrypted_read_byte(cpustate->space, M4510_MEM(t));
+	return cpustate->direct->read_decrypted_byte(M4510_MEM(t));
 }
 
 INLINE int m4510_cpu_readop_arg(m4510_Regs *cpustate)
 {
 	register UINT16 t=cpustate->pc.w.l++;
-	return memory_raw_read_byte(cpustate->space, M4510_MEM(t));
+	return cpustate->direct->read_raw_byte(M4510_MEM(t));
 }
 
 #define M4510
 #include "t65ce02.c"
 
-static UINT8 default_rdmem_id(const address_space *space, offs_t address)
+static UINT8 default_rdmem_id(address_space *space, offs_t address)
 {
 	m4510_Regs *cpustate = get_safe_token(space->cpu);
-	return memory_read_byte_8le(space, M4510_MEM(address));
+	return space->read_byte(M4510_MEM(address));
 }
-static void default_wrmem_id(const address_space *space, offs_t address, UINT8 data)
+static void default_wrmem_id(address_space *space, offs_t address, UINT8 data)
 {
 	m4510_Regs *cpustate = get_safe_token(space->cpu);
-	memory_write_byte_8le(space, M4510_MEM(address), data);
+	space->write_byte(M4510_MEM(address), data);
 }
 
 static CPU_INIT( m4510 )
@@ -206,6 +207,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->space = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->space->direct();
 
 	if ( intf )
 	{
diff -Nru src-old/emu/cpu/m6502/m6502.c src/emu/cpu/m6502/m6502.c
--- src-old/emu/cpu/m6502/m6502.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6502/m6502.c	2010-08-19 09:10:19.000000000 -0700
@@ -70,8 +70,9 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *space;
-	const address_space *io;
+	address_space *space;
+	direct_read_data *direct;
+	address_space *io;
 	int		int_occured;
 	int		icount;
 
@@ -99,8 +100,8 @@
 	return (m6502_Regs *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-static UINT8 default_rdmem_id(const address_space *space, offs_t offset) { return memory_read_byte_8le(space, offset); }
-static void default_wdmem_id(const address_space *space, offs_t offset, UINT8 data) { memory_write_byte_8le(space, offset, data); }
+static UINT8 default_rdmem_id(address_space *space, offs_t offset) { return space->read_byte(offset); }
+static void default_wdmem_id(address_space *space, offs_t offset, UINT8 data) { space->write_byte(offset, data); }
 
 /***************************************************************
  * include the opcode macros, functions and tables
@@ -135,6 +136,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->space = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->space->direct();
 	cpustate->subtype = subtype;
 	cpustate->insn = insn;
 	cpustate->rdmem_id = default_rdmem_id;
diff -Nru src-old/emu/cpu/m6502/m6509.c src/emu/cpu/m6502/m6509.c
--- src-old/emu/cpu/m6502/m6509.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6502/m6509.c	2010-08-19 09:10:19.000000000 -0700
@@ -79,7 +79,8 @@
 	UINT8	so_state;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *space;
+	address_space *space;
+	direct_read_data *direct;
 
 	int 	icount;
 
@@ -134,8 +135,8 @@
 	AM_RANGE(0x00001, 0x00001) AM_MIRROR(0xF0000) AM_READWRITE(m6509_read_00001, m6509_write_00001)
 ADDRESS_MAP_END
 
-static UINT8 default_rdmem_id(const address_space *space, offs_t address) { return memory_read_byte_8le(space, address); }
-static void default_wdmem_id(const address_space *space, offs_t address, UINT8 data) { memory_write_byte_8le(space, address, data); }
+static UINT8 default_rdmem_id(address_space *space, offs_t address) { return space->read_byte(address); }
+static void default_wdmem_id(address_space *space, offs_t address, UINT8 data) { space->write_byte(address, data); }
 
 static CPU_INIT( m6509 )
 {
@@ -147,6 +148,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->space = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->space->direct();
 
 	if ( intf )
 	{
diff -Nru src-old/emu/cpu/m6502/m65ce02.c src/emu/cpu/m6502/m65ce02.c
--- src-old/emu/cpu/m6502/m65ce02.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6502/m65ce02.c	2010-08-19 09:10:19.000000000 -0700
@@ -76,7 +76,8 @@
 	int		icount;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *space;
+	address_space *space;
+	direct_read_data *direct;
 	read8_space_func rdmem_id;					/* readmem callback for indexed instructions */
 	write8_space_func wrmem_id;					/* writemem callback for indexed instructions */
 };
@@ -94,8 +95,8 @@
 
 #include "t65ce02.c"
 
-static UINT8 default_rdmem_id(const address_space *space, offs_t address) { return memory_read_byte_8le(space, address); }
-static void default_wdmem_id(const address_space *space, offs_t address, UINT8 data) { memory_write_byte_8le(space, address, data); }
+static UINT8 default_rdmem_id(address_space *space, offs_t address) { return space->read_byte(address); }
+static void default_wdmem_id(address_space *space, offs_t address, UINT8 data) { space->write_byte(address, data); }
 
 static CPU_INIT( m65ce02 )
 {
@@ -107,6 +108,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->space = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->space->direct();
 
 	if ( intf )
 	{
diff -Nru src-old/emu/cpu/m6502/minc4510.h src/emu/cpu/m6502/minc4510.h
--- src-old/emu/cpu/m6502/minc4510.h	2008-11-26 12:35:58.000000000 -0800
+++ src/emu/cpu/m6502/minc4510.h	2010-08-19 09:10:19.000000000 -0700
@@ -52,10 +52,10 @@
 
 #define M4510_MEM(addr)	(cpustate->mem[(addr)>>13]+(addr))
 
-#define PEEK_OP()	memory_decrypted_read_byte(cpustate->space, M4510_MEM(PCW))
+#define PEEK_OP()	cpustate->direct->read_decrypted_byte(M4510_MEM(PCW))
 
-#define RDMEM(addr)			memory_read_byte_8le(cpustate->space, M4510_MEM(addr)); cpustate->icount -= 1
-#define WRMEM(addr,data)	memory_write_byte_8le(cpustate->space, M4510_MEM(addr),data); cpustate->icount -= 1
+#define RDMEM(addr)			cpustate->space->read_byte(M4510_MEM(addr)); cpustate->icount -= 1
+#define WRMEM(addr,data)	cpustate->space->write_byte(M4510_MEM(addr),data); cpustate->icount -= 1
 
 /***************************************************************
  *  RDOP    read an opcode
diff -Nru src-old/emu/cpu/m6502/mincce02.h src/emu/cpu/m6502/mincce02.h
--- src-old/emu/cpu/m6502/mincce02.h	2008-11-26 12:35:58.000000000 -0800
+++ src/emu/cpu/m6502/mincce02.h	2010-08-19 09:10:19.000000000 -0700
@@ -56,14 +56,14 @@
 /***************************************************************
  *  RDOP    read an opcode
  ***************************************************************/
-#define RDOP()	memory_decrypted_read_byte(cpustate->space, PCW++); cpustate->icount -= 1
+#define RDOP()	cpustate->direct->read_decrypted_byte(PCW++); cpustate->icount -= 1
 
 /***************************************************************
  *  RDOPARG read an opcode argument
  ***************************************************************/
-#define RDOPARG()	memory_raw_read_byte(cpustate->space, PCW++); cpustate->icount -= 1
+#define RDOPARG()	cpustate->direct->read_raw_byte(PCW++); cpustate->icount -= 1
 
-#define PEEK_OP()	memory_decrypted_read_byte(cpustate->space, PCW)
+#define PEEK_OP()	cpustate->direct->read_decrypted_byte(PCW)
 
-#define RDMEM(addr)			memory_read_byte_8le(cpustate->space, addr); cpustate->icount -= 1
-#define WRMEM(addr,data)	memory_write_byte_8le(cpustate->space, addr,data); cpustate->icount -= 1
+#define RDMEM(addr)			cpustate->space->read_byte(addr); cpustate->icount -= 1
+#define WRMEM(addr,data)	cpustate->space->write_byte(addr,data); cpustate->icount -= 1
diff -Nru src-old/emu/cpu/m6502/ops02.h src/emu/cpu/m6502/ops02.h
--- src-old/emu/cpu/m6502/ops02.h	2010-03-08 10:06:27.000000000 -0800
+++ src/emu/cpu/m6502/ops02.h	2010-08-19 09:10:19.000000000 -0700
@@ -70,23 +70,23 @@
 /***************************************************************
  *  RDOP    read an opcode
  ***************************************************************/
-#define RDOP() memory_decrypted_read_byte(cpustate->space, PCW++); cpustate->icount -= 1
-#define PEEKOP() memory_decrypted_read_byte(cpustate->space, PCW)
+#define RDOP() cpustate->direct->read_decrypted_byte(PCW++); cpustate->icount -= 1
+#define PEEKOP() cpustate->direct->read_decrypted_byte(PCW)
 
 /***************************************************************
  *  RDOPARG read an opcode argument
  ***************************************************************/
-#define RDOPARG() memory_raw_read_byte(cpustate->space, PCW++); cpustate->icount -= 1
+#define RDOPARG() cpustate->direct->read_raw_byte(PCW++); cpustate->icount -= 1
 
 /***************************************************************
  *  RDMEM   read memory
  ***************************************************************/
-#define RDMEM(addr) memory_read_byte_8le(cpustate->space, addr); cpustate->icount -= 1
+#define RDMEM(addr) cpustate->space->read_byte(addr); cpustate->icount -= 1
 
 /***************************************************************
  *  WRMEM   write memory
  ***************************************************************/
-#define WRMEM(addr,data) memory_write_byte_8le(cpustate->space, addr,data); cpustate->icount -= 1
+#define WRMEM(addr,data) cpustate->space->write_byte(addr,data); cpustate->icount -= 1
 
 /***************************************************************
  *  BRA  branch relative
@@ -507,7 +507,7 @@
  *  ILL Illegal opcode
  ***************************************************************/
 #define ILL 													\
-	logerror("M6502 illegal opcode %04x: %02x\n",(PCW-1)&0xffff, memory_decrypted_read_byte(cpustate->space, (PCW-1)&0xffff))
+	logerror("M6502 illegal opcode %04x: %02x\n",(PCW-1)&0xffff, cpustate->direct->read_decrypted_byte((PCW-1)&0xffff))
 
 /* 6502 ********************************************************
  *  INC Increment memory
diff -Nru src-old/emu/cpu/m6502/ops09.h src/emu/cpu/m6502/ops09.h
--- src-old/emu/cpu/m6502/ops09.h	2008-11-26 12:35:58.000000000 -0800
+++ src/emu/cpu/m6502/ops09.h	2010-08-19 09:10:19.000000000 -0700
@@ -34,25 +34,25 @@
  *  RDOP    read an opcode
  ***************************************************************/
 #undef RDOP
-#define RDOP() memory_decrypted_read_byte(cpustate->space, (PCW++)|PB); cpustate->icount -= 1
+#define RDOP() cpustate->direct->read_decrypted_byte((PCW++)|PB); cpustate->icount -= 1
 
 /***************************************************************
  *  RDOPARG read an opcode argument
  ***************************************************************/
 #undef RDOPARG
-#define RDOPARG() memory_raw_read_byte(cpustate->space, (PCW++)|PB); cpustate->icount -= 1
+#define RDOPARG() cpustate->direct->read_raw_byte((PCW++)|PB); cpustate->icount -= 1
 
 /***************************************************************
  *  RDMEM   read memory
  ***************************************************************/
 #undef RDMEM
-#define RDMEM(addr) memory_read_byte_8le(cpustate->space, addr); cpustate->icount -= 1
+#define RDMEM(addr) cpustate->space->read_byte(addr); cpustate->icount -= 1
 
 /***************************************************************
  *  WRMEM   write memory
  ***************************************************************/
 #undef WRMEM
-#define WRMEM(addr,data) memory_write_byte_8le(cpustate->space, addr,data); cpustate->icount -= 1
+#define WRMEM(addr,data) cpustate->space->write_byte(addr,data); cpustate->icount -= 1
 
 /***************************************************************
  * push a register onto the stack
@@ -203,4 +203,4 @@
 #undef KIL
 #define KIL 													\
 	PCW--;														\
-	logerror("M6509 KILL opcode %05x: %02x\n", PCD, memory_decrypted_read_byte(cpustate->space, PCD))
+	logerror("M6509 KILL opcode %05x: %02x\n", PCD, cpustate->direct->read_decrypted_byte(PCD))
diff -Nru src-old/emu/cpu/m6502/tdeco16.c src/emu/cpu/m6502/tdeco16.c
--- src-old/emu/cpu/m6502/tdeco16.c	2010-05-23 12:10:13.000000000 -0700
+++ src/emu/cpu/m6502/tdeco16.c	2010-08-19 01:27:05.000000000 -0700
@@ -188,7 +188,7 @@
 OP(47) { RD_DUM; ILL; }									/* 2 ILL / 5 RMB4 ZPG ?? */
 OP(67) {
 	int tmp; RD_IMM;
-	cpustate->a=memory_read_byte_8le(cpustate->io,0);
+	cpustate->a=cpustate->io->read_byte(0);
 
 //  logerror("%04x: VBL (0x67)\n",PCW);
 
@@ -274,7 +274,7 @@
 OP(4b) { int tmp; cpustate->icount -= 1; RD_IMM;
 	//logerror("%04x: OP4B %02x\n",PCW,tmp);
 	/* TODO: Maybe it's just read I/O 0 and do a logic AND with bit 1? */
-	cpustate->a=memory_read_byte_8le(cpustate->io,1);
+	cpustate->a=cpustate->io->read_byte(1);
 
 //tilt??
 
@@ -367,7 +367,7 @@
 	if (DECO16_VERBOSE)
 		logerror("%04x: BANK (8F) %02x\n",PCW,tmp);
 
-	memory_write_byte_8le(cpustate->io,0,tmp);
+	cpustate->io->write_byte(0,tmp);
 
 	//swap bank in/out
 } /*  */
diff -Nru src-old/emu/cpu/m6800/m6800.c src/emu/cpu/m6800/m6800.c
--- src-old/emu/cpu/m6800/m6800.c	2010-07-29 06:59:41.000000000 -0700
+++ src/emu/cpu/m6800/m6800.c	2010-08-30 08:20:58.000000000 -0700
@@ -116,9 +116,10 @@
 	legacy_cpu_device *device;
 
 	/* Memory spaces */
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
 	void	(* const * insn)(m6800_state *);	/* instruction table */
 	const UINT8 *cycles;			/* clock cycle of instruction table */
@@ -206,26 +207,26 @@
 /****************************************************************************/
 /* Read a byte from given memory location                                   */
 /****************************************************************************/
-#define RM(Addr) ((unsigned)memory_read_byte_8be(cpustate->program, Addr))
+#define RM(Addr) ((unsigned)cpustate->program->read_byte(Addr))
 
 /****************************************************************************/
 /* Write a byte to given memory location                                    */
 /****************************************************************************/
-#define WM(Addr,Value) (memory_write_byte_8be(cpustate->program, Addr,Value))
+#define WM(Addr,Value) (cpustate->program->write_byte(Addr,Value))
 
 /****************************************************************************/
 /* M6800_RDOP() is identical to M6800_RDMEM() except it is used for reading */
 /* opcodes. In case of system with memory mapped I/O, this function can be  */
 /* used to greatly speed up emulation                                       */
 /****************************************************************************/
-#define M_RDOP(Addr) ((unsigned)memory_decrypted_read_byte(cpustate->program, Addr))
+#define M_RDOP(Addr) ((unsigned)cpustate->direct->read_decrypted_byte(Addr))
 
 /****************************************************************************/
 /* M6800_RDOP_ARG() is identical to M6800_RDOP() but it's used for reading  */
 /* opcode arguments. This difference can be used to support systems that    */
 /* use different encoding mechanisms for opcodes and opcode arguments       */
 /****************************************************************************/
-#define M_RDOP_ARG(Addr) ((unsigned)memory_raw_read_byte(cpustate->program, Addr))
+#define M_RDOP_ARG(Addr) ((unsigned)cpustate->direct->read_raw_byte(Addr))
 
 /* macros to access memory */
 #define IMMBYTE(b)	b = M_RDOP_ARG(PCD); PC++
@@ -675,15 +676,15 @@
 	cpustate->port2_data = (cpustate->port2_data & 0xef) | (value << 4);
 
 	if(cpustate->port2_ddr == 0xff)
-		memory_write_byte_8be(cpustate->io, M6803_PORT2,cpustate->port2_data);
+		cpustate->io->write_byte(M6803_PORT2,cpustate->port2_data);
 	else
-		memory_write_byte_8be(cpustate->io, M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
-			| (memory_read_byte_8be(cpustate->io, M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
+		cpustate->io->write_byte(M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
+			| (cpustate->io->read_byte(M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
 }
 
 static int m6800_rx(m6800_state *cpustate)
 {
-	return (memory_read_byte_8be(cpustate->io, M6803_PORT2) & M6800_PORT2_IO3) >> 3;
+	return (cpustate->io->read_byte(M6803_PORT2) & M6800_PORT2_IO3) >> 3;
 }
 
 static TIMER_CALLBACK(m6800_tx_tick)
@@ -911,6 +912,7 @@
 	m6800_state *cpustate = get_safe_token(device);
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -954,6 +956,8 @@
 	cpustate->txstate = M6800_TX_STATE_INIT;
 	cpustate->txbits = cpustate->rxbits = 0;
 	cpustate->trcsr_read = 0;
+
+	cpustate->cc = 0xc0;
 }
 
 /****************************************************************************
@@ -995,273 +999,6 @@
 }
 
 /****************************************************************************
- * Execute one instruction
- ****************************************************************************/
-
-INLINE void m6800_execute_one(m6800_state *cpustate, UINT8 ireg)
-{
-	switch( ireg )
-	{
-		case 0x00: illegal(cpustate); break;
-		case 0x01: nop(cpustate); break;
-		case 0x02: illegal(cpustate); break;
-		case 0x03: illegal(cpustate); break;
-		case 0x04: illegal(cpustate); break;
-		case 0x05: illegal(cpustate); break;
-		case 0x06: tap(cpustate); break;
-		case 0x07: tpa(cpustate); break;
-		case 0x08: inx(cpustate); break;
-		case 0x09: dex(cpustate); break;
-		case 0x0A: CLV; break;
-		case 0x0B: SEV; break;
-		case 0x0C: CLC; break;
-		case 0x0D: SEC; break;
-		case 0x0E: cli(cpustate); break;
-		case 0x0F: sei(cpustate); break;
-		case 0x10: sba(cpustate); break;
-		case 0x11: cba(cpustate); break;
-		case 0x12: illegal(cpustate); break;
-		case 0x13: illegal(cpustate); break;
-		case 0x14: illegal(cpustate); break;
-		case 0x15: illegal(cpustate); break;
-		case 0x16: tab(cpustate); break;
-		case 0x17: tba(cpustate); break;
-		case 0x18: illegal(cpustate); break;
-		case 0x19: daa(cpustate); break;
-		case 0x1a: illegal(cpustate); break;
-		case 0x1b: aba(cpustate); break;
-		case 0x1c: illegal(cpustate); break;
-		case 0x1d: illegal(cpustate); break;
-		case 0x1e: illegal(cpustate); break;
-		case 0x1f: illegal(cpustate); break;
-		case 0x20: bra(cpustate); break;
-		case 0x21: brn(cpustate); break;
-		case 0x22: bhi(cpustate); break;
-		case 0x23: bls(cpustate); break;
-		case 0x24: bcc(cpustate); break;
-		case 0x25: bcs(cpustate); break;
-		case 0x26: bne(cpustate); break;
-		case 0x27: beq(cpustate); break;
-		case 0x28: bvc(cpustate); break;
-		case 0x29: bvs(cpustate); break;
-		case 0x2a: bpl(cpustate); break;
-		case 0x2b: bmi(cpustate); break;
-		case 0x2c: bge(cpustate); break;
-		case 0x2d: blt(cpustate); break;
-		case 0x2e: bgt(cpustate); break;
-		case 0x2f: ble(cpustate); break;
-		case 0x30: tsx(cpustate); break;
-		case 0x31: ins(cpustate); break;
-		case 0x32: pula(cpustate); break;
-		case 0x33: pulb(cpustate); break;
-		case 0x34: des(cpustate); break;
-		case 0x35: txs(cpustate); break;
-		case 0x36: psha(cpustate); break;
-		case 0x37: pshb(cpustate); break;
-		case 0x38: illegal(cpustate); break;
-		case 0x39: rts(cpustate); break;
-		case 0x3a: illegal(cpustate); break;
-		case 0x3b: rti(cpustate); break;
-		case 0x3c: illegal(cpustate); break;
-		case 0x3d: illegal(cpustate); break;
-		case 0x3e: wai(cpustate); break;
-		case 0x3f: swi(cpustate); break;
-		case 0x40: nega(cpustate); break;
-		case 0x41: illegal(cpustate); break;
-		case 0x42: illegal(cpustate); break;
-		case 0x43: coma(cpustate); break;
-		case 0x44: lsra(cpustate); break;
-		case 0x45: illegal(cpustate); break;
-		case 0x46: rora(cpustate); break;
-		case 0x47: asra(cpustate); break;
-		case 0x48: asla(cpustate); break;
-		case 0x49: rola(cpustate); break;
-		case 0x4a: deca(cpustate); break;
-		case 0x4b: illegal(cpustate); break;
-		case 0x4c: inca(cpustate); break;
-		case 0x4d: tsta(cpustate); break;
-		case 0x4e: illegal(cpustate); break;
-		case 0x4f: clra(cpustate); break;
-		case 0x50: negb(cpustate); break;
-		case 0x51: illegal(cpustate); break;
-		case 0x52: illegal(cpustate); break;
-		case 0x53: comb(cpustate); break;
-		case 0x54: lsrb(cpustate); break;
-		case 0x55: illegal(cpustate); break;
-		case 0x56: rorb(cpustate); break;
-		case 0x57: asrb(cpustate); break;
-		case 0x58: aslb(cpustate); break;
-		case 0x59: rolb(cpustate); break;
-		case 0x5a: decb(cpustate); break;
-		case 0x5b: illegal(cpustate); break;
-		case 0x5c: incb(cpustate); break;
-		case 0x5d: tstb(cpustate); break;
-		case 0x5e: illegal(cpustate); break;
-		case 0x5f: clrb(cpustate); break;
-		case 0x60: neg_ix(cpustate); break;
-		case 0x61: illegal(cpustate); break;
-		case 0x62: illegal(cpustate); break;
-		case 0x63: com_ix(cpustate); break;
-		case 0x64: lsr_ix(cpustate); break;
-		case 0x65: illegal(cpustate); break;
-		case 0x66: ror_ix(cpustate); break;
-		case 0x67: asr_ix(cpustate); break;
-		case 0x68: asl_ix(cpustate); break;
-		case 0x69: rol_ix(cpustate); break;
-		case 0x6a: dec_ix(cpustate); break;
-		case 0x6b: illegal(cpustate); break;
-		case 0x6c: inc_ix(cpustate); break;
-		case 0x6d: tst_ix(cpustate); break;
-		case 0x6e: jmp_ix(cpustate); break;
-		case 0x6f: clr_ix(cpustate); break;
-		case 0x70: neg_ex(cpustate); break;
-		case 0x71: illegal(cpustate); break;
-		case 0x72: illegal(cpustate); break;
-		case 0x73: com_ex(cpustate); break;
-		case 0x74: lsr_ex(cpustate); break;
-		case 0x75: illegal(cpustate); break;
-		case 0x76: ror_ex(cpustate); break;
-		case 0x77: asr_ex(cpustate); break;
-		case 0x78: asl_ex(cpustate); break;
-		case 0x79: rol_ex(cpustate); break;
-		case 0x7a: dec_ex(cpustate); break;
-		case 0x7b: illegal(cpustate); break;
-		case 0x7c: inc_ex(cpustate); break;
-		case 0x7d: tst_ex(cpustate); break;
-		case 0x7e: jmp_ex(cpustate); break;
-		case 0x7f: clr_ex(cpustate); break;
-		case 0x80: suba_im(cpustate); break;
-		case 0x81: cmpa_im(cpustate); break;
-		case 0x82: sbca_im(cpustate); break;
-		case 0x83: illegal(cpustate); break;
-		case 0x84: anda_im(cpustate); break;
-		case 0x85: bita_im(cpustate); break;
-		case 0x86: lda_im(cpustate); break;
-		case 0x87: sta_im(cpustate); break;
-		case 0x88: eora_im(cpustate); break;
-		case 0x89: adca_im(cpustate); break;
-		case 0x8a: ora_im(cpustate); break;
-		case 0x8b: adda_im(cpustate); break;
-		case 0x8c: cmpx_im(cpustate); break;
-		case 0x8d: bsr(cpustate); break;
-		case 0x8e: lds_im(cpustate); break;
-		case 0x8f: sts_im(cpustate); /* orthogonality */ break;
-		case 0x90: suba_di(cpustate); break;
-		case 0x91: cmpa_di(cpustate); break;
-		case 0x92: sbca_di(cpustate); break;
-		case 0x93: illegal(cpustate); break;
-		case 0x94: anda_di(cpustate); break;
-		case 0x95: bita_di(cpustate); break;
-		case 0x96: lda_di(cpustate); break;
-		case 0x97: sta_di(cpustate); break;
-		case 0x98: eora_di(cpustate); break;
-		case 0x99: adca_di(cpustate); break;
-		case 0x9a: ora_di(cpustate); break;
-		case 0x9b: adda_di(cpustate); break;
-		case 0x9c: cmpx_di(cpustate); break;
-		case 0x9d: jsr_di(cpustate); break;
-		case 0x9e: lds_di(cpustate); break;
-		case 0x9f: sts_di(cpustate); break;
-		case 0xa0: suba_ix(cpustate); break;
-		case 0xa1: cmpa_ix(cpustate); break;
-		case 0xa2: sbca_ix(cpustate); break;
-		case 0xa3: illegal(cpustate); break;
-		case 0xa4: anda_ix(cpustate); break;
-		case 0xa5: bita_ix(cpustate); break;
-		case 0xa6: lda_ix(cpustate); break;
-		case 0xa7: sta_ix(cpustate); break;
-		case 0xa8: eora_ix(cpustate); break;
-		case 0xa9: adca_ix(cpustate); break;
-		case 0xaa: ora_ix(cpustate); break;
-		case 0xab: adda_ix(cpustate); break;
-		case 0xac: cmpx_ix(cpustate); break;
-		case 0xad: jsr_ix(cpustate); break;
-		case 0xae: lds_ix(cpustate); break;
-		case 0xaf: sts_ix(cpustate); break;
-		case 0xb0: suba_ex(cpustate); break;
-		case 0xb1: cmpa_ex(cpustate); break;
-		case 0xb2: sbca_ex(cpustate); break;
-		case 0xb3: illegal(cpustate); break;
-		case 0xb4: anda_ex(cpustate); break;
-		case 0xb5: bita_ex(cpustate); break;
-		case 0xb6: lda_ex(cpustate); break;
-		case 0xb7: sta_ex(cpustate); break;
-		case 0xb8: eora_ex(cpustate); break;
-		case 0xb9: adca_ex(cpustate); break;
-		case 0xba: ora_ex(cpustate); break;
-		case 0xbb: adda_ex(cpustate); break;
-		case 0xbc: cmpx_ex(cpustate); break;
-		case 0xbd: jsr_ex(cpustate); break;
-		case 0xbe: lds_ex(cpustate); break;
-		case 0xbf: sts_ex(cpustate); break;
-		case 0xc0: subb_im(cpustate); break;
-		case 0xc1: cmpb_im(cpustate); break;
-		case 0xc2: sbcb_im(cpustate); break;
-		case 0xc3: illegal(cpustate); break;
-		case 0xc4: andb_im(cpustate); break;
-		case 0xc5: bitb_im(cpustate); break;
-		case 0xc6: ldb_im(cpustate); break;
-		case 0xc7: stb_im(cpustate); break;
-		case 0xc8: eorb_im(cpustate); break;
-		case 0xc9: adcb_im(cpustate); break;
-		case 0xca: orb_im(cpustate); break;
-		case 0xcb: addb_im(cpustate); break;
-		case 0xcc: illegal(cpustate); break;
-		case 0xcd: illegal(cpustate); break;
-		case 0xce: ldx_im(cpustate); break;
-		case 0xcf: stx_im(cpustate); break;
-		case 0xd0: subb_di(cpustate); break;
-		case 0xd1: cmpb_di(cpustate); break;
-		case 0xd2: sbcb_di(cpustate); break;
-		case 0xd3: illegal(cpustate); break;
-		case 0xd4: andb_di(cpustate); break;
-		case 0xd5: bitb_di(cpustate); break;
-		case 0xd6: ldb_di(cpustate); break;
-		case 0xd7: stb_di(cpustate); break;
-		case 0xd8: eorb_di(cpustate); break;
-		case 0xd9: adcb_di(cpustate); break;
-		case 0xda: orb_di(cpustate); break;
-		case 0xdb: addb_di(cpustate); break;
-		case 0xdc: illegal(cpustate); break;
-		case 0xdd: illegal(cpustate); break;
-		case 0xde: ldx_di(cpustate); break;
-		case 0xdf: stx_di(cpustate); break;
-		case 0xe0: subb_ix(cpustate); break;
-		case 0xe1: cmpb_ix(cpustate); break;
-		case 0xe2: sbcb_ix(cpustate); break;
-		case 0xe3: illegal(cpustate); break;
-		case 0xe4: andb_ix(cpustate); break;
-		case 0xe5: bitb_ix(cpustate); break;
-		case 0xe6: ldb_ix(cpustate); break;
-		case 0xe7: stb_ix(cpustate); break;
-		case 0xe8: eorb_ix(cpustate); break;
-		case 0xe9: adcb_ix(cpustate); break;
-		case 0xea: orb_ix(cpustate); break;
-		case 0xeb: addb_ix(cpustate); break;
-		case 0xec: illegal(cpustate); break;
-		case 0xed: illegal(cpustate); break;
-		case 0xee: ldx_ix(cpustate); break;
-		case 0xef: stx_ix(cpustate); break;
-		case 0xf0: subb_ex(cpustate); break;
-		case 0xf1: cmpb_ex(cpustate); break;
-		case 0xf2: sbcb_ex(cpustate); break;
-		case 0xf3: illegal(cpustate); break;
-		case 0xf4: andb_ex(cpustate); break;
-		case 0xf5: bitb_ex(cpustate); break;
-		case 0xf6: ldb_ex(cpustate); break;
-		case 0xf7: stb_ex(cpustate); break;
-		case 0xf8: eorb_ex(cpustate); break;
-		case 0xf9: adcb_ex(cpustate); break;
-		case 0xfa: orb_ex(cpustate); break;
-		case 0xfb: addb_ex(cpustate); break;
-		case 0xfc: addx_ex(cpustate); break;
-		case 0xfd: illegal(cpustate); break;
-		case 0xfe: ldx_ex(cpustate); break;
-		case 0xff: stx_ex(cpustate); break;
-	}
-}
-
-/****************************************************************************
  * Execute cycles CPU cycles. Return number of cycles really executed
  ****************************************************************************/
 static CPU_EXECUTE( m6800 )
@@ -1275,7 +1012,7 @@
 
 	do
 	{
-		if( cpustate->wai_state & M6800_WAI )
+		if( cpustate->wai_state & (M6800_WAI|M6800_SLP) )
 		{
 			EAT_CYCLES;
 		}
@@ -1285,8 +1022,8 @@
 			debugger_instruction_hook(device, PCD);
 			ireg=M_RDOP(PCD);
 			PC++;
-			m6800_execute_one(cpustate, ireg);
-			increment_counter(cpustate, cycles_6800[ireg]);
+			(*cpustate->insn[ireg])(cpustate);
+			increment_counter(cpustate, cpustate->cycles[ireg]);
 		}
 	} while( cpustate->icount>0 );
 }
@@ -1304,6 +1041,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -1327,6 +1065,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -1346,6 +1085,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -1356,304 +1096,6 @@
 	state_register(cpustate, "m6803");
 }
 
-/****************************************************************************
- * Execute one instruction
- ****************************************************************************/
-
-INLINE void m6803_execute_one(m6800_state *cpustate, UINT8 ireg)
-{
-	switch( ireg )
-	{
-		case 0x00: illegal(cpustate); break;
-		case 0x01: nop(cpustate); break;
-		case 0x02: illegal(cpustate); break;
-		case 0x03: illegal(cpustate); break;
-		case 0x04: lsrd(cpustate); /* 6803 only */; break;
-		case 0x05: asld(cpustate); /* 6803 only */; break;
-		case 0x06: tap(cpustate); break;
-		case 0x07: tpa(cpustate); break;
-		case 0x08: inx(cpustate); break;
-		case 0x09: dex(cpustate); break;
-		case 0x0A: CLV; break;
-		case 0x0B: SEV; break;
-		case 0x0C: CLC; break;
-		case 0x0D: SEC; break;
-		case 0x0E: cli(cpustate); break;
-		case 0x0F: sei(cpustate); break;
-		case 0x10: sba(cpustate); break;
-		case 0x11: cba(cpustate); break;
-		case 0x12: illegal(cpustate); break;
-		case 0x13: illegal(cpustate); break;
-		case 0x14: illegal(cpustate); break;
-		case 0x15: illegal(cpustate); break;
-		case 0x16: tab(cpustate); break;
-		case 0x17: tba(cpustate); break;
-		case 0x18: illegal(cpustate); break;
-		case 0x19: daa(cpustate); break;
-		case 0x1a: illegal(cpustate); break;
-		case 0x1b: aba(cpustate); break;
-		case 0x1c: illegal(cpustate); break;
-		case 0x1d: illegal(cpustate); break;
-		case 0x1e: illegal(cpustate); break;
-		case 0x1f: illegal(cpustate); break;
-		case 0x20: bra(cpustate); break;
-		case 0x21: brn(cpustate); break;
-		case 0x22: bhi(cpustate); break;
-		case 0x23: bls(cpustate); break;
-		case 0x24: bcc(cpustate); break;
-		case 0x25: bcs(cpustate); break;
-		case 0x26: bne(cpustate); break;
-		case 0x27: beq(cpustate); break;
-		case 0x28: bvc(cpustate); break;
-		case 0x29: bvs(cpustate); break;
-		case 0x2a: bpl(cpustate); break;
-		case 0x2b: bmi(cpustate); break;
-		case 0x2c: bge(cpustate); break;
-		case 0x2d: blt(cpustate); break;
-		case 0x2e: bgt(cpustate); break;
-		case 0x2f: ble(cpustate); break;
-		case 0x30: tsx(cpustate); break;
-		case 0x31: ins(cpustate); break;
-		case 0x32: pula(cpustate); break;
-		case 0x33: pulb(cpustate); break;
-		case 0x34: des(cpustate); break;
-		case 0x35: txs(cpustate); break;
-		case 0x36: psha(cpustate); break;
-		case 0x37: pshb(cpustate); break;
-		case 0x38: pulx(cpustate); /* 6803 only */ break;
-		case 0x39: rts(cpustate); break;
-		case 0x3a: abx(cpustate); /* 6803 only */ break;
-		case 0x3b: rti(cpustate); break;
-		case 0x3c: pshx(cpustate); /* 6803 only */ break;
-		case 0x3d: mul(cpustate); /* 6803 only */ break;
-		case 0x3e: wai(cpustate); break;
-		case 0x3f: swi(cpustate); break;
-		case 0x40: nega(cpustate); break;
-		case 0x41: illegal(cpustate); break;
-		case 0x42: illegal(cpustate); break;
-		case 0x43: coma(cpustate); break;
-		case 0x44: lsra(cpustate); break;
-		case 0x45: illegal(cpustate); break;
-		case 0x46: rora(cpustate); break;
-		case 0x47: asra(cpustate); break;
-		case 0x48: asla(cpustate); break;
-		case 0x49: rola(cpustate); break;
-		case 0x4a: deca(cpustate); break;
-		case 0x4b: illegal(cpustate); break;
-		case 0x4c: inca(cpustate); break;
-		case 0x4d: tsta(cpustate); break;
-		case 0x4e: illegal(cpustate); break;
-		case 0x4f: clra(cpustate); break;
-		case 0x50: negb(cpustate); break;
-		case 0x51: illegal(cpustate); break;
-		case 0x52: illegal(cpustate); break;
-		case 0x53: comb(cpustate); break;
-		case 0x54: lsrb(cpustate); break;
-		case 0x55: illegal(cpustate); break;
-		case 0x56: rorb(cpustate); break;
-		case 0x57: asrb(cpustate); break;
-		case 0x58: aslb(cpustate); break;
-		case 0x59: rolb(cpustate); break;
-		case 0x5a: decb(cpustate); break;
-		case 0x5b: illegal(cpustate); break;
-		case 0x5c: incb(cpustate); break;
-		case 0x5d: tstb(cpustate); break;
-		case 0x5e: illegal(cpustate); break;
-		case 0x5f: clrb(cpustate); break;
-		case 0x60: neg_ix(cpustate); break;
-		case 0x61: illegal(cpustate); break;
-		case 0x62: illegal(cpustate); break;
-		case 0x63: com_ix(cpustate); break;
-		case 0x64: lsr_ix(cpustate); break;
-		case 0x65: illegal(cpustate); break;
-		case 0x66: ror_ix(cpustate); break;
-		case 0x67: asr_ix(cpustate); break;
-		case 0x68: asl_ix(cpustate); break;
-		case 0x69: rol_ix(cpustate); break;
-		case 0x6a: dec_ix(cpustate); break;
-		case 0x6b: illegal(cpustate); break;
-		case 0x6c: inc_ix(cpustate); break;
-		case 0x6d: tst_ix(cpustate); break;
-		case 0x6e: jmp_ix(cpustate); break;
-		case 0x6f: clr_ix(cpustate); break;
-		case 0x70: neg_ex(cpustate); break;
-		case 0x71: illegal(cpustate); break;
-		case 0x72: illegal(cpustate); break;
-		case 0x73: com_ex(cpustate); break;
-		case 0x74: lsr_ex(cpustate); break;
-		case 0x75: illegal(cpustate); break;
-		case 0x76: ror_ex(cpustate); break;
-		case 0x77: asr_ex(cpustate); break;
-		case 0x78: asl_ex(cpustate); break;
-		case 0x79: rol_ex(cpustate); break;
-		case 0x7a: dec_ex(cpustate); break;
-		case 0x7b: illegal(cpustate); break;
-		case 0x7c: inc_ex(cpustate); break;
-		case 0x7d: tst_ex(cpustate); break;
-		case 0x7e: jmp_ex(cpustate); break;
-		case 0x7f: clr_ex(cpustate); break;
-		case 0x80: suba_im(cpustate); break;
-		case 0x81: cmpa_im(cpustate); break;
-		case 0x82: sbca_im(cpustate); break;
-		case 0x83: subd_im(cpustate); /* 6803 only */ break;
-		case 0x84: anda_im(cpustate); break;
-		case 0x85: bita_im(cpustate); break;
-		case 0x86: lda_im(cpustate); break;
-		case 0x87: sta_im(cpustate); break;
-		case 0x88: eora_im(cpustate); break;
-		case 0x89: adca_im(cpustate); break;
-		case 0x8a: ora_im(cpustate); break;
-		case 0x8b: adda_im(cpustate); break;
-		case 0x8c: cpx_im(cpustate); /* 6803 difference */ break;
-		case 0x8d: bsr(cpustate); break;
-		case 0x8e: lds_im(cpustate); break;
-		case 0x8f: sts_im(cpustate); /* orthogonality */ break;
-		case 0x90: suba_di(cpustate); break;
-		case 0x91: cmpa_di(cpustate); break;
-		case 0x92: sbca_di(cpustate); break;
-		case 0x93: subd_di(cpustate); /* 6803 only */ break;
-		case 0x94: anda_di(cpustate); break;
-		case 0x95: bita_di(cpustate); break;
-		case 0x96: lda_di(cpustate); break;
-		case 0x97: sta_di(cpustate); break;
-		case 0x98: eora_di(cpustate); break;
-		case 0x99: adca_di(cpustate); break;
-		case 0x9a: ora_di(cpustate); break;
-		case 0x9b: adda_di(cpustate); break;
-		case 0x9c: cpx_di(cpustate); /* 6803 difference */ break;
-		case 0x9d: jsr_di(cpustate); break;
-		case 0x9e: lds_di(cpustate); break;
-		case 0x9f: sts_di(cpustate); break;
-		case 0xa0: suba_ix(cpustate); break;
-		case 0xa1: cmpa_ix(cpustate); break;
-		case 0xa2: sbca_ix(cpustate); break;
-		case 0xa3: subd_ix(cpustate); /* 6803 only */ break;
-		case 0xa4: anda_ix(cpustate); break;
-		case 0xa5: bita_ix(cpustate); break;
-		case 0xa6: lda_ix(cpustate); break;
-		case 0xa7: sta_ix(cpustate); break;
-		case 0xa8: eora_ix(cpustate); break;
-		case 0xa9: adca_ix(cpustate); break;
-		case 0xaa: ora_ix(cpustate); break;
-		case 0xab: adda_ix(cpustate); break;
-		case 0xac: cpx_ix(cpustate); /* 6803 difference */ break;
-		case 0xad: jsr_ix(cpustate); break;
-		case 0xae: lds_ix(cpustate); break;
-		case 0xaf: sts_ix(cpustate); break;
-		case 0xb0: suba_ex(cpustate); break;
-		case 0xb1: cmpa_ex(cpustate); break;
-		case 0xb2: sbca_ex(cpustate); break;
-		case 0xb3: subd_ex(cpustate); /* 6803 only */ break;
-		case 0xb4: anda_ex(cpustate); break;
-		case 0xb5: bita_ex(cpustate); break;
-		case 0xb6: lda_ex(cpustate); break;
-		case 0xb7: sta_ex(cpustate); break;
-		case 0xb8: eora_ex(cpustate); break;
-		case 0xb9: adca_ex(cpustate); break;
-		case 0xba: ora_ex(cpustate); break;
-		case 0xbb: adda_ex(cpustate); break;
-		case 0xbc: cpx_ex(cpustate); /* 6803 difference */ break;
-		case 0xbd: jsr_ex(cpustate); break;
-		case 0xbe: lds_ex(cpustate); break;
-		case 0xbf: sts_ex(cpustate); break;
-		case 0xc0: subb_im(cpustate); break;
-		case 0xc1: cmpb_im(cpustate); break;
-		case 0xc2: sbcb_im(cpustate); break;
-		case 0xc3: addd_im(cpustate); /* 6803 only */ break;
-		case 0xc4: andb_im(cpustate); break;
-		case 0xc5: bitb_im(cpustate); break;
-		case 0xc6: ldb_im(cpustate); break;
-		case 0xc7: stb_im(cpustate); break;
-		case 0xc8: eorb_im(cpustate); break;
-		case 0xc9: adcb_im(cpustate); break;
-		case 0xca: orb_im(cpustate); break;
-		case 0xcb: addb_im(cpustate); break;
-		case 0xcc: ldd_im(cpustate); /* 6803 only */ break;
-		case 0xcd: std_im(cpustate); /* 6803 only -- orthogonality */ break;
-		case 0xce: ldx_im(cpustate); break;
-		case 0xcf: stx_im(cpustate); break;
-		case 0xd0: subb_di(cpustate); break;
-		case 0xd1: cmpb_di(cpustate); break;
-		case 0xd2: sbcb_di(cpustate); break;
-		case 0xd3: addd_di(cpustate); /* 6803 only */ break;
-		case 0xd4: andb_di(cpustate); break;
-		case 0xd5: bitb_di(cpustate); break;
-		case 0xd6: ldb_di(cpustate); break;
-		case 0xd7: stb_di(cpustate); break;
-		case 0xd8: eorb_di(cpustate); break;
-		case 0xd9: adcb_di(cpustate); break;
-		case 0xda: orb_di(cpustate); break;
-		case 0xdb: addb_di(cpustate); break;
-		case 0xdc: ldd_di(cpustate); /* 6803 only */ break;
-		case 0xdd: std_di(cpustate); /* 6803 only */ break;
-		case 0xde: ldx_di(cpustate); break;
-		case 0xdf: stx_di(cpustate); break;
-		case 0xe0: subb_ix(cpustate); break;
-		case 0xe1: cmpb_ix(cpustate); break;
-		case 0xe2: sbcb_ix(cpustate); break;
-		case 0xe3: addd_ix(cpustate); /* 6803 only */ break;
-		case 0xe4: andb_ix(cpustate); break;
-		case 0xe5: bitb_ix(cpustate); break;
-		case 0xe6: ldb_ix(cpustate); break;
-		case 0xe7: stb_ix(cpustate); break;
-		case 0xe8: eorb_ix(cpustate); break;
-		case 0xe9: adcb_ix(cpustate); break;
-		case 0xea: orb_ix(cpustate); break;
-		case 0xeb: addb_ix(cpustate); break;
-		case 0xec: ldd_ix(cpustate); /* 6803 only */ break;
-		case 0xed: std_ix(cpustate); /* 6803 only */ break;
-		case 0xee: ldx_ix(cpustate); break;
-		case 0xef: stx_ix(cpustate); break;
-		case 0xf0: subb_ex(cpustate); break;
-		case 0xf1: cmpb_ex(cpustate); break;
-		case 0xf2: sbcb_ex(cpustate); break;
-		case 0xf3: addd_ex(cpustate); /* 6803 only */ break;
-		case 0xf4: andb_ex(cpustate); break;
-		case 0xf5: bitb_ex(cpustate); break;
-		case 0xf6: ldb_ex(cpustate); break;
-		case 0xf7: stb_ex(cpustate); break;
-		case 0xf8: eorb_ex(cpustate); break;
-		case 0xf9: adcb_ex(cpustate); break;
-		case 0xfa: orb_ex(cpustate); break;
-		case 0xfb: addb_ex(cpustate); break;
-		case 0xfc: ldd_ex(cpustate); /* 6803 only */ break;
-		case 0xfd: std_ex(cpustate); /* 6803 only */ break;
-		case 0xfe: ldx_ex(cpustate); break;
-		case 0xff: stx_ex(cpustate); break;
-	}
-}
-
-/****************************************************************************
- * Execute cycles CPU cycles. Return number of cycles really executed
- ****************************************************************************/
-static CPU_EXECUTE( m6803 )
-{
-	m6800_state *cpustate = get_safe_token(device);
-	UINT8 ireg;
-
-	CHECK_IRQ_LINES(cpustate); /* HJB 990417 */
-
-	CLEANUP_COUNTERS();
-
-	do
-	{
-		if( cpustate->wai_state & M6800_WAI )
-		{
-			EAT_CYCLES;
-		}
-		else
-		{
-			pPPC = pPC;
-			debugger_instruction_hook(device, PCD);
-			ireg=M_RDOP(PCD);
-			PC++;
-			m6803_execute_one(cpustate, ireg);
-			increment_counter(cpustate, cycles_6803[ireg]);
-		}
-	} while( cpustate->icount>0 );
-}
-
-
 static READ8_HANDLER( m6803_internal_registers_r );
 static WRITE8_HANDLER( m6803_internal_registers_w );
 
@@ -1677,6 +1119,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -1697,6 +1140,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -1707,303 +1151,6 @@
 	state_register(cpustate, "hd63701");
 }
 
-/****************************************************************************
- * Execute one instruction
- ****************************************************************************/
-
-INLINE void hd63071_execute_one(m6800_state *cpustate, UINT8 ireg)
-{
-	switch( ireg )
-	{
-		case 0x00: trap(cpustate); break;
-		case 0x01: nop(cpustate); break;
-		case 0x02: trap(cpustate); break;
-		case 0x03: trap(cpustate); break;
-		case 0x04: lsrd(cpustate); /* 6803 only */; break;
-		case 0x05: asld(cpustate); /* 6803 only */; break;
-		case 0x06: tap(cpustate); break;
-		case 0x07: tpa(cpustate); break;
-		case 0x08: inx(cpustate); break;
-		case 0x09: dex(cpustate); break;
-		case 0x0A: CLV; break;
-		case 0x0B: SEV; break;
-		case 0x0C: CLC; break;
-		case 0x0D: SEC; break;
-		case 0x0E: cli(cpustate); break;
-		case 0x0F: sei(cpustate); break;
-		case 0x10: sba(cpustate); break;
-		case 0x11: cba(cpustate); break;
-		case 0x12: undoc1(cpustate); break;
-		case 0x13: undoc2(cpustate); break;
-		case 0x14: trap(cpustate); break;
-		case 0x15: trap(cpustate); break;
-		case 0x16: tab(cpustate); break;
-		case 0x17: tba(cpustate); break;
-		case 0x18: xgdx(cpustate); /* HD63701YO only */; break;
-		case 0x19: daa(cpustate); break;
-		case 0x1a: slp(cpustate); break;
-		case 0x1b: aba(cpustate); break;
-		case 0x1c: trap(cpustate); break;
-		case 0x1d: trap(cpustate); break;
-		case 0x1e: trap(cpustate); break;
-		case 0x1f: trap(cpustate); break;
-		case 0x20: bra(cpustate); break;
-		case 0x21: brn(cpustate); break;
-		case 0x22: bhi(cpustate); break;
-		case 0x23: bls(cpustate); break;
-		case 0x24: bcc(cpustate); break;
-		case 0x25: bcs(cpustate); break;
-		case 0x26: bne(cpustate); break;
-		case 0x27: beq(cpustate); break;
-		case 0x28: bvc(cpustate); break;
-		case 0x29: bvs(cpustate); break;
-		case 0x2a: bpl(cpustate); break;
-		case 0x2b: bmi(cpustate); break;
-		case 0x2c: bge(cpustate); break;
-		case 0x2d: blt(cpustate); break;
-		case 0x2e: bgt(cpustate); break;
-		case 0x2f: ble(cpustate); break;
-		case 0x30: tsx(cpustate); break;
-		case 0x31: ins(cpustate); break;
-		case 0x32: pula(cpustate); break;
-		case 0x33: pulb(cpustate); break;
-		case 0x34: des(cpustate); break;
-		case 0x35: txs(cpustate); break;
-		case 0x36: psha(cpustate); break;
-		case 0x37: pshb(cpustate); break;
-		case 0x38: pulx(cpustate); /* 6803 only */ break;
-		case 0x39: rts(cpustate); break;
-		case 0x3a: abx(cpustate); /* 6803 only */ break;
-		case 0x3b: rti(cpustate); break;
-		case 0x3c: pshx(cpustate); /* 6803 only */ break;
-		case 0x3d: mul(cpustate); /* 6803 only */ break;
-		case 0x3e: wai(cpustate); break;
-		case 0x3f: swi(cpustate); break;
-		case 0x40: nega(cpustate); break;
-		case 0x41: trap(cpustate); break;
-		case 0x42: trap(cpustate); break;
-		case 0x43: coma(cpustate); break;
-		case 0x44: lsra(cpustate); break;
-		case 0x45: trap(cpustate); break;
-		case 0x46: rora(cpustate); break;
-		case 0x47: asra(cpustate); break;
-		case 0x48: asla(cpustate); break;
-		case 0x49: rola(cpustate); break;
-		case 0x4a: deca(cpustate); break;
-		case 0x4b: trap(cpustate); break;
-		case 0x4c: inca(cpustate); break;
-		case 0x4d: tsta(cpustate); break;
-		case 0x4e: trap(cpustate); break;
-		case 0x4f: clra(cpustate); break;
-		case 0x50: negb(cpustate); break;
-		case 0x51: trap(cpustate); break;
-		case 0x52: trap(cpustate); break;
-		case 0x53: comb(cpustate); break;
-		case 0x54: lsrb(cpustate); break;
-		case 0x55: trap(cpustate); break;
-		case 0x56: rorb(cpustate); break;
-		case 0x57: asrb(cpustate); break;
-		case 0x58: aslb(cpustate); break;
-		case 0x59: rolb(cpustate); break;
-		case 0x5a: decb(cpustate); break;
-		case 0x5b: trap(cpustate); break;
-		case 0x5c: incb(cpustate); break;
-		case 0x5d: tstb(cpustate); break;
-		case 0x5e: trap(cpustate); break;
-		case 0x5f: clrb(cpustate); break;
-		case 0x60: neg_ix(cpustate); break;
-		case 0x61: aim_ix(cpustate); /* HD63701YO only */; break;
-		case 0x62: oim_ix(cpustate); /* HD63701YO only */; break;
-		case 0x63: com_ix(cpustate); break;
-		case 0x64: lsr_ix(cpustate); break;
-		case 0x65: eim_ix(cpustate); /* HD63701YO only */; break;
-		case 0x66: ror_ix(cpustate); break;
-		case 0x67: asr_ix(cpustate); break;
-		case 0x68: asl_ix(cpustate); break;
-		case 0x69: rol_ix(cpustate); break;
-		case 0x6a: dec_ix(cpustate); break;
-		case 0x6b: tim_ix(cpustate); /* HD63701YO only */; break;
-		case 0x6c: inc_ix(cpustate); break;
-		case 0x6d: tst_ix(cpustate); break;
-		case 0x6e: jmp_ix(cpustate); break;
-		case 0x6f: clr_ix(cpustate); break;
-		case 0x70: neg_ex(cpustate); break;
-		case 0x71: aim_di(cpustate); /* HD63701YO only */; break;
-		case 0x72: oim_di(cpustate); /* HD63701YO only */; break;
-		case 0x73: com_ex(cpustate); break;
-		case 0x74: lsr_ex(cpustate); break;
-		case 0x75: eim_di(cpustate); /* HD63701YO only */; break;
-		case 0x76: ror_ex(cpustate); break;
-		case 0x77: asr_ex(cpustate); break;
-		case 0x78: asl_ex(cpustate); break;
-		case 0x79: rol_ex(cpustate); break;
-		case 0x7a: dec_ex(cpustate); break;
-		case 0x7b: tim_di(cpustate); /* HD63701YO only */; break;
-		case 0x7c: inc_ex(cpustate); break;
-		case 0x7d: tst_ex(cpustate); break;
-		case 0x7e: jmp_ex(cpustate); break;
-		case 0x7f: clr_ex(cpustate); break;
-		case 0x80: suba_im(cpustate); break;
-		case 0x81: cmpa_im(cpustate); break;
-		case 0x82: sbca_im(cpustate); break;
-		case 0x83: subd_im(cpustate); /* 6803 only */ break;
-		case 0x84: anda_im(cpustate); break;
-		case 0x85: bita_im(cpustate); break;
-		case 0x86: lda_im(cpustate); break;
-		case 0x87: sta_im(cpustate); break;
-		case 0x88: eora_im(cpustate); break;
-		case 0x89: adca_im(cpustate); break;
-		case 0x8a: ora_im(cpustate); break;
-		case 0x8b: adda_im(cpustate); break;
-		case 0x8c: cpx_im(cpustate); /* 6803 difference */ break;
-		case 0x8d: bsr(cpustate); break;
-		case 0x8e: lds_im(cpustate); break;
-		case 0x8f: sts_im(cpustate); /* orthogonality */ break;
-		case 0x90: suba_di(cpustate); break;
-		case 0x91: cmpa_di(cpustate); break;
-		case 0x92: sbca_di(cpustate); break;
-		case 0x93: subd_di(cpustate); /* 6803 only */ break;
-		case 0x94: anda_di(cpustate); break;
-		case 0x95: bita_di(cpustate); break;
-		case 0x96: lda_di(cpustate); break;
-		case 0x97: sta_di(cpustate); break;
-		case 0x98: eora_di(cpustate); break;
-		case 0x99: adca_di(cpustate); break;
-		case 0x9a: ora_di(cpustate); break;
-		case 0x9b: adda_di(cpustate); break;
-		case 0x9c: cpx_di(cpustate); /* 6803 difference */ break;
-		case 0x9d: jsr_di(cpustate); break;
-		case 0x9e: lds_di(cpustate); break;
-		case 0x9f: sts_di(cpustate); break;
-		case 0xa0: suba_ix(cpustate); break;
-		case 0xa1: cmpa_ix(cpustate); break;
-		case 0xa2: sbca_ix(cpustate); break;
-		case 0xa3: subd_ix(cpustate); /* 6803 only */ break;
-		case 0xa4: anda_ix(cpustate); break;
-		case 0xa5: bita_ix(cpustate); break;
-		case 0xa6: lda_ix(cpustate); break;
-		case 0xa7: sta_ix(cpustate); break;
-		case 0xa8: eora_ix(cpustate); break;
-		case 0xa9: adca_ix(cpustate); break;
-		case 0xaa: ora_ix(cpustate); break;
-		case 0xab: adda_ix(cpustate); break;
-		case 0xac: cpx_ix(cpustate); /* 6803 difference */ break;
-		case 0xad: jsr_ix(cpustate); break;
-		case 0xae: lds_ix(cpustate); break;
-		case 0xaf: sts_ix(cpustate); break;
-		case 0xb0: suba_ex(cpustate); break;
-		case 0xb1: cmpa_ex(cpustate); break;
-		case 0xb2: sbca_ex(cpustate); break;
-		case 0xb3: subd_ex(cpustate); /* 6803 only */ break;
-		case 0xb4: anda_ex(cpustate); break;
-		case 0xb5: bita_ex(cpustate); break;
-		case 0xb6: lda_ex(cpustate); break;
-		case 0xb7: sta_ex(cpustate); break;
-		case 0xb8: eora_ex(cpustate); break;
-		case 0xb9: adca_ex(cpustate); break;
-		case 0xba: ora_ex(cpustate); break;
-		case 0xbb: adda_ex(cpustate); break;
-		case 0xbc: cpx_ex(cpustate); /* 6803 difference */ break;
-		case 0xbd: jsr_ex(cpustate); break;
-		case 0xbe: lds_ex(cpustate); break;
-		case 0xbf: sts_ex(cpustate); break;
-		case 0xc0: subb_im(cpustate); break;
-		case 0xc1: cmpb_im(cpustate); break;
-		case 0xc2: sbcb_im(cpustate); break;
-		case 0xc3: addd_im(cpustate); /* 6803 only */ break;
-		case 0xc4: andb_im(cpustate); break;
-		case 0xc5: bitb_im(cpustate); break;
-		case 0xc6: ldb_im(cpustate); break;
-		case 0xc7: stb_im(cpustate); break;
-		case 0xc8: eorb_im(cpustate); break;
-		case 0xc9: adcb_im(cpustate); break;
-		case 0xca: orb_im(cpustate); break;
-		case 0xcb: addb_im(cpustate); break;
-		case 0xcc: ldd_im(cpustate); /* 6803 only */ break;
-		case 0xcd: std_im(cpustate); /* 6803 only -- orthogonality */ break;
-		case 0xce: ldx_im(cpustate); break;
-		case 0xcf: stx_im(cpustate); break;
-		case 0xd0: subb_di(cpustate); break;
-		case 0xd1: cmpb_di(cpustate); break;
-		case 0xd2: sbcb_di(cpustate); break;
-		case 0xd3: addd_di(cpustate); /* 6803 only */ break;
-		case 0xd4: andb_di(cpustate); break;
-		case 0xd5: bitb_di(cpustate); break;
-		case 0xd6: ldb_di(cpustate); break;
-		case 0xd7: stb_di(cpustate); break;
-		case 0xd8: eorb_di(cpustate); break;
-		case 0xd9: adcb_di(cpustate); break;
-		case 0xda: orb_di(cpustate); break;
-		case 0xdb: addb_di(cpustate); break;
-		case 0xdc: ldd_di(cpustate); /* 6803 only */ break;
-		case 0xdd: std_di(cpustate); /* 6803 only */ break;
-		case 0xde: ldx_di(cpustate); break;
-		case 0xdf: stx_di(cpustate); break;
-		case 0xe0: subb_ix(cpustate); break;
-		case 0xe1: cmpb_ix(cpustate); break;
-		case 0xe2: sbcb_ix(cpustate); break;
-		case 0xe3: addd_ix(cpustate); /* 6803 only */ break;
-		case 0xe4: andb_ix(cpustate); break;
-		case 0xe5: bitb_ix(cpustate); break;
-		case 0xe6: ldb_ix(cpustate); break;
-		case 0xe7: stb_ix(cpustate); break;
-		case 0xe8: eorb_ix(cpustate); break;
-		case 0xe9: adcb_ix(cpustate); break;
-		case 0xea: orb_ix(cpustate); break;
-		case 0xeb: addb_ix(cpustate); break;
-		case 0xec: ldd_ix(cpustate); /* 6803 only */ break;
-		case 0xed: std_ix(cpustate); /* 6803 only */ break;
-		case 0xee: ldx_ix(cpustate); break;
-		case 0xef: stx_ix(cpustate); break;
-		case 0xf0: subb_ex(cpustate); break;
-		case 0xf1: cmpb_ex(cpustate); break;
-		case 0xf2: sbcb_ex(cpustate); break;
-		case 0xf3: addd_ex(cpustate); /* 6803 only */ break;
-		case 0xf4: andb_ex(cpustate); break;
-		case 0xf5: bitb_ex(cpustate); break;
-		case 0xf6: ldb_ex(cpustate); break;
-		case 0xf7: stb_ex(cpustate); break;
-		case 0xf8: eorb_ex(cpustate); break;
-		case 0xf9: adcb_ex(cpustate); break;
-		case 0xfa: orb_ex(cpustate); break;
-		case 0xfb: addb_ex(cpustate); break;
-		case 0xfc: ldd_ex(cpustate); /* 6803 only */ break;
-		case 0xfd: std_ex(cpustate); /* 6803 only */ break;
-		case 0xfe: ldx_ex(cpustate); break;
-		case 0xff: stx_ex(cpustate); break;
-	}
-}
-
-/****************************************************************************
- * Execute cycles CPU cycles. Return number of cycles really executed
- ****************************************************************************/
-static CPU_EXECUTE( hd63701 )
-{
-	m6800_state *cpustate = get_safe_token(device);
-	UINT8 ireg;
-
-	CHECK_IRQ_LINES(cpustate); /* HJB 990417 */
-
-	CLEANUP_COUNTERS();
-
-	do
-	{
-		if( cpustate->wai_state & (M6800_WAI|M6800_SLP) )
-		{
-			EAT_CYCLES;
-		}
-		else
-		{
-			pPPC = pPC;
-			debugger_instruction_hook(device, PCD);
-			ireg=M_RDOP(PCD);
-			PC++;
-			hd63071_execute_one(cpustate, ireg);
-			increment_counter(cpustate, cycles_63701[ireg]);
-		}
-	} while( cpustate->icount>0 );
-}
-
 /*
     if change_pc(cpustate) direccted these areas ,Call hd63701_trap_pc(cpustate).
     'mode' is selected by the sense of p2.0,p2.1,and p2.3 at reset timming.
@@ -2042,6 +1189,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -2050,305 +1198,6 @@
 	state_register(cpustate, "nsc8105");
 }
 
-/****************************************************************************
- * Execute one instruction
- ****************************************************************************/
-
-INLINE void nsc8105_execute_one(m6800_state *cpustate, UINT8 ireg)
-{
-	switch( ireg )
-	{
-		case 0x00: illegal(cpustate); break;
-		case 0x01: illegal(cpustate); break;
-		case 0x02: nop(cpustate); break;
-		case 0x03: illegal(cpustate); break;
-		case 0x04: illegal(cpustate); break;
-		case 0x05: tap(cpustate); break;
-		case 0x06: illegal(cpustate); break;
-		case 0x07: tpa(cpustate); break;
-		case 0x08: inx(cpustate); break;
-		case 0x09: CLV; break;
-		case 0x0a: dex(cpustate); break;
-		case 0x0b: SEV; break;
-		case 0x0c: CLC; break;
-		case 0x0d: cli(cpustate); break;
-		case 0x0e: SEC; break;
-		case 0x0f: sei(cpustate); break;
-		case 0x10: sba(cpustate); break;
-		case 0x11: illegal(cpustate); break;
-		case 0x12: cba(cpustate); break;
-		case 0x13: illegal(cpustate); break;
-		case 0x14: illegal(cpustate); break;
-		case 0x15: tab(cpustate); break;
-		case 0x16: illegal(cpustate); break;
-		case 0x17: tba(cpustate); break;
-		case 0x18: illegal(cpustate); break;
-		case 0x19: illegal(cpustate); break;
-		case 0x1a: daa(cpustate); break;
-		case 0x1b: aba(cpustate); break;
-		case 0x1c: illegal(cpustate); break;
-		case 0x1d: illegal(cpustate); break;
-		case 0x1e: illegal(cpustate); break;
-		case 0x1f: illegal(cpustate); break;
-		case 0x20: bra(cpustate); break;
-		case 0x21: bhi(cpustate); break;
-		case 0x22: brn(cpustate); break;
-		case 0x23: bls(cpustate); break;
-		case 0x24: bcc(cpustate); break;
-		case 0x25: bne(cpustate); break;
-		case 0x26: bcs(cpustate); break;
-		case 0x27: beq(cpustate); break;
-		case 0x28: bvc(cpustate); break;
-		case 0x29: bpl(cpustate); break;
-		case 0x2a: bvs(cpustate); break;
-		case 0x2b: bmi(cpustate); break;
-		case 0x2c: bge(cpustate); break;
-		case 0x2d: bgt(cpustate); break;
-		case 0x2e: blt(cpustate); break;
-		case 0x2f: ble(cpustate); break;
-		case 0x30: tsx(cpustate); break;
-		case 0x31: pula(cpustate); break;
-		case 0x32: ins(cpustate); break;
-		case 0x33: pulb(cpustate); break;
-		case 0x34: des(cpustate); break;
-		case 0x35: psha(cpustate); break;
-		case 0x36: txs(cpustate); break;
-		case 0x37: pshb(cpustate); break;
-		case 0x38: illegal(cpustate); break;
-		case 0x39: illegal(cpustate); break;
-		case 0x3a: rts(cpustate); break;
-		case 0x3b: rti(cpustate); break;
-		case 0x3c: illegal(cpustate); break;
-		case 0x3d: wai(cpustate); break;
-		case 0x3e: illegal(cpustate); break;
-		case 0x3f: swi(cpustate); break;
-		case 0x40: suba_im(cpustate); break;
-		case 0x41: sbca_im(cpustate); break;
-		case 0x42: cmpa_im(cpustate); break;
-		case 0x43: illegal(cpustate); break;
-		case 0x44: anda_im(cpustate); break;
-		case 0x45: lda_im(cpustate); break;
-		case 0x46: bita_im(cpustate); break;
-		case 0x47: sta_im(cpustate); break;
-		case 0x48: eora_im(cpustate); break;
-		case 0x49: ora_im(cpustate); break;
-		case 0x4a: adca_im(cpustate); break;
-		case 0x4b: adda_im(cpustate); break;
-		case 0x4c: cmpx_im(cpustate); break;
-		case 0x4d: lds_im(cpustate); break;
-		case 0x4e: bsr(cpustate); break;
-		case 0x4f: sts_im(cpustate); /* orthogonality */ break;
-		case 0x50: suba_di(cpustate); break;
-		case 0x51: sbca_di(cpustate); break;
-		case 0x52: cmpa_di(cpustate); break;
-		case 0x53: illegal(cpustate); break;
-		case 0x54: anda_di(cpustate); break;
-		case 0x55: lda_di(cpustate); break;
-		case 0x56: bita_di(cpustate); break;
-		case 0x57: sta_di(cpustate); break;
-		case 0x58: eora_di(cpustate); break;
-		case 0x59: ora_di(cpustate); break;
-		case 0x5a: adca_di(cpustate); break;
-		case 0x5b: adda_di(cpustate); break;
-		case 0x5c: cmpx_di(cpustate); break;
-		case 0x5d: lds_di(cpustate); break;
-		case 0x5e: jsr_di(cpustate); break;
-		case 0x5f: sts_di(cpustate); break;
-		case 0x60: suba_ix(cpustate); break;
-		case 0x61: sbca_ix(cpustate); break;
-		case 0x62: cmpa_ix(cpustate); break;
-		case 0x63: illegal(cpustate); break;
-		case 0x64: anda_ix(cpustate); break;
-		case 0x65: lda_ix(cpustate); break;
-		case 0x66: bita_ix(cpustate); break;
-		case 0x67: sta_ix(cpustate); break;
-		case 0x68: eora_ix(cpustate); break;
-		case 0x69: ora_ix(cpustate); break;
-		case 0x6a: adca_ix(cpustate); break;
-		case 0x6b: adda_ix(cpustate); break;
-		case 0x6c: cmpx_ix(cpustate); break;
-		case 0x6d: lds_ix(cpustate); break;
-		case 0x6e: jsr_ix(cpustate); break;
-		case 0x6f: sts_ix(cpustate); break;
-		case 0x70: suba_ex(cpustate); break;
-		case 0x71: sbca_ex(cpustate); break;
-		case 0x72: cmpa_ex(cpustate); break;
-		case 0x73: illegal(cpustate); break;
-		case 0x74: anda_ex(cpustate); break;
-		case 0x75: lda_ex(cpustate); break;
-		case 0x76: bita_ex(cpustate); break;
-		case 0x77: sta_ex(cpustate); break;
-		case 0x78: eora_ex(cpustate); break;
-		case 0x79: ora_ex(cpustate); break;
-		case 0x7a: adca_ex(cpustate); break;
-		case 0x7b: adda_ex(cpustate); break;
-		case 0x7c: cmpx_ex(cpustate); break;
-		case 0x7d: lds_ex(cpustate); break;
-		case 0x7e: jsr_ex(cpustate); break;
-		case 0x7f: sts_ex(cpustate); break;
-		case 0x80: nega(cpustate); break;
-		case 0x81: illegal(cpustate); break;
-		case 0x82: illegal(cpustate); break;
-		case 0x83: coma(cpustate); break;
-		case 0x84: lsra(cpustate); break;
-		case 0x85: rora(cpustate); break;
-		case 0x86: illegal(cpustate); break;
-		case 0x87: asra(cpustate); break;
-		case 0x88: asla(cpustate); break;
-		case 0x89: deca(cpustate); break;
-		case 0x8a: rola(cpustate); break;
-		case 0x8b: illegal(cpustate); break;
-		case 0x8c: inca(cpustate); break;
-		case 0x8d: illegal(cpustate); break;
-		case 0x8e: tsta(cpustate); break;
-		case 0x8f: clra(cpustate); break;
-		case 0x90: negb(cpustate); break;
-		case 0x91: illegal(cpustate); break;
-		case 0x92: illegal(cpustate); break;
-		case 0x93: comb(cpustate); break;
-		case 0x94: lsrb(cpustate); break;
-		case 0x95: rorb(cpustate); break;
-		case 0x96: illegal(cpustate); break;
-		case 0x97: asrb(cpustate); break;
-		case 0x98: aslb(cpustate); break;
-		case 0x99: decb(cpustate); break;
-		case 0x9a: rolb(cpustate); break;
-		case 0x9b: illegal(cpustate); break;
-		case 0x9c: incb(cpustate); break;
-		case 0x9d: illegal(cpustate); break;
-		case 0x9e: tstb(cpustate); break;
-		case 0x9f: clrb(cpustate); break;
-		case 0xa0: neg_ix(cpustate); break;
-		case 0xa1: illegal(cpustate); break;
-		case 0xa2: illegal(cpustate); break;
-		case 0xa3: com_ix(cpustate); break;
-		case 0xa4: lsr_ix(cpustate); break;
-		case 0xa5: ror_ix(cpustate); break;
-		case 0xa6: illegal(cpustate); break;
-		case 0xa7: asr_ix(cpustate); break;
-		case 0xa8: asl_ix(cpustate); break;
-		case 0xa9: dec_ix(cpustate); break;
-		case 0xaa: rol_ix(cpustate); break;
-		case 0xab: illegal(cpustate); break;
-		case 0xac: inc_ix(cpustate); break;
-		case 0xad: jmp_ix(cpustate); break;
-		case 0xae: tst_ix(cpustate); break;
-		case 0xaf: clr_ix(cpustate); break;
-		case 0xb0: neg_ex(cpustate); break;
-		case 0xb1: illegal(cpustate); break;
-		case 0xb2: illegal(cpustate); break;
-		case 0xb3: com_ex(cpustate); break;
-		case 0xb4: lsr_ex(cpustate); break;
-		case 0xb5: ror_ex(cpustate); break;
-		case 0xb6: illegal(cpustate); break;
-		case 0xb7: asr_ex(cpustate); break;
-		case 0xb8: asl_ex(cpustate); break;
-		case 0xb9: dec_ex(cpustate); break;
-		case 0xba: rol_ex(cpustate); break;
-		case 0xbb: illegal(cpustate); break;
-		case 0xbc: inc_ex(cpustate); break;
-		case 0xbd: jmp_ex(cpustate); break;
-		case 0xbe: tst_ex(cpustate); break;
-		case 0xbf: clr_ex(cpustate); break;
-		case 0xc0: subb_im(cpustate); break;
-		case 0xc1: sbcb_im(cpustate); break;
-		case 0xc2: cmpb_im(cpustate); break;
-		case 0xc3: illegal(cpustate); break;
-		case 0xc4: andb_im(cpustate); break;
-		case 0xc5: ldb_im(cpustate); break;
-		case 0xc6: bitb_im(cpustate); break;
-		case 0xc7: stb_im(cpustate); break;
-		case 0xc8: eorb_im(cpustate); break;
-		case 0xc9: orb_im(cpustate); break;
-		case 0xca: adcb_im(cpustate); break;
-		case 0xcb: addb_im(cpustate); break;
-		case 0xcc: illegal(cpustate); break;
-		case 0xcd: ldx_im(cpustate); break;
-		case 0xce: illegal(cpustate); break;
-		case 0xcf: stx_im(cpustate); break;
-		case 0xd0: subb_di(cpustate); break;
-		case 0xd1: sbcb_di(cpustate); break;
-		case 0xd2: cmpb_di(cpustate); break;
-		case 0xd3: illegal(cpustate); break;
-		case 0xd4: andb_di(cpustate); break;
-		case 0xd5: ldb_di(cpustate); break;
-		case 0xd6: bitb_di(cpustate); break;
-		case 0xd7: stb_di(cpustate); break;
-		case 0xd8: eorb_di(cpustate); break;
-		case 0xd9: orb_di(cpustate); break;
-		case 0xda: adcb_di(cpustate); break;
-		case 0xdb: addb_di(cpustate); break;
-		case 0xdc: illegal(cpustate); break;
-		case 0xdd: ldx_di(cpustate); break;
-		case 0xde: illegal(cpustate); break;
-		case 0xdf: stx_di(cpustate); break;
-		case 0xe0: subb_ix(cpustate); break;
-		case 0xe1: sbcb_ix(cpustate); break;
-		case 0xe2: cmpb_ix(cpustate); break;
-		case 0xe3: illegal(cpustate); break;
-		case 0xe4: andb_ix(cpustate); break;
-		case 0xe5: ldb_ix(cpustate); break;
-		case 0xe6: bitb_ix(cpustate); break;
-		case 0xe7: stb_ix(cpustate); break;
-		case 0xe8: eorb_ix(cpustate); break;
-		case 0xe9: orb_ix(cpustate); break;
-		case 0xea: adcb_ix(cpustate); break;
-		case 0xeb: addb_ix(cpustate); break;
-		case 0xec: adcx_im(cpustate); break; /* NSC8105 only */
-		case 0xed: ldx_ix(cpustate); break;
-		case 0xee: illegal(cpustate); break;
-		case 0xef: stx_ix(cpustate); break;
-		case 0xf0: subb_ex(cpustate); break;
-		case 0xf1: sbcb_ex(cpustate); break;
-		case 0xf2: cmpb_ex(cpustate); break;
-		case 0xf3: illegal(cpustate); break;
-		case 0xf4: andb_ex(cpustate); break;
-		case 0xf5: ldb_ex(cpustate); break;
-		case 0xf6: bitb_ex(cpustate); break;
-		case 0xf7: stb_ex(cpustate); break;
-		case 0xf8: eorb_ex(cpustate); break;
-		case 0xf9: orb_ex(cpustate); break;
-		case 0xfa: adcb_ex(cpustate); break;
-		case 0xfb: addb_ex(cpustate); break;
-		case 0xfc: addx_ex(cpustate); break;
-		case 0xfd: ldx_ex(cpustate); break;
-		case 0xfe: illegal(cpustate); break;
-		case 0xff: stx_ex(cpustate); break;
-	}
-}
-
-/****************************************************************************
- * Execute cycles CPU cycles. Return number of cycles really executed
- ****************************************************************************/
-static CPU_EXECUTE( nsc8105 )
-{
-	m6800_state *cpustate = get_safe_token(device);
-	UINT8 ireg;
-
-	CHECK_IRQ_LINES(cpustate); /* HJB 990417 */
-
-	CLEANUP_COUNTERS();
-
-	do
-	{
-		if( cpustate->wai_state & M6800_WAI )
-		{
-			EAT_CYCLES;
-		}
-		else
-		{
-			pPPC = pPC;
-			debugger_instruction_hook(device, PCD);
-			ireg=M_RDOP(PCD);
-			PC++;
-			nsc8105_execute_one(cpustate, ireg);
-			increment_counter(cpustate, cycles_nsc8105[ireg]);
-		}
-	} while( cpustate->icount>0 );
-}
-
-
-
 static READ8_HANDLER( m6803_internal_registers_r )
 {
 	m6800_state *cpustate = get_safe_token(space->cpu);
@@ -2360,20 +1209,20 @@
 		case 0x01:
 			return cpustate->port2_ddr;
 		case 0x02:
-			return (memory_read_byte_8be(cpustate->io, M6803_PORT1) & (cpustate->port1_ddr ^ 0xff))
+			return (cpustate->io->read_byte(M6803_PORT1) & (cpustate->port1_ddr ^ 0xff))
 					| (cpustate->port1_data & cpustate->port1_ddr);
 		case 0x03:
-			return (memory_read_byte_8be(cpustate->io, M6803_PORT2) & (cpustate->port2_ddr ^ 0xff))
+			return (cpustate->io->read_byte(M6803_PORT2) & (cpustate->port2_ddr ^ 0xff))
 					| (cpustate->port2_data & cpustate->port2_ddr);
 		case 0x04:
 			return cpustate->port3_ddr;
 		case 0x05:
 			return cpustate->port4_ddr;
 		case 0x06:
-			return (memory_read_byte_8be(cpustate->io, M6803_PORT3) & (cpustate->port3_ddr ^ 0xff))
+			return (cpustate->io->read_byte(M6803_PORT3) & (cpustate->port3_ddr ^ 0xff))
 					| (cpustate->port3_data & cpustate->port3_ddr);
 		case 0x07:
-			return (memory_read_byte_8be(cpustate->io, M6803_PORT4) & (cpustate->port4_ddr ^ 0xff))
+			return (cpustate->io->read_byte(M6803_PORT4) & (cpustate->port4_ddr ^ 0xff))
 					| (cpustate->port4_data & cpustate->port4_ddr);
 		case 0x08:
 			cpustate->pending_tcsr = 0;
@@ -2458,10 +1307,10 @@
 			{
 				cpustate->port1_ddr = data;
 				if(cpustate->port1_ddr == 0xff)
-					memory_write_byte_8be(cpustate->io, M6803_PORT1,cpustate->port1_data);
+					cpustate->io->write_byte(M6803_PORT1,cpustate->port1_data);
 				else
-					memory_write_byte_8be(cpustate->io, M6803_PORT1,(cpustate->port1_data & cpustate->port1_ddr)
-						| (memory_read_byte_8be(cpustate->io, M6803_PORT1) & (cpustate->port1_ddr ^ 0xff)));
+					cpustate->io->write_byte(M6803_PORT1,(cpustate->port1_data & cpustate->port1_ddr)
+						| (cpustate->io->read_byte(M6803_PORT1) & (cpustate->port1_ddr ^ 0xff)));
 			}
 			break;
 		case 0x01:
@@ -2469,10 +1318,10 @@
 			{
 				cpustate->port2_ddr = data;
 				if(cpustate->port2_ddr == 0xff)
-					memory_write_byte_8be(cpustate->io, M6803_PORT2,cpustate->port2_data);
+					cpustate->io->write_byte(M6803_PORT2,cpustate->port2_data);
 				else
-					memory_write_byte_8be(cpustate->io, M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
-						| (memory_read_byte_8be(cpustate->io, M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
+					cpustate->io->write_byte(M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
+						| (cpustate->io->read_byte(M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
 
 				if (cpustate->port2_ddr & 2)
 					logerror("CPU '%s' PC %04x: warning - port 2 bit 1 set as output (OLVL) - not supported\n",space->cpu->tag(),cpu_get_pc(space->cpu));
@@ -2481,10 +1330,10 @@
 		case 0x02:
 			cpustate->port1_data = data;
 			if(cpustate->port1_ddr == 0xff)
-				memory_write_byte_8be(cpustate->io, M6803_PORT1,cpustate->port1_data);
+				cpustate->io->write_byte(M6803_PORT1,cpustate->port1_data);
 			else
-				memory_write_byte_8be(cpustate->io, M6803_PORT1,(cpustate->port1_data & cpustate->port1_ddr)
-					| (memory_read_byte_8be(cpustate->io, M6803_PORT1) & (cpustate->port1_ddr ^ 0xff)));
+				cpustate->io->write_byte(M6803_PORT1,(cpustate->port1_data & cpustate->port1_ddr)
+					| (cpustate->io->read_byte(M6803_PORT1) & (cpustate->port1_ddr ^ 0xff)));
 			break;
 		case 0x03:
 			if (cpustate->trcsr & M6800_TRCSR_TE)
@@ -2496,20 +1345,20 @@
 				cpustate->port2_data = data;
 			}
 			if(cpustate->port2_ddr == 0xff)
-				memory_write_byte_8be(cpustate->io, M6803_PORT2,cpustate->port2_data);
+				cpustate->io->write_byte(M6803_PORT2,cpustate->port2_data);
 			else
-				memory_write_byte_8be(cpustate->io, M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
-					| (memory_read_byte_8be(cpustate->io, M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
+				cpustate->io->write_byte(M6803_PORT2,(cpustate->port2_data & cpustate->port2_ddr)
+					| (cpustate->io->read_byte(M6803_PORT2) & (cpustate->port2_ddr ^ 0xff)));
 			break;
 		case 0x04:
 			if (cpustate->port3_ddr != data)
 			{
 				cpustate->port3_ddr = data;
 				if(cpustate->port3_ddr == 0xff)
-					memory_write_byte_8be(cpustate->io, M6803_PORT3,cpustate->port3_data);
+					cpustate->io->write_byte(M6803_PORT3,cpustate->port3_data);
 				else
-					memory_write_byte_8be(cpustate->io, M6803_PORT3,(cpustate->port3_data & cpustate->port3_ddr)
-						| (memory_read_byte_8be(cpustate->io, M6803_PORT3) & (cpustate->port3_ddr ^ 0xff)));
+					cpustate->io->write_byte(M6803_PORT3,(cpustate->port3_data & cpustate->port3_ddr)
+						| (cpustate->io->read_byte(M6803_PORT3) & (cpustate->port3_ddr ^ 0xff)));
 			}
 			break;
 		case 0x05:
@@ -2517,27 +1366,27 @@
 			{
 				cpustate->port4_ddr = data;
 				if(cpustate->port4_ddr == 0xff)
-					memory_write_byte_8be(cpustate->io, M6803_PORT4,cpustate->port4_data);
+					cpustate->io->write_byte(M6803_PORT4,cpustate->port4_data);
 				else
-					memory_write_byte_8be(cpustate->io, M6803_PORT4,(cpustate->port4_data & cpustate->port4_ddr)
-						| (memory_read_byte_8be(cpustate->io, M6803_PORT4) & (cpustate->port4_ddr ^ 0xff)));
+					cpustate->io->write_byte(M6803_PORT4,(cpustate->port4_data & cpustate->port4_ddr)
+						| (cpustate->io->read_byte(M6803_PORT4) & (cpustate->port4_ddr ^ 0xff)));
 			}
 			break;
 		case 0x06:
 			cpustate->port3_data = data;
 			if(cpustate->port3_ddr == 0xff)
-				memory_write_byte_8be(cpustate->io, M6803_PORT3,cpustate->port3_data);
+				cpustate->io->write_byte(M6803_PORT3,cpustate->port3_data);
 			else
-				memory_write_byte_8be(cpustate->io, M6803_PORT3,(cpustate->port3_data & cpustate->port3_ddr)
-					| (memory_read_byte_8be(cpustate->io, M6803_PORT3) & (cpustate->port3_ddr ^ 0xff)));
+				cpustate->io->write_byte(M6803_PORT3,(cpustate->port3_data & cpustate->port3_ddr)
+					| (cpustate->io->read_byte(M6803_PORT3) & (cpustate->port3_ddr ^ 0xff)));
 			break;
 		case 0x07:
 			cpustate->port4_data = data;
 			if(cpustate->port4_ddr == 0xff)
-				memory_write_byte_8be(cpustate->io, M6803_PORT4,cpustate->port4_data);
+				cpustate->io->write_byte(M6803_PORT4,cpustate->port4_data);
 			else
-				memory_write_byte_8be(cpustate->io, M6803_PORT4,(cpustate->port4_data & cpustate->port4_ddr)
-					| (memory_read_byte_8be(cpustate->io, M6803_PORT4) & (cpustate->port4_ddr ^ 0xff)));
+				cpustate->io->write_byte(M6803_PORT4,(cpustate->port4_data & cpustate->port4_ddr)
+					| (cpustate->io->read_byte(M6803_PORT4) & (cpustate->port4_ddr ^ 0xff)));
 			break;
 		case 0x08:
 			cpustate->tcsr = data;
@@ -2768,7 +1617,6 @@
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(m6801);				break;
-		case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(m6803);			break;
 		case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(m6801);			break;
 
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
@@ -2817,7 +1665,6 @@
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(m6803);				break;
-		case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(m6803);			break;
 		case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(m6803);			break;
 
 		case DEVINFO_PTR_INTERNAL_MEMORY_MAP + ADDRESS_SPACE_PROGRAM: info->internal_map8 = ADDRESS_MAP_NAME(m6803_mem); break;
@@ -2868,7 +1715,6 @@
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(hd63701);				break;
-		case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(hd63701);		break;
 		case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(hd63701);		break;
 
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
@@ -2892,7 +1738,6 @@
 
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case CPUINFO_FCT_INIT:							info->init = CPU_INIT_NAME(nsc8105);				break;
-		case CPUINFO_FCT_EXECUTE:						info->execute = CPU_EXECUTE_NAME(nsc8105);		break;
 		case CPUINFO_FCT_DISASSEMBLE:					info->disassemble = CPU_DISASSEMBLE_NAME(nsc8105);		break;
 
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
diff -Nru src-old/emu/cpu/m68000/m68kcpu.c src/emu/cpu/m68000/m68kcpu.c
--- src-old/emu/cpu/m68000/m68kcpu.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m68000/m68kcpu.c	2010-08-30 08:20:58.000000000 -0700
@@ -944,262 +944,203 @@
  * 8-bit data memory interface
  ****************************************************************************/
 
-static UINT16 m68008_read_immediate_16(const address_space *space, offs_t address)
+UINT16 m68k_memory_interface::m68008_read_immediate_16(offs_t address)
 {
-	offs_t addr = address;
-	return (memory_decrypted_read_byte(space, addr) << 8) | (memory_decrypted_read_byte(space, addr + 1));
+	return (m_direct->read_decrypted_byte(address) << 8) | (m_direct->read_decrypted_byte(address + 1));
 }
 
-/* interface for 20/22-bit address bus, 8-bit data bus (68008) */
-static const m68k_memory_interface interface_d8 =
+void m68k_memory_interface::init8(address_space &space)
 {
-	0,
-	m68008_read_immediate_16,
-	memory_read_byte_8be,
-	memory_read_word_8be,
-	memory_read_dword_8be,
-	memory_write_byte_8be,
-	memory_write_word_8be,
-	memory_write_dword_8be
-};
+	m_space = &space;
+	m_direct = &space.direct();
+	m_cpustate = get_safe_token(&space.device());
+	opcode_xor = 0;
 
-/****************************************************************************
- * 16-bit data memory interface
- ****************************************************************************/
-
-static UINT16 read_immediate_16(const address_space *space, offs_t address)
-{
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-	return memory_decrypted_read_word(space, (address) ^ m68k->memory.opcode_xor);
-}
-
-static UINT16 simple_read_immediate_16(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_word(space, address);
+	readimm16 = m68k_readimm16_delegate(m68k_readimm16_proto_delegate::create_member(m68k_memory_interface, m68008_read_immediate_16), *this);
+	read8 = m68k_read8_delegate(m68k_read8_proto_delegate::create_member(address_space, read_byte), space);
+	read16 = m68k_read16_delegate(m68k_read16_proto_delegate::create_member(address_space, read_word), space);
+	read32 = m68k_read32_delegate(m68k_read32_proto_delegate::create_member(address_space, read_dword), space);
+	write8 = m68k_write8_delegate(m68k_write8_proto_delegate::create_member(address_space, write_byte), space);
+	write16 = m68k_write16_delegate(m68k_write16_proto_delegate::create_member(address_space, write_word), space);
+	write32 = m68k_write32_delegate(m68k_write32_proto_delegate::create_member(address_space, write_dword), space);
 }
 
-/* interface for 24-bit address bus, 16-bit data bus (68000, 68010) */
-static const m68k_memory_interface interface_d16 =
-{
-	0,
-	simple_read_immediate_16,
-	memory_read_byte_16be,
-	memory_read_word_16be,
-	memory_read_dword_16be,
-	memory_write_byte_16be,
-	memory_write_word_16be,
-	memory_write_dword_16be
-};
-
 /****************************************************************************
- * 32-bit data memory interface
+ * 16-bit data memory interface
  ****************************************************************************/
 
-/* potentially misaligned 16-bit reads with a 32-bit data bus (and 24-bit address bus) */
-static UINT16 readword_d32(const address_space *space, offs_t address)
+UINT16 m68k_memory_interface::read_immediate_16(offs_t address)
 {
-	UINT16 result;
-
-	if (!(address & 1))
-		return memory_read_word_32be(space, address);
-	result = memory_read_byte_32be(space, address) << 8;
-	return result | memory_read_byte_32be(space, address + 1);
+	return m_direct->read_decrypted_word((address) ^ opcode_xor);
 }
 
-/* potentially misaligned 16-bit writes with a 32-bit data bus (and 24-bit address bus) */
-static void writeword_d32(const address_space *space, offs_t address, UINT16 data)
+UINT16 m68k_memory_interface::simple_read_immediate_16(offs_t address)
 {
-	if (!(address & 1))
-	{
-		memory_write_word_32be(space, address, data);
-		return;
-	}
-	memory_write_byte_32be(space, address, data >> 8);
-	memory_write_byte_32be(space, address + 1, data);
+	return m_direct->read_decrypted_word(address);
 }
 
-/* potentially misaligned 32-bit reads with a 32-bit data bus (and 24-bit address bus) */
-static UINT32 readlong_d32(const address_space *space, offs_t address)
+void m68k_memory_interface::init16(address_space &space)
 {
-	UINT32 result;
+	m_space = &space;
+	m_direct = &space.direct();
+	m_cpustate = get_safe_token(&space.device());
+	opcode_xor = 0;
 
-	if (!(address & 3))
-		return memory_read_dword_32be(space, address);
-	else if (!(address & 1))
-	{
-		result = memory_read_word_32be(space, address) << 16;
-		return result | memory_read_word_32be(space, address + 2);
-	}
-	result = memory_read_byte_32be(space, address) << 24;
-	result |= memory_read_word_32be(space, address + 1) << 8;
-	return result | memory_read_byte_32be(space, address + 3);
+	readimm16 = m68k_readimm16_delegate(m68k_readimm16_proto_delegate::create_member(m68k_memory_interface, simple_read_immediate_16), *this);
+	read8 = m68k_read8_delegate(m68k_read8_proto_delegate::create_member(address_space, read_byte), space);
+	read16 = m68k_read16_delegate(m68k_read16_proto_delegate::create_member(address_space, read_word), space);
+	read32 = m68k_read32_delegate(m68k_read32_proto_delegate::create_member(address_space, read_dword), space);
+	write8 = m68k_write8_delegate(m68k_write8_proto_delegate::create_member(address_space, write_byte), space);
+	write16 = m68k_write16_delegate(m68k_write16_proto_delegate::create_member(address_space, write_word), space);
+	write32 = m68k_write32_delegate(m68k_write32_proto_delegate::create_member(address_space, write_dword), space);
 }
 
-/* potentially misaligned 32-bit writes with a 32-bit data bus (and 24-bit address bus) */
-static void writelong_d32(const address_space *space, offs_t address, UINT32 data)
-{
-	if (!(address & 3))
-	{
-		memory_write_dword_32be(space, address, data);
-		return;
-	}
-	else if (!(address & 1))
-	{
-		memory_write_word_32be(space, address, data >> 16);
-		memory_write_word_32be(space, address + 2, data);
-		return;
-	}
-	memory_write_byte_32be(space, address, data >> 24);
-	memory_write_word_32be(space, address + 1, data >> 8);
-	memory_write_byte_32be(space, address + 3, data);
-}
+/****************************************************************************
+ * 32-bit data memory interface
+ ****************************************************************************/
 
 /* interface for 32-bit data bus (68EC020, 68020) */
-static const m68k_memory_interface interface_d32 =
+void m68k_memory_interface::init32(address_space &space)
 {
-	WORD_XOR_BE(0),
-	read_immediate_16,
-	memory_read_byte_32be,
-	readword_d32,
-	readlong_d32,
-	memory_write_byte_32be,
-	writeword_d32,
-	writelong_d32
-};
+	m_space = &space;
+	m_direct = &space.direct();
+	m_cpustate = get_safe_token(&space.device());
+	opcode_xor = WORD_XOR_BE(0);
+
+	readimm16 = m68k_readimm16_delegate(m68k_readimm16_proto_delegate::create_member(m68k_memory_interface, read_immediate_16), *this);
+	read8 = m68k_read8_delegate(m68k_read8_proto_delegate::create_member(address_space, read_byte), space);
+	read16 = m68k_read16_delegate(m68k_read16_proto_delegate::create_member(address_space, read_word_unaligned), space);
+	read32 = m68k_read32_delegate(m68k_read32_proto_delegate::create_member(address_space, read_dword_unaligned), space);
+	write8 = m68k_write8_delegate(m68k_write8_proto_delegate::create_member(address_space, write_byte), space);
+	write16 = m68k_write16_delegate(m68k_write16_proto_delegate::create_member(address_space, write_word_unaligned), space);
+	write32 = m68k_write32_delegate(m68k_write32_proto_delegate::create_member(address_space, write_dword_unaligned), space);
+}
 
 /* interface for 32-bit data bus with PMMU (68EC020, 68020) */
-static UINT8 read_byte_32_mmu(const address_space *space, offs_t address)
+UINT8 m68k_memory_interface::read_byte_32_mmu(offs_t address)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
-	return memory_read_byte_32be(space, address);
+	return m_space->read_byte(address);
 }
 
-static void write_byte_32_mmu(const address_space *space, offs_t address, UINT8 data)
+void m68k_memory_interface::write_byte_32_mmu(offs_t address, UINT8 data)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
-	memory_write_byte_32be(space, address, data);
+	m_space->write_byte(address, data);
 }
 
-static UINT16 read_immediate_16_mmu(const address_space *space, offs_t address)
+UINT16 m68k_memory_interface::read_immediate_16_mmu(offs_t address)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
-	return memory_decrypted_read_word(space, (address) ^ m68k->memory.opcode_xor);
+	return m_direct->read_decrypted_word((address) ^ m_cpustate->memory.opcode_xor);
 }
 
 /* potentially misaligned 16-bit reads with a 32-bit data bus (and 24-bit address bus) */
-static UINT16 readword_d32_mmu(const address_space *space, offs_t address)
+UINT16 m68k_memory_interface::readword_d32_mmu(offs_t address)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
 	UINT16 result;
 
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
 	if (!(address & 1))
-		return memory_read_word_32be(space, address);
-	result = memory_read_byte_32be(space, address) << 8;
-	return result | memory_read_byte_32be(space, address + 1);
+		return m_space->read_word(address);
+	result = m_space->read_byte(address) << 8;
+	return result | m_space->read_byte(address + 1);
 }
 
 /* potentially misaligned 16-bit writes with a 32-bit data bus (and 24-bit address bus) */
-static void writeword_d32_mmu(const address_space *space, offs_t address, UINT16 data)
+void m68k_memory_interface::writeword_d32_mmu(offs_t address, UINT16 data)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
 	if (!(address & 1))
 	{
-		memory_write_word_32be(space, address, data);
+		m_space->write_word(address, data);
 		return;
 	}
-	memory_write_byte_32be(space, address, data >> 8);
-	memory_write_byte_32be(space, address + 1, data);
+	m_space->write_byte(address, data >> 8);
+	m_space->write_byte(address + 1, data);
 }
 
 /* potentially misaligned 32-bit reads with a 32-bit data bus (and 24-bit address bus) */
-static UINT32 readlong_d32_mmu(const address_space *space, offs_t address)
+UINT32 m68k_memory_interface::readlong_d32_mmu(offs_t address)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
 	UINT32 result;
 
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
 	if (!(address & 3))
-		return memory_read_dword_32be(space, address);
+		return m_space->read_dword(address);
 	else if (!(address & 1))
 	{
-		result = memory_read_word_32be(space, address) << 16;
-		return result | memory_read_word_32be(space, address + 2);
+		result = m_space->read_word(address) << 16;
+		return result | m_space->read_word(address + 2);
 	}
-	result = memory_read_byte_32be(space, address) << 24;
-	result |= memory_read_word_32be(space, address + 1) << 8;
-	return result | memory_read_byte_32be(space, address + 3);
+	result = m_space->read_byte(address) << 24;
+	result |= m_space->read_word(address + 1) << 8;
+	return result | m_space->read_byte(address + 3);
 }
 
 /* potentially misaligned 32-bit writes with a 32-bit data bus (and 24-bit address bus) */
-static void writelong_d32_mmu(const address_space *space, offs_t address, UINT32 data)
+void m68k_memory_interface::writelong_d32_mmu(offs_t address, UINT32 data)
 {
-	m68ki_cpu_core *m68k = get_safe_token(space->cpu);
-
-	if (m68k->pmmu_enabled)
+	if (m_cpustate->pmmu_enabled)
 	{
-		address = pmmu_translate_addr(m68k, address);
+		address = pmmu_translate_addr(m_cpustate, address);
 	}
 
 	if (!(address & 3))
 	{
-		memory_write_dword_32be(space, address, data);
+		m_space->write_dword(address, data);
 		return;
 	}
 	else if (!(address & 1))
 	{
-		memory_write_word_32be(space, address, data >> 16);
-		memory_write_word_32be(space, address + 2, data);
+		m_space->write_word(address, data >> 16);
+		m_space->write_word(address + 2, data);
 		return;
 	}
-	memory_write_byte_32be(space, address, data >> 24);
-	memory_write_word_32be(space, address + 1, data >> 8);
-	memory_write_byte_32be(space, address + 3, data);
-}
-
-static const m68k_memory_interface interface_d32_mmu =
-{
-	WORD_XOR_BE(0),
-	read_immediate_16_mmu,
-	read_byte_32_mmu,
-	readword_d32_mmu,
-	readlong_d32_mmu,
-	write_byte_32_mmu,
-	writeword_d32_mmu,
-	writelong_d32_mmu
-};
+	m_space->write_byte(address, data >> 24);
+	m_space->write_word(address + 1, data >> 8);
+	m_space->write_byte(address + 3, data);
+}
+
+void m68k_memory_interface::init32mmu(address_space &space)
+{
+	m_space = &space;
+	m_direct = &space.direct();
+	m_cpustate = get_safe_token(&space.device());
+	opcode_xor = WORD_XOR_BE(0);
+
+	readimm16 = m68k_readimm16_delegate(m68k_readimm16_proto_delegate::create_member(m68k_memory_interface, read_immediate_16_mmu), *this);
+	read8 = m68k_read8_delegate(m68k_read8_proto_delegate::create_member(m68k_memory_interface, read_byte_32_mmu), *this);
+	read16 = m68k_read16_delegate(m68k_read16_proto_delegate::create_member(m68k_memory_interface, readword_d32_mmu), *this);
+	read32 = m68k_read32_delegate(m68k_read32_proto_delegate::create_member(m68k_memory_interface, readlong_d32_mmu), *this);
+	write8 = m68k_write8_delegate(m68k_write8_proto_delegate::create_member(m68k_memory_interface, write_byte_32_mmu), *this);
+	write16 = m68k_write16_delegate(m68k_write16_proto_delegate::create_member(m68k_memory_interface, writeword_d32_mmu), *this);
+	write32 = m68k_write32_delegate(m68k_write32_proto_delegate::create_member(m68k_memory_interface, writelong_d32_mmu), *this);
+}
 
 
 void m68k_set_reset_callback(running_device *device, m68k_reset_func callback)
@@ -1294,7 +1235,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_000;
 	m68k->dasm_type        = M68K_CPU_TYPE_68000;
-	m68k->memory           = interface_d16;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init16(*m68k->program);
 	m68k->sr_mask          = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[0];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[0];
@@ -1339,7 +1284,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_008;
 	m68k->dasm_type        = M68K_CPU_TYPE_68008;
-	m68k->memory           = interface_d8;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init8(*m68k->program);
 	m68k->sr_mask          = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[0];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[0];
@@ -1388,7 +1337,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_010;
 	m68k->dasm_type        = M68K_CPU_TYPE_68010;
-	m68k->memory           = interface_d16;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init16(*m68k->program);
 	m68k->sr_mask          = 0xa71f; /* T1 -- S  -- -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[1];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[1];
@@ -1433,7 +1386,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_020;
 	m68k->dasm_type        = M68K_CPU_TYPE_68020;
-	m68k->memory           = interface_d32;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[2];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[2];
@@ -1481,7 +1438,11 @@
 	CPU_INIT_CALL(m68020);
 
 	m68k->has_pmmu	       = 1;
-	m68k->memory           = interface_d32_mmu;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32mmu(*m68k->program);
 }
 
 CPU_GET_INFO( m68020pmmu )
@@ -1510,7 +1471,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_EC020;
 	m68k->dasm_type        = M68K_CPU_TYPE_68EC020;
-	m68k->memory           = interface_d32;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[2];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[2];
@@ -1557,7 +1522,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_030;
 	m68k->dasm_type        = M68K_CPU_TYPE_68030;
-	m68k->memory           = interface_d32_mmu;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32mmu(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[3];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[3];
@@ -1610,7 +1579,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_EC030;
 	m68k->dasm_type        = M68K_CPU_TYPE_68EC030;
-	m68k->memory           = interface_d32;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[3];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[3];
@@ -1654,7 +1627,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_040;
 	m68k->dasm_type        = M68K_CPU_TYPE_68040;
-	m68k->memory           = interface_d32_mmu;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32mmu(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[4];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[4];
@@ -1706,7 +1683,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_EC040;
 	m68k->dasm_type        = M68K_CPU_TYPE_68EC040;
-	m68k->memory           = interface_d32;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[4];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[4];
@@ -1750,7 +1731,11 @@
 
 	m68k->cpu_type         = CPU_TYPE_LC040;
 	m68k->dasm_type        = M68K_CPU_TYPE_68LC040;
-	m68k->memory           = interface_d32;
+// hack alert: we use placement new to ensure we are properly initialized
+// because we live in the device state which is allocated as bytes
+// remove me when we have a real C++ device
+	new(&m68k->memory) m68k_memory_interface;
+	m68k->memory.init32(*m68k->program);
 	m68k->sr_mask          = 0xf71f; /* T1 T0 S  M  -- I2 I1 I0 -- -- -- X  N  Z  V  C  */
 	m68k->cyc_instruction  = m68ki_cycles[4];
 	m68k->cyc_exception    = m68ki_exception_cycle_table[4];
diff -Nru src-old/emu/cpu/m68000/m68kcpu.h src/emu/cpu/m68000/m68kcpu.h
--- src-old/emu/cpu/m68000/m68kcpu.h	2010-06-16 20:33:24.000000000 -0700
+++ src/emu/cpu/m68000/m68kcpu.h	2010-08-21 11:40:01.000000000 -0700
@@ -535,17 +535,55 @@
 
 /* Redirect memory calls */
 
-typedef struct _m68k_memory_interface m68k_memory_interface;
-struct _m68k_memory_interface
-{
+typedef proto_delegate_1param<UINT8, offs_t> m68k_read8_proto_delegate;
+typedef proto_delegate_1param<UINT16, offs_t> m68k_readimm16_proto_delegate;
+typedef proto_delegate_1param<UINT16, offs_t> m68k_read16_proto_delegate;
+typedef proto_delegate_1param<UINT32, offs_t> m68k_read32_proto_delegate;
+typedef proto_delegate_2param<void, offs_t, UINT8> m68k_write8_proto_delegate;
+typedef proto_delegate_2param<void, offs_t, UINT16> m68k_write16_proto_delegate;
+typedef proto_delegate_2param<void, offs_t, UINT32> m68k_write32_proto_delegate;
+
+typedef delegate_1param<UINT8, offs_t> m68k_read8_delegate;
+typedef delegate_1param<UINT16, offs_t> m68k_readimm16_delegate;
+typedef delegate_1param<UINT16, offs_t> m68k_read16_delegate;
+typedef delegate_1param<UINT32, offs_t> m68k_read32_delegate;
+typedef delegate_2param<void, offs_t, UINT8> m68k_write8_delegate;
+typedef delegate_2param<void, offs_t, UINT16> m68k_write16_delegate;
+typedef delegate_2param<void, offs_t, UINT32> m68k_write32_delegate;
+
+class m68k_memory_interface : public bindable_object
+{
+public:
+	void init8(address_space &space);
+	void init16(address_space &space);
+	void init32(address_space &space);
+	void init32mmu(address_space &space);
+
 	offs_t	opcode_xor;						// Address Calculation
-	UINT16	(*readimm16)(const address_space *, offs_t);			// Immediate read 16 bit
-	UINT8	(*read8)(const address_space *, offs_t);				// Normal read 8 bit
-	UINT16	(*read16)(const address_space *, offs_t);				// Normal read 16 bit
-	UINT32	(*read32)(const address_space *, offs_t);				// Normal read 32 bit
-	void	(*write8)(const address_space *, offs_t, UINT8);		// Write 8 bit
-	void	(*write16)(const address_space *, offs_t, UINT16);		// Write 16 bit
-	void	(*write32)(const address_space *, offs_t, UINT32);		// Write 32 bit
+	m68k_readimm16_delegate readimm16;		// Immediate read 16 bit
+	m68k_read8_delegate read8;
+	m68k_read16_delegate read16;
+	m68k_read32_delegate read32;
+	m68k_write8_delegate write8;
+	m68k_write16_delegate write16;
+	m68k_write32_delegate write32;
+
+private:
+	UINT16 m68008_read_immediate_16(offs_t address);
+	UINT16 read_immediate_16(offs_t address);
+	UINT16 simple_read_immediate_16(offs_t address);
+
+	UINT8 read_byte_32_mmu(offs_t address);
+	void write_byte_32_mmu(offs_t address, UINT8 data);
+	UINT16 read_immediate_16_mmu(offs_t address);
+	UINT16 readword_d32_mmu(offs_t address);
+	void writeword_d32_mmu(offs_t address, UINT16 data);
+	UINT32 readlong_d32_mmu(offs_t address);
+	void writelong_d32_mmu(offs_t address, UINT32 data);
+
+	address_space *m_space;
+	direct_read_data *m_direct;
+	m68ki_cpu_core *m_cpustate;
 };
 
 struct _m68ki_cpu_core
@@ -628,7 +666,7 @@
 	m68k_tas_func tas_instr_callback;             /* Called when a TAS instruction is encountered, allows / disallows writeback */
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	m68k_memory_interface memory;
 	offs_t encrypted_start;
 	offs_t encrypted_end;
@@ -779,23 +817,23 @@
 
 INLINE unsigned int m68k_read_immediate_32(m68ki_cpu_core *m68k, unsigned int address)
 {
-	return ((*m68k->memory.readimm16)(m68k->program, address) << 16) | (*m68k->memory.readimm16)(m68k->program, address + 2);
+	return (m68k->memory.readimm16(address) << 16) | m68k->memory.readimm16(address + 2);
 }
 
 INLINE unsigned int m68k_read_pcrelative_8(m68ki_cpu_core *m68k, unsigned int address)
 {
 	if (address >= m68k->encrypted_start && address < m68k->encrypted_end)
-		return (((*m68k->memory.readimm16)(m68k->program, address&~1)>>(8*(1-(address & 1))))&0xff);
+		return ((m68k->memory.readimm16(address&~1)>>(8*(1-(address & 1))))&0xff);
 
-	return (*m68k->memory.read8)(m68k->program, address);
+	return m68k->memory.read8(address);
 }
 
 INLINE unsigned int m68k_read_pcrelative_16(m68ki_cpu_core *m68k, unsigned int address)
 {
 	if (address >= m68k->encrypted_start && address < m68k->encrypted_end)
-		return (*m68k->memory.readimm16)(m68k->program, address);
+		return m68k->memory.readimm16(address);
 
-	return (*m68k->memory.read16)(m68k->program, address);
+	return m68k->memory.read16(address);
 }
 
 INLINE unsigned int m68k_read_pcrelative_32(m68ki_cpu_core *m68k, unsigned int address)
@@ -803,7 +841,7 @@
 	if (address >= m68k->encrypted_start && address < m68k->encrypted_end)
 		return m68k_read_immediate_32(m68k, address);
 
-	return (*m68k->memory.read32)(m68k->program, address);
+	return m68k->memory.read32(address);
 }
 
 
@@ -814,8 +852,8 @@
  */
 INLINE void m68kx_write_memory_32_pd(m68ki_cpu_core *m68k, unsigned int address, unsigned int value)
 {
-	(m68k->memory.write16)(m68k->program, address+2, value>>16);
-	(m68k->memory.write16)(m68k->program, address, value&0xffff);
+	m68k->memory.write16(address+2, value>>16);
+	m68k->memory.write16(address, value&0xffff);
 }
 
 
@@ -833,12 +871,12 @@
 	if(REG_PC != m68k->pref_addr)
 	{
 		m68k->pref_addr = REG_PC;
-		m68k->pref_data = (*m68k->memory.readimm16)(m68k->program, m68k->pref_addr);
+		m68k->pref_data = m68k->memory.readimm16(m68k->pref_addr);
 	}
 	result = MASK_OUT_ABOVE_16(m68k->pref_data);
 	REG_PC += 2;
 	m68k->pref_addr = REG_PC;
-	m68k->pref_data = (*m68k->memory.readimm16)(m68k->program, m68k->pref_addr);
+	m68k->pref_data = m68k->memory.readimm16(m68k->pref_addr);
 	return result;
 }
 
@@ -851,17 +889,17 @@
 	if(REG_PC != m68k->pref_addr)
 	{
 		m68k->pref_addr = REG_PC;
-		m68k->pref_data = (*m68k->memory.readimm16)(m68k->program, m68k->pref_addr);
+		m68k->pref_data = m68k->memory.readimm16(m68k->pref_addr);
 	}
 	temp_val = MASK_OUT_ABOVE_16(m68k->pref_data);
 	REG_PC += 2;
 	m68k->pref_addr = REG_PC;
-	m68k->pref_data = (*m68k->memory.readimm16)(m68k->program, m68k->pref_addr);
+	m68k->pref_data = m68k->memory.readimm16(m68k->pref_addr);
 
 	temp_val = MASK_OUT_ABOVE_32((temp_val << 16) | MASK_OUT_ABOVE_16(m68k->pref_data));
 	REG_PC += 2;
 	m68k->pref_addr = REG_PC;
-	m68k->pref_data = (*m68k->memory.readimm16)(m68k->program, m68k->pref_addr);
+	m68k->pref_data = m68k->memory.readimm16(m68k->pref_addr);
 
 	return temp_val;
 }
@@ -878,7 +916,7 @@
  */
 INLINE UINT32 m68ki_read_8_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc)
 {
-	return (*m68k->memory.read8)(m68k->program, address);
+	return m68k->memory.read8(address);
 }
 INLINE UINT32 m68ki_read_16_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc)
 {
@@ -886,7 +924,7 @@
 	{
 		m68ki_check_address_error(m68k, address, MODE_READ, fc);
 	}
-	return (*m68k->memory.read16)(m68k->program, address);
+	return m68k->memory.read16(address);
 }
 INLINE UINT32 m68ki_read_32_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc)
 {
@@ -894,12 +932,12 @@
 	{
 		m68ki_check_address_error(m68k, address, MODE_READ, fc);
 	}
-	return (*m68k->memory.read32)(m68k->program, address);
+	return m68k->memory.read32(address);
 }
 
 INLINE void m68ki_write_8_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc, UINT32 value)
 {
-	(*m68k->memory.write8)(m68k->program, address, value);
+	m68k->memory.write8(address, value);
 }
 INLINE void m68ki_write_16_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc, UINT32 value)
 {
@@ -907,7 +945,7 @@
 	{
 		m68ki_check_address_error(m68k, address, MODE_WRITE, fc);
 	}
-	(*m68k->memory.write16)(m68k->program, address, value);
+	m68k->memory.write16(address, value);
 }
 INLINE void m68ki_write_32_fc(m68ki_cpu_core *m68k, UINT32 address, UINT32 fc, UINT32 value)
 {
@@ -915,7 +953,7 @@
 	{
 		m68ki_check_address_error(m68k, address, MODE_WRITE, fc);
 	}
-	(*m68k->memory.write32)(m68k->program, address, value);
+	m68k->memory.write32(address, value);
 }
 
 /* Special call to simulate undocumented 68k behavior when move.l with a
@@ -929,8 +967,8 @@
 	{
 		m68ki_check_address_error(m68k, address, MODE_WRITE, fc);
 	}
-	(*m68k->memory.write16)(m68k->program, address+2, value>>16);
-	(*m68k->memory.write16)(m68k->program, address, value&0xffff);
+	m68k->memory.write16(address+2, value>>16);
+	m68k->memory.write16(address, value&0xffff);
 }
 
 
@@ -1682,7 +1720,7 @@
      */
 	if(m68k->run_mode == RUN_MODE_BERR_AERR_RESET)
 	{
-		(*m68k->memory.read8)(m68k->program, 0x00ffff01);
+		m68k->memory.read8(0x00ffff01);
 		m68k->stopped = STOP_LEVEL_HALT;
 		return;
 	}
diff -Nru src-old/emu/cpu/m68000/m68kmmu.h src/emu/cpu/m68000/m68kmmu.h
--- src-old/emu/cpu/m68000/m68kmmu.h	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/m68000/m68kmmu.h	2010-08-19 01:27:05.000000000 -0700
@@ -53,7 +53,7 @@
 		case 2:	// valid 4 byte descriptors
 			tofs *= 4;
 //          logerror("PMMU: reading table A entry at %08x\n", tofs + (root_aptr & 0xfffffffc));
-			tbl_entry = memory_read_dword_32be(m68k->program, tofs + (root_aptr & 0xfffffffc));
+			tbl_entry = m68k->program->read_dword(tofs + (root_aptr & 0xfffffffc));
 			tamode = tbl_entry & 3;
 //          logerror("PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tamode, tofs);
 			break;
@@ -61,8 +61,8 @@
 		case 3: // valid 8 byte descriptors
 			tofs *= 8;
 //          logerror("PMMU: reading table A entries at %08x\n", tofs + (root_aptr & 0xfffffffc));
-			tbl_entry2 = memory_read_dword_32be(m68k->program, tofs + (root_aptr & 0xfffffffc));
-			tbl_entry = memory_read_dword_32be(m68k->program, tofs + (root_aptr & 0xfffffffc)+4);
+			tbl_entry2 = m68k->program->read_dword(tofs + (root_aptr & 0xfffffffc));
+			tbl_entry = m68k->program->read_dword(tofs + (root_aptr & 0xfffffffc)+4);
 			tamode = tbl_entry2 & 3;
 //          logerror("PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tamode, tofs);
 			break;
@@ -82,7 +82,7 @@
 		case 2: // 4-byte table B descriptor
 			tofs *= 4;
 //          logerror("PMMU: reading table B entry at %08x\n", tofs + tptr);
-			tbl_entry = memory_read_dword_32be(m68k->program, tofs + tptr);
+			tbl_entry = m68k->program->read_dword(tofs + tptr);
 			tbmode = tbl_entry & 3;
 //          logerror("PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tbmode, tofs);
 			break;
@@ -90,8 +90,8 @@
 		case 3: // 8-byte table B descriptor
 			tofs *= 8;
 //          logerror("PMMU: reading table B entries at %08x\n", tofs + tptr);
-			tbl_entry2 = memory_read_dword_32be(m68k->program, tofs + tptr);
-			tbl_entry = memory_read_dword_32be(m68k->program, tofs + tptr + 4);
+			tbl_entry2 = m68k->program->read_dword(tofs + tptr);
+			tbl_entry = m68k->program->read_dword(tofs + tptr + 4);
 			tbmode = tbl_entry2 & 3;
 //          logerror("PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tbmode, tofs);
 			break;
@@ -121,7 +121,7 @@
 			case 2: // 4-byte table C descriptor
 				tofs *= 4;
 //              logerror("PMMU: reading table C entry at %08x\n", tofs + tptr);
-				tbl_entry = memory_read_dword_32be(m68k->program, tofs + tptr);
+				tbl_entry = m68k->program->read_dword(tofs + tptr);
 				tcmode = tbl_entry & 3;
 //              logerror("PMMU: addr %08x entry %08x mode %x tofs %x\n", addr_in, tbl_entry, tbmode, tofs);
 				break;
@@ -129,8 +129,8 @@
 			case 3: // 8-byte table C descriptor
 				tofs *= 8;
 //              logerror("PMMU: reading table C entries at %08x\n", tofs + tptr);
-				tbl_entry2 = memory_read_dword_32be(m68k->program, tofs + tptr);
-				tbl_entry = memory_read_dword_32be(m68k->program, tofs + tptr + 4);
+				tbl_entry2 = m68k->program->read_dword(tofs + tptr);
+				tbl_entry = m68k->program->read_dword(tofs + tptr + 4);
 				tcmode = tbl_entry2 & 3;
 //              logerror("PMMU: addr %08x entry %08x entry2 %08x mode %x tofs %x\n", addr_in, tbl_entry, tbl_entry2, tbmode, tofs);
 				break;
diff -Nru src-old/emu/cpu/m6805/m6805.c src/emu/cpu/m6805/m6805.c
--- src-old/emu/cpu/m6805/m6805.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6805/m6805.c	2010-08-19 09:10:19.000000000 -0700
@@ -62,7 +62,8 @@
 	UINT16	pending_interrupts; /* MB */
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int 	irq_state[9];		/* KW Additional lines for HD63705 */
 	int		nmi_state;
 } m6805_Regs;
@@ -79,26 +80,26 @@
 /****************************************************************************/
 /* Read a byte from given memory location                                   */
 /****************************************************************************/
-#define M6805_RDMEM(Addr) ((unsigned)memory_read_byte_8be(cpustate->program, Addr))
+#define M6805_RDMEM(Addr) ((unsigned)cpustate->program->read_byte(Addr))
 
 /****************************************************************************/
 /* Write a byte to given memory location                                    */
 /****************************************************************************/
-#define M6805_WRMEM(Addr,Value) (memory_write_byte_8be(cpustate->program, Addr,Value))
+#define M6805_WRMEM(Addr,Value) (cpustate->program->write_byte(Addr,Value))
 
 /****************************************************************************/
 /* M6805_RDOP() is identical to M6805_RDMEM() except it is used for reading */
 /* opcodes. In case of system with memory mapped I/O, this function can be  */
 /* used to greatly speed up emulation                                       */
 /****************************************************************************/
-#define M6805_RDOP(Addr) ((unsigned)memory_decrypted_read_byte(cpustate->program, Addr))
+#define M6805_RDOP(Addr) ((unsigned)cpustate->direct->read_decrypted_byte(Addr))
 
 /****************************************************************************/
 /* M6805_RDOP_ARG() is identical to M6805_RDOP() but it's used for reading  */
 /* opcode arguments. This difference can be used to support systems that    */
 /* use different encoding mechanisms for opcodes and opcode arguments       */
 /****************************************************************************/
-#define M6805_RDOP_ARG(Addr) ((unsigned)memory_raw_read_byte(cpustate->program, Addr))
+#define M6805_RDOP_ARG(Addr) ((unsigned)cpustate->direct->read_raw_byte(Addr))
 
 #define SUBTYPE	cpustate->subtype	/* CPU Type */
 #define SP_MASK cpustate->sp_mask	/* stack pointer mask */
@@ -459,6 +460,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 }
 
 static CPU_RESET( m6805 )
@@ -472,6 +474,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* Force CPU sub-type and relevant masks */
 	cpustate->subtype = SUBTYPE_M6805;
diff -Nru src-old/emu/cpu/m6809/6809tbl.c src/emu/cpu/m6809/6809tbl.c
--- src-old/emu/cpu/m6809/6809tbl.c	2008-11-23 21:10:18.000000000 -0800
+++ src/emu/cpu/m6809/6809tbl.c	2010-08-27 02:12:49.000000000 -0700
@@ -360,7 +360,6 @@
   /*F*/  5, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6
 };
 
-#if (BIG_SWITCH==0)
 static void (*const m6809_main[0x100])(m68_state_t *) = {
 /*          0xX0,   0xX1,     0xX2,    0xX3,    0xX4,    0xX5,    0xX6,    0xX7,
             0xX8,   0xX9,     0xXA,    0xXB,    0xXC,    0xXD,    0xXE,    0xXF   */
@@ -413,4 +412,3 @@
 /* 0xFX */  subb_ex,cmpb_ex,sbcb_ex,addd_ex,andb_ex,bitb_ex,ldb_ex, stb_ex,
 	    eorb_ex,adcb_ex,orb_ex, addb_ex,ldd_ex, std_ex, ldu_ex, stu_ex
 };
-#endif
diff -Nru src-old/emu/cpu/m6809/m6809.c src/emu/cpu/m6809/m6809.c
--- src-old/emu/cpu/m6809/m6809.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/m6809/m6809.c	2010-08-30 08:20:58.000000000 -0700
@@ -74,11 +74,6 @@
 #include "debugger.h"
 #include "m6809.h"
 
-/* Enable big switch statement for the main opcodes */
-#ifndef BIG_SWITCH
-#define BIG_SWITCH  1
-#endif
-
 #define VERBOSE 0
 
 #define LOG(x)	do { if (VERBOSE) logerror x; } while (0)
@@ -105,7 +100,8 @@
 	PAIR	ea;			/* effective address */
 
 	/* Memory spaces */
-    const address_space *program;
+    address_space *program;
+    direct_read_data *direct;
 
 	UINT8	int_state;	/* SYNC and CWAI flags */
 	UINT8	nmi_state;
@@ -172,26 +168,26 @@
 /****************************************************************************/
 /* Read a byte from given memory location                                   */
 /****************************************************************************/
-#define RM(Addr) ((unsigned)memory_read_byte_8be(m68_state->program, Addr))
+#define RM(Addr) ((unsigned)m68_state->program->read_byte(Addr))
 
 /****************************************************************************/
 /* Write a byte to given memory location                                    */
 /****************************************************************************/
-#define WM(Addr,Value) (memory_write_byte_8be(m68_state->program, Addr,Value))
+#define WM(Addr,Value) (m68_state->program->write_byte(Addr,Value))
 
 /****************************************************************************/
 /* Z80_RDOP() is identical to Z80_RDMEM() except it is used for reading     */
 /* opcodes. In case of system with memory mapped I/O, this function can be  */
 /* used to greatly speed up emulation                                       */
 /****************************************************************************/
-#define ROP(Addr) ((unsigned)memory_decrypted_read_byte(m68_state->program, Addr))
+#define ROP(Addr) ((unsigned)m68_state->direct->read_decrypted_byte(Addr))
 
 /****************************************************************************/
 /* Z80_RDOP_ARG() is identical to Z80_RDOP() except it is used for reading  */
 /* opcode arguments. This difference can be used to support systems that    */
 /* use different encoding mechanisms for opcodes and opcode arguments       */
 /****************************************************************************/
-#define ROP_ARG(Addr) ((unsigned)memory_raw_read_byte(m68_state->program, Addr))
+#define ROP_ARG(Addr) ((unsigned)m68_state->direct->read_raw_byte(Addr))
 
 /* macros to access memory */
 #define IMMBYTE(b)	b = ROP_ARG(PCD); PC++
@@ -383,6 +379,7 @@
 	m68_state->device = device;
 
 	m68_state->program = device->space(AS_PROGRAM);
+	m68_state->direct = &m68_state->program->direct();
 
 	/* setup regtable */
 
@@ -506,270 +503,8 @@
 
 			m68_state->ireg = ROP(PCD);
 			PC++;
-#if BIG_SWITCH
-            switch( m68_state->ireg )
-			{
-			case 0x00: neg_di(m68_state);    break;
-			case 0x01: neg_di(m68_state);    break;	/* undocumented */
-			case 0x02: IIError(m68_state);   break;
-			case 0x03: com_di(m68_state);    break;
-			case 0x04: lsr_di(m68_state);    break;
-			case 0x05: IIError(m68_state);   break;
-			case 0x06: ror_di(m68_state);    break;
-			case 0x07: asr_di(m68_state);    break;
-			case 0x08: asl_di(m68_state);    break;
-			case 0x09: rol_di(m68_state);    break;
-			case 0x0a: dec_di(m68_state);    break;
-			case 0x0b: IIError(m68_state);   break;
-			case 0x0c: inc_di(m68_state);    break;
-			case 0x0d: tst_di(m68_state);    break;
-			case 0x0e: jmp_di(m68_state);    break;
-			case 0x0f: clr_di(m68_state);    break;
-			case 0x10: pref10(m68_state);					 break;
-			case 0x11: pref11(m68_state);					 break;
-			case 0x12: nop(m68_state);	    break;
-			case 0x13: sync(m68_state);	    break;
-			case 0x14: IIError(m68_state);   break;
-			case 0x15: IIError(m68_state);   break;
-			case 0x16: lbra(m68_state);	    break;
-			case 0x17: lbsr(m68_state);	    break;
-			case 0x18: IIError(m68_state);   break;
-			case 0x19: daa(m68_state);	    break;
-			case 0x1a: orcc(m68_state);	    break;
-			case 0x1b: IIError(m68_state);   break;
-			case 0x1c: andcc(m68_state);     break;
-			case 0x1d: sex(m68_state);	    break;
-			case 0x1e: exg(m68_state);	    break;
-			case 0x1f: tfr(m68_state);	    break;
-			case 0x20: bra(m68_state);	    break;
-			case 0x21: brn(m68_state);	    break;
-			case 0x22: bhi(m68_state);	    break;
-			case 0x23: bls(m68_state);	    break;
-			case 0x24: bcc(m68_state);	    break;
-			case 0x25: bcs(m68_state);	    break;
-			case 0x26: bne(m68_state);	    break;
-			case 0x27: beq(m68_state);	    break;
-			case 0x28: bvc(m68_state);	    break;
-			case 0x29: bvs(m68_state);	    break;
-			case 0x2a: bpl(m68_state);	    break;
-			case 0x2b: bmi(m68_state);	    break;
-			case 0x2c: bge(m68_state);	    break;
-			case 0x2d: blt(m68_state);	    break;
-			case 0x2e: bgt(m68_state);	    break;
-			case 0x2f: ble(m68_state);	    break;
-			case 0x30: leax(m68_state);	    break;
-			case 0x31: leay(m68_state);	    break;
-			case 0x32: leas(m68_state);	    break;
-			case 0x33: leau(m68_state);	    break;
-			case 0x34: pshs(m68_state);	    break;
-			case 0x35: puls(m68_state);	    break;
-			case 0x36: pshu(m68_state);	    break;
-			case 0x37: pulu(m68_state);	    break;
-			case 0x38: IIError(m68_state);   break;
-			case 0x39: rts(m68_state);	    break;
-			case 0x3a: abx(m68_state);	    break;
-			case 0x3b: rti(m68_state);	    break;
-			case 0x3c: cwai(m68_state);	    break;
-			case 0x3d: mul(m68_state);	    break;
-			case 0x3e: IIError(m68_state);   break;
-			case 0x3f: swi(m68_state);	    break;
-			case 0x40: nega(m68_state);	    break;
-			case 0x41: IIError(m68_state);   break;
-			case 0x42: IIError(m68_state);   break;
-			case 0x43: coma(m68_state);	    break;
-			case 0x44: lsra(m68_state);	    break;
-			case 0x45: IIError(m68_state);   break;
-			case 0x46: rora(m68_state);	    break;
-			case 0x47: asra(m68_state);	    break;
-			case 0x48: asla(m68_state);	    break;
-			case 0x49: rola(m68_state);	    break;
-			case 0x4a: deca(m68_state);	    break;
-			case 0x4b: IIError(m68_state);   break;
-			case 0x4c: inca(m68_state);	    break;
-			case 0x4d: tsta(m68_state);	    break;
-			case 0x4e: IIError(m68_state);   break;
-			case 0x4f: clra(m68_state);	    break;
-			case 0x50: negb(m68_state);	    break;
-			case 0x51: IIError(m68_state);   break;
-			case 0x52: IIError(m68_state);   break;
-			case 0x53: comb(m68_state);	    break;
-			case 0x54: lsrb(m68_state);	    break;
-			case 0x55: IIError(m68_state);   break;
-			case 0x56: rorb(m68_state);	    break;
-			case 0x57: asrb(m68_state);	    break;
-			case 0x58: aslb(m68_state);	    break;
-			case 0x59: rolb(m68_state);	    break;
-			case 0x5a: decb(m68_state);	    break;
-			case 0x5b: IIError(m68_state);   break;
-			case 0x5c: incb(m68_state);	    break;
-			case 0x5d: tstb(m68_state);	    break;
-			case 0x5e: IIError(m68_state);   break;
-			case 0x5f: clrb(m68_state);	    break;
-			case 0x60: neg_ix(m68_state);    break;
-			case 0x61: IIError(m68_state);   break;
-			case 0x62: IIError(m68_state);   break;
-			case 0x63: com_ix(m68_state);    break;
-			case 0x64: lsr_ix(m68_state);    break;
-			case 0x65: IIError(m68_state);   break;
-			case 0x66: ror_ix(m68_state);    break;
-			case 0x67: asr_ix(m68_state);    break;
-			case 0x68: asl_ix(m68_state);    break;
-			case 0x69: rol_ix(m68_state);    break;
-			case 0x6a: dec_ix(m68_state);    break;
-			case 0x6b: IIError(m68_state);   break;
-			case 0x6c: inc_ix(m68_state);    break;
-			case 0x6d: tst_ix(m68_state);    break;
-			case 0x6e: jmp_ix(m68_state);    break;
-			case 0x6f: clr_ix(m68_state);    break;
-			case 0x70: neg_ex(m68_state);    break;
-			case 0x71: IIError(m68_state);   break;
-			case 0x72: IIError(m68_state);   break;
-			case 0x73: com_ex(m68_state);    break;
-			case 0x74: lsr_ex(m68_state);    break;
-			case 0x75: IIError(m68_state);   break;
-			case 0x76: ror_ex(m68_state);    break;
-			case 0x77: asr_ex(m68_state);    break;
-			case 0x78: asl_ex(m68_state);    break;
-			case 0x79: rol_ex(m68_state);    break;
-			case 0x7a: dec_ex(m68_state);    break;
-			case 0x7b: IIError(m68_state);   break;
-			case 0x7c: inc_ex(m68_state);    break;
-			case 0x7d: tst_ex(m68_state);    break;
-			case 0x7e: jmp_ex(m68_state);    break;
-			case 0x7f: clr_ex(m68_state);    break;
-			case 0x80: suba_im(m68_state);   break;
-			case 0x81: cmpa_im(m68_state);   break;
-			case 0x82: sbca_im(m68_state);   break;
-			case 0x83: subd_im(m68_state);   break;
-			case 0x84: anda_im(m68_state);   break;
-			case 0x85: bita_im(m68_state);   break;
-			case 0x86: lda_im(m68_state);    break;
-			case 0x87: sta_im(m68_state);    break;
-			case 0x88: eora_im(m68_state);   break;
-			case 0x89: adca_im(m68_state);   break;
-			case 0x8a: ora_im(m68_state);    break;
-			case 0x8b: adda_im(m68_state);   break;
-			case 0x8c: cmpx_im(m68_state);   break;
-			case 0x8d: bsr(m68_state);	    break;
-			case 0x8e: ldx_im(m68_state);    break;
-			case 0x8f: stx_im(m68_state);    break;
-			case 0x90: suba_di(m68_state);   break;
-			case 0x91: cmpa_di(m68_state);   break;
-			case 0x92: sbca_di(m68_state);   break;
-			case 0x93: subd_di(m68_state);   break;
-			case 0x94: anda_di(m68_state);   break;
-			case 0x95: bita_di(m68_state);   break;
-			case 0x96: lda_di(m68_state);    break;
-			case 0x97: sta_di(m68_state);    break;
-			case 0x98: eora_di(m68_state);   break;
-			case 0x99: adca_di(m68_state);   break;
-			case 0x9a: ora_di(m68_state);    break;
-			case 0x9b: adda_di(m68_state);   break;
-			case 0x9c: cmpx_di(m68_state);   break;
-			case 0x9d: jsr_di(m68_state);    break;
-			case 0x9e: ldx_di(m68_state);    break;
-			case 0x9f: stx_di(m68_state);    break;
-			case 0xa0: suba_ix(m68_state);   break;
-			case 0xa1: cmpa_ix(m68_state);   break;
-			case 0xa2: sbca_ix(m68_state);   break;
-			case 0xa3: subd_ix(m68_state);   break;
-			case 0xa4: anda_ix(m68_state);   break;
-			case 0xa5: bita_ix(m68_state);   break;
-			case 0xa6: lda_ix(m68_state);    break;
-			case 0xa7: sta_ix(m68_state);    break;
-			case 0xa8: eora_ix(m68_state);   break;
-			case 0xa9: adca_ix(m68_state);   break;
-			case 0xaa: ora_ix(m68_state);    break;
-			case 0xab: adda_ix(m68_state);   break;
-			case 0xac: cmpx_ix(m68_state);   break;
-			case 0xad: jsr_ix(m68_state);    break;
-			case 0xae: ldx_ix(m68_state);    break;
-			case 0xaf: stx_ix(m68_state);    break;
-			case 0xb0: suba_ex(m68_state);   break;
-			case 0xb1: cmpa_ex(m68_state);   break;
-			case 0xb2: sbca_ex(m68_state);   break;
-			case 0xb3: subd_ex(m68_state);   break;
-			case 0xb4: anda_ex(m68_state);   break;
-			case 0xb5: bita_ex(m68_state);   break;
-			case 0xb6: lda_ex(m68_state);    break;
-			case 0xb7: sta_ex(m68_state);    break;
-			case 0xb8: eora_ex(m68_state);   break;
-			case 0xb9: adca_ex(m68_state);   break;
-			case 0xba: ora_ex(m68_state);    break;
-			case 0xbb: adda_ex(m68_state);   break;
-			case 0xbc: cmpx_ex(m68_state);   break;
-			case 0xbd: jsr_ex(m68_state);    break;
-			case 0xbe: ldx_ex(m68_state);    break;
-			case 0xbf: stx_ex(m68_state);    break;
-			case 0xc0: subb_im(m68_state);   break;
-			case 0xc1: cmpb_im(m68_state);   break;
-			case 0xc2: sbcb_im(m68_state);   break;
-			case 0xc3: addd_im(m68_state);   break;
-			case 0xc4: andb_im(m68_state);   break;
-			case 0xc5: bitb_im(m68_state);   break;
-			case 0xc6: ldb_im(m68_state);    break;
-			case 0xc7: stb_im(m68_state);    break;
-			case 0xc8: eorb_im(m68_state);   break;
-			case 0xc9: adcb_im(m68_state);   break;
-			case 0xca: orb_im(m68_state);    break;
-			case 0xcb: addb_im(m68_state);   break;
-			case 0xcc: ldd_im(m68_state);    break;
-			case 0xcd: std_im(m68_state);    break;
-			case 0xce: ldu_im(m68_state);    break;
-			case 0xcf: stu_im(m68_state);    break;
-			case 0xd0: subb_di(m68_state);   break;
-			case 0xd1: cmpb_di(m68_state);   break;
-			case 0xd2: sbcb_di(m68_state);   break;
-			case 0xd3: addd_di(m68_state);   break;
-			case 0xd4: andb_di(m68_state);   break;
-			case 0xd5: bitb_di(m68_state);   break;
-			case 0xd6: ldb_di(m68_state);    break;
-			case 0xd7: stb_di(m68_state);    break;
-			case 0xd8: eorb_di(m68_state);   break;
-			case 0xd9: adcb_di(m68_state);   break;
-			case 0xda: orb_di(m68_state);    break;
-			case 0xdb: addb_di(m68_state);   break;
-			case 0xdc: ldd_di(m68_state);    break;
-			case 0xdd: std_di(m68_state);    break;
-			case 0xde: ldu_di(m68_state);    break;
-			case 0xdf: stu_di(m68_state);    break;
-			case 0xe0: subb_ix(m68_state);   break;
-			case 0xe1: cmpb_ix(m68_state);   break;
-			case 0xe2: sbcb_ix(m68_state);   break;
-			case 0xe3: addd_ix(m68_state);   break;
-			case 0xe4: andb_ix(m68_state);   break;
-			case 0xe5: bitb_ix(m68_state);   break;
-			case 0xe6: ldb_ix(m68_state);    break;
-			case 0xe7: stb_ix(m68_state);    break;
-			case 0xe8: eorb_ix(m68_state);   break;
-			case 0xe9: adcb_ix(m68_state);   break;
-			case 0xea: orb_ix(m68_state);    break;
-			case 0xeb: addb_ix(m68_state);   break;
-			case 0xec: ldd_ix(m68_state);    break;
-			case 0xed: std_ix(m68_state);    break;
-			case 0xee: ldu_ix(m68_state);    break;
-			case 0xef: stu_ix(m68_state);    break;
-			case 0xf0: subb_ex(m68_state);   break;
-			case 0xf1: cmpb_ex(m68_state);   break;
-			case 0xf2: sbcb_ex(m68_state);   break;
-			case 0xf3: addd_ex(m68_state);   break;
-			case 0xf4: andb_ex(m68_state);   break;
-			case 0xf5: bitb_ex(m68_state);   break;
-			case 0xf6: ldb_ex(m68_state);    break;
-			case 0xf7: stb_ex(m68_state);    break;
-			case 0xf8: eorb_ex(m68_state);   break;
-			case 0xf9: adcb_ex(m68_state);   break;
-			case 0xfa: orb_ex(m68_state);    break;
-			case 0xfb: addb_ex(m68_state);   break;
-			case 0xfc: ldd_ex(m68_state);    break;
-			case 0xfd: std_ex(m68_state);    break;
-			case 0xfe: ldu_ex(m68_state);    break;
-			case 0xff: stu_ex(m68_state);    break;
-			}
-#else
-            		(*m6809_main[m68_state->ireg])(m68_state);
-#endif    /* BIG_SWITCH */
-        		m68_state->icount -= cycles1[m68_state->ireg];
+        	(*m6809_main[m68_state->ireg])(m68_state);
+			m68_state->icount -= cycles1[m68_state->ireg];
 
 		} while( m68_state->icount > 0 );
 
diff -Nru src-old/emu/cpu/mb86233/mb86233.c src/emu/cpu/mb86233/mb86233.c
--- src-old/emu/cpu/mb86233/mb86233.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mb86233/mb86233.c	2010-08-19 09:10:19.000000000 -0700
@@ -51,7 +51,8 @@
 	UINT32			extport[0x30];
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 
 	/* FIFO */
@@ -95,9 +96,9 @@
 #define ALU(cs,a)			mb86233_alu(cs,a)
 #define GETREPCNT()			cpustate->repcnt
 
-#define ROPCODE(a)			memory_decrypted_read_dword(cpustate->program, a<<2)
-#define RDMEM(a)			memory_read_dword_32le(cpustate->program, (a<<2))
-#define WRMEM(a,v)			memory_write_dword_32le(cpustate->program, (a<<2), v)
+#define ROPCODE(a)			cpustate->direct->read_decrypted_dword(a<<2)
+#define RDMEM(a)			cpustate->program->read_dword((a<<2))
+#define WRMEM(a,v)			cpustate->program->write_dword((a<<2), v)
 
 /***************************************************************************
     Initialization and Shutdown
@@ -112,6 +113,7 @@
 	memset(cpustate, 0, sizeof( *cpustate ) );
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	if ( _config )
 	{
diff -Nru src-old/emu/cpu/mb88xx/mb88xx.c src/emu/cpu/mb88xx/mb88xx.c
--- src-old/emu/cpu/mb88xx/mb88xx.c	2010-07-15 03:53:29.000000000 -0700
+++ src/emu/cpu/mb88xx/mb88xx.c	2010-08-19 09:10:19.000000000 -0700
@@ -75,9 +75,10 @@
     UINT8 pending_interrupt;
     device_irq_callback irqcallback;
     legacy_cpu_device *device;
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
     int icount;
 };
 
@@ -98,13 +99,13 @@
     MACROS
 ***************************************************************************/
 
-#define READOP(a)			(memory_decrypted_read_byte(cpustate->program, a))
+#define READOP(a)			(cpustate->direct->read_decrypted_byte(a))
 
-#define RDMEM(a)			(memory_read_byte_8be(cpustate->data, a))
-#define WRMEM(a,v)			(memory_write_byte_8be(cpustate->data, (a), (v)))
+#define RDMEM(a)			(cpustate->data->read_byte(a))
+#define WRMEM(a,v)			(cpustate->data->write_byte((a), (v)))
 
-#define READPORT(a)			(memory_read_byte_8be(cpustate->io, a))
-#define WRITEPORT(a,v)		(memory_write_byte_8be(cpustate->io, (a), (v)))
+#define READPORT(a)			(cpustate->io->read_byte(a))
+#define WRITEPORT(a,v)		(cpustate->io->write_byte((a), (v)))
 
 #define TEST_ST()			(cpustate->st & 1)
 #define TEST_ZF()			(cpustate->zf & 1)
@@ -144,6 +145,7 @@
 	cpustate->irqcallback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/mc68hc11/mc68hc11.c src/emu/cpu/mc68hc11/mc68hc11.c
--- src-old/emu/cpu/mc68hc11/mc68hc11.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mc68hc11/mc68hc11.c	2010-08-19 09:10:19.000000000 -0700
@@ -62,8 +62,9 @@
 	device_irq_callback irq_callback;
 	UINT8 irq_state[2];
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	direct_read_data *direct;
+	address_space *program;
+	address_space *io;
 	int icount;
 
 	int ram_position;
@@ -97,21 +98,21 @@
 	switch(reg)
 	{
 		case 0x00:		/* PORTA */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTA);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTA);
 		case 0x01:		/* DDRA */
 			return 0;
 		case 0x02:		/* PIOC */
 			return 0;
 		case 0x03:		/* PORTC */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTC);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTC);
 		case 0x04:		/* PORTB */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTB);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTB);
 		case 0x08:		/* PORTD */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTD);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTD);
 		case 0x09:		/* DDRD */
 			return 0;
 		case 0x0a:		/* PORTE */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTE);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTE);
 		case 0x23:
 			return cpustate->tflg1;
 		case 0x28:		/* SPCR1 */
@@ -122,44 +123,44 @@
 		{
 			if (cpustate->adctl & 0x10)
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x4) + MC68HC11_IO_AD0);
+				return cpustate->io->read_byte((cpustate->adctl & 0x4) + MC68HC11_IO_AD0);
 			}
 			else
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
+				return cpustate->io->read_byte((cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
 			}
 		}
 		case 0x32:		/* ADR2 */
 		{
 			if (cpustate->adctl & 0x10)
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x4) + MC68HC11_IO_AD1);
+				return cpustate->io->read_byte((cpustate->adctl & 0x4) + MC68HC11_IO_AD1);
 			}
 			else
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
+				return cpustate->io->read_byte((cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
 			}
 		}
 		case 0x33:		/* ADR3 */
 		{
 			if (cpustate->adctl & 0x10)
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x4) + MC68HC11_IO_AD2);
+				return cpustate->io->read_byte((cpustate->adctl & 0x4) + MC68HC11_IO_AD2);
 			}
 			else
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
+				return cpustate->io->read_byte((cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
 			}
 		}
 		case 0x34:		/* ADR4 */
 		{
 			if (cpustate->adctl & 0x10)
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x4) + MC68HC11_IO_AD3);
+				return cpustate->io->read_byte((cpustate->adctl & 0x4) + MC68HC11_IO_AD3);
 			}
 			else
 			{
-				return memory_read_byte(cpustate->io, (cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
+				return cpustate->io->read_byte((cpustate->adctl & 0x7) + MC68HC11_IO_AD0);
 			}
 		}
 		case 0x38:		/* OPT2 */
@@ -175,9 +176,9 @@
 		case 0x74:		/* SCSR1 */
 			return 0x40;
 		case 0x7c:		/* PORTH */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTH);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTH);
 		case 0x7e:		/* PORTG */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_PORTG);
+			return cpustate->io->read_byte(MC68HC11_IO_PORTG);
 		case 0x7f:		/* DDRG */
 			return 0;
 
@@ -186,7 +187,7 @@
 		case 0x89:		/* SPSR2 */
 			return 0x80;
 		case 0x8a:		/* SPDR2 */
-			return memory_read_byte(cpustate->io, MC68HC11_IO_SPI2_DATA);
+			return cpustate->io->read_byte(MC68HC11_IO_SPI2_DATA);
 
 		case 0x8b:		/* OPT4 */
 			return 0;
@@ -203,25 +204,25 @@
 	switch(reg)
 	{
 		case 0x00:		/* PORTA */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTA, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTA, value);
 			return;
 		case 0x01:		/* DDRA */
 			//mame_printf_debug("HC11: ddra = %02X\n", value);
 			return;
 		case 0x03:		/* PORTC */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTC, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTC, value);
 			return;
 		case 0x04:		/* PORTC */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTB, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTB, value);
 			return;
 		case 0x08:		/* PORTD */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTD, value); //mask & 0x3f?
+			cpustate->io->write_byte(MC68HC11_IO_PORTD, value); //mask & 0x3f?
 			return;
 		case 0x09:		/* DDRD */
 			//mame_printf_debug("HC11: ddrd = %02X\n", value);
 			return;
 		case 0x0a:		/* PORTE */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTE, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTE, value);
 			return;
 		case 0x22:		/* TMSK1 */
 			return;
@@ -271,13 +272,13 @@
 		case 0x77:		/* SCDRL */
 			return;
 		case 0x7c:		/* PORTH */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTH, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTH, value);
 			return;
 		case 0x7d:		/* DDRH */
 			//mame_printf_debug("HC11: ddrh = %02X at %04X\n", value, cpustate->pc);
 			return;
 		case 0x7e:		/* PORTG */
-			memory_write_byte(cpustate->io, MC68HC11_IO_PORTG, value);
+			cpustate->io->write_byte(MC68HC11_IO_PORTG, value);
 			return;
 		case 0x7f:		/* DDRG */
 			//mame_printf_debug("HC11: ddrg = %02X at %04X\n", value, cpustate->pc);
@@ -288,7 +289,7 @@
 		case 0x89:		/* SPSR2 */
 			return;
 		case 0x8a:		/* SPDR2 */
-			memory_write_byte(cpustate->io, MC68HC11_IO_SPI2_DATA, value);
+			cpustate->io->write_byte(MC68HC11_IO_SPI2_DATA, value);
 			return;
 
 		case 0x8b:		/* OPT4 */
@@ -303,13 +304,13 @@
 
 INLINE UINT8 FETCH(hc11_state *cpustate)
 {
-	return memory_decrypted_read_byte(cpustate->program, cpustate->pc++);
+	return cpustate->direct->read_decrypted_byte(cpustate->pc++);
 }
 
 INLINE UINT16 FETCH16(hc11_state *cpustate)
 {
 	UINT16 w;
-	w = (memory_decrypted_read_byte(cpustate->program, cpustate->pc) << 8) | (memory_decrypted_read_byte(cpustate->program, cpustate->pc+1));
+	w = (cpustate->direct->read_decrypted_byte(cpustate->pc) << 8) | (cpustate->direct->read_decrypted_byte(cpustate->pc+1));
 	cpustate->pc += 2;
 	return w;
 }
@@ -324,7 +325,7 @@
 	{
 		return cpustate->internal_ram[address-cpustate->ram_position];
 	}
-	return memory_read_byte(cpustate->program, address);
+	return cpustate->program->read_byte(address);
 }
 
 INLINE void WRITE8(hc11_state *cpustate, UINT32 address, UINT8 value)
@@ -339,7 +340,7 @@
 		cpustate->internal_ram[address-cpustate->ram_position] = value;
 		return;
 	}
-	memory_write_byte(cpustate->program, address, value);
+	cpustate->program->write_byte(address, value);
 }
 
 INLINE UINT16 READ16(hc11_state *cpustate, UINT32 address)
@@ -416,6 +417,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 }
 
diff -Nru src-old/emu/cpu/mcs48/mcs48.c src/emu/cpu/mcs48/mcs48.c
--- src-old/emu/cpu/mcs48/mcs48.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mcs48/mcs48.c	2010-08-19 09:10:19.000000000 -0700
@@ -154,9 +154,10 @@
 	int			icount;
 
 	/* Memory spaces */
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
 	UINT8		feature_mask;		/* processor feature flags */
 	UINT16		int_rom_size;		/* internal rom size */
@@ -175,23 +176,23 @@
 ***************************************************************************/
 
 /* ROM is mapped to ADDRESS_SPACE_PROGRAM */
-#define program_r(a)	memory_read_byte_8le(cpustate->program, a)
+#define program_r(a)	cpustate->program->read_byte(a)
 
 /* RAM is mapped to ADDRESS_SPACE_DATA */
-#define ram_r(a)		memory_read_byte_8le(cpustate->data, a)
-#define ram_w(a,V)		memory_write_byte_8le(cpustate->data, a, V)
+#define ram_r(a)		cpustate->data->read_byte(a)
+#define ram_w(a,V)		cpustate->data->write_byte(a, V)
 
 /* ports are mapped to ADDRESS_SPACE_IO */
-#define ext_r(a)		memory_read_byte_8le(cpustate->io, a)
-#define ext_w(a,V)		memory_write_byte_8le(cpustate->io, a, V)
-#define port_r(a)		memory_read_byte_8le(cpustate->io, MCS48_PORT_P0 + a)
-#define port_w(a,V)		memory_write_byte_8le(cpustate->io, MCS48_PORT_P0 + a, V)
-#define test_r(a)		memory_read_byte_8le(cpustate->io, MCS48_PORT_T0 + a)
-#define test_w(a,V)		memory_write_byte_8le(cpustate->io, MCS48_PORT_T0 + a, V)
-#define bus_r()			memory_read_byte_8le(cpustate->io, MCS48_PORT_BUS)
-#define bus_w(V)		memory_write_byte_8le(cpustate->io, MCS48_PORT_BUS, V)
-#define ea_r()			memory_read_byte_8le(cpustate->io, MCS48_PORT_EA)
-#define prog_w(V)		memory_write_byte_8le(cpustate->io, MCS48_PORT_PROG, V)
+#define ext_r(a)		cpustate->io->read_byte(a)
+#define ext_w(a,V)		cpustate->io->write_byte(a, V)
+#define port_r(a)		cpustate->io->read_byte(MCS48_PORT_P0 + a)
+#define port_w(a,V)		cpustate->io->write_byte(MCS48_PORT_P0 + a, V)
+#define test_r(a)		cpustate->io->read_byte(MCS48_PORT_T0 + a)
+#define test_w(a,V)		cpustate->io->write_byte(MCS48_PORT_T0 + a, V)
+#define bus_r()			cpustate->io->read_byte(MCS48_PORT_BUS)
+#define bus_w(V)		cpustate->io->write_byte(MCS48_PORT_BUS, V)
+#define ea_r()			cpustate->io->read_byte(MCS48_PORT_EA)
+#define prog_w(V)		cpustate->io->write_byte(MCS48_PORT_PROG, V)
 
 /* r0-r7 map to memory via the regptr */
 #define R0				regptr[0]
@@ -247,7 +248,7 @@
 
 INLINE UINT8 opcode_fetch(mcs48_state *cpustate)
 {
-	return memory_decrypted_read_byte(cpustate->program, cpustate->pc++);
+	return cpustate->direct->read_decrypted_byte(cpustate->pc++);
 }
 
 
@@ -258,7 +259,7 @@
 
 INLINE UINT8 argument_fetch(mcs48_state *cpustate)
 {
-	return memory_raw_read_byte(cpustate->program, cpustate->pc++);
+	return cpustate->direct->read_raw_byte(cpustate->pc++);
 }
 
 
@@ -269,7 +270,7 @@
 
 INLINE void update_regptr(mcs48_state *cpustate)
 {
-	cpustate->regptr = (UINT8 *)memory_get_write_ptr(cpustate->data, (cpustate->psw & B_FLAG) ? 24 : 0);
+	cpustate->regptr = (UINT8 *)cpustate->data->get_write_ptr((cpustate->psw & B_FLAG) ? 24 : 0);
 }
 
 
@@ -857,6 +858,7 @@
 	cpustate->feature_mask = feature_mask;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/mcs51/mcs51.c src/emu/cpu/mcs51/mcs51.c
--- src-old/emu/cpu/mcs51/mcs51.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mcs51/mcs51.c	2010-08-19 09:10:19.000000000 -0700
@@ -285,9 +285,10 @@
 	legacy_cpu_device *device;
 
 	/* Memory spaces */
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
 	/* Serial Port TX/RX Callbacks */
 	// TODO: Move to special port r/w
@@ -310,15 +311,15 @@
 ***************************************************************************/
 
 /* Read Opcode/Opcode Arguments from Program Code */
-#define ROP(pc)			memory_decrypted_read_byte(mcs51_state->program, pc)
-#define ROP_ARG(pc)		memory_raw_read_byte(mcs51_state->program, pc)
+#define ROP(pc)			mcs51_state->direct->read_decrypted_byte(pc)
+#define ROP_ARG(pc)		mcs51_state->direct->read_raw_byte(pc)
 
 /* Read a byte from External Code Memory (Usually Program Rom(s) Space) */
-#define CODEMEM_R(a)	(UINT8)memory_read_byte_8le(mcs51_state->program, a)
+#define CODEMEM_R(a)	(UINT8)mcs51_state->program->read_byte(a)
 
 /* Read/Write a byte from/to External Data Memory (Usually RAM or other I/O) */
-#define DATAMEM_R(a)	(UINT8)memory_read_byte_8le(mcs51_state->io, a)
-#define DATAMEM_W(a,v)	memory_write_byte_8le(mcs51_state->io, a, v)
+#define DATAMEM_R(a)	(UINT8)mcs51_state->io->read_byte(a)
+#define DATAMEM_W(a,v)	mcs51_state->io->write_byte(a, v)
 
 /* Read/Write a byte from/to the Internal RAM */
 
@@ -327,8 +328,8 @@
 
 /* Read/Write a byte from/to the Internal RAM indirectly */
 /* (called from indirect addressing)                     */
-INLINE UINT8 iram_iread(mcs51_state_t *mcs51_state, offs_t a) { return (a <= mcs51_state->ram_mask) ? memory_read_byte_8le(mcs51_state->data, a) : 0xff; }
-INLINE void iram_iwrite(mcs51_state_t *mcs51_state, offs_t a, UINT8 d) { if (a <= mcs51_state->ram_mask) memory_write_byte_8le(mcs51_state->data, a, d); }
+INLINE UINT8 iram_iread(mcs51_state_t *mcs51_state, offs_t a) { return (a <= mcs51_state->ram_mask) ? mcs51_state->data->read_byte(a) : 0xff; }
+INLINE void iram_iwrite(mcs51_state_t *mcs51_state, offs_t a, UINT8 d) { if (a <= mcs51_state->ram_mask) mcs51_state->data->write_byte(a, d); }
 
 #define IRAM_IR(a)		iram_iread(mcs51_state, a)
 #define IRAM_IW(a, d)	iram_iwrite(mcs51_state, a, d)
@@ -342,8 +343,8 @@
 #define BIT_W(a,v)		bit_address_w(mcs51_state, a, v)
 
 /* Input/Output a byte from given I/O port */
-#define IN(port)		((UINT8)memory_read_byte(mcs51_state->io, port))
-#define OUT(port,value) memory_write_byte(mcs51_state->io, port,value)
+#define IN(port)		((UINT8)mcs51_state->io->read_byte(port))
+#define OUT(port,value) mcs51_state->io->write_byte(port,value)
 
 
 /***************************************************************************
@@ -689,8 +690,8 @@
 
 INLINE void update_ptrs(mcs51_state_t *mcs51_state)
 {
-	mcs51_state->internal_ram = (UINT8 *)memory_get_write_ptr(mcs51_state->data, 0x00);
-	mcs51_state->sfr_ram = (UINT8 *)memory_get_write_ptr(mcs51_state->data, 0x100);
+	mcs51_state->internal_ram = (UINT8 *)mcs51_state->data->get_write_ptr(0x00);
+	mcs51_state->sfr_ram = (UINT8 *)mcs51_state->data->get_write_ptr(0x100);
 }
 
 
@@ -757,13 +758,13 @@
 
 INLINE UINT8 iram_read(mcs51_state_t *mcs51_state, size_t offset)
 {
-	return (((offset) < 0x80) ? memory_read_byte_8le(mcs51_state->data, offset) : mcs51_state->sfr_read(mcs51_state, offset));
+	return (((offset) < 0x80) ? mcs51_state->data->read_byte(offset) : mcs51_state->sfr_read(mcs51_state, offset));
 }
 
 INLINE void iram_write(mcs51_state_t *mcs51_state, size_t offset, UINT8 data)
 {
 	if ((offset) < 0x80)
-		memory_write_byte_8le(mcs51_state->data, offset, data);
+		mcs51_state->data->write_byte(offset, data);
 	else
 		mcs51_state->sfr_write(mcs51_state, offset, data);
 }
@@ -1957,7 +1958,7 @@
 		/* Read next opcode */
 		PPC = PC;
 		debugger_instruction_hook(device, PC);
-		op = memory_decrypted_read_byte(mcs51_state->program, PC++);
+		op = mcs51_state->direct->read_decrypted_byte(PC++);
 
 		/* process opcode and count cycles */
 		mcs51_state->inst_cycles = mcs51_cycles[op];
@@ -2024,7 +2025,7 @@
 			/* no write in this case according to manual */
 			return;
 	}
-	memory_write_byte_8le(mcs51_state->data, (size_t)offset | 0x100, data);
+	mcs51_state->data->write_byte((size_t)offset | 0x100, data);
 }
 
 static UINT8 mcs51_sfr_read(mcs51_state_t *mcs51_state, size_t offset)
@@ -2057,7 +2058,7 @@
 		case ADDR_SBUF:
 		case ADDR_IE:
 		case ADDR_IP:
-			return memory_read_byte_8le(mcs51_state->data, (size_t) offset | 0x100);
+			return mcs51_state->data->read_byte((size_t) offset | 0x100);
 		/* Illegal or non-implemented sfr */
 		default:
 			LOG(("mcs51 '%s': attemping to read an invalid/non-implemented SFR address: %x at 0x%04x\n", mcs51_state->device->tag(), (UINT32)offset,PC));
@@ -2075,6 +2076,7 @@
 	mcs51_state->device = device;
 
 	mcs51_state->program = device->space(AS_PROGRAM);
+	mcs51_state->direct = &mcs51_state->program->direct();
 	mcs51_state->data = device->space(AS_DATA);
 	mcs51_state->io = device->space(AS_IO);
 
@@ -2212,7 +2214,7 @@
 		case ADDR_RCAP2H:
 		case ADDR_TL2:
 		case ADDR_TH2:
-			memory_write_byte_8le(mcs51_state->data, (size_t) offset | 0x100, data);
+			mcs51_state->data->write_byte((size_t) offset | 0x100, data);
 			break;
 
 		default:
@@ -2230,7 +2232,7 @@
 		case ADDR_RCAP2H:
 		case ADDR_TL2:
 		case ADDR_TH2:
-			return memory_read_byte_8le(mcs51_state->data, (size_t) offset | 0x100);
+			return mcs51_state->data->read_byte((size_t) offset | 0x100);
 		default:
 			return mcs51_sfr_read(mcs51_state, offset);
 	}
@@ -2272,7 +2274,7 @@
 			i8052_sfr_write(mcs51_state, offset, data);
 			return;
 	}
-	memory_write_byte_8le(mcs51_state->data, (size_t) offset | 0x100, data);
+	mcs51_state->data->write_byte((size_t) offset | 0x100, data);
 }
 
 static UINT8 i80c52_sfr_read(mcs51_state_t *mcs51_state, size_t offset)
@@ -2283,7 +2285,7 @@
 		case ADDR_IPH:
 		case ADDR_SADDR:
 		case ADDR_SADEN:
-			return memory_read_byte_8le(mcs51_state->data, (size_t) offset | 0x100);
+			return mcs51_state->data->read_byte((size_t) offset | 0x100);
 		default:
 			return i8052_sfr_read(mcs51_state, offset);
 	}
@@ -2355,7 +2357,7 @@
 			mcs51_sfr_write(mcs51_state, offset, data);
 			return;
 	}
-	memory_write_byte_8le(mcs51_state->data, (size_t) offset | 0x100, data);
+	mcs51_state->data->write_byte((size_t) offset | 0x100, data);
 }
 
 static UINT8 ds5002fp_sfr_read(mcs51_state_t *mcs51_state, size_t offset)
@@ -2376,7 +2378,7 @@
 		default:
 			return mcs51_sfr_read(mcs51_state, offset);
 	}
-	return memory_read_byte_8le(mcs51_state->data, (size_t) offset | 0x100);
+	return mcs51_state->data->read_byte((size_t) offset | 0x100);
 }
 
 static CPU_INIT( ds5002fp )
diff -Nru src-old/emu/cpu/minx/minx.c src/emu/cpu/minx/minx.c
--- src-old/emu/cpu/minx/minx.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/minx/minx.c	2010-08-19 01:27:05.000000000 -0700
@@ -85,12 +85,12 @@
 	UINT8	interrupt_pending;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 } minx_state;
 
-#define RD(offset)		memory_read_byte_8be( minx->program, offset )
-#define WR(offset,data)	memory_write_byte_8be( minx->program, offset, data )
+#define RD(offset)		minx->program->read_byte( offset )
+#define WR(offset,data)	minx->program->write_byte( offset, data )
 #define GET_MINX_PC		( ( minx->PC & 0x8000 ) ? ( minx->V << 15 ) | (minx->PC & 0x7FFF ) : minx->PC )
 
 INLINE minx_state *get_safe_token(running_device *device)
diff -Nru src-old/emu/cpu/mips/mips3com.c src/emu/cpu/mips/mips3com.c
--- src-old/emu/cpu/mips/mips3com.c	2010-06-30 17:34:46.000000000 -0700
+++ src/emu/cpu/mips/mips3com.c	2010-08-19 09:10:19.000000000 -0700
@@ -82,6 +82,7 @@
 	mips->irq_callback = irqcallback;
 	mips->device = device;
 	mips->program = device->space(AS_PROGRAM);
+	mips->direct = &mips->program->direct();
 	mips->icache_size = config->icache;
 	mips->dcache_size = config->dcache;
 	mips->system_clock = config->system_clock;
@@ -98,7 +99,7 @@
 	}
 
 	/* set up the endianness */
-	mips->memory = mips->program->accessors;
+	mips->program->accessors(mips->memory);
 
 	/* allocate the virtual TLB */
 	mips->vtlb = vtlb_alloc(device, ADDRESS_SPACE_PROGRAM, 2 * mips->tlbentries + 2, 0);
diff -Nru src-old/emu/cpu/mips/mips3com.h src/emu/cpu/mips/mips3com.h
--- src-old/emu/cpu/mips/mips3com.h	2010-06-16 20:33:24.000000000 -0700
+++ src/emu/cpu/mips/mips3com.h	2010-08-19 09:10:19.000000000 -0700
@@ -196,7 +196,8 @@
 	mips3_flavor	flavor;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *	device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	UINT32			system_clock;
 	UINT32			cpu_clock;
 	UINT64			count_zero_time;
diff -Nru src-old/emu/cpu/mips/mips3drc.c src/emu/cpu/mips/mips3drc.c
--- src-old/emu/cpu/mips/mips3drc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mips/mips3drc.c	2010-08-21 15:25:58.000000000 -0700
@@ -742,7 +742,7 @@
 	drcuml_block *block;
 	jmp_buf errorbuf;
 
-	profiler_mark_start(PROFILER_DRC_COMPILE);
+	g_profiler.start(PROFILER_DRC_COMPILE);
 
 	/* get a description of this sequence */
 	desclist = drcfe_describe_code(mips3->impstate->drcfe, pc);
@@ -794,7 +794,7 @@
 		}
 
 		/* validate this code block if we're not pointing into ROM */
-		if (memory_get_write_ptr(mips3->program, seqhead->physpc) != NULL)
+		if (mips3->program->get_write_ptr(seqhead->physpc) != NULL)
 			generate_checksum_block(mips3, block, &compiler, seqhead, seqlast);
 
 		/* label this instruction, if it may be jumped to locally */
@@ -827,7 +827,7 @@
 
 	/* end the sequence */
 	drcuml_block_end(block);
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -1520,7 +1520,7 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
-			void *base = memory_decrypted_read_ptr(mips3->program, seqhead->physpc);
+			void *base = mips3->direct->read_decrypted_ptr(seqhead->physpc);
 			UML_LOAD(block, IREG(0), base, IMM(0), DWORD);							// load    i0,base,0,dword
 			UML_CMP(block, IREG(0), IMM(seqhead->opptr.l[0]));						// cmp     i0,opptr[0]
 			UML_EXHc(block, IF_NE, mips3->impstate->nocode, IMM(epc(seqhead)));		// exne    nocode,seqhead->pc
@@ -1534,20 +1534,20 @@
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				void *base = memory_decrypted_read_ptr(mips3->program, seqhead->physpc);
+				void *base = mips3->direct->read_decrypted_ptr(seqhead->physpc);
 				UML_LOAD(block, IREG(0), base, IMM(0), DWORD);						// load    i0,base,0,dword
 				UML_CMP(block, IREG(0), IMM(curdesc->opptr.l[0]));					// cmp     i0,opptr[0]
 				UML_EXHc(block, IF_NE, mips3->impstate->nocode, IMM(epc(seqhead)));	// exne    nocode,seqhead->pc
 			}
 #else
 		UINT32 sum = 0;
-		void *base = memory_decrypted_read_ptr(mips3->program, seqhead->physpc);
+		void *base = mips3->direct->read_decrypted_ptr(seqhead->physpc);
 		UML_LOAD(block, IREG(0), base, IMM(0), DWORD);								// load    i0,base,0,dword
 		sum += seqhead->opptr.l[0];
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				base = memory_decrypted_read_ptr(mips3->program, curdesc->physpc);
+				base = mips3->direct->read_decrypted_ptr(curdesc->physpc);
 				UML_LOAD(block, IREG(1), base, IMM(0), DWORD);						// load    i1,base,dword
 				UML_ADD(block, IREG(0), IREG(0), IREG(1));							// add     i0,i0,i1
 				sum += curdesc->opptr.l[0];
diff -Nru src-old/emu/cpu/mips/mips3fe.c src/emu/cpu/mips/mips3fe.c
--- src-old/emu/cpu/mips/mips3fe.c	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/cpu/mips/mips3fe.c	2010-08-19 09:10:19.000000000 -0700
@@ -53,7 +53,7 @@
 	}
 
 	/* fetch the opcode */
-	op = desc->opptr.l[0] = memory_decrypted_read_dword(mips->program, desc->physpc);
+	op = desc->opptr.l[0] = mips->direct->read_decrypted_dword(desc->physpc);
 
 	/* all instructions are 4 bytes and default to a single cycle each */
 	desc->length = 4;
diff -Nru src-old/emu/cpu/mips/psx.c src/emu/cpu/mips/psx.c
--- src-old/emu/cpu/mips/psx.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mips/psx.c	2010-08-19 09:10:19.000000000 -0700
@@ -186,7 +186,8 @@
 	UINT32 multiplier_operand2;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int bus_attached;
 	UINT32 bad_byte_address_mask;
 	UINT32 bad_half_address_mask;
@@ -335,7 +336,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		return memory_read_byte_32le( psxcpu->program, address );
+		return psxcpu->program->read_byte( address );
 	}
 	else
 	{
@@ -347,7 +348,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		return memory_read_word_32le( psxcpu->program, address );
+		return psxcpu->program->read_word( address );
 	}
 	else
 	{
@@ -359,7 +360,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		return memory_read_dword_32le( psxcpu->program, address );
+		return psxcpu->program->read_dword( address );
 	}
 	else
 	{
@@ -371,7 +372,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		return memory_read_dword_masked_32le( psxcpu->program, address, mask );
+		return psxcpu->program->read_dword( address, mask );
 	}
 	else
 	{
@@ -383,7 +384,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		memory_write_dword_32le( psxcpu->program, address, data );
+		psxcpu->program->write_dword( address, data );
 	}
 	else
 	{
@@ -395,7 +396,7 @@
 {
 	if( psxcpu->bus_attached )
 	{
-		memory_write_dword_masked_32le( psxcpu->program, address, data, mask );
+		psxcpu->program->write_dword( address, data, mask );
 	}
 	else
 	{
@@ -1300,7 +1301,7 @@
 	psxcpu->berr = 1;
 }
 
-static void mips_update_scratchpad( const address_space *space )
+static void mips_update_scratchpad( address_space *space )
 {
 	psxcpu_state *psxcpu = get_safe_token(space->cpu);
 
@@ -1342,7 +1343,7 @@
 		( psxcpu->cp0r[ CP0_SR ] & SR_IEC ) != 0 &&
 		( psxcpu->cp0r[ CP0_SR ] & psxcpu->cp0r[ CP0_CAUSE ] & CAUSE_IP ) != 0 )
 	{
-		psxcpu->op = memory_decrypted_read_dword( psxcpu->program, psxcpu->pc );
+		psxcpu->op = psxcpu->direct->read_decrypted_dword( psxcpu->pc );
 		mips_execute_unstoppable_instructions( psxcpu, 1 );
 		mips_exception( psxcpu, EXC_INT );
 	}
@@ -1375,11 +1376,11 @@
 	{
 		UINT32 safepc = psxcpu->delayv & ~psxcpu->bad_word_address_mask;
 
-		psxcpu->op = memory_decrypted_read_dword( psxcpu->program, safepc );
+		psxcpu->op = psxcpu->direct->read_decrypted_dword( safepc );
 	}
 	else
 	{
-		psxcpu->op = memory_decrypted_read_dword( psxcpu->program, psxcpu->pc + 4 );
+		psxcpu->op = psxcpu->direct->read_decrypted_dword( psxcpu->pc + 4 );
 	}
 }
 
@@ -1636,6 +1637,7 @@
 	psxcpu->irq_callback = irqcallback;
 	psxcpu->device = device;
 	psxcpu->program = device->space(AS_PROGRAM);
+	psxcpu->direct = &psxcpu->program->direct();
 
 	mips_state_register( "psxcpu", device );
 }
@@ -1797,7 +1799,7 @@
 					}
 				}
 
-				data = memory_read_dword_32le( psxcpu->program, address );
+				data = psxcpu->program->read_dword( address );
 			}
 			break;
 
@@ -1852,7 +1854,7 @@
 		if (LOG_BIOSCALL) log_bioscall( psxcpu );
 		debugger_instruction_hook(device,  psxcpu->pc );
 
-		psxcpu->op = memory_decrypted_read_dword( psxcpu->program, psxcpu->pc );
+		psxcpu->op = psxcpu->direct->read_decrypted_dword( psxcpu->pc );
 		switch( INS_OP( psxcpu->op ) )
 		{
 		case OP_SPECIAL:
@@ -2959,7 +2961,7 @@
 {
 	/* if a mtc/ctc precedes then this will get the value moved (which cop1 register is irrelevant). */
 	/* if a mfc/cfc follows then it will get the same value as this one. */
-	return memory_read_dword_32le( psxcpu->program, psxcpu->pc + 4 );
+	return psxcpu->program->read_dword( psxcpu->pc + 4 );
 }
 
 static void setcp1dr( psxcpu_state *psxcpu, int reg, UINT32 value )
@@ -2970,7 +2972,7 @@
 {
 	/* if a mtc/ctc precedes then this will get the value moved (which cop1 register is irrelevant). */
 	/* if a mfc/cfc follows then it will get the same value as this one. */
-	return memory_read_dword_32le( psxcpu->program, psxcpu->pc + 4 );
+	return psxcpu->program->read_dword( psxcpu->pc + 4 );
 }
 
 static void setcp1cr( psxcpu_state *psxcpu, int reg, UINT32 value )
@@ -2983,7 +2985,7 @@
 	/* if you have mtc/ctc with an mfc/cfc directly afterwards then you get the value that was moved. */
 	/* if you have an lwc with an mfc/cfc somewhere after it then you get the value that is loaded */
 	/* otherwise you get the next opcode. which register you transfer to or from is irrelevant. */
-	return memory_read_dword_32le( psxcpu->program, psxcpu->pc + 4 );
+	return psxcpu->program->read_dword( psxcpu->pc + 4 );
 }
 
 static void setcp3dr( psxcpu_state *psxcpu, int reg, UINT32 value )
@@ -2995,7 +2997,7 @@
 	/* if you have mtc/ctc with an mfc/cfc directly afterwards then you get the value that was moved. */
 	/* if you have an lwc with an mfc/cfc somewhere after it then you get the value that is loaded */
 	/* otherwise you get the next opcode. which register you transfer to or from is irrelevant. */
-	return memory_read_dword_32le( psxcpu->program, psxcpu->pc + 4 );
+	return psxcpu->program->read_dword( psxcpu->pc + 4 );
 }
 
 static void setcp3cr( psxcpu_state *psxcpu, int reg, UINT32 value )
diff -Nru src-old/emu/cpu/mips/r3000.c src/emu/cpu/mips/r3000.c
--- src-old/emu/cpu/mips/r3000.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/mips/r3000.c	2010-08-19 09:10:19.000000000 -0700
@@ -139,7 +139,8 @@
 	int			hasfpu;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 
 	/* endian-dependent load/store */
 	void		(*lwl)(r3000_state *r3000, UINT32 op);
@@ -150,7 +151,7 @@
 	/* memory accesses */
 	UINT8		bigendian;
 	data_accessors cur;
-	const data_accessors *memory_hand;
+	data_accessors memory_hand;
 	const data_accessors *cache_hand;
 
 	/* cache memory */
@@ -187,19 +188,19 @@
 static void swl_le(r3000_state *r3000, UINT32 op);
 static void swr_le(r3000_state *r3000, UINT32 op);
 
-static UINT8 readcache_be(const address_space *space, offs_t offset);
-static UINT16 readcache_be_word(const address_space *space, offs_t offset);
-static UINT32 readcache_be_dword(const address_space *space, offs_t offset);
-static void writecache_be(const address_space *space, offs_t offset, UINT8 data);
-static void writecache_be_word(const address_space *space, offs_t offset, UINT16 data);
-static void writecache_be_dword(const address_space *space, offs_t offset, UINT32 data);
-
-static UINT8 readcache_le(const address_space *space, offs_t offset);
-static UINT16 readcache_le_word(const address_space *space, offs_t offset);
-static UINT32 readcache_le_dword(const address_space *space, offs_t offset);
-static void writecache_le(const address_space *space, offs_t offset, UINT8 data);
-static void writecache_le_word(const address_space *space, offs_t offset, UINT16 data);
-static void writecache_le_dword(const address_space *space, offs_t offset, UINT32 data);
+static UINT8 readcache_be(address_space *space, offs_t offset);
+static UINT16 readcache_be_word(address_space *space, offs_t offset);
+static UINT32 readcache_be_dword(address_space *space, offs_t offset);
+static void writecache_be(address_space *space, offs_t offset, UINT8 data);
+static void writecache_be_word(address_space *space, offs_t offset, UINT16 data);
+static void writecache_be_dword(address_space *space, offs_t offset, UINT32 data);
+
+static UINT8 readcache_le(address_space *space, offs_t offset);
+static UINT16 readcache_le_word(address_space *space, offs_t offset);
+static UINT32 readcache_le_dword(address_space *space, offs_t offset);
+static void writecache_le(address_space *space, offs_t offset, UINT8 data);
+static void writecache_le_word(address_space *space, offs_t offset, UINT16 data);
+static void writecache_le_dword(address_space *space, offs_t offset, UINT32 data);
 
 
 
@@ -225,7 +226,7 @@
     MEMORY ACCESSORS
 ***************************************************************************/
 
-#define ROPCODE(R,pc)		memory_decrypted_read_dword((R)->program, pc)
+#define ROPCODE(R,pc)		(R)->direct->read_decrypted_dword(pc)
 
 
 
@@ -312,6 +313,7 @@
 	r3000->irq_callback = irqcallback;
 	r3000->device = device;
 	r3000->program = device->space(AS_PROGRAM);
+	r3000->direct = &r3000->program->direct();
 }
 
 
@@ -319,9 +321,9 @@
 {
 	/* set up the endianness */
 	r3000->bigendian = bigendian;
+	r3000->program->accessors(r3000->memory_hand);
 	if (r3000->bigendian)
 	{
-		r3000->memory_hand = &r3000->program->accessors;
 		r3000->cache_hand = &be_cache;
 		r3000->lwl = lwl_be;
 		r3000->lwr = lwr_be;
@@ -330,7 +332,6 @@
 	}
 	else
 	{
-		r3000->memory_hand = &r3000->program->accessors;
 		r3000->cache_hand = &le_cache;
 		r3000->lwl = lwl_le;
 		r3000->lwr = lwr_le;
@@ -339,7 +340,7 @@
 	}
 
 	/* initialize the rest of the config */
-	r3000->cur = *r3000->memory_hand;
+	r3000->cur = r3000->memory_hand;
 	r3000->cache = r3000->dcache;
 	r3000->cache_size = r3000->dcache_size;
 
@@ -396,7 +397,7 @@
 			if (val & SR_IsC)
 				r3000->cur = *r3000->cache_hand;
 			else
-				r3000->cur = *r3000->memory_hand;
+				r3000->cur = r3000->memory_hand;
 		}
 
 		/* handle cache switching */
@@ -892,84 +893,84 @@
     CACHE I/O
 ***************************************************************************/
 
-static UINT8 readcache_be(const address_space *space, offs_t offset)
+static UINT8 readcache_be(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? r3000->cache[BYTE4_XOR_BE(offset)] : 0xff;
 }
 
-static UINT16 readcache_be_word(const address_space *space, offs_t offset)
+static UINT16 readcache_be_word(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? *(UINT16 *)&r3000->cache[WORD_XOR_BE(offset)] : 0xffff;
 }
 
-static UINT32 readcache_be_dword(const address_space *space, offs_t offset)
+static UINT32 readcache_be_dword(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? *(UINT32 *)&r3000->cache[offset] : 0xffffffff;
 }
 
-static void writecache_be(const address_space *space, offs_t offset, UINT8 data)
+static void writecache_be(address_space *space, offs_t offset, UINT8 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	if (offset * 4 < r3000->cache_size) r3000->cache[BYTE4_XOR_BE(offset)] = data;
 }
 
-static void writecache_be_word(const address_space *space, offs_t offset, UINT16 data)
+static void writecache_be_word(address_space *space, offs_t offset, UINT16 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	if (offset * 4 < r3000->cache_size) *(UINT16 *)&r3000->cache[WORD_XOR_BE(offset)] = data;
 }
 
-static void writecache_be_dword(const address_space *space, offs_t offset, UINT32 data)
+static void writecache_be_dword(address_space *space, offs_t offset, UINT32 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	if (offset * 4 < r3000->cache_size) *(UINT32 *)&r3000->cache[offset] = data;
 }
 
-static UINT8 readcache_le(const address_space *space, offs_t offset)
+static UINT8 readcache_le(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? r3000->cache[BYTE4_XOR_LE(offset)] : 0xff;
 }
 
-static UINT16 readcache_le_word(const address_space *space, offs_t offset)
+static UINT16 readcache_le_word(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? *(UINT16 *)&r3000->cache[WORD_XOR_LE(offset)] : 0xffff;
 }
 
-static UINT32 readcache_le_dword(const address_space *space, offs_t offset)
+static UINT32 readcache_le_dword(address_space *space, offs_t offset)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	return (offset * 4 < r3000->cache_size) ? *(UINT32 *)&r3000->cache[offset] : 0xffffffff;
 }
 
-static void writecache_le(const address_space *space, offs_t offset, UINT8 data)
+static void writecache_le(address_space *space, offs_t offset, UINT8 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	if (offset * 4 < r3000->cache_size) r3000->cache[BYTE4_XOR_LE(offset)] = data;
 }
 
-static void writecache_le_word(const address_space *space, offs_t offset, UINT16 data)
+static void writecache_le_word(address_space *space, offs_t offset, UINT16 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
 	if (offset * 4 < r3000->cache_size) *(UINT16 *)&r3000->cache[WORD_XOR_LE(offset)] = data;
 }
 
-static void writecache_le_dword(const address_space *space, offs_t offset, UINT32 data)
+static void writecache_le_dword(address_space *space, offs_t offset, UINT32 data)
 {
 	r3000_state *r3000 = get_safe_token(space->cpu);
 	offset &= 0x1fffffff;
diff -Nru src-old/emu/cpu/mn10200/mn10200.c src/emu/cpu/mn10200/mn10200.c
--- src-old/emu/cpu/mn10200/mn10200.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/cpu/mn10200/mn10200.c	2010-08-19 01:27:05.000000000 -0700
@@ -65,8 +65,8 @@
 	int cycles;
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	address_space *io;
 };
 
 static void mn10200_w(mn102_info *mn102, UINT32 adr, UINT32 data, int type);
@@ -79,7 +79,7 @@
 		return mn10200_r(mn102, address-0xfc00, MEM_BYTE);
 	}
 
-	return memory_read_byte_16le(mn102->program, address);
+	return mn102->program->read_byte(address);
 }
 
 INLINE UINT16 mn102_read_word(mn102_info *mn102, UINT32 address)
@@ -91,10 +91,10 @@
 
 	if (address & 1)
 	{
-		return memory_read_byte_16le(mn102->program, address) | (memory_read_byte_16le(mn102->program, address+1)<<8);
+		return mn102->program->read_byte(address) | (mn102->program->read_byte(address+1)<<8);
 	}
 
-	return memory_read_word_16le(mn102->program, address);
+	return mn102->program->read_word(address);
 }
 
 INLINE void mn102_write_byte(mn102_info *mn102, UINT32 address, UINT8 data)
@@ -105,7 +105,7 @@
 		return;
 	}
 
-	memory_write_byte_16le(mn102->program, address, data);
+	mn102->program->write_byte(address, data);
 }
 
 INLINE void mn102_write_word(mn102_info *mn102, UINT32 address, UINT16 data)
@@ -118,12 +118,12 @@
 
 	if (address & 1)
 	{
-		memory_write_byte_16le(mn102->program, address, data&0xff);
-		memory_write_byte_16le(mn102->program, address+1, (data>>8)&0xff);
+		mn102->program->write_byte(address, data&0xff);
+		mn102->program->write_byte(address+1, (data>>8)&0xff);
 		return;
 	}
 
-	memory_write_word_16le(mn102->program, address, data);
+	mn102->program->write_word(address, data);
 }
 
 INLINE INT32 r24u(mn102_info *mn102, offs_t adr)
@@ -2057,7 +2057,7 @@
     break;
 
   case 0x264:
-	memory_write_byte_8le(mn102->io, MN10200_PORT1, data);
+	mn102->io->write_byte(MN10200_PORT1, data);
     break;
 
   case 0x280: case 0x290: case 0x2a0: case 0x2b0: case 0x2c0: case 0x2d0: case 0x2e0: case 0x2f0: {
@@ -2211,15 +2211,15 @@
     break;
 
 	case 0x3c0:	// port 0 data
-		memory_write_byte_8le(mn102->io, MN10200_PORT0, data);
+		mn102->io->write_byte(MN10200_PORT0, data);
 		break;
 
 	case 0x3c2:	// port 2 data
-		memory_write_byte_8le(mn102->io, MN10200_PORT2, data);
+		mn102->io->write_byte(MN10200_PORT2, data);
 		break;
 
 	case 0x3c3:	// port 3 data
-		memory_write_byte_8le(mn102->io, MN10200_PORT3, data);
+		mn102->io->write_byte(MN10200_PORT3, data);
 		break;
 
 	case 0x3e0:	// port0 ddr
@@ -2304,7 +2304,7 @@
 		break;
 
 	case 0x264:	// port 1 data
-		return memory_read_byte_8le(mn102->io, MN10200_PORT1);
+		return mn102->io->read_byte(MN10200_PORT1);
 
 	case 0x28c: case 0x29c: case 0x2ac: case 0x2bc: case 0x2cc: case 0x2dc: case 0x2ec: case 0x2fc:
 		{
@@ -2313,13 +2313,13 @@
 		}
 
 	case 0x3c0:	// port 0 data
-		return memory_read_byte_8le(mn102->io, MN10200_PORT0);
+		return mn102->io->read_byte(MN10200_PORT0);
 
 	case 0x3c2:	// port 2 data
-		return memory_read_byte_8le(mn102->io, MN10200_PORT2);
+		return mn102->io->read_byte(MN10200_PORT2);
 
 	case 0x3c3:	// port 3 data
-		return memory_read_byte_8le(mn102->io, MN10200_PORT3);
+		return mn102->io->read_byte(MN10200_PORT3);
 
   default:
     log_event("MN102", "internal_r %04x (%03x)", adr+0xfc00, adr);
diff -Nru src-old/emu/cpu/nec/nec.c src/emu/cpu/nec/nec.c
--- src-old/emu/cpu/nec/nec.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/nec/nec.c	2010-08-21 11:40:01.000000000 -0700
@@ -131,21 +131,11 @@
     UINT8  b[16];   /* or as 8 bit registers */
 } necbasicregs;
 
-typedef struct
-{
-	offs_t	fetch_xor;
-
-	UINT8	(*rbyte)(const address_space *, offs_t);
-	UINT16	(*rword)(const address_space *, offs_t);
-	void	(*wbyte)(const address_space *, offs_t, UINT8);
-	void	(*wword)(const address_space *, offs_t, UINT16);
-} memory_interface;
-
-
 typedef struct _nec_state_t nec_state_t;
 struct _nec_state_t
 {
 	necbasicregs regs;
+	offs_t	fetch_xor;
 	UINT16	sregs[4];
 
 	UINT16	ip;
@@ -162,12 +152,11 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int		icount;
 
-	memory_interface	mem;
-
 	const nec_config *config;
 
 	UINT8	prefetch_size;
@@ -240,7 +229,7 @@
 INLINE UINT8 fetch(nec_state_t *nec_state)
 {
 	prefetch(nec_state);
-	return memory_raw_read_byte(nec_state->program, FETCH_XOR((nec_state->sregs[PS]<<4)+nec_state->ip++));
+	return nec_state->direct->read_raw_byte(FETCH_XOR((nec_state->sregs[PS]<<4)+nec_state->ip++));
 }
 
 INLINE UINT16 fetchword(nec_state_t *nec_state)
@@ -263,7 +252,7 @@
 	UINT8 ret;
 
 	prefetch(nec_state);
-	ret = memory_decrypted_read_byte(nec_state->program, FETCH_XOR( ( nec_state->sregs[PS]<<4)+nec_state->ip++));
+	ret = nec_state->direct->read_decrypted_byte(FETCH_XOR( ( nec_state->sregs[PS]<<4)+nec_state->ip++));
 
 	if (nec_state->MF == 1)
 		if (nec_state->config->v25v35_decryptiontable)
@@ -357,8 +346,8 @@
 		nec_state->pending_irq &= ~INT_IRQ;
 	}
 
-    dest_off = read_word(int_num*4);
-    dest_seg = read_word(int_num*4+2);
+    dest_off = read_mem_word(int_num*4);
+    dest_seg = read_mem_word(int_num*4+2);
 
 	PUSH(nec_state->sregs[PS]);
 	PUSH(nec_state->ip);
@@ -1130,60 +1119,11 @@
 	nec_state->irq_callback = irqcallback;
 	nec_state->device = device;
 	nec_state->program = device->space(AS_PROGRAM);
+	nec_state->direct = &nec_state->program->direct();
 	nec_state->io = device->space(AS_IO);
 }
 
 
-/*****************************************************************************
-    8-bit memory accessors
- *****************************************************************************/
-
-static void configure_memory_8bit(nec_state_t *nec_state)
-{
-	nec_state->mem.fetch_xor = 0;
-
-	nec_state->mem.rbyte = memory_read_byte_8le;
-	nec_state->mem.rword = memory_read_word_8le;
-	nec_state->mem.wbyte = memory_write_byte_8le;
-	nec_state->mem.wword = memory_write_word_8le;
-}
-
-
-/*****************************************************************************
-    16-bit memory accessors
- *****************************************************************************/
-
-static UINT16 read_word_16le(const address_space *space, offs_t addr)
-{
-	if (!(addr & 1))
-		return memory_read_word_16le(space, addr);
-	else
-	{
-		UINT16 result = memory_read_byte_16le(space, addr);
-		return result | (memory_read_byte_16le(space, addr + 1) << 8);
-	}
-}
-
-static void write_word_16le(const address_space *space, offs_t addr, UINT16 data)
-{
-	if (!(addr & 1))
-		memory_write_word_16le(space, addr, data);
-	else
-	{
-		memory_write_byte_16le(space, addr, data);
-		memory_write_byte_16le(space, addr + 1, data >> 8);
-	}
-}
-
-static void configure_memory_16bit(nec_state_t *nec_state)
-{
-	nec_state->mem.fetch_xor = BYTE_XOR_LE(0);
-
-	nec_state->mem.rbyte = memory_read_byte_16le;
-	nec_state->mem.rword = read_word_16le;
-	nec_state->mem.wbyte = memory_write_byte_16le;
-	nec_state->mem.wword = write_word_16le;
-}
 
 static CPU_EXECUTE( necv )
 {
@@ -1217,7 +1157,7 @@
 	nec_state_t *nec_state = get_safe_token(device);
 
 	nec_init(device, irqcallback, 0);
-	configure_memory_8bit(nec_state);
+	nec_state->fetch_xor = 0;
 	nec_state->chip_type=V20_TYPE;
 	nec_state->prefetch_size = 4;		/* 3 words */
 	nec_state->prefetch_cycles = 4;		/* four cycles per byte */
@@ -1228,7 +1168,7 @@
 	nec_state_t *nec_state = get_safe_token(device);
 
 	nec_init(device, irqcallback, 1);
-	configure_memory_16bit(nec_state);
+	nec_state->fetch_xor = BYTE_XOR_LE(0);
 	nec_state->chip_type=V30_TYPE;
 	nec_state->prefetch_size = 6;		/* 3 words */
 	nec_state->prefetch_cycles = 2;		/* two cycles per byte / four per word */
@@ -1247,7 +1187,7 @@
      * properly without. */
 	nec_state->prefetch_cycles = 1;		/* two cycles per byte / four per word */
 
-	configure_memory_16bit(nec_state);
+	nec_state->fetch_xor = BYTE_XOR_LE(0);
 }
 
 
diff -Nru src-old/emu/cpu/nec/necmodrm.h src/emu/cpu/nec/necmodrm.h
--- src-old/emu/cpu/nec/necmodrm.h	2010-05-15 13:57:15.000000000 -0700
+++ src/emu/cpu/nec/necmodrm.h	2010-08-19 01:27:05.000000000 -0700
@@ -13,15 +13,15 @@
 #define RegByte(ModRM) nec_state->regs.b[Mod_RM.reg.b[ModRM]]
 
 #define GetRMWord(ModRM) \
-	((ModRM) >= 0xc0 ? nec_state->regs.w[Mod_RM.RM.w[ModRM]] : ( (*GetEA[ModRM])(nec_state), read_word( EA ) ))
+	((ModRM) >= 0xc0 ? nec_state->regs.w[Mod_RM.RM.w[ModRM]] : ( (*GetEA[ModRM])(nec_state), read_mem_word( EA ) ))
 
 #define PutbackRMWord(ModRM,val)			     \
 {							     \
 	if (ModRM >= 0xc0) nec_state->regs.w[Mod_RM.RM.w[ModRM]]=val; \
-    else write_word(EA,val);  \
+    else write_mem_word(EA,val);  \
 }
 
-#define GetnextRMWord read_word((EA&0xf0000)|((EA+2)&0xffff))
+#define GetnextRMWord read_mem_word((EA&0xf0000)|((EA+2)&0xffff))
 
 #define PutRMWord(ModRM,val)				\
 {							\
@@ -29,7 +29,7 @@
 		nec_state->regs.w[Mod_RM.RM.w[ModRM]]=val;	\
 	else {						\
 		(*GetEA[ModRM])(nec_state);			\
-		write_word( EA ,val);			\
+		write_mem_word( EA ,val);			\
 	}						\
 }
 
@@ -41,19 +41,19 @@
 	else {						\
 		(*GetEA[ModRM])(nec_state);			\
 		val = FETCHWORD();				\
-		write_word( EA , val);			\
+		write_mem_word( EA , val);			\
 	}						\
 }
 
 #define GetRMByte(ModRM) \
-	((ModRM) >= 0xc0 ? nec_state->regs.b[Mod_RM.RM.b[ModRM]] : read_byte( (*GetEA[ModRM])(nec_state) ))
+	((ModRM) >= 0xc0 ? nec_state->regs.b[Mod_RM.RM.b[ModRM]] : read_mem_byte( (*GetEA[ModRM])(nec_state) ))
 
 #define PutRMByte(ModRM,val)				\
 {							\
 	if (ModRM >= 0xc0)				\
 		nec_state->regs.b[Mod_RM.RM.b[ModRM]]=val;	\
 	else						\
-		write_byte( (*GetEA[ModRM])(nec_state) ,val);	\
+		write_mem_byte( (*GetEA[ModRM])(nec_state) ,val);	\
 }
 
 #define PutImmRMByte(ModRM) 				\
@@ -62,7 +62,7 @@
 		nec_state->regs.b[Mod_RM.RM.b[ModRM]]=FETCH();	\
 	else {						\
 		(*GetEA[ModRM])(nec_state);			\
-		write_byte( EA , FETCH() );		\
+		write_mem_byte( EA , FETCH() );		\
 	}						\
 }
 
@@ -71,7 +71,7 @@
 	if (ModRM >= 0xc0)				\
 		nec_state->regs.b[Mod_RM.RM.b[ModRM]]=val;	\
 	else						\
-		write_byte(EA,val);			\
+		write_mem_byte(EA,val);			\
 }
 
 #define DEF_br8							\
diff -Nru src-old/emu/cpu/nec/necpriv.h src/emu/cpu/nec/necpriv.h
--- src-old/emu/cpu/nec/necpriv.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/nec/necpriv.h	2010-08-21 11:40:01.000000000 -0700
@@ -80,15 +80,15 @@
 
 /************************************************************************/
 
-#define read_byte(a)			(*nec_state->mem.rbyte)(nec_state->program, a)
-#define read_word(a)			(*nec_state->mem.rword)(nec_state->program, a)
-#define write_byte(a,d)			(*nec_state->mem.wbyte)(nec_state->program, (a),(d))
-#define write_word(a,d)			(*nec_state->mem.wword)(nec_state->program, (a),(d))
-
-#define read_port_byte(a)		(*nec_state->mem.rbyte)(nec_state->io, a)
-#define read_port_word(a)		(*nec_state->mem.rword)(nec_state->io, a)
-#define write_port_byte(a,d)	(*nec_state->mem.wbyte)(nec_state->io, (a),(d))
-#define write_port_word(a,d)	(*nec_state->mem.wword)(nec_state->io, (a),(d))
+#define read_mem_byte(a)			nec_state->program->read_byte(a)
+#define read_mem_word(a)			nec_state->program->read_word_unaligned(a)
+#define write_mem_byte(a,d)			nec_state->program->write_byte((a),(d))
+#define write_mem_word(a,d)			nec_state->program->write_word_unaligned((a),(d))
+
+#define read_port_byte(a)		nec_state->io->read_byte(a)
+#define read_port_word(a)		nec_state->io->read_word_unaligned(a)
+#define write_port_byte(a,d)	nec_state->io->write_byte((a),(d))
+#define write_port_word(a,d)	nec_state->io->write_word_unaligned((a),(d))
 
 /************************************************************************/
 
@@ -98,22 +98,22 @@
 
 #define DefaultBase(Seg) ((nec_state->seg_prefix && (Seg==DS0 || Seg==SS)) ? nec_state->prefix_base : nec_state->sregs[Seg] << 4)
 
-#define GetMemB(Seg,Off) (read_byte(DefaultBase(Seg) + (Off)))
-#define GetMemW(Seg,Off) (read_word(DefaultBase(Seg) + (Off)))
+#define GetMemB(Seg,Off) (read_mem_byte(DefaultBase(Seg) + (Off)))
+#define GetMemW(Seg,Off) (read_mem_word(DefaultBase(Seg) + (Off)))
 
-#define PutMemB(Seg,Off,x) { write_byte(DefaultBase(Seg) + (Off), (x)); }
-#define PutMemW(Seg,Off,x) { write_word(DefaultBase(Seg) + (Off), (x)); }
+#define PutMemB(Seg,Off,x) { write_mem_byte(DefaultBase(Seg) + (Off), (x)); }
+#define PutMemW(Seg,Off,x) { write_mem_word(DefaultBase(Seg) + (Off), (x)); }
 
 /* prefetch timing */
 
 #define FETCH() 			fetch(nec_state)
-#define FETCH_XOR(a)		((a) ^ nec_state->mem.fetch_xor)
+#define FETCH_XOR(a)		((a) ^ nec_state->fetch_xor)
 #define FETCHWORD()			fetchword(nec_state)
 #define EMPTY_PREFETCH()	nec_state->prefetch_reset = 1
 
 
-#define PUSH(val) { nec_state->regs.w[SP]-=2; write_word((((nec_state->sregs[SS]<<4)+nec_state->regs.w[SP])),val); }
-#define POP(var) { var = read_word((((nec_state->sregs[SS]<<4)+nec_state->regs.w[SP]))); nec_state->regs.w[SP]+=2; }
+#define PUSH(val) { nec_state->regs.w[SP]-=2; write_mem_word((((nec_state->sregs[SS]<<4)+nec_state->regs.w[SP])),val); }
+#define POP(var) { var = read_mem_word((((nec_state->sregs[SS]<<4)+nec_state->regs.w[SP]))); nec_state->regs.w[SP]+=2; }
 
 #define GetModRM UINT32 ModRM=FETCH()
 
@@ -221,7 +221,7 @@
 	}										\
 	else {									\
 		(*GetEA[ModRM])(nec_state);					\
-		tmp=read_byte(EA);					\
+		tmp=read_mem_byte(EA);					\
     }
 
 #define BITOP_WORD							\
@@ -231,7 +231,7 @@
 	}										\
 	else {									\
 		(*GetEA[ModRM])(nec_state);					\
-		tmp=read_word(EA);					\
+		tmp=read_mem_word(EA);					\
     }
 
 #define BIT_NOT								\
diff -Nru src-old/emu/cpu/pdp1/pdp1.c src/emu/cpu/pdp1/pdp1.c
--- src-old/emu/cpu/pdp1/pdp1.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/pdp1/pdp1.c	2010-08-19 01:27:05.000000000 -0700
@@ -343,8 +343,8 @@
 #define LOG_EXTRA 0
 #define LOG_IOT_EXTRA 0
 
-#define READ_PDP_18BIT(A) ((signed)memory_read_dword_32be(cpustate->program, (A)<<2))
-#define WRITE_PDP_18BIT(A,V) (memory_write_dword_32be(cpustate->program, (A)<<2,(V)))
+#define READ_PDP_18BIT(A) ((signed)cpustate->program->read_dword((A)<<2))
+#define WRITE_PDP_18BIT(A,V) (cpustate->program->write_dword((A)<<2,(V)))
 
 
 /* PDP1 Registers */
@@ -418,7 +418,7 @@
 	int type_20_sbs;
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 };
 
diff -Nru src-old/emu/cpu/pdp1/tx0.c src/emu/cpu/pdp1/tx0.c
--- src-old/emu/cpu/pdp1/tx0.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/pdp1/tx0.c	2010-08-19 01:27:05.000000000 -0700
@@ -65,7 +65,7 @@
 	int icount;
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 };
 
 INLINE tx0_state *get_safe_token(running_device *device)
@@ -76,8 +76,8 @@
 	return (tx0_state *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-#define READ_TX0_18BIT(A) ((signed)memory_read_dword_32be(cpustate->program, (A)<<2))
-#define WRITE_TX0_18BIT(A,V) (memory_write_dword_32be(cpustate->program, (A)<<2,(V)))
+#define READ_TX0_18BIT(A) ((signed)cpustate->program->read_dword((A)<<2))
+#define WRITE_TX0_18BIT(A,V) (cpustate->program->write_dword((A)<<2,(V)))
 
 
 #define io_handler_rim 3
diff -Nru src-old/emu/cpu/pic16c5x/pic16c5x.c src/emu/cpu/pic16c5x/pic16c5x.c
--- src-old/emu/cpu/pic16c5x/pic16c5x.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/pic16c5x/pic16c5x.c	2010-08-19 09:10:19.000000000 -0700
@@ -98,9 +98,10 @@
 
 
 	legacy_cpu_device *device;
-	const	address_space *program;
-	const	address_space *data;
-	const	address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 };
 
 INLINE pic16c5x_state *get_safe_token(running_device *device)
@@ -126,19 +127,19 @@
 
 INLINE void update_internalram_ptr(pic16c5x_state *cpustate)
 {
-	cpustate->internalram = (UINT8 *)memory_get_write_ptr(cpustate->data, 0x00);
+	cpustate->internalram = (UINT8 *)cpustate->data->get_write_ptr(0x00);
 }
 
 
 
 
-#define PIC16C5x_RDOP(A)         (memory_decrypted_read_word(cpustate->program, (A)<<1))
-#define PIC16C5x_RAM_RDMEM(A)    ((UINT8)memory_read_byte_8le(cpustate->data, A))
-#define PIC16C5x_RAM_WRMEM(A,V)  (memory_write_byte_8le(cpustate->data, A,V))
-#define PIC16C5x_In(Port)        ((UINT8)memory_read_byte_8le(cpustate->io, (Port)))
-#define PIC16C5x_Out(Port,Value) (memory_write_byte_8le(cpustate->io, (Port),Value))
+#define PIC16C5x_RDOP(A)         (cpustate->direct->read_decrypted_word((A)<<1))
+#define PIC16C5x_RAM_RDMEM(A)    ((UINT8)cpustate->data->read_byte(A))
+#define PIC16C5x_RAM_WRMEM(A,V)  (cpustate->data->write_byte(A,V))
+#define PIC16C5x_In(Port)        ((UINT8)cpustate->io->read_byte((Port)))
+#define PIC16C5x_Out(Port,Value) (cpustate->io->write_byte((Port),Value))
 /************  Read the state of the T0 Clock input signal  ************/
-#define PIC16C5x_T0_In           (memory_read_byte_8le(cpustate->io, PIC16C5x_T0))
+#define PIC16C5x_T0_In           (cpustate->io->read_byte(PIC16C5x_T0))
 
 #define M_RDRAM(A)		(((A) < 8) ? cpustate->internalram[A] : PIC16C5x_RAM_RDMEM(A))
 #define M_WRTRAM(A,V)	do { if ((A) < 8) cpustate->internalram[A] = (V); else PIC16C5x_RAM_WRMEM(A,V); } while (0)
@@ -729,6 +730,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/pic16c62x/pic16c62x.c src/emu/cpu/pic16c62x/pic16c62x.c
--- src-old/emu/cpu/pic16c62x/pic16c62x.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/pic16c62x/pic16c62x.c	2010-08-19 09:10:19.000000000 -0700
@@ -88,9 +88,10 @@
 
 
 	legacy_cpu_device *device;
-	const	address_space *program;
-	const	address_space *data;
-	const	address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 };
 
 INLINE pic16c62x_state *get_safe_token(running_device *device)
@@ -126,16 +127,16 @@
 
 INLINE void update_internalram_ptr(pic16c62x_state *cpustate)
 {
-	cpustate->internalram = (UINT8 *)memory_get_write_ptr(cpustate->data, 0x00);
+	cpustate->internalram = (UINT8 *)cpustate->data->get_write_ptr(0x00);
 }
 
-#define PIC16C62x_RDOP(A)         (memory_decrypted_read_word(cpustate->program, (A)<<1))
-#define PIC16C62x_RAM_RDMEM(A)    ((UINT8)memory_read_byte_8le(cpustate->data, A))
-#define PIC16C62x_RAM_WRMEM(A,V)  (memory_write_byte_8le(cpustate->data, A,V))
-#define PIC16C62x_In(Port)        ((UINT8)memory_read_byte_8le(cpustate->io, (Port)))
-#define PIC16C62x_Out(Port,Value) (memory_write_byte_8le(cpustate->io, (Port),Value))
+#define PIC16C62x_RDOP(A)         (cpustate->direct->read_decrypted_word((A)<<1))
+#define PIC16C62x_RAM_RDMEM(A)    ((UINT8)cpustate->data->read_byte(A))
+#define PIC16C62x_RAM_WRMEM(A,V)  (cpustate->data->write_byte(A,V))
+#define PIC16C62x_In(Port)        ((UINT8)cpustate->io->read_byte((Port)))
+#define PIC16C62x_Out(Port,Value) (cpustate->io->write_byte((Port),Value))
 /************  Read the state of the T0 Clock input signal  ************/
-#define PIC16C62x_T0_In           (memory_read_byte_8le(cpustate->io, PIC16C62x_T0) >> 4)
+#define PIC16C62x_T0_In           (cpustate->io->read_byte(PIC16C62x_T0) >> 4)
 
 #define M_RDRAM(A)		(((A) == 0) ? cpustate->internalram[0] : PIC16C62x_RAM_RDMEM(A))
 #define M_WRTRAM(A,V)	do { if ((A) == 0) cpustate->internalram[0] = (V); else PIC16C62x_RAM_WRMEM(A,V); } while (0)
@@ -837,6 +838,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/powerpc/ppc.c src/emu/cpu/powerpc/ppc.c
--- src-old/emu/cpu/powerpc/ppc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/powerpc/ppc.c	2010-08-19 00:26:14.000000000 -0700
@@ -307,7 +307,7 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 
 	// STUFF added for the 6xx series
 	UINT32 dec, dec_frac;
@@ -330,20 +330,20 @@
 
 	/* PowerPC function pointers for memory accesses/exceptions */
 	jmp_buf exception_jmpbuf;
-	UINT8 (*read8)(const address_space *space, offs_t address);
-	UINT16 (*read16)(const address_space *space, offs_t address);
-	UINT32 (*read32)(const address_space *space, offs_t address);
-	UINT64 (*read64)(const address_space *space, offs_t address);
-	void (*write8)(const address_space *space, offs_t address, UINT8 data);
-	void (*write16)(const address_space *space, offs_t address, UINT16 data);
-	void (*write32)(const address_space *space, offs_t address, UINT32 data);
-	void (*write64)(const address_space *space, offs_t address, UINT64 data);
-	UINT16 (*read16_unaligned)(const address_space *space, offs_t address);
-	UINT32 (*read32_unaligned)(const address_space *space, offs_t address);
-	UINT64 (*read64_unaligned)(const address_space *space, offs_t address);
-	void (*write16_unaligned)(const address_space *space, offs_t address, UINT16 data);
-	void (*write32_unaligned)(const address_space *space, offs_t address, UINT32 data);
-	void (*write64_unaligned)(const address_space *space, offs_t address, UINT64 data);
+	UINT8 (*read8)(address_space *space, offs_t address);
+	UINT16 (*read16)(address_space *space, offs_t address);
+	UINT32 (*read32)(address_space *space, offs_t address);
+	UINT64 (*read64)(address_space *space, offs_t address);
+	void (*write8)(address_space *space, offs_t address, UINT8 data);
+	void (*write16)(address_space *space, offs_t address, UINT16 data);
+	void (*write32)(address_space *space, offs_t address, UINT32 data);
+	void (*write64)(address_space *space, offs_t address, UINT64 data);
+	UINT16 (*read16_unaligned)(address_space *space, offs_t address);
+	UINT32 (*read32_unaligned)(address_space *space, offs_t address);
+	UINT64 (*read64_unaligned)(address_space *space, offs_t address);
+	void (*write16_unaligned)(address_space *space, offs_t address, UINT16 data);
+	void (*write32_unaligned)(address_space *space, offs_t address, UINT32 data);
+	void (*write64_unaligned)(address_space *space, offs_t address, UINT64 data);
 
 	void (* optable19[1024])(UINT32);
 	void (* optable31[1024])(UINT32);
@@ -786,14 +786,14 @@
 	return 0;
 }
 
-static UINT8 ppc_read8_translated(const address_space *space, offs_t address);
-static UINT16 ppc_read16_translated(const address_space *space, offs_t address);
-static UINT32 ppc_read32_translated(const address_space *space, offs_t address);
-static UINT64 ppc_read64_translated(const address_space *space, offs_t address);
-static void ppc_write8_translated(const address_space *space, offs_t address, UINT8 data);
-static void ppc_write16_translated(const address_space *space, offs_t address, UINT16 data);
-static void ppc_write32_translated(const address_space *space, offs_t address, UINT32 data);
-static void ppc_write64_translated(const address_space *space, offs_t address, UINT64 data);
+static UINT8 ppc_read8_translated(address_space *space, offs_t address);
+static UINT16 ppc_read16_translated(address_space *space, offs_t address);
+static UINT32 ppc_read32_translated(address_space *space, offs_t address);
+static UINT64 ppc_read64_translated(address_space *space, offs_t address);
+static void ppc_write8_translated(address_space *space, offs_t address, UINT8 data);
+static void ppc_write16_translated(address_space *space, offs_t address, UINT16 data);
+static void ppc_write32_translated(address_space *space, offs_t address, UINT32 data);
+static void ppc_write64_translated(address_space *space, offs_t address, UINT64 data);
 
 INLINE void ppc_set_msr(UINT32 value)
 {
diff -Nru src-old/emu/cpu/powerpc/ppc403.c src/emu/cpu/powerpc/ppc403.c
--- src-old/emu/cpu/powerpc/ppc403.c	2010-06-09 09:20:50.000000000 -0700
+++ src/emu/cpu/powerpc/ppc403.c	2010-08-19 01:27:05.000000000 -0700
@@ -634,7 +634,7 @@
 
 						for (i=0; i < length; i++)
 						{
-							memory_write_byte_32be(ppc.program, ppc.dma[ch].da++, spu_rx_dma_ptr[i]);
+							ppc.program->write_byte(ppc.dma[ch].da++, spu_rx_dma_ptr[i]);
 						}
 					}
 
@@ -809,7 +809,7 @@
 							int length = ppc.dma[ch].ct;
 
 							for( i=0; i < length; i++ ) {
-								spu_tx_dma_ptr[i] = memory_read_byte_32be(ppc.program, ppc.dma[ch].da++);
+								spu_tx_dma_ptr[i] = ppc.program->read_byte(ppc.dma[ch].da++);
 							}
 							spu_tx_dma_handler(length);
 						}
@@ -906,47 +906,47 @@
 
 /*********************************************************************************/
 
-static UINT8 ppc403_read8(const address_space *space, UINT32 a)
+static UINT8 ppc403_read8(address_space *space, UINT32 a)
 {
 	if(a >= 0x40000000 && a <= 0x4000000f)		/* Serial Port */
 		return ppc403_spu_r(a);
-	return memory_read_byte_32be(space, a);
+	return space->read_byte(a);
 }
 
 #define ppc403_read16	memory_read_word_32be
 #define ppc403_read32	memory_read_dword_32be
 
-static void ppc403_write8(const address_space *space, UINT32 a, UINT8 d)
+static void ppc403_write8(address_space *space, UINT32 a, UINT8 d)
 {
 	if( a >= 0x40000000 && a <= 0x4000000f )		/* Serial Port */
 	{
 		ppc403_spu_w(a, d);
 		return;
 	}
-	memory_write_byte_32be(space, a, d);
+	space->write_byte(a, d);
 }
 
 #define ppc403_write16	memory_write_word_32be
 #define ppc403_write32	memory_write_dword_32be
 
-static UINT16 ppc403_read16_unaligned(const address_space *space, UINT32 a)
+static UINT16 ppc403_read16_unaligned(address_space *space, UINT32 a)
 {
 	fatalerror("ppc: Unaligned read16 %08X at %08X", a, ppc.pc);
 	return 0;
 }
 
-static UINT32 ppc403_read32_unaligned(const address_space *space, UINT32 a)
+static UINT32 ppc403_read32_unaligned(address_space *space, UINT32 a)
 {
 	fatalerror("ppc: Unaligned read32 %08X at %08X", a, ppc.pc);
 	return 0;
 }
 
-static void ppc403_write16_unaligned(const address_space *space, UINT32 a, UINT16 d)
+static void ppc403_write16_unaligned(address_space *space, UINT32 a, UINT16 d)
 {
 	fatalerror("ppc: Unaligned write16 %08X, %04X at %08X", a, d, ppc.pc);
 }
 
-static void ppc403_write32_unaligned(const address_space *space, UINT32 a, UINT32 d)
+static void ppc403_write32_unaligned(address_space *space, UINT32 a, UINT32 d)
 {
 	fatalerror("ppc: Unaligned write32 %08X, %08X at %08X", a, d, ppc.pc);
 }
diff -Nru src-old/emu/cpu/powerpc/ppc_mem.c src/emu/cpu/powerpc/ppc_mem.c
--- src-old/emu/cpu/powerpc/ppc_mem.c	2008-12-29 23:54:17.000000000 -0800
+++ src/emu/cpu/powerpc/ppc_mem.c	2010-08-19 07:19:38.000000000 -0700
@@ -66,29 +66,29 @@
 
 /***********************************************************************/
 
-static UINT16 ppc_read16_unaligned(const address_space *space, UINT32 a)
+static UINT16 ppc_read16_unaligned(address_space *space, UINT32 a)
 {
 	return ((UINT16)ppc.read8(space, a+0) << 8) | ((UINT16)ppc.read8(space, a+1) << 0);
 }
 
-static UINT32 ppc_read32_unaligned(const address_space *space, UINT32 a)
+static UINT32 ppc_read32_unaligned(address_space *space, UINT32 a)
 {
 	return ((UINT32)ppc.read8(space, a+0) << 24) | ((UINT32)ppc.read8(space, a+1) << 16) |
 				   ((UINT32)ppc.read8(space, a+2) << 8) | ((UINT32)ppc.read8(space, a+3) << 0);
 }
 
-static UINT64 ppc_read64_unaligned(const address_space *space, UINT32 a)
+static UINT64 ppc_read64_unaligned(address_space *space, UINT32 a)
 {
 	return ((UINT64)READ32(space, a+0) << 32) | (UINT64)(READ32(space, a+4));
 }
 
-static void ppc_write16_unaligned(const address_space *space, UINT32 a, UINT16 d)
+static void ppc_write16_unaligned(address_space *space, UINT32 a, UINT16 d)
 {
 	ppc.write8(space, a+0, (UINT8)(d >> 8));
 	ppc.write8(space, a+1, (UINT8)(d));
 }
 
-static void ppc_write32_unaligned(const address_space *space, UINT32 a, UINT32 d)
+static void ppc_write32_unaligned(address_space *space, UINT32 a, UINT32 d)
 {
 	ppc.write8(space, a+0, (UINT8)(d >> 24));
 	ppc.write8(space, a+1, (UINT8)(d >> 16));
@@ -96,7 +96,7 @@
 	ppc.write8(space, a+3, (UINT8)(d >> 0));
 }
 
-static void ppc_write64_unaligned(const address_space *space, UINT32 a, UINT64 d)
+static void ppc_write64_unaligned(address_space *space, UINT32 a, UINT64 d)
 {
 	ppc.write32(space, a+0, (UINT32)(d >> 32));
 	ppc.write32(space, a+4, (UINT32)(d));
@@ -207,7 +207,7 @@
 					| (((ppc.sdr1 & 0x01FF) & (hash >> 10)) << 16)
 					| ((hash & 0x03FF) << 6);
 
-				pteg_ptr[hash_type] = memory_get_read_ptr(ppc->program, pteg_address);
+				pteg_ptr[hash_type] = ppc->program->get_read_ptr(pteg_address);
 				if (pteg_ptr[hash_type])
 				{
 					for (i = 0; i < 8; i++)
@@ -306,59 +306,59 @@
 	return success;
 }
 
-static UINT8 ppc_read8_translated(const address_space *space, offs_t address)
+static UINT8 ppc_read8_translated(address_space *space, offs_t address)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_READ);
-	return memory_read_byte_64be(space, address);
+	return space->read_byte(address);
 }
 
-static UINT16 ppc_read16_translated(const address_space *space, offs_t address)
+static UINT16 ppc_read16_translated(address_space *space, offs_t address)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_READ);
-	return memory_read_word_64be(space, address);
+	return space->read_word(address);
 }
 
-static UINT32 ppc_read32_translated(const address_space *space, offs_t address)
+static UINT32 ppc_read32_translated(address_space *space, offs_t address)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_READ);
-	return memory_read_dword_64be(space, address);
+	return space->read_dword(address);
 }
 
-static UINT64 ppc_read64_translated(const address_space *space, offs_t address)
+static UINT64 ppc_read64_translated(address_space *space, offs_t address)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_READ);
-	return memory_read_qword_64be(space, address);
+	return space->read_qword(address);
 }
 
-static void ppc_write8_translated(const address_space *space, offs_t address, UINT8 data)
+static void ppc_write8_translated(address_space *space, offs_t address, UINT8 data)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_WRITE);
-	memory_write_byte_64be(space, address, data);
+	space->write_byte(address, data);
 }
 
-static void ppc_write16_translated(const address_space *space, offs_t address, UINT16 data)
+static void ppc_write16_translated(address_space *space, offs_t address, UINT16 data)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_WRITE);
-	memory_write_word_64be(space, address, data);
+	space->write_word(address, data);
 }
 
-static void ppc_write32_translated(const address_space *space, offs_t address, UINT32 data)
+static void ppc_write32_translated(address_space *space, offs_t address, UINT32 data)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_WRITE);
-	memory_write_dword_64be(space, address, data);
+	space->write_dword(address, data);
 }
 
-static void ppc_write64_translated(const address_space *space, offs_t address, UINT64 data)
+static void ppc_write64_translated(address_space *space, offs_t address, UINT64 data)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_DATA | PPC_TRANSLATE_WRITE);
-	memory_write_qword_64be(space, address, data);
+	space->write_qword(address, data);
 }
 
 #ifndef PPC_DRC
-static UINT32 ppc_readop_translated(const address_space *space, offs_t address)
+static UINT32 ppc_readop_translated(address_space *space, offs_t address)
 {
 	ppc_translate_address(&address, PPC_TRANSLATE_CODE | PPC_TRANSLATE_READ);
-	return memory_read_dword_64be(space, address);
+	return space->read_dword(address);
 }
 #endif
 
@@ -385,10 +385,10 @@
 	{
 		switch(size)
 		{
-			case 1:	*value = memory_read_byte(ppc.program, offset);	break;
-			case 2:	*value = memory_read_word(ppc.program, offset);	break;
-			case 4:	*value = memory_read_dword(ppc.program, offset);	break;
-			case 8:	*value = memory_read_qword(ppc.program, offset);	break;
+			case 1:	*value = ppc.program->read_byte(offset);	break;
+			case 2:	*value = ppc.program->read_word(offset);	break;
+			case 4:	*value = ppc.program->read_dword(offset);	break;
+			case 8:	*value = ppc.program->read_qword(offset);	break;
 		}
 	}
 
@@ -406,10 +406,10 @@
 	{
 		switch(size)
 		{
-			case 1:	*value = memory_read_byte(ppc.program, offset);	break;
-			case 2:	*value = memory_read_word(ppc.program, offset);	break;
-			case 4:	*value = memory_read_dword(ppc.program, offset);	break;
-			case 8:	*value = memory_read_qword(ppc.program, offset);	break;
+			case 1:	*value = ppc.program->read_byte(offset);	break;
+			case 2:	*value = ppc.program->read_word(offset);	break;
+			case 4:	*value = ppc.program->read_dword(offset);	break;
+			case 8:	*value = ppc.program->read_qword(offset);	break;
 		}
 	}
 
@@ -425,10 +425,10 @@
 	{
 		switch(size)
 		{
-			case 1:	memory_write_byte(ppc.program, offset, value);	break;
-			case 2:	memory_write_word(ppc.program, offset, value);	break;
-			case 4:	memory_write_dword(ppc.program, offset, value);	break;
-			case 8:	memory_write_qword(ppc.program, offset, value);	break;
+			case 1:	ppc.program->write_byte(offset, value);	break;
+			case 2:	ppc.program->write_word(offset, value);	break;
+			case 4:	ppc.program->write_dword(offset, value);	break;
+			case 8:	ppc.program->write_qword(offset, value);	break;
 		}
 	}
 
diff -Nru src-old/emu/cpu/powerpc/ppccom.c src/emu/cpu/powerpc/ppccom.c
--- src-old/emu/cpu/powerpc/ppccom.c	2010-06-30 13:48:26.000000000 -0700
+++ src/emu/cpu/powerpc/ppccom.c	2010-08-19 09:10:19.000000000 -0700
@@ -300,6 +300,7 @@
 	ppc->irq_callback = irqcallback;
 	ppc->device = device;
 	ppc->program = device->space(AS_PROGRAM);
+	ppc->direct = &ppc->program->direct();
 	ppc->system_clock = (config != NULL) ? config->bus_frequency : device->clock();
 	ppc->tb_divisor = (ppc->tb_divisor * device->clock() + ppc->system_clock / 2 - 1) / ppc->system_clock;
 	ppc->codexor = 0;
@@ -537,7 +538,7 @@
 	for (hashnum = 0; hashnum < 2; hashnum++)
 	{
 		offs_t ptegaddr = hashbase | ((hash << 6) & hashmask);
-		UINT32 *ptegptr = (UINT32 *)memory_get_read_ptr(ppc->program, ptegaddr);
+		UINT32 *ptegptr = (UINT32 *)ppc->program->get_read_ptr(ptegaddr);
 
 		/* should only have valid memory here, but make sure */
 		if (ptegptr != NULL)
@@ -1639,7 +1640,7 @@
 		return FALSE;
 
 	/* fetch the data */
-	*byte = memory_read_byte(ppc->program, dmaregs[DCR4XX_DMADA0]++);
+	*byte = ppc->program->read_byte(dmaregs[DCR4XX_DMADA0]++);
 	ppc4xx_dma_decrement_count(ppc, dmachan);
 	return TRUE;
 }
@@ -1663,7 +1664,7 @@
 		return FALSE;
 
 	/* store the data */
-	memory_write_byte(ppc->program, dmaregs[DCR4XX_DMADA0]++, byte);
+	ppc->program->write_byte(dmaregs[DCR4XX_DMADA0]++, byte);
 	ppc4xx_dma_decrement_count(ppc, dmachan);
 	return TRUE;
 }
@@ -1716,7 +1717,7 @@
 				case 1:
 					do
 					{
-						memory_write_byte(ppc->program, dmaregs[DCR4XX_DMADA0], memory_read_byte(ppc->program, dmaregs[DCR4XX_DMASA0]));
+						ppc->program->write_byte(dmaregs[DCR4XX_DMADA0], ppc->program->read_byte(dmaregs[DCR4XX_DMASA0]));
 						dmaregs[DCR4XX_DMASA0] += srcinc;
 						dmaregs[DCR4XX_DMADA0] += destinc;
 					} while (!ppc4xx_dma_decrement_count(ppc, dmachan));
@@ -1726,7 +1727,7 @@
 				case 2:
 					do
 					{
-						memory_write_word(ppc->program, dmaregs[DCR4XX_DMADA0], memory_read_word(ppc->program, dmaregs[DCR4XX_DMASA0]));
+						ppc->program->write_word(dmaregs[DCR4XX_DMADA0], ppc->program->read_word(dmaregs[DCR4XX_DMASA0]));
 						dmaregs[DCR4XX_DMASA0] += srcinc;
 						dmaregs[DCR4XX_DMADA0] += destinc;
 					} while (!ppc4xx_dma_decrement_count(ppc, dmachan));
@@ -1736,7 +1737,7 @@
 				case 4:
 					do
 					{
-						memory_write_dword(ppc->program, dmaregs[DCR4XX_DMADA0], memory_read_dword(ppc->program, dmaregs[DCR4XX_DMASA0]));
+						ppc->program->write_dword(dmaregs[DCR4XX_DMADA0], ppc->program->read_dword(dmaregs[DCR4XX_DMASA0]));
 						dmaregs[DCR4XX_DMASA0] += srcinc;
 						dmaregs[DCR4XX_DMADA0] += destinc;
 					} while (!ppc4xx_dma_decrement_count(ppc, dmachan));
@@ -1746,8 +1747,8 @@
 				case 16:
 					do
 					{
-						memory_write_qword(ppc->program, dmaregs[DCR4XX_DMADA0], memory_read_qword(ppc->program, dmaregs[DCR4XX_DMASA0]));
-						memory_write_qword(ppc->program, dmaregs[DCR4XX_DMADA0] + 8, memory_read_qword(ppc->program, dmaregs[DCR4XX_DMASA0] + 8));
+						ppc->program->write_qword(dmaregs[DCR4XX_DMADA0], ppc->program->read_qword(dmaregs[DCR4XX_DMASA0]));
+						ppc->program->write_qword(dmaregs[DCR4XX_DMADA0] + 8, ppc->program->read_qword(dmaregs[DCR4XX_DMASA0] + 8));
 						dmaregs[DCR4XX_DMASA0] += srcinc;
 						dmaregs[DCR4XX_DMADA0] += destinc;
 					} while (!ppc4xx_dma_decrement_count(ppc, dmachan));
diff -Nru src-old/emu/cpu/powerpc/ppccom.h src/emu/cpu/powerpc/ppccom.h
--- src-old/emu/cpu/powerpc/ppccom.h	2010-06-16 20:33:24.000000000 -0700
+++ src/emu/cpu/powerpc/ppccom.h	2010-08-19 09:10:19.000000000 -0700
@@ -552,7 +552,8 @@
 	/* internal stuff */
 	device_irq_callback irq_callback;
 	legacy_cpu_device *	device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	offs_t			codexor;
 	UINT32			irq_pending;
 	UINT32			system_clock;
diff -Nru src-old/emu/cpu/powerpc/ppcdrc.c src/emu/cpu/powerpc/ppcdrc.c
--- src-old/emu/cpu/powerpc/ppcdrc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/powerpc/ppcdrc.c	2010-08-21 15:25:58.000000000 -0700
@@ -947,7 +947,7 @@
 	drcuml_block *block;
 	jmp_buf errorbuf;
 
-	profiler_mark_start(PROFILER_DRC_COMPILE);
+	g_profiler.start(PROFILER_DRC_COMPILE);
 
 	/* get a description of this sequence */
 	desclist = drcfe_describe_code(ppc->impstate->drcfe, pc);
@@ -999,7 +999,7 @@
 		}
 
 		/* validate this code block if we're not pointing into ROM */
-		if (memory_get_write_ptr(ppc->program, seqhead->physpc) != NULL)
+		if (ppc->program->get_write_ptr(seqhead->physpc) != NULL)
 			generate_checksum_block(ppc, block, &compiler, seqhead, seqlast);				// <checksum>
 
 		/* label this instruction, if it may be jumped to locally */
@@ -1030,7 +1030,7 @@
 
 	/* end the sequence */
 	drcuml_block_end(block);
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -2097,7 +2097,7 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
-			void *base = memory_decrypted_read_ptr(ppc->program, seqhead->physpc ^ ppc->codexor);
+			void *base = ppc->direct->read_decrypted_ptr(seqhead->physpc ^ ppc->codexor);
 			UML_LOAD(block, IREG(0), base, IMM(0), DWORD);									// load    i0,base,dword
 			UML_CMP(block, IREG(0), IMM(seqhead->opptr.l[0]));								// cmp     i0,*opptr
 			UML_EXHc(block, IF_NE, ppc->impstate->nocode, IMM(seqhead->pc));				// exne    nocode,seqhead->pc
@@ -2111,20 +2111,20 @@
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				void *base = memory_decrypted_read_ptr(ppc->program, seqhead->physpc ^ ppc->codexor);
+				void *base = ppc->direct->read_decrypted_ptr(seqhead->physpc ^ ppc->codexor);
 				UML_LOAD(block, IREG(0), base, IMM(0), DWORD);								// load    i0,base,dword
 				UML_CMP(block, IREG(0), IMM(curdesc->opptr.l[0]));							// cmp     i0,*opptr
 				UML_EXHc(block, IF_NE, ppc->impstate->nocode, IMM(seqhead->pc));			// exne    nocode,seqhead->pc
 			}
 #else
 		UINT32 sum = 0;
-		void *base = memory_decrypted_read_ptr(ppc->program, seqhead->physpc ^ ppc->codexor);
+		void *base = ppc->direct->read_decrypted_ptr(seqhead->physpc ^ ppc->codexor);
 		UML_LOAD(block, IREG(0), base, IMM(0), DWORD);										// load    i0,base,dword
 		sum += seqhead->opptr.l[0];
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				base = memory_decrypted_read_ptr(ppc->program, curdesc->physpc ^ ppc->codexor);
+				base = ppc->direct->read_decrypted_ptr(curdesc->physpc ^ ppc->codexor);
 				UML_LOAD(block, IREG(1), base, IMM(0), DWORD);								// load    i1,base,dword
 				UML_ADD(block, IREG(0), IREG(0), IREG(1));									// add     i0,i0,i1
 				sum += curdesc->opptr.l[0];
diff -Nru src-old/emu/cpu/powerpc/ppcfe.c src/emu/cpu/powerpc/ppcfe.c
--- src-old/emu/cpu/powerpc/ppcfe.c	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/cpu/powerpc/ppcfe.c	2010-08-19 09:10:19.000000000 -0700
@@ -142,7 +142,7 @@
 	}
 
 	/* fetch the opcode */
-	op = desc->opptr.l[0] = memory_decrypted_read_dword(ppc->program, desc->physpc ^ ppc->codexor);
+	op = desc->opptr.l[0] = ppc->direct->read_decrypted_dword(desc->physpc ^ ppc->codexor);
 
 	/* all instructions are 4 bytes and default to a single cycle each */
 	desc->length = 4;
diff -Nru src-old/emu/cpu/rsp/rsp.c src/emu/cpu/rsp/rsp.c
--- src-old/emu/cpu/rsp/rsp.c	2010-07-21 19:25:53.000000000 -0700
+++ src/emu/cpu/rsp/rsp.c	2010-08-19 09:10:19.000000000 -0700
@@ -109,7 +109,7 @@
 INLINE UINT8 READ8(rsp_state *rsp, UINT32 address)
 {
 	address = 0x04000000 | (address & 0xfff);
-	return memory_read_byte_32be(rsp->program, address);
+	return rsp->program->read_byte(address);
 }
 
 INLINE UINT16 READ16(rsp_state *rsp, UINT32 address)
@@ -119,10 +119,10 @@
 	if (address & 1)
 	{
 		//osd_die("RSP: READ16: unaligned %08X at %08X\n", address, rsp->ppc);
-		return ((memory_read_byte_32be(rsp->program, address+0) & 0xff) << 8) | (memory_read_byte_32be(rsp->program, address+1) & 0xff);
+		return ((rsp->program->read_byte(address+0) & 0xff) << 8) | (rsp->program->read_byte(address+1) & 0xff);
 	}
 
-	return memory_read_word_32be(rsp->program, address);
+	return rsp->program->read_word(address);
 }
 
 INLINE UINT32 READ32(rsp_state *rsp, UINT32 address)
@@ -132,19 +132,19 @@
 	if (address & 3)
 	{
 		//osd_die("RSP: READ32: unaligned %08X at %08X\n", address, rsp->ppc);
-		return ((memory_read_byte_32be(rsp->program, address + 0) & 0xff) << 24) |
-			   ((memory_read_byte_32be(rsp->program, address + 1) & 0xff) << 16) |
-			   ((memory_read_byte_32be(rsp->program, address + 2) & 0xff) << 8) |
-			   ((memory_read_byte_32be(rsp->program, address + 3) & 0xff) << 0);
+		return ((rsp->program->read_byte(address + 0) & 0xff) << 24) |
+			   ((rsp->program->read_byte(address + 1) & 0xff) << 16) |
+			   ((rsp->program->read_byte(address + 2) & 0xff) << 8) |
+			   ((rsp->program->read_byte(address + 3) & 0xff) << 0);
 	}
 
-	return memory_read_dword_32be(rsp->program, address);
+	return rsp->program->read_dword(address);
 }
 
 INLINE void WRITE8(rsp_state *rsp, UINT32 address, UINT8 data)
 {
 	address = 0x04000000 | (address & 0xfff);
-	memory_write_byte_32be(rsp->program, address, data);
+	rsp->program->write_byte(address, data);
 }
 
 INLINE void WRITE16(rsp_state *rsp, UINT32 address, UINT16 data)
@@ -154,12 +154,12 @@
 	if (address & 1)
 	{
 		//fatalerror("RSP: WRITE16: unaligned %08X, %04X at %08X\n", address, data, rsp->ppc);
-		memory_write_byte_32be(rsp->program, address + 0, (data >> 8) & 0xff);
-		memory_write_byte_32be(rsp->program, address + 1, (data >> 0) & 0xff);
+		rsp->program->write_byte(address + 0, (data >> 8) & 0xff);
+		rsp->program->write_byte(address + 1, (data >> 0) & 0xff);
 		return;
 	}
 
-	memory_write_word_32be(rsp->program, address, data);
+	rsp->program->write_word(address, data);
 }
 
 INLINE void WRITE32(rsp_state *rsp, UINT32 address, UINT32 data)
@@ -169,14 +169,14 @@
 	if (address & 3)
 	{
 		//osd_die("RSP: WRITE32: unaligned %08X, %08X at %08X\n", address, data, rsp->ppc);
-		memory_write_byte_32be(rsp->program, address + 0, (data >> 24) & 0xff);
-		memory_write_byte_32be(rsp->program, address + 1, (data >> 16) & 0xff);
-		memory_write_byte_32be(rsp->program, address + 2, (data >> 8) & 0xff);
-		memory_write_byte_32be(rsp->program, address + 3, (data >> 0) & 0xff);
+		rsp->program->write_byte(address + 0, (data >> 24) & 0xff);
+		rsp->program->write_byte(address + 1, (data >> 16) & 0xff);
+		rsp->program->write_byte(address + 2, (data >> 8) & 0xff);
+		rsp->program->write_byte(address + 3, (data >> 0) & 0xff);
 		return;
 	}
 
-	memory_write_dword_32be(rsp->program, address, data);
+	rsp->program->write_dword(address, data);
 }
 
 /*****************************************************************************/
@@ -310,6 +310,7 @@
 	rsp->irq_callback = irqcallback;
 	rsp->device = device;
 	rsp->program = device->space(AS_PROGRAM);
+	rsp->direct = &rsp->program->direct();
 
 #if 1
 	// Inaccurate.  RSP registers power on to a random state...
diff -Nru src-old/emu/cpu/rsp/rsp.h src/emu/cpu/rsp/rsp.h
--- src-old/emu/cpu/rsp/rsp.h	2010-07-15 04:22:07.000000000 -0700
+++ src/emu/cpu/rsp/rsp.h	2010-08-19 09:10:19.000000000 -0700
@@ -210,7 +210,8 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 
 	rspimp_state* impstate;
diff -Nru src-old/emu/cpu/rsp/rspdrc.c src/emu/cpu/rsp/rspdrc.c
--- src-old/emu/cpu/rsp/rspdrc.c	2010-07-21 22:24:06.000000000 -0700
+++ src/emu/cpu/rsp/rspdrc.c	2010-08-21 15:25:58.000000000 -0700
@@ -699,6 +699,7 @@
 	rsp->irq_callback = irqcallback;
 	rsp->device = device;
 	rsp->program = device->space(AS_PROGRAM);
+	rsp->direct = &rsp->program->direct();
 
 #if 1
     // Inaccurate.  RSP registers power on to a random state...
@@ -7206,7 +7207,7 @@
 	drcuml_block *block;
 	jmp_buf errorbuf;
 
-	profiler_mark_start(PROFILER_DRC_COMPILE);
+	g_profiler.start(PROFILER_DRC_COMPILE);
 
 	/* get a description of this sequence */
 	desclist = drcfe_describe_code(rsp->impstate->drcfe, pc);
@@ -7258,7 +7259,7 @@
 		}
 
 		/* validate this code block if we're not pointing into ROM */
-		if (memory_get_write_ptr(rsp->program, seqhead->physpc) != NULL)
+		if (rsp->program->get_write_ptr(seqhead->physpc) != NULL)
 			generate_checksum_block(rsp, block, &compiler, seqhead, seqlast);
 
 		/* label this instruction, if it may be jumped to locally */
@@ -7287,7 +7288,7 @@
 
 	/* end the sequence */
 	drcuml_block_end(block);
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 /***************************************************************************
@@ -7601,7 +7602,7 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
-			void *base = memory_decrypted_read_ptr(rsp->program, seqhead->physpc | 0x1000);
+			void *base = rsp->direct->read_decrypted_ptr(seqhead->physpc | 0x1000);
 			UML_LOAD(block, IREG(0), base, IMM(0), DWORD);							// load    i0,base,0,dword
 			UML_CMP(block, IREG(0), IMM(seqhead->opptr.l[0]));						// cmp     i0,opptr[0]
 			UML_EXHc(block, IF_NE, rsp->impstate->nocode, IMM(epc(seqhead)));		// exne    nocode,seqhead->pc
@@ -7612,13 +7613,13 @@
 	else
 	{
 		UINT32 sum = 0;
-		void *base = memory_decrypted_read_ptr(rsp->program, seqhead->physpc | 0x1000);
+		void *base = rsp->direct->read_decrypted_ptr(seqhead->physpc | 0x1000);
 		UML_LOAD(block, IREG(0), base, IMM(0), DWORD);								// load    i0,base,0,dword
 		sum += seqhead->opptr.l[0];
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				base = memory_decrypted_read_ptr(rsp->program, curdesc->physpc | 0x1000);
+				base = rsp->direct->read_decrypted_ptr(curdesc->physpc | 0x1000);
 				UML_LOAD(block, IREG(1), base, IMM(0), DWORD);						// load    i1,base,dword
 				UML_ADD(block, IREG(0), IREG(0), IREG(1));							// add     i0,i0,i1
 				sum += curdesc->opptr.l[0];
diff -Nru src-old/emu/cpu/rsp/rspfe.c src/emu/cpu/rsp/rspfe.c
--- src-old/emu/cpu/rsp/rspfe.c	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/cpu/rsp/rspfe.c	2010-08-19 09:10:19.000000000 -0700
@@ -38,7 +38,7 @@
 	UINT32 op, opswitch;
 
 	/* fetch the opcode */
-	op = desc->opptr.l[0] = memory_decrypted_read_dword(rsp->program, desc->physpc | 0x1000);
+	op = desc->opptr.l[0] = rsp->direct->read_decrypted_dword(desc->physpc | 0x1000);
 
 	/* all instructions are 4 bytes and default to a single cycle each */
 	desc->length = 4;
diff -Nru src-old/emu/cpu/s2650/s2650.c src/emu/cpu/s2650/s2650.c
--- src-old/emu/cpu/s2650/s2650.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/s2650/s2650.c	2010-08-19 09:10:19.000000000 -0700
@@ -43,8 +43,9 @@
 	int		icount;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 };
 
 INLINE s2650_regs *get_safe_token(running_device *device)
@@ -151,7 +152,7 @@
  * RDMEM
  * read memory byte from addr
  ***************************************************************/
-#define RDMEM(addr) memory_read_byte_8le(s2650c->program, addr)
+#define RDMEM(addr) s2650c->program->read_byte(addr)
 
 static void s2650_set_sense(s2650_regs *s2650c, int state);
 
@@ -161,7 +162,7 @@
 
     s2650c->psu = new_val;
     if ((new_val ^ old) & FO)
-    	memory_write_byte_8le(s2650c->io, S2650_FO_PORT, (new_val & FO) ? 1 : 0);
+    	s2650c->io->write_byte(S2650_FO_PORT, (new_val & FO) ? 1 : 0);
 }
 
 INLINE UINT8 get_sp(s2650_regs *s2650c)
@@ -235,7 +236,7 @@
  ***************************************************************/
 INLINE UINT8 ROP(s2650_regs *s2650c)
 {
-	UINT8 result = memory_decrypted_read_byte(s2650c->program, s2650c->page + s2650c->iar);
+	UINT8 result = s2650c->direct->read_decrypted_byte(s2650c->page + s2650c->iar);
 	s2650c->iar = (s2650c->iar + 1) & PMSK;
 	return result;
 }
@@ -246,7 +247,7 @@
  ***************************************************************/
 INLINE UINT8 ARG(s2650_regs *s2650c)
 {
-	UINT8 result = memory_raw_read_byte(s2650c->program, s2650c->page + s2650c->iar);
+	UINT8 result = s2650c->direct->read_raw_byte(s2650c->page + s2650c->iar);
 	s2650c->iar = (s2650c->iar + 1) & PMSK;
 	return result;
 }
@@ -532,7 +533,7 @@
  * Store source register to memory addr (CC unchanged)
  ***************************************************************/
 #define M_STR(address,source)									\
-	memory_write_byte_8le(s2650c->program, address, source)
+	s2650c->program->write_byte(address, source)
 
 /***************************************************************
  * M_AND
@@ -677,7 +678,7 @@
  ***************************************************************/
 #define M_SPSU()												\
 {																\
-	R0 = ((s2650c->psu & ~PSU34) | (memory_read_byte_8le(s2650c->io, S2650_SENSE_PORT) ? SI : 0)); \
+	R0 = ((s2650c->psu & ~PSU34) | (s2650c->io->read_byte(S2650_SENSE_PORT) ? SI : 0)); \
 	SET_CC(R0); 												\
 }
 
@@ -746,7 +747,7 @@
 #define M_TPSU()												\
 {																\
 	UINT8 tpsu = ARG(s2650c);										\
-    UINT8 rpsu = (s2650c->psu | (memory_read_byte_8le(s2650c->io, S2650_SENSE_PORT) ? SI : 0)); \
+    UINT8 rpsu = (s2650c->psu | (s2650c->io->read_byte(S2650_SENSE_PORT) ? SI : 0)); \
 	s2650c->psl &= ~CC;												\
 	if( (rpsu & tpsu) != tpsu )									\
 		s2650c->psl |= 0x80;											\
@@ -796,6 +797,7 @@
 	s2650c->irq_callback = irqcallback;
 	s2650c->device = device;
 	s2650c->program = device->space(AS_PROGRAM);
+	s2650c->direct = &s2650c->program->direct();
 	s2650c->io = device->space(AS_IO);
 
 	state_save_register_device_item(device, 0, s2650c->ppc);
@@ -828,6 +830,7 @@
 
 	s2650c->device = device;
 	s2650c->program = device->space(AS_PROGRAM);
+	s2650c->direct = &s2650c->program->direct();
 	s2650c->io = device->space(AS_IO);
 	s2650c->psl = COM | WC;
 	/* force write */
@@ -879,7 +882,7 @@
 {
 	/* OR'd with Input to allow for external connections */
 
-    return (((s2650c->psu & SI) ? 1 : 0) | ((memory_read_byte_8le(s2650c->io, S2650_SENSE_PORT) & SI) ? 1 : 0));
+    return (((s2650c->psu & SI) ? 1 : 0) | ((s2650c->io->read_byte(S2650_SENSE_PORT) & SI) ? 1 : 0));
 }
 
 static CPU_EXECUTE( s2650 )
@@ -1018,7 +1021,7 @@
 			case 0x32:		/* REDC,2 */
 			case 0x33:		/* REDC,3 */
 				s2650c->icount -= 6;
-				s2650c->reg[s2650c->r] = memory_read_byte_8le(s2650c->io, S2650_CTRL_PORT);
+				s2650c->reg[s2650c->r] = s2650c->io->read_byte(S2650_CTRL_PORT);
 				SET_CC( s2650c->reg[s2650c->r] );
 				break;
 
@@ -1108,7 +1111,7 @@
 			case 0x56:		/* REDE,2 v */
 			case 0x57:		/* REDE,3 v */
 				s2650c->icount -= 9;
-				s2650c->reg[s2650c->r] = memory_read_byte_8le( s2650c->io, ARG(s2650c) );
+				s2650c->reg[s2650c->r] = s2650c->io->read_byte( ARG(s2650c) );
 				SET_CC(s2650c->reg[s2650c->r]);
 				break;
 
@@ -1167,7 +1170,7 @@
 			case 0x72:		/* REDD,2 */
 			case 0x73:		/* REDD,3 */
 				s2650c->icount -= 6;
-				s2650c->reg[s2650c->r] = memory_read_byte_8le(s2650c->io, S2650_DATA_PORT);
+				s2650c->reg[s2650c->r] = s2650c->io->read_byte(S2650_DATA_PORT);
 				SET_CC(s2650c->reg[s2650c->r]);
 				break;
 
@@ -1323,7 +1326,7 @@
 			case 0xb2:		/* WRTC,2 */
 			case 0xb3:		/* WRTC,3 */
 				s2650c->icount -= 6;
-				memory_write_byte_8le(s2650c->io, S2650_CTRL_PORT,s2650c->reg[s2650c->r]);
+				s2650c->io->write_byte(S2650_CTRL_PORT,s2650c->reg[s2650c->r]);
 				break;
 
 			case 0xb4:		/* TPSU */
@@ -1409,7 +1412,7 @@
 			case 0xd6:		/* WRTE,2 v */
 			case 0xd7:		/* WRTE,3 v */
 				s2650c->icount -= 9;
-				memory_write_byte_8le( s2650c->io, ARG(s2650c), s2650c->reg[s2650c->r] );
+				s2650c->io->write_byte( ARG(s2650c), s2650c->reg[s2650c->r] );
 				break;
 
 			case 0xd8:		/* BIRR,0 (*)a */
@@ -1467,7 +1470,7 @@
 			case 0xf2:		/* WRTD,2 */
 			case 0xf3:		/* WRTD,3 */
 				s2650c->icount -= 6;
-				memory_write_byte_8le(s2650c->io, S2650_DATA_PORT, s2650c->reg[s2650c->r]);
+				s2650c->io->write_byte(S2650_DATA_PORT, s2650c->reg[s2650c->r]);
 				break;
 
 			case 0xf4:		/* TMI,0  v */
diff -Nru src-old/emu/cpu/saturn/satops.c src/emu/cpu/saturn/satops.c
--- src-old/emu/cpu/saturn/satops.c	2010-03-08 10:06:27.000000000 -0800
+++ src/emu/cpu/saturn/satops.c	2010-08-19 09:10:19.000000000 -0700
@@ -7,7 +7,7 @@
 {
 	UINT8 data;
 	cpustate->icount-=3;
-        data=memory_decrypted_read_byte(cpustate->program, cpustate->pc);
+        data=cpustate->direct->read_decrypted_byte(cpustate->pc);
 	saturn_assert(data<0x10);
 	cpustate->pc=(cpustate->pc+1)&0xfffff;
 	return data;
@@ -17,7 +17,7 @@
 {
 	UINT8 data;
 	cpustate->icount-=3;
-        data=memory_raw_read_byte(cpustate->program, cpustate->pc);
+        data=cpustate->direct->read_raw_byte(cpustate->pc);
 	saturn_assert(data<0x10);
 	cpustate->pc=(cpustate->pc+1)&0xfffff;
 	return data;
@@ -78,7 +78,7 @@
 {
 	UINT8 data;
 	cpustate->icount-=3;
-	data=memory_read_byte(cpustate->program, adr&0xfffff);
+	data=cpustate->program->read_byte(adr&0xfffff);
 	saturn_assert(data<0x10);
 	if (cpustate->config&&cpustate->config->crc) cpustate->config->crc(cpustate->device, adr&0xfffff, data);
 	return data;
@@ -108,7 +108,7 @@
 {
 	cpustate->icount-=3;
 	saturn_assert(nib<0x10);
-	memory_write_byte(cpustate->program, adr&0xfffff,nib);
+	cpustate->program->write_byte(adr&0xfffff,nib);
 }
 
 #define BEGIN_B 0
diff -Nru src-old/emu/cpu/saturn/saturn.c src/emu/cpu/saturn/saturn.c
--- src-old/emu/cpu/saturn/saturn.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/saturn/saturn.c	2010-08-19 09:10:19.000000000 -0700
@@ -83,7 +83,8 @@
 	int		monitor_in;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	int icount;
 };
 
@@ -115,6 +116,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	state_save_register_device_item_array(device, 0,cpustate->reg[R0]);
 	state_save_register_device_item_array(device, 0,cpustate->reg[R1]);
diff -Nru src-old/emu/cpu/sc61860/sc61860.c src/emu/cpu/sc61860/sc61860.c
--- src-old/emu/cpu/sc61860/sc61860.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sc61860/sc61860.c	2010-08-19 09:10:19.000000000 -0700
@@ -56,7 +56,8 @@
     struct { int t2ms, t512ms; int count;} timer;
 
     legacy_cpu_device *device;
-    const address_space *program;
+    address_space *program;
+    direct_read_data *direct;
     int icount;
 };
 
@@ -106,6 +107,7 @@
 	timer_pulse(device->machine, ATTOTIME_IN_HZ(500), cpustate, 0, sc61860_2ms_tick);
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 }
 
 static CPU_EXECUTE( sc61860 )
diff -Nru src-old/emu/cpu/sc61860/scops.c src/emu/cpu/sc61860/scops.c
--- src-old/emu/cpu/sc61860/scops.c	2008-12-10 11:37:47.000000000 -0800
+++ src/emu/cpu/sc61860/scops.c	2010-08-19 09:10:19.000000000 -0700
@@ -28,29 +28,29 @@
 
 INLINE UINT8 READ_OP(sc61860_state *cpustate)
 {
-	return memory_decrypted_read_byte(cpustate->program, cpustate->pc++);
+	return cpustate->direct->read_decrypted_byte(cpustate->pc++);
 }
 
 INLINE UINT8 READ_OP_ARG(sc61860_state *cpustate)
 {
-	return memory_raw_read_byte(cpustate->program, cpustate->pc++);
+	return cpustate->direct->read_raw_byte(cpustate->pc++);
 }
 
 INLINE UINT16 READ_OP_ARG_WORD(sc61860_state *cpustate)
 {
-	UINT16 t=memory_decrypted_read_byte(cpustate->program, cpustate->pc++)<<8;
-	t|=memory_decrypted_read_byte(cpustate->program, cpustate->pc++);
+	UINT16 t=cpustate->direct->read_decrypted_byte(cpustate->pc++)<<8;
+	t|=cpustate->direct->read_decrypted_byte(cpustate->pc++);
 	return t;
 }
 
 INLINE UINT8 READ_BYTE(sc61860_state *cpustate, UINT16 adr)
 {
-	return memory_read_byte(cpustate->program, adr);
+	return cpustate->program->read_byte(adr);
 }
 
 INLINE void WRITE_BYTE(sc61860_state *cpustate, UINT16 a,UINT8 v)
 {
-	memory_write_byte(cpustate->program, a,v);
+	cpustate->program->write_byte(a,v);
 }
 
 #define PUSH(v) cpustate->ram[--cpustate->r]=v
diff -Nru src-old/emu/cpu/scmp/scmp.c src/emu/cpu/scmp/scmp.c
--- src-old/emu/cpu/scmp/scmp.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/scmp/scmp.c	2010-08-19 09:10:19.000000000 -0700
@@ -33,8 +33,9 @@
 	UINT8	SR;
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int					icount;
 
 	devcb_resolved_write8		flag_out_func;
@@ -69,24 +70,24 @@
 {
 	UINT16 pc = cpustate->PC.w.l;
 	cpustate->PC.w.l = ADD12(cpustate->PC.w.l,1);
-	return memory_decrypted_read_byte(cpustate->program,  pc);
+	return cpustate->direct->read_decrypted_byte( pc);
 }
 
 INLINE UINT8 ARG(scmp_state *cpustate)
 {
 	UINT16 pc = cpustate->PC.w.l;
 	cpustate->PC.w.l = ADD12(cpustate->PC.w.l,1);
-	return memory_raw_read_byte(cpustate->program, pc);
+	return cpustate->direct->read_raw_byte(pc);
 }
 
 INLINE UINT8 RM(scmp_state *cpustate,UINT32 a)
 {
-	return memory_read_byte_8le(cpustate->program, a);
+	return cpustate->program->read_byte(a);
 }
 
 INLINE void WM(scmp_state *cpustate,UINT32 a, UINT8 v)
 {
-	memory_write_byte_8le(cpustate->program, a, v);
+	cpustate->program->write_byte(a, v);
 }
 
 INLINE void illegal(scmp_state *cpustate,UINT8 opcode)
@@ -514,6 +515,7 @@
 	cpustate->device = device;
 
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	/* resolve callbacks */
 	devcb_resolve_write8(&cpustate->flag_out_func, &cpustate->config.flag_out_func, device);
diff -Nru src-old/emu/cpu/se3208/se3208.c src/emu/cpu/se3208/se3208.c
--- src-old/emu/cpu/se3208/se3208.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/se3208/se3208.c	2010-08-19 09:10:19.000000000 -0700
@@ -24,7 +24,8 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	UINT8 IRQ;
 	UINT8 NMI;
 
@@ -65,54 +66,54 @@
 	return (se3208_state_t *)downcast<legacy_cpu_device *>(device)->token();
 }
 
-INLINE UINT32 read_dword_unaligned(const address_space *space, UINT32 address)
+INLINE UINT32 read_dword_unaligned(address_space *space, UINT32 address)
 {
 	if (address & 3)
-		return memory_read_byte_32le(space,address) | memory_read_byte_32le(space,address+1)<<8 | memory_read_byte_32le(space,address+2)<<16 | memory_read_byte_32le(space,address+3)<<24;
+		return space->read_byte(address) | space->read_byte(address+1)<<8 | space->read_byte(address+2)<<16 | space->read_byte(address+3)<<24;
 	else
-		return memory_read_dword_32le(space,address);
+		return space->read_dword(address);
 }
 
-INLINE UINT16 read_word_unaligned(const address_space *space, UINT32 address)
+INLINE UINT16 read_word_unaligned(address_space *space, UINT32 address)
 {
 	if (address & 1)
-		return memory_read_byte_32le(space,address) | memory_read_byte_32le(space,address+1)<<8;
+		return space->read_byte(address) | space->read_byte(address+1)<<8;
 	else
-		return memory_read_word_32le(space,address);
+		return space->read_word(address);
 }
 
-INLINE void write_dword_unaligned(const address_space *space, UINT32 address, UINT32 data)
+INLINE void write_dword_unaligned(address_space *space, UINT32 address, UINT32 data)
 {
 	if (address & 3)
 	{
-		memory_write_byte_32le(space, address, data & 0xff);
-		memory_write_byte_32le(space, address+1, (data>>8)&0xff);
-		memory_write_byte_32le(space, address+2, (data>>16)&0xff);
-		memory_write_byte_32le(space, address+3, (data>>24)&0xff);
+		space->write_byte(address, data & 0xff);
+		space->write_byte(address+1, (data>>8)&0xff);
+		space->write_byte(address+2, (data>>16)&0xff);
+		space->write_byte(address+3, (data>>24)&0xff);
 	}
 	else
 	{
-		memory_write_dword_32le(space, address, data);
+		space->write_dword(address, data);
 	}
 }
 
-INLINE void write_word_unaligned(const address_space *space, UINT32 address, UINT16 data)
+INLINE void write_word_unaligned(address_space *space, UINT32 address, UINT16 data)
 {
 	if (address & 1)
 	{
-		memory_write_byte_32le(space, address, data & 0xff);
-		memory_write_byte_32le(space, address+1, (data>>8)&0xff);
+		space->write_byte(address, data & 0xff);
+		space->write_byte(address+1, (data>>8)&0xff);
 	}
 	else
 	{
-		memory_write_word_32le(space, address, data);
+		space->write_word(address, data);
 	}
 }
 
 
 INLINE UINT8 SE3208_Read8(se3208_state_t *se3208_state, UINT32 addr)
 {
-	return memory_read_byte_32le(se3208_state->program,addr);
+	return se3208_state->program->read_byte(addr);
 }
 
 INLINE UINT16 SE3208_Read16(se3208_state_t *se3208_state, UINT32 addr)
@@ -127,7 +128,7 @@
 
 INLINE void SE3208_Write8(se3208_state_t *se3208_state, UINT32 addr,UINT8 val)
 {
-	memory_write_byte_32le(se3208_state->program,addr,val);
+	se3208_state->program->write_byte(addr,val);
 }
 
 INLINE void SE3208_Write16(se3208_state_t *se3208_state, UINT32 addr,UINT16 val)
@@ -1718,6 +1719,7 @@
 	se3208_state->irq_callback = save_irqcallback;
 	se3208_state->device = device;
 	se3208_state->program = device->space(AS_PROGRAM);
+	se3208_state->direct = &se3208_state->program->direct();
 	se3208_state->PC=SE3208_Read32(se3208_state, 0);
 	se3208_state->SR=0;
 	se3208_state->IRQ=CLEAR_LINE;
@@ -1758,7 +1760,7 @@
 
 	do
 	{
-		UINT16 Opcode=memory_decrypted_read_word(se3208_state->program, WORD_XOR_LE(se3208_state->PC));
+		UINT16 Opcode=se3208_state->direct->read_decrypted_word(WORD_XOR_LE(se3208_state->PC));
 
 		debugger_instruction_hook(device, se3208_state->PC);
 
@@ -1788,6 +1790,7 @@
 	se3208_state->irq_callback = irqcallback;
 	se3208_state->device = device;
 	se3208_state->program = device->space(AS_PROGRAM);
+	se3208_state->direct = &se3208_state->program->direct();
 }
 
 static CPU_EXIT( se3208 )
diff -Nru src-old/emu/cpu/sh2/sh2.c src/emu/cpu/sh2/sh2.c
--- src-old/emu/cpu/sh2/sh2.c	2010-07-21 22:24:06.000000000 -0700
+++ src/emu/cpu/sh2/sh2.c	2010-08-19 01:27:05.000000000 -0700
@@ -131,12 +131,12 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xff << (((~A) & 3)*8)) >> (((~A) & 3)*8);
 
 	if (A >= 0xc0000000)
-		return memory_read_byte_32be(sh2->program, A);
+		return sh2->program->read_byte(A);
 
 	if (A >= 0x40000000)
 		return 0xa5;
 
-	return memory_read_byte_32be(sh2->program, A & AM);
+	return sh2->program->read_byte(A & AM);
 }
 
 INLINE UINT16 RW(sh2_state *sh2, offs_t A)
@@ -145,12 +145,12 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xffff << (((~A) & 2)*8)) >> (((~A) & 2)*8);
 
 	if (A >= 0xc0000000)
-		return memory_read_word_32be(sh2->program, A);
+		return sh2->program->read_word(A);
 
 	if (A >= 0x40000000)
 		return 0xa5a5;
 
-	return memory_read_word_32be(sh2->program, A & AM);
+	return sh2->program->read_word(A & AM);
 }
 
 INLINE UINT32 RL(sh2_state *sh2, offs_t A)
@@ -159,12 +159,12 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xffffffff);
 
 	if (A >= 0xc0000000)
-		return memory_read_dword_32be(sh2->program, A);
+		return sh2->program->read_dword(A);
 
 	if (A >= 0x40000000)
 		return 0xa5a5a5a5;
 
-  return memory_read_dword_32be(sh2->program, A & AM);
+  return sh2->program->read_dword(A & AM);
 }
 
 INLINE void WB(sh2_state *sh2, offs_t A, UINT8 V)
@@ -178,14 +178,14 @@
 
 	if (A >= 0xc0000000)
 	{
-		memory_write_byte_32be(sh2->program, A,V);
+		sh2->program->write_byte(A,V);
 		return;
 	}
 
 	if (A >= 0x40000000)
 		return;
 
-	memory_write_byte_32be(sh2->program, A & AM,V);
+	sh2->program->write_byte(A & AM,V);
 }
 
 INLINE void WW(sh2_state *sh2, offs_t A, UINT16 V)
@@ -198,14 +198,14 @@
 
 	if (A >= 0xc0000000)
 	{
-		memory_write_word_32be(sh2->program, A,V);
+		sh2->program->write_word(A,V);
 		return;
 	}
 
 	if (A >= 0x40000000)
 		return;
 
-	memory_write_word_32be(sh2->program, A & AM,V);
+	sh2->program->write_word(A & AM,V);
 }
 
 INLINE void WL(sh2_state *sh2, offs_t A, UINT32 V)
@@ -218,14 +218,14 @@
 
 	if (A >= 0xc0000000)
 	{
-		memory_write_dword_32be(sh2->program, A,V);
+		sh2->program->write_dword(A,V);
 		return;
 	}
 
 	if (A >= 0x40000000)
 		return;
 
-	memory_write_dword_32be(sh2->program, A & AM,V);
+	sh2->program->write_dword(A & AM,V);
 }
 
 /*  code                 cycles  t-bit
diff -Nru src-old/emu/cpu/sh2/sh2comn.c src/emu/cpu/sh2/sh2comn.c
--- src-old/emu/cpu/sh2/sh2comn.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh2/sh2comn.c	2010-08-19 13:17:55.000000000 -0700
@@ -30,12 +30,12 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xffffffff);
 
 	if (A >= 0xc0000000)
-		return memory_read_dword_32be(sh2->program, A);
+		return sh2->program->read_dword(A);
 
 	if (A >= 0x40000000)
 		return 0xa5a5a5a5;
 
-  return memory_read_dword_32be(sh2->program, A & AM);
+  return sh2->program->read_dword(A & AM);
 }
 
 INLINE void WL(sh2_state *sh2, offs_t A, UINT32 V)
@@ -48,14 +48,14 @@
 
 	if (A >= 0xc0000000)
 	{
-		memory_write_dword_32be(sh2->program, A,V);
+		sh2->program->write_dword(A,V);
 		return;
 	}
 
 	if (A >= 0x40000000)
 		return;
 
-	memory_write_dword_32be(sh2->program, A & AM,V);
+	sh2->program->write_dword(A & AM,V);
 }
 
 static void sh2_timer_resync(sh2_state *sh2)
@@ -185,9 +185,9 @@
 					if(incd == 2)
 						dst --;
 
-					dmadata = memory_read_byte_32be(sh2->program, src);
+					dmadata = sh2->program->read_byte(src);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_byte_32be(sh2->program, dst, dmadata);
+					sh2->program->write_byte(dst, dmadata);
 
 					if(incs == 1)
 						src ++;
@@ -207,9 +207,9 @@
 						dst -= 2;
 
 					// check: should this really be using read_word_32 / write_word_32?
-					dmadata	= memory_read_word_32be(sh2->program, src);
+					dmadata	= sh2->program->read_word(src);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_word_32be(sh2->program, dst, dmadata);
+					sh2->program->write_word(dst, dmadata);
 
 					if(incs == 1)
 						src += 2;
@@ -227,9 +227,9 @@
 					if(incd == 2)
 						dst -= 4;
 
-					dmadata	= memory_read_dword_32be(sh2->program, src);
+					dmadata	= sh2->program->read_dword(src);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_dword_32be(sh2->program, dst, dmadata);
+					sh2->program->write_dword(dst, dmadata);
 
 					if(incs == 1)
 						src += 4;
@@ -247,21 +247,21 @@
 					if(incd == 2)
 						dst -= 16;
 
-					dmadata = memory_read_dword_32be(sh2->program, src);
+					dmadata = sh2->program->read_dword(src);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_dword_32be(sh2->program, dst, dmadata);
+					sh2->program->write_dword(dst, dmadata);
 
-					dmadata = memory_read_dword_32be(sh2->program, src+4);
+					dmadata = sh2->program->read_dword(src+4);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_dword_32be(sh2->program, dst+4, dmadata);
+					sh2->program->write_dword(dst+4, dmadata);
 
-					dmadata = memory_read_dword_32be(sh2->program, src+8);
+					dmadata = sh2->program->read_dword(src+8);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_dword_32be(sh2->program, dst+8, dmadata);
+					sh2->program->write_dword(dst+8, dmadata);
 
-					dmadata = memory_read_dword_32be(sh2->program, src+12);
+					dmadata = sh2->program->read_dword(src+12);
 					if (sh2->dma_callback_kludge) dmadata = sh2->dma_callback_kludge(src, dst, dmadata, size);
-					memory_write_dword_32be(sh2->program, dst+12, dmadata);
+					sh2->program->write_dword(dst+12, dmadata);
 
 					src += 16;
 					if(incd == 1)
@@ -702,6 +702,7 @@
 void sh2_common_init(sh2_state *sh2, legacy_cpu_device *device, device_irq_callback irqcallback)
 {
 	const sh2_cpu_core *conf = (const sh2_cpu_core *)device->baseconfig().static_config();
+	int i;
 
 	sh2->timer = timer_alloc(device->machine, sh2_timer_callback, sh2);
 	timer_adjust_oneshot(sh2->timer, attotime_never, 0);
@@ -728,31 +729,50 @@
 	sh2->irq_callback = irqcallback;
 	sh2->device = device;
 	sh2->program = device->space(AS_PROGRAM);
+	sh2->direct = &sh2->program->direct();
 	sh2->internal = device->space(AS_PROGRAM);
 
 	state_save_register_device_item(device, 0, sh2->pc);
-	state_save_register_device_item(device, 0, sh2->r[15]);
 	state_save_register_device_item(device, 0, sh2->sr);
 	state_save_register_device_item(device, 0, sh2->pr);
 	state_save_register_device_item(device, 0, sh2->gbr);
 	state_save_register_device_item(device, 0, sh2->vbr);
 	state_save_register_device_item(device, 0, sh2->mach);
 	state_save_register_device_item(device, 0, sh2->macl);
-	state_save_register_device_item(device, 0, sh2->r[ 0]);
-	state_save_register_device_item(device, 0, sh2->r[ 1]);
-	state_save_register_device_item(device, 0, sh2->r[ 2]);
-	state_save_register_device_item(device, 0, sh2->r[ 3]);
-	state_save_register_device_item(device, 0, sh2->r[ 4]);
-	state_save_register_device_item(device, 0, sh2->r[ 5]);
-	state_save_register_device_item(device, 0, sh2->r[ 6]);
-	state_save_register_device_item(device, 0, sh2->r[ 7]);
-	state_save_register_device_item(device, 0, sh2->r[ 8]);
-	state_save_register_device_item(device, 0, sh2->r[ 9]);
-	state_save_register_device_item(device, 0, sh2->r[10]);
-	state_save_register_device_item(device, 0, sh2->r[11]);
-	state_save_register_device_item(device, 0, sh2->r[12]);
-	state_save_register_device_item(device, 0, sh2->r[13]);
-	state_save_register_device_item(device, 0, sh2->r[14]);
+	state_save_register_device_item_array(device, 0, sh2->r);
 	state_save_register_device_item(device, 0, sh2->ea);
+	state_save_register_device_item(device, 0, sh2->delay);
+	state_save_register_device_item(device, 0, sh2->cpu_off);
+	state_save_register_device_item(device, 0, sh2->dvsr);
+	state_save_register_device_item(device, 0, sh2->dvdnth);
+	state_save_register_device_item(device, 0, sh2->dvdntl);
+	state_save_register_device_item(device, 0, sh2->dvcr);
+	state_save_register_device_item(device, 0, sh2->pending_irq);
+	state_save_register_device_item(device, 0, sh2->test_irq);
+	state_save_register_device_item(device, 0, sh2->pending_nmi);
+	state_save_register_device_item(device, 0, sh2->irqline);
+	state_save_register_device_item(device, 0, sh2->evec);
+	state_save_register_device_item(device, 0, sh2->irqsr);
+	state_save_register_device_item(device, 0, sh2->target);
+	for (i = 0; i < 16; ++i)
+	{
+		state_save_register_device_item(device, i, sh2->irq_queue[i].irq_vector);
+		state_save_register_device_item(device, i, sh2->irq_queue[i].irq_priority);
+	}
+	state_save_register_device_item(device, 0, sh2->pcfsel);
+	state_save_register_device_item(device, 0, sh2->maxpcfsel);
+	state_save_register_device_item_array(device, 0, sh2->pcflushes);
+	state_save_register_device_item_array(device, 0, sh2->irq_line_state);
+	state_save_register_device_item_pointer(device, 0, sh2->m, 0x200/4);
+	state_save_register_device_item(device, 0, sh2->nmi_line_state);
+	state_save_register_device_item(device, 0, sh2->frc);
+	state_save_register_device_item(device, 0, sh2->ocra);
+	state_save_register_device_item(device, 0, sh2->ocrb);
+	state_save_register_device_item(device, 0, sh2->icr);
+	state_save_register_device_item(device, 0, sh2->frc_base);
+	state_save_register_device_item(device, 0, sh2->frt_input);
+	state_save_register_device_item(device, 0, sh2->internal_irq_level);
+	state_save_register_device_item(device, 0, sh2->internal_irq_vector);
+	state_save_register_device_item_array(device, 0, sh2->dma_timer_active);
 }
 
diff -Nru src-old/emu/cpu/sh2/sh2comn.h src/emu/cpu/sh2/sh2comn.h
--- src-old/emu/cpu/sh2/sh2comn.h	2010-07-06 18:27:54.000000000 -0700
+++ src/emu/cpu/sh2/sh2comn.h	2010-08-19 09:10:19.000000000 -0700
@@ -116,8 +116,9 @@
 	INT8	irq_line_state[17];
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *internal;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *internal;
 	UINT32	*m;
 	INT8  nmi_line_state;
 
diff -Nru src-old/emu/cpu/sh2/sh2drc.c src/emu/cpu/sh2/sh2drc.c
--- src-old/emu/cpu/sh2/sh2drc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh2/sh2drc.c	2010-08-21 15:25:58.000000000 -0700
@@ -151,9 +151,9 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xffff << (((~A) & 2)*8)) >> (((~A) & 2)*8);
 
 	if (A >= 0xc0000000)
-		return memory_read_word_32be(sh2->program, A);
+		return sh2->program->read_word(A);
 
-	return memory_read_word_32be(sh2->program, A & AM);
+	return sh2->program->read_word(A & AM);
 }
 
 INLINE UINT32 RL(sh2_state *sh2, offs_t A)
@@ -162,9 +162,9 @@
 		return sh2_internal_r(sh2->internal, (A & 0x1fc)>>2, 0xffffffff);
 
 	if (A >= 0xc0000000)
-		return memory_read_dword_32be(sh2->program, A);
+		return sh2->program->read_dword(A);
 
-	return memory_read_dword_32be(sh2->program, A & AM);
+	return sh2->program->read_dword(A & AM);
 }
 
 /*-------------------------------------------------
@@ -827,8 +827,8 @@
 	sh2->m = m;
 	memset(sh2->m, 0, 0x200);
 
-	sh2->pc = memory_read_dword_32be(sh2->program, 0);
-	sh2->r[15] = memory_read_dword_32be(sh2->program, 4);
+	sh2->pc = sh2->program->read_dword(0);
+	sh2->r[15] = sh2->program->read_dword(4);
 	sh2->sr = I;
 
 	sh2->internal_irq_level = -1;
@@ -925,7 +925,7 @@
 	drcuml_block *block;
 	jmp_buf errorbuf;
 
-	profiler_mark_start(PROFILER_DRC_COMPILE);
+	g_profiler.start(PROFILER_DRC_COMPILE);
 
 	/* get a description of this sequence */
 	desclist = drcfe_describe_code(sh2->drcfe, pc);
@@ -977,7 +977,7 @@
 		}
 
 		/* validate this code block if we're not pointing into ROM */
-		if (memory_get_write_ptr(sh2->program, seqhead->physpc) != NULL)
+		if (sh2->program->get_write_ptr(seqhead->physpc) != NULL)
 			generate_checksum_block(sh2, block, &compiler, seqhead, seqlast);
 
 		/* label this instruction, if it may be jumped to locally */
@@ -1016,7 +1016,7 @@
 
 	/* end the sequence */
 	drcuml_block_end(block);
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 /*-------------------------------------------------
@@ -1515,7 +1515,7 @@
 	{
 		if (!(seqhead->flags & OPFLAG_VIRTUAL_NOOP))
 		{
-			void *base = memory_decrypted_read_ptr(sh2->program, SH2_CODE_XOR(seqhead->physpc));
+			void *base = sh2->direct->read_decrypted_ptr(SH2_CODE_XOR(seqhead->physpc));
 			UML_LOAD(block, IREG(0), base, IMM(0), WORD);							// load    i0,base,word
 			UML_CMP(block, IREG(0), IMM(seqhead->opptr.w[0]));						// cmp     i0,*opptr
 			UML_EXHc(block, IF_NE, sh2->nocode, IMM(epc(seqhead)));		// exne    nocode,seqhead->pc
@@ -1529,20 +1529,20 @@
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				base = memory_decrypted_read_ptr(sh2->program, SH2_CODE_XOR(curdesc->physpc));
+				base = sh2->direct->read_decrypted_ptr(SH2_CODE_XOR(curdesc->physpc));
 				UML_LOAD(block, IREG(0), curdesc->opptr.w, IMM(0), WORD);			// load    i0,*opptr,0,word
 				UML_CMP(block, IREG(0), IMM(curdesc->opptr.w[0]));					// cmp     i0,*opptr
 				UML_EXHc(block, IF_NE, sh2->nocode, IMM(epc(seqhead)));	// exne    nocode,seqhead->pc
 			}
 #else
 		UINT32 sum = 0;
-		void *base = memory_decrypted_read_ptr(sh2->program, SH2_CODE_XOR(seqhead->physpc));
+		void *base = sh2->direct->read_decrypted_ptr(SH2_CODE_XOR(seqhead->physpc));
 		UML_LOAD(block, IREG(0), base, IMM(0), WORD);								// load    i0,base,word
 		sum += seqhead->opptr.w[0];
 		for (curdesc = seqhead->next; curdesc != seqlast->next; curdesc = curdesc->next)
 			if (!(curdesc->flags & OPFLAG_VIRTUAL_NOOP))
 			{
-				base = memory_decrypted_read_ptr(sh2->program, SH2_CODE_XOR(curdesc->physpc));
+				base = sh2->direct->read_decrypted_ptr(SH2_CODE_XOR(curdesc->physpc));
 				UML_LOAD(block, IREG(1), base, IMM(0), WORD);						// load    i1,*opptr,word
 				UML_ADD(block, IREG(0), IREG(0), IREG(1));							// add     i0,i0,i1
 				sum += curdesc->opptr.w[0];
diff -Nru src-old/emu/cpu/sh2/sh2fe.c src/emu/cpu/sh2/sh2fe.c
--- src-old/emu/cpu/sh2/sh2fe.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh2/sh2fe.c	2010-08-19 09:10:19.000000000 -0700
@@ -43,7 +43,7 @@
 	UINT16 opcode;
 
 	/* fetch the opcode */
-	opcode = desc->opptr.w[0] = memory_decrypted_read_word(context->program, SH2_CODE_XOR(desc->physpc));
+	opcode = desc->opptr.w[0] = context->direct->read_decrypted_word(SH2_CODE_XOR(desc->physpc));
 
 	/* all instructions are 2 bytes and most are a single cycle */
 	desc->length = 2;
diff -Nru src-old/emu/cpu/sh4/sh4.c src/emu/cpu/sh4/sh4.c
--- src-old/emu/cpu/sh4/sh4.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh4/sh4.c	2010-08-19 09:10:19.000000000 -0700
@@ -126,9 +126,9 @@
 		return sh4_internal_r(sh4->internal, ((A & 0x0fc) >> 2) | ((A & 0x1fe0000) >> 11), 0xff << ((A & 3)*8)) >> ((A & 3)*8);
 
 	if (A >= 0xe0000000)
-		return memory_read_byte_64le(sh4->program, A);
+		return sh4->program->read_byte(A);
 
-	return memory_read_byte_64le(sh4->program, A & AM);
+	return sh4->program->read_byte(A & AM);
 }
 
 INLINE UINT16 RW(sh4_state *sh4, offs_t A)
@@ -137,9 +137,9 @@
 		return sh4_internal_r(sh4->internal, ((A & 0x0fc) >> 2) | ((A & 0x1fe0000) >> 11), 0xffff << ((A & 2)*8)) >> ((A & 2)*8);
 
 	if (A >= 0xe0000000)
-		return memory_read_word_64le(sh4->program, A);
+		return sh4->program->read_word(A);
 
-	return memory_read_word_64le(sh4->program, A & AM);
+	return sh4->program->read_word(A & AM);
 }
 
 INLINE UINT32 RL(sh4_state *sh4, offs_t A)
@@ -148,9 +148,9 @@
 		return sh4_internal_r(sh4->internal, ((A & 0x0fc) >> 2) | ((A & 0x1fe0000) >> 11), 0xffffffff);
 
 	if (A >= 0xe0000000)
-		return memory_read_dword_64le(sh4->program, A);
+		return sh4->program->read_dword(A);
 
-  return memory_read_dword_64le(sh4->program, A & AM);
+  return sh4->program->read_dword(A & AM);
 }
 
 INLINE void WB(sh4_state *sh4, offs_t A, UINT8 V)
@@ -164,11 +164,11 @@
 
 	if (A >= 0xe0000000)
 	{
-		memory_write_byte_64le(sh4->program, A,V);
+		sh4->program->write_byte(A,V);
 		return;
 	}
 
-	memory_write_byte_64le(sh4->program, A & AM,V);
+	sh4->program->write_byte(A & AM,V);
 }
 
 INLINE void WW(sh4_state *sh4, offs_t A, UINT16 V)
@@ -181,11 +181,11 @@
 
 	if (A >= 0xe0000000)
 	{
-		memory_write_word_64le(sh4->program, A,V);
+		sh4->program->write_word(A,V);
 		return;
 	}
 
-	memory_write_word_64le(sh4->program, A & AM,V);
+	sh4->program->write_word(A & AM,V);
 }
 
 INLINE void WL(sh4_state *sh4, offs_t A, UINT32 V)
@@ -198,14 +198,14 @@
 
 	if (A >= 0xe0000000)
 	{
-		memory_write_dword_64le(sh4->program, A,V);
+		sh4->program->write_dword(A,V);
 		return;
 	}
 
 /*  if (A >= 0x40000000)
         return;*/
 
-	memory_write_dword_64le(sh4->program, A & AM,V);
+	sh4->program->write_dword(A & AM,V);
 }
 
 /*  code                 cycles  t-bit
@@ -2129,7 +2129,7 @@
 		for (a = 0;a < 4;a++)
 		{
 			// shouldn't be causing a memory read, should store sq writes in registers.
-			memory_write_qword_64le(sh4->program, dest, memory_read_qword_64le(sh4->program, addr));
+			sh4->program->write_qword(dest, sh4->program->read_qword(addr));
 			addr += 8;
 			dest += 8;
 		}
@@ -3282,6 +3282,7 @@
 	sh4->device = device;
 	sh4->internal = device->space(AS_PROGRAM);
 	sh4->program = device->space(AS_PROGRAM);
+	sh4->direct = &sh4->program->direct();
 	sh4->io = device->space(AS_IO);
 
 	sh4->dma_timer[0] = tsaved[0];
@@ -3340,11 +3341,11 @@
 
 		if (sh4->delay)
 		{
-			opcode = memory_decrypted_read_word(sh4->program, WORD2_XOR_LE((UINT32)(sh4->delay & AM)));
+			opcode = sh4->direct->read_decrypted_word(WORD2_XOR_LE((UINT32)(sh4->delay & AM)));
 			sh4->pc -= 2;
 		}
 		else
-			opcode = memory_decrypted_read_word(sh4->program, WORD2_XOR_LE((UINT32)(sh4->pc & AM)));
+			opcode = sh4->direct->read_decrypted_word(WORD2_XOR_LE((UINT32)(sh4->pc & AM)));
 
 		debugger_instruction_hook(device, sh4->pc & AM);
 
diff -Nru src-old/emu/cpu/sh4/sh4comn.c src/emu/cpu/sh4/sh4comn.c
--- src-old/emu/cpu/sh4/sh4comn.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh4/sh4comn.c	2010-08-19 01:27:05.000000000 -0700
@@ -480,7 +480,7 @@
 				src --;
 			if(incd == 2)
 				dst --;
-			memory_write_byte_64le(sh4->program, dst, memory_read_byte_64le(sh4->program, src));
+			sh4->program->write_byte(dst, sh4->program->read_byte(src));
 			if(incs == 1)
 				src ++;
 			if(incd == 1)
@@ -496,7 +496,7 @@
 				src -= 2;
 			if(incd == 2)
 				dst -= 2;
-			memory_write_word_64le(sh4->program, dst, memory_read_word_64le(sh4->program, src));
+			sh4->program->write_word(dst, sh4->program->read_word(src));
 			if(incs == 1)
 				src += 2;
 			if(incd == 1)
@@ -512,7 +512,7 @@
 				src -= 8;
 			if(incd == 2)
 				dst -= 8;
-			memory_write_qword_64le(sh4->program, dst, memory_read_qword_64le(sh4->program, src));
+			sh4->program->write_qword(dst, sh4->program->read_qword(src));
 			if(incs == 1)
 				src += 8;
 			if(incd == 1)
@@ -529,7 +529,7 @@
 				src -= 4;
 			if(incd == 2)
 				dst -= 4;
-			memory_write_dword_64le(sh4->program, dst, memory_read_dword_64le(sh4->program, src));
+			sh4->program->write_dword(dst, sh4->program->read_dword(src));
 			if(incs == 1)
 				src += 4;
 			if(incd == 1)
@@ -546,10 +546,10 @@
 				src -= 32;
 			if(incd == 2)
 				dst -= 32;
-			memory_write_qword_64le(sh4->program, dst, memory_read_qword_64le(sh4->program, src));
-			memory_write_qword_64le(sh4->program, dst+8, memory_read_qword_64le(sh4->program, src+8));
-			memory_write_qword_64le(sh4->program, dst+16, memory_read_qword_64le(sh4->program, src+16));
-			memory_write_qword_64le(sh4->program, dst+24, memory_read_qword_64le(sh4->program, src+24));
+			sh4->program->write_qword(dst, sh4->program->read_qword(src));
+			sh4->program->write_qword(dst+8, sh4->program->read_qword(src+8));
+			sh4->program->write_qword(dst+16, sh4->program->read_qword(src+16));
+			sh4->program->write_qword(dst+24, sh4->program->read_qword(src+24));
 			if(incs == 1)
 				src += 32;
 			if(incd == 1)
@@ -910,11 +910,11 @@
 		sh4->ioport16_direction &= 0xffff;
 		sh4->ioport16_pullup = (sh4->ioport16_pullup | sh4->ioport16_direction) ^ 0xffff;
 		if (sh4->m[BCR2] & 1)
-			memory_write_dword_64le(sh4->io, SH4_IOPORT_16, (UINT64)(sh4->m[PDTRA] & sh4->ioport16_direction) | ((UINT64)sh4->m[PCTRA] << 16));
+			sh4->io->write_dword(SH4_IOPORT_16, (UINT64)(sh4->m[PDTRA] & sh4->ioport16_direction) | ((UINT64)sh4->m[PCTRA] << 16));
 		break;
 	case PDTRA:
 		if (sh4->m[BCR2] & 1)
-			memory_write_dword_64le(sh4->io, SH4_IOPORT_16, (UINT64)(sh4->m[PDTRA] & sh4->ioport16_direction) | ((UINT64)sh4->m[PCTRA] << 16));
+			sh4->io->write_dword(SH4_IOPORT_16, (UINT64)(sh4->m[PDTRA] & sh4->ioport16_direction) | ((UINT64)sh4->m[PCTRA] << 16));
 		break;
 	case PCTRB:
 		sh4->ioport4_pullup = 0;
@@ -926,11 +926,11 @@
 		sh4->ioport4_direction &= 0xf;
 		sh4->ioport4_pullup = (sh4->ioport4_pullup | sh4->ioport4_direction) ^ 0xf;
 		if (sh4->m[BCR2] & 1)
-			memory_write_dword_64le(sh4->io, SH4_IOPORT_4, (sh4->m[PDTRB] & sh4->ioport4_direction) | (sh4->m[PCTRB] << 16));
+			sh4->io->write_dword(SH4_IOPORT_4, (sh4->m[PDTRB] & sh4->ioport4_direction) | (sh4->m[PCTRB] << 16));
 		break;
 	case PDTRB:
 		if (sh4->m[BCR2] & 1)
-			memory_write_dword_64le(sh4->io, SH4_IOPORT_4, (sh4->m[PDTRB] & sh4->ioport4_direction) | (sh4->m[PCTRB] << 16));
+			sh4->io->write_dword(SH4_IOPORT_4, (sh4->m[PDTRB] & sh4->ioport4_direction) | (sh4->m[PCTRB] << 16));
 		break;
 
 	case SCBRR2:
@@ -981,11 +981,11 @@
 		// I/O ports
 	case PDTRA:
 		if (sh4->m[BCR2] & 1)
-			return (memory_read_dword_64le(sh4->io, SH4_IOPORT_16) & ~sh4->ioport16_direction) | (sh4->m[PDTRA] & sh4->ioport16_direction);
+			return (sh4->io->read_dword(SH4_IOPORT_16) & ~sh4->ioport16_direction) | (sh4->m[PDTRA] & sh4->ioport16_direction);
 		break;
 	case PDTRB:
 		if (sh4->m[BCR2] & 1)
-			return (memory_read_dword_64le(sh4->io, SH4_IOPORT_4) & ~sh4->ioport4_direction) | (sh4->m[PDTRB] & sh4->ioport4_direction);
+			return (sh4->io->read_dword(SH4_IOPORT_4) & ~sh4->ioport4_direction) | (sh4->m[PDTRB] & sh4->ioport4_direction);
 		break;
 
 		// SCIF (UART with FIFO)
@@ -1278,7 +1278,7 @@
 				len = s->length;
 				p32bits = (UINT32 *)(s->buffer);
 				for (pos = 0;pos < len;pos++) {
-					*p32bits = memory_read_dword_64le(sh4->program, s->source);
+					*p32bits = sh4->program->read_dword(s->source);
 					p32bits++;
 					s->source = s->source + 4;
 				}
@@ -1286,7 +1286,7 @@
 				len = s->length;
 				p32bits = (UINT32 *)(s->buffer);
 				for (pos = 0;pos < len;pos++) {
-					memory_write_dword_64le(sh4->program, s->destination, *p32bits);
+					sh4->program->write_dword(s->destination, *p32bits);
 					p32bits++;
 					s->destination = s->destination + 4;
 				}
@@ -1297,7 +1297,7 @@
 				len = s->length * 4;
 				p32bytes = (UINT64 *)(s->buffer);
 				for (pos = 0;pos < len;pos++) {
-					*p32bytes = memory_read_qword_64le(sh4->program, s->source);
+					*p32bytes = sh4->program->read_qword(s->source);
 					p32bytes++;
 					s->destination = s->destination + 8;
 				}
@@ -1305,7 +1305,7 @@
 				len = s->length * 4;
 				p32bytes = (UINT64 *)(s->buffer);
 				for (pos = 0;pos < len;pos++) {
-					memory_write_qword_64le(sh4->program, s->destination, *p32bytes);
+					sh4->program->write_qword(s->destination, *p32bytes);
 					p32bytes++;
 					s->destination = s->destination + 8;
 				}
diff -Nru src-old/emu/cpu/sh4/sh4comn.h src/emu/cpu/sh4/sh4comn.h
--- src-old/emu/cpu/sh4/sh4comn.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sh4/sh4comn.h	2010-08-19 09:10:19.000000000 -0700
@@ -63,9 +63,10 @@
 	INT8	irq_line_state[17];
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *internal;
-	const address_space *program;
-	const address_space *io;
+	address_space *internal;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	UINT32	*m;
 	INT8	nmi_line_state;
 
diff -Nru src-old/emu/cpu/sharc/sharc.c src/emu/cpu/sharc/sharc.c
--- src-old/emu/cpu/sharc/sharc.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sharc/sharc.c	2010-08-19 00:26:14.000000000 -0700
@@ -126,8 +126,8 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
+	address_space *program;
+	address_space *data;
 	void (*opcode_handler)(SHARC_REGS *cpustate);
 	int icount;
 	UINT64 opcode;
diff -Nru src-old/emu/cpu/sharc/sharcmem.c src/emu/cpu/sharc/sharcmem.c
--- src-old/emu/cpu/sharc/sharcmem.c	2008-12-07 22:07:54.000000000 -0800
+++ src/emu/cpu/sharc/sharcmem.c	2010-08-19 01:27:05.000000000 -0700
@@ -153,7 +153,7 @@
 		}
 	}
 
-	return memory_read_dword_32le(cpustate->data, address << 2);
+	return cpustate->data->read_dword(address << 2);
 }
 
 static void dm_write32(SHARC_REGS *cpustate, UINT32 address, UINT32 data)
@@ -198,5 +198,5 @@
 		return;
 	}
 
-	memory_write_dword_32le(cpustate->data, address << 2, data);
+	cpustate->data->write_dword(address << 2, data);
 }
diff -Nru src-old/emu/cpu/sm8500/sm8500.c src/emu/cpu/sm8500/sm8500.c
--- src-old/emu/cpu/sm8500/sm8500.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sm8500/sm8500.c	2010-08-30 08:20:58.000000000 -0700
@@ -7,6 +7,14 @@
   this cpu, and made educated guesses on the number of cycles for each instruction.
 
   Code by Wilbert Pol
+
+
+There is some internal ram for the main cpu registers. They are offset by an index value.
+The address is (PS0 & 0xF8) + register number. It is not known what happens when PS0 >= F8.
+The assumption is that F8 to 107 is used, but it might wrap around instead.
+The registers also mirror out to main RAM, appearing at 0000 to 000F regardless of where
+they are internally.
+
 */
 
 #include "emu.h"
@@ -27,33 +35,25 @@
 {
 	SM8500_CONFIG config;
 	UINT16 PC;
-	UINT8 *register_base;
 	UINT8 IE0;
 	UINT8 IE1;
 	UINT8 IR0;
 	UINT8 IR1;
-	UINT8 P0;
-	UINT8 P1;
-	UINT8 P2;
-	UINT8 P3;
 	UINT8 SYS;
 	UINT8 CKC;
 	UINT8 clock_changed;
 	UINT16 SP;
 	UINT8 PS0;
 	UINT8 PS1;
-	UINT8 P0C;
-	UINT8 P1C;
-	UINT8 P2C;
-	UINT8 P3C;
-	UINT8 IFLAGS;
+	UINT16 IFLAGS;
 	UINT8 CheckInterrupts;
 	int halted;
 	int icount;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	UINT8 internal_ram[0x500];
+	address_space *program;
+	UINT16 oldpc;
+	UINT8 register_ram[0x108];
 };
 
 INLINE sm8500_state *get_safe_token(running_device *device)
@@ -67,29 +67,56 @@
         0, 8, 2, 10, 4, 12, 6, 14
 };
 
-static UINT8 sm85cpu_mem_readbyte( sm8500_state *cpustate, UINT32 offset ) {
-	return ( offset < 0x10 ) ? cpustate->register_base[offset] : memory_read_byte_8be( cpustate->program, offset );
+INLINE void sm8500_get_sp( sm8500_state *cpustate )
+{
+	UINT16 data = cpustate->program->read_byte(0x1c) << 8;
+	cpustate->SP = cpustate->program->read_byte(0x1d);
+	if (cpustate->SYS&0x40) cpustate->SP |= data;
 }
 
-static void sm85cpu_mem_writebyte( sm8500_state *cpustate, UINT32 offset, UINT8 data ) {
-	if ( offset < 0x10 ) {
-		cpustate->register_base[offset] = data;
-	} else {
-		memory_write_byte_8be( cpustate->program, offset, data );
+static UINT8 sm85cpu_mem_readbyte( sm8500_state *cpustate, UINT32 offset )
+{
+	offset &= 0xffff;
+	return (offset < 0x10) ? cpustate->register_ram[offset + (cpustate->PS0 & 0xF8)]
+		: cpustate->program->read_byte( offset );
+}
+
+static void sm85cpu_mem_writebyte( sm8500_state *cpustate, UINT32 offset, UINT8 data )
+{
+	UINT8 i;
+	offset &= 0xffff;
+	if (offset < 0x10)
+		cpustate->register_ram[offset + (cpustate->PS0 & 0xF8)] = data;
+
+	cpustate->program->write_byte ( offset, data );
+
+	switch (offset)
+	{
+		case 0x10: cpustate->IE0 = data; break;
+		case 0x11: cpustate->IE1 = data; break;
+		case 0x12: cpustate->IR0 = data; break;
+		case 0x13: cpustate->IR1 = data; break;
+		case 0x19: cpustate->SYS = data; break;
+		case 0x1a: cpustate->CKC = data; break;
+		case 0x1c:
+		case 0x1d: sm8500_get_sp(cpustate); break;
+		case 0x1e: cpustate->PS0 = data;
+				for (i = 0; i < 16; i++)	// refresh register contents in debugger
+					cpustate->program->write_byte(i, sm85cpu_mem_readbyte(cpustate, i)); break;
+		case 0x1f: cpustate->PS1 = data; break;
 	}
 }
 
+
 INLINE UINT16 sm85cpu_mem_readword( sm8500_state *cpustate, UINT32 address )
 {
-	UINT16 value = (UINT16) sm85cpu_mem_readbyte( cpustate, address ) << 8;
-	value |= sm85cpu_mem_readbyte( cpustate, ( address + 1 ) & 0xffff );
-	return value;
+	return (sm85cpu_mem_readbyte( cpustate, address ) << 8) | (sm85cpu_mem_readbyte( cpustate, address+1 ));
 }
 
 INLINE void sm85cpu_mem_writeword( sm8500_state *cpustate, UINT32 address, UINT16 value )
 {
 	sm85cpu_mem_writebyte( cpustate, address, value >> 8 );
-	sm85cpu_mem_writebyte( cpustate, ( address + 1 ) & 0xffff, value & 0xff );
+	sm85cpu_mem_writebyte( cpustate, address+1, value );
 }
 
 static CPU_INIT( sm8500 )
@@ -106,7 +133,6 @@
 		cpustate->config.handle_dma = NULL;
 		cpustate->config.handle_timers = NULL;
 	}
-	cpustate->register_base = cpustate->internal_ram;
 }
 
 static CPU_RESET( sm8500 )
@@ -114,32 +140,33 @@
 	sm8500_state *cpustate = get_safe_token(device);
 
 	cpustate->PC = 0x1020;
-	cpustate->IE0 = 0;
-	cpustate->IE1 = 0;
-	cpustate->IR0 = 0;
-	cpustate->IR1 = 0;
-	cpustate->P0 = 0xFF;
-	cpustate->P1 = 0xFF;
-	cpustate->P2 = 0xFF;
-	cpustate->P3 = 0;
-	cpustate->SYS = 0;
-	cpustate->CKC = 0; cpustate->clock_changed = 0;
-	cpustate->PS1 = 0;
-	cpustate->register_base = cpustate->internal_ram;
+	cpustate->clock_changed = 0;
 	cpustate->halted = 0;
+	sm85cpu_mem_writeword(cpustate, 0x10, 0);                 // IE0, IE1
+	sm85cpu_mem_writeword(cpustate, 0x12, 0);                 // IR0, IR1
+	sm85cpu_mem_writeword(cpustate, 0x14, 0xffff);            // P0, P1
+	sm85cpu_mem_writeword(cpustate, 0x16, 0xff00);            // P2, P3
+	sm85cpu_mem_writebyte(cpustate, 0x19, 0);                 // SYS
+	sm85cpu_mem_writebyte(cpustate, 0x1a, 0);                 // CKC
+	sm85cpu_mem_writebyte(cpustate, 0x1f, 0);                 // PS1
+	sm85cpu_mem_writebyte(cpustate, 0x2b, 0xff);              // URTT
+	sm85cpu_mem_writebyte(cpustate, 0x2d, 0x42);              // URTS
+	sm85cpu_mem_writebyte(cpustate, 0x5f, 0x38);              // WDTC
 }
 
 static CPU_EXIT( sm8500 )
 {
 }
 
-#define PUSH_BYTE(X)	cpustate->SP = cpustate->SP - 1; \
-			if ( ( cpustate->SYS & 0x40 ) == 0 ) { \
-				cpustate->SP = cpustate->SP & 0xFF; \
-			} \
+#define PUSH_BYTE(X)	cpustate->SP--; \
+			if ( ( cpustate->SYS & 0x40 ) == 0 ) cpustate->SP &= 0xFF; \
 			sm85cpu_mem_writebyte( cpustate, cpustate->SP, X );
 
 INLINE void sm8500_do_interrupt(sm8500_state *cpustate, UINT16 vector) {
+	/* Get regs from ram */
+	sm8500_get_sp(cpustate);
+	cpustate->SYS = cpustate->program->read_byte(0x19);
+	cpustate->PS1 = cpustate->program->read_byte(0x1f);
 	/* Push PC */
 	PUSH_BYTE( cpustate->PC & 0xFF );
 	PUSH_BYTE( cpustate->PC >> 8 );
@@ -147,6 +174,10 @@
 	PUSH_BYTE( cpustate->PS1 );
 	/* Clear I flag */
 	cpustate->PS1 &= ~ 0x01;
+	/* save regs to ram */
+	cpustate->program->write_byte (0x1f, cpustate->PS1);
+	cpustate->program->write_byte (0x1d, cpustate->SP&0xFF);
+	if (cpustate->SYS&0x40) cpustate->program->write_byte(0x1c, cpustate->SP>>8);
 	/* Change PC to address stored at "vector" */
 	cpustate->PC = sm85cpu_mem_readword( cpustate, vector );
 }
@@ -157,13 +188,17 @@
 		while( irqline < 11 ) {
 			if ( cpustate->IFLAGS & ( 1 << irqline ) ) {
 				cpustate->halted = 0;
+				cpustate->IE0 = cpustate->program->read_byte(0x10);
+				cpustate->IE1 = cpustate->program->read_byte(0x11);
+				cpustate->IR0 = cpustate->program->read_byte(0x12);
+				cpustate->IR1 = cpustate->program->read_byte(0x13);
+				cpustate->PS0 = cpustate->program->read_byte(0x1e);
+				cpustate->PS1 = cpustate->program->read_byte(0x1f);
 				switch( irqline ) {
-				case ILL_INT:
-					sm8500_do_interrupt( cpustate, 0x101C );
-					break;
 				case WDT_INT:
-					sm8500_do_interrupt( cpustate, 0x101E );
+					sm8500_do_interrupt( cpustate, 0x101C );
 					break;
+				case ILL_INT:
 				case NMI_INT:
 					sm8500_do_interrupt( cpustate, 0x101E );
 					break;
@@ -217,6 +252,8 @@
 					break;
 				}
 				cpustate->IFLAGS &= ~ ( 1 << irqline );
+				cpustate->program->write_byte(0x12, cpustate->IR0);
+				cpustate->program->write_byte(0x13, cpustate->IR1);
 			}
 			irqline++;
 		}
@@ -227,7 +264,6 @@
 {
 	sm8500_state *cpustate = get_safe_token(device);
 	UINT8	op;
-	UINT16 oldpc;
 	int	mycycles;
 
 	do
@@ -238,15 +274,23 @@
 		UINT32	res;
 
 		debugger_instruction_hook(device, cpustate->PC);
-		oldpc = cpustate->PC;
+		cpustate->oldpc = cpustate->PC;
 		mycycles = 0;
 		sm8500_process_interrupts(cpustate);
 		if ( !cpustate->halted ) {
 			op = sm85cpu_mem_readbyte( cpustate, cpustate->PC++ );
+			cpustate->SYS = cpustate->program->read_byte(0x19);
+			cpustate->PS0 = cpustate->program->read_byte(0x1e);
+			cpustate->PS1 = cpustate->program->read_byte(0x1f);
+			sm8500_get_sp(cpustate);
 			switch( op )
 			{
 #include "sm85ops.h"
 			}
+			if (cpustate->SYS&0x40) cpustate->program->write_byte(0x1c,cpustate->SP>>8);
+			cpustate->program->write_byte(0x1d,cpustate->SP&0xFF);
+			sm85cpu_mem_writebyte(cpustate,0x1e,cpustate->PS0);	// need to update debugger
+			cpustate->program->write_byte(0x1f,cpustate->PS1);
 		} else {
 			mycycles = 4;
 			if ( cpustate->config.handle_dma ) {
@@ -278,8 +322,8 @@
 	case STATE_GENPC:
 	case SM8500_PC:		return cpustate->PC;
 	case STATE_GENSP:
-	case SM8500_SP:		return ( cpustate->SYS & 0x40 ) ? cpustate->SP : cpustate->SP & 0xFF ;
-	case SM8500_PS:		return ( cpustate->PS0 << 8 ) | cpustate->PS1;
+	case SM8500_SP:		return cpustate->SP;
+	case SM8500_PS:		return sm85cpu_mem_readword( cpustate, 0x1e );
 	case SM8500_SYS16:	return cpustate->SYS;
 	case SM8500_RR0:	return sm85cpu_mem_readword( cpustate, 0x00 );
 	case SM8500_RR2:	return sm85cpu_mem_readword( cpustate, 0x02 );
@@ -289,24 +333,24 @@
 	case SM8500_RR10:	return sm85cpu_mem_readword( cpustate, 0x0A );
 	case SM8500_RR12:	return sm85cpu_mem_readword( cpustate, 0x0C );
 	case SM8500_RR14:	return sm85cpu_mem_readword( cpustate, 0x0E );
-	case SM8500_IE0:	return cpustate->IE0;
-	case SM8500_IE1:	return cpustate->IE1;
-	case SM8500_IR0:	return cpustate->IR0;
-	case SM8500_IR1:	return cpustate->IR1;
-	case SM8500_P0:		return cpustate->P0;
-	case SM8500_P1:		return cpustate->P1;
-	case SM8500_P2:		return cpustate->P2;
-	case SM8500_P3:		return cpustate->P3;
-	case SM8500_SYS:	return cpustate->SYS;
-	case SM8500_CKC:	return cpustate->CKC;
-	case SM8500_SPH:	return (cpustate->SP >> 8);
-	case SM8500_SPL:	return cpustate->SP & 0xFF;
-	case SM8500_PS0:	return cpustate->PS0;
-	case SM8500_PS1:	return cpustate->PS1;
-	case SM8500_P0C:	return cpustate->P0C;
-	case SM8500_P1C:	return cpustate->P1C;
-	case SM8500_P2C:	return cpustate->P2C;
-	case SM8500_P3C:	return cpustate->P3C;
+	case SM8500_IE0:	return sm85cpu_mem_readbyte( cpustate, 0x10 );
+	case SM8500_IE1:	return sm85cpu_mem_readbyte( cpustate, 0x11 );
+	case SM8500_IR0:	return sm85cpu_mem_readbyte( cpustate, 0x12 );
+	case SM8500_IR1:	return sm85cpu_mem_readbyte( cpustate, 0x13 );
+	case SM8500_P0:		return sm85cpu_mem_readbyte( cpustate, 0x14 );
+	case SM8500_P1:		return sm85cpu_mem_readbyte( cpustate, 0x15 );
+	case SM8500_P2:		return sm85cpu_mem_readbyte( cpustate, 0x16 );
+	case SM8500_P3:		return sm85cpu_mem_readbyte( cpustate, 0x17 );
+	case SM8500_SYS:	return sm85cpu_mem_readbyte( cpustate, 0x19 );
+	case SM8500_CKC:	return sm85cpu_mem_readbyte( cpustate, 0x1a );
+	case SM8500_SPH:	return sm85cpu_mem_readbyte( cpustate, 0x1c );
+	case SM8500_SPL:	return sm85cpu_mem_readbyte( cpustate, 0x1d );
+	case SM8500_PS0:	return sm85cpu_mem_readbyte( cpustate, 0x1e );
+	case SM8500_PS1:	return sm85cpu_mem_readbyte( cpustate, 0x1f );
+	case SM8500_P0C:	return sm85cpu_mem_readbyte( cpustate, 0x20 );
+	case SM8500_P1C:	return sm85cpu_mem_readbyte( cpustate, 0x21 );
+	case SM8500_P2C:	return sm85cpu_mem_readbyte( cpustate, 0x22 );
+	case SM8500_P3C:	return sm85cpu_mem_readbyte( cpustate, 0x23 );
 	}
 	return 0;
 }
@@ -318,9 +362,9 @@
 	case STATE_GENPC:
 	case SM8500_PC:		cpustate->PC = val; break;
 	case STATE_GENSP:
-	case SM8500_SP:		cpustate->SP = val; break;
-	case SM8500_PS:		sm8500_set_reg( cpustate, SM8500_PS0, ( val >> 8 ) & 0xFF ); sm8500_set_reg( cpustate, SM8500_PS1, val & 0xFF ); break;
-	case SM8500_SYS16:	cpustate->SYS = val; break;
+	case SM8500_SP:		cpustate->SP = val; cpustate->program->write_byte(0x1d, val&0xff); if (cpustate->SYS&0x40) cpustate->program->write_byte(0x1c, val>>8); break;
+	case SM8500_PS:		sm85cpu_mem_writeword( cpustate, 0x1e, val); break;
+	case SM8500_SYS16:	val&=0xff; sm85cpu_mem_writebyte( cpustate, 0x19, val); break;
 	case SM8500_RR0:	sm85cpu_mem_writeword( cpustate, 0x00, val); break;
 	case SM8500_RR2:	sm85cpu_mem_writeword( cpustate, 0x02, val); break;
 	case SM8500_RR4:	sm85cpu_mem_writeword( cpustate, 0x04, val); break;
@@ -329,29 +373,31 @@
 	case SM8500_RR10:	sm85cpu_mem_writeword( cpustate, 0x0A, val); break;
 	case SM8500_RR12:	sm85cpu_mem_writeword( cpustate, 0x0C, val); break;
 	case SM8500_RR14:	sm85cpu_mem_writeword( cpustate, 0x0E, val); break;
-	case SM8500_IE0:	cpustate->IE0 = val; break;
-	case SM8500_IE1:	cpustate->IE1 = val; break;
-	case SM8500_IR0:	cpustate->IR0 = val; break;
-	case SM8500_IR1:	cpustate->IR1 = val; break;
-	case SM8500_P0:		cpustate->P0 = val; break;
-	case SM8500_P1:		cpustate->P1 = val; break;
-	case SM8500_P2:		cpustate->P2 = val; break;
-	case SM8500_P3:		cpustate->P3 = val; break;
-	case SM8500_SYS:	cpustate->SYS = val; break;
-	case SM8500_CKC:	cpustate->CKC = val; if ( val & 0x80 ) { cpustate->clock_changed = 1; }; break;
-	case SM8500_SPH:	cpustate->SP = ( ( val & 0xFF ) << 8 ) | ( cpustate->SP & 0xFF ); break;
-	case SM8500_SPL:	cpustate->SP = ( cpustate->SP & 0xFF00 ) | ( val & 0xFF ); break;
-	case SM8500_PS0:	cpustate->PS0 = val; cpustate->register_base = cpustate->internal_ram + ( val & 0xF8 ); break;
-	case SM8500_PS1:	cpustate->PS1 = val; break;
-	case SM8500_P0C:	cpustate->P0C = val; break;
-	case SM8500_P1C:	cpustate->P1C = val; break;
-	case SM8500_P2C:	cpustate->P2C = val; break;
-	case SM8500_P3C:	cpustate->P3C = val; break;
+	case SM8500_IE0:	sm85cpu_mem_writebyte( cpustate, 0x10, val); break;
+	case SM8500_IE1:	sm85cpu_mem_writebyte( cpustate, 0x11, val); break;
+	case SM8500_IR0:	sm85cpu_mem_writebyte( cpustate, 0x12, val); break;
+	case SM8500_IR1:	sm85cpu_mem_writebyte( cpustate, 0x13, val); break;
+	case SM8500_P0:		sm85cpu_mem_writebyte( cpustate, 0x14, val); break;
+	case SM8500_P1:		sm85cpu_mem_writebyte( cpustate, 0x15, val); break;
+	case SM8500_P2:		sm85cpu_mem_writebyte( cpustate, 0x16, val); break;
+	case SM8500_P3:		sm85cpu_mem_writebyte( cpustate, 0x17, val); break;
+	case SM8500_SYS:	sm85cpu_mem_writebyte( cpustate, 0x19, val); break;
+	case SM8500_CKC:	sm85cpu_mem_writebyte( cpustate, 0x1a, val); if ( val & 0x80 ) { cpustate->clock_changed = 1; }; break;
+	case SM8500_SPH:	sm85cpu_mem_writebyte( cpustate, 0x1c, val); break;
+	case SM8500_SPL:	sm85cpu_mem_writebyte( cpustate, 0x1d, val); break;
+	case SM8500_PS0:	sm85cpu_mem_writebyte( cpustate, 0x1e, val); break;
+	case SM8500_PS1:	sm85cpu_mem_writebyte( cpustate, 0x1f, val); break;
+	case SM8500_P0C:	sm85cpu_mem_writebyte( cpustate, 0x20, val); break;
+	case SM8500_P1C:	sm85cpu_mem_writebyte( cpustate, 0x21, val); break;
+	case SM8500_P2C:	sm85cpu_mem_writebyte( cpustate, 0x22, val); break;
+	case SM8500_P3C:	sm85cpu_mem_writebyte( cpustate, 0x23, val); break;
 	}
 }
 
 static void sm8500_set_irq_line( sm8500_state *cpustate, int irqline, int state )
 {
+	cpustate->IR0 = cpustate->program->read_byte(0x12);
+	cpustate->IR1 = cpustate->program->read_byte(0x13);
 	if ( state == ASSERT_LINE ) {
 		cpustate->IFLAGS |= ( 0x01 << irqline );
 		cpustate->CheckInterrupts = 1;
@@ -381,12 +427,8 @@
 			cpustate->CheckInterrupts = 0;
 		}
 	}
-}
-
-UINT8 *sm8500_get_internal_ram(legacy_cpu_device *device)
-{
-	sm8500_state *cpustate = get_safe_token(device);
-	return cpustate->internal_ram;
+	cpustate->program->write_byte(0x12, cpustate->IR0);
+	cpustate->program->write_byte(0x13, cpustate->IR1);
 }
 
 static CPU_SET_INFO( sm8500 )
@@ -438,7 +480,7 @@
 	case CPUINFO_INT_REGISTER + SM8500_P1C:
 	case CPUINFO_INT_REGISTER + SM8500_P2C:
 	case CPUINFO_INT_REGISTER + SM8500_P3C:
-							sm8500_set_reg( cpustate, state - CPUINFO_INT_REGISTER, info->i ); break;
+		sm8500_set_reg( cpustate, state - CPUINFO_INT_REGISTER, info->i ); break;
 
 	}
 }
@@ -475,7 +517,10 @@
 	case CPUINFO_INT_INPUT_STATE + 4:
 	case CPUINFO_INT_INPUT_STATE + 5:
 	case CPUINFO_INT_INPUT_STATE + 6:
-	case CPUINFO_INT_INPUT_STATE + 7:			info->i = cpustate->IFLAGS & ( 1 << (state - CPUINFO_INT_INPUT_STATE)); break;
+	case CPUINFO_INT_INPUT_STATE + 7:
+	case CPUINFO_INT_INPUT_STATE + 8:
+	case CPUINFO_INT_INPUT_STATE + 9:
+	case CPUINFO_INT_INPUT_STATE + 10:			info->i = cpustate->IFLAGS & ( 1 << (state - CPUINFO_INT_INPUT_STATE)); break;
 	case CPUINFO_INT_REGISTER + SM8500_RR0:
 	case CPUINFO_INT_REGISTER + SM8500_RR2:
 	case CPUINFO_INT_REGISTER + SM8500_RR4:
@@ -509,7 +554,7 @@
 								info->i = sm8500_get_reg( cpustate, state - CPUINFO_INT_REGISTER ); break;
 	case CPUINFO_INT_REGISTER + STATE_GENPC:			info->i = sm8500_get_reg( cpustate, SM8500_PC ); break;
 	case CPUINFO_INT_REGISTER + STATE_GENSP:			info->i = sm8500_get_reg( cpustate, SM8500_SP ); break;
-	case CPUINFO_INT_PREVIOUSPC:				info->i = 0x0000; break;
+	case CPUINFO_INT_PREVIOUSPC:				info->i = cpustate->oldpc; break;
 
 
 	case CPUINFO_FCT_SET_INFO:				info->setinfo = CPU_SET_INFO_NAME(sm8500); break;
@@ -548,7 +593,7 @@
 	case CPUINFO_STR_REGISTER + SM8500_PC:			sprintf(info->s, "PC:%04X", cpustate->PC); break;
 	case CPUINFO_STR_REGISTER + SM8500_SP:			sprintf(info->s, "SP:%04X", cpustate->SP); break;
 	case CPUINFO_STR_REGISTER + SM8500_PS:			sprintf(info->s, "PS:%04X", ( cpustate->PS0 << 8 ) | cpustate->PS1 ); break;
-	case CPUINFO_STR_REGISTER + SM8500_SYS16:		sprintf(info->s, "SYS:%04X", cpustate->SYS ); break;
+	case CPUINFO_STR_REGISTER + SM8500_SYS16:		sprintf(info->s, "SYS:%02X", cpustate->SYS ); break;
 	}
 }
 
diff -Nru src-old/emu/cpu/sm8500/sm8500.h src/emu/cpu/sm8500/sm8500.h
--- src-old/emu/cpu/sm8500/sm8500.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/sm8500/sm8500.h	2010-08-20 05:21:17.000000000 -0700
@@ -36,6 +36,4 @@
 
 extern CPU_DISASSEMBLE( sm8500 );
 
-UINT8 *sm8500_get_internal_ram(legacy_cpu_device *device);
-
 #endif /* __SM8500_H__ */
diff -Nru src-old/emu/cpu/sm8500/sm8500d.c src/emu/cpu/sm8500/sm8500d.c
--- src-old/emu/cpu/sm8500/sm8500d.c	2010-04-10 11:02:28.000000000 -0700
+++ src/emu/cpu/sm8500/sm8500d.c	2010-08-20 05:21:17.000000000 -0700
@@ -41,7 +41,7 @@
 	"iret", "jmp",  "mov",  "movm", "movw",  "mult", "neg",  "nop",  "or",
 	"orw",  "pop",  "popw", "push", "pushw", "ret",  "rl",   "rlc",
 	"rr",   "rrc",  "sbc",  "sbcw", "setc", "sll",   "sra",  "srl",  "stop",
-	"sub",  "subw", "swap", "xor",  "xorw", "mov PS0,", "invalid", "dm?",
+	"sub",  "subw", "swap", "xor",  "xorw", "mov  PS0,", "invalid", "dm?",
 /* unknowns */
 "unk5A", "unk5B",
 
diff -Nru src-old/emu/cpu/sm8500/sm85ops.h src/emu/cpu/sm8500/sm85ops.h
--- src-old/emu/cpu/sm8500/sm85ops.h	2009-12-28 02:09:20.000000000 -0800
+++ src/emu/cpu/sm8500/sm85ops.h	2010-08-20 05:21:17.000000000 -0700
@@ -488,17 +488,13 @@
 			case 0x0F: /* NC  */ if ( ! (cpustate->PS1 & FLAG_C) ) res = 1; break; \
 			}
 
-#define PUSH8(X)	cpustate->SP = cpustate->SP - 1; \
-			if ( ( cpustate->SYS & 0x40 ) == 0 ) { \
-				cpustate->SP = cpustate->SP & 0xFF; \
-			} \
+#define PUSH8(X)	cpustate->SP--; \
+			if ( ( cpustate->SYS & 0x40 ) == 0 ) cpustate->SP &= 0xFF; \
 			sm85cpu_mem_writebyte( cpustate, cpustate->SP, X );
 
 #define POP8(X)		X = sm85cpu_mem_readbyte( cpustate, cpustate->SP ); \
-			cpustate->SP = cpustate->SP + 1; \
-			if ( ( cpustate->SYS & 0x40 ) == 0 ) { \
-				cpustate->SP = cpustate->SP & 0xFF; \
-			}
+			cpustate->SP++; \
+			if ( ( cpustate->SYS & 0x40 ) == 0 ) cpustate->SP &= 0xFF;
 
 case 0x00:	/* CLR R - 4 cycles - Flags affected: -------- */
 	ARG_R;
@@ -910,7 +906,7 @@
 	break;
 case 0x2E:	/* MOV PS0,#00 - 4 cycles - Flags affected: -------- */
 	ARG_R;
-	cpustate->PS0 = r1; cpustate->register_base = cpustate->internal_ram + ( r1 & 0xF8 );
+	cpustate->PS0 = r1;
         mycycles += 4;
 	break;
 case 0x2F:	/* BTST R,i - 6 cycles - Flags affected: -Z-0---- */
@@ -1280,7 +1276,11 @@
 	break;
 case 0x5B:	/* unk5B - 6,7,11,8,7 cycles */
 logerror( "%04X: unk%02x\n", cpustate->PC-1,op );
-	ARG_ad16;
+/* NOTE: This unknown command is used in several carts, the code below allows those carts to boot */
+	ARG_iR;
+	r1 = r2 & 7;
+	res = sm85cpu_mem_readbyte( cpustate, r1 ) + 1;
+	sm85cpu_mem_writebyte( cpustate, r1, res );
 	mycycles += 6;
 	break;
 case 0x5C:	/* DIV RRr,RRs - 47 cycles - Flags affected: -Z-V---- */
diff -Nru src-old/emu/cpu/spc700/spc700.c src/emu/cpu/spc700/spc700.c
--- src-old/emu/cpu/spc700/spc700.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/spc700/spc700.c	2010-08-19 01:27:05.000000000 -0700
@@ -88,7 +88,7 @@
 	uint ir;		/* Instruction Register */
 	device_irq_callback int_ack;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	uint stopped;	/* stopped status */
 	int ICount;
 	uint source;
@@ -247,15 +247,15 @@
 /* ================================= MAME ================================= */
 /* ======================================================================== */
 
-#define spc700_read_8(addr) memory_read_byte_8le(cpustate->program,addr)
-#define spc700_write_8(addr,data) memory_write_byte_8le(cpustate->program,addr,data)
+#define spc700_read_8(addr) cpustate->program->read_byte(addr)
+#define spc700_write_8(addr,data) cpustate->program->write_byte(addr,data)
 
 #define spc700_read_8_direct(A)     spc700_read_8(A)
 #define spc700_write_8_direct(A, V) spc700_write_8(A, V)
 //#define spc700_read_instruction(A)    memory_decrypted_read_byte(cpustate->program,A)
 //#define spc700_read_8_immediate(A)    memory_raw_read_byte(cpustate->program,A)
-#define spc700_read_instruction(A)    memory_read_byte_8le(cpustate->program,A)
-#define spc700_read_8_immediate(A)    memory_read_byte_8le(cpustate->program,A)
+#define spc700_read_instruction(A)    cpustate->program->read_byte(A)
+#define spc700_read_8_immediate(A)    cpustate->program->read_byte(A)
 #define spc700_jumping(A)
 #define spc700_branching(A)
 
diff -Nru src-old/emu/cpu/ssem/ssem.c src/emu/cpu/ssem/ssem.c
--- src-old/emu/cpu/ssem/ssem.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/ssem/ssem.c	2010-08-19 01:27:05.000000000 -0700
@@ -22,7 +22,7 @@
     UINT32 halt;
 
     legacy_cpu_device *device;
-    const address_space *program;
+    address_space *program;
     int icount;
 };
 
@@ -67,10 +67,10 @@
     // the address value to get the appropriate byte index.
     address <<= 2;
 
-    v |= memory_read_byte(cpustate->program, address + 0) << 24;
-    v |= memory_read_byte(cpustate->program, address + 1) << 16;
-    v |= memory_read_byte(cpustate->program, address + 2) <<  8;
-    v |= memory_read_byte(cpustate->program, address + 3) <<  0;
+    v |= cpustate->program->read_byte(address + 0) << 24;
+    v |= cpustate->program->read_byte(address + 1) << 16;
+    v |= cpustate->program->read_byte(address + 2) <<  8;
+    v |= cpustate->program->read_byte(address + 3) <<  0;
 
     return reverse(v);
 }
@@ -84,10 +84,10 @@
     // the address value to get the appropriate byte index.
     address <<= 2;
 
-    memory_write_byte(cpustate->program, address + 0, (v >> 24) & 0x000000ff);
-    memory_write_byte(cpustate->program, address + 1, (v >> 16) & 0x000000ff);
-    memory_write_byte(cpustate->program, address + 2, (v >>  8) & 0x000000ff);
-    memory_write_byte(cpustate->program, address + 3, (v >>  0) & 0x000000ff);
+    cpustate->program->write_byte(address + 0, (v >> 24) & 0x000000ff);
+    cpustate->program->write_byte(address + 1, (v >> 16) & 0x000000ff);
+    cpustate->program->write_byte(address + 2, (v >>  8) & 0x000000ff);
+    cpustate->program->write_byte(address + 3, (v >>  0) & 0x000000ff);
     return;
 }
 
@@ -130,7 +130,7 @@
         {
             for( i = 0; i < 0x80; i++ )
             {
-                fputc(memory_read_byte_32be(cpustate->program, i), store);
+                fputc(cpustate->program->read_byte(i), store);
             }
             fclose(store);
         }
diff -Nru src-old/emu/cpu/ssp1601/ssp1601.c src/emu/cpu/ssp1601/ssp1601.c
--- src-old/emu/cpu/ssp1601/ssp1601.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/ssp1601/ssp1601.c	2010-08-19 09:10:19.000000000 -0700
@@ -53,8 +53,9 @@
 	int g_cycles;
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 };
 
 INLINE ssp1601_state_t *get_safe_token(running_device *device)
@@ -83,8 +84,8 @@
 
 #define PPC    ssp1601_state->ppc.w.h
 
-#define FETCH() memory_decrypted_read_word(ssp1601_state->program, rPC++ << 1)
-#define PROGRAM_WORD(a) memory_read_word(ssp1601_state->program, (a) << 1)
+#define FETCH() ssp1601_state->direct->read_decrypted_word(rPC++ << 1)
+#define PROGRAM_WORD(a) ssp1601_state->program->read_word((a) << 1)
 #define GET_PPC_OFFS() PPC
 
 #define REG_READ(ssp1601_state,r) (((r) <= 4) ? ssp1601_state->gr[r].w.h : reg_read_handlers[r](ssp1601_state, r))
@@ -255,13 +256,13 @@
 static UINT32 read_ext(ssp1601_state_t *ssp1601_state, int reg)
 {
 	reg &= 7;
-	return memory_read_word_16be(ssp1601_state->io, (reg << 1));
+	return ssp1601_state->io->read_word((reg << 1));
 }
 
 static void write_ext(ssp1601_state_t *ssp1601_state, int reg, UINT32 d)
 {
 	reg &= 7;
-	memory_write_word_16be(ssp1601_state->io, (reg << 1), d);
+	ssp1601_state->io->write_word((reg << 1), d);
 }
 
 // 4
@@ -529,6 +530,7 @@
 	ssp1601_state->gr[0].w.h = 0xffff; // constant reg
 	ssp1601_state->device = device;
 	ssp1601_state->program = device->space(AS_PROGRAM);
+	ssp1601_state->direct = &ssp1601_state->program->direct();
 	ssp1601_state->io = device->space(AS_IO);
 
 }
diff -Nru src-old/emu/cpu/superfx/superfx.c src/emu/cpu/superfx/superfx.c
--- src-old/emu/cpu/superfx/superfx.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/superfx/superfx.c	2010-08-19 01:27:05.000000000 -0700
@@ -62,7 +62,7 @@
 	pixelcache_t pixelcache[2];
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 };
 
@@ -179,12 +179,12 @@
 
 INLINE UINT8 superfx_bus_read(superfx_state *cpustate, UINT32 addr)
 {
-	return memory_read_byte(cpustate->program, addr);
+	return cpustate->program->read_byte(addr);
 }
 
 INLINE void superfx_bus_write(superfx_state *cpustate, UINT32 addr, UINT8 data)
 {
-	memory_write_byte(cpustate->program, addr, data);
+	cpustate->program->write_byte(addr, data);
 }
 
 INLINE void superfx_pixelcache_flush(superfx_state *cpustate, INT32 line)
diff -Nru src-old/emu/cpu/t11/t11.c src/emu/cpu/t11/t11.c
--- src-old/emu/cpu/t11/t11.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/t11/t11.c	2010-08-19 09:10:19.000000000 -0700
@@ -34,7 +34,8 @@
     int					icount;
 	device_irq_callback	irq_callback;
 	legacy_cpu_device *		device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 };
 
 
@@ -74,7 +75,7 @@
 
 INLINE int ROPCODE(t11_state *cpustate)
 {
-	int val = memory_decrypted_read_word(cpustate->program, cpustate->PC);
+	int val = cpustate->direct->read_decrypted_word(cpustate->PC);
 	cpustate->PC += 2;
 	return val;
 }
@@ -82,25 +83,25 @@
 
 INLINE int RBYTE(t11_state *cpustate, int addr)
 {
-	return memory_read_byte_16le(cpustate->program, addr);
+	return cpustate->program->read_byte(addr);
 }
 
 
 INLINE void WBYTE(t11_state *cpustate, int addr, int data)
 {
-	memory_write_byte_16le(cpustate->program, addr, data);
+	cpustate->program->write_byte(addr, data);
 }
 
 
 INLINE int RWORD(t11_state *cpustate, int addr)
 {
-	return memory_read_word_16le(cpustate->program, addr & 0xfffe);
+	return cpustate->program->read_word(addr & 0xfffe);
 }
 
 
 INLINE void WWORD(t11_state *cpustate, int addr, int data)
 {
-	memory_write_word_16le(cpustate->program, addr & 0xfffe, data);
+	cpustate->program->write_word(addr & 0xfffe, data);
 }
 
 
@@ -264,6 +265,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 
 	state_save_register_device_item(device, 0, cpustate->ppc.w.l);
 	state_save_register_device_item(device, 0, cpustate->reg[0].w.l);
diff -Nru src-old/emu/cpu/tlcs90/tlcs90.c src/emu/cpu/tlcs90/tlcs90.c
--- src-old/emu/cpu/tlcs90/tlcs90.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/cpu/tlcs90/tlcs90.c	2010-08-19 01:27:05.000000000 -0700
@@ -32,8 +32,8 @@
 	UINT16		irq_state, irq_mask;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	address_space *io;
 	int		icount;
 	int			extra_cycles;		// extra cycles for interrupts
 	UINT8		internal_registers[48];
@@ -177,16 +177,16 @@
 #define R16D8( N,R,I )		cpustate->mode##N = MODE_R16D8;	cpustate->r##N = R;	cpustate->r##N##b = I;
 #define R16R8( N,R,g )		cpustate->mode##N = MODE_R16R8;	cpustate->r##N = R;	cpustate->r##N##b = g;
 
-INLINE UINT8  RM8 (t90_Regs *cpustate, UINT32 a)	{ return memory_read_byte_8le( cpustate->program, a ); }
+INLINE UINT8  RM8 (t90_Regs *cpustate, UINT32 a)	{ return cpustate->program->read_byte( a ); }
 INLINE UINT16 RM16(t90_Regs *cpustate, UINT32 a)	{ return RM8(cpustate,a) | (RM8( cpustate, (a+1) & 0xffff ) << 8); }
 
-INLINE void WM8 (t90_Regs *cpustate, UINT32 a, UINT8  v)	{ memory_write_byte_8le( cpustate->program, a, v ); }
+INLINE void WM8 (t90_Regs *cpustate, UINT32 a, UINT8  v)	{ cpustate->program->write_byte( a, v ); }
 INLINE void WM16(t90_Regs *cpustate, UINT32 a, UINT16 v)	{ WM8(cpustate,a,v);	WM8( cpustate, (a+1) & 0xffff, v >> 8); }
 
-INLINE UINT8  RX8 (t90_Regs *cpustate, UINT32 a, UINT32 base)	{ return memory_read_byte_8le( cpustate->program, base | a ); }
+INLINE UINT8  RX8 (t90_Regs *cpustate, UINT32 a, UINT32 base)	{ return cpustate->program->read_byte( base | a ); }
 INLINE UINT16 RX16(t90_Regs *cpustate, UINT32 a, UINT32 base)	{ return RX8(cpustate,a,base) | (RX8( cpustate, (a+1) & 0xffff, base ) << 8); }
 
-INLINE void WX8 (t90_Regs *cpustate, UINT32 a, UINT8  v, UINT32 base)	{ memory_write_byte_8le( cpustate->program, base | a, v ); }
+INLINE void WX8 (t90_Regs *cpustate, UINT32 a, UINT8  v, UINT32 base)	{ cpustate->program->write_byte( base | a, v ); }
 INLINE void WX16(t90_Regs *cpustate, UINT32 a, UINT16 v, UINT32 base)	{ WX8(cpustate,a,v,base);	WX8( cpustate, (a+1) & 0xffff, v >> 8, base); }
 
 INLINE UINT8  READ8(t90_Regs *cpustate)	{ UINT8 b0 = RM8( cpustate, cpustate->addr++ ); cpustate->addr &= 0xffff; return b0; }
@@ -2284,7 +2284,7 @@
 {
 	t90_Regs *cpustate = get_safe_token(space->cpu);
 
-	#define RIO		memory_read_byte_8le( cpustate->io, T90_IOBASE+offset )
+	#define RIO		cpustate->io->read_byte( T90_IOBASE+offset )
 
 	UINT8 data = cpustate->internal_registers[offset];
 	switch ( T90_IOBASE + offset )
@@ -2495,7 +2495,7 @@
 
 static WRITE8_HANDLER( t90_internal_registers_w )
 {
-	#define WIO		memory_write_byte_8le( cpustate->io, T90_IOBASE+offset, data )
+	#define WIO		cpustate->io->write_byte( T90_IOBASE+offset, data )
 
 	t90_Regs *cpustate = get_safe_token(space->cpu);
 	UINT8 out_mask;
diff -Nru src-old/emu/cpu/tlcs900/tlcs900.c src/emu/cpu/tlcs900/tlcs900.c
--- src-old/emu/cpu/tlcs900/tlcs900.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tlcs900/tlcs900.c	2010-08-19 01:27:05.000000000 -0700
@@ -73,7 +73,7 @@
 	int regbank;
 	device_irq_callback irqcallback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 };
 
 
@@ -195,8 +195,8 @@
 #define FLAG_SF		0x80
 
 
-#define RDMEM(addr)			memory_read_byte_8le( cpustate->program, addr )
-#define WRMEM(addr,data)	memory_write_byte_8le( cpustate->program, addr, data )
+#define RDMEM(addr)			cpustate->program->read_byte( addr )
+#define WRMEM(addr,data)	cpustate->program->write_byte( addr, data )
 #define RDOP()				RDMEM( cpustate->pc.d ); cpustate->pc.d++
 #define RDMEMW(addr)			( RDMEM(addr) | ( RDMEM(addr+1) << 8 ) )
 #define RDMEML(addr)			( RDMEMW(addr) | ( RDMEMW(addr+2) << 16 ) )
diff -Nru src-old/emu/cpu/tms0980/tms0980.c src/emu/cpu/tms0980/tms0980.c
--- src-old/emu/cpu/tms0980/tms0980.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms0980/tms0980.c	2010-08-19 01:27:05.000000000 -0700
@@ -268,8 +268,8 @@
 	UINT8	byte_size;		/* 8 or 9 bit bytes */
 	const UINT32 *decode_table;
 	const tms0980_config	*config;
-	const address_space *program;
-	const address_space *data;
+	address_space *program;
+	address_space *data;
 };
 
 
@@ -814,7 +814,7 @@
 			/* fetch: rom address 0 */
 			/* execute: read ram, alu input, execute br/call, k input valid */
 			tms0980_set_cki_bus( device );
-			cpustate->ram_data = memory_read_byte_8le( cpustate->data, cpustate->ram_address );
+			cpustate->ram_data = cpustate->data->read_byte( cpustate->ram_address );
 			cpustate->status = 1;
 			cpustate->p = 0;
 			cpustate->n = 0;
@@ -909,22 +909,22 @@
 				}
 				if ( cpustate->decode & M_STO )
 				{
-					memory_write_byte_8le( cpustate->data, cpustate->ram_address, cpustate->a );
+					cpustate->data->write_byte( cpustate->ram_address, cpustate->a );
 				}
 				if ( cpustate->decode & M_CKM )
 				{
-					memory_write_byte_8le( cpustate->data, cpustate->ram_address, cpustate->cki_bus );
+					cpustate->data->write_byte( cpustate->ram_address, cpustate->cki_bus );
 				}
 			}
 			else
 			{
 				if ( cpustate->decode & F_SBIT )
 				{
-					memory_write_byte_8le( cpustate->data, cpustate->ram_address, cpustate->ram_data | tms0980_bit_value[ cpustate->opcode & 0x03 ] );
+					cpustate->data->write_byte( cpustate->ram_address, cpustate->ram_data | tms0980_bit_value[ cpustate->opcode & 0x03 ] );
 				}
 				if ( cpustate->decode & F_RBIT )
 				{
-					memory_write_byte_8le( cpustate->data, cpustate->ram_address, cpustate->ram_data & tms0980_nbit_value[ cpustate->opcode & 0x03 ] );
+					cpustate->data->write_byte( cpustate->ram_address, cpustate->ram_data & tms0980_nbit_value[ cpustate->opcode & 0x03 ] );
 				}
 				if ( cpustate->decode & F_SETR )
 				{
@@ -1028,12 +1028,12 @@
 			if ( cpustate->byte_size > 8 )
 			{
 				debugger_instruction_hook( device, cpustate->rom_address << 1 );
-				cpustate->opcode = memory_read_word_16be( cpustate->program, cpustate->rom_address << 1 ) & 0x1FF;
+				cpustate->opcode = cpustate->program->read_word( cpustate->rom_address << 1 ) & 0x1FF;
 			}
 			else
 			{
 				debugger_instruction_hook( device, cpustate->rom_address );
-				cpustate->opcode = memory_read_word_8le( cpustate->program, cpustate->rom_address ) & 0xFF;
+				cpustate->opcode = cpustate->program->read_word( cpustate->rom_address ) & 0xFF;
 			}
 			tms0980_next_pc( cpustate );
 			if (LOG)
diff -Nru src-old/emu/cpu/tms32010/tms32010.c src/emu/cpu/tms32010/tms32010.c
--- src-old/emu/cpu/tms32010/tms32010.c	2010-07-27 08:34:59.000000000 -0700
+++ src/emu/cpu/tms32010/tms32010.c	2010-08-19 09:10:19.000000000 -0700
@@ -98,9 +98,10 @@
 	int		addr_mask;
 
 	legacy_cpu_device *device;
-	const	address_space *program;
-	const	address_space *data;
-	const	address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 };
 
 INLINE tms32010_state *get_safe_token(running_device *device)
@@ -148,21 +149,21 @@
  *  Read the state of the BIO pin
  */
 
-#define TMS32010_BIO_In (memory_read_word_16be(cpustate->io, TMS32010_BIO<<1))
+#define TMS32010_BIO_In (cpustate->io->read_word(TMS32010_BIO<<1))
 
 
 /****************************************************************************
  *  Input a word from given I/O port
  */
 
-#define TMS32010_In(Port) (memory_read_word_16be(cpustate->io, (Port)<<1))
+#define TMS32010_In(Port) (cpustate->io->read_word((Port)<<1))
 
 
 /****************************************************************************
  *  Output a word to given I/O port
  */
 
-#define TMS32010_Out(Port,Value) (memory_write_word_16be(cpustate->io, (Port)<<1,Value))
+#define TMS32010_Out(Port,Value) (cpustate->io->write_word((Port)<<1,Value))
 
 
 
@@ -170,14 +171,14 @@
  *  Read a word from given ROM memory location
  */
 
-#define TMS32010_ROM_RDMEM(A) (memory_read_word_16be(cpustate->program, (A)<<1))
+#define TMS32010_ROM_RDMEM(A) (cpustate->program->read_word((A)<<1))
 
 
 /****************************************************************************
  *  Write a word to given ROM memory location
  */
 
-#define TMS32010_ROM_WRMEM(A,V) (memory_write_word_16be(cpustate->program, (A)<<1,V))
+#define TMS32010_ROM_WRMEM(A,V) (cpustate->program->write_word((A)<<1,V))
 
 
 
@@ -185,14 +186,14 @@
  *  Read a word from given RAM memory location
  */
 
-#define TMS32010_RAM_RDMEM(A) (memory_read_word_16be(cpustate->data, (A)<<1))
+#define TMS32010_RAM_RDMEM(A) (cpustate->data->read_word((A)<<1))
 
 
 /****************************************************************************
  *  Write a word to given RAM memory location
  */
 
-#define TMS32010_RAM_WRMEM(A,V) (memory_write_word_16be(cpustate->data, (A)<<1,V))
+#define TMS32010_RAM_WRMEM(A,V) (cpustate->data->write_word((A)<<1,V))
 
 
 
@@ -202,7 +203,7 @@
  *  used to greatly speed up emulation
  */
 
-#define TMS32010_RDOP(A) (memory_decrypted_read_word(cpustate->program, (A)<<1))
+#define TMS32010_RDOP(A) (cpustate->direct->read_decrypted_word((A)<<1))
 
 
 /****************************************************************************
@@ -211,7 +212,7 @@
  *  that use different encoding mechanisms for opcodes and opcode arguments
  */
 
-#define TMS32010_RDOP_ARG(A) (memory_raw_read_word(cpustate->program, (A)<<1))
+#define TMS32010_RDOP_ARG(A) (cpustate->direct->read_raw_word((A)<<1))
 
 
 /************************************************************************
@@ -828,6 +829,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 }
diff -Nru src-old/emu/cpu/tms32025/tms32025.c src/emu/cpu/tms32025/tms32025.c
--- src-old/emu/cpu/tms32025/tms32025.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms32025/tms32025.c	2010-08-19 09:10:19.000000000 -0700
@@ -127,13 +127,13 @@
 
 #define SET_PC(x)	do { cpustate->PC = (x); } while (0)
 
-#define P_IN(A)			(memory_read_word_16be(cpustate->io, (A)<<1))
-#define P_OUT(A,V)		(memory_write_word_16be(cpustate->io, ((A)<<1),(V)))
-#define S_IN(A)			(memory_read_word_16be(cpustate->io, (A)<<1))
-#define S_OUT(A,V)		(memory_write_word_16be(cpustate->io, ((A)<<1),(V)))
+#define P_IN(A)			(cpustate->io->read_word((A)<<1))
+#define P_OUT(A,V)		(cpustate->io->write_word(((A)<<1),(V)))
+#define S_IN(A)			(cpustate->io->read_word((A)<<1))
+#define S_OUT(A,V)		(cpustate->io->write_word(((A)<<1),(V)))
 
-#define M_RDOP(A)		((cpustate->pgmmap[(A) >> 7]) ? (cpustate->pgmmap[(A) >> 7][(A) & 0x7f]) : memory_decrypted_read_word(cpustate->program, (A)<<1))
-#define M_RDOP_ARG(A)	((cpustate->pgmmap[(A) >> 7]) ? (cpustate->pgmmap[(A) >> 7][(A) & 0x7f]) : memory_decrypted_read_word(cpustate->program, (A)<<1))
+#define M_RDOP(A)		((cpustate->pgmmap[(A) >> 7]) ? (cpustate->pgmmap[(A) >> 7][(A) & 0x7f]) : cpustate->direct->read_decrypted_word((A)<<1))
+#define M_RDOP_ARG(A)	((cpustate->pgmmap[(A) >> 7]) ? (cpustate->pgmmap[(A) >> 7][(A) & 0x7f]) : cpustate->direct->read_decrypted_word((A)<<1))
 
 
 
@@ -174,9 +174,10 @@
 	int		waiting_for_serial_frame;
 
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
+	address_space *io;
 
 	UINT16 *pgmmap[0x200];
 	UINT16 *datamap[0x200];
@@ -324,7 +325,7 @@
 	addr &= 0xffff;
 	ram = cpustate->pgmmap[addr >> 7];
 	if (ram) return ram[addr & 0x7f];
-	return memory_read_word_16be(cpustate->program, addr << 1);
+	return cpustate->program->read_word(addr << 1);
 }
 
 INLINE void M_WRTROM(tms32025_state *cpustate, offs_t addr, UINT16 data)
@@ -333,7 +334,7 @@
 	addr &= 0xffff;
 	ram = cpustate->pgmmap[addr >> 7];
 	if (ram) { ram[addr & 0x7f] = data; }
-	else memory_write_word_16be(cpustate->program, addr << 1, data);
+	else cpustate->program->write_word(addr << 1, data);
 }
 
 INLINE UINT16 M_RDRAM(tms32025_state *cpustate, offs_t addr)
@@ -342,7 +343,7 @@
 	addr &= 0xffff;
 	ram = cpustate->datamap[addr >> 7];
 	if (ram) return ram[addr & 0x7f];
-	return memory_read_word_16be(cpustate->data, addr << 1);
+	return cpustate->data->read_word(addr << 1);
 }
 
 INLINE void M_WRTRAM(tms32025_state *cpustate, offs_t addr, UINT16 data)
@@ -359,7 +360,7 @@
 				cpustate->IFR |= 0x20;
 		}
 	}
-	else memory_write_word_16be(cpustate->data, addr << 1, data);
+	else cpustate->data->write_word(addr << 1, data);
 }
 
 
@@ -1722,6 +1723,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
diff -Nru src-old/emu/cpu/tms32031/tms32031.c src/emu/cpu/tms32031/tms32031.c
--- src-old/emu/cpu/tms32031/tms32031.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms32031/tms32031.c	2010-08-19 09:10:19.000000000 -0700
@@ -120,7 +120,8 @@
 	tms32031_iack_func	iack_w;
 	device_irq_callback	irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 };
 
 INLINE tms32031_state *get_safe_token(running_device *device)
@@ -146,10 +147,10 @@
     MEMORY ACCESSORS
 ***************************************************************************/
 
-#define ROPCODE(T,pc)		memory_decrypted_read_dword((T)->program, (pc) << 2)
+#define ROPCODE(T,pc)		(T)->direct->read_decrypted_dword((pc) << 2)
 
-#define RMEM(T,addr)		memory_read_dword_32le((T)->program, (addr) << 2)
-#define WMEM(T,addr,data)	memory_write_dword_32le((T)->program, (addr) << 2, data)
+#define RMEM(T,addr)		(T)->program->read_dword((addr) << 2)
+#define WMEM(T,addr,data)	(T)->program->write_dword((addr) << 2, data)
 
 
 
@@ -374,6 +375,7 @@
 	tms->irq_callback = irqcallback;
 	tms->device = device;
 	tms->program = device->space(AS_PROGRAM);
+	tms->direct = &tms->program->direct();
 
 	/* copy in the xf write routines */
 	tms->bootoffset = (configdata != NULL) ? configdata->bootoffset : 0;
diff -Nru src-old/emu/cpu/tms32051/tms32051.c src/emu/cpu/tms32051/tms32051.c
--- src-old/emu/cpu/tms32051/tms32051.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms32051/tms32051.c	2010-08-19 09:10:19.000000000 -0700
@@ -144,8 +144,9 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *data;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *data;
 	int icount;
 };
 
@@ -164,7 +165,7 @@
 
 #define CYCLES(x)		(cpustate->icount -= x)
 
-#define ROPCODE(cpustate)		memory_decrypted_read_word(cpustate->program, (cpustate->pc++) << 1)
+#define ROPCODE(cpustate)		cpustate->direct->read_decrypted_word((cpustate->pc++) << 1)
 
 INLINE void CHANGE_PC(tms32051_state *cpustate, UINT16 new_pc)
 {
@@ -173,22 +174,22 @@
 
 INLINE UINT16 PM_READ16(tms32051_state *cpustate, UINT16 address)
 {
-	return memory_read_word_16le(cpustate->program, address << 1);
+	return cpustate->program->read_word(address << 1);
 }
 
 INLINE void PM_WRITE16(tms32051_state *cpustate, UINT16 address, UINT16 data)
 {
-	memory_write_word_16le(cpustate->program, address << 1, data);
+	cpustate->program->write_word(address << 1, data);
 }
 
 INLINE UINT16 DM_READ16(tms32051_state *cpustate, UINT16 address)
 {
-	return memory_read_word_16le(cpustate->data, address << 1);
+	return cpustate->data->read_word(address << 1);
 }
 
 INLINE void DM_WRITE16(tms32051_state *cpustate, UINT16 address, UINT16 data)
 {
-	memory_write_word_16le(cpustate->data, address << 1, data);
+	cpustate->data->write_word(address << 1, data);
 }
 
 #include "32051ops.c"
@@ -224,6 +225,7 @@
 
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 }
 
diff -Nru src-old/emu/cpu/tms34010/34010gfx.c src/emu/cpu/tms34010/34010gfx.c
--- src-old/emu/cpu/tms34010/34010gfx.c	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/cpu/tms34010/34010gfx.c	2010-08-19 01:27:05.000000000 -0700
@@ -201,7 +201,17 @@
 
 
 /* Shift register handling */
-static void shiftreg_w(const address_space *space, offs_t offset,UINT16 data)
+static void memory_w(address_space *space, offs_t offset,UINT16 data)
+{
+	space->write_word(offset, data);
+}
+
+static UINT16 memory_r(address_space *space, offs_t offset)
+{
+	return space->read_word(offset);
+}
+
+static void shiftreg_w(address_space *space, offs_t offset,UINT16 data)
 {
 	tms34010_state *tms = get_safe_token(space->cpu);
 	if (tms->config->from_shiftreg)
@@ -210,7 +220,7 @@
 		logerror("From ShiftReg function not set. PC = %08X\n", tms->pc);
 }
 
-static UINT16 shiftreg_r(const address_space *space, offs_t offset)
+static UINT16 shiftreg_r(address_space *space, offs_t offset)
 {
 	tms34010_state *tms = get_safe_token(space->cpu);
 	if (tms->config->to_shiftreg)
@@ -220,7 +230,7 @@
 	return tms->shiftreg[0];
 }
 
-static UINT16 dummy_shiftreg_r(const address_space *space, offs_t offset)
+static UINT16 dummy_shiftreg_r(address_space *space, offs_t offset)
 {
 	tms34010_state *tms = get_safe_token(space->cpu);
 	return tms->shiftreg[0];
@@ -1028,8 +1038,8 @@
 	if (!P_FLAG(tms))
 	{
 		int dx, dy, x, y, /*words,*/ yreverse;
-		void (*word_write)(const address_space *space,offs_t address,UINT16 data);
-		UINT16 (*word_read)(const address_space *space,offs_t address);
+		void (*word_write)(address_space *space,offs_t address,UINT16 data);
+		UINT16 (*word_read)(address_space *space,offs_t address);
 		UINT32 readwrites = 0;
 		UINT32 saddr, daddr;
 		XY dstxy = { 0 };
@@ -1042,8 +1052,8 @@
 		}
 		else
 		{
-			word_write = memory_write_word_16le;
-			word_read = memory_read_word_16le;
+			word_write = memory_w;
+			word_read = memory_r;
 		}
 
 		/* compute the starting addresses */
@@ -1375,8 +1385,8 @@
 	if (!P_FLAG(tms))
 	{
 		int dx, dy, x, y, words, yreverse;
-		void (*word_write)(const address_space *space,offs_t address,UINT16 data);
-		UINT16 (*word_read)(const address_space *space,offs_t address);
+		void (*word_write)(address_space *space,offs_t address,UINT16 data);
+		UINT16 (*word_read)(address_space *space,offs_t address);
 		UINT32 saddr, daddr;
 		XY dstxy = { 0 };
 
@@ -1388,8 +1398,8 @@
 		}
 		else
 		{
-			word_write = memory_write_word_16le;
-			word_read = memory_read_word_16le;
+			word_write = memory_w;
+			word_read = memory_r;
 		}
 
 		/* compute the starting addresses */
@@ -1640,8 +1650,8 @@
 	if (!P_FLAG(tms))
 	{
 		int dx, dy, x, y, words, left_partials, right_partials, full_words;
-		void (*word_write)(const address_space *space,offs_t address,UINT16 data);
-		UINT16 (*word_read)(const address_space *space,offs_t address);
+		void (*word_write)(address_space *space,offs_t address,UINT16 data);
+		UINT16 (*word_read)(address_space *space,offs_t address);
 		UINT32 saddr, daddr;
 		XY dstxy = { 0 };
 
@@ -1653,8 +1663,8 @@
 		}
 		else
 		{
-			word_write = memory_write_word_16le;
-			word_read = memory_read_word_16le;
+			word_write = memory_w;
+			word_read = memory_r;
 		}
 
 		/* compute the starting addresses */
@@ -1854,8 +1864,8 @@
 	if (!P_FLAG(tms))
 	{
 		int dx, dy, x, y, words, left_partials, right_partials, full_words;
-		void (*word_write)(const address_space *space,offs_t address,UINT16 data);
-		UINT16 (*word_read)(const address_space *space,offs_t address);
+		void (*word_write)(address_space *space,offs_t address,UINT16 data);
+		UINT16 (*word_read)(address_space *space,offs_t address);
 		UINT32 daddr;
 		XY dstxy = { 0 };
 
@@ -1867,8 +1877,8 @@
 		}
 		else
 		{
-			word_write = memory_write_word_16le;
-			word_read = memory_read_word_16le;
+			word_write = memory_w;
+			word_read = memory_r;
 		}
 
 		/* compute the bounds of the operation */
diff -Nru src-old/emu/cpu/tms34010/34010ops.c src/emu/cpu/tms34010/34010ops.c
--- src-old/emu/cpu/tms34010/34010ops.c	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/tms34010/34010ops.c	2010-08-19 09:10:19.000000000 -0700
@@ -78,13 +78,13 @@
 {
 	/* kludge for Super High Impact -- this doesn't seem to cause */
 	/* an illegal opcode exception */
-	if (memory_decrypted_read_word(tms->program, TOBYTE(tms->pc - 0x10)) == 0x0007)
+	if (tms->direct->read_decrypted_word(TOBYTE(tms->pc - 0x10)) == 0x0007)
 		return;
 
 	/* 9 Ball Shootout calls to FFDF7468, expecting it */
 	/* to execute the next instruction from FFDF7470 */
 	/* but the instruction at FFDF7460 is an 0x0001 */
-	if (memory_decrypted_read_word(tms->program, TOBYTE(tms->pc - 0x10)) == 0x0001)
+	if (tms->direct->read_decrypted_word(TOBYTE(tms->pc - 0x10)) == 0x0001)
 		return;
 
 	PUSH(tms, tms->pc);
@@ -94,7 +94,7 @@
 	COUNT_UNKNOWN_CYCLES(tms,16);
 
 	/* extra check to prevent bad things */
-	if (tms->pc == 0 || opcode_table[memory_decrypted_read_word(tms->program, TOBYTE(tms->pc)) >> 4] == unimpl)
+	if (tms->pc == 0 || opcode_table[tms->direct->read_decrypted_word(TOBYTE(tms->pc)) >> 4] == unimpl)
 	{
 		cpu_set_input_line(tms->device, INPUT_LINE_HALT, ASSERT_LINE);
 		debugger_break(tms->device->machine);
diff -Nru src-old/emu/cpu/tms34010/34010ops.h src/emu/cpu/tms34010/34010ops.h
--- src-old/emu/cpu/tms34010/34010ops.h	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/cpu/tms34010/34010ops.h	2010-08-19 01:27:05.000000000 -0700
@@ -22,20 +22,20 @@
     MEMORY I/O MACROS
 ***************************************************************************/
 
-#define TMS34010_RDMEM(T,A)			((unsigned)memory_read_byte_16le ((T)->program, A))
-#define TMS34010_RDMEM_WORD(T,A)	((unsigned)memory_read_word_16le ((T)->program, A))
+#define TMS34010_RDMEM(T,A)			((unsigned)(T)->program->read_byte (A))
+#define TMS34010_RDMEM_WORD(T,A)	((unsigned)(T)->program->read_word (A))
 INLINE UINT32 TMS34010_RDMEM_DWORD(tms34010_state *tms, offs_t A)
 {
-	UINT32 result = memory_read_word_16le(tms->program, A);
-	return result | (memory_read_word_16le(tms->program, A+2)<<16);
+	UINT32 result = tms->program->read_word(A);
+	return result | (tms->program->read_word(A+2)<<16);
 }
 
-#define TMS34010_WRMEM(T,A,V)		(memory_write_byte_16le((T)->program, A,V))
-#define TMS34010_WRMEM_WORD(T,A,V)	(memory_write_word_16le((T)->program, A,V))
+#define TMS34010_WRMEM(T,A,V)		((T)->program->write_byte(A,V))
+#define TMS34010_WRMEM_WORD(T,A,V)	((T)->program->write_word(A,V))
 INLINE void TMS34010_WRMEM_DWORD(tms34010_state *tms, offs_t A,UINT32 V)
 {
-	memory_write_word_16le(tms->program, A,V);
-	memory_write_word_16le(tms->program, A+2,V>>16);
+	tms->program->write_word(A,V);
+	tms->program->write_word(A+2,V>>16);
 }
 
 
diff -Nru src-old/emu/cpu/tms34010/tms34010.c src/emu/cpu/tms34010/tms34010.c
--- src-old/emu/cpu/tms34010/tms34010.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/cpu/tms34010/tms34010.c	2010-08-19 09:10:19.000000000 -0700
@@ -63,7 +63,8 @@
 	UINT8				executing;
 	device_irq_callback	irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
+	direct_read_data *direct;
 	const tms34010_config *config;
 	screen_device *screen;
 	emu_timer *			scantimer;
@@ -220,32 +221,32 @@
 {
 	UINT32 pc = TOBYTE(tms->pc);
 	tms->pc += 2 << 3;
-	return memory_decrypted_read_word(tms->program, pc);
+	return tms->direct->read_decrypted_word(pc);
 }
 
 INLINE INT16 PARAM_WORD(tms34010_state *tms)
 {
 	UINT32 pc = TOBYTE(tms->pc);
 	tms->pc += 2 << 3;
-	return memory_raw_read_word(tms->program, pc);
+	return tms->direct->read_raw_word(pc);
 }
 
 INLINE INT32 PARAM_LONG(tms34010_state *tms)
 {
 	UINT32 pc = TOBYTE(tms->pc);
 	tms->pc += 4 << 3;
-	return (UINT16)memory_raw_read_word(tms->program, pc) | (memory_raw_read_word(tms->program, pc + 2) << 16);
+	return (UINT16)tms->direct->read_raw_word(pc) | (tms->direct->read_raw_word(pc + 2) << 16);
 }
 
 INLINE INT16 PARAM_WORD_NO_INC(tms34010_state *tms)
 {
-	return memory_raw_read_word(tms->program, TOBYTE(tms->pc));
+	return tms->direct->read_raw_word(TOBYTE(tms->pc));
 }
 
 INLINE INT32 PARAM_LONG_NO_INC(tms34010_state *tms)
 {
 	UINT32 pc = TOBYTE(tms->pc);
-	return (UINT16)memory_raw_read_word(tms->program, pc) | (memory_raw_read_word(tms->program, pc + 2) << 16);
+	return (UINT16)tms->direct->read_raw_word(pc) | (tms->direct->read_raw_word(pc + 2) << 16);
 }
 
 /* read memory byte */
@@ -628,6 +629,7 @@
 	tms->irq_callback = irqcallback;
 	tms->device = device;
 	tms->program = device->space(AS_PROGRAM);
+	tms->direct = &tms->program->direct();
 	tms->screen = downcast<screen_device *>(device->machine->device(configdata->screen_tag));
 
 	/* set up the state table */
@@ -689,6 +691,7 @@
 	tms->scantimer = save_scantimer;
 	tms->device = device;
 	tms->program = device->space(AS_PROGRAM);
+	tms->direct = &tms->program->direct();
 
 	/* fetch the initial PC and reset the state */
 	tms->pc = RLONG(tms, 0xffffffe0) & 0xfffffff0;
@@ -1556,7 +1559,7 @@
 
 void tms34010_host_w(running_device *cpu, int reg, int data)
 {
-	const address_space *space;
+	address_space *space;
 	tms34010_state *tms = get_safe_token(cpu);
 	unsigned int addr;
 
diff -Nru src-old/emu/cpu/tms34010/tms34010.h src/emu/cpu/tms34010/tms34010.h
--- src-old/emu/cpu/tms34010/tms34010.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms34010/tms34010.h	2010-08-19 00:26:14.000000000 -0700
@@ -198,8 +198,8 @@
 	int		pixperclock;						/* pixels per clock */
 	void	(*scanline_callback)(screen_device &screen, bitmap_t *bitmap, int scanline, const tms34010_display_params *params);
 	void	(*output_int)(running_device *device, int state);			/* output interrupt callback */
-	void	(*to_shiftreg)(const address_space *space, offs_t, UINT16 *);	/* shift register write */
-	void	(*from_shiftreg)(const address_space *space, offs_t, UINT16 *);	/* shift register read */
+	void	(*to_shiftreg)(address_space *space, offs_t, UINT16 *);	/* shift register write */
+	void	(*from_shiftreg)(address_space *space, offs_t, UINT16 *);	/* shift register read */
 };
 
 
diff -Nru src-old/emu/cpu/tms57002/tms57002.c src/emu/cpu/tms57002/tms57002.c
--- src-old/emu/cpu/tms57002/tms57002.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms57002/tms57002.c	2010-08-19 01:27:05.000000000 -0700
@@ -104,7 +104,7 @@
 
 	cd cache;
 
-	const address_space *program, *data;
+	address_space *program, *data;
 	int icount;
 	int unsupported_inst_warning;
 } tms57002_t;
@@ -192,7 +192,7 @@
 				s->sti = (s->sti & ~SU_MASK) | SU_PRG;
 				break;
 			case SU_PRG:
-				memory_write_dword_32le(s->program, (s->pc++) << 2, val);
+				s->program->write_dword((s->pc++) << 2, val);
 				break;
 			}
 		}
@@ -391,7 +391,7 @@
 static void tms57002_xm_step_read(tms57002_t *s)
 {
 	UINT32 adr = s->xm_adr;
-	UINT8 v = memory_read_byte_8le(s->data, adr);
+	UINT8 v = s->data->read_byte(adr);
 	int done;
 	if(s->st0 & ST0_WORD) {
 		if(s->st0 & ST0_SEL) {
@@ -451,7 +451,7 @@
 			done = off == 12;
 		}
 	}
-	memory_write_byte_8le(s->data, adr, v);
+	s->data->write_byte(adr, v);
 	if(done) {
 		s->sti &= ~S_WRITE;
 		s->xm_adr = 0;
@@ -986,7 +986,7 @@
 void tms57002_execute(tms57002_t *s)
 {
 	while(!(s->sti & (S_IDLE | IN_PLOAD | IN_CLOAD))) {
-		UINT32 opcode = memory_read_dword_32le(s->program, s->pc << 2);
+		UINT32 opcode = s->program->read_dword(s->pc << 2);
 
 		if(s->sti & (S_READ|S_WRITE)) {
 			if(s->sti & S_READ)
@@ -1245,7 +1245,7 @@
 
 	for(;;) {
 		short ipc;
-		UINT32 opcode = memory_read_dword_32le(s->program, adr << 2);
+		UINT32 opcode = s->program->read_dword(adr << 2);
 
 		if((opcode & 0xfc0000) == 0xfc0000)
 			tms57002_decode_one(s, opcode, &cs, tms57002_decode_cat3);
diff -Nru src-old/emu/cpu/tms7000/tms7000.c src/emu/cpu/tms7000/tms7000.c
--- src-old/emu/cpu/tms7000/tms7000.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/tms7000/tms7000.c	2010-08-19 09:10:19.000000000 -0700
@@ -52,12 +52,12 @@
 
 /* Static variables */
 
-#define RM(Addr) ((unsigned)memory_read_byte_8be(cpustate->program, Addr))
-#define WM(Addr,Value) (memory_write_byte_8be(cpustate->program, Addr, Value))
+#define RM(Addr) ((unsigned)cpustate->program->read_byte(Addr))
+#define WM(Addr,Value) (cpustate->program->write_byte(Addr, Value))
 
-#define IMMBYTE(b)	b = ((unsigned)memory_raw_read_byte(cpustate->program, pPC)); pPC++
-#define SIMMBYTE(b)	b = ((signed)memory_raw_read_byte(cpustate->program, pPC)); pPC++
-#define IMMWORD(w)	w.b.h = (unsigned)memory_raw_read_byte(cpustate->program, pPC++); w.b.l = (unsigned)memory_raw_read_byte(cpustate->program, pPC++)
+#define IMMBYTE(b)	b = ((unsigned)cpustate->direct->read_raw_byte(pPC)); pPC++
+#define SIMMBYTE(b)	b = ((signed)cpustate->direct->read_raw_byte(pPC)); pPC++
+#define IMMWORD(w)	w.b.h = (unsigned)cpustate->direct->read_raw_byte(pPC++); w.b.l = (unsigned)cpustate->direct->read_raw_byte(pPC++)
 
 #define PUSHBYTE(b) pSP++; WM(pSP,b)
 #define PUSHWORD(w) pSP++; WM(pSP,w.b.h); pSP++; WM(pSP,w.b.l)
@@ -74,8 +74,9 @@
 	UINT8		pf[0x100];	/* Perpherial file */
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int			icount;
 	int 		div_by_16_trigger;
 	int			cycles_per_INT2;
@@ -165,6 +166,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	memset(cpustate->pf, 0, 0x100);
@@ -454,7 +456,7 @@
 
 		if( cpustate->idle_state == 0 )
 		{
-			op = memory_decrypted_read_byte(cpustate->program, pPC++);
+			op = cpustate->direct->read_decrypted_byte(pPC++);
 
 			opfn[op](cpustate);
 		}
@@ -495,7 +497,7 @@
 		if( cpustate->idle_state == 0 )
 		{
 
-			op = memory_decrypted_read_byte(cpustate->program, pPC++);
+			op = cpustate->direct->read_decrypted_byte(pPC++);
 
 			opfn_exl[op](cpustate);
 		}
@@ -599,19 +601,19 @@
 			break;
 
 		case 0x06: /* Port B write */
-			memory_write_byte_8be( cpustate->io, TMS7000_PORTB, data );
+			cpustate->io->write_byte( TMS7000_PORTB, data );
 			cpustate->pf[ 0x06 ] = data;
 			break;
 
 		case 0x08: /* Port C write */
 			temp1 = data & cpustate->pf[ 0x09 ];	/* Mask off input bits */
-			memory_write_byte_8be( cpustate->io, TMS7000_PORTC, temp1 );
+			cpustate->io->write_byte( TMS7000_PORTC, temp1 );
 			cpustate->pf[ 0x08 ] = temp1;
 			break;
 
 		case 0x0a: /* Port D write */
 			temp1 = data & cpustate->pf[ 0x0b ];	/* Mask off input bits */
-			memory_write_byte_8be( cpustate->io, TMS7000_PORTD, temp1 );
+			cpustate->io->write_byte( TMS7000_PORTD, temp1 );
 			cpustate->pf[ 0x0a ] = temp1;
 			break;
 
@@ -647,7 +649,7 @@
 			break;
 
 		case 0x04: /* Port A read */
-			result = memory_read_byte_8be( cpustate->io, TMS7000_PORTA );
+			result = cpustate->io->read_byte( TMS7000_PORTA );
 			break;
 
 
@@ -658,14 +660,14 @@
 
 		case 0x08: /* Port C read */
 			temp1 = cpustate->pf[ 0x08 ] & cpustate->pf[ 0x09 ];	/* Get previous output bits */
-			temp2 = memory_read_byte_8be( cpustate->io, TMS7000_PORTC );			/* Read port */
+			temp2 = cpustate->io->read_byte( TMS7000_PORTC );			/* Read port */
 			temp3 = temp2 & (~cpustate->pf[ 0x09 ]);				/* Mask off output bits */
 			result = temp1 | temp3;								/* OR together */
 			break;
 
 		case 0x0a: /* Port D read */
 			temp1 = cpustate->pf[ 0x0a ] & cpustate->pf[ 0x0b ];	/* Get previous output bits */
-			temp2 = memory_read_byte_8be( cpustate->io, TMS7000_PORTD );			/* Read port */
+			temp2 = cpustate->io->read_byte( TMS7000_PORTD );			/* Read port */
 			temp3 = temp2 & (~cpustate->pf[ 0x0b ]);				/* Mask off output bits */
 			result = temp1 | temp3;								/* OR together */
 			break;
diff -Nru src-old/emu/cpu/tms9900/99xxcore.h src/emu/cpu/tms9900/99xxcore.h
--- src-old/emu/cpu/tms9900/99xxcore.h	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/cpu/tms9900/99xxcore.h	2010-08-19 01:27:05.000000000 -0700
@@ -437,8 +437,8 @@
     retreive the value on IC0-IC3 (non-standard behaviour) */
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	address_space *io;
 	int icount;
 
 	UINT8 IDLE;       /* nonzero if processor is IDLE - i.e waiting for interrupt while writing
@@ -529,7 +529,7 @@
 READ16_HANDLER(ti990_10_internal_r)
 {
 	//return cpustate->ROM[offset];
-	return memory_read_word_16be(space, 0x1ffc00+offset);
+	return space->read_word(0x1ffc00+offset);
 }
 
 #endif
@@ -579,14 +579,14 @@
 		{	/* intercept TPCS and CPU ROM */
 			if (addr < 0xfc00)
 				/* TPCS */
-				return memory_read_word_16be(cpustate->program, 0x1f0000+addr);
+				return cpustate->program->read_word(0x1f0000+addr);
 			else
 				/* CPU ROM */
-				return memory_read_word_16be(cpustate->program, 0x1f0000+addr);	/* hack... */
+				return cpustate->program->read_word(0x1f0000+addr);	/* hack... */
 		}
 		else if (! cpustate->mapping_on)
 		{
-			return memory_read_word_16be(cpustate->program, addr);
+			return cpustate->program->read_word(addr);
 		}
 		else
 		{
@@ -607,13 +607,13 @@
 					cpustate->error_interrupt_register |= EIR_MAPERR;
 					cpustate->write_inhibit = 1;
 				}
-				return memory_read_word_16be(cpustate->program, addr);
+				return cpustate->program->read_word(addr);
 			}
 			if ((! (cpustate->error_interrupt_register & EIR_MAPERR)) && ! (cpustate->diaglat))
 				cpustate->mapper_address_latch = cpustate->map_files[map_file].bias[map_index]+addr;
 			if ((cpustate->latch_control[map_index]) && (! cpustate->reset_maperr))
 				cpustate->diaglat = 1;
-			return memory_read_word_16be(cpustate->program, cpustate->map_files[map_file].bias[map_index]+addr);
+			return cpustate->program->read_word(cpustate->map_files[map_file].bias[map_index]+addr);
 		}
 	}
 
@@ -624,14 +624,14 @@
 		{	/* intercept TPCS and CPU ROM */
 			if (addr < 0xfc00)
 				/* TPCS */
-				memory_write_word_16be(cpustate->program, 0x1f0000+addr, data);
+				cpustate->program->write_word(0x1f0000+addr, data);
 			else
 				/* CPU ROM */
-				memory_write_word_16be(cpustate->program, 0x1f0000+addr, data);	/* hack... */
+				cpustate->program->write_word(0x1f0000+addr, data);	/* hack... */
 		}
 		else if (! cpustate->mapping_on)
 		{
-			memory_write_word_16be(cpustate->program, addr, data);
+			cpustate->program->write_word(addr, data);
 		}
 		else
 		{
@@ -653,16 +653,16 @@
 					cpustate->write_inhibit = 1;
 				}
 				if (cpustate->write_inhibit)
-					(void)memory_read_word_16be(cpustate->program, addr);
+					(void)cpustate->program->read_word(addr);
 				else
-					memory_write_word_16be(cpustate->program, addr, data);
+					cpustate->program->write_word(addr, data);
 				return;
 			}
 			if ((! (cpustate->error_interrupt_register & EIR_MAPERR)) && ! (cpustate->diaglat))
 				cpustate->mapper_address_latch = cpustate->map_files[map_file].bias[map_index]+addr;
 			if ((cpustate->latch_control[map_index]) && (! cpustate->reset_maperr))
 				cpustate->diaglat = 1;
-			memory_write_word_16be(cpustate->program, cpustate->map_files[map_file].bias[map_index]+addr, data);
+			cpustate->program->write_word(cpustate->map_files[map_file].bias[map_index]+addr, data);
 		}
 	}
 
@@ -673,14 +673,14 @@
 		{	/* intercept TPCS and CPU ROM */
 			if (addr < 0xfc00)
 				/* TPCS */
-				return memory_read_byte_16be(cpustate->program, 0x1f0000+addr);
+				return cpustate->program->read_byte(0x1f0000+addr);
 			else
 				/* CPU ROM */
-				return memory_read_byte_16be(cpustate->program, 0x1f0000+addr);	/* hack... */
+				return cpustate->program->read_byte(0x1f0000+addr);	/* hack... */
 		}
 		else if (! cpustate->mapping_on)
 		{
-			return memory_read_byte_16be(cpustate->program, addr);
+			return cpustate->program->read_byte(addr);
 		}
 		else
 		{
@@ -701,13 +701,13 @@
 					cpustate->error_interrupt_register |= EIR_MAPERR;
 					cpustate->write_inhibit = 1;
 				}
-				return memory_read_byte_16be(cpustate->program, addr);
+				return cpustate->program->read_byte(addr);
 			}
 			if ((! (cpustate->error_interrupt_register & EIR_MAPERR)) && ! (cpustate->diaglat))
 				cpustate->mapper_address_latch = cpustate->map_files[map_file].bias[map_index]+addr;
 			if ((cpustate->latch_control[map_index]) && (! cpustate->reset_maperr))
 				cpustate->diaglat = 1;
-			return memory_read_byte_16be(cpustate->program, cpustate->map_files[map_file].bias[map_index]+addr);
+			return cpustate->program->read_byte(cpustate->map_files[map_file].bias[map_index]+addr);
 		}
 	}
 
@@ -718,14 +718,14 @@
 		{	/* intercept TPCS and CPU ROM */
 			if (addr < 0xfc00)
 				/* TPCS */
-				memory_write_byte_16be(cpustate->program, 0x1f0000+addr, data);
+				cpustate->program->write_byte(0x1f0000+addr, data);
 			else
 				/* CPU ROM */
-				memory_write_byte_16be(cpustate->program, 0x1f0000+addr, data);	/* hack... */
+				cpustate->program->write_byte(0x1f0000+addr, data);	/* hack... */
 		}
 		else if (! cpustate->mapping_on)
 		{
-			memory_write_byte_16be(cpustate->program, addr, data);
+			cpustate->program->write_byte(addr, data);
 		}
 		else
 		{
@@ -747,16 +747,16 @@
 					cpustate->write_inhibit = 1;
 				}
 				if (cpustate->write_inhibit)
-					(void)memory_read_byte_16be(cpustate->program, addr);
+					(void)cpustate->program->read_byte(addr);
 				else
-					memory_write_byte_16be(cpustate->program, addr, data);
+					cpustate->program->write_byte(addr, data);
 				return;
 			}
 			if ((! (cpustate->error_interrupt_register & EIR_MAPERR)) && ! (cpustate->diaglat))
 				cpustate->mapper_address_latch = cpustate->map_files[map_file].bias[map_index]+addr;
 			if ((cpustate->latch_control[map_index]) && (! cpustate->reset_maperr))
 				cpustate->diaglat = 1;
-			memory_write_byte_16be(cpustate->program, cpustate->map_files[map_file].bias[map_index]+addr, data);
+			cpustate->program->write_byte(cpustate->map_files[map_file].bias[map_index]+addr, data);
 		}
 	}
 
@@ -767,11 +767,11 @@
     remember this when writing memory handlers.*/
 	/*This does not apply to tms9995 and tms99xxx, but does apply to tms9980 (see below).*/
 
-	#define readword(cs, addr)        memory_read_word_16be((cs)->program, addr)
-	#define writeword(cs, addr,data)  memory_write_word_16be((cs)->program, (addr), (data))
+	#define readword(cs, addr)        (cs)->program->read_word(addr)
+	#define writeword(cs, addr,data)  (cs)->program->write_word((addr), (data))
 
-	#define readbyte(cs, addr)        memory_read_byte_16be((cs)->program, addr)
-	#define writebyte(cs, addr,data)  memory_write_byte_16be((cs)->program, (addr),(data))
+	#define readbyte(cs, addr)        (cs)->program->read_byte(addr)
+	#define writebyte(cs, addr,data)  (cs)->program->write_byte((addr),(data))
 
 #elif (TMS99XX_MODEL == TMS9980_ID)
 	/*8-bit data bus, 14-bit address*/
@@ -784,14 +784,14 @@
 		int val;
 
 		cpustate->icount -= 2;
-		val = memory_read_byte_8be(cpustate->program, addr);
-		return (val << 8) | memory_read_byte_8be(cpustate->program, addr+1);
+		val = cpustate->program->read_byte(addr);
+		return (val << 8) | cpustate->program->read_byte(addr+1);
 	}
-	#define writeword(cs, addr,data)  { (cs)->icount -= 2; memory_write_byte_8be((cs)->program, (addr), (data) >> 8); memory_write_byte_8be(cpustate->program, (addr) + 1, (data) & 0xff); }
+	#define writeword(cs, addr,data)  { (cs)->icount -= 2; (cs)->program->write_byte((addr), (data) >> 8); cpustate->program->write_byte((addr) + 1, (data) & 0xff); }
 
 #if 0
-	#define readbyte(cs, addr)        ((cs)->icount -= 2, memory_read_byte_8be((cs)->program, addr))
-	#define writebyte(cs, addr,data)  { (cs)->icount -= 2; memory_write_byte_8be((cs)->program, (addr),(data)); }
+	#define readbyte(cs, addr)        ((cs)->icount -= 2, (cs)->program->read_byte(addr))
+	#define writebyte(cs, addr,data)  { (cs)->icount -= 2; (cs)->program->write_byte((addr),(data)); }
 #else
 	/*This is how it really works*/
 	/*Note that every writebyte must match a readbyte (which is indeed the case)*/
@@ -801,13 +801,13 @@
 		cpustate->icount -= 2;
 		if (addr & 1)
 		{
-			cpustate->extra_byte = memory_read_byte_8be(cpustate->program, addr-1);
-			return memory_read_byte_8be(cpustate->program, addr);
+			cpustate->extra_byte = cpustate->program->read_byte(addr-1);
+			return cpustate->program->read_byte(addr);
 		}
 		else
 		{
-			int val = memory_read_byte_8be(cpustate->program, addr);
-			cpustate->extra_byte = memory_read_byte_8be(cpustate->program, addr+1);
+			int val = cpustate->program->read_byte(addr);
+			cpustate->extra_byte = cpustate->program->read_byte(addr+1);
 			return val;
 		}
 	}
@@ -816,13 +816,13 @@
 		cpustate->icount -= 2;
 		if (addr & 1)
 		{
-			memory_write_byte_8be(cpustate->program, addr-1, cpustate->extra_byte);
-			memory_write_byte_8be(cpustate->program, addr, data);
+			cpustate->program->write_byte(addr-1, cpustate->extra_byte);
+			cpustate->program->write_byte(addr, data);
 		}
 		else
 		{
-			memory_write_byte_8be(cpustate->program, addr, data);
-			memory_write_byte_8be(cpustate->program, addr+1, cpustate->extra_byte);
+			cpustate->program->write_byte(addr, data);
+			cpustate->program->write_byte(addr+1, cpustate->extra_byte);
 		}
 	}
 #endif
@@ -841,7 +841,7 @@
 		else
 		{
 			cpustate->icount -= 2;
-			return (memory_read_byte_8be(cpustate->program, addr) << 8) + memory_read_byte_8be(cpustate->program, addr + 1);
+			return (cpustate->program->read_byte(addr) << 8) + cpustate->program->read_byte(addr + 1);
 		}
 	}
 	static void writeword(tms99xx_state *cpustate, int addr, int data)
@@ -852,8 +852,8 @@
 		else if (!(addr < 0x2000))
 		{
 			cpustate->icount -= 2;
-			memory_write_byte_8be(cpustate->program, addr, data >> 8);
-			memory_write_byte_8be(cpustate->program, addr + 1, data & 0xff);
+			cpustate->program->write_byte(addr, data >> 8);
+			cpustate->program->write_byte(addr + 1, data & 0xff);
 		}
 	}
 
@@ -870,13 +870,13 @@
 			cpustate->icount -= 2;
 			if (addr & 1)
 			{
-				cpustate->extra_byte = memory_read_byte_8be(cpustate->program, addr-1);
-				return memory_read_byte_8be(cpustate->program, addr);
+				cpustate->extra_byte = cpustate->program->read_byte(addr-1);
+				return cpustate->program->read_byte(addr);
 			}
 			else
 			{
-				int val = memory_read_byte_8be(cpustate->program, addr);
-				cpustate->extra_byte = memory_read_byte_8be(cpustate->program, addr+1);
+				int val = cpustate->program->read_byte(addr);
+				cpustate->extra_byte = cpustate->program->read_byte(addr+1);
 				return val;
 			}
 		}
@@ -891,13 +891,13 @@
 			cpustate->icount -= 2;
 			if (addr & 1)
 			{
-				memory_write_byte_8be(cpustate->program, addr-1, cpustate->extra_byte);
-				memory_write_byte_8be(cpustate->program, addr, data);
+				cpustate->program->write_byte(addr-1, cpustate->extra_byte);
+				cpustate->program->write_byte(addr, data);
 			}
 			else
 			{
-				memory_write_byte_8be(cpustate->program, addr, data);
-				memory_write_byte_8be(cpustate->program, addr+1, cpustate->extra_byte);
+				cpustate->program->write_byte(addr, data);
+				cpustate->program->write_byte(addr+1, cpustate->extra_byte);
 			}
 		}
 	}
@@ -914,8 +914,8 @@
 		{
 			int reply;
 			cpustate->icount -= cpustate->memory_wait_states_word;
-			reply = memory_read_byte_8be(cpustate->program, addr);
-			return (reply << 8) | memory_read_byte_8be(cpustate->program, addr + 1);
+			reply = cpustate->program->read_byte(addr);
+			return (reply << 8) | cpustate->program->read_byte(addr + 1);
 		}
 		else if (addr < 0xf0fc)
 		{
@@ -925,8 +925,8 @@
 		{
 			int reply;
 			cpustate->icount -= cpustate->memory_wait_states_word;
-			reply = memory_read_byte_8be(cpustate->program, addr);
-			return (reply << 8) | memory_read_byte_8be(cpustate->program, addr + 1);
+			reply = cpustate->program->read_byte(addr);
+			return (reply << 8) | cpustate->program->read_byte(addr + 1);
 		}
 		else if (addr < 0xfffc)
 		{
@@ -949,8 +949,8 @@
 		if ((addr < 0xf000) || (cpustate->is_mp9537))
 		{
 			cpustate->icount -= cpustate->memory_wait_states_word;
-			memory_write_byte_8be(cpustate->program, addr, data >> 8);
-			memory_write_byte_8be(cpustate->program, addr + 1, data & 0xff);
+			cpustate->program->write_byte(addr, data >> 8);
+			cpustate->program->write_byte(addr + 1, data & 0xff);
 		}
 		else if (addr < 0xf0fc)
 		{
@@ -959,8 +959,8 @@
 		else if (addr < 0xfffa)
 		{
 			cpustate->icount -= cpustate->memory_wait_states_word;
-			memory_write_byte_8be(cpustate->program, addr, data >> 8);
-			memory_write_byte_8be(cpustate->program, addr + 1, data & 0xff);
+			cpustate->program->write_byte(addr, data >> 8);
+			cpustate->program->write_byte(addr + 1, data & 0xff);
 		}
 		else if (addr < 0xfffc)
 		{
@@ -979,7 +979,7 @@
 		if ((addr < 0xf000) || (cpustate->is_mp9537))
 		{
 			cpustate->icount -= cpustate->memory_wait_states_byte;
-			return memory_read_byte_8be(cpustate->program, addr);
+			return cpustate->program->read_byte(addr);
 		}
 		else if (addr < 0xf0fc)
 		{
@@ -988,7 +988,7 @@
 		else if (addr < 0xfffa)
 		{
 			cpustate->icount -= cpustate->memory_wait_states_byte;
-			return memory_read_byte_8be(cpustate->program, addr);
+			return cpustate->program->read_byte(addr);
 		}
 		else if (addr < 0xfffc)
 		{
@@ -1018,7 +1018,7 @@
 		if ((addr < 0xf000) || (cpustate->is_mp9537))
 		{
 			cpustate->icount -= cpustate->memory_wait_states_byte;
-			memory_write_byte_8be(cpustate->program, addr, data);
+			cpustate->program->write_byte(addr, data);
 		}
 		else if (addr < 0xf0fc)
 		{
@@ -1027,7 +1027,7 @@
 		else if (addr < 0xfffa)
 		{
 			cpustate->icount -= cpustate->memory_wait_states_byte;
-			memory_write_byte_8be(cpustate->program, addr, data);
+			cpustate->program->write_byte(addr, data);
 		}
 		else if (addr < 0xfffc)
 		{
@@ -1999,7 +1999,7 @@
 	CRU_PRIVILEGE_VIOLATION = -1
 } cru_error_code;
 
-#define WRITEPORT(cs, port, data) memory_write_byte_8be((cs)->io, port, data)
+#define WRITEPORT(cs, port, data) (cs)->io->write_byte(port, data)
 
 #if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
 /* on tms9940, we have to handle internal CRU ports */
@@ -2218,7 +2218,7 @@
     read at the same address.  This seems to be impossible to emulate efficiently, so, if you need
     to emulate this, you're in trouble.
 */
-#define READPORT(cs, port) memory_read_byte_8be((cs)->io, port)
+#define READPORT(cs, port) (cs)->io->read_byte(port)
 
 
 #if (TMS99XX_MODEL == TMS9940_ID) || (TMS99XX_MODEL == TMS9985_ID)
@@ -2429,10 +2429,10 @@
 
 	for (i=0; i<3; i++)
 	{
-		cpustate->map_files[dst_file].L[i] = memory_read_word_16be(cpustate->program, cpustate->mapper_address_latch) & 0xffe0;
+		cpustate->map_files[dst_file].L[i] = cpustate->program->read_word(cpustate->mapper_address_latch) & 0xffe0;
 		cpustate->map_files[dst_file].limit[i] = (cpustate->map_files[dst_file].L[i] ^ 0xffe0) | 0x001f;
 		cpustate->mapper_address_latch = (cpustate->mapper_address_latch+2) & 0x1fffff;
-		cpustate->map_files[dst_file].B[i] = memory_read_word_16be(cpustate->program, cpustate->mapper_address_latch);
+		cpustate->map_files[dst_file].B[i] = cpustate->program->read_word(cpustate->mapper_address_latch);
 		cpustate->map_files[dst_file].bias[i] = ((unsigned int) cpustate->map_files[dst_file].B[i]) << 5;
 		cpustate->mapper_address_latch = (cpustate->mapper_address_latch+2) & 0x1fffff;
 	}
diff -Nru src-old/emu/cpu/unsp/unsp.c src/emu/cpu/unsp/unsp.c
--- src-old/emu/cpu/unsp/unsp.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/unsp/unsp.c	2010-08-19 01:27:05.000000000 -0700
@@ -98,12 +98,12 @@
 
 INLINE UINT16 READ16(unsp_state *unsp, UINT32 address)
 {
-	return memory_read_word_16be(unsp->program, address << 1);
+	return unsp->program->read_word(address << 1);
 }
 
 INLINE void WRITE16(unsp_state *unsp, UINT32 address, UINT16 data)
 {
-	memory_write_word_16be(unsp->program, address << 1, data);
+	unsp->program->write_word(address << 1, data);
 }
 
 /*****************************************************************************/
diff -Nru src-old/emu/cpu/unsp/unsp.h src/emu/cpu/unsp/unsp.h
--- src-old/emu/cpu/unsp/unsp.h	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/unsp/unsp.h	2010-08-19 00:26:14.000000000 -0700
@@ -24,7 +24,7 @@
 	UINT8 saved_sb;
 
 	legacy_cpu_device *device;
-	const address_space *program;
+	address_space *program;
 	int icount;
 
 	unspimp_state *impstate;
diff -Nru src-old/emu/cpu/upd7810/upd7810.c src/emu/cpu/upd7810/upd7810.c
--- src-old/emu/cpu/upd7810/upd7810.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/upd7810/upd7810.c	2010-08-19 09:10:19.000000000 -0700
@@ -500,8 +500,9 @@
 	UPD7810_CONFIG config;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int icount;
 };
 
@@ -642,10 +643,10 @@
 	UINT8 mask_l0_l1;
 };
 
-#define RDOP(O) 	O = memory_decrypted_read_byte(cpustate->program, PCD); PC++
-#define RDOPARG(A)	A = memory_raw_read_byte(cpustate->program, PCD); PC++
-#define RM(A)		memory_read_byte_8le(cpustate->program, A)
-#define WM(A,V) 	memory_write_byte_8le(cpustate->program, A,V)
+#define RDOP(O) 	O = cpustate->direct->read_decrypted_byte(PCD); PC++
+#define RDOPARG(A)	A = cpustate->direct->read_raw_byte(PCD); PC++
+#define RM(A)		cpustate->program->read_byte(A)
+#define WM(A,V) 	cpustate->program->write_byte(A,V)
 
 #define ZHC_ADD(after,before,carry) 	\
 	if (after == 0) PSW |= Z; else PSW &= ~Z; \
@@ -686,17 +687,17 @@
 	{
 	case UPD7810_PORTA:
 		if (cpustate->ma)	// NS20031301 no need to read if the port is set as output
-			cpustate->pa_in = memory_read_byte_8le(cpustate->io, port);
+			cpustate->pa_in = cpustate->io->read_byte(port);
 		data = (cpustate->pa_in & cpustate->ma) | (cpustate->pa_out & ~cpustate->ma);
 		break;
 	case UPD7810_PORTB:
 		if (cpustate->mb)	// NS20031301 no need to read if the port is set as output
-			cpustate->pb_in = memory_read_byte_8le(cpustate->io, port);
+			cpustate->pb_in = cpustate->io->read_byte(port);
 		data = (cpustate->pb_in & cpustate->mb) | (cpustate->pb_out & ~cpustate->mb);
 		break;
 	case UPD7810_PORTC:
 		if (cpustate->mc)	// NS20031301 no need to read if the port is set as output
-			cpustate->pc_in = memory_read_byte_8le(cpustate->io, port);
+			cpustate->pc_in = cpustate->io->read_byte(port);
 		data = (cpustate->pc_in & cpustate->mc) | (cpustate->pc_out & ~cpustate->mc);
 		if (cpustate->mcc & 0x01)	/* PC0 = TxD output */
 			data = (data & ~0x01) | (cpustate->txd & 1 ? 0x01 : 0x00);
@@ -716,7 +717,7 @@
 			data = (data & ~0x80) | (cpustate->co1 & 1 ? 0x80 : 0x00);
 		break;
 	case UPD7810_PORTD:
-		cpustate->pd_in = memory_read_byte_8le(cpustate->io, port);
+		cpustate->pd_in = cpustate->io->read_byte(port);
 		switch (cpustate->mm & 0x07)
 		{
 		case 0x00:			/* PD input mode, PF port mode */
@@ -731,7 +732,7 @@
 		}
 		break;
 	case UPD7810_PORTF:
-		cpustate->pf_in = memory_read_byte_8le(cpustate->io, port);
+		cpustate->pf_in = cpustate->io->read_byte(port);
 		switch (cpustate->mm & 0x06)
 		{
 		case 0x00:			/* PD input/output mode, PF port mode */
@@ -751,7 +752,7 @@
 		}
 		break;
 	case UPD7807_PORTT:	// NS20031301 partial implementation
-		data = memory_read_byte_8le(cpustate->io, port);
+		data = cpustate->io->read_byte(port);
 		break;
 	default:
 		logerror("uPD7810 internal error: RP(cpustate) called with invalid port number\n");
@@ -767,13 +768,13 @@
 		cpustate->pa_out = data;
 //      data = (data & ~cpustate->ma) | (cpustate->pa_in & cpustate->ma);
 		data = (data & ~cpustate->ma) | (cpustate->ma);	// NS20031401
-		memory_write_byte_8le(cpustate->io, port, data);
+		cpustate->io->write_byte(port, data);
 		break;
 	case UPD7810_PORTB:
 		cpustate->pb_out = data;
 //      data = (data & ~cpustate->mb) | (cpustate->pb_in & cpustate->mb);
 		data = (data & ~cpustate->mb) | (cpustate->mb);	// NS20031401
-		memory_write_byte_8le(cpustate->io, port, data);
+		cpustate->io->write_byte(port, data);
 		break;
 	case UPD7810_PORTC:
 		cpustate->pc_out = data;
@@ -795,7 +796,7 @@
 			data = (data & ~0x40) | (cpustate->co0 & 1 ? 0x40 : 0x00);
 		if (cpustate->mcc & 0x80)	/* PC7 = CO1 output */
 			data = (data & ~0x80) | (cpustate->co1 & 1 ? 0x80 : 0x00);
-		memory_write_byte_8le(cpustate->io, port, data);
+		cpustate->io->write_byte(port, data);
 		break;
 	case UPD7810_PORTD:
 		cpustate->pd_out = data;
@@ -810,7 +811,7 @@
 		default:			/* PD extension mode, PF port/extension mode */
 			return;
 		}
-		memory_write_byte_8le(cpustate->io, port, data);
+		cpustate->io->write_byte(port, data);
 		break;
 	case UPD7810_PORTF:
 		cpustate->pf_out = data;
@@ -829,7 +830,7 @@
 			data |= 0xff;	/* what would come out for the lower bits here? */
 			break;
 		}
-		memory_write_byte_8le(cpustate->io, port, data);
+		cpustate->io->write_byte(port, data);
 		break;
 	default:
 		logerror("uPD7810 internal error: RP(cpustate) called with invalid port number\n");
@@ -1703,6 +1704,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	state_save_register_device_item(device, 0, cpustate->ppc.w.l);
@@ -1787,6 +1789,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->opXX = opXX_7810;
diff -Nru src-old/emu/cpu/v30mz/v30mz.c src/emu/cpu/v30mz/v30mz.c
--- src-old/emu/cpu/v30mz/v30mz.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/v30mz/v30mz.c	2010-08-19 09:10:19.000000000 -0700
@@ -85,8 +85,9 @@
 
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int icount;
 
 	UINT32 prefix_base;	/* base address of the latest prefix segment */
@@ -139,6 +140,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	cpustate->sregs[CS] = 0xffff;
diff -Nru src-old/emu/cpu/v30mz/v30mz.h src/emu/cpu/v30mz/v30mz.h
--- src-old/emu/cpu/v30mz/v30mz.h	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/v30mz/v30mz.h	2010-08-19 09:10:19.000000000 -0700
@@ -74,30 +74,30 @@
 
 #define DefaultBase(Seg) ((cpustate->seg_prefix && (Seg==DS || Seg==SS)) ? cpustate->prefix_base : cpustate->sregs[Seg] << 4)
 
-#define GetMemB(Seg,Off) ((UINT8)memory_read_byte_8le(cpustate->program, (DefaultBase(Seg)+(Off))))
-#define GetMemW(Seg,Off) ((UINT16) memory_read_byte_8le(cpustate->program, (DefaultBase(Seg)+(Off))) + (memory_read_byte_8le(cpustate->program, (DefaultBase(Seg)+((Off)+1)))<<8) )
+#define GetMemB(Seg,Off) ((UINT8)cpustate->program->read_byte((DefaultBase(Seg)+(Off))))
+#define GetMemW(Seg,Off) ((UINT16) cpustate->program->read_byte((DefaultBase(Seg)+(Off))) + (cpustate->program->read_byte((DefaultBase(Seg)+((Off)+1)))<<8) )
 
-#define PutMemB(Seg,Off,x) { memory_write_byte_8le(cpustate->program, (DefaultBase(Seg)+(Off)),(x)); }
+#define PutMemB(Seg,Off,x) { cpustate->program->write_byte((DefaultBase(Seg)+(Off)),(x)); }
 #define PutMemW(Seg,Off,x) { PutMemB(Seg,Off,(x)&0xff); PutMemB(Seg,(Off)+1,(BYTE)((x)>>8)); }
 
 /* Todo:  Remove these later - plus readword could overflow */
-#define ReadByte(ea) ((BYTE)memory_read_byte_8le(cpustate->program, (ea)))
-#define ReadWord(ea) (memory_read_byte_8le(cpustate->program, (ea))+(memory_read_byte_8le(cpustate->program, ((ea)+1))<<8))
-#define WriteByte(ea,val) { memory_write_byte_8le(cpustate->program, (ea),val); }
-#define WriteWord(ea,val) { memory_write_byte_8le(cpustate->program, (ea),(BYTE)(val)); memory_write_byte_8le(cpustate->program, ((ea)+1),(val)>>8); }
-
-#define read_port(port) memory_read_byte_8le(cpustate->io, port)
-#define write_port(port,val) memory_write_byte_8le(cpustate->io, port,val)
-
-#define FETCH (memory_raw_read_byte(cpustate->program, (cpustate->sregs[CS]<<4)+cpustate->ip++))
-#define FETCHOP (memory_decrypted_read_byte(cpustate->program, (cpustate->sregs[CS]<<4)+cpustate->ip++))
-#define FETCHWORD(var) { var=memory_raw_read_byte(cpustate->program, (((cpustate->sregs[CS]<<4)+cpustate->ip)))+(memory_raw_read_byte(cpustate->program, (((cpustate->sregs[CS]<<4)+cpustate->ip+1)))<<8); cpustate->ip+=2; }
+#define ReadByte(ea) ((BYTE)cpustate->program->read_byte((ea)))
+#define ReadWord(ea) (cpustate->program->read_byte((ea))+(cpustate->program->read_byte(((ea)+1))<<8))
+#define WriteByte(ea,val) { cpustate->program->write_byte((ea),val); }
+#define WriteWord(ea,val) { cpustate->program->write_byte((ea),(BYTE)(val)); cpustate->program->write_byte(((ea)+1),(val)>>8); }
+
+#define read_port(port) cpustate->io->read_byte(port)
+#define write_port(port,val) cpustate->io->write_byte(port,val)
+
+#define FETCH (cpustate->direct->read_raw_byte((cpustate->sregs[CS]<<4)+cpustate->ip++))
+#define FETCHOP (cpustate->direct->read_decrypted_byte((cpustate->sregs[CS]<<4)+cpustate->ip++))
+#define FETCHWORD(var) { var=cpustate->direct->read_raw_byte((((cpustate->sregs[CS]<<4)+cpustate->ip)))+(cpustate->direct->read_raw_byte((((cpustate->sregs[CS]<<4)+cpustate->ip+1)))<<8); cpustate->ip+=2; }
 #define PUSH(val) { cpustate->regs.w[SP]-=2; WriteWord((((cpustate->sregs[SS]<<4)+cpustate->regs.w[SP])),val); }
 #define POP(var) { var = ReadWord((((cpustate->sregs[SS]<<4)+cpustate->regs.w[SP]))); cpustate->regs.w[SP]+=2; }
-#define PEEK(addr) ((BYTE)memory_raw_read_byte(cpustate->program, addr))
-#define PEEKOP(addr) ((BYTE)memory_decrypted_read_byte(cpustate->program, addr))
+#define PEEK(addr) ((BYTE)cpustate->direct->read_raw_byte(addr))
+#define PEEKOP(addr) ((BYTE)cpustate->direct->read_decrypted_byte(addr))
 
-#define GetModRM UINT32 ModRM=memory_raw_read_byte(cpustate->program, (cpustate->sregs[CS]<<4)+cpustate->ip++)
+#define GetModRM UINT32 ModRM=cpustate->direct->read_raw_byte((cpustate->sregs[CS]<<4)+cpustate->ip++)
 
 /* Cycle count macros:
     CLK  - cycle count is the same on all processors
diff -Nru src-old/emu/cpu/v60/am.c src/emu/cpu/v60/am.c
--- src-old/emu/cpu/v60/am.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/am.c	2010-08-21 11:40:01.000000000 -0700
@@ -25,14 +25,14 @@
 static UINT32 ReadAM(v60_state *cpustate)
 {
 	cpustate->modm = cpustate->modm?1:0;
-	cpustate->modval = OpRead8(cpustate->program, cpustate->modadd);
+	cpustate->modval = OpRead8(cpustate, cpustate->modadd);
 	return AMTable1[cpustate->modm][cpustate->modval >> 5](cpustate);
 }
 
 static UINT32 BitReadAM(v60_state *cpustate)
 {
 	cpustate->modm = cpustate->modm?1:0;
-	cpustate->modval = OpRead8(cpustate->program, cpustate->modadd);
+	cpustate->modval = OpRead8(cpustate, cpustate->modadd);
 	return BAMTable1[cpustate->modm][cpustate->modval >> 5](cpustate);
 }
 
@@ -52,14 +52,14 @@
 static UINT32 ReadAMAddress(v60_state *cpustate)
 {
 	cpustate->modm = cpustate->modm?1:0;
-	cpustate->modval = OpRead8(cpustate->program, cpustate->modadd);
+	cpustate->modval = OpRead8(cpustate, cpustate->modadd);
 	return AMTable2[cpustate->modm][cpustate->modval >> 5](cpustate);
 }
 
 static UINT32 BitReadAMAddress(v60_state *cpustate)
 {
 	cpustate->modm = cpustate->modm?1:0;
-	cpustate->modval = OpRead8(cpustate->program, cpustate->modadd);
+	cpustate->modval = OpRead8(cpustate, cpustate->modadd);
 	return BAMTable2[cpustate->modm][cpustate->modval >> 5](cpustate);
 }
 
@@ -77,7 +77,7 @@
 static UINT32 WriteAM(v60_state *cpustate)
 {
 	cpustate->modm = cpustate->modm?1:0;
-	cpustate->modval = OpRead8(cpustate->program, cpustate->modadd);
+	cpustate->modval = OpRead8(cpustate, cpustate->modadd);
 	return AMTable3[cpustate->modm][cpustate->modval >> 5](cpustate);
 }
 
diff -Nru src-old/emu/cpu/v60/am1.c src/emu/cpu/v60/am1.c
--- src-old/emu/cpu/v60/am1.c	2009-01-13 23:10:30.000000000 -0800
+++ src/emu/cpu/v60/am1.c	2010-08-21 11:40:01.000000000 -0700
@@ -25,13 +25,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	}
 
@@ -41,7 +41,7 @@
 static UINT32 bam1RegisterIndirect(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 	return 1;
 }
 
@@ -50,13 +50,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -66,7 +66,7 @@
 static UINT32 bam1RegisterIndirectIndexed(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 2;
 }
@@ -76,15 +76,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F]);
 		cpustate->reg[cpustate->modval & 0x1F]++;
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		cpustate->reg[cpustate->modval & 0x1F] +=2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		cpustate->reg[cpustate->modval & 0x1F] +=4;
 		break;
 	}
@@ -95,7 +95,7 @@
 static UINT32 bam1Autoincrement(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 	switch (cpustate->moddim)
 	{
 	case 10:
@@ -117,15 +117,15 @@
 	{
 	case 0:
 		cpustate->reg[cpustate->modval & 0x1F]--;
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
 		cpustate->reg[cpustate->modval & 0x1F]-=2;
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 2:
 		cpustate->reg[cpustate->modval & 0x1F]-=4;
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	}
 
@@ -147,7 +147,7 @@
 		fatalerror("CPU - BAM1 - 7");
 		break;
 	}
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F]);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F]);
 	return 1;
 }
 
@@ -156,13 +156,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -171,8 +171,8 @@
 
 static UINT32 bam1Displacement8(v60_state *cpustate)
 {
-	cpustate->bamoffset = MemRead8(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
+	cpustate->bamoffset = cpustate->program->read_byte(cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 2;
 }
@@ -183,13 +183,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -198,8 +198,8 @@
 
 static UINT32 bam1Displacement16(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead16(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead16(cpustate, cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -209,13 +209,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -224,8 +224,8 @@
 
 static UINT32 bam1Displacement32(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 5;
 }
@@ -235,13 +235,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -251,7 +251,7 @@
 static UINT32 bam1DisplacementIndexed8(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -261,13 +261,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -277,7 +277,7 @@
 static UINT32 bam1DisplacementIndexed16(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 4;
 }
@@ -287,13 +287,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -303,7 +303,7 @@
 static UINT32 bam1DisplacementIndexed32(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -314,13 +314,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -329,8 +329,8 @@
 
 static UINT32 bam1PCDisplacement8(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead8(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead8(cpustate, cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 2;
 }
@@ -340,13 +340,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -355,8 +355,8 @@
 
 static UINT32 bam1PCDisplacement16(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead16(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead16(cpustate, cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -366,13 +366,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -381,8 +381,8 @@
 
 static UINT32 bam1PCDisplacement32(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 1);
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 1);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 5;
 }
@@ -392,13 +392,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -408,7 +408,7 @@
 static UINT32 bam1PCDisplacementIndexed8(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -419,13 +419,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -435,7 +435,7 @@
 static UINT32 bam1PCDisplacementIndexed16(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 4;
 }
@@ -445,13 +445,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -461,7 +461,7 @@
 static UINT32 bam1PCDisplacementIndexed32(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -471,13 +471,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -487,7 +487,7 @@
 static UINT32 bam1DisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 	return 2;
 }
 
@@ -496,13 +496,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -512,7 +512,7 @@
 static UINT32 bam1DisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 	return 3;
 }
 
@@ -521,13 +521,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -537,7 +537,7 @@
 static UINT32 bam1DisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)));
 	return 5;
 }
 
@@ -546,13 +546,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -562,7 +562,7 @@
 static UINT32 bam1DisplacementIndirectIndexed8(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -572,13 +572,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -588,7 +588,7 @@
 static UINT32 bam1DisplacementIndirectIndexed16(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 4;
 }
@@ -598,13 +598,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -614,7 +614,7 @@
 static UINT32 bam1DisplacementIndirectIndexed32(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -624,13 +624,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -640,7 +640,7 @@
 static UINT32 bam1PCDisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)));
 	return 2;
 }
 
@@ -649,13 +649,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -665,7 +665,7 @@
 static UINT32 bam1PCDisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)));
 	return 3;
 }
 
@@ -674,13 +674,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -690,7 +690,7 @@
 static UINT32 bam1PCDisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)));
 	return 5;
 }
 
@@ -699,13 +699,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -715,7 +715,7 @@
 static UINT32 bam1PCDisplacementIndirectIndexed8(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -725,13 +725,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -741,7 +741,7 @@
 static UINT32 bam1PCDisplacementIndirectIndexed16(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 4;
 }
@@ -751,13 +751,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -767,7 +767,7 @@
 static UINT32 bam1PCDisplacementIndirectIndexed32(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -777,15 +777,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 	}
 
@@ -794,8 +794,8 @@
 
 static UINT32 bam1DoubleDisplacement8(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead8(cpustate->program, cpustate->modadd + 2);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead8(cpustate, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -805,15 +805,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 	}
 
@@ -822,8 +822,8 @@
 
 static UINT32 bam1DoubleDisplacement16(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead16(cpustate->program, cpustate->modadd + 3);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead16(cpustate, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 5;
 }
@@ -833,15 +833,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 	}
 
@@ -850,8 +850,8 @@
 
 static UINT32 bam1DoubleDisplacement32(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 5);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 9;
 }
@@ -861,15 +861,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 		break;
 	}
 
@@ -878,8 +878,8 @@
 
 static UINT32 bam1PCDoubleDisplacement8(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead8(cpustate->program, cpustate->modadd + 2);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead8(cpustate, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 3;
 }
@@ -889,15 +889,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3));
 		break;
 	}
 
@@ -906,8 +906,8 @@
 
 static UINT32 bam1PCDoubleDisplacement16(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead16(cpustate->program, cpustate->modadd + 3);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead16(cpustate, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 5;
 }
@@ -918,15 +918,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5));
 		break;
 	}
 
@@ -935,8 +935,8 @@
 
 static UINT32 bam1PCDoubleDisplacement32(v60_state *cpustate)
 {
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 5);
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 9;
 }
@@ -946,15 +946,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_byte(OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_word_unaligned(OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1));
 		break;
 	}
 
@@ -964,7 +964,7 @@
 static UINT32 bam1DirectAddress(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1));
 	return 5;
 }
 
@@ -973,15 +973,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -991,7 +991,7 @@
 static UINT32 bam1DirectAddressIndexed(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -1001,15 +1001,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)));
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)));
 		break;
 	}
 
@@ -1019,7 +1019,7 @@
 static UINT32 bam1DirectAddressDeferred(v60_state *cpustate)
 {
 	cpustate->bamoffset = 0;
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)));
 	return 5;
 }
 
@@ -1028,15 +1028,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead8(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
+		cpustate->amout = cpustate->program->read_byte(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F]);
 		break;
 
 	case 1:
-		cpustate->amout = MemRead16(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
+		cpustate->amout = cpustate->program->read_word_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2);
 		break;
 
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4);
 		break;
 	}
 
@@ -1046,7 +1046,7 @@
 static UINT32 bam1DirectAddressDeferredIndexed(v60_state *cpustate)
 {
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->amout = MemRead32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->bamoffset / 8);
 	cpustate->bamoffset&=7;
 	return 6;
 }
@@ -1056,15 +1056,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = OpRead8(cpustate->program, cpustate->modadd + 1);
+		cpustate->amout = OpRead8(cpustate, cpustate->modadd + 1);
 		return 2;
 
 	case 1:
-		cpustate->amout = OpRead16(cpustate->program, cpustate->modadd + 1);
+		cpustate->amout = OpRead16(cpustate, cpustate->modadd + 1);
 		return 3;
 
 	case 2:
-		cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 1);
+		cpustate->amout = OpRead32(cpustate, cpustate->modadd + 1);
 		return 5;
 	}
 
@@ -1311,13 +1311,13 @@
 
 static UINT32 am1Group6(v60_state *cpustate)
 {
-	cpustate->modval2 = OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->modval2 = OpRead8(cpustate, cpustate->modadd + 1);
 	return AMTable1_G6[cpustate->modval2 >> 5](cpustate);
 }
 
 static UINT32 bam1Group6(v60_state *cpustate)
 {
-	cpustate->modval2 = OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->modval2 = OpRead8(cpustate, cpustate->modadd + 1);
 	return BAMTable1_G6[cpustate->modval2 >> 5](cpustate);
 }
 
diff -Nru src-old/emu/cpu/v60/am2.c src/emu/cpu/v60/am2.c
--- src-old/emu/cpu/v60/am2.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/am2.c	2010-08-21 11:40:01.000000000 -0700
@@ -151,7 +151,7 @@
 static UINT32 am2Displacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1);
 
 	return 2;
 }
@@ -160,7 +160,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 1);
 
 	return 2;
 }
@@ -168,7 +168,7 @@
 static UINT32 am2Displacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1);
 
 	return 3;
 }
@@ -177,7 +177,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->bamoffset = (INT16)OpRead16(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = (INT16)OpRead16(cpustate, cpustate->modadd + 1);
 
 	return 3;
 }
@@ -185,7 +185,7 @@
 static UINT32 am2Displacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1);
 
 	return 5;
 }
@@ -194,7 +194,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->reg[cpustate->modval & 0x1F];
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 1);
 
 	return 5;
 }
@@ -206,16 +206,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -225,7 +225,7 @@
 static UINT32 bam2DisplacementIndexed8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 3;
@@ -238,16 +238,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -257,7 +257,7 @@
 static UINT32 bam2DisplacementIndexed16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 4;
@@ -270,16 +270,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -289,7 +289,7 @@
 static UINT32 bam2DisplacementIndexed32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -298,7 +298,7 @@
 static UINT32 am2PCDisplacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1);
 
 	return 2;
 }
@@ -307,7 +307,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->PC;
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 1);
 
 	return 2;
 }
@@ -315,7 +315,7 @@
 static UINT32 am2PCDisplacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1);
 
 	return 3;
 }
@@ -324,7 +324,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->PC;
-	cpustate->bamoffset = (INT16)OpRead16(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = (INT16)OpRead16(cpustate, cpustate->modadd + 1);
 
 	return 3;
 }
@@ -332,7 +332,7 @@
 static UINT32 am2PCDisplacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1);
 
 	return 5;
 }
@@ -341,7 +341,7 @@
 {
 	cpustate->amflag = 0;
 	cpustate->amout = cpustate->PC;
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 1);
 
 	return 5;
 }
@@ -354,16 +354,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -373,7 +373,7 @@
 static UINT32 bam2PCDisplacementIndexed8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 3;
@@ -386,16 +386,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -405,7 +405,7 @@
 static UINT32 bam2PCDisplacementIndexed16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 4;
@@ -418,16 +418,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -437,7 +437,7 @@
 static UINT32 bam2PCDisplacementIndexed32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -446,7 +446,7 @@
 static UINT32 am2DisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 
 	return 2;
 }
@@ -454,7 +454,7 @@
 static UINT32 bam2DisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 	return 2;
 }
@@ -462,7 +462,7 @@
 static UINT32 am2DisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 
 	return 3;
 }
@@ -470,7 +470,7 @@
 static UINT32 bam2DisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 	return 3;
 }
@@ -478,7 +478,7 @@
 static UINT32 am2DisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
 
 	return 5;
 }
@@ -486,7 +486,7 @@
 static UINT32 bam2DisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 
 	return 5;
@@ -499,16 +499,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -518,7 +518,7 @@
 static UINT32 bam2DisplacementIndirectIndexed8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 3;
@@ -531,16 +531,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -550,7 +550,7 @@
 static UINT32 bam2DisplacementIndirectIndexed16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 4;
@@ -563,16 +563,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -582,7 +582,7 @@
 static UINT32 bam2DisplacementIndirectIndexed32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -591,7 +591,7 @@
 static UINT32 am2PCDisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 
 	return 2;
 }
@@ -599,7 +599,7 @@
 static UINT32 bam2PCDisplacementIndirect8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 
 	return 2;
@@ -608,7 +608,7 @@
 static UINT32 am2PCDisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 
 	return 3;
 }
@@ -616,7 +616,7 @@
 static UINT32 bam2PCDisplacementIndirect16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 
 	return 3;
@@ -625,7 +625,7 @@
 static UINT32 am2PCDisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
 
 	return 5;
 }
@@ -633,7 +633,7 @@
 static UINT32 bam2PCDisplacementIndirect32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 
 	return 5;
@@ -646,16 +646,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -665,7 +665,7 @@
 static UINT32 bam2PCDisplacementIndirectIndexed8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 3;
@@ -678,16 +678,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -698,7 +698,7 @@
 static UINT32 bam2PCDisplacementIndirectIndexed16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 4;
@@ -712,16 +712,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -731,7 +731,7 @@
 static UINT32 bam2PCDisplacementIndirectIndexed32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -740,7 +740,7 @@
 static UINT32 am2DoubleDisplacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 
 	return 3;
 }
@@ -748,8 +748,8 @@
 static UINT32 bam2DoubleDisplacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 
 	return 3;
 }
@@ -757,7 +757,7 @@
 static UINT32 am2DoubleDisplacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3);
 
 	return 5;
 }
@@ -765,8 +765,8 @@
 static UINT32 bam2DoubleDisplacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 3);
 
 	return 5;
 }
@@ -774,7 +774,7 @@
 static UINT32 am2DoubleDisplacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5);
 
 	return 9;
 }
@@ -782,8 +782,8 @@
 static UINT32 bam2DoubleDisplacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 5);
 
 	return 9;
 }
@@ -792,7 +792,7 @@
 static UINT32 am2PCDoubleDisplacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 
 	return 3;
 }
@@ -800,8 +800,8 @@
 static UINT32 bam2PCDoubleDisplacement8(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 2);
 
 	return 3;
 }
@@ -809,7 +809,7 @@
 static UINT32 am2PCDoubleDisplacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3);
 
 	return 5;
 }
@@ -817,8 +817,8 @@
 static UINT32 bam2PCDoubleDisplacement16(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = (INT8)OpRead8(cpustate->program, cpustate->modadd + 3);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = (INT8)OpRead8(cpustate, cpustate->modadd + 3);
 
 	return 5;
 }
@@ -826,7 +826,7 @@
 static UINT32 am2PCDoubleDisplacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5);
 
 	return 9;
 }
@@ -834,8 +834,8 @@
 static UINT32 bam2PCDoubleDisplacement32(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1));
-	cpustate->bamoffset = OpRead32(cpustate->program, cpustate->modadd + 5);
+	cpustate->amout = cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1));
+	cpustate->bamoffset = OpRead32(cpustate, cpustate->modadd + 5);
 
 	return 9;
 }
@@ -843,7 +843,7 @@
 static UINT32 am2DirectAddress(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = OpRead32(cpustate, cpustate->modadd + 1);
 
 	return 5;
 }
@@ -851,7 +851,7 @@
 static UINT32 bam2DirectAddress(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 1);
+	cpustate->amout = OpRead32(cpustate, cpustate->modadd + 1);
 	cpustate->bamoffset = 0;
 
 	return 5;
@@ -864,16 +864,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -883,7 +883,7 @@
 static UINT32 bam2DirectAddressIndexed(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = OpRead32(cpustate->program, cpustate->modadd + 2);
+	cpustate->amout = OpRead32(cpustate, cpustate->modadd + 2);
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -892,7 +892,7 @@
 static UINT32 am2DirectAddressDeferred(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1));
 
 	return 5;
 }
@@ -900,7 +900,7 @@
 static UINT32 bam2DirectAddressDeferred(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1));
+	cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1));
 	cpustate->bamoffset = 0;
 
 	return 5;
@@ -913,16 +913,16 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F];
 		break;
 	case 1:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2;
 		break;
 	case 2:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4;
 		break;
 	case 3:
-		cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
+		cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 8;
 		break;
 	}
 
@@ -932,7 +932,7 @@
 static UINT32 bam2DirectAddressDeferredIndexed(v60_state *cpustate)
 {
 	cpustate->amflag = 0;
-	cpustate->amout = MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2));
+	cpustate->amout = cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2));
 	cpustate->bamoffset = cpustate->reg[cpustate->modval & 0x1F];
 
 	return 6;
@@ -1182,12 +1182,12 @@
 
 static UINT32 am2Group6(v60_state *cpustate)
 {
-	cpustate->modval2 = OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->modval2 = OpRead8(cpustate, cpustate->modadd + 1);
 	return AMTable2_G6[cpustate->modval2 >> 5](cpustate);
 }
 static UINT32 bam2Group6(v60_state *cpustate)
 {
-	cpustate->modval2 = OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->modval2 = OpRead8(cpustate, cpustate->modadd + 1);
 	return BAMTable2_G6[cpustate->modval2 >> 5](cpustate);
 }
 
diff -Nru src-old/emu/cpu/v60/am3.c src/emu/cpu/v60/am3.c
--- src-old/emu/cpu/v60/am3.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/am3.c	2010-08-21 11:40:01.000000000 -0700
@@ -25,13 +25,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
 		break;
 	}
 
@@ -43,13 +43,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -61,15 +61,15 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		cpustate->reg[cpustate->modval & 0x1F] += 1;
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
 		cpustate->reg[cpustate->modval & 0x1F] += 2;
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
 		cpustate->reg[cpustate->modval & 0x1F] += 4;
 		break;
 	}
@@ -83,15 +83,15 @@
 	{
 	case 0:
 		cpustate->reg[cpustate->modval & 0x1F] -= 1;
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
 		cpustate->reg[cpustate->modval & 0x1F] -= 2;
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
 		break;
 	case 2:
 		cpustate->reg[cpustate->modval & 0x1F] -= 4;
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
 		break;
 	}
 
@@ -103,13 +103,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -121,13 +121,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -139,13 +139,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -158,13 +158,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -176,13 +176,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -194,13 +194,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -213,13 +213,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -231,13 +231,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -249,13 +249,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -267,13 +267,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -285,13 +285,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -303,13 +303,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -321,13 +321,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -339,13 +339,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -357,13 +357,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -376,13 +376,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -394,13 +394,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -412,13 +412,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval2 & 0x1F] + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -430,13 +430,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -448,13 +448,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -466,13 +466,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -485,13 +485,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -503,13 +503,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -521,13 +521,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -540,13 +540,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalw);
 		break;
 	}
 
@@ -558,13 +558,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalw);
 		break;
 	}
 
@@ -576,13 +576,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->reg[cpustate->modval & 0x1F] + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalw);
 		break;
 	}
 
@@ -595,13 +595,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT8)OpRead8(cpustate->program, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate->program, cpustate->modadd + 2), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT8)OpRead8(cpustate, cpustate->modadd + 1)) + (INT8)OpRead8(cpustate, cpustate->modadd + 2), cpustate->modwritevalw);
 		break;
 	}
 
@@ -613,13 +613,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + (INT16)OpRead16(cpustate->program, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate->program, cpustate->modadd + 3), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + (INT16)OpRead16(cpustate, cpustate->modadd + 1)) + (INT16)OpRead16(cpustate, cpustate->modadd + 3), cpustate->modwritevalw);
 		break;
 	}
 
@@ -631,13 +631,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, cpustate->PC + OpRead32(cpustate->program, cpustate->modadd + 1)) + OpRead32(cpustate->program, cpustate->modadd + 5), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(cpustate->PC + OpRead32(cpustate, cpustate->modadd + 1)) + OpRead32(cpustate, cpustate->modadd + 5), cpustate->modwritevalw);
 		break;
 	}
 
@@ -649,13 +649,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalb);
+		cpustate->program->write_byte(OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1), cpustate->modwritevalw);
 		break;
 	}
 
@@ -667,13 +667,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 2, cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2) + cpustate->reg[cpustate->modval & 0x1F] * 4, cpustate->modwritevalw);
 		break;
 	}
 
@@ -685,13 +685,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 1)), cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 1)), cpustate->modwritevalw);
 		break;
 	}
 
@@ -703,13 +703,13 @@
 	switch (cpustate->moddim)
 	{
 	case 0:
-		MemWrite8(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
+		cpustate->program->write_byte(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalb);
 		break;
 	case 1:
-		MemWrite16(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
+		cpustate->program->write_word_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalh);
 		break;
 	case 2:
-		MemWrite32(cpustate->program, MemRead32(cpustate->program, OpRead32(cpustate->program, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
+		cpustate->program->write_dword_unaligned(cpustate->program->read_dword_unaligned(OpRead32(cpustate, cpustate->modadd + 2)) + cpustate->reg[cpustate->modval & 0x1F], cpustate->modwritevalw);
 		break;
 	}
 
@@ -846,7 +846,7 @@
 
 static UINT32 am3Group6(v60_state *cpustate)
 {
-	cpustate->modval2 = OpRead8(cpustate->program, cpustate->modadd + 1);
+	cpustate->modval2 = OpRead8(cpustate, cpustate->modadd + 1);
 	return AMTable3_G6[cpustate->modval2 >> 5](cpustate);
 }
 
diff -Nru src-old/emu/cpu/v60/op12.c src/emu/cpu/v60/op12.c
--- src-old/emu/cpu/v60/op12.c	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/v60/op12.c	2010-08-21 11:40:01.000000000 -0700
@@ -20,37 +20,37 @@
 	if ((cs)->flag##num)								\
 		appb = (UINT8)(cs)->reg[(cs)->op##num];			\
 	else												\
-		appb = MemRead8((cs)->program, (cs)->op##num);
+		appb = (cs)->program->read_byte((cs)->op##num);
 
 #define F12LOADOPHALF(cs, num)							\
 	if ((cs)->flag##num)								\
 		apph = (UINT16)(cs)->reg[(cs)->op##num];		\
 	else												\
-		apph = MemRead16((cs)->program, (cs)->op##num);
+		apph = (cs)->program->read_word_unaligned((cs)->op##num);
 
 #define F12LOADOPWORD(cs, num)							\
 	if ((cs)->flag##num)								\
 		appw = (cs)->reg[(cs)->op##num];				\
 	else												\
-		appw = MemRead32((cs)->program,(cs)->op##num);
+		appw = (cs)->program->read_dword_unaligned((cs)->op##num);
 
 #define F12STOREOPBYTE(cs, num)							\
 	if ((cs)->flag##num)								\
 		SETREG8((cs)->reg[(cs)->op##num], appb);		\
 	else												\
-		MemWrite8((cs)->program, (cs)->op##num, appb);
+		(cs)->program->write_byte((cs)->op##num, appb);
 
 #define F12STOREOPHALF(cs, num)							\
 	if ((cs)->flag##num)								\
 		SETREG16((cs)->reg[(cs)->op##num], apph);		\
 	else												\
-		MemWrite16((cs)->program, (cs)->op##num, apph);
+		(cs)->program->write_word_unaligned((cs)->op##num, apph);
 
 #define F12STOREOPWORD(cs, num)							\
 	if ((cs)->flag##num)								\
 		(cs)->reg[(cs)->op##num] = appw;				\
 	else												\
-		MemWrite32((cs)->program, (cs)->op##num, appw);
+		(cs)->program->write_dword_unaligned((cs)->op##num, appw);
 
 #define F12LOADOP1BYTE(cs)  F12LOADOPBYTE(cs, 1)
 #define F12LOADOP1HALF(cs)  F12LOADOPHALF(cs, 1)
@@ -76,7 +76,7 @@
 // writing to the second operand.
 static void F12DecodeFirstOperand(v60_state *cpustate, UINT32 (*DecodeOp1)(v60_state *), UINT8 dim1)
 {
-	cpustate->instflags = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->instflags = OpRead8(cpustate, cpustate->PC + 1);
 
 	// Check if F1 or F2
 	if (cpustate->instflags & 0x80)
@@ -177,7 +177,7 @@
 // Decode both format 1 / 2 operands
 static void F12DecodeOperands(v60_state *cpustate, UINT32 (*DecodeOp1)(v60_state *), UINT8 dim1, UINT32 (*DecodeOp2)(v60_state *), UINT8 dim2)
 {
-	UINT8 _if12 = OpRead8(cpustate->program, cpustate->PC + 1);
+	UINT8 _if12 = OpRead8(cpustate, cpustate->PC + 1);
 
 	// Check if F1 or F2
 	if (_if12 & 0x80)
@@ -402,11 +402,11 @@
 	F12DecodeOperands(cpustate, ReadAMAddress, 0,ReadAMAddress, 2);
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->AP);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->AP);
 	cpustate->AP = cpustate->op2;
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + cpustate->amlength1 + cpustate->amlength2 + 2);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + cpustate->amlength1 + cpustate->amlength2 + 2);
 	cpustate->PC = cpustate->op1;
 
 	return 0;
@@ -462,16 +462,16 @@
 	oldPSW = v60_update_psw_for_exception(cpustate, 0, cpustate->op1);
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->op2);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->op2);
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x1800 + cpustate->op1 * 0x100, 8));
+	cpustate->program->write_dword_unaligned(cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x1800 + cpustate->op1 * 0x100, 8));
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, oldPSW);
+	cpustate->program->write_dword_unaligned(cpustate->SP, oldPSW);
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + cpustate->amlength1 + cpustate->amlength2 + 2);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + cpustate->amlength1 + cpustate->amlength2 + 2);
 
 	cpustate->PC = GETINTVECT(cpustate, 24 + cpustate->op1);
 
@@ -591,8 +591,8 @@
 	}
 	else
 	{
-		a = MemRead32(cpustate->program, cpustate->op2);
-		b = MemRead32(cpustate->program, cpustate->op2 + 4);
+		a = cpustate->program->read_dword_unaligned(cpustate->op2);
+		b = cpustate->program->read_dword_unaligned(cpustate->op2 + 4);
 	}
 
 	dv = ((UINT64)b << 32) | ((UINT64)a);
@@ -610,8 +610,8 @@
 	}
 	else
 	{
-		MemWrite32(cpustate->program, cpustate->op2, a);
-		MemWrite32(cpustate->program, cpustate->op2 + 4, b);
+		cpustate->program->write_dword_unaligned(cpustate->op2, a);
+		cpustate->program->write_dword_unaligned(cpustate->op2 + 4, b);
 	}
 
 	F12END(cpustate);
@@ -631,8 +631,8 @@
 	}
 	else
 	{
-		a = MemRead32(cpustate->program, cpustate->op2);
-		b = MemRead32(cpustate->program, cpustate->op2 + 4);
+		a = cpustate->program->read_dword_unaligned(cpustate->op2);
+		b = cpustate->program->read_dword_unaligned(cpustate->op2 + 4);
 	}
 
 	dv = (UINT64)(((UINT64)b << 32) | (UINT64)a);
@@ -649,8 +649,8 @@
 	}
 	else
 	{
-		MemWrite32(cpustate->program, cpustate->op2, a);
-		MemWrite32(cpustate->program, cpustate->op2 + 4, b);
+		cpustate->program->write_dword_unaligned(cpustate->op2, a);
+		cpustate->program->write_dword_unaligned(cpustate->op2 + 4, b);
 	}
 
 	F12END(cpustate);
@@ -708,7 +708,7 @@
 static UINT32 opINB(v60_state *cpustate)
 {
 	F12DecodeFirstOperand(cpustate, ReadAMAddress, 0);
-	cpustate->modwritevalb = MemRead8(cpustate->io, cpustate->op1);
+	cpustate->modwritevalb = cpustate->io->read_byte(cpustate->op1);
 
 	if ( cpustate->stall_io )
 	{
@@ -723,7 +723,7 @@
 static UINT32 opINH(v60_state *cpustate)
 {
 	F12DecodeFirstOperand(cpustate, ReadAMAddress, 1);
-	cpustate->modwritevalh = MemRead16(cpustate->io, cpustate->op1);
+	cpustate->modwritevalh = cpustate->io->read_word_unaligned(cpustate->op1);
 
 	if ( cpustate->stall_io )
 	{
@@ -738,7 +738,7 @@
 static UINT32 opINW(v60_state *cpustate)
 {
 	F12DecodeFirstOperand(cpustate, ReadAMAddress, 2);
-	cpustate->modwritevalw = MemRead32(cpustate->io, cpustate->op1);
+	cpustate->modwritevalw = cpustate->io->read_dword_unaligned(cpustate->op1);
 
 	if ( cpustate->stall_io )
 	{
@@ -755,7 +755,7 @@
 	F12DecodeOperands(cpustate, ReadAMAddress, 2,ReadAM, 2);
 	if (cpustate->op2 >= 0 && cpustate->op2 <= 28)
 	{
-	  if (cpustate->flag1 &&(!(OpRead8(cpustate->program, cpustate->PC + 1)&0x80 && OpRead8(cpustate->program, cpustate->PC + 2) == 0xf4 ) ))
+	  if (cpustate->flag1 &&(!(OpRead8(cpustate, cpustate->PC + 1)&0x80 && OpRead8(cpustate, cpustate->PC + 2) == 0xf4 ) ))
 			cpustate->reg[cpustate->op2 + 36] = cpustate->reg[cpustate->op1];
 		else
 			cpustate->reg[cpustate->op2 + 36] = cpustate->op1;
@@ -776,22 +776,22 @@
 
 	cpustate->TR = cpustate->op2;
 
-	cpustate->TKCW = MemRead32(cpustate->program, cpustate->op2);
+	cpustate->TKCW = cpustate->program->read_dword_unaligned(cpustate->op2);
 	cpustate->op2 += 4;
 	if(cpustate->SYCW & 0x100) {
-		cpustate->L0SP = MemRead32(cpustate->program, cpustate->op2);
+		cpustate->L0SP = cpustate->program->read_dword_unaligned(cpustate->op2);
 		cpustate->op2 += 4;
 	}
 	if(cpustate->SYCW & 0x200) {
-		cpustate->L1SP = MemRead32(cpustate->program, cpustate->op2);
+		cpustate->L1SP = cpustate->program->read_dword_unaligned(cpustate->op2);
 		cpustate->op2 += 4;
 	}
 	if(cpustate->SYCW & 0x400) {
-		cpustate->L2SP = MemRead32(cpustate->program, cpustate->op2);
+		cpustate->L2SP = cpustate->program->read_dword_unaligned(cpustate->op2);
 		cpustate->op2 += 4;
 	}
 	if(cpustate->SYCW & 0x800) {
-		cpustate->L3SP = MemRead32(cpustate->program, cpustate->op2);
+		cpustate->L3SP = cpustate->program->read_dword_unaligned(cpustate->op2);
 		cpustate->op2 += 4;
 	}
 
@@ -800,7 +800,7 @@
 	// 31 registers supported, _not_ 32
 	for(i = 0; i < 31; i++)
 		if(cpustate->op1 & (1 << i)) {
-			cpustate->reg[i] = MemRead32(cpustate->program, cpustate->op2);
+			cpustate->reg[i] = cpustate->program->read_dword_unaligned(cpustate->op2);
 			cpustate->op2 += 4;
 		}
 
@@ -822,8 +822,8 @@
 	}
 	else
 	{
-		a = MemRead32(cpustate->program, cpustate->op1);
-		b = MemRead32(cpustate->program, cpustate->op1 + 4);
+		a = cpustate->program->read_dword_unaligned(cpustate->op1);
+		b = cpustate->program->read_dword_unaligned(cpustate->op1 + 4);
 	}
 
 	if (cpustate->flag2)
@@ -833,8 +833,8 @@
 	}
 	else
 	{
-		MemWrite32(cpustate->program, cpustate->op2, a);
-		MemWrite32(cpustate->program, cpustate->op2 + 4, b);
+		cpustate->program->write_dword_unaligned(cpustate->op2, a);
+		cpustate->program->write_dword_unaligned(cpustate->op2 + 4, b);
 	}
 
 	F12END(cpustate);
@@ -1235,21 +1235,21 @@
 static UINT32 opOUTB(v60_state *cpustate)
 {
 	F12DecodeOperands(cpustate, ReadAM, 0,ReadAMAddress, 2);
-	MemWrite8(cpustate->io, cpustate->op2,(UINT8)cpustate->op1);
+	cpustate->io->write_byte(cpustate->op2,(UINT8)cpustate->op1);
 	F12END(cpustate);
 }
 
 static UINT32 opOUTH(v60_state *cpustate)
 {
 	F12DecodeOperands(cpustate, ReadAM, 1,ReadAMAddress, 2);
-	MemWrite16(cpustate->io, cpustate->op2,(UINT16)cpustate->op1);
+	cpustate->io->write_word_unaligned(cpustate->op2,(UINT16)cpustate->op1);
 	F12END(cpustate);
 }
 
 static UINT32 opOUTW(v60_state *cpustate)
 {
 	F12DecodeOperands(cpustate, ReadAM, 2,ReadAMAddress, 2);
-	MemWrite32(cpustate->io, cpustate->op2, cpustate->op1);
+	cpustate->io->write_dword_unaligned(cpustate->op2, cpustate->op1);
 	F12END(cpustate);
 }
 
@@ -2328,7 +2328,7 @@
 	}
 	else
 	{
-		a = MemRead32(cpustate->program, cpustate->op2);
+		a = cpustate->program->read_dword_unaligned(cpustate->op2);
 	}
 
 	res = (INT64)a * (INT64)(INT32)cpustate->op1;
@@ -2346,8 +2346,8 @@
 	}
 	else
 	{
-		MemWrite32(cpustate->program, cpustate->op2, a);
-		MemWrite32(cpustate->program, cpustate->op2 + 4, b);
+		cpustate->program->write_dword_unaligned(cpustate->op2, a);
+		cpustate->program->write_dword_unaligned(cpustate->op2 + 4, b);
 	}
 
 	F12END(cpustate);
@@ -2366,7 +2366,7 @@
 	}
 	else
 	{
-		a = MemRead32(cpustate->program, cpustate->op2);
+		a = cpustate->program->read_dword_unaligned(cpustate->op2);
 	}
 
 	res = (UINT64)a * (UINT64)cpustate->op1;
@@ -2383,8 +2383,8 @@
 	}
 	else
 	{
-		MemWrite32(cpustate->program, cpustate->op2, a);
-		MemWrite32(cpustate->program, cpustate->op2 + 4, b);
+		cpustate->program->write_dword_unaligned(cpustate->op2, a);
+		cpustate->program->write_dword_unaligned(cpustate->op2 + 4, b);
 	}
 
 	F12END(cpustate);
diff -Nru src-old/emu/cpu/v60/op2.c src/emu/cpu/v60/op2.c
--- src-old/emu/cpu/v60/op2.c	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/v60/op2.c	2010-08-21 11:40:01.000000000 -0700
@@ -7,13 +7,13 @@
 	if ((cs)->flag##num)									\
 		appf = u2f((cs)->reg[(cs)->op##num]);				\
 	else													\
-		appf = u2f(MemRead32((cs)->program, (cs)->op##num));
+		appf = u2f((cs)->program->read_dword_unaligned((cs)->op##num));
 
 #define F2STOREOPFLOAT(cs,num)								\
 	if ((cs)->flag##num)									\
 		(cs)->reg[(cs)->op##num] = f2u(appf);				\
 	else													\
-		MemWrite32((cs)->program, (cs)->op##num, f2u(appf));
+		(cs)->program->write_dword_unaligned((cs)->op##num, f2u(appf));
 
 static void F2DecodeFirstOperand(v60_state *cpustate, UINT32 (*DecodeOp1)(v60_state *), UINT8 dim1)
 {
@@ -341,13 +341,13 @@
 
 static UINT32 op5F(v60_state *cpustate)
 {
-	cpustate->instflags = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->instflags = OpRead8(cpustate, cpustate->PC + 1);
 	return Op5FTable[cpustate->instflags & 0x1F](cpustate);
 }
 
 
 static UINT32 op5C(v60_state *cpustate)
 {
-	cpustate->instflags = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->instflags = OpRead8(cpustate, cpustate->PC + 1);
 	return Op5CTable[cpustate->instflags & 0x1F](cpustate);
 }
diff -Nru src-old/emu/cpu/v60/op3.c src/emu/cpu/v60/op3.c
--- src-old/emu/cpu/v60/op3.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/op3.c	2010-08-21 11:40:01.000000000 -0700
@@ -9,14 +9,14 @@
 	if (cpustate->amflag)
 		appb = (UINT8)cpustate->reg[cpustate->amout];
 	else
-		appb = MemRead8(cpustate->program, cpustate->amout);
+		appb = cpustate->program->read_byte(cpustate->amout);
 
 	ADDB(appb, 1);
 
 	if (cpustate->amflag)
 		SETREG8(cpustate->reg[cpustate->amout], appb);
 	else
-		MemWrite8(cpustate->program, cpustate->amout, appb);
+		cpustate->program->write_byte(cpustate->amout, appb);
 
 	return cpustate->amlength1 + 1;
 }
@@ -32,14 +32,14 @@
 	if (cpustate->amflag)
 		apph = (UINT16)cpustate->reg[cpustate->amout];
 	else
-		apph = MemRead16(cpustate->program, cpustate->amout);
+		apph = cpustate->program->read_word_unaligned(cpustate->amout);
 
 	ADDW(apph, 1);
 
 	if (cpustate->amflag)
 		SETREG16(cpustate->reg[cpustate->amout], apph);
 	else
-		MemWrite16(cpustate->program, cpustate->amout, apph);
+		cpustate->program->write_word_unaligned(cpustate->amout, apph);
 
 	return cpustate->amlength1 + 1;
 }
@@ -55,14 +55,14 @@
 	if (cpustate->amflag)
 		appw = cpustate->reg[cpustate->amout];
 	else
-		appw = MemRead32(cpustate->program, cpustate->amout);
+		appw = cpustate->program->read_dword_unaligned(cpustate->amout);
 
 	ADDL(appw, 1);
 
 	if (cpustate->amflag)
 		cpustate->reg[cpustate->amout] = appw;
 	else
-		MemWrite32(cpustate->program, cpustate->amout, appw);
+		cpustate->program->write_dword_unaligned(cpustate->amout, appw);
 
 	return cpustate->amlength1 + 1;
 }
@@ -78,14 +78,14 @@
 	if (cpustate->amflag)
 		appb = (UINT8)cpustate->reg[cpustate->amout];
 	else
-		appb = MemRead8(cpustate->program, cpustate->amout);
+		appb = cpustate->program->read_byte(cpustate->amout);
 
 	SUBB(appb, 1);
 
 	if (cpustate->amflag)
 		SETREG8(cpustate->reg[cpustate->amout], appb);
 	else
-		MemWrite8(cpustate->program, cpustate->amout, appb);
+		cpustate->program->write_byte(cpustate->amout, appb);
 
 	return cpustate->amlength1 + 1;
 }
@@ -101,14 +101,14 @@
 	if (cpustate->amflag)
 		apph = (UINT16)cpustate->reg[cpustate->amout];
 	else
-		apph = MemRead16(cpustate->program, cpustate->amout);
+		apph = cpustate->program->read_word_unaligned(cpustate->amout);
 
 	SUBW(apph, 1);
 
 	if (cpustate->amflag)
 		SETREG16(cpustate->reg[cpustate->amout], apph);
 	else
-		MemWrite16(cpustate->program, cpustate->amout, apph);
+		cpustate->program->write_word_unaligned(cpustate->amout, apph);
 
 	return cpustate->amlength1 + 1;
 }
@@ -124,14 +124,14 @@
 	if (cpustate->amflag)
 		appw = cpustate->reg[cpustate->amout];
 	else
-		appw = MemRead32(cpustate->program, cpustate->amout);
+		appw = cpustate->program->read_dword_unaligned(cpustate->amout);
 
 	SUBL(appw, 1);
 
 	if (cpustate->amflag)
 		cpustate->reg[cpustate->amout] = appw;
 	else
-		MemWrite32(cpustate->program, cpustate->amout, appw);
+		cpustate->program->write_dword_unaligned(cpustate->amout, appw);
 
 	return cpustate->amlength1 + 1;
 }
@@ -166,7 +166,7 @@
 
 	// Save NextPC into the stack
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + cpustate->amlength1 + 1);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + cpustate->amlength1 + 1);
 
 	// Jump there
 	cpustate->PC = cpustate->amout;
@@ -184,7 +184,7 @@
 
 	// step 1: save frame pointer on the stack
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->FP);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->FP);
 
 	// step 2: cpustate->FP = new cpustate->SP
 	cpustate->FP = cpustate->SP;
@@ -204,11 +204,11 @@
 	ReadAM(cpustate);
 
 	// Read return address from stack
-	cpustate->PC = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->PC = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP +=4;
 
 	// Restore cpustate->AP from stack
-	cpustate->AP = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->AP = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP +=4;
 
 	// Skip stack frame
@@ -284,13 +284,13 @@
 
 	// Issue the software trap with interrupts
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x3000 + 0x100 * (cpustate->amout & 0xF), 4));
+	cpustate->program->write_dword_unaligned(cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x3000 + 0x100 * (cpustate->amout & 0xF), 4));
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, oldPSW);
+	cpustate->program->write_dword_unaligned(cpustate->SP, oldPSW);
 
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + cpustate->amlength1 + 1);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + cpustate->amlength1 + 1);
 
 	cpustate->PC = GETINTVECT(cpustate, 48 + (cpustate->amout & 0xF));
 
@@ -307,10 +307,10 @@
 	ReadAM(cpustate);
 
 	// Restore cpustate->PC and cpustate->PSW from stack
-	cpustate->PC = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->PC = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP += 4;
 
-	newPSW = MemRead32(cpustate->program, cpustate->SP);
+	newPSW = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP += 4;
 
 	// Destroy stack frame
@@ -332,10 +332,10 @@
 	ReadAM(cpustate);
 
 	// Restore cpustate->PC and cpustate->PSW from stack
-	cpustate->PC = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->PC = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP += 4;
 
-	newPSW = MemRead32(cpustate->program, cpustate->SP);
+	newPSW = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP += 4;
 
 	// Destroy stack frame
@@ -361,29 +361,29 @@
 	v60WritePSW(cpustate, v60ReadPSW(cpustate) | 0x10000000);
 	v60SaveStack(cpustate);
 
-	MemWrite32(cpustate->program, adr, cpustate->TKCW);
+	cpustate->program->write_dword_unaligned(adr, cpustate->TKCW);
 	adr += 4;
 	if(cpustate->SYCW & 0x100) {
-		MemWrite32(cpustate->program, adr, cpustate->L0SP);
+		cpustate->program->write_dword_unaligned(adr, cpustate->L0SP);
 		adr += 4;
 	}
 	if(cpustate->SYCW & 0x200) {
-		MemWrite32(cpustate->program, adr, cpustate->L1SP);
+		cpustate->program->write_dword_unaligned(adr, cpustate->L1SP);
 		adr += 4;
 	}
 	if(cpustate->SYCW & 0x400) {
-		MemWrite32(cpustate->program, adr, cpustate->L2SP);
+		cpustate->program->write_dword_unaligned(adr, cpustate->L2SP);
 		adr += 4;
 	}
 	if(cpustate->SYCW & 0x800) {
-		MemWrite32(cpustate->program, adr, cpustate->L3SP);
+		cpustate->program->write_dword_unaligned(adr, cpustate->L3SP);
 		adr += 4;
 	}
 
 	// 31 registers supported, _not_ 32
 	for(i = 0; i < 31; i++)
 		if(cpustate->amout & (1 << i)) {
-			MemWrite32(cpustate->program, adr, cpustate->reg[i]);
+			cpustate->program->write_dword_unaligned(adr, cpustate->reg[i]);
 			adr += 4;
 		}
 
@@ -417,7 +417,7 @@
 	if (cpustate->amflag)
 		appb = (UINT8)cpustate->reg[cpustate->amout & 0x1F];
 	else
-		appb = MemRead8(cpustate->program, cpustate->amout);
+		appb = cpustate->program->read_byte(cpustate->amout);
 
 	// Set the flags for SUB appb, FF
 	SUBB(appb, 0xff);
@@ -426,7 +426,7 @@
 	if (cpustate->amflag)
 		SETREG8(cpustate->reg[cpustate->amout & 0x1F], 0xFF);
 	else
-		MemWrite8(cpustate->program, cpustate->amout, 0xFF);
+		cpustate->program->write_byte(cpustate->amout, 0xFF);
 
 	return cpustate->amlength1 + 1;
 }
@@ -457,13 +457,13 @@
 	for (i = 0;i < 31;i++)
 		if (cpustate->amout & (1 << i))
 		{
-			cpustate->reg[i] = MemRead32(cpustate->program, cpustate->SP);
+			cpustate->reg[i] = cpustate->program->read_dword_unaligned(cpustate->SP);
 			cpustate->SP += 4;
 		}
 
 	if (cpustate->amout & (1 << 31))
 	{
-		v60WritePSW(cpustate, (v60ReadPSW(cpustate) & 0xffff0000) | MemRead16(cpustate->program, cpustate->SP));
+		v60WritePSW(cpustate, (v60ReadPSW(cpustate) & 0xffff0000) | cpustate->program->read_word_unaligned(cpustate->SP));
 		cpustate->SP += 4;
 	}
 
@@ -483,14 +483,14 @@
 	if (cpustate->amout & (1 << 31))
 	{
 		cpustate->SP -= 4;
-		MemWrite32(cpustate->program, cpustate->SP, v60ReadPSW(cpustate));
+		cpustate->program->write_dword_unaligned(cpustate->SP, v60ReadPSW(cpustate));
 	}
 
 	for (i = 0;i < 31;i++)
 		if (cpustate->amout & (1 << (30 - i)))
 		{
 			cpustate->SP -= 4;
-			MemWrite32(cpustate->program, cpustate->SP, cpustate->reg[(30 - i)]);
+			cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->reg[(30 - i)]);
 		}
 
 
@@ -553,7 +553,7 @@
 	cpustate->amlength1 = ReadAM(cpustate);
 
 	cpustate->SP-=4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->amout);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->amout);
 
 	return cpustate->amlength1 + 1;
 }
@@ -562,7 +562,7 @@
 {
 	cpustate->modadd = cpustate->PC + 1;
 	cpustate->moddim = 2;
-	cpustate->modwritevalw = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->modwritevalw = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP +=4;
 	cpustate->amlength1 = WriteAM(cpustate);
 
diff -Nru src-old/emu/cpu/v60/op4.c src/emu/cpu/v60/op4.c
--- src-old/emu/cpu/v60/op4.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/op4.c	2010-08-21 11:40:01.000000000 -0700
@@ -9,7 +9,7 @@
 
 	if (!((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -22,7 +22,7 @@
 
 	if (!((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -36,7 +36,7 @@
 
 	if (!(cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -49,7 +49,7 @@
 
 	if (!(cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -62,7 +62,7 @@
 
 	if ((cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -75,7 +75,7 @@
 
 	if ((cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -89,7 +89,7 @@
 
 	if (((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -102,7 +102,7 @@
 
 	if (((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -113,7 +113,7 @@
 {
 	if (!(cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -124,7 +124,7 @@
 {
 	if (!(cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -135,7 +135,7 @@
 {
 	if ((cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -146,7 +146,7 @@
 {
 	if ((cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -157,7 +157,7 @@
 {
 	if (!(cpustate->_CY))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -168,7 +168,7 @@
 {
 	if (!(cpustate->_CY))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -179,7 +179,7 @@
 {
 	if ((cpustate->_CY))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -190,7 +190,7 @@
 {
 	if ((cpustate->_CY))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -201,7 +201,7 @@
 {
 	if (!(cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -212,7 +212,7 @@
 {
 	if (!(cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -223,7 +223,7 @@
 {
 	if ((cpustate->_Z))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -234,7 +234,7 @@
 {
 	if ((cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -245,7 +245,7 @@
 {
 	if (!(cpustate->_OV))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -256,7 +256,7 @@
 {
 	if (!(cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -267,7 +267,7 @@
 {
 	if ((cpustate->_OV))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -278,7 +278,7 @@
 {
 	if ((cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -289,7 +289,7 @@
 {
 	if (!(cpustate->_S))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -300,7 +300,7 @@
 {
 	if (!(cpustate->_S))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -311,7 +311,7 @@
 {
 	if ((cpustate->_S))
 	{
-		cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -322,7 +322,7 @@
 {
 	if ((cpustate->_S))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 		return 0;
 	}
 
@@ -331,13 +331,13 @@
 
 static UINT32 opBR8(v60_state *cpustate) /* TRUSTED */
 {
-	cpustate->PC += (INT8)OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->PC += (INT8)OpRead8(cpustate, cpustate->PC + 1);
 	return 0;
 }
 
 static UINT32 opBR16(v60_state *cpustate) /* TRUSTED */
 {
-	cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+	cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 	return 0;
 }
 
@@ -345,10 +345,10 @@
 {
 	// Save Next cpustate->PC onto the stack
 	cpustate->SP -= 4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + 3);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + 3);
 
 	// Jump to subroutine
-	cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 1);
+	cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 1);
 	return 0;
 }
 
diff -Nru src-old/emu/cpu/v60/op5.c src/emu/cpu/v60/op5.c
--- src-old/emu/cpu/v60/op5.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/op5.c	2010-08-21 11:40:01.000000000 -0700
@@ -9,11 +9,11 @@
     UINT32 oldPSW = v60_update_psw_for_exception(cpustate, 0, 0);
 
     cpustate->SP -=4;
-    MemWrite32(cpustate->program, cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x0d00, 4));
+    cpustate->program->write_dword_unaligned(cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x0d00, 4));
     cpustate->SP -=4;
-    MemWrite32(cpustate->program, cpustate->SP, oldPSW);
+    cpustate->program->write_dword_unaligned(cpustate->SP, oldPSW);
     cpustate->SP -=4;
-    MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + 1);
+    cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + 1);
     cpustate->PC = GETINTVECT(cpustate, 13);
 */
 	logerror("Skipping BRK opcode! cpustate->PC=%x", cpustate->PC);
@@ -26,13 +26,13 @@
 	UINT32 oldPSW = v60_update_psw_for_exception(cpustate, 0, 0);
 
 	cpustate->SP -=4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC);
 	cpustate->SP -=4;
-	MemWrite32(cpustate->program, cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x1501, 4));
+	cpustate->program->write_dword_unaligned(cpustate->SP, EXCEPTION_CODE_AND_SIZE(0x1501, 4));
 	cpustate->SP -=4;
-	MemWrite32(cpustate->program, cpustate->SP, oldPSW);
+	cpustate->program->write_dword_unaligned(cpustate->SP, oldPSW);
 	cpustate->SP -=4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC + 1);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC + 1);
 	cpustate->PC = GETINTVECT(cpustate, 21);
 
 	return 0;
@@ -48,7 +48,7 @@
 static UINT32 opDISPOSE(v60_state *cpustate)
 {
 	cpustate->SP = cpustate->FP;
-	cpustate->FP = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->FP = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP +=4;
 
 	return 1;
@@ -68,7 +68,7 @@
 
 static UINT32 opRSR(v60_state *cpustate)
 {
-	cpustate->PC = MemRead32(cpustate->program, cpustate->SP);
+	cpustate->PC = cpustate->program->read_dword_unaligned(cpustate->SP);
 	cpustate->SP +=4;
 
 	return 0;
diff -Nru src-old/emu/cpu/v60/op6.c src/emu/cpu/v60/op6.c
--- src-old/emu/cpu/v60/op6.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/op6.c	2010-08-21 11:40:01.000000000 -0700
@@ -7,7 +7,7 @@
 {
 	if (cpustate->reg[reg] == 0)
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -21,7 +21,7 @@
 	NORMALIZEFLAGS(cpustate);
 	if ((cpustate->reg[reg] != 0) && !((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -35,7 +35,7 @@
 	NORMALIZEFLAGS(cpustate);
 	if ((cpustate->reg[reg] != 0) && ((cpustate->_S ^ cpustate->_OV) | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -50,7 +50,7 @@
 	NORMALIZEFLAGS(cpustate);
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -64,7 +64,7 @@
 	NORMALIZEFLAGS(cpustate);
 	if ((cpustate->reg[reg] != 0) && (cpustate->_S ^ cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -77,7 +77,7 @@
 
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -90,7 +90,7 @@
 
 	if ((cpustate->reg[reg] != 0) && (cpustate->_CY | cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -104,7 +104,7 @@
 
 	if ((cpustate->reg[reg] != 0) && (cpustate->_CY))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -117,7 +117,7 @@
 
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_CY))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -130,7 +130,7 @@
 
 	if ((cpustate->reg[reg] != 0) && (cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -143,7 +143,7 @@
 
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_Z))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -156,7 +156,7 @@
 
 	if ((cpustate->reg[reg] != 0) && (cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -169,7 +169,7 @@
 
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_OV))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -182,7 +182,7 @@
 
 	if ((cpustate->reg[reg] != 0) && (cpustate->_S))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -195,7 +195,7 @@
 
 	if ((cpustate->reg[reg] != 0) && !(cpustate->_S))
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -208,7 +208,7 @@
 
 	if (cpustate->reg[reg] != 0)
 	{
-		cpustate->PC += (INT16)OpRead16(cpustate->program, cpustate->PC + 2);
+		cpustate->PC += (INT16)OpRead16(cpustate, cpustate->PC + 2);
 		return 0;
 	}
 
@@ -242,13 +242,13 @@
 
 static UINT32 opC6(v60_state *cpustate) /* TRUSTED */
 {
-	UINT8 appb = OpRead8(cpustate->program, cpustate->PC + 1);
+	UINT8 appb = OpRead8(cpustate, cpustate->PC + 1);
 	return OpC6Table[appb >> 5](cpustate, appb & 0x1f);
 }
 
 static UINT32 opC7(v60_state *cpustate) /* TRUSTED */
 {
-	UINT8 appb = OpRead8(cpustate->program, cpustate->PC + 1);
+	UINT8 appb = OpRead8(cpustate, cpustate->PC + 1);
 	return OpC7Table[appb >> 5](cpustate, appb & 0x1f);
 }
 
diff -Nru src-old/emu/cpu/v60/op7a.c src/emu/cpu/v60/op7a.c
--- src-old/emu/cpu/v60/op7a.c	2009-12-28 02:04:00.000000000 -0800
+++ src/emu/cpu/v60/op7a.c	2010-08-21 11:40:01.000000000 -0700
@@ -39,7 +39,7 @@
 	cpustate->op1 = cpustate->amout;
 
 	// Decode length
-	appb = OpRead8(cpustate->program, cpustate->PC + 2 + cpustate->amlength1);
+	appb = OpRead8(cpustate, cpustate->PC + 2 + cpustate->amlength1);
 	if (appb & 0x80)
 		cpustate->lenop1 = cpustate->reg[appb & 0x1F];
 	else
@@ -54,7 +54,7 @@
 	cpustate->op2 = cpustate->amout;
 
 	// Decode length
-	appb = OpRead8(cpustate->program, cpustate->PC + 3 + cpustate->amlength1 + cpustate->amlength2);
+	appb = OpRead8(cpustate, cpustate->PC + 3 + cpustate->amlength1 + cpustate->amlength2);
 	if (appb & 0x80)
 		cpustate->lenop2 = cpustate->reg[appb & 0x1F];
 	else
@@ -73,7 +73,7 @@
 	cpustate->op1 = cpustate->amout;
 
 	// Decode ext
-	appb = OpRead8(cpustate->program, cpustate->PC + 2 + cpustate->amlength1);
+	appb = OpRead8(cpustate, cpustate->PC + 2 + cpustate->amlength1);
 	if (appb & 0x80)
 		cpustate->lenop1 = cpustate->reg[appb & 0x1F];
 	else
@@ -126,7 +126,7 @@
 	cpustate->op2 = cpustate->amout;
 
 	// Decode ext
-	appb = OpRead8(cpustate->program, cpustate->PC + 2 + cpustate->amlength1 + cpustate->amlength2);
+	appb = OpRead8(cpustate, cpustate->PC + 2 + cpustate->amlength1 + cpustate->amlength2);
 	if (appb & 0x80)
 		cpustate->lenop1 = cpustate->reg[appb & 0x1F];
 	else
@@ -137,26 +137,26 @@
 	if ((cs)->flag1) \
 		appb = (UINT8)((cs)->reg[(cs)->op1]&0xFF); \
 	else \
-		appb = MemRead8((cs)->program, (cs)->op1);
+		appb = (cs)->program->read_byte((cs)->op1);
 
 #define F7CLOADOP2BYTE(cs,appb) \
 	if ((cs)->flag2) \
 		appb = (UINT8)((cs)->reg[(cs)->op2]&0xFF); \
 	else \
-		appb = MemRead8((cs)->program, (cs)->op2);
+		appb = (cs)->program->read_byte((cs)->op2);
 
 
 #define F7CSTOREOP2BYTE(cs) \
 	if ((cs)->flag2) \
 		SETREG8((cs)->reg[(cs)->op2], appb); \
 	else \
-		MemWrite8((cs)->program, (cs)->op2, appb);
+		(cs)->program->write_byte((cs)->op2, appb);
 
 #define F7CSTOREOP2HALF(cs) \
 	if ((cs)->flag2) \
 		SETREG16((cs)->reg[(cs)->op2], apph); \
 	else \
-		MemWrite16((cs)->program, (cs)->op2, apph);
+		(cs)->program->write_word_unaligned((cs)->op2, apph);
 
 static UINT32 opCMPSTRB(v60_state *cpustate, UINT8 bFill, UINT8 bStop)
 {
@@ -171,12 +171,12 @@
 		if (cpustate->lenop1 < cpustate->lenop2)
 		{
 			for (i = cpustate->lenop1; i < cpustate->lenop2; i++)
-				MemWrite8(cpustate->program, cpustate->op1 + i,(UINT8)cpustate->R26);
+				cpustate->program->write_byte(cpustate->op1 + i,(UINT8)cpustate->R26);
 		}
 		else if (cpustate->lenop2 < cpustate->lenop1)
 		{
 			for (i = cpustate->lenop2; i < cpustate->lenop1; i++)
-				MemWrite8(cpustate->program, cpustate->op2 + i,(UINT8)cpustate->R26);
+				cpustate->program->write_byte(cpustate->op2 + i,(UINT8)cpustate->R26);
 		}
 	}
 
@@ -188,8 +188,8 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		c1 = MemRead8(cpustate->program, cpustate->op1 + i);
-		c2 = MemRead8(cpustate->program, cpustate->op2 + i);
+		c1 = cpustate->program->read_byte(cpustate->op1 + i);
+		c2 = cpustate->program->read_byte(cpustate->op2 + i);
 
 		if (c1 > c2)
 		{
@@ -237,12 +237,12 @@
 		if (cpustate->lenop1 < cpustate->lenop2)
 		{
 			for (i = cpustate->lenop1; i < cpustate->lenop2; i++)
-				MemWrite16(cpustate->program, cpustate->op1 + i * 2,(UINT16)cpustate->R26);
+				cpustate->program->write_word_unaligned(cpustate->op1 + i * 2,(UINT16)cpustate->R26);
 		}
 		else if (cpustate->lenop2 < cpustate->lenop1)
 		{
 			for (i = cpustate->lenop2; i < cpustate->lenop1; i++)
-				MemWrite16(cpustate->program, cpustate->op2 + i * 2,(UINT16)cpustate->R26);
+				cpustate->program->write_word_unaligned(cpustate->op2 + i * 2,(UINT16)cpustate->R26);
 		}
 	}
 
@@ -254,8 +254,8 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		c1 = MemRead16(cpustate->program, cpustate->op1 + i * 2);
-		c2 = MemRead16(cpustate->program, cpustate->op2 + i * 2);
+		c1 = cpustate->program->read_word_unaligned(cpustate->op1 + i * 2);
+		c2 = cpustate->program->read_word_unaligned(cpustate->op2 + i * 2);
 
 		if (c1 > c2)
 		{
@@ -308,7 +308,7 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		MemWrite8(cpustate->program, cpustate->op2 + i,(c1 = MemRead8(cpustate->program, cpustate->op1 + i)));
+		cpustate->program->write_byte(cpustate->op2 + i,(c1 = cpustate->program->read_byte(cpustate->op1 + i)));
 
 		if (bStop && c1 == (UINT8)cpustate->R26)
 			break;
@@ -320,7 +320,7 @@
 	if (bFill && cpustate->lenop1 < cpustate->lenop2)
 	{
 		for (;i < cpustate->lenop2; i++)
-			MemWrite8(cpustate->program, cpustate->op2 + i,(UINT8)cpustate->R26);
+			cpustate->program->write_byte(cpustate->op2 + i,(UINT8)cpustate->R26);
 
 		cpustate->R27 = cpustate->op2 + i;
 	}
@@ -340,7 +340,7 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		MemWrite8(cpustate->program, cpustate->op2 + (dest - i - 1),(c1 = MemRead8(cpustate->program, cpustate->op1 + (dest - i - 1))));
+		cpustate->program->write_byte(cpustate->op2 + (dest - i - 1),(c1 = cpustate->program->read_byte(cpustate->op1 + (dest - i - 1))));
 
 		if (bStop && c1 == (UINT8)cpustate->R26)
 			break;
@@ -352,7 +352,7 @@
 	if (bFill && cpustate->lenop1 < cpustate->lenop2)
 	{
 		for (;i < cpustate->lenop2; i++)
-			MemWrite8(cpustate->program, cpustate->op2 + dest + (cpustate->lenop2 - i - 1),(UINT8)cpustate->R26);
+			cpustate->program->write_byte(cpustate->op2 + dest + (cpustate->lenop2 - i - 1),(UINT8)cpustate->R26);
 
 		cpustate->R27 = cpustate->op2 + (cpustate->lenop2 - i - 1);
 	}
@@ -376,7 +376,7 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		MemWrite16(cpustate->program, cpustate->op2 + i * 2,(c1 = MemRead16(cpustate->program, cpustate->op1 + i * 2)));
+		cpustate->program->write_word_unaligned(cpustate->op2 + i * 2,(c1 = cpustate->program->read_word_unaligned(cpustate->op1 + i * 2)));
 
 		if (bStop && c1 == (UINT16)cpustate->R26)
 			break;
@@ -388,7 +388,7 @@
 	if (bFill && cpustate->lenop1 < cpustate->lenop2)
 	{
 		for (;i < cpustate->lenop2; i++)
-			MemWrite16(cpustate->program, cpustate->op2 + i * 2,(UINT16)cpustate->R26);
+			cpustate->program->write_word_unaligned(cpustate->op2 + i * 2,(UINT16)cpustate->R26);
 
 		cpustate->R27 = cpustate->op2 + i * 2;
 	}
@@ -413,7 +413,7 @@
 
 	for (i = 0; i < dest; i++)
 	{
-		MemWrite16(cpustate->program, cpustate->op2 + (dest - i - 1) * 2,(c1 = MemRead16(cpustate->program, cpustate->op1 + (dest - i - 1) * 2)));
+		cpustate->program->write_word_unaligned(cpustate->op2 + (dest - i - 1) * 2,(c1 = cpustate->program->read_word_unaligned(cpustate->op1 + (dest - i - 1) * 2)));
 
 		if (bStop && c1 == (UINT16)cpustate->R26)
 			break;
@@ -425,7 +425,7 @@
 	if (bFill && cpustate->lenop1 < cpustate->lenop2)
 	{
 		for (;i < cpustate->lenop2; i++)
-			MemWrite16(cpustate->program, cpustate->op2 + (cpustate->lenop2 - i - 1) * 2,(UINT16)cpustate->R26);
+			cpustate->program->write_word_unaligned(cpustate->op2 + (cpustate->lenop2 - i - 1) * 2,(UINT16)cpustate->R26);
 
 		cpustate->R27 = cpustate->op2 + (cpustate->lenop2 - i - 1) * 2;
 	}
@@ -442,7 +442,7 @@
 
 	for (i = 0; i < cpustate->lenop1; i++)
 	{
-		appb = (MemRead8(cpustate->program, cpustate->op1 + i) == (UINT8)cpustate->op2);
+		appb = (cpustate->program->read_byte(cpustate->op1 + i) == (UINT8)cpustate->op2);
 		if ((bSearch && appb) || (!bSearch && !appb))
 			break;
 	}
@@ -468,7 +468,7 @@
 
 	for (i = 0; i < cpustate->lenop1; i++)
 	{
-		appb = (MemRead16(cpustate->program, cpustate->op1 + i * 2) == (UINT16)cpustate->op2);
+		appb = (cpustate->program->read_word_unaligned(cpustate->op1 + i * 2) == (UINT16)cpustate->op2);
 		if ((bSearch && appb) || (!bSearch && !appb))
 			break;
 	}
@@ -493,7 +493,7 @@
 
 	for (i = cpustate->lenop1; i >= 0; i--)
 	{
-		appb = (MemRead8(cpustate->program, cpustate->op1 + i) == (UINT8)cpustate->op2);
+		appb = (cpustate->program->read_byte(cpustate->op1 + i) == (UINT8)cpustate->op2);
 		if ((bSearch && appb) || (!bSearch && !appb))
 			break;
 	}
@@ -519,7 +519,7 @@
 
 	for (i = cpustate->lenop1 - 1; i >= 0; i--)
 	{
-		appb = (MemRead16(cpustate->program, cpustate->op1 + i * 2) == (UINT16)cpustate->op2);
+		appb = (cpustate->program->read_word_unaligned(cpustate->op1 + i * 2) == (UINT16)cpustate->op2);
 		if ((bSearch && appb) || (!bSearch && !appb))
 			break;
 	}
@@ -618,7 +618,7 @@
 
 	// Read first UINT8
 	cpustate->op1 += cpustate->bamoffset / 8;
-	data = MemRead8(cpustate->program, cpustate->op1);
+	data = cpustate->program->read_byte(cpustate->op1);
 	offset = cpustate->bamoffset & 7;
 
 	// Scan bitstring
@@ -639,7 +639,7 @@
 			// Next UINT8 please
 			offset = 0;
 			cpustate->op1++;
-			data = MemRead8(cpustate->program, cpustate->op1);
+			data = cpustate->program->read_byte(cpustate->op1);
 		}
 	}
 
@@ -664,13 +664,13 @@
 	F7CCREATEBITMASK(cpustate->lenop1);
 
 	cpustate->op2 += cpustate->bamoffset / 8;
-	appw = MemRead32(cpustate->program, cpustate->op2);
+	appw = cpustate->program->read_dword_unaligned(cpustate->op2);
 	cpustate->bamoffset &= 7;
 
 	appw &= ~(cpustate->lenop1 << cpustate->bamoffset);
 	appw |=  (cpustate->lenop1 & cpustate->op1) << cpustate->bamoffset;
 
-	MemWrite32(cpustate->program, cpustate->op2, appw);
+	cpustate->program->write_dword_unaligned(cpustate->op2, appw);
 
 	F7CEND(cpustate);
 }
@@ -685,13 +685,13 @@
 	F7CCREATEBITMASK(cpustate->lenop1);
 
 	cpustate->op2 += cpustate->bamoffset / 8;
-	appw = MemRead32(cpustate->program, cpustate->op2);
+	appw = cpustate->program->read_dword_unaligned(cpustate->op2);
 	cpustate->bamoffset &= 7;
 
 	appw &= ~(cpustate->lenop1 << cpustate->bamoffset);
 	appw |=  (cpustate->lenop1 & cpustate->op1) << cpustate->bamoffset;
 
-	MemWrite32(cpustate->program, cpustate->op2, appw);
+	cpustate->program->write_dword_unaligned(cpustate->op2, appw);
 
 	F7CEND(cpustate);
 }
@@ -715,8 +715,8 @@
 	cpustate->bamoffset1 &= 7;
 	cpustate->bamoffset2 &= 7;
 
-	srcdata = MemRead8(cpustate->program, cpustate->op1);
-	dstdata = MemRead8(cpustate->program, cpustate->op2);
+	srcdata = cpustate->program->read_byte(cpustate->op1);
+	dstdata = cpustate->program->read_byte(cpustate->op2);
 
 	for (i = 0; i < cpustate->lenop1; i++)
 	{
@@ -731,14 +731,14 @@
 		{
 			cpustate->bamoffset1 = 8;
 			cpustate->op1--;
-			srcdata = MemRead8(cpustate->program, cpustate->op1);
+			srcdata = cpustate->program->read_byte(cpustate->op1);
 		}
 		if (cpustate->bamoffset2 == 0)
 		{
-			MemWrite8(cpustate->program, cpustate->op2, dstdata);
+			cpustate->program->write_byte(cpustate->op2, dstdata);
 			cpustate->bamoffset2 = 8;
 			cpustate->op2--;
-			dstdata = MemRead8(cpustate->program, cpustate->op2);
+			dstdata = cpustate->program->read_byte(cpustate->op2);
 		}
 
 		cpustate->bamoffset1--;
@@ -747,7 +747,7 @@
 
 	// Flush of the final data
 	if (cpustate->bamoffset2 != 7)
-		MemWrite8(cpustate->program, cpustate->op2, dstdata);
+		cpustate->program->write_byte(cpustate->op2, dstdata);
 
 	F7BEND(cpustate);
 }
@@ -765,8 +765,8 @@
 	cpustate->bamoffset1 &= 7;
 	cpustate->bamoffset2 &= 7;
 
-	srcdata = MemRead8(cpustate->program, cpustate->op1);
-	dstdata = MemRead8(cpustate->program, cpustate->op2);
+	srcdata = cpustate->program->read_byte(cpustate->op1);
+	dstdata = cpustate->program->read_byte(cpustate->op2);
 
 	for (i = 0; i < cpustate->lenop1; i++)
 	{
@@ -783,20 +783,20 @@
 		{
 			cpustate->bamoffset1 = 0;
 			cpustate->op1++;
-			srcdata = MemRead8(cpustate->program, cpustate->op1);
+			srcdata = cpustate->program->read_byte(cpustate->op1);
 		}
 		if (cpustate->bamoffset2 == 8)
 		{
-			MemWrite8(cpustate->program, cpustate->op2, dstdata);
+			cpustate->program->write_byte(cpustate->op2, dstdata);
 			cpustate->bamoffset2 = 0;
 			cpustate->op2++;
-			dstdata = MemRead8(cpustate->program, cpustate->op2);
+			dstdata = cpustate->program->read_byte(cpustate->op2);
 		}
 	}
 
 	// Flush of the final data
 	if (cpustate->bamoffset2 != 0)
-		MemWrite8(cpustate->program, cpustate->op2, dstdata);
+		cpustate->program->write_byte(cpustate->op2, dstdata);
 
 	F7BEND(cpustate);
 }
@@ -1177,35 +1177,35 @@
 
 static UINT32 op58(v60_state *cpustate)
 {
-	cpustate->subop = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->subop = OpRead8(cpustate, cpustate->PC + 1);
 
 	return Op58Table[cpustate->subop & 0x1F](cpustate);
 }
 
 static UINT32 op5A(v60_state *cpustate)
 {
-	cpustate->subop = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->subop = OpRead8(cpustate, cpustate->PC + 1);
 
 	return Op5ATable[cpustate->subop & 0x1F](cpustate);
 }
 
 static UINT32 op5B(v60_state *cpustate)
 {
-	cpustate->subop = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->subop = OpRead8(cpustate, cpustate->PC + 1);
 
 	return Op5BTable[cpustate->subop & 0x1F](cpustate);
 }
 
 static UINT32 op5D(v60_state *cpustate)
 {
-	cpustate->subop = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->subop = OpRead8(cpustate, cpustate->PC + 1);
 
 	return Op5DTable[cpustate->subop & 0x1F](cpustate);
 }
 
 static UINT32 op59(v60_state *cpustate)
 {
-	cpustate->subop = OpRead8(cpustate->program, cpustate->PC + 1);
+	cpustate->subop = OpRead8(cpustate, cpustate->PC + 1);
 
 	return Op59Table[cpustate->subop & 0x1F](cpustate);
 }
diff -Nru src-old/emu/cpu/v60/v60.c src/emu/cpu/v60/v60.c
--- src-old/emu/cpu/v60/v60.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/v60/v60.c	2010-08-30 08:20:58.000000000 -0700
@@ -8,7 +8,19 @@
 #include "v60.h"
 
 // memory accessors
-#include "v60mem.c"
+#if defined(LSB_FIRST) && !defined(ALIGN_INTS)
+#define OpRead8(s, a)	((s)->direct->read_decrypted_byte(a))
+#define OpRead16(s, a)	((s)->direct->read_decrypted_word(a))
+#define OpRead32(s, a)	((s)->direct->read_decrypted_dword(a))
+#else
+#define OpRead8(s, a)   ((s)->direct->read_decrypted_byte((a) ^ (s)->fetch_xor))
+#define OpRead16(s, a)	(((s)->direct->read_decrypted_byte(((a)+0) ^ (s)->fetch_xor) << 0) | \
+						 ((s)->direct->read_decrypted_byte(((a)+1) ^ (s)->fetch_xor) << 8))
+#define OpRead32(s, a)	(((s)->direct->read_decrypted_byte(((a)+0) ^ (s)->fetch_xor) << 0) | \
+						 ((s)->direct->read_decrypted_byte(((a)+1) ^ (s)->fetch_xor) << 8) | \
+						 ((s)->direct->read_decrypted_byte(((a)+2) ^ (s)->fetch_xor) << 16) | \
+						 ((s)->direct->read_decrypted_byte(((a)+3) ^ (s)->fetch_xor) << 24))
+#endif
 
 
 // macros stolen from MAME for flags calc
@@ -72,15 +84,17 @@
 typedef struct _v60_state v60_state;
 struct _v60_state
 {
-	struct cpu_info 	info;
+	offs_t				fetch_xor;
+	offs_t				start_pc;
 	UINT32				reg[68];
 	v60_flags			flags;
 	UINT8				irq_line;
 	UINT8				nmi_line;
 	device_irq_callback	irq_cb;
 	legacy_cpu_device *		device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *	direct;
+	address_space *io;
 	UINT32				PPC;
 	int					icount;
 	int					stall_io;
@@ -285,7 +299,7 @@
 }
 
 
-#define GETINTVECT(cs, nint)					MemRead32((cs)->program,((cs)->SBR & ~0xfff) + (nint) * 4)
+#define GETINTVECT(cs, nint)					(cs)->program->read_dword(((cs)->SBR & ~0xfff) + (nint) * 4)
 #define EXCEPTION_CODE_AND_SIZE(code, size)	(((code) << 16) | (size))
 
 
@@ -303,7 +317,7 @@
 
 static UINT32 opUNHANDLED(v60_state *cpustate)
 {
-	fatalerror("Unhandled OpCode found : %02x at %08x", OpRead16(cpustate->program, cpustate->PC), cpustate->PC);
+	fatalerror("Unhandled OpCode found : %02x at %08x", OpRead16(cpustate, cpustate->PC), cpustate->PC);
 	return 0; /* never reached, fatalerror won't return */
 }
 
@@ -338,9 +352,11 @@
 	// Set cpustate->PIR (Processor ID) for NEC cpustate-> LSB is reserved to NEC,
 	// so I don't know what it contains.
 	cpustate->PIR = 0x00006000;
-	cpustate->info = v60_i;
+	cpustate->fetch_xor = BYTE_XOR_LE(0);
+	cpustate->start_pc = 0xfffff0;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 }
 
@@ -352,9 +368,11 @@
 	// Set cpustate->PIR (Processor ID) for NEC v70. LSB is reserved to NEC,
 	// so I don't know what it contains.
 	cpustate->PIR = 0x00007000;
-	cpustate->info = v70_i;
+	cpustate->fetch_xor = BYTE4_XOR_LE(0);
+	cpustate->start_pc = 0xfffffff0;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 }
 
@@ -363,7 +381,7 @@
 	v60_state *cpustate = get_safe_token(device);
 
 	cpustate->PSW	= 0x10000000;
-	cpustate->PC	= cpustate->info.start_pc;
+	cpustate->PC	= cpustate->start_pc;
 	cpustate->SBR	= 0x00000000;
 	cpustate->SYCW	= 0x00000070;
 	cpustate->TKCW	= 0x0000e000;
@@ -391,9 +409,9 @@
 
 	// Push cpustate->PC and cpustate->PSW onto the stack
 	cpustate->SP-=4;
-	MemWrite32(cpustate->program, cpustate->SP, oldPSW);
+	cpustate->program->write_dword_unaligned(cpustate->SP, oldPSW);
 	cpustate->SP-=4;
-	MemWrite32(cpustate->program, cpustate->SP, cpustate->PC);
+	cpustate->program->write_dword_unaligned(cpustate->SP, cpustate->PC);
 
 	// Jump to vector for user interrupt
 	cpustate->PC = GETINTVECT(cpustate, vector);
@@ -449,7 +467,7 @@
 		cpustate->PPC = cpustate->PC;
 		debugger_instruction_hook(device, cpustate->PC);
 		cpustate->icount -= 8;	/* fix me -- this is just an average */
-		inc = OpCodeTable[OpRead8(cpustate->program, cpustate->PC)](cpustate);
+		inc = OpCodeTable[OpRead8(cpustate, cpustate->PC)](cpustate);
 		cpustate->PC += inc;
 		if (cpustate->irq_line != CLEAR_LINE)
 			v60_try_irq(cpustate);
diff -Nru src-old/emu/cpu/v60/v60mem.c src/emu/cpu/v60/v60mem.c
--- src-old/emu/cpu/v60/v60mem.c	2008-12-07 23:35:28.000000000 -0800
+++ src/emu/cpu/v60/v60mem.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,228 +0,0 @@
-/****************************************************************/
-/* Structure defining all callbacks for different architectures */
-/****************************************************************/
-
-struct cpu_info {
-	UINT8  (*mr8) (const address_space *space, offs_t address);
-	void   (*mw8) (const address_space *space, offs_t address, UINT8  data);
-	UINT16 (*mr16)(const address_space *space, offs_t address);
-	void   (*mw16)(const address_space *space, offs_t address, UINT16 data);
-	UINT32 (*mr32)(const address_space *space, offs_t address);
-	void   (*mw32)(const address_space *space, offs_t address, UINT32 data);
-	UINT8  (*or8) (const address_space *space, offs_t address);
-	UINT16 (*or16)(const address_space *space, offs_t address);
-	UINT32 (*or32)(const address_space *space, offs_t address);
-	UINT32 start_pc;
-};
-
-
-
-/*****************************************************************/
-/* Memory accesses for 16-bit data bus, 24-bit address bus (V60) */
-/*****************************************************************/
-
-#define MemRead8_16		memory_read_byte_16le
-#define MemWrite8_16	memory_write_byte_16le
-
-static UINT16 MemRead16_16(const address_space *space, offs_t address)
-{
-	if (!(address & 1))
-		return memory_read_word_16le(space, address);
-	else
-	{
-		UINT16 result = memory_read_byte_16le(space, address);
-		return result | memory_read_byte_16le(space, address + 1) << 8;
-	}
-}
-
-static void MemWrite16_16(const address_space *space, offs_t address, UINT16 data)
-{
-	if (!(address & 1))
-		memory_write_word_16le(space, address, data);
-	else
-	{
-		memory_write_byte_16le(space, address, data);
-		memory_write_byte_16le(space, address + 1, data >> 8);
-	}
-}
-
-static UINT32 MemRead32_16(const address_space *space, offs_t address)
-{
-	if (!(address & 1))
-	{
-		UINT32 result = memory_read_word_16le(space, address);
-		return result | (memory_read_word_16le(space, address + 2) << 16);
-	}
-	else
-	{
-		UINT32 result = memory_read_byte_16le(space, address);
-		result |= memory_read_word_16le(space, address + 1) << 8;
-		return result | memory_read_byte_16le(space, address + 3) << 24;
-	}
-}
-
-static void MemWrite32_16(const address_space *space, offs_t address, UINT32 data)
-{
-	if (!(address & 1))
-	{
-		memory_write_word_16le(space, address, data);
-		memory_write_word_16le(space, address + 2, data >> 16);
-	}
-	else
-	{
-		memory_write_byte_16le(space, address, data);
-		memory_write_word_16le(space, address + 1, data >> 8);
-		memory_write_byte_16le(space, address + 3, data >> 24);
-	}
-}
-
-
-/*****************************************************************/
-/* Opcode accesses for 16-bit data bus, 24-bit address bus (V60) */
-/*****************************************************************/
-
-static UINT8 OpRead8_16(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE_XOR_LE(address));
-}
-
-static UINT16 OpRead16_16(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE_XOR_LE(address)) | (memory_decrypted_read_byte(space, BYTE_XOR_LE(address + 1)) << 8);
-}
-
-static UINT32 OpRead32_16(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE_XOR_LE(address)) | (memory_decrypted_read_byte(space, BYTE_XOR_LE(address + 1)) << 8) |
-			(memory_decrypted_read_byte(space, BYTE_XOR_LE(address + 2)) << 16) | (memory_decrypted_read_byte(space, BYTE_XOR_LE(address + 3)) << 24);
-}
-
-
-
-/*****************************************************************/
-/* Memory accesses for 32-bit data bus, 32-bit address bus (V70) */
-/*****************************************************************/
-
-#define MemRead8_32		memory_read_byte_32le
-#define MemWrite8_32	memory_write_byte_32le
-
-static UINT16 MemRead16_32(const address_space *space, offs_t address)
-{
-	if (!(address & 1))
-		return memory_read_word_32le(space, address);
-	else
-	{
-		UINT16 result = memory_read_byte_32le(space, address);
-		return result | memory_read_byte_32le(space, address + 1) << 8;
-	}
-}
-
-static void MemWrite16_32(const address_space *space, offs_t address, UINT16 data)
-{
-	if (!(address & 1))
-		memory_write_word_32le(space, address, data);
-	else
-	{
-		memory_write_byte_32le(space, address, data);
-		memory_write_byte_32le(space, address + 1, data >> 8);
-	}
-}
-
-static UINT32 MemRead32_32(const address_space *space, offs_t address)
-{
-	if (!(address & 3))
-		return memory_read_dword_32le(space, address);
-	else if (!(address & 1))
-	{
-		UINT32 result = memory_read_word_32le(space, address);
-		return result | (memory_read_word_32le(space, address + 2) << 16);
-	}
-	else
-	{
-		UINT32 result = memory_read_byte_32le(space, address);
-		result |= memory_read_word_32le(space, address + 1) << 8;
-		return result | memory_read_byte_32le(space, address + 3) << 24;
-	}
-}
-
-static void MemWrite32_32(const address_space *space, offs_t address, UINT32 data)
-{
-	if (!(address & 3))
-		memory_write_dword_32le(space, address, data);
-	else if (!(address & 1))
-	{
-		memory_write_word_32le(space, address, data);
-		memory_write_word_32le(space, address + 2, data >> 16);
-	}
-	else
-	{
-		memory_write_byte_32le(space, address, data);
-		memory_write_word_32le(space, address + 1, data >> 8);
-		memory_write_byte_32le(space, address + 3, data >> 24);
-	}
-}
-
-
-
-/*****************************************************************/
-/* Opcode accesses for 32-bit data bus, 32-bit address bus (V60) */
-/*****************************************************************/
-
-static UINT8 OpRead8_32(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE4_XOR_LE(address));
-}
-
-static UINT16 OpRead16_32(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE4_XOR_LE(address)) | (memory_decrypted_read_byte(space, BYTE4_XOR_LE(address + 1)) << 8);
-}
-
-static UINT32 OpRead32_32(const address_space *space, offs_t address)
-{
-	return memory_decrypted_read_byte(space, BYTE4_XOR_LE(address)) | (memory_decrypted_read_byte(space, BYTE4_XOR_LE(address + 1)) << 8) |
-			(memory_decrypted_read_byte(space, BYTE4_XOR_LE(address + 2)) << 16) | (memory_decrypted_read_byte(space, BYTE4_XOR_LE(address + 3)) << 24);
-}
-
-
-
-/************************************************/
-/* Structures pointing to various I/O functions */
-/************************************************/
-
-static const struct cpu_info v60_i =
-{
-	MemRead8_16,  MemWrite8_16,  MemRead16_16,  MemWrite16_16,  MemRead32_16,  MemWrite32_16,
-	OpRead8_16,                  OpRead16_16,                   OpRead32_16,
-	0xfffff0
-};
-
-static const struct cpu_info v70_i =
-{
-	MemRead8_32,  MemWrite8_32,  MemRead16_32,  MemWrite16_32,  MemRead32_32,  MemWrite32_32,
-	OpRead8_32,                  OpRead16_32,                   OpRead32_32,
-	0xfffffff0
-};
-
-
-
-/**************************************/
-/* Macro shorthands for I/O functions */
-/**************************************/
-
-#define MemRead8    cpustate->info.mr8
-#define MemWrite8   cpustate->info.mw8
-#define MemRead16   cpustate->info.mr16
-#define MemWrite16  cpustate->info.mw16
-#define MemRead32   cpustate->info.mr32
-#define MemWrite32  cpustate->info.mw32
-
-#if defined(LSB_FIRST) && !defined(ALIGN_INTS)
-#define OpRead8(s, a)	(memory_decrypted_read_byte(s, a))
-#define OpRead16(s, a)	(memory_decrypted_read_word(s, a))
-#define OpRead32(s, a)	(memory_decrypted_read_dword(s, a))
-#else
-#define OpRead8     cpustate->info.or8
-#define OpRead16    cpustate->info.or16
-#define OpRead32    cpustate->info.or32
-#endif
diff -Nru src-old/emu/cpu/v810/v810.c src/emu/cpu/v810/v810.c
--- src-old/emu/cpu/v810/v810.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/v810/v810.c	2010-08-19 09:10:19.000000000 -0700
@@ -31,8 +31,9 @@
 	UINT8 nmi_line;
 	device_irq_callback irq_cb;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	UINT32 PPC;
 	int icount;
 };
@@ -109,26 +110,26 @@
 #define SET_NP(val)				(cpustate->PSW = (cpustate->PSW & ~0x00020000) | ((val) << 17))
 #define SET_AE(val)				(cpustate->PSW = (cpustate->PSW & ~0x00040000) | ((val) << 18))
 
-#define R_B(cs, addr) (memory_read_byte_32le((cs)->program, addr))
-#define R_H(cs, addr) (memory_read_word_32le((cs)->program, addr))
-#define R_W(cs, addr) (memory_read_dword_32le((cs)->program, addr))
+#define R_B(cs, addr) ((cs)->program->read_byte(addr))
+#define R_H(cs, addr) ((cs)->program->read_word(addr))
+#define R_W(cs, addr) ((cs)->program->read_dword(addr))
 
 
-#define W_B(cs, addr, val) (memory_write_byte_32le((cs)->program, addr,val))
-#define W_H(cs, addr, val) (memory_write_word_32le((cs)->program, addr,val))
-#define W_W(cs, addr, val) (memory_write_dword_32le((cs)->program, addr,val))
+#define W_B(cs, addr, val) ((cs)->program->write_byte(addr,val))
+#define W_H(cs, addr, val) ((cs)->program->write_word(addr,val))
+#define W_W(cs, addr, val) ((cs)->program->write_dword(addr,val))
 
 
-#define RIO_B(cs, addr) (memory_read_byte_32le((cs)->io, addr))
-#define RIO_H(cs, addr) (memory_read_word_32le((cs)->io, addr))
-#define RIO_W(cs, addr) (memory_read_dword_32le((cs)->io, addr))
+#define RIO_B(cs, addr) ((cs)->io->read_byte(addr))
+#define RIO_H(cs, addr) ((cs)->io->read_word(addr))
+#define RIO_W(cs, addr) ((cs)->io->read_dword(addr))
 
 
-#define WIO_B(cs, addr, val) (memory_write_byte_32le((cs)->io, addr,val))
-#define WIO_H(cs, addr, val) (memory_write_word_32le((cs)->io, addr,val))
-#define WIO_W(cs, addr, val) (memory_write_dword_32le((cs)->io, addr,val))
+#define WIO_B(cs, addr, val) ((cs)->io->write_byte(addr,val))
+#define WIO_H(cs, addr, val) ((cs)->io->write_word(addr,val))
+#define WIO_W(cs, addr, val) ((cs)->io->write_dword(addr,val))
 
-#define R_OP(cs, addr)	(memory_decrypted_read_word((cs)->program, addr))
+#define R_OP(cs, addr)	((cs)->direct->read_decrypted_word(addr))
 
 #define GET1 (op&0x1f)
 #define GET2 ((op>>5)&0x1f)
@@ -1002,6 +1003,7 @@
 	cpustate->irq_cb = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	state_save_register_device_item_array(device, 0, cpustate->reg);
diff -Nru src-old/emu/cpu/z180/z180.c src/emu/cpu/z180/z180.c
--- src-old/emu/cpu/z180/z180.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/z180/z180.c	2010-08-19 09:10:19.000000000 -0700
@@ -140,8 +140,9 @@
 	z80_daisy_chain daisy;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *iospace;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *iospace;
 	UINT8	rtemp;
 	UINT32	ioltemp;
 	int icount;
@@ -839,7 +840,7 @@
 static UINT8 z180_readcontrol(z180_state *cpustate, offs_t port)
 {
 	/* normal external readport */
-	UINT8 data = memory_read_byte_8le(cpustate->iospace, port);
+	UINT8 data = cpustate->iospace->read_byte(port);
 
 	/* remap internal I/O registers */
 	if((port & (cpustate->IO_IOCR & 0xc0)) == (cpustate->IO_IOCR & 0xc0))
@@ -1267,7 +1268,7 @@
 static void z180_writecontrol(z180_state *cpustate, offs_t port, UINT8 data)
 {
 	/* normal external write port */
-	memory_write_byte_8le(cpustate->iospace, port, data);
+	cpustate->iospace->write_byte(port, data);
 
 	/* remap internal I/O registers */
 	if((port & (cpustate->IO_IOCR & 0xc0)) == (cpustate->IO_IOCR & 0xc0))
@@ -1642,18 +1643,18 @@
 		switch( cpustate->IO_DMODE & (Z180_DMODE_SM | Z180_DMODE_DM) )
 		{
 		case 0x00:	/* memory SAR0+1 to memory DAR0+1 */
-			memory_write_byte_8le(cpustate->program, dar0++, memory_read_byte_8le(cpustate->program, sar0++));
+			cpustate->program->write_byte(dar0++, cpustate->program->read_byte(sar0++));
 			break;
 		case 0x04:	/* memory SAR0-1 to memory DAR0+1 */
-			memory_write_byte_8le(cpustate->program, dar0++, memory_read_byte_8le(cpustate->program, sar0--));
+			cpustate->program->write_byte(dar0++, cpustate->program->read_byte(sar0--));
 			break;
 		case 0x08:	/* memory SAR0 fixed to memory DAR0+1 */
-			memory_write_byte_8le(cpustate->program, dar0++, memory_read_byte_8le(cpustate->program, sar0));
+			cpustate->program->write_byte(dar0++, cpustate->program->read_byte(sar0));
 			break;
 		case 0x0c:	/* I/O SAR0 fixed to memory DAR0+1 */
 			if (cpustate->iol & Z180_DREQ0)
 			{
-				memory_write_byte_8le(cpustate->program, dar0++, IN(cpustate, sar0));
+				cpustate->program->write_byte(dar0++, IN(cpustate, sar0));
 				/* edge sensitive DREQ0 ? */
 				if (cpustate->IO_DCNTL & Z180_DCNTL_DIM0)
 				{
@@ -1663,18 +1664,18 @@
 			}
 			break;
 		case 0x10:	/* memory SAR0+1 to memory DAR0-1 */
-			memory_write_byte_8le(cpustate->program, dar0--, memory_read_byte_8le(cpustate->program, sar0++));
+			cpustate->program->write_byte(dar0--, cpustate->program->read_byte(sar0++));
 			break;
 		case 0x14:	/* memory SAR0-1 to memory DAR0-1 */
-			memory_write_byte_8le(cpustate->program, dar0--, memory_read_byte_8le(cpustate->program, sar0--));
+			cpustate->program->write_byte(dar0--, cpustate->program->read_byte(sar0--));
 			break;
 		case 0x18:	/* memory SAR0 fixed to memory DAR0-1 */
-			memory_write_byte_8le(cpustate->program, dar0--, memory_read_byte_8le(cpustate->program, sar0));
+			cpustate->program->write_byte(dar0--, cpustate->program->read_byte(sar0));
 			break;
 		case 0x1c:	/* I/O SAR0 fixed to memory DAR0-1 */
 			if (cpustate->iol & Z180_DREQ0)
             {
-				memory_write_byte_8le(cpustate->program, dar0--, IN(cpustate, sar0));
+				cpustate->program->write_byte(dar0--, IN(cpustate, sar0));
 				/* edge sensitive DREQ0 ? */
 				if (cpustate->IO_DCNTL & Z180_DCNTL_DIM0)
 				{
@@ -1684,10 +1685,10 @@
 			}
 			break;
 		case 0x20:	/* memory SAR0+1 to memory DAR0 fixed */
-			memory_write_byte_8le(cpustate->program, dar0, memory_read_byte_8le(cpustate->program, sar0++));
+			cpustate->program->write_byte(dar0, cpustate->program->read_byte(sar0++));
 			break;
 		case 0x24:	/* memory SAR0-1 to memory DAR0 fixed */
-			memory_write_byte_8le(cpustate->program, dar0, memory_read_byte_8le(cpustate->program, sar0--));
+			cpustate->program->write_byte(dar0, cpustate->program->read_byte(sar0--));
 			break;
 		case 0x28:	/* reserved */
 			break;
@@ -1696,7 +1697,7 @@
 		case 0x30:	/* memory SAR0+1 to I/O DAR0 fixed */
 			if (cpustate->iol & Z180_DREQ0)
             {
-				OUT(cpustate, dar0, memory_read_byte_8le(cpustate->program, sar0++));
+				OUT(cpustate, dar0, cpustate->program->read_byte(sar0++));
 				/* edge sensitive DREQ0 ? */
 				if (cpustate->IO_DCNTL & Z180_DCNTL_DIM0)
 				{
@@ -1708,7 +1709,7 @@
 		case 0x34:	/* memory SAR0-1 to I/O DAR0 fixed */
 			if (cpustate->iol & Z180_DREQ0)
             {
-				OUT(cpustate, dar0, memory_read_byte_8le(cpustate->program, sar0--));
+				OUT(cpustate, dar0, cpustate->program->read_byte(sar0--));
 				/* edge sensitive DREQ0 ? */
 				if (cpustate->IO_DCNTL & Z180_DCNTL_DIM0)
 				{
@@ -1776,16 +1777,16 @@
 	switch (cpustate->IO_DCNTL & (Z180_DCNTL_DIM1 | Z180_DCNTL_DIM0))
 	{
 	case 0x00:	/* memory MAR1+1 to I/O IAR1 fixed */
-		memory_write_byte_8le(cpustate->iospace, iar1, memory_read_byte_8le(cpustate->program, mar1++));
+		cpustate->iospace->write_byte(iar1, cpustate->program->read_byte(mar1++));
 		break;
 	case 0x01:	/* memory MAR1-1 to I/O IAR1 fixed */
-		memory_write_byte_8le(cpustate->iospace, iar1, memory_read_byte_8le(cpustate->program, mar1--));
+		cpustate->iospace->write_byte(iar1, cpustate->program->read_byte(mar1--));
 		break;
 	case 0x02:	/* I/O IAR1 fixed to memory MAR1+1 */
-		memory_write_byte_8le(cpustate->program, mar1++, memory_read_byte_8le(cpustate->iospace, iar1));
+		cpustate->program->write_byte(mar1++, cpustate->iospace->read_byte(iar1));
 		break;
 	case 0x03:	/* I/O IAR1 fixed to memory MAR1-1 */
-		memory_write_byte_8le(cpustate->program, mar1--, memory_read_byte_8le(cpustate->iospace, iar1));
+		cpustate->program->write_byte(mar1--, cpustate->iospace->read_byte(iar1));
 		break;
 	}
 
@@ -2212,6 +2213,7 @@
 	cpustate->after_EI = 0;
 	cpustate->ea = 0;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->iospace = device->space(AS_IO);
 	cpustate->device = device;
 
diff -Nru src-old/emu/cpu/z180/z180dd.c src/emu/cpu/z180/z180dd.c
--- src-old/emu/cpu/z180/z180dd.c	2010-05-19 11:00:06.000000000 -0700
+++ src/emu/cpu/z180/z180dd.c	2010-08-19 09:10:19.000000000 -0700
@@ -1,6 +1,6 @@
 OP(illegal,1) {
 	logerror("Z180 '%s' ill. opcode $%02x $%02x\n",
-			cpustate->device->tag(), memory_decrypted_read_byte(cpustate->program, (cpustate->_PCD-1)&0xffff), memory_decrypted_read_byte(cpustate->program, cpustate->_PCD));
+			cpustate->device->tag(), cpustate->direct->read_decrypted_byte((cpustate->_PCD-1)&0xffff), cpustate->direct->read_decrypted_byte(cpustate->_PCD));
 }
 
 /**********************************************************
diff -Nru src-old/emu/cpu/z180/z180ed.c src/emu/cpu/z180/z180ed.c
--- src-old/emu/cpu/z180/z180ed.c	2010-05-19 11:00:06.000000000 -0700
+++ src/emu/cpu/z180/z180ed.c	2010-08-19 09:10:19.000000000 -0700
@@ -1,7 +1,7 @@
 OP(illegal,2)
 {
 	logerror("Z180 '%s' ill. opcode $ed $%02x\n",
-			cpustate->device->tag(), memory_decrypted_read_byte(cpustate->program, (cpustate->_PCD-1)&0xffff));
+			cpustate->device->tag(), cpustate->direct->read_decrypted_byte((cpustate->_PCD-1)&0xffff));
 }
 
 /**********************************************************
diff -Nru src-old/emu/cpu/z180/z180ops.h src/emu/cpu/z180/z180ops.h
--- src-old/emu/cpu/z180/z180ops.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/cpu/z180/z180ops.h	2010-08-19 09:10:19.000000000 -0700
@@ -22,7 +22,7 @@
  ***************************************************************/
 #define IN(cs,port)												\
 	(((port ^ (cs)->IO_IOCR) & 0xffc0) == 0) ?					\
-		z180_readcontrol(cs, port) : memory_read_byte_8le((cs)->iospace, port)
+		z180_readcontrol(cs, port) : (cs)->iospace->read_byte(port)
 
 /***************************************************************
  * Output a byte to given I/O port
@@ -30,7 +30,7 @@
 #define OUT(cs,port,value)										\
 	if (((port ^ (cs)->IO_IOCR) & 0xffc0) == 0)					\
 		z180_writecontrol(cs,port,value);						\
-	else memory_write_byte_8le((cs)->iospace,port,value)
+	else (cs)->iospace->write_byte(port,value)
 
 /***************************************************************
  * MMU calculate the memory managemant lookup table
@@ -66,7 +66,7 @@
 /***************************************************************
  * Read a byte from given memory location
  ***************************************************************/
-#define RM(cs,addr)	memory_read_byte_8le((cs)->program, MMU_REMAP_ADDR(cs,addr))
+#define RM(cs,addr)	(cs)->program->read_byte(MMU_REMAP_ADDR(cs,addr))
 #ifdef UNUSED_FUNCTION
 UINT8 z180_readmem(running_device *device, offs_t offset)
 {
@@ -78,7 +78,7 @@
 /***************************************************************
  * Write a byte to given memory location
  ***************************************************************/
-#define WM(cs,addr,value) memory_write_byte_8le((cs)->program, MMU_REMAP_ADDR(cs,addr),value)
+#define WM(cs,addr,value) (cs)->program->write_byte(MMU_REMAP_ADDR(cs,addr),value)
 #ifdef UNUSED_FUNCTION
 void z180_writemem(running_device *device, offs_t offset, UINT8 data)
 {
@@ -114,7 +114,7 @@
 {
 	offs_t addr = cpustate->_PCD;
 	cpustate->_PC++;
-	return memory_decrypted_read_byte(cpustate->program, MMU_REMAP_ADDR(cpustate, addr));
+	return cpustate->direct->read_decrypted_byte(MMU_REMAP_ADDR(cpustate, addr));
 }
 
 /****************************************************************
@@ -127,14 +127,14 @@
 {
 	offs_t addr = cpustate->_PCD;
 	cpustate->_PC++;
-	return memory_raw_read_byte(cpustate->program, MMU_REMAP_ADDR(cpustate, addr));
+	return cpustate->direct->read_raw_byte(MMU_REMAP_ADDR(cpustate, addr));
 }
 
 INLINE UINT32 ARG16(z180_state *cpustate)
 {
 	offs_t addr = cpustate->_PCD;
 	cpustate->_PC += 2;
-	return memory_raw_read_byte(cpustate->program, MMU_REMAP_ADDR(cpustate, addr)) | (memory_raw_read_byte(cpustate->program, MMU_REMAP_ADDR(cpustate, addr+1)) << 8);
+	return cpustate->direct->read_raw_byte(MMU_REMAP_ADDR(cpustate, addr)) | (cpustate->direct->read_raw_byte(MMU_REMAP_ADDR(cpustate, addr+1)) << 8);
 }
 
 /***************************************************************
diff -Nru src-old/emu/cpu/z8/z8.c src/emu/cpu/z8/z8.c
--- src-old/emu/cpu/z8/z8.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/z8/z8.c	2010-08-19 09:10:19.000000000 -0700
@@ -159,9 +159,10 @@
 typedef struct _z8_state z8_state;
 struct _z8_state
 {
-    const address_space *program;
-    const address_space *data;
-    const address_space *io;
+    address_space *program;
+    direct_read_data *direct;
+    address_space *data;
+    address_space *io;
 
 	/* registers */
 	UINT16 pc;				/* program counter */
@@ -202,7 +203,7 @@
 
 INLINE UINT8 fetch(z8_state *cpustate)
 {
-	UINT8 data = memory_decrypted_read_byte(cpustate->program, cpustate->pc);
+	UINT8 data = cpustate->direct->read_decrypted_byte(cpustate->pc);
 
 	cpustate->pc++;
 
@@ -233,7 +234,7 @@
 
 		if (!(P3M & Z8_P3M_P0_STROBED))
 		{
-			if (mask) cpustate->input[offset] = memory_read_byte_8be(cpustate->io, offset);
+			if (mask) cpustate->input[offset] = cpustate->io->read_byte(offset);
 		}
 
 		data |= cpustate->input[offset] & mask;
@@ -249,7 +250,7 @@
 
 		if ((P3M & Z8_P3M_P33_P34_MASK) != Z8_P3M_P33_P34_DAV1_RDY1)
 		{
-			if (mask) cpustate->input[offset] = memory_read_byte_8be(cpustate->io, offset);
+			if (mask) cpustate->input[offset] = cpustate->io->read_byte(offset);
 		}
 
 		data |= cpustate->input[offset] & mask;
@@ -260,7 +261,7 @@
 
 		if (!(P3M & Z8_P3M_P2_STROBED))
 		{
-			if (mask) cpustate->input[offset] = memory_read_byte_8be(cpustate->io, offset);
+			if (mask) cpustate->input[offset] = cpustate->io->read_byte(offset);
 		}
 
 		data = (cpustate->input[offset] & mask) | (cpustate->output[offset] & ~mask);
@@ -273,7 +274,7 @@
 			mask = 0x0f;
 		}
 
-		if (mask) cpustate->input[offset] = memory_read_byte_8be(cpustate->io, offset);
+		if (mask) cpustate->input[offset] = cpustate->io->read_byte(offset);
 
 		data = (cpustate->input[offset] & mask) | (cpustate->output[offset] & ~mask);
 		break;
@@ -318,19 +319,19 @@
 		cpustate->output[offset] = data;
 		if ((P01M & Z8_P01M_P0L_MODE_MASK) == Z8_P01M_P0L_MODE_OUTPUT) mask |= 0x0f;
 		if ((P01M & Z8_P01M_P0H_MODE_MASK) == Z8_P01M_P0H_MODE_OUTPUT) mask |= 0xf0;
-		if (mask) memory_write_byte_8be(cpustate->io, offset, data & mask);
+		if (mask) cpustate->io->write_byte(offset, data & mask);
 		break;
 
 	case Z8_REGISTER_P1:
 		cpustate->output[offset] = data;
 		if ((P01M & Z8_P01M_P1_MODE_MASK) == Z8_P01M_P1_MODE_OUTPUT) mask = 0xff;
-		if (mask) memory_write_byte_8be(cpustate->io, offset, data & mask);
+		if (mask) cpustate->io->write_byte(offset, data & mask);
 		break;
 
 	case Z8_REGISTER_P2:
 		cpustate->output[offset] = data;
 		mask = cpustate->r[Z8_REGISTER_P2M] ^ 0xff;
-		if (mask) memory_write_byte_8be(cpustate->io, offset, data & mask);
+		if (mask) cpustate->io->write_byte(offset, data & mask);
 		break;
 
 	case Z8_REGISTER_P3:
@@ -342,7 +343,7 @@
 			mask = 0xf0;
 		}
 
-		if (mask) memory_write_byte_8be(cpustate->io, offset, data & mask);
+		if (mask) cpustate->io->write_byte(offset, data & mask);
 		break;
 
 	case Z8_REGISTER_SIO:
@@ -436,7 +437,7 @@
 		register_pair_write(cpustate, Z8_REGISTER_SPH, sp);
 
 		/* @SP <- src */
-		memory_write_byte(cpustate->data, sp, src);
+		cpustate->data->write_byte(sp, src);
 	}
 }
 
@@ -458,7 +459,7 @@
 		register_pair_write(cpustate, Z8_REGISTER_SPH, sp);
 
 		/* @SP <- src */
-		memory_write_word_8le(cpustate->data, sp, src);
+		cpustate->data->write_word(sp, src);
 	}
 }
 
@@ -480,7 +481,7 @@
 		register_pair_write(cpustate, Z8_REGISTER_SPH, sp);
 
 		/* @SP <- src */
-		return memory_read_byte(cpustate->data, sp);
+		return cpustate->data->read_byte(sp);
 	}
 }
 
@@ -502,7 +503,7 @@
 		register_pair_write(cpustate, Z8_REGISTER_SPH, sp);
 
 		/* @SP <- src */
-		return memory_read_word_8le(cpustate->data, sp);
+		return cpustate->data->read_word(sp);
 	}
 }
 
@@ -663,6 +664,7 @@
 
 	/* find address spaces */
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->data = device->space(AS_DATA);
 	cpustate->io = device->space(AS_IO);
 
@@ -694,7 +696,7 @@
 		debugger_instruction_hook(device, cpustate->pc);
 
 		/* TODO: sample interrupts */
-		cpustate->input[3] = memory_read_byte_8be(cpustate->io, 3);
+		cpustate->input[3] = cpustate->io->read_byte(3);
 
 		/* fetch opcode */
 		opcode = fetch(cpustate);
diff -Nru src-old/emu/cpu/z8/z8ops.c src/emu/cpu/z8/z8ops.c
--- src-old/emu/cpu/z8/z8ops.c	2009-12-29 07:35:54.000000000 -0800
+++ src/emu/cpu/z8/z8ops.c	2010-08-19 09:10:19.000000000 -0700
@@ -140,19 +140,19 @@
 INSTRUCTION( ld_R1_IM )			{ mode_R1_IM(load) }
 INSTRUCTION( ld_IR1_IM )		{ mode_IR1_IM(load) }
 
-static void load_from_memory(z8_state *cpustate, const address_space *space)
+static void load_from_memory(z8_state *cpustate, address_space *space)
 {
 	UINT8 operands = fetch(cpustate);
 	UINT8 dst = get_working_register(cpustate, operands >> 4);
 	UINT8 src = get_working_register(cpustate, operands & 0x0f);
 
 	UINT16 address = register_pair_read(cpustate, src);
-	UINT8 data = memory_decrypted_read_byte(cpustate->program, address);
+	UINT8 data = cpustate->direct->read_decrypted_byte(address);
 
 	register_write(cpustate, dst, data);
 }
 
-static void load_to_memory(z8_state *cpustate, const address_space *space)
+static void load_to_memory(z8_state *cpustate, address_space *space)
 {
 	UINT8 operands = fetch(cpustate);
 	UINT8 src = get_working_register(cpustate, operands >> 4);
@@ -161,10 +161,10 @@
 	UINT16 address = register_pair_read(cpustate, dst);
 	UINT8 data = register_read(cpustate, src);
 
-	memory_write_byte(cpustate->program, address, data);
+	cpustate->program->write_byte(address, data);
 }
 
-static void load_from_memory_autoinc(z8_state *cpustate, const address_space *space)
+static void load_from_memory_autoinc(z8_state *cpustate, address_space *space)
 {
 	UINT8 operands = fetch(cpustate);
 	UINT8 dst = get_working_register(cpustate, operands >> 4);
@@ -172,7 +172,7 @@
 	UINT8 src = get_working_register(cpustate, operands & 0x0f);
 
 	UINT16 address = register_pair_read(cpustate, src);
-	UINT8 data = memory_decrypted_read_byte(cpustate->program, address);
+	UINT8 data = cpustate->direct->read_decrypted_byte(address);
 
 	register_write(cpustate, real_dst, data);
 
@@ -180,7 +180,7 @@
 	register_pair_write(cpustate, src, address + 1);
 }
 
-static void load_to_memory_autoinc(z8_state *cpustate, const address_space *space)
+static void load_to_memory_autoinc(z8_state *cpustate, address_space *space)
 {
 	UINT8 operands = fetch(cpustate);
 	UINT8 src = get_working_register(cpustate, operands >> 4);
@@ -190,7 +190,7 @@
 	UINT16 address = register_pair_read(cpustate, dst);
 	UINT8 data = register_read(cpustate, real_src);
 
-	memory_write_byte(cpustate->program, address, data);
+	cpustate->program->write_byte(address, data);
 
 	register_pair_write(cpustate, dst, address + 1);
 	register_write(cpustate, src, real_src + 1);
diff -Nru src-old/emu/cpu/z80/z80.c src/emu/cpu/z80/z80.c
--- src-old/emu/cpu/z80/z80.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/z80/z80.c	2010-08-22 08:58:17.000000000 -0700
@@ -150,8 +150,9 @@
 	UINT32			ea;
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int				icount;
 	z80_daisy_chain daisy;
 	UINT8			rtemp;
@@ -595,17 +596,17 @@
 /***************************************************************
  * Input a byte from given I/O port
  ***************************************************************/
-#define IN(Z,port)  		memory_read_byte_8le((Z)->io, port)
+#define IN(Z,port)  		(Z)->io->read_byte(port)
 
 /***************************************************************
  * Output a byte to given I/O port
  ***************************************************************/
-#define OUT(Z,port,value)	memory_write_byte_8le((Z)->io, port, value)
+#define OUT(Z,port,value)	(Z)->io->write_byte(port, value)
 
 /***************************************************************
  * Read a byte from given memory location
  ***************************************************************/
-#define RM(Z,addr)			memory_read_byte_8le((Z)->program, addr)
+#define RM(Z,addr)			(Z)->program->read_byte(addr)
 
 /***************************************************************
  * Read a word from given memory location
@@ -619,7 +620,7 @@
 /***************************************************************
  * Write a byte to given memory location
  ***************************************************************/
-#define WM(Z,addr,value)	memory_write_byte_8le((Z)->program, addr, value)
+#define WM(Z,addr,value)	(Z)->program->write_byte(addr, value)
 
 /***************************************************************
  * Write a word to given memory location
@@ -639,7 +640,7 @@
 {
 	unsigned pc = z80->PCD;
 	z80->PC++;
-	return memory_decrypted_read_byte(z80->program, pc);
+	return z80->direct->read_decrypted_byte(pc);
 }
 
 /****************************************************************
@@ -652,14 +653,14 @@
 {
 	unsigned pc = z80->PCD;
 	z80->PC++;
-	return memory_raw_read_byte(z80->program, pc);
+	return z80->direct->read_raw_byte(pc);
 }
 
 INLINE UINT32 ARG16(z80_state *z80)
 {
 	unsigned pc = z80->PCD;
 	z80->PC += 2;
-	return memory_raw_read_byte(z80->program, pc) | (memory_raw_read_byte(z80->program, (pc+1)&0xffff) << 8);
+	return z80->direct->read_raw_byte(pc) | (z80->direct->read_raw_byte((pc+1)&0xffff) << 8);
 }
 
 /***************************************************************
@@ -2036,7 +2037,7 @@
 
 OP(illegal,1) {
 	logerror("Z80 '%s' ill. opcode $%02x $%02x\n",
-			z80->device->tag(), memory_decrypted_read_byte(z80->program, (z80->PCD-1)&0xffff), memory_decrypted_read_byte(z80->program, z80->PCD));
+			z80->device->tag(), z80->direct->read_decrypted_byte((z80->PCD-1)&0xffff), z80->direct->read_decrypted_byte(z80->PCD));
 }
 
 /**********************************************************
@@ -2624,7 +2625,7 @@
 OP(illegal,2)
 {
 	logerror("Z80 '%s' ill. opcode $ed $%02x\n",
-			z80->device->tag(), memory_decrypted_read_byte(z80->program, (z80->PCD-1)&0xffff));
+			z80->device->tag(), z80->direct->read_decrypted_byte((z80->PCD-1)&0xffff));
 }
 
 /**********************************************************
@@ -3470,6 +3471,7 @@
 	z80->irq_callback = irqcallback;
 	z80->device = device;
 	z80->program = device->space(AS_PROGRAM);
+	z80->direct = &z80->program->direct();
 	z80->io = device->space(AS_IO);
 	z80->IX = z80->IY = 0xffff; /* IX and IY are FFFF after a reset! */
 	z80->F = ZF;			/* Zero flag is set */
@@ -3541,6 +3543,8 @@
 	z80->nmi_pending = FALSE;
 	z80->irq_state = CLEAR_LINE;
 	z80->after_ei = FALSE;
+	z80->iff1 = 0;
+	z80->iff2 = 0;
 
 	z80->daisy.reset();
 
diff -Nru src-old/emu/cpu/z80/z80daisy.c src/emu/cpu/z80/z80daisy.c
--- src-old/emu/cpu/z80/z80daisy.c	2010-06-16 23:55:54.000000000 -0700
+++ src/emu/cpu/z80/z80daisy.c	2010-08-27 07:06:53.000000000 -0700
@@ -175,7 +175,7 @@
 			return;
 		}
 	}
-	logerror("z80daisy_call_reti_device: failed to find an device to reti!\n");
+	//logerror("z80daisy_call_reti_device: failed to find an device to reti!\n");
 }
 
 
diff -Nru src-old/emu/cpu/z8000/z8000.c src/emu/cpu/z8000/z8000.c
--- src-old/emu/cpu/z8000/z8000.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/cpu/z8000/z8000.c	2010-08-19 09:10:19.000000000 -0700
@@ -83,8 +83,9 @@
 	int irq_state[2];	/* IRQ line states (NVI, VI) */
 	device_irq_callback irq_callback;
 	legacy_cpu_device *device;
-	const address_space *program;
-	const address_space *io;
+	address_space *program;
+	direct_read_data *direct;
+	address_space *io;
 	int icount;
 };
 
@@ -108,53 +109,53 @@
 
 INLINE UINT16 RDOP(z8000_state *cpustate)
 {
-	UINT16 res = memory_decrypted_read_word(cpustate->program, cpustate->pc);
+	UINT16 res = cpustate->direct->read_decrypted_word(cpustate->pc);
     cpustate->pc += 2;
     return res;
 }
 
 INLINE UINT8 RDMEM_B(z8000_state *cpustate, UINT32 addr)
 {
-	return memory_read_byte_16be(cpustate->program, addr);
+	return cpustate->program->read_byte(addr);
 }
 
 INLINE UINT16 RDMEM_W(z8000_state *cpustate, UINT32 addr)
 {
 	addr &= ~1;
-	return memory_read_word_16be(cpustate->program, addr);
+	return cpustate->program->read_word(addr);
 }
 
 INLINE UINT32 RDMEM_L(z8000_state *cpustate, UINT32 addr)
 {
 	UINT32 result;
 	addr &= ~1;
-	result = memory_read_word_16be(cpustate->program, addr) << 16;
-	return result + memory_read_word_16be(cpustate->program, addr + 2);
+	result = cpustate->program->read_word(addr) << 16;
+	return result + cpustate->program->read_word(addr + 2);
 }
 
 INLINE void WRMEM_B(z8000_state *cpustate, UINT32 addr, UINT8 value)
 {
-	memory_write_byte_16be(cpustate->program, addr, value);
+	cpustate->program->write_byte(addr, value);
 }
 
 INLINE void WRMEM_W(z8000_state *cpustate, UINT32 addr, UINT16 value)
 {
 	addr &= ~1;
-	memory_write_word_16be(cpustate->program, addr, value);
+	cpustate->program->write_word(addr, value);
 }
 
 INLINE void WRMEM_L(z8000_state *cpustate, UINT32 addr, UINT32 value)
 {
 	addr &= ~1;
-	memory_write_word_16be(cpustate->program, addr, value >> 16);
-	memory_write_word_16be(cpustate->program, (UINT16)(addr + 2), value & 0xffff);
+	cpustate->program->write_word(addr, value >> 16);
+	cpustate->program->write_word((UINT16)(addr + 2), value & 0xffff);
 }
 
 INLINE UINT8 RDPORT_B(z8000_state *cpustate, int mode, UINT16 addr)
 {
 	if(mode == 0)
 	{
-		return memory_read_byte_8le(cpustate->io, addr);
+		return cpustate->io->read_byte(addr);
 	}
 	else
 	{
@@ -167,8 +168,8 @@
 {
 	if(mode == 0)
 	{
-		return memory_read_byte_8le(cpustate->io, (UINT16)(addr)) +
-			  (memory_read_byte_8le(cpustate->io, (UINT16)(addr+1)) << 8);
+		return cpustate->io->read_byte((UINT16)(addr)) +
+			  (cpustate->io->read_byte((UINT16)(addr+1)) << 8);
 	}
 	else
 	{
@@ -181,7 +182,7 @@
 {
 	if(mode == 0)
 	{
-        memory_write_byte_8le(cpustate->io, addr,value);
+        cpustate->io->write_byte(addr,value);
 	}
 	else
 	{
@@ -193,8 +194,8 @@
 {
 	if(mode == 0)
 	{
-		memory_write_byte_8le(cpustate->io, (UINT16)(addr),value & 0xff);
-		memory_write_byte_8le(cpustate->io, (UINT16)(addr+1),(value >> 8) & 0xff);
+		cpustate->io->write_byte((UINT16)(addr),value & 0xff);
+		cpustate->io->write_byte((UINT16)(addr+1),(value >> 8) & 0xff);
 	}
 	else
 	{
@@ -204,7 +205,7 @@
 
 INLINE UINT16 fetch(z8000_state *cpustate)
 {
-	UINT16 data = memory_decrypted_read_word(cpustate->program, cpustate->pc);
+	UINT16 data = cpustate->direct->read_decrypted_word(cpustate->pc);
 
 	cpustate->pc+=2;
 
@@ -365,6 +366,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* already initialized? */
@@ -379,6 +381,7 @@
 	cpustate->irq_callback = irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 
 	/* already initialized? */
@@ -395,6 +398,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 	cpustate->fcw = RDMEM_W(cpustate,  2); /* get reset cpustate->fcw */
 	if(cpustate->fcw & F_SEG)
@@ -416,6 +420,7 @@
 	cpustate->irq_callback = save_irqcallback;
 	cpustate->device = device;
 	cpustate->program = device->space(AS_PROGRAM);
+	cpustate->direct = &cpustate->program->direct();
 	cpustate->io = device->space(AS_IO);
 	cpustate->fcw = RDMEM_W(cpustate,  2); /* get reset cpustate->fcw */
 	cpustate->pc = RDMEM_W(cpustate,  4); /* get reset cpustate->pc  */
diff -Nru src-old/emu/debug/debugcmd.c src/emu/debug/debugcmd.c
--- src-old/emu/debug/debugcmd.c	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/debug/debugcmd.c	2010-08-21 12:27:14.000000000 -0700
@@ -161,9 +161,9 @@
     given address is valid for cheating
 -------------------------------------------------*/
 
-INLINE int cheat_address_is_valid(const address_space *space, offs_t address)
+INLINE int cheat_address_is_valid(address_space *space, offs_t address)
 {
-	return debug_cpu_translate(space, TRANSLATE_READ, &address) && (memory_get_write_ptr(space, address) != NULL);
+	return debug_cpu_translate(space, TRANSLATE_READ, &address) && (space->get_write_ptr(address) != NULL);
 }
 
 
@@ -210,7 +210,7 @@
     and swapping if necessary
 -------------------------------------------------*/
 
-INLINE UINT64 cheat_read_extended(const cheat_system *cheatsys, const address_space *space, offs_t address)
+INLINE UINT64 cheat_read_extended(const cheat_system *cheatsys, address_space *space, offs_t address)
 {
 	return cheat_sign_extend(cheatsys, cheat_byte_swap(cheatsys, debug_read_memory(space, address, cheatsys->width, TRUE)));
 }
@@ -554,7 +554,7 @@
     address space
 -------------------------------------------------*/
 
-int debug_command_parameter_cpu_space(running_machine *machine, const char *param, int spacenum, const address_space **result)
+int debug_command_parameter_cpu_space(running_machine *machine, const char *param, int spacenum, address_space **result)
 {
 	device_t *cpu;
 
@@ -998,14 +998,14 @@
 			/* build up a comma-separated list */
 			if (!exec->device().debug()->observing())
 			{
-				if (buffer.len() == 0)
+				if (!buffer)
 					buffer.printf("Currently ignoring device '%s'", exec->device().tag());
 				else
 					buffer.catprintf(", '%s'", exec->device().tag());
 			}
 
 		/* special message for none */
-		if (buffer.len() == 0)
+		if (!buffer)
 			buffer.printf("Not currently ignoring any devices");
 		debug_console_printf(machine, "%s\n", buffer.cstr());
 	}
@@ -1060,14 +1060,14 @@
 			/* build up a comma-separated list */
 			if (exec->device().debug()->observing())
 			{
-				if (buffer.len() == 0)
+				if (!buffer)
 					buffer.printf("Currently observing CPU '%s'", exec->device().tag());
 				else
 					buffer.catprintf(", '%s'", exec->device().tag());
 			}
 
 		/* special message for none */
-		if (buffer.len() == 0)
+		if (!buffer)
 			buffer.printf("Not currently observing any devices");
 		debug_console_printf(machine, "%s\n", buffer.cstr());
 	}
@@ -1305,7 +1305,7 @@
 static void execute_wpset(running_machine *machine, int ref, int params, const char *param[])
 {
 	parsed_expression *condition = NULL;
-	const address_space *space;
+	address_space *space;
 	const char *action = NULL;
 	UINT64 address, length;
 	int type = 0;
@@ -1438,14 +1438,14 @@
 			{
 				static const char *const types[] = { "unkn ", "read ", "write", "r/w  " };
 
-				debug_console_printf(machine, "Device '%s' %s space watchpoints:\n", device->tag(), device->debug()->watchpoint_first(spacenum)->space().name);
+				debug_console_printf(machine, "Device '%s' %s space watchpoints:\n", device->tag(), device->debug()->watchpoint_first(spacenum)->space().name());
 
 				/* loop over the watchpoints */
 				for (device_debug::watchpoint *wp = device->debug()->watchpoint_first(spacenum); wp != NULL; wp = wp->next())
 				{
 					buffer.printf("%c%4X @ %s-%s %s", wp->enabled() ? ' ' : 'D', wp->index(),
-							core_i64_hex_format(memory_byte_to_address(&wp->space(), wp->address()), wp->space().addrchars),
-							core_i64_hex_format(memory_byte_to_address_end(&wp->space(), wp->address() + wp->length()) - 1, wp->space().addrchars),
+							core_i64_hex_format(wp->space().byte_to_address(wp->address()), wp->space().addrchars()),
+							core_i64_hex_format(wp->space().byte_to_address_end(wp->address() + wp->length()) - 1, wp->space().addrchars()),
 							types[wp->type() & 3]);
 					if (wp->condition() != NULL)
 						buffer.catprintf(" if %s", wp->condition());
@@ -1511,7 +1511,7 @@
 static void execute_save(running_machine *machine, int ref, int params, const char *param[])
 {
 	UINT64 offset, endoffset, length;
-	const address_space *space;
+	address_space *space;
 	FILE *f;
 	UINT64 i;
 
@@ -1524,8 +1524,8 @@
 		return;
 
 	/* determine the addresses to write */
-	endoffset = memory_address_to_byte(space, offset + length - 1) & space->bytemask;
-	offset = memory_address_to_byte(space, offset) & space->bytemask;
+	endoffset = space->address_to_byte(offset + length - 1) & space->bytemask();
+	offset = space->address_to_byte(offset) & space->bytemask();
 
 	/* open the file */
 	f = fopen(param[0], "wb");
@@ -1555,7 +1555,7 @@
 static void execute_dump(running_machine *machine, int ref, int params, const char *param[])
 {
 	UINT64 offset, endoffset, length, width = 0, ascii = 1;
-	const address_space *space;
+	address_space *space;
 	FILE *f = NULL;
 	UINT64 i, j;
 
@@ -1573,16 +1573,16 @@
 
 	/* further validation */
 	if (width == 0)
-		width = space->dbits / 8;
-	if (width < memory_address_to_byte(space, 1))
-		width = memory_address_to_byte(space, 1);
+		width = space->data_width() / 8;
+	if (width < space->address_to_byte(1))
+		width = space->address_to_byte(1);
 	if (width != 1 && width != 2 && width != 4 && width != 8)
 	{
 		debug_console_printf(machine, "Invalid width! (must be 1,2,4 or 8)\n");
 		return;
 	}
-	endoffset = memory_address_to_byte(space, offset + length - 1) & space->bytemask;
-	offset = memory_address_to_byte(space, offset) & space->bytemask;
+	endoffset = space->address_to_byte(offset + length - 1) & space->bytemask();
+	offset = space->address_to_byte(offset) & space->bytemask();
 
 	/* open the file */
 	f = fopen(param[0], "w");
@@ -1599,7 +1599,7 @@
 		int outdex = 0;
 
 		/* print the address */
-		outdex += sprintf(&output[outdex], "%s: ", core_i64_hex_format((UINT32)memory_byte_to_address(space, i), space->logaddrchars));
+		outdex += sprintf(&output[outdex], "%s: ", core_i64_hex_format((UINT32)space->byte_to_address(i), space->logaddrchars()));
 
 		/* print the bytes */
 		for (j = 0; j < 16; j += width)
@@ -1653,7 +1653,7 @@
 static void execute_cheatinit(running_machine *machine, int ref, int params, const char *param[])
 {
 	UINT64 offset, length = 0, real_length = 0;
-	const address_space *space;
+	address_space *space;
 	UINT32 active_cheat = 0;
 	UINT64 curaddr;
 	UINT8 i, region_count = 0;
@@ -1711,19 +1711,19 @@
 	if (params <= 1)
 	{
 		offset = 0;
-		length = space->bytemask + 1;
-		for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
+		length = space->bytemask() + 1;
+		for (entry = space->map()->m_entrylist.first(); entry != NULL; entry = entry->next())
 		{
-			cheat_region[region_count].offset = memory_address_to_byte(space, entry->m_addrstart) & space->bytemask;
-			cheat_region[region_count].endoffset = memory_address_to_byte(space, entry->m_addrend) & space->bytemask;
+			cheat_region[region_count].offset = space->address_to_byte(entry->m_addrstart) & space->bytemask();
+			cheat_region[region_count].endoffset = space->address_to_byte(entry->m_addrend) & space->bytemask();
 			cheat_region[region_count].share = entry->m_share;
-			cheat_region[region_count].disabled = (entry->m_write.type == AMH_RAM) ? FALSE : TRUE;
+			cheat_region[region_count].disabled = (entry->m_write.m_type == AMH_RAM) ? FALSE : TRUE;
 
 			/* disable double share regions */
 			if (entry->m_share != NULL)
 				for (i = 0; i < region_count; i++)
 					if (cheat_region[i].share != NULL)
-						if (strcmp(cheat_region[i].share, entry->m_share)==0)
+						if (strcmp(cheat_region[i].share, entry->m_share) == 0)
 							cheat_region[region_count].disabled = TRUE;
 
 			region_count++;
@@ -1738,8 +1738,8 @@
 			return;
 
 		/* force region to the specified range */
-		cheat_region[region_count].offset = memory_address_to_byte(space, offset) & space->bytemask;;
-		cheat_region[region_count].endoffset = memory_address_to_byte(space, offset + length - 1) & space->bytemask;;
+		cheat_region[region_count].offset = space->address_to_byte(offset) & space->bytemask();
+		cheat_region[region_count].endoffset = space->address_to_byte(offset + length - 1) & space->bytemask();
 		cheat_region[region_count].share = NULL;
 		cheat_region[region_count].disabled = FALSE;
 		region_count++;
@@ -1815,7 +1815,7 @@
 
 static void execute_cheatnext(running_machine *machine, int ref, int params, const char *param[])
 {
-	const address_space *space;
+	address_space *space;
 	UINT64 cheatindex;
 	UINT32 active_cheat = 0;
 	UINT8 condition;
@@ -1984,7 +1984,7 @@
 static void execute_cheatlist(running_machine *machine, int ref, int params, const char *param[])
 {
 	char spaceletter, sizeletter;
-	const address_space *space;
+	address_space *space;
 	device_t *cpu;
 	UINT32 active_cheat = 0;
 	UINT64 cheatindex;
@@ -2000,7 +2000,7 @@
 	if (params > 0)
 		f = fopen(param[0], "w");
 
-	switch (space->spacenum)
+	switch (space->spacenum())
 	{
 		default:
 		case ADDRESS_SPACE_PROGRAM:	spaceletter = 'p';	break;
@@ -2023,19 +2023,19 @@
 		if (cheat.cheatmap[cheatindex].state == 1)
 		{
 			UINT64 value = cheat_byte_swap(&cheat, cheat_read_extended(&cheat, space, cheat.cheatmap[cheatindex].offset)) & sizemask;
-			offs_t address = memory_byte_to_address(space, cheat.cheatmap[cheatindex].offset);
+			offs_t address = space->byte_to_address(cheat.cheatmap[cheatindex].offset);
 
 			if (params > 0)
 			{
 				active_cheat++;
-				fprintf(f, "  <cheat desc=\"Possibility %d : %s (%s)\">\n", active_cheat, core_i64_hex_format(address, space->logaddrchars), core_i64_hex_format(value, cheat.width * 2));
+				fprintf(f, "  <cheat desc=\"Possibility %d : %s (%s)\">\n", active_cheat, core_i64_hex_format(address, space->logaddrchars()), core_i64_hex_format(value, cheat.width * 2));
 				fprintf(f, "    <script state=\"run\">\n");
-				fprintf(f, "      <action>%s.p%c%c@%s=%s</action>\n", cpu->tag(), spaceletter, sizeletter, core_i64_hex_format(address, space->logaddrchars), core_i64_hex_format(cheat_byte_swap(&cheat, cheat.cheatmap[cheatindex].first_value) & sizemask, cheat.width * 2));
+				fprintf(f, "      <action>%s.p%c%c@%s=%s</action>\n", cpu->tag(), spaceletter, sizeletter, core_i64_hex_format(address, space->logaddrchars()), core_i64_hex_format(cheat_byte_swap(&cheat, cheat.cheatmap[cheatindex].first_value) & sizemask, cheat.width * 2));
 				fprintf(f, "    </script>\n");
 				fprintf(f, "  </cheat>\n\n");
 			}
 			else
-				debug_console_printf(machine, "Address=%s Start=%s Current=%s\n", core_i64_hex_format(address, space->logaddrchars), core_i64_hex_format(cheat_byte_swap(&cheat, cheat.cheatmap[cheatindex].first_value) & sizemask, cheat.width * 2), core_i64_hex_format(value, cheat.width * 2));
+				debug_console_printf(machine, "Address=%s Start=%s Current=%s\n", core_i64_hex_format(address, space->logaddrchars()), core_i64_hex_format(cheat_byte_swap(&cheat, cheat.cheatmap[cheatindex].first_value) & sizemask, cheat.width * 2), core_i64_hex_format(value, cheat.width * 2));
 		}
 	}
 	if (params > 0)
@@ -2079,7 +2079,7 @@
 static void execute_find(running_machine *machine, int ref, int params, const char *param[])
 {
 	UINT64 offset, endoffset, length;
-	const address_space *space;
+	address_space *space;
 	UINT64 data_to_find[256];
 	UINT8 data_size[256];
 	int cur_data_size;
@@ -2096,9 +2096,9 @@
 		return;
 
 	/* further validation */
-	endoffset = memory_address_to_byte(space, offset + length - 1) & space->bytemask;
-	offset = memory_address_to_byte(space, offset) & space->bytemask;
-	cur_data_size = memory_address_to_byte(space, 1);
+	endoffset = space->address_to_byte(offset + length - 1) & space->bytemask();
+	offset = space->address_to_byte(offset) & space->bytemask();
+	cur_data_size = space->address_to_byte(1);
 	if (cur_data_size == 0)
 		cur_data_size = 1;
 
@@ -2161,7 +2161,7 @@
 		if (match)
 		{
 			found++;
-			debug_console_printf(machine, "Found at %s\n", core_i64_hex_format((UINT32)memory_byte_to_address(space, i), space->addrchars));
+			debug_console_printf(machine, "Found at %s\n", core_i64_hex_format((UINT32)space->byte_to_address(i), space->addrchars()));
 		}
 	}
 
@@ -2179,7 +2179,7 @@
 {
 	UINT64 offset, length, bytes = 1;
 	int minbytes, maxbytes, byteswidth;
-	const address_space *space;
+	address_space *space;
 	FILE *f = NULL;
 	int i, j;
 
@@ -2215,7 +2215,7 @@
 	/* now write the data out */
 	for (i = 0; i < length; )
 	{
-		int pcbyte = memory_address_to_byte(space, offset + i) & space->bytemask;
+		int pcbyte = space->address_to_byte(offset + i) & space->bytemask();
 		char output[200+DEBUG_COMMENT_MAX_LINE_LENGTH], disasm[200];
 		const char *comment;
 		offs_t tempaddr;
@@ -2223,7 +2223,7 @@
 		int numbytes = 0;
 
 		/* print the address */
-		outdex += sprintf(&output[outdex], "%s: ", core_i64_hex_format((UINT32)memory_byte_to_address(space, pcbyte), space->logaddrchars));
+		outdex += sprintf(&output[outdex], "%s: ", core_i64_hex_format((UINT32)space->byte_to_address(pcbyte), space->logaddrchars()));
 
 		/* make sure we can translate the address */
 		tempaddr = pcbyte;
@@ -2246,7 +2246,7 @@
 		if (bytes)
 		{
 			int startdex = outdex;
-			numbytes = memory_address_to_byte(space, numbytes);
+			numbytes = space->address_to_byte(numbytes);
 			for (j = 0; j < numbytes; j += minbytes)
 				outdex += sprintf(&output[outdex], "%s ", core_i64_hex_format(debug_read_opcode(space, pcbyte + j, minbytes, FALSE), minbytes * 2));
 			if (outdex - startdex < byteswidth)
@@ -2373,7 +2373,7 @@
 static void execute_history(running_machine *machine, int ref, int params, const char *param[])
 {
 	/* validate parameters */
-	const address_space *space;
+	address_space *space;
 	if (!debug_command_parameter_cpu_space(machine, (params > 0) ? param[0] : NULL, ADDRESS_SPACE_PROGRAM, &space))
 		return;
 
@@ -2394,7 +2394,7 @@
 		offs_t pc = debug->history_pc(-index);
 
 		/* fetch the bytes up to the maximum */
-		offs_t pcbyte = memory_address_to_byte(space, pc) & space->bytemask;
+		offs_t pcbyte = space->address_to_byte(pc) & space->bytemask();
 		UINT8 opbuf[64], argbuf[64];
 		for (int numbytes = 0; numbytes < maxbytes; numbytes++)
 		{
@@ -2405,7 +2405,7 @@
 		char buffer[200];
 		debug->disassemble(buffer, pc, opbuf, argbuf);
 
-		debug_console_printf(machine, "%s: %s\n", core_i64_hex_format(pc, space->logaddrchars), buffer);
+		debug_console_printf(machine, "%s: %s\n", core_i64_hex_format(pc, space->logaddrchars()), buffer);
 	}
 }
 
@@ -2473,7 +2473,7 @@
 
 static void execute_map(running_machine *machine, int ref, int params, const char *param[])
 {
-	const address_space *space;
+	address_space *space;
 	offs_t taddress;
 	UINT64 address;
 	int intention;
@@ -2490,14 +2490,14 @@
 	for (intention = TRANSLATE_READ_DEBUG; intention <= TRANSLATE_FETCH_DEBUG; intention++)
 	{
 		static const char *const intnames[] = { "Read", "Write", "Fetch" };
-		taddress = memory_address_to_byte(space, address) & space->bytemask;
+		taddress = space->address_to_byte(address) & space->bytemask();
 		if (debug_cpu_translate(space, intention, &taddress))
 		{
-			const char *mapname = memory_get_handler_string(space, intention == TRANSLATE_WRITE_DEBUG, taddress);
-			debug_console_printf(machine, "%7s: %s logical == %s physical -> %s\n", intnames[intention & 3], core_i64_hex_format(address, space->logaddrchars), core_i64_hex_format(memory_byte_to_address(space, taddress), space->addrchars), mapname);
+			const char *mapname = const_cast<address_space *>(space)->get_handler_string((intention == TRANSLATE_WRITE_DEBUG) ? ROW_WRITE : ROW_READ, taddress);
+			debug_console_printf(machine, "%7s: %s logical == %s physical -> %s\n", intnames[intention & 3], core_i64_hex_format(address, space->logaddrchars()), core_i64_hex_format(space->byte_to_address(taddress), space->addrchars()), mapname);
 		}
 		else
-			debug_console_printf(machine, "%7s: %s logical is unmapped\n", intnames[intention & 3], core_i64_hex_format(address, space->logaddrchars));
+			debug_console_printf(machine, "%7s: %s logical is unmapped\n", intnames[intention & 3], core_i64_hex_format(address, space->logaddrchars()));
 	}
 }
 
diff -Nru src-old/emu/debug/debugcmd.h src/emu/debug/debugcmd.h
--- src-old/emu/debug/debugcmd.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/debug/debugcmd.h	2010-08-19 00:26:14.000000000 -0700
@@ -33,6 +33,6 @@
 int debug_command_parameter_cpu(running_machine *machine, const char *param, device_t **result);
 
 /* validates a parameter as a cpu and retrieves the given address space */
-int debug_command_parameter_cpu_space(running_machine *machine, const char *param, int spacenum, const address_space **result);
+int debug_command_parameter_cpu_space(running_machine *machine, const char *param, int spacenum, address_space **result);
 
 #endif
diff -Nru src-old/emu/debug/debugcmt.c src/emu/debug/debugcmt.c
--- src-old/emu/debug/debugcmt.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/debug/debugcmt.c	2010-08-19 00:26:14.000000000 -0700
@@ -281,7 +281,7 @@
 
 UINT32 debug_comment_get_opcode_crc32(device_t *device, offs_t address)
 {
-	const address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
 	int i;
 	UINT32 crc;
 	UINT8 opbuf[64], argbuf[64];
@@ -289,7 +289,7 @@
 	offs_t numbytes;
 	cpu_device *cpudevice = downcast<cpu_device *>(device);
 	int maxbytes = cpudevice->max_opcode_bytes();
-	UINT32 addrmask = space->logaddrmask;
+	UINT32 addrmask = space->logaddrmask();
 
 	memset(opbuf, 0x00, sizeof(opbuf));
 	memset(argbuf, 0x00, sizeof(argbuf));
@@ -302,7 +302,7 @@
 	}
 
 	numbytes = device->debug()->disassemble(buff, address & addrmask, opbuf, argbuf) & DASMFLAG_LENGTHMASK;
-	numbytes = memory_address_to_byte(space, numbytes);
+	numbytes = space->address_to_byte(numbytes);
 
 	crc = crc32(0, argbuf, numbytes);
 
diff -Nru src-old/emu/debug/debugcpu.c src/emu/debug/debugcpu.c
--- src-old/emu/debug/debugcpu.c	2010-07-06 20:30:06.000000000 -0700
+++ src/emu/debug/debugcpu.c	2010-08-22 05:36:56.000000000 -0700
@@ -81,10 +81,10 @@
 
 	symbol_table *	symtable;					/* global symbol table */
 
-	UINT8			within_instruction_hook;
-	UINT8			vblank_occurred;
-	UINT8			memory_modified;
-	UINT8			debugger_access;
+	bool			within_instruction_hook;
+	bool			vblank_occurred;
+	bool			memory_modified;
+	bool			debugger_access;
 
 	int				execution_state;
 
@@ -112,10 +112,10 @@
 
 /* expression handlers */
 static UINT64 expression_read_memory(void *param, const char *name, int space, UINT32 address, int size);
-static UINT64 expression_read_program_direct(const address_space *space, int opcode, offs_t address, int size);
+static UINT64 expression_read_program_direct(address_space *space, int opcode, offs_t address, int size);
 static UINT64 expression_read_memory_region(running_machine *machine, const char *rgntag, offs_t address, int size);
 static void expression_write_memory(void *param, const char *name, int space, UINT32 address, int size, UINT64 data);
-static void expression_write_program_direct(const address_space *space, int opcode, offs_t address, int size, UINT64 data);
+static void expression_write_program_direct(address_space *space, int opcode, offs_t address, int size, UINT64 data);
 static void expression_write_memory_region(running_machine *machine, const char *rgntag, offs_t address, int size, UINT64 data);
 static EXPRERR expression_validate(void *param, const char *name, int space);
 
@@ -243,14 +243,14 @@
 
 
 /*-------------------------------------------------
-    debug_cpu_is_stopped - return TRUE if the
+    debug_cpu_is_stopped - return true if the
     current execution state is stopped
 -------------------------------------------------*/
 
 int debug_cpu_is_stopped(running_machine *machine)
 {
 	debugcpu_private *global = machine->debugcpu_data;
-	return (global != NULL) ? (global->execution_state == EXECUTION_STATE_STOPPED) : FALSE;
+	return (global != NULL) ? (global->execution_state == EXECUTION_STATE_STOPPED) : false;
 }
 
 
@@ -323,12 +323,12 @@
     address
 -------------------------------------------------*/
 
-int debug_cpu_translate(const address_space *space, int intention, offs_t *address)
+int debug_cpu_translate(address_space *space, int intention, offs_t *address)
 {
 	device_memory_interface *memory;
 	if (space->cpu->interface(memory))
-		return memory->translate(space->spacenum, intention, *address);
-	return TRUE;
+		return memory->translate(space->spacenum(), intention, *address);
+	return true;
 }
 
 
@@ -341,32 +341,33 @@
     the specified memory space
 -------------------------------------------------*/
 
-UINT8 debug_read_byte(const address_space *space, offs_t address, int apply_translation)
+UINT8 debug_read_byte(address_space *_space, offs_t address, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 	UINT64 custom;
 	UINT8 result;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* all accesses from this point on are for the debugger */
-	memory_set_debugger_access(space, global->debugger_access = TRUE);
+	space->set_debugger_access(global->debugger_access = true);
 
 	/* translate if necessary; if not mapped, return 0xff */
 	if (apply_translation && !debug_cpu_translate(space, TRANSLATE_READ_DEBUG, &address))
 		result = 0xff;
 
-	/* if there is a custom read handler, and it returns TRUE, use that value */
-	else if (device_memory(space->cpu)->read(space->spacenum, address, 1, custom))
+	/* if there is a custom read handler, and it returns true, use that value */
+	else if (device_memory(space->cpu)->read(space->spacenum(), address, 1, custom))
 		result = custom;
 
 	/* otherwise, call the byte reading function for the translated address */
 	else
-		result = memory_read_byte(space, address);
+		result = space->read_byte(address);
 
 	/* no longer accessing via the debugger */
-	memory_set_debugger_access(space, global->debugger_access = FALSE);
+	space->set_debugger_access(global->debugger_access = false);
 	return result;
 }
 
@@ -376,13 +377,14 @@
     specified memory space
 -------------------------------------------------*/
 
-UINT16 debug_read_word(const address_space *space, offs_t address, int apply_translation)
+UINT16 debug_read_word(address_space *_space, offs_t address, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 	UINT16 result;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is misaligned read, or if there are no word readers, just read two bytes */
 	if ((address & 1) != 0)
@@ -391,7 +393,7 @@
 		UINT8 byte1 = debug_read_byte(space, address + 1, apply_translation);
 
 		/* based on the endianness, the result is assembled differently */
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 			result = byte0 | (byte1 << 8);
 		else
 			result = byte1 | (byte0 << 8);
@@ -403,22 +405,22 @@
 		UINT64 custom;
 
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, return 0xffff */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_READ_DEBUG, &address))
 			result = 0xffff;
 
-		/* if there is a custom read handler, and it returns TRUE, use that value */
-		else if (device_memory(space->cpu)->read(space->spacenum, address, 2, custom))
+		/* if there is a custom read handler, and it returns true, use that value */
+		else if (device_memory(space->cpu)->read(space->spacenum(), address, 2, custom))
 			result = custom;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			result = memory_read_word(space, address);
+			result = space->read_word(address);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
+		space->set_debugger_access(global->debugger_access = false);
 	}
 
 	return result;
@@ -430,13 +432,14 @@
     specified memory space
 -------------------------------------------------*/
 
-UINT32 debug_read_dword(const address_space *space, offs_t address, int apply_translation)
+UINT32 debug_read_dword(address_space *_space, offs_t address, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 	UINT32 result;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is misaligned read, or if there are no dword readers, just read two words */
 	if ((address & 3) != 0)
@@ -445,7 +448,7 @@
 		UINT16 word1 = debug_read_word(space, address + 2, apply_translation);
 
 		/* based on the endianness, the result is assembled differently */
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 			result = word0 | (word1 << 16);
 		else
 			result = word1 | (word0 << 16);
@@ -457,22 +460,22 @@
 		UINT64 custom;
 
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, return 0xffffffff */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_READ_DEBUG, &address))
 			result = 0xffffffff;
 
-		/* if there is a custom read handler, and it returns TRUE, use that value */
-		else if (device_memory(space->cpu)->read(space->spacenum, address, 4, custom))
+		/* if there is a custom read handler, and it returns true, use that value */
+		else if (device_memory(space->cpu)->read(space->spacenum(), address, 4, custom))
 			result = custom;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			result = memory_read_dword(space, address);
+			result = space->read_dword(address);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
+		space->set_debugger_access(global->debugger_access = false);
 	}
 
 	return result;
@@ -484,13 +487,14 @@
     specified memory space
 -------------------------------------------------*/
 
-UINT64 debug_read_qword(const address_space *space, offs_t address, int apply_translation)
+UINT64 debug_read_qword(address_space *_space, offs_t address, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 	UINT64 result;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is misaligned read, or if there are no qword readers, just read two dwords */
 	if ((address & 7) != 0)
@@ -499,7 +503,7 @@
 		UINT32 dword1 = debug_read_dword(space, address + 4, apply_translation);
 
 		/* based on the endianness, the result is assembled differently */
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 			result = dword0 | ((UINT64)dword1 << 32);
 		else
 			result = dword1 | ((UINT64)dword0 << 32);
@@ -511,22 +515,22 @@
 		UINT64 custom;
 
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, return 0xffffffffffffffff */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_READ_DEBUG, &address))
 			result = ~(UINT64)0;
 
-		/* if there is a custom read handler, and it returns TRUE, use that value */
-		else if (device_memory(space->cpu)->read(space->spacenum, address, 8, custom))
+		/* if there is a custom read handler, and it returns true, use that value */
+		else if (device_memory(space->cpu)->read(space->spacenum(), address, 8, custom))
 			result = custom;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			result = memory_read_qword(space, address);
+			result = space->read_qword(address);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
+		space->set_debugger_access(global->debugger_access = false);
 	}
 
 	return result;
@@ -538,7 +542,7 @@
     from the specified memory space
 -------------------------------------------------*/
 
-UINT64 debug_read_memory(const address_space *space, offs_t address, int size, int apply_translation)
+UINT64 debug_read_memory(address_space *space, offs_t address, int size, int apply_translation)
 {
 	UINT64 result = ~(UINT64)0 >> (64 - 8*size);
 	switch (size)
@@ -557,31 +561,32 @@
     specified memory space
 -------------------------------------------------*/
 
-void debug_write_byte(const address_space *space, offs_t address, UINT8 data, int apply_translation)
+void debug_write_byte(address_space *_space, offs_t address, UINT8 data, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* all accesses from this point on are for the debugger */
-	memory_set_debugger_access(space, global->debugger_access = TRUE);
+	space->set_debugger_access(global->debugger_access = true);
 
 	/* translate if necessary; if not mapped, we're done */
 	if (apply_translation && !debug_cpu_translate(space, TRANSLATE_WRITE_DEBUG, &address))
 		;
 
-	/* if there is a custom write handler, and it returns TRUE, use that */
-	else if (device_memory(space->cpu)->write(space->spacenum, address, 1, data))
+	/* if there is a custom write handler, and it returns true, use that */
+	else if (device_memory(space->cpu)->write(space->spacenum(), address, 1, data))
 		;
 
 	/* otherwise, call the byte reading function for the translated address */
 	else
-		memory_write_byte(space, address, data);
+		space->write_byte(address, data);
 
 	/* no longer accessing via the debugger */
-	memory_set_debugger_access(space, global->debugger_access = FALSE);
-	global->memory_modified = TRUE;
+	space->set_debugger_access(global->debugger_access = false);
+	global->memory_modified = true;
 }
 
 
@@ -590,17 +595,18 @@
     specified memory space
 -------------------------------------------------*/
 
-void debug_write_word(const address_space *space, offs_t address, UINT16 data, int apply_translation)
+void debug_write_word(address_space *_space, offs_t address, UINT16 data, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is a misaligned write, or if there are no word writers, just read two bytes */
 	if ((address & 1) != 0)
 	{
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 		{
 			debug_write_byte(space, address + 0, data >> 0, apply_translation);
 			debug_write_byte(space, address + 1, data >> 8, apply_translation);
@@ -616,23 +622,23 @@
 	else
 	{
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, we're done */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_WRITE_DEBUG, &address))
 			;
 
-		/* if there is a custom write handler, and it returns TRUE, use that */
-		else if (device_memory(space->cpu)->write(space->spacenum, address, 2, data))
+		/* if there is a custom write handler, and it returns true, use that */
+		else if (device_memory(space->cpu)->write(space->spacenum(), address, 2, data))
 			;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			memory_write_word(space, address, data);
+			space->write_word(address, data);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
-		global->memory_modified = TRUE;
+		space->set_debugger_access(global->debugger_access = false);
+		global->memory_modified = true;
 	}
 }
 
@@ -642,17 +648,18 @@
     specified memory space
 -------------------------------------------------*/
 
-void debug_write_dword(const address_space *space, offs_t address, UINT32 data, int apply_translation)
+void debug_write_dword(address_space *_space, offs_t address, UINT32 data, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is a misaligned write, or if there are no dword writers, just read two words */
 	if ((address & 3) != 0)
 	{
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 		{
 			debug_write_word(space, address + 0, data >> 0, apply_translation);
 			debug_write_word(space, address + 2, data >> 16, apply_translation);
@@ -668,23 +675,23 @@
 	else
 	{
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, we're done */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_WRITE_DEBUG, &address))
 			;
 
-		/* if there is a custom write handler, and it returns TRUE, use that */
-		else if (device_memory(space->cpu)->write(space->spacenum, address, 4, data))
+		/* if there is a custom write handler, and it returns true, use that */
+		else if (device_memory(space->cpu)->write(space->spacenum(), address, 4, data))
 			;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			memory_write_dword(space, address, data);
+			space->write_dword(address, data);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
-		global->memory_modified = TRUE;
+		space->set_debugger_access(global->debugger_access = false);
+		global->memory_modified = true;
 	}
 }
 
@@ -694,17 +701,18 @@
     specified memory space
 -------------------------------------------------*/
 
-void debug_write_qword(const address_space *space, offs_t address, UINT64 data, int apply_translation)
+void debug_write_qword(address_space *_space, offs_t address, UINT64 data, int apply_translation)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	debugcpu_private *global = space->machine->debugcpu_data;
 
 	/* mask against the logical byte mask */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* if this is a misaligned write, or if there are no qword writers, just read two dwords */
 	if ((address & 7) != 0)
 	{
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 		{
 			debug_write_dword(space, address + 0, data >> 0, apply_translation);
 			debug_write_dword(space, address + 4, data >> 32, apply_translation);
@@ -720,23 +728,23 @@
 	else
 	{
 		/* all accesses from this point on are for the debugger */
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 		/* translate if necessary; if not mapped, we're done */
 		if (apply_translation && !debug_cpu_translate(space, TRANSLATE_WRITE_DEBUG, &address))
 			;
 
-		/* if there is a custom write handler, and it returns TRUE, use that */
-		else if (device_memory(space->cpu)->write(space->spacenum, address, 8, data))
+		/* if there is a custom write handler, and it returns true, use that */
+		else if (device_memory(space->cpu)->write(space->spacenum(), address, 8, data))
 			;
 
 		/* otherwise, call the byte reading function for the translated address */
 		else
-			memory_write_qword(space, address, data);
+			space->write_qword(address, data);
 
 		/* no longer accessing via the debugger */
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
-		global->memory_modified = TRUE;
+		space->set_debugger_access(global->debugger_access = false);
+		global->memory_modified = true;
 	}
 }
 
@@ -746,7 +754,7 @@
     to the specified memory space
 -------------------------------------------------*/
 
-void debug_write_memory(const address_space *space, offs_t address, UINT64 data, int size, int apply_translation)
+void debug_write_memory(address_space *space, offs_t address, UINT64 data, int size, int apply_translation)
 {
 	switch (size)
 	{
@@ -763,31 +771,32 @@
     the given offset from opcode space
 -------------------------------------------------*/
 
-UINT64 debug_read_opcode(const address_space *space, offs_t address, int size, int arg)
+UINT64 debug_read_opcode(address_space *_space, offs_t address, int size, int arg)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	UINT64 result = ~(UINT64)0 & (~(UINT64)0 >> (64 - 8*size)), result2;
 	debugcpu_private *global = space->machine->debugcpu_data;
 
 	/* keep in logical range */
-	address &= space->logbytemask;
+	address &= space->logbytemask();
 
 	/* return early if we got the result directly */
-	memory_set_debugger_access(space, global->debugger_access = TRUE);
+	space->set_debugger_access(global->debugger_access = true);
 	device_memory_interface *memory;
 	if (space->cpu->interface(memory) && memory->readop(address, size, result2))
 	{
-		memory_set_debugger_access(space, global->debugger_access = FALSE);
+		space->set_debugger_access(global->debugger_access = false);
 		return result2;
 	}
 
 	/* if we're bigger than the address bus, break into smaller pieces */
-	if (size > space->dbits / 8)
+	if (size > space->data_width() / 8)
 	{
 		int halfsize = size / 2;
 		UINT64 r0 = debug_read_opcode(space, address + 0, halfsize, arg);
 		UINT64 r1 = debug_read_opcode(space, address + halfsize, halfsize, arg);
 
-		if (space->endianness == ENDIANNESS_LITTLE)
+		if (space->endianness() == ENDIANNESS_LITTLE)
 			return r0 | (r1 << (8 * halfsize));
 		else
 			return r1 | (r0 << (8 * halfsize));
@@ -798,8 +807,8 @@
 		return result;
 
 	/* keep in physical range */
-	address &= space->bytemask;
-	switch (space->dbits / 8 * 10 + size)
+	address &= space->bytemask();
+	switch (space->data_width() / 8 * 10 + size)
 	{
 		/* dump opcodes in bytes from a byte-sized bus */
 		case 11:
@@ -807,7 +816,7 @@
 
 		/* dump opcodes in bytes from a word-sized bus */
 		case 21:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? BYTE_XOR_LE(0) : BYTE_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? BYTE_XOR_LE(0) : BYTE_XOR_BE(0);
 			break;
 
 		/* dump opcodes in words from a word-sized bus */
@@ -816,12 +825,12 @@
 
 		/* dump opcodes in bytes from a dword-sized bus */
 		case 41:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? BYTE4_XOR_LE(0) : BYTE4_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? BYTE4_XOR_LE(0) : BYTE4_XOR_BE(0);
 			break;
 
 		/* dump opcodes in words from a dword-sized bus */
 		case 42:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? WORD_XOR_LE(0) : WORD_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? WORD_XOR_LE(0) : WORD_XOR_BE(0);
 			break;
 
 		/* dump opcodes in dwords from a dword-sized bus */
@@ -830,17 +839,17 @@
 
 		/* dump opcodes in bytes from a qword-sized bus */
 		case 81:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? BYTE8_XOR_LE(0) : BYTE8_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? BYTE8_XOR_LE(0) : BYTE8_XOR_BE(0);
 			break;
 
 		/* dump opcodes in words from a qword-sized bus */
 		case 82:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? WORD2_XOR_LE(0) : WORD2_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? WORD2_XOR_LE(0) : WORD2_XOR_BE(0);
 			break;
 
 		/* dump opcodes in dwords from a qword-sized bus */
 		case 84:
-			address ^= (space->endianness == ENDIANNESS_LITTLE) ? DWORD_XOR_LE(0) : DWORD_XOR_BE(0);
+			address ^= (space->endianness() == ENDIANNESS_LITTLE) ? DWORD_XOR_LE(0) : DWORD_XOR_BE(0);
 			break;
 
 		/* dump opcodes in qwords from a qword-sized bus */
@@ -848,27 +857,27 @@
 			break;
 
 		default:
-			fatalerror("debug_read_opcode: unknown type = %d", space->dbits / 8 * 10 + size);
+			fatalerror("debug_read_opcode: unknown type = %d", space->data_width() / 8 * 10 + size);
 			break;
 	}
 
 	/* turn on debugger access */
 	if (!global->debugger_access)
-		memory_set_debugger_access(space, global->debugger_access = TRUE);
+		space->set_debugger_access(global->debugger_access = true);
 
 	/* switch off the size and handle unaligned accesses */
 	switch (size)
 	{
 		case 1:
-			result = (arg) ? memory_raw_read_byte(space, address) : memory_decrypted_read_byte(space, address);
+			result = (arg) ? space->direct().read_raw_byte(address) : space->direct().read_decrypted_byte(address);
 			break;
 
 		case 2:
-			result = (arg) ? memory_raw_read_word(space, address & ~1) : memory_decrypted_read_word(space, address & ~1);
+			result = (arg) ? space->direct().read_raw_word(address & ~1) : space->direct().read_decrypted_word(address & ~1);
 			if ((address & 1) != 0)
 			{
-				result2 = (arg) ? memory_raw_read_word(space, (address & ~1) + 2) : memory_decrypted_read_word(space, (address & ~1) + 2);
-				if (space->endianness == ENDIANNESS_LITTLE)
+				result2 = (arg) ? space->direct().read_raw_word((address & ~1) + 2) : space->direct().read_decrypted_word((address & ~1) + 2);
+				if (space->endianness() == ENDIANNESS_LITTLE)
 					result = (result >> (8 * (address & 1))) | (result2 << (16 - 8 * (address & 1)));
 				else
 					result = (result << (8 * (address & 1))) | (result2 >> (16 - 8 * (address & 1)));
@@ -877,11 +886,11 @@
 			break;
 
 		case 4:
-			result = (arg) ? memory_raw_read_dword(space, address & ~3) : memory_decrypted_read_dword(space, address & ~3);
+			result = (arg) ? space->direct().read_raw_dword(address & ~3) : space->direct().read_decrypted_dword(address & ~3);
 			if ((address & 3) != 0)
 			{
-				result2 = (arg) ? memory_raw_read_dword(space, (address & ~3) + 4) : memory_decrypted_read_dword(space, (address & ~3) + 4);
-				if (space->endianness == ENDIANNESS_LITTLE)
+				result2 = (arg) ? space->direct().read_raw_dword((address & ~3) + 4) : space->direct().read_decrypted_dword((address & ~3) + 4);
+				if (space->endianness() == ENDIANNESS_LITTLE)
 					result = (result >> (8 * (address & 3))) | (result2 << (32 - 8 * (address & 3)));
 				else
 					result = (result << (8 * (address & 3))) | (result2 >> (32 - 8 * (address & 3)));
@@ -890,11 +899,11 @@
 			break;
 
 		case 8:
-			result = (arg) ? memory_raw_read_qword(space, address & ~7) : memory_decrypted_read_qword(space, address & ~7);
+			result = (arg) ? space->direct().read_raw_qword(address & ~7) : space->direct().read_decrypted_qword(address & ~7);
 			if ((address & 7) != 0)
 			{
-				result2 = (arg) ? memory_raw_read_qword(space, (address & ~7) + 8) : memory_decrypted_read_qword(space, (address & ~7) + 8);
-				if (space->endianness == ENDIANNESS_LITTLE)
+				result2 = (arg) ? space->direct().read_raw_qword((address & ~7) + 8) : space->direct().read_decrypted_qword((address & ~7) + 8);
+				if (space->endianness() == ENDIANNESS_LITTLE)
 					result = (result >> (8 * (address & 7))) | (result2 << (64 - 8 * (address & 7)));
 				else
 					result = (result << (8 * (address & 7))) | (result2 >> (64 - 8 * (address & 7)));
@@ -903,7 +912,7 @@
 	}
 
 	/* no longer accessing via the debugger */
-	memory_set_debugger_access(space, global->debugger_access = FALSE);
+	space->set_debugger_access(global->debugger_access = false);
 	return result;
 }
 
@@ -935,7 +944,7 @@
 {
 	/* just set a global flag to be consumed later */
 	if (vblank_state)
-		device.machine->debugcpu_data->vblank_occurred = TRUE;
+		device.machine->debugcpu_data->vblank_occurred = true;
 }
 
 
@@ -1030,7 +1039,7 @@
 	running_machine *machine = (running_machine *)param;
 	UINT64 result = ~(UINT64)0 >> (64 - 8*size);
 	device_t *device = NULL;
-	const address_space *space;
+	address_space *space;
 
 	switch (spacenum)
 	{
@@ -1044,7 +1053,7 @@
 				device = debug_cpu_get_visible_cpu(machine);
 			space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM + (spacenum - EXPSPACE_PROGRAM_LOGICAL));
 			if (space != NULL)
-				result = debug_read_memory(space, memory_address_to_byte(space, address), size, TRUE);
+				result = debug_read_memory(space, space->address_to_byte(address), size, true);
 			break;
 
 		case EXPSPACE_PROGRAM_PHYSICAL:
@@ -1057,7 +1066,7 @@
 				device = debug_cpu_get_visible_cpu(machine);
 			space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM + (spacenum - EXPSPACE_PROGRAM_PHYSICAL));
 			if (space != NULL)
-				result = debug_read_memory(space, memory_address_to_byte(space, address), size, FALSE);
+				result = debug_read_memory(space, space->address_to_byte(address), size, false);
 			break;
 
 		case EXPSPACE_OPCODE:
@@ -1084,8 +1093,9 @@
     directly from an opcode or RAM pointer
 -------------------------------------------------*/
 
-static UINT64 expression_read_program_direct(const address_space *space, int opcode, offs_t address, int size)
+static UINT64 expression_read_program_direct(address_space *_space, int opcode, offs_t address, int size)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	UINT64 result = ~(UINT64)0 >> (64 - 8*size);
 
 	if (space != NULL)
@@ -1094,7 +1104,7 @@
 
 		/* adjust the address into a byte address, but not if being called recursively */
 		if ((opcode & 2) == 0)
-			address = memory_address_to_byte(space, address);
+			address = space->address_to_byte(address);
 
 		/* call ourself recursively until we are byte-sized */
 		if (size > 1)
@@ -1107,7 +1117,7 @@
 			r1 = expression_read_program_direct(space, opcode | 2, address + halfsize, halfsize);
 
 			/* assemble based on the target endianness */
-			if (space->endianness == ENDIANNESS_LITTLE)
+			if (space->endianness() == ENDIANNESS_LITTLE)
 				result = r0 | (r1 << (8 * halfsize));
 			else
 				result = r1 | (r0 << (8 * halfsize));
@@ -1117,18 +1127,18 @@
 		else
 		{
 			/* lowmask specified which address bits are within the databus width */
-			offs_t lowmask = space->dbits / 8 - 1;
+			offs_t lowmask = space->data_width() / 8 - 1;
 
 			/* get the base of memory, aligned to the address minus the lowbits */
 			if (opcode & 1)
-				base = (UINT8 *)memory_decrypted_read_ptr(space, address & ~lowmask);
+				base = (UINT8 *)space->direct().read_decrypted_ptr(address & ~lowmask);
 			else
-				base = (UINT8 *)memory_get_read_ptr(space, address & ~lowmask);
+				base = (UINT8 *)space->get_read_ptr(address & ~lowmask);
 
 			/* if we have a valid base, return the appropriate byte */
 			if (base != NULL)
 			{
-				if (space->endianness == ENDIANNESS_LITTLE)
+				if (space->endianness() == ENDIANNESS_LITTLE)
 					result = base[BYTE8_XOR_LE(address) & lowmask];
 				else
 					result = base[BYTE8_XOR_BE(address) & lowmask];
@@ -1197,7 +1207,7 @@
 {
 	running_machine *machine = (running_machine *)param;
 	device_t *device = NULL;
-	const address_space *space;
+	address_space *space;
 
 	switch (spacenum)
 	{
@@ -1211,7 +1221,7 @@
 				device = debug_cpu_get_visible_cpu(machine);
 			space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM + (spacenum - EXPSPACE_PROGRAM_LOGICAL));
 			if (space != NULL)
-				debug_write_memory(space, memory_address_to_byte(space, address), data, size, TRUE);
+				debug_write_memory(space, space->address_to_byte(address), data, size, true);
 			break;
 
 		case EXPSPACE_PROGRAM_PHYSICAL:
@@ -1224,7 +1234,7 @@
 				device = debug_cpu_get_visible_cpu(machine);
 			space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM + (spacenum - EXPSPACE_PROGRAM_PHYSICAL));
 			if (space != NULL)
-				debug_write_memory(space, memory_address_to_byte(space, address), data, size, FALSE);
+				debug_write_memory(space, space->address_to_byte(address), data, size, false);
 			break;
 
 		case EXPSPACE_OPCODE:
@@ -1250,8 +1260,9 @@
     directly to an opcode or RAM pointer
 -------------------------------------------------*/
 
-static void expression_write_program_direct(const address_space *space, int opcode, offs_t address, int size, UINT64 data)
+static void expression_write_program_direct(address_space *_space, int opcode, offs_t address, int size, UINT64 data)
 {
+	address_space *space = const_cast<address_space *>(_space);
 	if (space != NULL)
 	{
 		debugcpu_private *global = space->machine->debugcpu_data;
@@ -1259,7 +1270,7 @@
 
 		/* adjust the address into a byte address, but not if being called recursively */
 		if ((opcode & 2) == 0)
-			address = memory_address_to_byte(space, address);
+			address = space->address_to_byte(address);
 
 		/* call ourself recursively until we are byte-sized */
 		if (size > 1)
@@ -1269,7 +1280,7 @@
 
 			/* break apart based on the target endianness */
 			halfmask = ~(UINT64)0 >> (64 - 8 * halfsize);
-			if (space->endianness == ENDIANNESS_LITTLE)
+			if (space->endianness() == ENDIANNESS_LITTLE)
 			{
 				r0 = data & halfmask;
 				r1 = (data >> (8 * halfsize)) & halfmask;
@@ -1289,22 +1300,22 @@
 		else
 		{
 			/* lowmask specified which address bits are within the databus width */
-			offs_t lowmask = space->dbits / 8 - 1;
+			offs_t lowmask = space->data_width() / 8 - 1;
 
 			/* get the base of memory, aligned to the address minus the lowbits */
 			if (opcode & 1)
-				base = (UINT8 *)memory_decrypted_read_ptr(space, address & ~lowmask);
+				base = (UINT8 *)space->direct().read_decrypted_ptr(address & ~lowmask);
 			else
-				base = (UINT8 *)memory_get_read_ptr(space, address & ~lowmask);
+				base = (UINT8 *)space->get_read_ptr(address & ~lowmask);
 
 			/* if we have a valid base, write the appropriate byte */
 			if (base != NULL)
 			{
-				if (space->endianness == ENDIANNESS_LITTLE)
+				if (space->endianness() == ENDIANNESS_LITTLE)
 					base[BYTE8_XOR_LE(address) & lowmask] = data;
 				else
 					base[BYTE8_XOR_BE(address) & lowmask] = data;
-				global->memory_modified = TRUE;
+				global->memory_modified = true;
 			}
 		}
 	}
@@ -1360,7 +1371,7 @@
 				base[BYTE8_XOR_LE(address) & lowmask] = data;
 			else
 				base[BYTE8_XOR_BE(address) & lowmask] = data;
-			global->memory_modified = TRUE;
+			global->memory_modified = true;
 		}
 	}
 }
@@ -1678,7 +1689,7 @@
 		// if a VBLANK occurred, check on things
 		if (global->vblank_occurred)
 		{
-			global->vblank_occurred = FALSE;
+			global->vblank_occurred = false;
 
 			// if we were waiting for a VBLANK, signal it now
 			if ((m_flags & DEBUG_FLAG_STOP_VBLANK) != 0)
@@ -1769,7 +1780,7 @@
 	debugcpu_private *global = m_device.machine->debugcpu_data;
 
 	// note that we are in the debugger code
-	global->within_instruction_hook = TRUE;
+	global->within_instruction_hook = true;
 
 	// update the history
 	m_pc_history[m_pc_history_index++ % HISTORY_SIZE] = curpc;
@@ -1831,7 +1842,7 @@
 	// if we are supposed to halt, do it now
 	if (global->execution_state == EXECUTION_STATE_STOPPED)
 	{
-		int firststop = TRUE;
+		int firststop = true;
 
 		// reset any transient state
 		reset_transient_flags(*m_device.machine);
@@ -1845,19 +1856,19 @@
 		debugger_refresh_display(m_device.machine);
 
 		// wait for the debugger; during this time, disable sound output
-		sound_mute(m_device.machine, TRUE);
+		sound_mute(m_device.machine, true);
 		while (global->execution_state == EXECUTION_STATE_STOPPED)
 		{
 			// flush any pending updates before waiting again
 			m_device.machine->m_debug_view->flush_osd_updates();
 
 			// clear the memory modified flag and wait
-			global->memory_modified = FALSE;
+			global->memory_modified = false;
 			if (m_device.machine->debug_flags & DEBUG_FLAG_OSD_ENABLED)
 				osd_wait_for_debugger(&m_device, firststop);
 			else if (m_device.machine->debug_flags & DEBUG_FLAG_ENABLED)
 				debugint_wait_for_debugger(&m_device, firststop);
-			firststop = FALSE;
+			firststop = false;
 
 			// if something modified memory, update the screen
 			if (global->memory_modified)
@@ -1873,7 +1884,7 @@
 			if (m_device.machine->scheduled_event_pending())
 				global->execution_state = EXECUTION_STATE_RUNNING;
 		}
-		sound_mute(m_device.machine, FALSE);
+		sound_mute(m_device.machine, false);
 
 		// remember the last visible CPU in the debugger
 		global->visiblecpu = &m_device;
@@ -1884,7 +1895,7 @@
 		prepare_for_step_overout(pc());
 
 	// no longer in debugger code
-	global->within_instruction_hook = FALSE;
+	global->within_instruction_hook = false;
 }
 
 
@@ -1894,7 +1905,7 @@
 //  memory read happens
 //-------------------------------------------------
 
-void device_debug::memory_read_hook(const address_space &space, offs_t address, UINT64 mem_mask)
+void device_debug::memory_read_hook(address_space &space, offs_t address, UINT64 mem_mask)
 {
 	// check watchpoints
 	watchpoint_check(space, WATCHPOINT_READ, address, 0, mem_mask);
@@ -1911,7 +1922,7 @@
 //  memory write happens
 //-------------------------------------------------
 
-void device_debug::memory_write_hook(const address_space &space, offs_t address, UINT64 data, UINT64 mem_mask)
+void device_debug::memory_write_hook(address_space &space, offs_t address, UINT64 data, UINT64 mem_mask)
 {
 	watchpoint_check(space, WATCHPOINT_WRITE, address, data, mem_mask);
 }
@@ -1955,8 +1966,8 @@
 #ifdef MAME_DEBUG
 if (m_memory != NULL && m_disasm != NULL)
 {
-	const address_space *space = m_memory->space(AS_PROGRAM);
-	int bytes = memory_address_to_byte(space, result & DASMFLAG_LENGTHMASK);
+	address_space *space = m_memory->space(AS_PROGRAM);
+	int bytes = space->address_to_byte(result & DASMFLAG_LENGTHMASK);
 	assert(bytes >= m_disasm->min_opcode_bytes());
 	assert(bytes <= m_disasm->max_opcode_bytes());
 	(void) bytes; // appease compiler
@@ -2068,7 +2079,7 @@
 
 	assert(m_exec != NULL);
 
-	global->vblank_occurred = FALSE;
+	global->vblank_occurred = false;
 	m_flags |= DEBUG_FLAG_STOP_VBLANK;
 	global->execution_state = EXECUTION_STATE_RUNNING;
 }
@@ -2268,16 +2279,16 @@
 //  returning its index
 //-------------------------------------------------
 
-int device_debug::watchpoint_set(const address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action)
+int device_debug::watchpoint_set(address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action)
 {
-	assert(space.spacenum < ARRAY_LENGTH(m_wplist));
+	assert(space.spacenum() < ARRAY_LENGTH(m_wplist));
 
 	// allocate a new one
 	watchpoint *wp = auto_alloc(m_device.machine, watchpoint(m_device.machine->debugcpu_data->bpindex++, space, type, address, length, condition, action));
 
 	// hook it into our list
-	wp->m_next = m_wplist[space.spacenum];
-	m_wplist[space.spacenum] = wp;
+	wp->m_next = m_wplist[space.spacenum()];
+	m_wplist[space.spacenum()] = wp;
 
 	// update the flags and return the index
 	watchpoint_update_flags(wp->m_space);
@@ -2298,7 +2309,7 @@
 			if ((*wp)->m_index == index)
 			{
 				watchpoint *deleteme = *wp;
-				const address_space &space = deleteme->m_space;
+				address_space &space = deleteme->m_space;
 				*wp = deleteme->m_next;
 				auto_free(m_device.machine, deleteme);
 				watchpoint_update_flags(space);
@@ -2546,7 +2557,7 @@
 			global->execution_state = EXECUTION_STATE_STOPPED;
 
 			// if we hit, evaluate the action
-			if (bp->m_action.len() != 0)
+			if (bp->m_action)
 				debug_console_execute_command(m_device.machine, bp->m_action, 0);
 
 			// print a notification, unless the action made us go again
@@ -2562,7 +2573,7 @@
 //  watchpoint flags
 //-------------------------------------------------
 
-void device_debug::watchpoint_update_flags(const address_space &space)
+void device_debug::watchpoint_update_flags(address_space &space)
 {
 	// if hotspots are enabled, turn on all reads
 	bool enableread = false;
@@ -2571,7 +2582,7 @@
 
 	// see if there are any enabled breakpoints
 	bool enablewrite = false;
-	for (watchpoint *wp = m_wplist[space.spacenum]; wp != NULL; wp = wp->m_next)
+	for (watchpoint *wp = m_wplist[space.spacenum()]; wp != NULL; wp = wp->m_next)
 		if (wp->m_enabled)
 		{
 			if (wp->m_type & WATCHPOINT_READ)
@@ -2581,8 +2592,8 @@
 		}
 
 	// push the flags out globally
-	memory_enable_read_watchpoints(&space, enableread);
-	memory_enable_write_watchpoints(&space, enablewrite);
+	space.enable_read_watchpoints(enableread);
+	space.enable_write_watchpoints(enablewrite);
 }
 
 
@@ -2591,20 +2602,20 @@
 //  for a given CPU and address space
 //-------------------------------------------------
 
-void device_debug::watchpoint_check(const address_space &space, int type, offs_t address, UINT64 value_to_write, UINT64 mem_mask)
+void device_debug::watchpoint_check(address_space &space, int type, offs_t address, UINT64 value_to_write, UINT64 mem_mask)
 {
 	debugcpu_private *global = space.machine->debugcpu_data;
 
 	// if we're within debugger code, don't stop
 	if (global->within_instruction_hook || global->debugger_access)
 		return;
-	global->within_instruction_hook = TRUE;
+	global->within_instruction_hook = true;
 
 	// adjust address, size & value_to_write based on mem_mask.
 	offs_t size = 0;
 	if (mem_mask != 0)
 	{
-		int bus_size = space.dbits / 8;
+		int bus_size = space.data_width() / 8;
 		int address_offset = 0;
 
 		while (address_offset < bus_size && (mem_mask & 0xff) == 0)
@@ -2620,7 +2631,7 @@
 			mem_mask >>= 8;
 		}
 
-		if (space.endianness == ENDIANNESS_LITTLE)
+		if (space.endianness() == ENDIANNESS_LITTLE)
 			address += address_offset;
 		else
 			address += bus_size - size - address_offset;
@@ -2632,14 +2643,14 @@
 		global->wpdata = value_to_write;
 
 	// see if we match
-	for (watchpoint *wp = m_wplist[space.spacenum]; wp != NULL; wp = wp->m_next)
+	for (watchpoint *wp = m_wplist[space.spacenum()]; wp != NULL; wp = wp->m_next)
 		if (wp->hit(type, address, size))
 		{
 			// halt in the debugger by default
 			global->execution_state = EXECUTION_STATE_STOPPED;
 
 			// if we hit, evaluate the action
-			if (wp->m_action != NULL)
+			if (wp->m_action)
 				debug_console_execute_command(space.machine, wp->m_action, 0);
 
 			// print a notification, unless the action made us go again
@@ -2654,21 +2665,21 @@
 
 				if (type & WATCHPOINT_WRITE)
 				{
-					buffer.printf("Stopped at watchpoint %X writing %s to %08X (PC=%X)", wp->m_index, sizes[size], memory_byte_to_address(&space, address), pc);
+					buffer.printf("Stopped at watchpoint %X writing %s to %08X (PC=%X)", wp->m_index, sizes[size], space.byte_to_address(address), pc);
 					if (value_to_write >> 32)
 						buffer.catprintf(" (data=%X%08X)", (UINT32)(value_to_write >> 32), (UINT32)value_to_write);
 					else
 						buffer.catprintf(" (data=%X)", (UINT32)value_to_write);
 				}
 				else
-					buffer.printf("Stopped at watchpoint %X reading %s from %08X (PC=%X)", wp->m_index, sizes[size], memory_byte_to_address(&space, address), pc);
+					buffer.printf("Stopped at watchpoint %X reading %s from %08X (PC=%X)", wp->m_index, sizes[size], space.byte_to_address(address), pc);
 				debug_console_printf(space.machine, "%s\n", buffer.cstr());
 				space.cpu->debug()->compute_debug_flags();
 			}
 			break;
 		}
 
-	global->within_instruction_hook = FALSE;
+	global->within_instruction_hook = false;
 }
 
 
@@ -2677,7 +2688,7 @@
 //  memory read access
 //-------------------------------------------------
 
-void device_debug::hotspot_check(const address_space &space, offs_t address)
+void device_debug::hotspot_check(address_space &space, offs_t address)
 {
 	offs_t curpc = pc();
 
@@ -2693,7 +2704,7 @@
 		// if the bottom of the list is over the threshhold, print it
 		hotspot_entry &spot = m_hotspots[m_hotspot_count - 1];
 		if (spot.m_count > m_hotspot_threshhold)
-			debug_console_printf(space.machine, "Hotspot @ %s %08X (PC=%08X) hit %d times (fell off bottom)\n", space.name, spot.m_access, spot.m_pc, spot.m_count);
+			debug_console_printf(space.machine, "Hotspot @ %s %08X (PC=%08X) hit %d times (fell off bottom)\n", space.name(), spot.m_access, spot.m_pc, spot.m_count);
 
 		// move everything else down and insert this one at the top
 		memmove(&m_hotspots[1], &m_hotspots[0], sizeof(m_hotspots[0]) * (m_hotspot_count - 1));
@@ -2728,21 +2739,21 @@
 	assert(m_memory != NULL && m_disasm != NULL);
 
 	// determine the adjusted PC
-	const address_space *space = m_memory->space(AS_PROGRAM);
-	offs_t pcbyte = memory_address_to_byte(space, pc) & space->bytemask;
+	address_space *space = m_memory->space(AS_PROGRAM);
+	offs_t pcbyte = space->address_to_byte(pc) & space->bytemask();
 
 	// fetch the bytes up to the maximum
 	UINT8 opbuf[64], argbuf[64];
 	int maxbytes = max_opcode_bytes();
 	for (int numbytes = 0; numbytes < maxbytes; numbytes++)
 	{
-		opbuf[numbytes] = debug_read_opcode(space, pcbyte + numbytes, 1, FALSE);
-		argbuf[numbytes] = debug_read_opcode(space, pcbyte + numbytes, 1, TRUE);
+		opbuf[numbytes] = debug_read_opcode(space, pcbyte + numbytes, 1, false);
+		argbuf[numbytes] = debug_read_opcode(space, pcbyte + numbytes, 1, true);
 	}
 
 	// disassemble to our buffer
 	buffer.expand(200);
-	return disassemble(buffer, pc, opbuf, argbuf);
+	return disassemble(buffer.text, pc, opbuf, argbuf);
 }
 
 
@@ -2777,8 +2788,8 @@
 
 UINT64 device_debug::get_logunmap(void *globalref, void *ref)
 {
-	const address_space *space = reinterpret_cast<const address_space *>(ref);
-	return memory_get_log_unmap(space);
+	address_space *space = reinterpret_cast<address_space *>(ref);
+	return space->log_unmap();
 }
 
 
@@ -2789,8 +2800,8 @@
 
 void device_debug::set_logunmap(void *globalref, void *ref, UINT64 value)
 {
-	const address_space *space = reinterpret_cast<const address_space *>(ref);
-	memory_set_log_unmap(space, value ? 1 : 0);
+	address_space *space = reinterpret_cast<address_space *>(ref);
+	space->set_log_unmap(value ? true : false);
 }
 
 
@@ -2881,14 +2892,14 @@
 //  watchpoint - constructor
 //-------------------------------------------------
 
-device_debug::watchpoint::watchpoint(int index, const address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action)
+device_debug::watchpoint::watchpoint(int index, address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action)
 	: m_next(NULL),
 	  m_space(space),
 	  m_index(index),
 	  m_enabled(true),
 	  m_type(type),
-	  m_address(memory_address_to_byte(&space, address) & space.bytemask),
-	  m_length(memory_address_to_byte(&space, length)),
+	  m_address(space.address_to_byte(address) & space.bytemask()),
+	  m_length(space.address_to_byte(length)),
 	  m_condition(condition),
 	  m_action((action != NULL) ? action : "")
 {
@@ -3000,7 +3011,7 @@
 	m_loops = 0;
 
 	// execute any trace actions first
-	if (m_action != NULL)
+	if (m_action)
 		debug_console_execute_command(m_debug.m_device.machine, m_action, 0);
 
 	// print the address
diff -Nru src-old/emu/debug/debugcpu.h src/emu/debug/debugcpu.h
--- src-old/emu/debug/debugcpu.h	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/debug/debugcpu.h	2010-08-19 00:26:14.000000000 -0700
@@ -107,12 +107,12 @@
 
 	public:
 		// construction/destruction
-		watchpoint(int index, const address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition = NULL, const char *action = NULL);
+		watchpoint(int index, address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition = NULL, const char *action = NULL);
 		~watchpoint();
 
 		// getters
 		watchpoint *next() const { return m_next; }
-		const address_space &space() const { return m_space; }
+		address_space &space() const { return m_space; }
 		int index() const { return m_index; }
 		int type() const { return m_type; }
 		bool enabled() const { return m_enabled; }
@@ -126,7 +126,7 @@
 		bool hit(int type, offs_t address, int size);
 
 		watchpoint *		m_next;						// next in the list
-		const address_space &m_space;					// address space
+		address_space &m_space;					// address space
 		int					m_index;					// user reported index
 		bool				m_enabled;					// enabled?
 		UINT8				m_type;						// type (read/write)
@@ -146,7 +146,7 @@
 
 	// commonly-used pass-throughs
 	offs_t pc() const { return (m_state != NULL) ? m_state->pc() : 0; }
-	int logaddrchars(int spacenum = AS_PROGRAM) const { return (m_memory != NULL && m_memory->space(spacenum) != NULL) ? m_memory->space(spacenum)->logaddrchars : 8; }
+	int logaddrchars(int spacenum = AS_PROGRAM) const { return (m_memory != NULL && m_memory->space(spacenum) != NULL) ? m_memory->space(spacenum)->logaddrchars() : 8; }
 	int min_opcode_bytes() const { return (m_disasm != NULL) ? m_disasm->max_opcode_bytes() : 1; }
 	int max_opcode_bytes() const { return (m_disasm != NULL) ? m_disasm->max_opcode_bytes() : 1; }
 
@@ -156,8 +156,8 @@
 	void interrupt_hook(int irqline);
 	void exception_hook(int exception);
 	void instruction_hook(offs_t curpc);
-	void memory_read_hook(const address_space &space, offs_t address, UINT64 mem_mask);
-	void memory_write_hook(const address_space &space, offs_t address, UINT64 data, UINT64 mem_mask);
+	void memory_read_hook(address_space &space, offs_t address, UINT64 mem_mask);
+	void memory_write_hook(address_space &space, offs_t address, UINT64 data, UINT64 mem_mask);
 
 	// hooks into our operations
 	void set_instruction_hook(debug_instruction_hook_func hook);
@@ -194,7 +194,7 @@
 
 	// watchpoints
 	watchpoint *watchpoint_first(int spacenum) const { return m_wplist[spacenum]; }
-	int watchpoint_set(const address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action);
+	int watchpoint_set(address_space &space, int type, offs_t address, offs_t length, parsed_expression *condition, const char *action);
 	bool watchpoint_clear(int wpnum);
 	void watchpoint_clear_all();
 	bool watchpoint_enable(int index, bool enable = true);
@@ -225,9 +225,9 @@
 	// breakpoint and watchpoint helpers
 	void breakpoint_update_flags();
 	void breakpoint_check(offs_t pc);
-	void watchpoint_update_flags(const address_space &space);
-	void watchpoint_check(const address_space &space, int type, offs_t address, UINT64 value_to_write, UINT64 mem_mask);
-	void hotspot_check(const address_space &space, offs_t address);
+	void watchpoint_update_flags(address_space &space);
+	void watchpoint_check(address_space &space, int type, offs_t address, UINT64 value_to_write, UINT64 mem_mask);
+	void hotspot_check(address_space &space, offs_t address);
 
 	// symbol get/set callbacks
 	static UINT64 get_current_pc(void *globalref, void *ref);
@@ -304,7 +304,7 @@
 	{
 		offs_t				m_access;					// access address
 		offs_t				m_pc;						// PC of the access
-		const address_space *m_space;					// space where the access occurred
+		address_space *m_space;					// space where the access occurred
 		UINT32				m_count;					// number of hits
 	};
 	hotspot_entry *			m_hotspots;					// hotspot list
@@ -394,40 +394,40 @@
 /* ----- debugger memory accessors ----- */
 
 /* return the physical address corresponding to the given logical address */
-int debug_cpu_translate(const address_space *space, int intention, offs_t *address);
+int debug_cpu_translate(address_space *space, int intention, offs_t *address);
 
 /* return a byte from the the specified memory space */
-UINT8 debug_read_byte(const address_space *space, offs_t address, int apply_translation);
+UINT8 debug_read_byte(address_space *space, offs_t address, int apply_translation);
 
 /* return a word from the the specified memory space */
-UINT16 debug_read_word(const address_space *space, offs_t address, int apply_translation);
+UINT16 debug_read_word(address_space *space, offs_t address, int apply_translation);
 
 /* return a dword from the the specified memory space */
-UINT32 debug_read_dword(const address_space *space, offs_t address, int apply_translation);
+UINT32 debug_read_dword(address_space *space, offs_t address, int apply_translation);
 
 /* return a qword from the the specified memory space */
-UINT64 debug_read_qword(const address_space *space, offs_t address, int apply_translation);
+UINT64 debug_read_qword(address_space *space, offs_t address, int apply_translation);
 
 /* return 1,2,4 or 8 bytes from the specified memory space */
-UINT64 debug_read_memory(const address_space *space, offs_t address, int size, int apply_translation);
+UINT64 debug_read_memory(address_space *space, offs_t address, int size, int apply_translation);
 
 /* write a byte to the specified memory space */
-void debug_write_byte(const address_space *space, offs_t address, UINT8 data, int apply_translation);
+void debug_write_byte(address_space *space, offs_t address, UINT8 data, int apply_translation);
 
 /* write a word to the specified memory space */
-void debug_write_word(const address_space *space, offs_t address, UINT16 data, int apply_translation);
+void debug_write_word(address_space *space, offs_t address, UINT16 data, int apply_translation);
 
 /* write a dword to the specified memory space */
-void debug_write_dword(const address_space *space, offs_t address, UINT32 data, int apply_translation);
+void debug_write_dword(address_space *space, offs_t address, UINT32 data, int apply_translation);
 
 /* write a qword to the specified memory space */
-void debug_write_qword(const address_space *space, offs_t address, UINT64 data, int apply_translation);
+void debug_write_qword(address_space *space, offs_t address, UINT64 data, int apply_translation);
 
 /* write 1,2,4 or 8 bytes to the specified memory space */
-void debug_write_memory(const address_space *space, offs_t address, UINT64 data, int size, int apply_translation);
+void debug_write_memory(address_space *space, offs_t address, UINT64 data, int size, int apply_translation);
 
 /* read 1,2,4 or 8 bytes at the given offset from opcode space */
-UINT64 debug_read_opcode(const address_space *space, offs_t offset, int size, int arg);
+UINT64 debug_read_opcode(address_space *space, offs_t offset, int size, int arg);
 
 
 #endif
diff -Nru src-old/emu/debug/dvdisasm.c src/emu/debug/dvdisasm.c
--- src-old/emu/debug/dvdisasm.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/debug/dvdisasm.c	2010-08-18 23:57:51.000000000 -0700
@@ -203,7 +203,7 @@
 		case DCH_HOME:				// set the active column to the PC
 		{
 			const debug_view_disasm_source &source = downcast<const debug_view_disasm_source &>(*m_source);
-			offs_t pc = memory_address_to_byte(source.m_space, cpu_get_pc(&source.m_device)) & source.m_space->logbytemask;
+			offs_t pc = source.m_space->address_to_byte(cpu_get_pc(&source.m_device)) & source.m_space->logbytemask();
 
 			// figure out which row the pc is on
 			for (int curline = 0; curline < m_allocated.y; curline++)
@@ -242,9 +242,9 @@
 	const debug_view_disasm_source &source = downcast<const debug_view_disasm_source &>(*m_source);
 
 	// compute the increment
-	int minlen = memory_byte_to_address(source.m_space, source.m_disasmintf->min_opcode_bytes());
+	int minlen = source.m_space->byte_to_address(source.m_disasmintf->min_opcode_bytes());
 	if (minlen == 0) minlen = 1;
-	int maxlen = memory_byte_to_address(source.m_space, source.m_disasmintf->max_opcode_bytes());
+	int maxlen = source.m_space->byte_to_address(source.m_disasmintf->max_opcode_bytes());
 	if (maxlen == 0) maxlen = 1;
 
 	// start off numinstrs back
@@ -253,13 +253,13 @@
 		curpc = 0;
 
 	/* loop until we find what we are looking for */
-	offs_t targetpcbyte = memory_address_to_byte(source.m_space, targetpc) & source.m_space->logbytemask;
+	offs_t targetpcbyte = source.m_space->address_to_byte(targetpc) & source.m_space->logbytemask();
 	offs_t fillpcbyte = targetpcbyte;
 	offs_t lastgoodpc = targetpc;
 	while (1)
 	{
 		// fill the buffer up to the target
-		offs_t curpcbyte = memory_address_to_byte(source.m_space, curpc) & source.m_space->logbytemask;
+		offs_t curpcbyte = source.m_space->address_to_byte(curpc) & source.m_space->logbytemask();
 		UINT8 opbuf[1024], argbuf[1024];
 		while (curpcbyte < fillpcbyte)
 		{
@@ -274,7 +274,7 @@
 		offs_t scanpc;
 		for (scanpc = curpc; scanpc < targetpc; scanpc += instlen)
 		{
-			offs_t scanpcbyte = memory_address_to_byte(source.m_space, scanpc) & source.m_space->logbytemask;
+			offs_t scanpcbyte = source.m_space->address_to_byte(scanpc) & source.m_space->logbytemask();
 			offs_t physpcbyte = scanpcbyte;
 
 			// get the disassembly, but only if mapped
@@ -348,7 +348,7 @@
 	const debug_view_disasm_source &source = downcast<const debug_view_disasm_source &>(*m_source);
 
 	// determine how many characters we need for an address and set the divider
-	m_divider1 = 1 + source.m_space->logaddrchars + 1;
+	m_divider1 = 1 + source.m_space->logaddrchars() + 1;
 
 	// assume a fixed number of characters for the disassembly
 	m_divider2 = m_divider1 + 1 + m_dasm_width + 1;
@@ -358,7 +358,7 @@
 	int maxbytes = source.m_disasmintf->max_opcode_bytes();
 
 	// ensure that the PC is aligned to the minimum opcode size
-	pc &= ~memory_byte_to_address_end(source.m_space, minbytes - 1);
+	pc &= ~source.m_space->byte_to_address_end(minbytes - 1);
 
 	// set the width of the third column according to display mode
 	if (m_right_column == DASM_RIGHTCOL_RAW || m_right_column == DASM_RIGHTCOL_ENCRYPTED)
@@ -390,7 +390,7 @@
 	for (int line = 0; line < lines; line++)
 	{
 		// convert PC to a byte offset
-		offs_t pcbyte = memory_address_to_byte(source.m_space, pc) & source.m_space->logbytemask;
+		offs_t pcbyte = source.m_space->address_to_byte(pc) & source.m_space->logbytemask();
 
 		// save a copy of the previous line as a backup if we're only doing one line
 		int instr = startline + line;
@@ -401,7 +401,7 @@
 
 		// convert back and set the address of this instruction
 		m_byteaddress[instr] = pcbyte;
-		sprintf(&destbuf[0], " %s  ", core_i64_hex_format(memory_byte_to_address(source.m_space, pcbyte), source.m_space->logaddrchars));
+		sprintf(&destbuf[0], " %s  ", core_i64_hex_format(source.m_space->byte_to_address(pcbyte), source.m_space->logaddrchars()));
 
 		// make sure we can translate the address, and then disassemble the result
 		char buffer[100];
@@ -419,7 +419,7 @@
 			}
 
 			// disassemble the result
-			pc += numbytes = source.m_disasmintf->disassemble(buffer, pc & source.m_space->logaddrmask, opbuf, argbuf) & DASMFLAG_LENGTHMASK;
+			pc += numbytes = source.m_disasmintf->disassemble(buffer, pc & source.m_space->logaddrmask(), opbuf, argbuf) & DASMFLAG_LENGTHMASK;
 		}
 		else
 			strcpy(buffer, "<unmapped>");
@@ -431,13 +431,13 @@
 		if (m_right_column == DASM_RIGHTCOL_RAW || m_right_column == DASM_RIGHTCOL_ENCRYPTED)
 		{
 			// get the bytes
-			numbytes = memory_address_to_byte(source.m_space, numbytes) & source.m_space->logbytemask;
+			numbytes = source.m_space->address_to_byte(numbytes) & source.m_space->logbytemask();
 			generate_bytes(pcbyte, numbytes, minbytes, &destbuf[m_divider2], m_allocated.x - m_divider2, m_right_column == DASM_RIGHTCOL_ENCRYPTED);
 		}
 		else if (m_right_column == DASM_RIGHTCOL_COMMENTS)
 		{
 			// get and add the comment, if present
-			offs_t comment_address = memory_byte_to_address(source.m_space, m_byteaddress[instr]);
+			offs_t comment_address = source.m_space->byte_to_address(m_byteaddress[instr]);
 			const char *text = debug_comment_get_text(&source.m_device, comment_address, debug_comment_get_opcode_crc32(&source.m_device, comment_address));
 			if (text != NULL)
 				sprintf(&destbuf[m_divider2], "// %.*s", m_allocated.x - m_divider2 - 1, text);
@@ -449,8 +449,8 @@
 	}
 
 	// update opcode base information
-	m_last_direct_decrypted = source.m_space->direct.decrypted;
-	m_last_direct_raw = source.m_space->direct.raw;
+	m_last_direct_decrypted = source.m_space->direct().decrypted();
+	m_last_direct_raw = source.m_space->direct().raw();
 	m_last_change_count = debug_comment_all_change_count(&m_machine);
 
 	// now longer need to recompute
@@ -469,7 +469,7 @@
 	const debug_view_disasm_source &source = downcast<const debug_view_disasm_source &>(*m_source);
 
 	offs_t pc = cpu_get_pc(&source.m_device);
-	offs_t pcbyte = memory_address_to_byte(source.m_space, pc) & source.m_space->logbytemask;
+	offs_t pcbyte = source.m_space->address_to_byte(pc) & source.m_space->logbytemask();
 
 	// update our context; if the expression is dirty, recompute
 	if (m_expression.dirty())
@@ -480,7 +480,7 @@
 	UINT64 result = m_expression.value();
 	if (result != previous)
 	{
-		offs_t resultbyte = memory_address_to_byte(source.m_space, result) & source.m_space->logbytemask;
+		offs_t resultbyte = source.m_space->address_to_byte(result) & source.m_space->logbytemask();
 
 		// see if the new result is an address we already have
 		UINT32 row;
@@ -498,7 +498,7 @@
 	}
 
 	// if the opcode base has changed, rework things
-	if (source.m_space->direct.decrypted != m_last_direct_decrypted || source.m_space->direct.raw != m_last_direct_raw)
+	if (source.m_space->direct().decrypted() != m_last_direct_decrypted || source.m_space->direct().raw() != m_last_direct_raw)
 		m_recompute = true;
 
 	// if the comments have changed, redo it
@@ -517,7 +517,7 @@
 			m_topleft.x = 0;
 
 			// recompute from where we last recomputed!
-			recompute(memory_byte_to_address(source.m_space, m_byteaddress[0]), 0, m_total.y);
+			recompute(source.m_space->byte_to_address(m_byteaddress[0]), 0, m_total.y);
 		}
 		else
 		{
@@ -579,7 +579,7 @@
 			else
 			{
 				for (device_debug::breakpoint *bp = source.m_device.debug()->breakpoint_first(); bp != NULL; bp = bp->next())
-					if (m_byteaddress[effrow] == (memory_address_to_byte(source.m_space, bp->address()) & source.m_space->logbytemask))
+					if (m_byteaddress[effrow] == (source.m_space->address_to_byte(bp->address()) & source.m_space->logbytemask()))
 						attrib = DCA_CHANGED;
 			}
 
@@ -627,7 +627,7 @@
 offs_t debug_view_disasm::selected_address()
 {
 	flush_updates();
-	return memory_byte_to_address(downcast<const debug_view_disasm_source &>(*m_source).m_space, m_byteaddress[m_cursor.y]);
+	return downcast<const debug_view_disasm_source &>(*m_source).m_space->byte_to_address(m_byteaddress[m_cursor.y]);
 }
 
 
@@ -695,7 +695,7 @@
 void debug_view_disasm::set_selected_address(offs_t address)
 {
 	const debug_view_disasm_source &source = downcast<const debug_view_disasm_source &>(*m_source);
-	offs_t byteaddress = memory_address_to_byte(source.m_space, address) & source.m_space->logbytemask;
+	offs_t byteaddress = source.m_space->address_to_byte(address) & source.m_space->logbytemask();
 	for (int line = 0; line < m_total.y; line++)
 		if (m_byteaddress[line] == byteaddress)
 		{
diff -Nru src-old/emu/debug/dvdisasm.h src/emu/debug/dvdisasm.h
--- src-old/emu/debug/dvdisasm.h	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/debug/dvdisasm.h	2010-08-19 00:26:14.000000000 -0700
@@ -73,13 +73,13 @@
 public:
 	// getters
 	device_t &device() const { return m_device; }
-	const address_space *space() const { return m_space; }
+	address_space *space() const { return m_space; }
 
 private:
 	// internal state
 	device_t &			m_device;				// underlying device
 	device_disasm_interface *m_disasmintf;		// disassembly interface
-	const address_space *m_space;				// address space to display
+	address_space *m_space;				// address space to display
 };
 
 
diff -Nru src-old/emu/debug/dvmemory.c src/emu/debug/dvmemory.c
--- src-old/emu/debug/dvmemory.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/debug/dvmemory.c	2010-08-19 00:26:14.000000000 -0700
@@ -72,15 +72,15 @@
 //  debug_view_memory_source - constructors
 //-------------------------------------------------
 
-debug_view_memory_source::debug_view_memory_source(const char *name, const address_space &space)
+debug_view_memory_source::debug_view_memory_source(const char *name, address_space &space)
 	: debug_view_source(name, space.cpu),
 	  m_space(&space),
 	  m_memintf(dynamic_cast<device_memory_interface *>(space.cpu)),
 	  m_base(NULL),
 	  m_length(0),
 	  m_offsetxor(0),
-	  m_endianness(space.endianness),
-	  m_prefsize(space.dbits / 8)
+	  m_endianness(space.endianness()),
+	  m_prefsize(space.data_width() / 8)
 {
 }
 
@@ -156,10 +156,10 @@
 	for (bool gotone = m_machine.m_devicelist.first(memintf); gotone; gotone = memintf->next(memintf))
 		for (int spacenum = 0; spacenum < ADDRESS_SPACES; spacenum++)
 		{
-			const address_space *space = memintf->space(spacenum);
+			address_space *space = memintf->space(spacenum);
 			if (space != NULL)
 			{
-				name.printf("%s '%s' %s space memory", memintf->device().name(), memintf->device().tag(), space->name);
+				name.printf("%s '%s' %s space memory", memintf->device().name(), memintf->device().tag(), space->name());
 				m_source_list.append(*auto_alloc(&m_machine, debug_view_memory_source(name, *space)));
 			}
 		}
@@ -263,7 +263,7 @@
 		if (effrow < m_total.y)
 		{
 			offs_t addrbyte = m_byte_offset + effrow * m_bytes_per_row;
-			offs_t address = (source.m_space != NULL) ? memory_byte_to_address(source.m_space, addrbyte) : addrbyte;
+			offs_t address = (source.m_space != NULL) ? source.m_space->byte_to_address(addrbyte) : addrbyte;
 			char addrtext[20];
 
 			// generate the address
@@ -441,8 +441,8 @@
 	int addrchars;
 	if (source.m_space != NULL)
 	{
-		m_maxaddr = m_no_translation ? source.m_space->bytemask : source.m_space->logbytemask;
-		addrchars = m_no_translation ? source.m_space->addrchars : source.m_space->logaddrchars;
+		m_maxaddr = m_no_translation ? source.m_space->bytemask() : source.m_space->logbytemask();
+		addrchars = m_no_translation ? source.m_space->addrchars() : source.m_space->logaddrchars();
 	}
 	else
 	{
@@ -457,9 +457,9 @@
 		m_addrformat.printf("%%0%dX%*s", addrchars, 8 - addrchars, "");
 
 	// if we are viewing a space with a minimum chunk size, clamp the bytes per chunk
-	if (source.m_space != NULL && source.m_space->ashift < 0)
+	if (source.m_space != NULL && source.m_space->byte_to_address(1) > 1)
 	{
-		UINT32 min_bytes_per_chunk = 1 << -source.m_space->ashift;
+		UINT32 min_bytes_per_chunk = source.m_space->byte_to_address(1);
 		while (m_bytes_per_chunk < min_bytes_per_chunk)
 		{
 			m_bytes_per_chunk *= 2;
@@ -521,7 +521,7 @@
 		const debug_view_memory_source &source = downcast<const debug_view_memory_source &>(*m_source);
 		offs_t resultbyte;
 		if (source.m_space != NULL)
-			resultbyte  = memory_address_to_byte(source.m_space, m_expression.value()) & source.m_space->logbytemask;
+			resultbyte  = source.m_space->address_to_byte(m_expression.value()) & source.m_space->logbytemask();
 		else
 			resultbyte = m_expression.value();
 
@@ -621,7 +621,7 @@
 	{
 		offs_t dummyaddr = offs;
 
-		bool ismapped = m_no_translation ? true : source.m_memintf->translate(source.m_space->spacenum, TRANSLATE_READ_DEBUG, dummyaddr);
+		bool ismapped = m_no_translation ? true : source.m_memintf->translate(source.m_space->spacenum(), TRANSLATE_READ_DEBUG, dummyaddr);
 		data = ~(UINT64)0;
 		if (ismapped)
 		{
diff -Nru src-old/emu/debug/dvmemory.h src/emu/debug/dvmemory.h
--- src-old/emu/debug/dvmemory.h	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/debug/dvmemory.h	2010-08-19 00:26:14.000000000 -0700
@@ -52,15 +52,15 @@
 {
 	friend class debug_view_memory;
 
-	debug_view_memory_source(const char *name, const address_space &space);
+	debug_view_memory_source(const char *name, address_space &space);
 	debug_view_memory_source(const char *name, const region_info &region);
 	debug_view_memory_source(const char *name, void *base, int element_size, int num_elements);
 
 public:
-	const address_space *space() const { return m_space; }
+	address_space *space() const { return m_space; }
 
 private:
-	const address_space *m_space;				// address space we reference (if any)
+	address_space *m_space;				// address space we reference (if any)
 	device_memory_interface *m_memintf;			// pointer to the memory interface of the device
 	void *				m_base;					// pointer to memory base
 	offs_t				m_length;				// length of memory
diff -Nru src-old/emu/debugint/debugint.c src/emu/debugint/debugint.c
--- src-old/emu/debugint/debugint.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/debugint/debugint.c	2010-08-21 12:23:48.000000000 -0700
@@ -492,7 +492,7 @@
 
 	dview_draw_outlined_box(dv, RECT_DVIEW_TITLE, 0, 0, rect_get_width(&dv->bounds), TITLE_HEIGHT, col);
 
-	if (dv->title == NULL)
+	if (!dv->title)
 		return;
 
 	for (i=0; i<strlen(dv->title); i++)
diff -Nru src-old/emu/delegate.c src/emu/delegate.c
--- src-old/emu/delegate.c	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/delegate.c	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,97 @@
+/***************************************************************************
+
+    delegate.c
+
+    Templates and classes to enable delegates for callbacks.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+#include "emucore.h"
+#include "delegate.h"
+
+
+//**************************************************************************
+//  BINDABLE OBJECT
+//**************************************************************************
+
+//-------------------------------------------------
+//  bindable_object - constructor
+//-------------------------------------------------
+
+bindable_object::bindable_object()
+{
+}
+
+
+//-------------------------------------------------
+//  ~bindable_object - destructor
+//-------------------------------------------------
+
+bindable_object::~bindable_object()
+{
+}
+
+
+
+//**************************************************************************
+//  INTERNAL DELEGATE HELPERS
+//**************************************************************************
+
+#if (USE_DELEGATE_TYPE == DELEGATE_TYPE_INTERNAL)
+
+// NULL structure used in dummy constructor
+delegate_gcc_mfp_internal delegate_gcc_mfp_null;
+
+
+//-------------------------------------------------
+//  delegate_convert_raw - given an object and
+//  an raw function, adjust the object base and
+//  return the actual final code pointer
+//-------------------------------------------------
+
+delegate_generic_function delegate_convert_raw(delegate_generic_class *&object, delegate_gcc_mfp_internal &mfp)
+{
+	// apply the "this" delta to the object first
+	object = reinterpret_cast<delegate_generic_class *>(reinterpret_cast<UINT8 *>(object) + mfp.this_delta);
+
+	// if the low bit of the vtable index is clear, then it is just a raw function pointer
+	if (!(mfp.u.vtable_index & 1))
+		return mfp.u.funcptr;
+
+	// otherwise, it is the byte index into the vtable where the actual function lives
+	UINT8 *vtable_base = *reinterpret_cast<UINT8 **>(object);
+	return *reinterpret_cast<delegate_generic_function *>(vtable_base + mfp.u.vtable_index - 1);
+}
+
+#endif
diff -Nru src-old/emu/delegate.h src/emu/delegate.h
--- src-old/emu/delegate.h	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/delegate.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,1209 @@
+/***************************************************************************
+
+    delegate.h
+
+    Templates and classes to enable delegates for callbacks.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+****************************************************************************
+
+    There are many implementations of delegate-like functionality for
+    C++ code, but none of them is a perfect drop-in fit for use in MAME.
+    In order to be useful in MAME, we need the following properties:
+
+        * No significant overhead; we want to use these for memory
+          accessors, and memory accessor overhead is already the dominant
+          performance aspect for most drivers.
+
+        * Existing static functions need to be bound with an additional
+          pointer parameter as the first argument. All existing
+          implementations that allow static function binding assume the
+          same signature as the member functions.
+
+        * We must be able to bind the function separately from the
+          object. This is to allow configurations to bind functions
+          before the objects are created.
+
+    Thus, the implementations below are based on existing works but are
+    really a new implementation that is specific to MAME.
+
+    --------------------------------------------------------------------
+
+    The "compatible" version of delegates is based on an implementation
+    from Sergey Ryazanov, found here:
+
+        http://www.codeproject.com/KB/cpp/ImpossiblyFastCppDelegate.aspx
+
+    These delegates essentially generate a templated static stub function
+    for each target function. The static function takes the first
+    parameter, uses it as the object pointer, and calls through the
+    member function. For static functions, the stub is compatible with
+    the signature of a static function, so we just set the stub directly.
+
+    Pros:
+        * should work with any modern compiler
+        * static bindings are just as fast as direct calls
+
+    Cons:
+        * lots of little stub functions generated
+        * double-hops on member function calls means more overhead
+        * calling through stub functions repackages parameters
+
+    --------------------------------------------------------------------
+
+    The "internal" version of delegates makes use of the internal
+    structure of member function pointers in order to convert them at
+    binding time into simple static function pointers. This only works
+    on platforms where object->func(p1, p2) is equivalent in calling
+    convention to func(object, p1, p2).
+
+    Most of the information on how this works comes from Don Clugston
+    in this article:
+
+        http://www.codeproject.com/KB/cpp/FastDelegate.aspx
+
+    Pros:
+        * as fast as a standard function call in static and member cases
+        * no stub functions or double-hops needed
+
+    Cons:
+        * requires internal knowledge of the member function pointer
+        * only works for GCC (for now; MSVC info is also readily available)
+
+***************************************************************************/
+
+#pragma once
+
+#ifndef __DELEGATE_H__
+#define __DELEGATE_H__
+
+
+//**************************************************************************
+//  MACROS
+//**************************************************************************
+
+// types of delegates supported
+#define DELEGATE_TYPE_COMPATIBLE 0
+#define DELEGATE_TYPE_INTERNAL 1
+
+// select which one we will be using
+#if defined(__GNUC__)
+#define USE_DELEGATE_TYPE DELEGATE_TYPE_INTERNAL
+#else
+#define USE_DELEGATE_TYPE DELEGATE_TYPE_COMPATIBLE
+#endif
+
+// nicer macros to hide the template gobblety-gook and to pass the names
+#define create_member_name(_class, _member, _name)	_create_member<_class, &_class::_member>(_name)
+#define create_member(_class, _member)				_create_member<_class, &_class::_member>(#_class "::" #_member)
+#define create_static(_class, _func)				_crate_static<_class, &_func>(#_func)
+
+
+
+//**************************************************************************
+//  HELPER CLASSES
+//**************************************************************************
+
+// ======================> generic_class
+
+// define a dummy generic class that is just straight single-inheritance
+#ifdef _MSC_VER
+class __single_inheritance generic_class;
+class delegate_generic_class { };
+#else
+class delegate_generic_class;
+#endif
+
+
+// ======================> bindable_object
+
+// define a bindable_object base class that must be at the root of any object
+// hierarchy which intends to do late binding
+class bindable_object
+{
+public:
+	// virtual destructor to ensure this is a polymorphic class
+	bindable_object();
+	virtual ~bindable_object();
+};
+
+// define a deferred cast helper function that does a proper dynamic_cast
+// from a bindable_object to the target class, and returns a delegate_generic_class
+template<class _TargetClass>
+static delegate_generic_class *deferred_cast(bindable_object &object)
+{
+	return reinterpret_cast<delegate_generic_class *>(dynamic_cast<_TargetClass *>(&object));
+}
+
+// we store pointers to these deferred casting helpers, so make a friendly type for it
+typedef delegate_generic_class *(*deferred_cast_func)(bindable_object &object);
+
+
+// ======================> delegate_base
+
+// simple base class for all delegates to derive from; it is explicitly
+// polymorphic so that a delegate_base * can be used as a lowest-common
+// denominator, and then downcast to the appropriate type with proper
+// type checking
+class delegate_base
+{
+public:
+	delegate_base(deferred_cast_func caster, const char *name)
+		: m_caster(caster),
+		  m_name(name) { }
+
+	virtual ~delegate_base() { }
+
+	// getters
+	bool isnull() const { return (m_caster == NULL); }
+	bool valid_target(bindable_object &object) const { return ((*m_caster)(object) != NULL); }
+	const char *name() const { return m_name; }
+
+protected:
+	deferred_cast_func		m_caster;			// pointer to helper function that does the cast
+	const char *			m_name;				// name string
+};
+
+
+
+//**************************************************************************
+//  COMPATIBLE DELEGATES
+//**************************************************************************
+
+#if (USE_DELEGATE_TYPE == DELEGATE_TYPE_COMPATIBLE)
+
+// ======================> proto_delegate_0param
+
+template<typename _ReturnType>
+class proto_delegate_0param : public delegate_base
+{
+protected:
+	// pointer to a static version of the function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *);
+
+public:
+	// constructors
+	proto_delegate_0param(static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function) { }
+
+	proto_delegate_0param(const proto_delegate_0param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)()>
+	static proto_delegate_0param _create_member(const char *name = NULL)
+	{
+		return proto_delegate_0param(&method_stub<_FunctionClass, _FunctionPtr>, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *)>
+	static proto_delegate_0param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_0param(reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_0param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster);
+	}
+
+protected:
+	// helper stub that calls the member function
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)()>
+    static _ReturnType method_stub(delegate_generic_class *object_ptr)
+    {
+        _FunctionClass *p = reinterpret_cast<_FunctionClass *>(object_ptr);
+        return (p->*_FunctionPtr)();
+    }
+
+	// internal state
+	static_func 			m_function;			// pointer to the stub or static function
+};
+
+
+// ======================> delegate_0param
+
+template<typename _ReturnType>
+class delegate_0param : public proto_delegate_0param<_ReturnType>
+{
+	typedef proto_delegate_0param<_ReturnType> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+
+public:
+	// constructors
+	delegate_0param()
+		: m_object(NULL) { }
+
+	delegate_0param(proto_base proto)
+		: proto_delegate_0param<_ReturnType>(proto),
+		  m_object(NULL) { }
+
+	delegate_0param(proto_base proto, bindable_object &object)
+		: proto_delegate_0param<_ReturnType>(proto),
+		  m_object((*m_caster)(object)) { }
+
+	// bind the actual object
+	void bind(bindable_object &object) { m_object = (*m_caster)(object); }
+
+	// call the function
+	_ReturnType operator()() const { return (*m_function)(m_object); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_0param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_1param
+
+template<typename _ReturnType, typename _P1Type>
+class proto_delegate_1param : public delegate_base
+{
+protected:
+	// pointer to a static version of the function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type);
+
+public:
+	// constructors
+	proto_delegate_1param(static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function) { }
+
+	proto_delegate_1param(const proto_delegate_1param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type)>
+	static proto_delegate_1param _create_member(const char *name = NULL)
+	{
+		return proto_delegate_1param(&method_stub<_FunctionClass, _FunctionPtr>, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type)>
+	static proto_delegate_1param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_1param(reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_1param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster);
+	}
+
+protected:
+	// helper stub that calls the member function
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type)>
+    static _ReturnType method_stub(delegate_generic_class *object_ptr, _P1Type p1)
+    {
+        _FunctionClass *p = reinterpret_cast<_FunctionClass *>(object_ptr);
+        return (p->*_FunctionPtr)(p1);
+    }
+
+	// internal state
+	static_func 			m_function;			// pointer to the stub or static function
+};
+
+
+// ======================> delegate_1param
+
+template<typename _ReturnType, typename _P1Type>
+class delegate_1param : public proto_delegate_1param<_ReturnType, _P1Type>
+{
+	typedef proto_delegate_1param<_ReturnType, _P1Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+
+public:
+	// constructors
+	delegate_1param()
+		: m_object(NULL) { }
+
+	delegate_1param(proto_delegate_1param<_ReturnType, _P1Type> proto)
+		: proto_delegate_1param<_ReturnType, _P1Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_1param(proto_delegate_1param<_ReturnType, _P1Type> proto, bindable_object &object)
+		: proto_delegate_1param<_ReturnType, _P1Type>(proto),
+		  m_object((*m_caster)(object)) { }
+
+	// bind the actual object
+	void bind(bindable_object &object) { m_object = (*m_caster)(object); }
+
+	// call the function
+	_ReturnType operator()(_P1Type p1) const { return (*m_function)(m_object, p1); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_1param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_2param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type>
+class proto_delegate_2param : public delegate_base
+{
+protected:
+	// pointer to a static version of the function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type);
+
+public:
+	// constructors
+	proto_delegate_2param(static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function) { }
+
+	proto_delegate_2param(const proto_delegate_2param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type)>
+	static proto_delegate_2param _create_member(const char *name = NULL)
+	{
+		return proto_delegate_2param(&method_stub<_FunctionClass, _FunctionPtr>, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type)>
+	static proto_delegate_2param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_2param(reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_2param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster);
+	}
+
+protected:
+	// helper stub that calls the member function
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type)>
+    static _ReturnType method_stub(delegate_generic_class *object_ptr, _P1Type p1, _P2Type p2)
+    {
+        _FunctionClass *p = reinterpret_cast<_FunctionClass *>(object_ptr);
+        return (p->*_FunctionPtr)(p1, p2);
+    }
+
+	// internal state
+	static_func 			m_function;			// pointer to the stub or static function
+};
+
+
+// ======================> delegate_2param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type>
+class delegate_2param : public proto_delegate_2param<_ReturnType, _P1Type, _P2Type>
+{
+	typedef proto_delegate_2param<_ReturnType, _P1Type, _P2Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+
+public:
+	// constructors
+	delegate_2param()
+		: m_object(NULL) { }
+
+	delegate_2param(proto_delegate_2param<_ReturnType, _P1Type, _P2Type> proto)
+		: proto_delegate_2param<_ReturnType, _P1Type, _P2Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_2param(proto_delegate_2param<_ReturnType, _P1Type, _P2Type> proto, bindable_object &object)
+		: proto_delegate_2param<_ReturnType, _P1Type, _P2Type>(proto),
+		  m_object((*m_caster)(object)) { }
+
+	// bind the actual object
+	void bind(bindable_object &object) { m_object = (*m_caster)(object); }
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2) const { return (*m_function)(m_object, p1, p2); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_2param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_3param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type>
+class proto_delegate_3param : public delegate_base
+{
+protected:
+	// pointer to a static version of the function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type);
+
+public:
+	// constructors
+	proto_delegate_3param(static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function) { }
+
+	proto_delegate_3param(const proto_delegate_3param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type)>
+	static proto_delegate_3param _create_member(const char *name = NULL)
+	{
+		return proto_delegate_3param(&method_stub<_FunctionClass, _FunctionPtr>, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type, _P3Type)>
+	static proto_delegate_3param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_3param(reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_3param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster);
+	}
+
+protected:
+	// helper stub that calls the member function
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type)>
+    static _ReturnType method_stub(delegate_generic_class *object_ptr, _P1Type p1, _P2Type p2, _P3Type p3)
+    {
+        _FunctionClass *p = reinterpret_cast<_FunctionClass *>(object_ptr);
+        return (p->*_FunctionPtr)(p1, p2, p3);
+    }
+
+	// internal state
+	static_func 			m_function;			// pointer to the stub or static function
+};
+
+
+// ======================> delegate_3param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type>
+class delegate_3param : public proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>
+{
+	typedef proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+
+public:
+	// constructors
+	delegate_3param()
+		: m_object(NULL) { }
+
+	delegate_3param(proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type> proto)
+		: proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_3param(proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type> proto, bindable_object &object)
+		: proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>(proto),
+		  m_object((*m_caster)(object)) { }
+
+	// bind the actual object
+	void bind(bindable_object &object) { m_object = (*m_caster)(object); }
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2, _P3Type p3) const { return (*m_function)(m_object, p1, p2, p3); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_3param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_4param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type, typename _P4Type>
+class proto_delegate_4param : public delegate_base
+{
+protected:
+	// pointer to a static version of the function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type, _P4Type);
+
+public:
+	// constructors
+	proto_delegate_4param(static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function) { }
+
+	proto_delegate_4param(const proto_delegate_4param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type, _P4Type)>
+	static proto_delegate_4param _create_member(const char *name = NULL)
+	{
+		return proto_delegate_4param(&method_stub<_FunctionClass, _FunctionPtr>, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type, _P3Type, _P4Type)>
+	static proto_delegate_4param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_4param(reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_4param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster);
+	}
+
+protected:
+	// helper stub that calls the member function
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type, _P4Type)>
+    static _ReturnType method_stub(delegate_generic_class *object_ptr, _P1Type p1, _P2Type p2, _P3Type p3, _P4Type p4)
+    {
+        _FunctionClass *p = reinterpret_cast<_FunctionClass *>(object_ptr);
+        return (p->*_FunctionPtr)(p1, p2, p3, p4);
+    }
+
+	// internal state
+	static_func 			m_function;			// pointer to the stub or static function
+};
+
+
+// ======================> delegate_4param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type, typename _P4Type>
+class delegate_4param : public proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>
+{
+	typedef proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+
+public:
+	// constructors
+	delegate_4param()
+		: m_object(NULL) { }
+
+	delegate_4param(proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type> proto)
+		: proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_4param(proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type> proto, bindable_object &object)
+		: proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>(proto),
+		  m_object((*m_caster)(object)) { }
+
+	// bind the actual object
+	void bind(bindable_object &object) { m_object = (*m_caster)(object); }
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2, _P3Type p3, _P4Type p4) const { return (*m_function)(m_object, p1, p2, p3, p4); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_4param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+#endif
+
+
+//**************************************************************************
+//  GCC DELEGATES
+//**************************************************************************
+
+#if (USE_DELEGATE_TYPE == DELEGATE_TYPE_INTERNAL)
+
+// a generic function pointer type and a generic member function pointer type
+typedef void (*delegate_generic_function)();
+
+// struct describing the contents of a member function pointer
+struct delegate_gcc_mfp_internal
+{
+	union										// first item can be one of two things:
+	{
+		delegate_generic_function funcptr;		// if even, it's a pointer to the function
+		FPTR				vtable_index;		// if odd, it's the byte offset into the vtable
+	} u;
+	int 					this_delta;			// delta to apply to the 'this' pointer
+};
+
+// helper function
+delegate_generic_function delegate_convert_raw(delegate_generic_class *&object, delegate_gcc_mfp_internal &mfp);
+
+// global dummy extern
+extern delegate_gcc_mfp_internal delegate_gcc_mfp_null;
+
+
+// ======================> proto_delegate_0param
+
+template<typename _ReturnType>
+class proto_delegate_0param : public delegate_base
+{
+protected:
+	// pointer to a static function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *);
+
+public:
+	// constructors
+	proto_delegate_0param(delegate_gcc_mfp_internal &mfp = delegate_gcc_mfp_null, static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function),
+		  m_rawfunction(mfp) { }
+
+	proto_delegate_0param(const proto_delegate_0param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function),
+		  m_rawfunction(proto.m_rawfunction) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)()>
+	static proto_delegate_0param _create_member(const char *name = NULL)
+	{
+		union
+		{
+			_ReturnType (_FunctionClass::*mfp)();
+			delegate_gcc_mfp_internal	internal;
+		} tempunion;
+		tempunion.mfp = _FunctionPtr;
+		return proto_delegate_0param(tempunion.internal, NULL, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *)>
+	static proto_delegate_0param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_0param(delegate_gcc_mfp_null, reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_0param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster &&
+				m_rawfunction.u.funcptr == rhs.m_rawfunction.u.funcptr &&
+				m_rawfunction.this_delta == rhs.m_rawfunction.this_delta);
+	}
+
+protected:
+	// internal state
+	static_func					m_function;			// generic static function pointer
+	delegate_gcc_mfp_internal	m_rawfunction;		// raw member function definition
+};
+
+
+// ======================> delegate_0param
+
+template<typename _ReturnType>
+class delegate_0param : public proto_delegate_0param<_ReturnType>
+{
+	typedef _ReturnType (*static_func)(delegate_generic_class *);
+	typedef proto_delegate_0param<_ReturnType> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+	using proto_base::m_rawfunction;
+
+public:
+	// constructors
+	delegate_0param()
+		: m_object(NULL) { }
+
+	delegate_0param(proto_base proto)
+		: proto_delegate_0param<_ReturnType>(proto),
+		  m_object(NULL) { }
+
+	delegate_0param(proto_base proto, bindable_object &object)
+		: proto_delegate_0param<_ReturnType>(proto),
+		  m_object(NULL) { bind(object); }
+
+	// bind the actual object
+	void bind(bindable_object &object)
+	{
+		m_object = (*m_caster)(object);
+		if (m_rawfunction.u.funcptr != NULL)
+			m_function = reinterpret_cast<static_func>(delegate_convert_raw(m_object, m_rawfunction));
+	}
+
+	// call the function
+	_ReturnType operator()() const { return (*m_function)(m_object); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_0param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_1param
+
+template<typename _ReturnType, typename _P1Type>
+class proto_delegate_1param : public delegate_base
+{
+protected:
+	// pointer to a static function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type);
+
+public:
+	// constructors
+	proto_delegate_1param(delegate_gcc_mfp_internal &mfp = delegate_gcc_mfp_null, static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function),
+		  m_rawfunction(mfp) { }
+
+	proto_delegate_1param(const proto_delegate_1param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function),
+		  m_rawfunction(proto.m_rawfunction) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type)>
+	static proto_delegate_1param _create_member(const char *name = NULL)
+	{
+		union
+		{
+			_ReturnType (_FunctionClass::*mfp)(_P1Type);
+			delegate_gcc_mfp_internal	internal;
+		} tempunion;
+		tempunion.mfp = _FunctionPtr;
+		return proto_delegate_1param(tempunion.internal, NULL, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type)>
+	static proto_delegate_1param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_1param(delegate_gcc_mfp_null, reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_1param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster &&
+				m_rawfunction.u.funcptr == rhs.m_rawfunction.u.funcptr &&
+				m_rawfunction.this_delta == rhs.m_rawfunction.this_delta);
+	}
+
+protected:
+	// internal state
+	static_func					m_function;			// generic static function pointer
+	delegate_gcc_mfp_internal	m_rawfunction;		// raw member function definition
+};
+
+
+// ======================> delegate_1param
+
+template<typename _ReturnType, typename _P1Type>
+class delegate_1param : public proto_delegate_1param<_ReturnType, _P1Type>
+{
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type);
+	typedef proto_delegate_1param<_ReturnType, _P1Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+	using proto_base::m_rawfunction;
+
+public:
+	// constructors
+	delegate_1param()
+		: m_object(NULL) { }
+
+	delegate_1param(proto_base proto)
+		: proto_delegate_1param<_ReturnType, _P1Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_1param(proto_base proto, bindable_object &object)
+		: proto_delegate_1param<_ReturnType, _P1Type>(proto),
+		  m_object(NULL) { bind(object); }
+
+	// bind the actual object
+	void bind(bindable_object &object)
+	{
+		m_object = (*m_caster)(object);
+		if (m_rawfunction.u.funcptr != NULL)
+			m_function = reinterpret_cast<static_func>(delegate_convert_raw(m_object, m_rawfunction));
+	}
+
+	// call the function
+	_ReturnType operator()(_P1Type p1) const { return (*m_function)(m_object, p1); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_1param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_2param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type>
+class proto_delegate_2param : public delegate_base
+{
+protected:
+	// pointer to a static function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type);
+
+public:
+	// constructors
+	proto_delegate_2param(delegate_gcc_mfp_internal &mfp = delegate_gcc_mfp_null, static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function),
+		  m_rawfunction(mfp) { }
+
+	proto_delegate_2param(const proto_delegate_2param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function),
+		  m_rawfunction(proto.m_rawfunction) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type)>
+	static proto_delegate_2param _create_member(const char *name = NULL)
+	{
+		union
+		{
+			_ReturnType (_FunctionClass::*mfp)(_P1Type, _P2Type);
+			delegate_gcc_mfp_internal	internal;
+		} tempunion;
+		tempunion.mfp = _FunctionPtr;
+		return proto_delegate_2param(tempunion.internal, NULL, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type)>
+	static proto_delegate_2param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_2param(delegate_gcc_mfp_null, reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_2param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster &&
+				m_rawfunction.u.funcptr == rhs.m_rawfunction.u.funcptr &&
+				m_rawfunction.this_delta == rhs.m_rawfunction.this_delta);
+	}
+
+protected:
+	// internal state
+	static_func					m_function;			// generic static function pointer
+	delegate_gcc_mfp_internal	m_rawfunction;		// raw member function definition
+};
+
+
+// ======================> delegate_2param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type>
+class delegate_2param : public proto_delegate_2param<_ReturnType, _P1Type, _P2Type>
+{
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type);
+	typedef proto_delegate_2param<_ReturnType, _P1Type, _P2Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+	using proto_base::m_rawfunction;
+
+public:
+	// constructors
+	delegate_2param()
+		: m_object(NULL) { }
+
+	delegate_2param(proto_base proto)
+		: proto_delegate_2param<_ReturnType, _P1Type, _P2Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_2param(proto_base proto, bindable_object &object)
+		: proto_delegate_2param<_ReturnType, _P1Type, _P2Type>(proto),
+		  m_object(NULL) { bind(object); }
+
+	// bind the actual object
+	void bind(bindable_object &object)
+	{
+		m_object = (*m_caster)(object);
+		if (m_rawfunction.u.funcptr != NULL)
+			m_function = reinterpret_cast<static_func>(delegate_convert_raw(m_object, m_rawfunction));
+	}
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2) const { return (*m_function)(m_object, p1, p2); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_2param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_3param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type>
+class proto_delegate_3param : public delegate_base
+{
+protected:
+	// pointer to a static function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type);
+
+public:
+	// constructors
+	proto_delegate_3param(delegate_gcc_mfp_internal &mfp = delegate_gcc_mfp_null, static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function),
+		  m_rawfunction(mfp) { }
+
+	proto_delegate_3param(const proto_delegate_3param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function),
+		  m_rawfunction(proto.m_rawfunction) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type)>
+	static proto_delegate_3param _create_member(const char *name = NULL)
+	{
+		union
+		{
+			_ReturnType (_FunctionClass::*mfp)(_P1Type, _P2Type, _P3Type);
+			delegate_gcc_mfp_internal	internal;
+		} tempunion;
+		tempunion.mfp = _FunctionPtr;
+		return proto_delegate_3param(tempunion.internal, NULL, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type, _P3Type)>
+	static proto_delegate_3param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_3param(delegate_gcc_mfp_null, reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_3param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster &&
+				m_rawfunction.u.funcptr == rhs.m_rawfunction.u.funcptr &&
+				m_rawfunction.this_delta == rhs.m_rawfunction.this_delta);
+	}
+
+protected:
+	// internal state
+	static_func					m_function;			// generic static function pointer
+	delegate_gcc_mfp_internal	m_rawfunction;		// raw member function definition
+};
+
+
+// ======================> delegate_3param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type>
+class delegate_3param : public proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>
+{
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type);
+	typedef proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+	using proto_base::m_rawfunction;
+
+public:
+	// constructors
+	delegate_3param()
+		: m_object(NULL) { }
+
+	delegate_3param(proto_base proto)
+		: proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_3param(proto_base proto, bindable_object &object)
+		: proto_delegate_3param<_ReturnType, _P1Type, _P2Type, _P3Type>(proto),
+		  m_object(NULL) { bind(object); }
+
+	// bind the actual object
+	void bind(bindable_object &object)
+	{
+		m_object = (*m_caster)(object);
+		if (m_rawfunction.u.funcptr != NULL)
+			m_function = reinterpret_cast<static_func>(delegate_convert_raw(m_object, m_rawfunction));
+	}
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2, _P3Type p3) const { return (*m_function)(m_object, p1, p2, p3); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_3param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+// ======================> proto_delegate_4param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type, typename _P4Type>
+class proto_delegate_4param : public delegate_base
+{
+protected:
+	// pointer to a static function which takes the object as a first parameter
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type, _P4Type);
+
+public:
+	// constructors
+	proto_delegate_4param(delegate_gcc_mfp_internal &mfp = delegate_gcc_mfp_null, static_func function = NULL, deferred_cast_func caster = NULL, const char *name = NULL)
+		: delegate_base(caster, name),
+		  m_function(function),
+		  m_rawfunction(mfp) { }
+
+	proto_delegate_4param(const proto_delegate_4param &proto)
+		: delegate_base(proto.m_caster, proto.m_name),
+		  m_function(proto.m_function),
+		  m_rawfunction(proto.m_rawfunction) { }
+
+	// create a member function proto-delegate
+	template<class _FunctionClass, _ReturnType (_FunctionClass::*_FunctionPtr)(_P1Type, _P2Type, _P3Type, _P4Type)>
+	static proto_delegate_4param _create_member(const char *name = NULL)
+	{
+		union
+		{
+			_ReturnType (_FunctionClass::*mfp)(_P1Type, _P2Type, _P3Type, _P4Type);
+			delegate_gcc_mfp_internal	internal;
+		} tempunion;
+		tempunion.mfp = _FunctionPtr;
+		return proto_delegate_4param(tempunion.internal, NULL, &deferred_cast<_FunctionClass>, name);
+	}
+
+	// create a static function proto-delegate
+	template<class _FunctionClass, _ReturnType (*_FunctionPtr)(_FunctionClass *, _P1Type, _P2Type, _P3Type, _P4Type)>
+	static proto_delegate_4param _create_static(const char *name = NULL)
+	{
+		return proto_delegate_4param(delegate_gcc_mfp_null, reinterpret_cast<static_func>(_FunctionPtr), &deferred_cast<_FunctionClass>, name);
+	}
+
+	// equality testing
+	bool operator==(const proto_delegate_4param &rhs) const
+	{
+		return (m_function == rhs.m_function && m_caster == rhs.m_caster &&
+				m_rawfunction.u.funcptr == rhs.m_rawfunction.u.funcptr &&
+				m_rawfunction.this_delta == rhs.m_rawfunction.this_delta);
+	}
+
+protected:
+	// internal state
+	static_func					m_function;			// generic static function pointer
+	delegate_gcc_mfp_internal	m_rawfunction;		// raw member function definition
+};
+
+
+// ======================> delegate_4param
+
+template<typename _ReturnType, typename _P1Type, typename _P2Type, typename _P3Type, typename _P4Type>
+class delegate_4param : public proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>
+{
+	typedef _ReturnType (*static_func)(delegate_generic_class *, _P1Type, _P2Type, _P3Type, _P4Type);
+	typedef proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type> proto_base;
+
+	using delegate_base::m_caster;
+	using proto_base::m_function;
+	using proto_base::m_rawfunction;
+
+public:
+	// constructors
+	delegate_4param()
+		: m_object(NULL) { }
+
+	delegate_4param(proto_base proto)
+		: proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>(proto),
+		  m_object(NULL) { }
+
+	delegate_4param(proto_base proto, bindable_object &object)
+		: proto_delegate_4param<_ReturnType, _P1Type, _P2Type, _P3Type, _P4Type>(proto),
+		  m_object(NULL) { bind(object); }
+
+	// bind the actual object
+	void bind(bindable_object &object)
+	{
+		m_object = (*m_caster)(object);
+		if (m_rawfunction.u.funcptr != NULL)
+			m_function = reinterpret_cast<static_func>(delegate_convert_raw(m_object, m_rawfunction));
+	}
+
+	// call the function
+	_ReturnType operator()(_P1Type p1, _P2Type p2, _P3Type p3, _P4Type p4) const { return (*m_function)(m_object, p1, p2, p3, p4); }
+
+	// testing
+	bool has_object() const { return (m_object != NULL); }
+	bool operator==(const delegate_4param &rhs) const { return (m_object == rhs.m_object && proto_base::operator==(rhs)); }
+
+protected:
+	// internal state
+	delegate_generic_class *m_object;			// pointer to the post-cast object
+};
+
+
+
+#endif
+
+
+#endif	/* __DELEGATE_H__ */
diff -Nru src-old/emu/deprecat.h src/emu/deprecat.h
--- src-old/emu/deprecat.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/deprecat.h	2010-08-26 08:21:19.000000000 -0700
@@ -31,9 +31,7 @@
  *************************************/
 
 #define MDRV_CPU_VBLANK_INT_HACK(_func, _rate) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_DIEXEC_VBLANK_INT, 8, _rate, 24), \
-	TOKEN_PTR(cpu_interrupt, _func), \
-	TOKEN_PTR(stringptr, NULL), \
+	device_config_execute_interface::static_set_vblank_int(device, _func, NULL, _rate); \
 
 
 
diff -Nru src-old/emu/devcpu.c src/emu/devcpu.c
--- src-old/emu/devcpu.c	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/devcpu.c	2010-08-26 09:00:27.000000000 -0700
@@ -78,6 +78,8 @@
 		m_space_config[spacenum].m_addrbus_width = get_legacy_config_int(DEVINFO_INT_ADDRBUS_WIDTH + spacenum);
 		m_space_config[spacenum].m_addrbus_shift = get_legacy_config_int(DEVINFO_INT_ADDRBUS_SHIFT + spacenum);
 		m_space_config[spacenum].m_logaddr_width = get_legacy_config_int(CPUINFO_INT_LOGADDR_WIDTH + spacenum);
+		if (m_space_config[spacenum].m_logaddr_width == 0)
+			m_space_config[spacenum].m_logaddr_width = m_space_config[spacenum].m_addrbus_width;
 		m_space_config[spacenum].m_page_shift = get_legacy_config_int(CPUINFO_INT_PAGE_SHIFT + spacenum);
 		m_space_config[spacenum].m_internal_map = reinterpret_cast<address_map_constructor>(get_legacy_config_fct(DEVINFO_PTR_INTERNAL_MEMORY_MAP + spacenum));
 		m_space_config[spacenum].m_default_map = reinterpret_cast<address_map_constructor>(get_legacy_config_fct(DEVINFO_PTR_DEFAULT_MEMORY_MAP + spacenum));
@@ -223,7 +225,8 @@
 	  m_state_export(reinterpret_cast<cpu_state_io_func>(m_cpu_config.get_legacy_config_fct(CPUINFO_FCT_EXPORT_STATE))),
 	  m_string_export(reinterpret_cast<cpu_string_io_func>(m_cpu_config.get_legacy_config_fct(CPUINFO_FCT_EXPORT_STRING))),
 	  m_exit(reinterpret_cast<cpu_exit_func>(m_cpu_config.get_legacy_config_fct(CPUINFO_FCT_EXIT))),
-	  m_using_legacy_state(false)
+	  m_using_legacy_state(false),
+	  m_inited(false)
 {
 	memset(&m_partial_frame_period, 0, sizeof(m_partial_frame_period));
 
@@ -243,7 +246,7 @@
 legacy_cpu_device::~legacy_cpu_device()
 {
 	// call the CPU's exit function if present
-	if (m_exit != NULL)
+	if (m_inited && m_exit != NULL)
 		(*m_exit)(this);
 }
 
@@ -257,6 +260,7 @@
 	// standard init
 	cpu_init_func init = reinterpret_cast<cpu_init_func>(m_cpu_config.get_legacy_config_fct(CPUINFO_FCT_INIT));
 	(*init)(this, static_standard_irq_callback);
+	m_inited = true;
 
 	// fetch information about the CPU states
 	if (m_state_list == NULL)
diff -Nru src-old/emu/devcpu.h src/emu/devcpu.h
--- src-old/emu/devcpu.h	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/devcpu.h	2010-08-26 09:00:27.000000000 -0700
@@ -420,7 +420,7 @@
 public:
 	// basic information getters
 	virtual const rom_entry *rom_region() const { return reinterpret_cast<const rom_entry *>(get_legacy_config_ptr(DEVINFO_PTR_ROM_REGION)); }
-	virtual const machine_config_token *machine_config_tokens() const { return reinterpret_cast<const machine_config_token *>(get_legacy_config_ptr(DEVINFO_PTR_MACHINE_CONFIG)); }
+	virtual machine_config_constructor machine_config_additions() const { return reinterpret_cast<machine_config_constructor>(get_legacy_config_ptr(DEVINFO_PTR_MACHINE_CONFIG)); }
 
 protected:
 	// device_config_execute_interface overrides
@@ -536,6 +536,7 @@
 
 	UINT64					m_state_io;					// temporary buffer for state I/O
 	bool					m_using_legacy_state;		// true if we are using the old-style state access
+	bool					m_inited;
 };
 
 
diff -Nru src-old/emu/devintrf.c src/emu/devintrf.c
--- src-old/emu/devintrf.c	2010-08-02 01:40:01.000000000 -0700
+++ src/emu/devintrf.c	2010-08-30 08:20:58.000000000 -0700
@@ -273,17 +273,6 @@
 
 
 //-------------------------------------------------
-//  interface_process_token - default token
-//  processing for a given interface
-//-------------------------------------------------
-
-bool device_config_interface::interface_process_token(UINT32 entrytype, const machine_config_token *&tokens)
-{
-	return false;
-}
-
-
-//-------------------------------------------------
 //  interface_validity_check - default validation
 //  for a device after the configuration has been
 //  constructed
@@ -317,8 +306,6 @@
 	  m_tag(tag),
 	  m_config_complete(false)
 {
-	memset(m_inline_data, 0, sizeof(m_inline_data));
-
 	// derive the clock from our owner if requested
 	if ((m_clock & 0xff000000) == 0xff000000)
 	{
@@ -354,124 +341,6 @@
 
 
 //-------------------------------------------------
-//  process_token - process tokens
-//-------------------------------------------------
-
-void device_config::process_token(UINT32 entrytype, const machine_config_token *&tokens)
-{
-	int size, offset, bits, index;
-	UINT32 data32;
-	UINT64 data64;
-	bool processed = false;
-
-	// first process stuff we know about
-	switch (entrytype)
-	{
-		// specify device clock
-		case MCONFIG_TOKEN_DEVICE_CLOCK:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, m_clock, 32);
-			processed = true;
-			break;
-
-		// specify pointer to static device configuration
-		case MCONFIG_TOKEN_DEVICE_CONFIG:
-			m_static_config = TOKEN_GET_PTR(tokens, voidptr);
-			processed = true;
-			break;
-
-		// provide inline device data packed into a 16-bit space
-		case MCONFIG_TOKEN_DEVICE_INLINE_DATA16:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK3(tokens, entrytype, 8, index, 8, data32, 16);
-			assert(index >= 0 && index < ARRAY_LENGTH(m_inline_data));
-			m_inline_data[index] = data32;
-			processed = true;
-			break;
-
-		// provide inline device data packed into a 32-bit space
-		case MCONFIG_TOKEN_DEVICE_INLINE_DATA32:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, index, 8);
-			assert(index >= 0 && index < ARRAY_LENGTH(m_inline_data));
-			m_inline_data[index] = TOKEN_GET_UINT32(tokens);
-			processed = true;
-			break;
-
-		// provide inline device data packed into a 64-bit space
-		case MCONFIG_TOKEN_DEVICE_INLINE_DATA64:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, index, 8);
-			assert(index >= 0 && index < ARRAY_LENGTH(m_inline_data));
-			TOKEN_EXTRACT_UINT64(tokens, m_inline_data[index]);
-			processed = true;
-			break;
-
-		// provide inline device data packed into a 32-bit word
-		case MCONFIG_TOKEN_DEVICE_CONFIG_DATA32:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK3(tokens, entrytype, 8, size, 4, offset, 12);
-			data32 = TOKEN_GET_UINT32(tokens);
-			switch (size)
-			{
-				case 1: *(UINT8 *) ((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data32; break;
-				case 2: *(UINT16 *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data32; break;
-				case 4: *(UINT32 *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data32; break;
-			}
-			processed = true;
-			break;
-
-		// provide inline device data packed into a 64-bit word
-		case MCONFIG_TOKEN_DEVICE_CONFIG_DATA64:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK3(tokens, entrytype, 8, size, 4, offset, 12);
-			TOKEN_EXTRACT_UINT64(tokens, data64);
-			switch (size)
-			{
-				case 1: *(UINT8 *) ((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data64; break;
-				case 2: *(UINT16 *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data64; break;
-				case 4: *(UINT32 *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data64; break;
-				case 8: *(UINT64 *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = data64; break;
-			}
-			processed = true;
-			break;
-
-		// provide inline floating-point device data packed into a fixed-point 32-bit word
-		case MCONFIG_TOKEN_DEVICE_CONFIG_DATAFP32:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK4(tokens, entrytype, 8, size, 4, bits, 6, offset, 12);
-			data32 = TOKEN_GET_UINT32(tokens);
-			switch (size)
-			{
-				case 4: *(float *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = (float)(INT32)data32 / (float)(1 << bits); break;
-				case 8: *(double *)((UINT8 *)downcast<legacy_device_config_base *>(this)->inline_config() + offset) = (double)(INT32)data32 / (double)(1 << bits); break;
-			}
-			processed = true;
-			break;
-	}
-
-	// anything else might be handled by one of our interfaces
-	for (device_config_interface *intf = m_interface_list; intf != NULL; intf = intf->interface_next())
-		if (intf->interface_process_token(entrytype, tokens))
-		{
-			assert(!processed);
-			processed = true;
-		}
-
-	// or it might be processed by the device itself
-	if (device_process_token(entrytype, tokens))
-	{
-		assert(!processed);
-		processed = true;
-	}
-
-	// regardless, *somebody* must handle it
-	if (!processed)
-		throw emu_fatalerror("Unhandled token %d for device '%s'", entrytype, tag());
-}
-
-
-//-------------------------------------------------
 //  validity_check - validate a device after the
 //  configuration has been constructed
 //-------------------------------------------------
@@ -506,18 +375,6 @@
 
 
 //-------------------------------------------------
-//  device_process_token - process basic device
-//  tokens
-//-------------------------------------------------
-
-bool device_config::device_process_token(UINT32 entrytype, const machine_config_token *&tokens)
-{
-	// handle nothing by default
-	return false;
-}
-
-
-//-------------------------------------------------
 //  device_validity_check - validate a device after
 //  the configuration has been constructed
 //-------------------------------------------------
@@ -541,12 +398,12 @@
 
 
 //-------------------------------------------------
-//  machine_config_tokens - return a pointer to
-//  a set of machine configuration tokens
-//  describing sub-devices for this device
+//  machine_config - return a pointer to a machine
+//  config constructor describing sub-devices for
+//  this device
 //-------------------------------------------------
 
-const machine_config_token *device_config::machine_config_tokens() const
+machine_config_constructor device_config::machine_config_additions() const
 {
 	return NULL;
 }
diff -Nru src-old/emu/devintrf.h src/emu/devintrf.h
--- src-old/emu/devintrf.h	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/devintrf.h	2010-08-30 08:20:58.000000000 -0700
@@ -66,32 +66,13 @@
 
 // configure devices
 #define MDRV_DEVICE_CONFIG(_config) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DEVICE_CONFIG, 8), \
-	TOKEN_PTR(voidptr, &(_config)),
+	device_config::static_set_static_config(device, &(_config)); \
 
 #define MDRV_DEVICE_CONFIG_CLEAR() \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DEVICE_CONFIG, 8), \
-	TOKEN_PTR(voidptr, NULL),
+	device_config::static_set_static_config(device, NULL); \
 
 #define MDRV_DEVICE_CLOCK(_clock) \
-	TOKEN_UINT64_PACK2(MCONFIG_TOKEN_DEVICE_CLOCK, 8, _clock, 32),
-
-#define MDRV_DEVICE_INLINE_DATA16(_index, _data) \
-	TOKEN_UINT32_PACK3(MCONFIG_TOKEN_DEVICE_INLINE_DATA16, 8, _index, 8, (UINT16)(_data), 16), \
-
-#define MDRV_DEVICE_INLINE_DATA32(_index, _data) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_DEVICE_INLINE_DATA32, 8, _index, 8), \
-	TOKEN_UINT32((UINT32)(_data)),
-
-#define MDRV_DEVICE_INLINE_DATA64(_index, _data) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_DEVICE_INLINE_DATA64, 8, _index, 8), \
-	TOKEN_UINT64((UINT64)(_data)),
-
-#ifdef PTR64
-#define MDRV_DEVICE_INLINE_DATAPTR(_index, _data) MDRV_DEVICE_INLINE_DATA64(_index, (FPTR)(_data))
-#else
-#define MDRV_DEVICE_INLINE_DATAPTR(_index, _data) MDRV_DEVICE_INLINE_DATA32(_index, (FPTR)(_data))
-#endif
+	device_config::static_set_clock(device, _clock); \
 
 
 
@@ -110,7 +91,6 @@
 class device_memory_interface;
 class device_state_interface;
 struct rom_entry;
-union machine_config_token;
 class machine_config;
 
 
@@ -265,10 +245,13 @@
 	const void *static_config() const { return m_static_config; }
 
 	// methods that wrap both interface-level and device-level behavior
-	void process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	void config_complete();
 	bool validity_check(const game_driver &driver) const;
 
+	// configuration helpers
+	static void static_set_clock(device_config *device, UINT32 clock) { device->m_clock = clock; }
+	static void static_set_static_config(device_config *device, const void *config) { device->m_static_config = config; }
+
 	//------------------- begin derived class overrides
 
 	// required operation overrides
@@ -276,14 +259,13 @@
 
 	// optional operation overrides
 protected:
-	virtual bool device_process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	virtual void device_config_complete();
 	virtual bool device_validity_check(const game_driver &driver) const;
 
 public:
 	// optional information overrides
 	virtual const rom_entry *rom_region() const;
-	virtual const machine_config_token *machine_config_tokens() const;
+	virtual machine_config_constructor machine_config_additions() const;
 
 	//------------------- end derived class overrides
 
@@ -298,7 +280,6 @@
 
 	const machine_config &	m_machine_config;		// reference to the machine's configuration
 	const void *			m_static_config;		// static device configuration
-	UINT64					m_inline_data[16];		// array of inline configuration values
 
 	astring					m_name;					// name of the device
 
@@ -333,7 +314,6 @@
 
 	// optional operation overrides
 	virtual void interface_config_complete();
-	virtual bool interface_process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	virtual bool interface_validity_check(const game_driver &driver) const;
 
 protected:
@@ -347,7 +327,7 @@
 // ======================> device_t
 
 // device_t represents a device that is live and attached to a running_machine
-class device_t
+class device_t : public bindable_object
 {
 	DISABLE_COPYING(device_t);
 
@@ -416,7 +396,7 @@
 
 	// machine and ROM configuration getters ... pass through to underlying config
 	const rom_entry *rom_region() const { return m_baseconfig.rom_region(); }
-	const machine_config_token *machine_config_tokens() const { return m_baseconfig.machine_config_tokens(); }
+	machine_config_constructor machine_config_additions() const { return m_baseconfig.machine_config_additions(); }
 
 public:
 	running_machine *		machine;
diff -Nru src-old/emu/devlegcy.c src/emu/devlegcy.c
--- src-old/emu/devlegcy.c	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/devlegcy.c	2010-08-30 08:20:58.000000000 -0700
@@ -128,6 +128,65 @@
 
 
 //-------------------------------------------------
+//  static_set_inline32 - configuration helper to
+//  set a 32-bit value in the inline configuration
+//-------------------------------------------------
+
+void legacy_device_config_base::static_set_inline32(device_config *device, UINT32 offset, UINT32 size, UINT32 value)
+{
+	legacy_device_config_base *legacy = downcast<legacy_device_config_base *>(device);
+	void *dest = reinterpret_cast<UINT8 *>(legacy->m_inline_config) + offset;
+	if (size == 1)
+		*reinterpret_cast<UINT8 *>(dest) = value;
+	else if (size == 2)
+		*reinterpret_cast<UINT16 *>(dest) = value;
+	else if (size == 4)
+		*reinterpret_cast<UINT32 *>(dest) = value;
+	else
+		throw emu_fatalerror("Unexpected size %d in legacy_device_config_base::static_set_inline32", size);
+}
+
+
+//-------------------------------------------------
+//  static_set_inline64 - configuration helper to
+//  set a 64-bit value in the inline configuration
+//-------------------------------------------------
+
+void legacy_device_config_base::static_set_inline64(device_config *device, UINT32 offset, UINT32 size, UINT64 value)
+{
+	legacy_device_config_base *legacy = downcast<legacy_device_config_base *>(device);
+	void *dest = reinterpret_cast<UINT8 *>(legacy->m_inline_config) + offset;
+	if (size == 1)
+		*reinterpret_cast<UINT8 *>(dest) = value;
+	else if (size == 2)
+		*reinterpret_cast<UINT16 *>(dest) = value;
+	else if (size == 4)
+		*reinterpret_cast<UINT32 *>(dest) = value;
+	else if (size == 8)
+		*reinterpret_cast<UINT64 *>(dest) = value;
+	else
+		throw emu_fatalerror("Unexpected size %d in legacy_device_config_base::static_set_inline64", size);
+}
+
+
+//-------------------------------------------------
+//  static_set_inline_float - configuration helper
+//  to set a floating-point value in the inline
+//  configuration
+//-------------------------------------------------
+
+void legacy_device_config_base::static_set_inline_float(device_config *device, UINT32 offset, UINT32 size, float value)
+{
+	legacy_device_config_base *legacy = downcast<legacy_device_config_base *>(device);
+	void *dest = reinterpret_cast<UINT8 *>(legacy->m_inline_config) + offset;
+	if (size == 4)
+		*reinterpret_cast<float *>(dest) = value;
+	else
+		throw emu_fatalerror("Unexpected size %d in legacy_device_config_base::static_set_inline_float", size);
+}
+
+
+//-------------------------------------------------
 //  device_validity_check - perform validity
 //  checks on a device configuration
 //-------------------------------------------------
diff -Nru src-old/emu/devlegcy.h src/emu/devlegcy.h
--- src-old/emu/devlegcy.h	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/devlegcy.h	2010-08-26 08:21:19.000000000 -0700
@@ -275,10 +275,11 @@
 //  DEVICE_CONFIGURATION_MACROS
 //**************************************************************************
 
+#define structsizeof(_struct, _field) sizeof(((_struct *)NULL)->_field)
+
 // inline device configurations that require 32 bits of storage in the token
 #define MDRV_DEVICE_CONFIG_DATA32_EXPLICIT(_size, _offset, _val) \
-	TOKEN_UINT32_PACK3(MCONFIG_TOKEN_DEVICE_CONFIG_DATA32, 8, _size, 4, _offset, 12), \
-	TOKEN_UINT32((UINT32)(_val)),
+	legacy_device_config_base::static_set_inline32(device, _offset, _size, (UINT32)(_val));
 
 #define MDRV_DEVICE_CONFIG_DATA32(_struct, _field, _val) \
 	MDRV_DEVICE_CONFIG_DATA32_EXPLICIT(structsizeof(_struct, _field), offsetof(_struct, _field), _val)
@@ -301,8 +302,7 @@
 
 // inline device configurations that require 32 bits of fixed-point storage in the token
 #define MDRV_DEVICE_CONFIG_DATAFP32_EXPLICIT(_size, _offset, _val, _fixbits) \
-	TOKEN_UINT32_PACK4(MCONFIG_TOKEN_DEVICE_CONFIG_DATAFP32, 8, _size, 4, _fixbits, 6, _offset, 12), \
-	TOKEN_UINT32((INT32)((float)(_val) * (float)(1 << (_fixbits)))),
+	legacy_device_config_base::static_set_inline_float(device, _offset, _size, (float)(_val));
 
 #define MDRV_DEVICE_CONFIG_DATAFP32(_struct, _field, _val, _fixbits) \
 	MDRV_DEVICE_CONFIG_DATAFP32_EXPLICIT(structsizeof(_struct, _field), offsetof(_struct, _field), _val, _fixbits)
@@ -325,8 +325,7 @@
 
 // inline device configurations that require 64 bits of storage in the token
 #define MDRV_DEVICE_CONFIG_DATA64_EXPLICIT(_size, _offset, _val) \
-	TOKEN_UINT32_PACK3(MCONFIG_TOKEN_DEVICE_CONFIG_DATA64, 8, _size, 4, _offset, 12), \
-	TOKEN_UINT64((UINT64)(_val)),
+	legacy_device_config_base::static_set_inline64(device, _offset, _size, (UINT64)(_val));
 
 #define MDRV_DEVICE_CONFIG_DATA64(_struct, _field, _val) \
 	MDRV_DEVICE_CONFIG_DATA64_EXPLICIT(structsizeof(_struct, _field), offsetof(_struct, _field), _val)
@@ -373,6 +372,8 @@
 //**************************************************************************
 
 union deviceinfo;
+class machine_config;
+class device_config;
 
 char *get_temp_string_buffer(void);
 resource_pool &machine_get_pool(running_machine &machine);
@@ -402,7 +403,7 @@
 	device_execute_func 	execute;					// DEVINFO_FCT_EXECUTE
 	device_nvram_func		nvram;						// DEVINFO_FCT_NVRAM
 	const rom_entry *		romregion;					// DEVINFO_PTR_ROM_REGION
-	const machine_config_token *machine_config;			// DEVINFO_PTR_MACHINE_CONFIG
+	machine_config_constructor machine_config;			// DEVINFO_PTR_MACHINE_CONFIG
 	address_map_constructor	internal_map8;				// DEVINFO_PTR_INTERNAL_MEMORY_MAP
 	address_map_constructor	internal_map16;				// DEVINFO_PTR_INTERNAL_MEMORY_MAP
 	address_map_constructor	internal_map32;				// DEVINFO_PTR_INTERNAL_MEMORY_MAP
@@ -433,11 +434,16 @@
 	// basic information getters
 public:
 	virtual const rom_entry *rom_region() const { return reinterpret_cast<const rom_entry *>(get_legacy_config_ptr(DEVINFO_PTR_ROM_REGION)); }
-	virtual const machine_config_token *machine_config_tokens() const { return reinterpret_cast<const machine_config_token *>(get_legacy_config_ptr(DEVINFO_PTR_MACHINE_CONFIG)); }
+	virtual machine_config_constructor machine_config_additions() const { return reinterpret_cast<machine_config_constructor>(get_legacy_config_ptr(DEVINFO_PTR_MACHINE_CONFIG)); }
 
 	// access to legacy inline configuartion
 	void *inline_config() const { return m_inline_config; }
 
+	// inline configuration helpers
+	static void static_set_inline32(device_config *device, UINT32 offset, UINT32 size, UINT32 value);
+	static void static_set_inline64(device_config *device, UINT32 offset, UINT32 size, UINT64 value);
+	static void static_set_inline_float(device_config *device, UINT32 offset, UINT32 size, float value);
+
 protected:
 	// overrides
 	virtual bool device_validity_check(const game_driver &driver) const;
diff -Nru src-old/emu/diexec.c src/emu/diexec.c
--- src-old/emu/diexec.c	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/diexec.c	2010-08-30 08:20:58.000000000 -0700
@@ -78,7 +78,7 @@
 	  m_vblank_interrupts_per_frame(0),
 	  m_vblank_interrupt_screen(NULL),
 	  m_timed_interrupt(NULL),
-	  m_timed_interrupt_period(0)
+	  m_timed_interrupt_period(attotime_zero)
 {
 }
 
@@ -93,6 +93,51 @@
 
 
 //-------------------------------------------------
+//  static_set_disable - configuration helper to
+//  set the disabled state of a device
+//-------------------------------------------------
+
+void device_config_execute_interface::static_set_disable(device_config *device)
+{
+	device_config_execute_interface *exec = dynamic_cast<device_config_execute_interface *>(device);
+	if (exec == NULL)
+		throw emu_fatalerror("MDRV_DEVICE_DISABLE called on device '%s' with no execute interface", device->tag());
+	exec->m_disabled = true;
+}
+
+
+//-------------------------------------------------
+//  static_set_vblank_int - configuration helper
+//  to set up VBLANK interrupts on the device
+//-------------------------------------------------
+
+void device_config_execute_interface::static_set_vblank_int(device_config *device, device_interrupt_func function, const char *tag, int rate)
+{
+	device_config_execute_interface *exec = dynamic_cast<device_config_execute_interface *>(device);
+	if (exec == NULL)
+		throw emu_fatalerror("MDRV_DEVICE_VBLANK_INT called on device '%s' with no execute interface", device->tag());
+	exec->m_vblank_interrupt = function;
+	exec->m_vblank_interrupts_per_frame = rate;
+	exec->m_vblank_interrupt_screen = tag;
+}
+
+
+//-------------------------------------------------
+//  static_set_periodic_int - configuration helper
+//  to set up periodic interrupts on the device
+//-------------------------------------------------
+
+void device_config_execute_interface::static_set_periodic_int(device_config *device, device_interrupt_func function, attotime rate)
+{
+	device_config_execute_interface *exec = dynamic_cast<device_config_execute_interface *>(device);
+	if (exec == NULL)
+		throw emu_fatalerror("MDRV_DEVICE_PERIODIC_INT called on device '%s' with no execute interface", device->tag());
+	exec->m_timed_interrupt = function;
+	exec->m_timed_interrupt_period = rate;
+}
+
+
+//-------------------------------------------------
 //  execute_clocks_to_cycles - convert the number
 //  of clocks to cycles, rounding down if necessary
 //-------------------------------------------------
@@ -161,39 +206,6 @@
 
 
 //-------------------------------------------------
-//  interface_process_token - token processing for
-//  the sound interface
-//-------------------------------------------------
-
-bool device_config_execute_interface::interface_process_token(UINT32 entrytype, const machine_config_token *&tokens)
-{
-	switch (entrytype)
-	{
-		// disable a device
-		case MCONFIG_TOKEN_DIEXEC_DISABLE:
-			m_disabled = true;
-			return true;
-
-		// VBLANK interrupt
-		case MCONFIG_TOKEN_DIEXEC_VBLANK_INT:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, m_vblank_interrupts_per_frame, 24);
-			m_vblank_interrupt = TOKEN_GET_PTR(tokens, cpu_interrupt);
-			m_vblank_interrupt_screen = TOKEN_GET_STRING(tokens);
-			return true;
-
-		// timed interrupt
-		case MCONFIG_TOKEN_DIEXEC_PERIODIC_INT:
-			m_timed_interrupt = TOKEN_GET_PTR(tokens, cpu_interrupt);
-			TOKEN_EXTRACT_UINT64(tokens, m_timed_interrupt_period);
-			return true;
-	}
-
-	return false;
-}
-
-
-//-------------------------------------------------
 //  interface_validity_check - validation for a
 //  device after the configuration has been
 //  constructed
@@ -234,12 +246,12 @@
 		error = true;
 	}
 
-	if (m_timed_interrupt != NULL && m_timed_interrupt_period == 0)
+	if (m_timed_interrupt != NULL && attotime_compare(m_timed_interrupt_period, attotime_zero) == 0)
 	{
 		mame_printf_error("%s: %s device '%s' has a timer interrupt handler with 0 period!\n", driver.source_file, driver.name, devconfig->tag());
 		error = true;
 	}
-	else if (m_timed_interrupt == NULL && m_timed_interrupt_period != 0)
+	else if (m_timed_interrupt == NULL && attotime_compare(m_timed_interrupt_period, attotime_zero) != 0)
 	{
 		mame_printf_error("%s: %s device '%s' has a no timer interrupt handler but has a non-0 period given!\n", driver.source_file, driver.name, devconfig->tag());
 		error = true;
@@ -267,7 +279,7 @@
 	  m_timedint_timer(NULL),
 	  m_iloops(0),
 	  m_partial_frame_timer(NULL),
-	  m_profiler(0),
+	  m_profiler(PROFILER_IDLE),
 	  m_icount(NULL),
 	  m_cycles_running(0),
 	  m_cycles_stolen(0),
@@ -538,7 +550,7 @@
 	// fill in the initial states
 	int index = m_machine.m_devicelist.index(&m_device);
 	m_suspend = SUSPEND_REASON_RESET;
-	m_profiler = index + PROFILER_DEVICE_FIRST;
+	m_profiler = profile_type(index + PROFILER_DEVICE_FIRST);
 	m_inttrigger = index + TRIGGER_INT;
 
 	// fill in the input states and IRQ callback information
@@ -548,7 +560,7 @@
 	// allocate timers if we need them
 	if (m_execute_config.m_vblank_interrupts_per_frame > 1)
 		m_partial_frame_timer = timer_alloc(&m_machine, static_trigger_partial_frame_interrupt, (void *)this);
-	if (m_execute_config.m_timed_interrupt_period != 0)
+	if (attotime_compare(m_execute_config.m_timed_interrupt_period, attotime_zero) != 0)
 		m_timedint_timer = timer_alloc(&m_machine, static_trigger_periodic_interrupt, (void *)this);
 
 	// register for save states
@@ -624,9 +636,9 @@
 	}
 
 	// reconfigure periodic interrupts
-	if (m_execute_config.m_timed_interrupt_period != 0)
+	if (attotime_compare(m_execute_config.m_timed_interrupt_period, attotime_zero) != 0)
 	{
-		attotime timedint_period = UINT64_ATTOTIME_TO_ATTOTIME(m_execute_config.m_timed_interrupt_period);
+		attotime timedint_period = m_execute_config.m_timed_interrupt_period;
 		assert(m_timedint_timer != NULL);
 		timer_adjust_periodic(m_timedint_timer, timedint_period, 0, timedint_period);
 	}
diff -Nru src-old/emu/diexec.h src/emu/diexec.h
--- src-old/emu/diexec.h	2010-07-05 17:52:36.000000000 -0700
+++ src/emu/diexec.h	2010-08-26 08:21:19.000000000 -0700
@@ -109,17 +109,13 @@
 //**************************************************************************
 
 #define MDRV_DEVICE_DISABLE() \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DIEXEC_DISABLE, 8), \
+	device_config_execute_interface::static_set_disable(device); \
 
 #define MDRV_DEVICE_VBLANK_INT(_tag, _func) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_DIEXEC_VBLANK_INT, 8, 0, 24), \
-	TOKEN_PTR(device_interrupt, _func), \
-	TOKEN_PTR(stringptr, _tag), \
+	device_config_execute_interface::static_set_vblank_int(device, _func, _tag); \
 
 #define MDRV_DEVICE_PERIODIC_INT(_func, _rate)	\
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DIEXEC_PERIODIC_INT, 8), \
-	TOKEN_PTR(device_interrupt, _func), \
-	TOKEN_UINT64(UINT64_ATTOTIME_IN_HZ(_rate)), \
+	device_config_execute_interface::static_set_periodic_int(device, _func, ATTOTIME_IN_HZ(_rate)); \
 
 
 
@@ -164,6 +160,11 @@
 	UINT32 input_lines() const { return execute_input_lines(); }
 	UINT32 default_irq_vector() const { return execute_default_irq_vector(); }
 
+	// static inline helpers
+	static void static_set_disable(device_config *device);
+	static void static_set_vblank_int(device_config *device, device_interrupt_func function, const char *tag, int rate = 0);
+	static void static_set_periodic_int(device_config *device, device_interrupt_func function, attotime rate);
+
 protected:
 	// clock and cycle information getters
 	virtual UINT64 execute_clocks_to_cycles(UINT64 clocks) const;
@@ -176,7 +177,6 @@
 	virtual UINT32 execute_default_irq_vector() const;
 
 	// optional operation overrides
-	virtual bool interface_process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	virtual bool interface_validity_check(const game_driver &driver) const;
 
 	bool					m_disabled;
@@ -184,7 +184,7 @@
 	int 					m_vblank_interrupts_per_frame;	// usually 1
 	const char *			m_vblank_interrupt_screen;		// the screen that causes the VBLANK interrupt
 	device_interrupt_func	m_timed_interrupt;				// for interrupts not tied to VBLANK
-	UINT64					m_timed_interrupt_period;		// period for periodic interrupts
+	attotime				m_timed_interrupt_period;		// period for periodic interrupts
 };
 
 
@@ -322,7 +322,7 @@
 	attotime				m_partial_frame_period;		// the length of one partial frame for interrupt purposes
 
 	// cycle counting and executing
-	int						m_profiler;					// profiler tag
+	profile_type			m_profiler;					// profiler tag
 	int *					m_icount;					// pointer to the icount
 	int 					m_cycles_running;			// number of cycles we are executing
 	int						m_cycles_stolen;			// number of cycles we artificially stole
diff -Nru src-old/emu/diimage.c src/emu/diimage.c
--- src-old/emu/diimage.c	2010-08-04 00:49:46.000000000 -0700
+++ src/emu/diimage.c	2010-08-21 12:27:14.000000000 -0700
@@ -271,7 +271,7 @@
 void device_image_interface::clear_error()
 {
     m_err = IMAGE_ERROR_SUCCESS;
-    if (m_err_message.len()!=0)
+    if (m_err_message)
     {
         m_err_message.reset();
     }
@@ -297,7 +297,7 @@
 
 const char *device_image_interface::error()
 {
-    return (m_err_message.len()!=0) ? m_err_message.cstr() : messages[m_err];
+    return (m_err_message) ? m_err_message.cstr() : messages[m_err];
 }
 
 
@@ -413,7 +413,7 @@
 const char * device_image_interface::working_directory()
 {
    /* check to see if we've never initialized the working directory */
-    if (m_working_directory.len() == 0)
+    if (!m_working_directory)
         setup_working_directory();
 
     return m_working_directory;
@@ -593,7 +593,7 @@
     int rc;
 
     /* only calculate CRC if it hasn't been calculated, and the open_mode is read only */
-    if (m_hash.len()==0 && !m_writeable && !m_created)
+    if (!m_hash && !m_writeable && !m_created)
     {
         /* do not cause a linear read of 600 megs please */
         /* TODO: use SHA/MD5 in the CHD header as the hash */
@@ -628,7 +628,7 @@
     UINT32 crc = 0;
 
 	image_checkhash();
-    if (m_hash.len()!= 0)
+    if (m_hash)
         crc = hash_data_extract_crc32(m_hash.cstr());
 
     return crc;
diff -Nru src-old/emu/diimage.h src/emu/diimage.h
--- src-old/emu/diimage.h	2010-07-28 00:21:11.000000000 -0700
+++ src/emu/diimage.h	2010-08-21 12:27:14.000000000 -0700
@@ -222,11 +222,11 @@
 	void seterror(image_error_t err, const char *message);
 	void message(const char *format, ...);
 
-	bool exists() { return m_name.len() != 0; }
-	const char *filename() { if (m_name.len()==0) return NULL; else return m_name; }
-	const char *basename() { if (m_basename.len()==0) return NULL; else return m_basename; }
-	const char *basename_noext()  { if (m_basename_noext.len()==0) return NULL; else return m_basename_noext; }
-	const char *filetype()  { if (m_filetype.len()==0) return NULL; else return m_filetype; }
+	bool exists() { return m_name; }
+	const char *filename() { if (!m_name) return NULL; else return m_name; }
+	const char *basename() { if (!m_basename) return NULL; else return m_basename; }
+	const char *basename_noext()  { if (!m_basename_noext) return NULL; else return m_basename_noext; }
+	const char *filetype()  { if (!m_filetype) return NULL; else return m_filetype; }
 	core_file *image_core_file() { return m_file; }
 	UINT64 length() { check_for_file(); return core_fsize(m_file); }
 	bool is_writable() { return m_writeable; }
diff -Nru src-old/emu/dimemory.c src/emu/dimemory.c
--- src-old/emu/dimemory.c	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/dimemory.c	2010-08-30 08:20:58.000000000 -0700
@@ -144,26 +144,18 @@
 
 
 //-------------------------------------------------
-//  interface_process_token - token processing for
-//  the memory interface
+//  static_set_vblank_int - configuration helper
+//  to set up VBLANK interrupts on the device
 //-------------------------------------------------
 
-bool device_config_memory_interface::interface_process_token(UINT32 entrytype, const machine_config_token *&tokens)
+void device_config_memory_interface::static_set_addrmap(device_config *device, int spacenum, address_map_constructor map)
 {
-	UINT32 data32;
-
-	switch (entrytype)
-	{
-		// specify device address map
-		case MCONFIG_TOKEN_DIMEMORY_MAP:
-			TOKEN_UNGET_UINT32(tokens);
-			TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, data32, 8);
-			assert(data32 < ARRAY_LENGTH(m_address_map));
-			m_address_map[data32] = TOKEN_GET_PTR(tokens, addrmap);
-			return true;
-	}
-
-	return false;
+	device_config_memory_interface *memory = dynamic_cast<device_config_memory_interface *>(device);
+	if (memory == NULL)
+		throw emu_fatalerror("MDRV_DEVICE_ADDRESS_MAP called on device '%s' with no memory interface", device->tag());
+	if (spacenum >= ARRAY_LENGTH(memory->m_address_map))
+		throw emu_fatalerror("MDRV_DEVICE_ADDRESS_MAP called with out-of-range space number %d", device->tag(), spacenum);
+	memory->m_address_map[spacenum] = map;
 }
 
 
@@ -191,7 +183,7 @@
 			::address_map *map = global_alloc(::address_map(*devconfig, spacenum));
 
 			// if this is an empty map, just skip it
-			if (map->m_entrylist == NULL)
+			if (map->m_entrylist.first() == NULL)
 			{
 				global_free(map);
 				continue;
@@ -210,7 +202,7 @@
 			}
 
 			// loop over entries and look for errors
-			for (address_map_entry *entry = map->m_entrylist; entry != NULL; entry = entry->m_next)
+			for (address_map_entry *entry = map->m_entrylist.first(); entry != NULL; entry = entry->next())
 			{
 				UINT32 bytestart = spaceconfig->addr2byte(entry->m_addrstart);
 				UINT32 byteend = spaceconfig->addr2byte_end(entry->m_addrend);
@@ -219,12 +211,12 @@
 				if (!detected_overlap)
 				{
 					address_map_entry *scan;
-					for (scan = map->m_entrylist; scan != entry; scan = scan->m_next)
+					for (scan = map->m_entrylist.first(); scan != entry; scan = scan->next())
 						if (entry->m_addrstart <= scan->m_addrend && entry->m_addrend >= scan->m_addrstart &&
-							((entry->m_read.type != AMH_NONE && scan->m_read.type != AMH_NONE) ||
-							 (entry->m_write.type != AMH_NONE && scan->m_write.type != AMH_NONE)))
+							((entry->m_read.m_type != AMH_NONE && scan->m_read.m_type != AMH_NONE) ||
+							 (entry->m_write.m_type != AMH_NONE && scan->m_write.m_type != AMH_NONE)))
 						{
-							mame_printf_warning("%s: %s '%s' %s space has overlapping memory (%X-%X,%d,%d) vs (%X-%X,%d,%d)\n", driver.source_file, driver.name, devconfig->tag(), spaceconfig->m_name, entry->m_addrstart, entry->m_addrend, entry->m_read.type, entry->m_write.type, scan->m_addrstart, scan->m_addrend, scan->m_read.type, scan->m_write.type);
+							mame_printf_warning("%s: %s '%s' %s space has overlapping memory (%X-%X,%d,%d) vs (%X-%X,%d,%d)\n", driver.source_file, driver.name, devconfig->tag(), spaceconfig->m_name, entry->m_addrstart, entry->m_addrend, entry->m_read.m_type, entry->m_write.m_type, scan->m_addrstart, scan->m_addrend, scan->m_read.m_type, scan->m_write.m_type);
 							detected_overlap = true;
 							break;
 						}
@@ -245,7 +237,7 @@
 				}
 
 				// if this is a program space, auto-assign implicit ROM entries
-				if (entry->m_read.type == AMH_ROM && entry->m_region == NULL)
+				if (entry->m_read.m_type == AMH_ROM && entry->m_region == NULL)
 				{
 					entry->m_region = devconfig->tag();
 					entry->m_rgnoffs = entry->m_addrstart;
@@ -287,25 +279,25 @@
 				}
 
 				// make sure all devices exist
-				if ((entry->m_read.type == AMH_DEVICE_HANDLER && entry->m_read.tag != NULL && m_machine_config.m_devicelist.find(entry->m_read.tag) == NULL) ||
-					(entry->m_write.type == AMH_DEVICE_HANDLER && entry->m_write.tag != NULL && m_machine_config.m_devicelist.find(entry->m_write.tag) == NULL))
+				if ((entry->m_read.m_type == AMH_LEGACY_DEVICE_HANDLER && entry->m_read.m_tag != NULL && m_machine_config.m_devicelist.find(entry->m_read.m_tag) == NULL) ||
+					(entry->m_write.m_type == AMH_LEGACY_DEVICE_HANDLER && entry->m_write.m_tag != NULL && m_machine_config.m_devicelist.find(entry->m_write.m_tag) == NULL))
 				{
-					mame_printf_error("%s: %s device '%s' %s space memory map entry references nonexistant device '%s'\n", driver.source_file, driver.name, devconfig->tag(), spaceconfig->m_name, entry->m_write.tag);
+					mame_printf_error("%s: %s device '%s' %s space memory map entry references nonexistant device '%s'\n", driver.source_file, driver.name, devconfig->tag(), spaceconfig->m_name, entry->m_write.m_tag);
 					error = true;
 				}
 
 				// make sure ports exist
-//              if ((entry->m_read.type == AMH_PORT && entry->m_read.tag != NULL && portlist.find(entry->m_read.tag) == NULL) ||
-//                  (entry->m_write.type == AMH_PORT && entry->m_write.tag != NULL && portlist.find(entry->m_write.tag) == NULL))
+//              if ((entry->m_read.m_type == AMH_PORT && entry->m_read.m_tag != NULL && portlist.find(entry->m_read.m_tag) == NULL) ||
+//                  (entry->m_write.m_type == AMH_PORT && entry->m_write.m_tag != NULL && portlist.find(entry->m_write.m_tag) == NULL))
 //              {
 //                  mame_printf_error("%s: %s device '%s' %s space memory map entry references nonexistant port tag '%s'\n", driver.source_file, driver.name, devconfig->tag(), spaceconfig->m_name, entry->m_read.tag);
 //                  error = true;
 //              }
 
 				// validate bank and share tags
-				if (entry->m_read.type == AMH_BANK && !validate_tag(&driver, "bank", entry->m_read.tag))
+				if (entry->m_read.m_type == AMH_BANK && !validate_tag(&driver, "bank", entry->m_read.m_tag))
 					error = true ;
-				if (entry->m_write.type == AMH_BANK && !validate_tag(&driver, "bank", entry->m_write.tag))
+				if (entry->m_write.m_type == AMH_BANK && !validate_tag(&driver, "bank", entry->m_write.m_tag))
 					error = true;
 				if (entry->m_share != NULL && !validate_tag(&driver, "share", entry->m_share))
 					error = true;
@@ -350,10 +342,10 @@
 //  to a device
 //-------------------------------------------------
 
-void device_memory_interface::set_address_space(int spacenum, const address_space *space)
+void device_memory_interface::set_address_space(int spacenum, address_space &space)
 {
 	assert(spacenum < ARRAY_LENGTH(m_addrspace));
-	m_addrspace[spacenum] = space;
+	m_addrspace[spacenum] = &space;
 }
 
 
diff -Nru src-old/emu/dimemory.h src/emu/dimemory.h
--- src-old/emu/dimemory.h	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/dimemory.h	2010-08-26 08:21:19.000000000 -0700
@@ -82,8 +82,7 @@
 //**************************************************************************
 
 #define MDRV_DEVICE_ADDRESS_MAP(_space, _map) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_DIMEMORY_MAP, 8, _space, 8), \
-	TOKEN_PTR(addrmap, (address_map_constructor)ADDRESS_MAP_NAME(_map)),
+	device_config_memory_interface::static_set_addrmap(device, _space, ADDRESS_MAP_NAME(_map));
 
 #define MDRV_DEVICE_PROGRAM_MAP(_map) \
 	MDRV_DEVICE_ADDRESS_MAP(AS_PROGRAM, _map)
@@ -100,48 +99,6 @@
 //  TYPE DEFINITIONS
 //**************************************************************************
 
-// ======================> address_space_config
-
-class address_space_config
-{
-public:
-	address_space_config();
-	address_space_config(const char *name, endianness_t endian, UINT8 datawidth, UINT8 addrwidth, INT8 addrshift = 0, address_map_constructor internal = NULL, address_map_constructor defmap = NULL);
-	address_space_config(const char *name, endianness_t endian, UINT8 datawidth, UINT8 addrwidth, INT8 addrshift, UINT8 logwidth, UINT8 pageshift, address_map_constructor internal = NULL, address_map_constructor defmap = NULL);
-
-	inline offs_t addr2byte(offs_t address) const
-	{
-		return (m_addrbus_shift < 0) ? (address << -m_addrbus_shift) : (address >> m_addrbus_shift);
-	}
-
-	inline offs_t addr2byte_end(offs_t address) const
-	{
-		return (m_addrbus_shift < 0) ? ((address << -m_addrbus_shift) | ((1 << -m_addrbus_shift) - 1)) : (address >> m_addrbus_shift);
-	}
-
-	inline offs_t byte2addr(offs_t address) const
-	{
-		return (m_addrbus_shift > 0) ? (address << m_addrbus_shift) : (address >> -m_addrbus_shift);
-	}
-
-	inline offs_t byte2addr_end(offs_t address) const
-	{
-		return (m_addrbus_shift > 0) ? ((address << m_addrbus_shift) | ((1 << -m_addrbus_shift) - 1)) : (address >> -m_addrbus_shift);
-	}
-
-	const char *		m_name;
-	endianness_t		m_endianness;
-	UINT8				m_databus_width;
-	UINT8				m_addrbus_width;
-	INT8				m_addrbus_shift;
-	UINT8				m_logaddr_width;
-	UINT8				m_page_shift;
-	address_map_constructor m_internal_map;
-	address_map_constructor m_default_map;
-};
-
-
-
 // ======================> device_config_memory_interface
 
 // class representing interface-specific configuration state
@@ -158,12 +115,14 @@
 	address_map_constructor address_map(int spacenum = 0) const { return (spacenum < ARRAY_LENGTH(m_address_map)) ? m_address_map[spacenum] : NULL; }
 	const address_space_config *space_config(int spacenum = 0) const { return memory_space_config(spacenum); }
 
+	// static inline helpers
+	static void static_set_addrmap(device_config *device, int spacenum, address_map_constructor map);
+
 protected:
 	// required overrides
 	virtual const address_space_config *memory_space_config(int spacenum) const = 0;
 
 	// optional operation overrides
-	virtual bool interface_process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	virtual bool interface_validity_check(const game_driver &driver) const;
 
 	address_map_constructor	m_address_map[ADDRESS_SPACES]; // address maps for each address space
@@ -187,11 +146,11 @@
 
 	// basic information getters
 	const address_space_config *space_config(int spacenum = 0) const { return m_memory_config.space_config(spacenum); }
-	const address_space *space(int index = 0) const { return m_addrspace[index]; }
-	const address_space *space(device_space index) const { return m_addrspace[static_cast<int>(index)]; }
+	address_space *space(int index = 0) const { return m_addrspace[index]; }
+	address_space *space(device_space index) const { return m_addrspace[static_cast<int>(index)]; }
 
 	// address space accessors
-	void set_address_space(int spacenum, const address_space *space);
+	void set_address_space(int spacenum, address_space &space);
 
 	// address translation
 	bool translate(int spacenum, int intention, offs_t &address) { return memory_translate(spacenum, intention, address); }
@@ -212,7 +171,7 @@
 
 	// configuration
 	const device_config_memory_interface &m_memory_config;	// reference to our device_config_execute_interface
-	const address_space *	m_addrspace[ADDRESS_SPACES]; // reported address spaces
+	address_space *		m_addrspace[ADDRESS_SPACES]; // reported address spaces
 };
 
 
@@ -240,7 +199,7 @@
 //  given address space on this device
 //-------------------------------------------------
 
-inline const address_space *device_get_space(device_t *device, int spacenum = 0)
+inline address_space *device_get_space(device_t *device, int spacenum = 0)
 {
 	return device_memory(device)->space(spacenum);
 }
diff -Nru src-old/emu/disound.c src/emu/disound.c
--- src-old/emu/disound.c	2010-06-27 23:40:44.000000000 -0700
+++ src/emu/disound.c	2010-08-30 08:20:58.000000000 -0700
@@ -68,41 +68,34 @@
 
 
 //-------------------------------------------------
-//  interface_process_token - token processing for
-//  the sound interface
+//  static_add_route - configuration helper to add
+//  a new route to the device
 //-------------------------------------------------
 
-bool device_config_sound_interface::interface_process_token(UINT32 entrytype, const machine_config_token *&tokens)
+void device_config_sound_interface::static_add_route(device_config *device, UINT32 output, const char *target, double gain, UINT32 input)
 {
-	switch (entrytype)
-	{
-		// custom config 1 is a new route
-		case MCONFIG_TOKEN_DISOUND_ROUTE:
-		{
-			// put back the token that was originally fetched so we can grab a packed 64-bit token
-			TOKEN_UNGET_UINT32(tokens);
+	device_config_sound_interface *sound = dynamic_cast<device_config_sound_interface *>(device);
+	if (sound == NULL)
+		throw emu_fatalerror("MDRV_SOUND_ROUTE called on device '%s' with no sound interface", device->tag());
 
-			// extract data
-			int output, input;
-			UINT32 gain;
-			TOKEN_GET_UINT64_UNPACK4(tokens, entrytype, 8, output, 12, input, 12, gain, 32);
-			float fgain = (float)gain * (1.0f / (float)(1 << 24));
-			const char *target = TOKEN_GET_STRING(tokens);
-
-			// allocate a new route
-			sound_route **routeptr;
-			for (routeptr = &m_route_list; *routeptr != NULL; routeptr = &(*routeptr)->m_next) ;
-			*routeptr = global_alloc(sound_route(output, input, fgain, target));
-			return true;
-		}
+	sound_route **routeptr;
+	for (routeptr = &sound->m_route_list; *routeptr != NULL; routeptr = &(*routeptr)->m_next) ;
+	*routeptr = global_alloc(sound_route(output, input, gain, target));
+}
 
-		// custom config 2 resets the sound routes
-		case MCONFIG_TOKEN_DISOUND_RESET:
-			reset_routes();
-			return true;
-	}
 
-	return false;
+//-------------------------------------------------
+//  static_reset_routes - configuration helper to
+//  reset all existing routes to the device
+//-------------------------------------------------
+
+void device_config_sound_interface::static_reset_routes(device_config *device)
+{
+	device_config_sound_interface *sound = dynamic_cast<device_config_sound_interface *>(device);
+	if (sound == NULL)
+		throw emu_fatalerror("MDRV_SOUND_ROUTES_RESET called on device '%s' with no sound interface", device->tag());
+
+	sound->reset_routes();
 }
 
 
diff -Nru src-old/emu/disound.h src/emu/disound.h
--- src-old/emu/disound.h	2010-06-16 23:55:54.000000000 -0700
+++ src/emu/disound.h	2010-08-26 08:21:19.000000000 -0700
@@ -76,14 +76,13 @@
 	MDRV_DEVICE_CONFIG(_config)
 
 #define MDRV_SOUND_ROUTE_EX(_output, _target, _gain, _input) \
-	TOKEN_UINT64_PACK4(MCONFIG_TOKEN_DISOUND_ROUTE, 8, _output, 12, _input, 12, ((float)(_gain) * (float)(1 << 24)), 32), \
-	TOKEN_PTR(stringptr, _target),
+	device_config_sound_interface::static_add_route(device, _output, _target, _gain, _input); \
 
 #define MDRV_SOUND_ROUTE(_output, _target, _gain) \
 	MDRV_SOUND_ROUTE_EX(_output, _target, _gain, 0)
 
 #define MDRV_SOUND_ROUTES_RESET() \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DISOUND_RESET, 8),
+	device_config_sound_interface::static_reset_routes(device); \
 
 
 
@@ -118,9 +117,12 @@
 
 	sound_route *		m_route_list;			// list of sound routes
 
+	// static inline helpers
+	static void static_add_route(device_config *device, UINT32 output, const char *target, double gain, UINT32 input = 0);
+	static void static_reset_routes(device_config *device);
+
 protected:
 	// optional operation overrides
-	virtual bool interface_process_token(UINT32 entrytype, const machine_config_token *&tokens);
 	virtual bool interface_validity_check(const game_driver &driver) const;
 
 	void reset_routes();
diff -Nru src-old/emu/drawgfxm.h src/emu/drawgfxm.h
--- src-old/emu/drawgfxm.h	2010-05-10 15:43:31.000000000 -0700
+++ src/emu/drawgfxm.h	2010-08-21 15:25:58.000000000 -0700
@@ -370,7 +370,7 @@
 
 #define DRAWGFX_CORE(PIXEL_TYPE, PIXEL_OP, PRIORITY_TYPE)								\
 do {																					\
-	profiler_mark_start(PROFILER_DRAWGFX);												\
+	g_profiler.start(PROFILER_DRAWGFX);												\
 	do {																				\
 		const UINT8 *srcdata;															\
 		INT32 destendx, destendy;														\
@@ -613,7 +613,7 @@
 			}																			\
 		}																				\
 	} while (0);																		\
-	profiler_mark_end();														\
+	g_profiler.stop();														\
 } while (0)
 
 
@@ -642,7 +642,7 @@
 
 #define DRAWGFXZOOM_CORE(PIXEL_TYPE, PIXEL_OP, PRIORITY_TYPE)							\
 do {																					\
-	profiler_mark_start(PROFILER_DRAWGFX);													\
+	g_profiler.start(PROFILER_DRAWGFX);													\
 	do {																				\
 		const UINT8 *srcdata;															\
 		UINT32 dstwidth, dstheight;														\
@@ -698,7 +698,7 @@
 		destendy = desty + dstheight - 1;												\
 		if (desty > cliprect->max_y || destendy < cliprect->min_y)						\
 		{																				\
-			profiler_mark_end();													\
+			g_profiler.stop();													\
 			return;																		\
 		}																				\
 																						\
@@ -797,7 +797,7 @@
 			}																			\
 		}																				\
 	} while (0);																		\
-	profiler_mark_end();														\
+	g_profiler.stop();														\
 } while (0)
 
 
@@ -821,7 +821,7 @@
 
 #define COPYBITMAP_CORE(PIXEL_TYPE, PIXEL_OP, PRIORITY_TYPE)							\
 do {																					\
-	profiler_mark_start(PROFILER_COPYBITMAP);													\
+	g_profiler.start(PROFILER_COPYBITMAP);													\
 	do {																				\
 		const PIXEL_TYPE *srcdata;														\
 		UINT32 numblocks, leftovers;													\
@@ -975,7 +975,7 @@
 			}																			\
 		}																				\
 	} while (0);																		\
-	profiler_mark_end();														\
+	g_profiler.stop();														\
 } while (0)
 
 
@@ -1006,7 +1006,7 @@
 	UINT32 numblocks, leftovers;													\
 	INT32 curx, cury;																\
 																					\
-	profiler_mark_start(PROFILER_COPYBITMAP);										\
+	g_profiler.start(PROFILER_COPYBITMAP);										\
 																					\
 	assert(dest != NULL);															\
 	assert(src != NULL);															\
@@ -1280,7 +1280,7 @@
 			}																		\
 		}																			\
 	}																				\
-	profiler_mark_end();															\
+	g_profiler.stop();															\
 } while (0)
 
 
diff -Nru src-old/emu/driver.h src/emu/driver.h
--- src-old/emu/driver.h	2010-05-19 08:08:32.000000000 -0700
+++ src/emu/driver.h	2010-08-26 08:21:19.000000000 -0700
@@ -67,7 +67,7 @@
 	const char *		description;				/* full name of the game */
 	const char *		year;						/* year the game was released */
 	const char *		manufacturer;				/* manufacturer of the game */
-	const machine_config_token *machine_config;		/* machine driver tokens */
+	machine_config_constructor machine_config;		/* machine driver tokens */
 	const input_port_token *ipt;					/* pointer to array of input port tokens */
 	void				(*driver_init)(running_machine *machine); /* DRIVER_INIT callback */
 	const rom_entry *	rom;						/* pointer to list of ROMs for the game */
diff -Nru src-old/emu/emu.h src/emu/emu.h
--- src-old/emu/emu.h	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/emu.h	2010-08-26 08:21:19.000000000 -0700
@@ -52,6 +52,7 @@
 // core emulator headers -- must be first
 #include "emucore.h"
 #include "eminline.h"
+#include "profiler.h"
 
 // commonly-referenecd utilities imported from lib/util
 #include "chd.h"
@@ -62,11 +63,18 @@
 #include "attotime.h"
 #include "fileio.h" // remove me once NVRAM is implemented as device
 #include "tokenize.h"
+#include "delegate.h"
 
 // memory and address spaces
 #include "memory.h"
 #include "addrmap.h"
 
+// define machine_config_constructor here due to circular dependency
+// between devices and the machine config
+class machine_config;
+class device_config;
+typedef void (*machine_config_constructor)(machine_config &config, device_config *owner);
+
 // devices and callbacks
 #include "devintrf.h"
 #include "devcb.h"
diff -Nru src-old/emu/emu.mak src/emu/emu.mak
--- src-old/emu/emu.mak	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/emu.mak	2010-08-24 02:32:43.000000000 -0700
@@ -45,6 +45,7 @@
 	$(EMUOBJ)/config.o \
 	$(EMUOBJ)/crsshair.o \
 	$(EMUOBJ)/debugger.o \
+	$(EMUOBJ)/delegate.o \
 	$(EMUOBJ)/devcb.o \
 	$(EMUOBJ)/devcpu.o \
 	$(EMUOBJ)/devimage.o \
@@ -109,12 +110,8 @@
 	$(EMUOBJ)/debug/dvtext.o \
 	$(EMUOBJ)/debug/express.o \
 	$(EMUOBJ)/debug/textbuf.o \
-	$(EMUOBJ)/debugint/debugint.o
-
-ifdef PROFILER
-EMUOBJS += \
+	$(EMUOBJ)/debugint/debugint.o \
 	$(EMUOBJ)/profiler.o
-endif
 
 EMUSOUNDOBJS = \
 	$(EMUOBJ)/sound/filter.o \
diff -Nru src-old/emu/emucore.h src/emu/emucore.h
--- src-old/emu/emucore.h	2010-06-16 23:55:54.000000000 -0700
+++ src/emu/emucore.h	2010-08-30 08:20:58.000000000 -0700
@@ -355,6 +355,100 @@
 //  COMMON TEMPLATES
 //**************************************************************************
 
+// ======================> simple_list
+
+template<class T>
+class simple_list
+{
+	DISABLE_COPYING(simple_list);
+
+	T *m_head;
+	T *m_tail;
+	resource_pool &m_pool;
+	int m_count;
+
+public:
+	simple_list(resource_pool &pool = global_resource_pool) :
+		m_head(NULL),
+		m_tail(NULL),
+		m_pool(pool),
+		m_count(0) { }
+
+	virtual ~simple_list() { reset(); }
+
+	T *first() const { return m_head; }
+	T *last() const { return m_tail; }
+	int count() const { return m_count; }
+
+	void reset() { while (m_head != NULL) remove(*m_head); }
+
+	int index(T *object) const
+	{
+		int num = 0;
+		for (T *cur = m_head; cur != NULL; cur = cur->m_next)
+			if (cur == object)
+				return num;
+			else
+				num++;
+		return -1;
+	}
+
+	T &prepend(T &object)
+	{
+		object.m_next = m_head;
+		m_head = &object;
+		if (m_tail == NULL)
+			m_tail = m_head;
+		m_count++;
+		return object;
+	}
+
+	T &append(T &object)
+	{
+		object.m_next = NULL;
+		if (m_tail != NULL)
+			m_tail = m_tail->m_next = &object;
+		else
+			m_tail = m_head = &object;
+		m_count++;
+		return object;
+	}
+
+	void detach(T &object)
+	{
+		T *prev = NULL;
+		for (T *cur = m_head; cur != NULL; prev = cur, cur = cur->m_next)
+			if (cur == &object)
+			{
+				if (prev != NULL)
+					prev->m_next = object.m_next;
+				else
+					m_head = object.m_next;
+				if (m_tail == &object)
+					m_tail = prev;
+				m_count--;
+				return;
+			}
+	}
+
+	void remove(T &object)
+	{
+		detach(object);
+		pool_free(m_pool, &object);
+	}
+
+	T *find(int index) const
+	{
+		for (T *cur = m_head; cur != NULL; cur = cur->m_next)
+			if (index-- == 0)
+				return cur;
+		return NULL;
+	}
+};
+
+
+// ======================> tagged_list
+
 template<class T>
 class tagged_list
 {
diff -Nru src-old/emu/image.c src/emu/image.c
--- src-old/emu/image.c	2010-08-04 00:49:46.000000000 -0700
+++ src/emu/image.c	2010-08-26 08:21:19.000000000 -0700
@@ -517,10 +517,10 @@
 	device_config *devconfig = type(*config, owner->subtag(tempstring,tag), &owner->baseconfig(), clock);
 	running_device *device = device_list->append(devconfig->tag(), devconfig->alloc_device(*owner->machine));
 
-	const machine_config_token *tokens = device->machine_config_tokens();
-	if (tokens != NULL)
+	machine_config_constructor machconfig = device->machine_config_additions();
+	if (machconfig != NULL)
     {
-		config->detokenize(tokens,devconfig);
+    	(*machconfig)(*config, devconfig);
         for (const device_config *config_dev = config->m_devicelist.first(); config_dev != NULL; config_dev = config_dev->next())
         {
 			if (config_dev->owner()==devconfig) {
diff -Nru src-old/emu/info.c src/emu/info.c
--- src-old/emu/info.c	2010-07-29 00:04:19.000000000 -0700
+++ src/emu/info.c	2010-08-24 12:39:27.000000000 -0700
@@ -979,9 +979,10 @@
 
 		for ( int i = 0; i < DEVINFO_STR_SWLIST_MAX - DEVINFO_STR_SWLIST_0; i++ )
 		{
-			if ( swlist->list_name[i] && (swlist->list_type == SOFTWARE_LIST_ORIGINAL_SYSTEM))
+			if ( swlist->list_name[i] )
 			{
-				fprintf(out, "\t\t<softwarelist name=\"%s\" />\n", swlist->list_name[i] );
+				fprintf(out, "\t\t<softwarelist name=\"%s\" ", swlist->list_name[i] );
+				fprintf(out, "status=\"%s\" />\n", (swlist->list_type == SOFTWARE_LIST_ORIGINAL_SYSTEM) ? "original" : "compatible" );
 			}
 		}
 	}
@@ -1040,8 +1041,8 @@
 	if (game->description != NULL)
 		fprintf(out, "\t\t<description>%s</description>\n", xml_normalize_string(game->description));
 
-	/* print the year only if is a number */
-	if (game->year != NULL && strspn(game->year, "0123456789") == strlen(game->year))
+	/* print the year only if is a number or another allowed character (? or +) */
+	if (game->year != NULL && strspn(game->year, "0123456789?+") == strlen(game->year))
 		fprintf(out, "\t\t<year>%s</year>\n", xml_normalize_string(game->year));
 
 	/* print the manufacturer information */
@@ -1212,6 +1213,7 @@
 		"\t\t\t\t<!ATTLIST extension name CDATA #REQUIRED>\n"
 		"\t\t<!ELEMENT softwarelist EMPTY>\n"
 		"\t\t\t<!ATTLIST softwarelist name CDATA #REQUIRED>\n"
+		"\t\t\t<!ATTLIST softwarelist status (original|compatible) #REQUIRED>\n"
 #ifdef MESS
 		"\t\t<!ELEMENT ramoption (#PCDATA)>\n"
 		"\t\t\t<!ATTLIST ramoption default CDATA #IMPLIED>\n"
diff -Nru src-old/emu/inptport.c src/emu/inptport.c
--- src-old/emu/inptport.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/inptport.c	2010-08-21 15:25:58.000000000 -0700
@@ -2468,7 +2468,7 @@
 	INT32 mouse_target_y;
 	int mouse_button;
 
-profiler_mark_start(PROFILER_INPUT);
+g_profiler.start(PROFILER_INPUT);
 
 	/* record/playback information about the current frame */
 	playback_frame(machine, curtime);
@@ -2546,7 +2546,7 @@
 			}
 	}
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -4420,7 +4420,7 @@
 
 	/* verify the header against the current game */
 	if (memcmp(machine->gamedrv->name, header + 0x14, strlen(machine->gamedrv->name) + 1) != 0)
-		fatalerror("Input file is for " GAMENOUN " '%s', not for current " GAMENOUN " '%s'\n", header + 0x14, machine->gamedrv->name);
+		mame_printf_info("Input file is for " GAMENOUN " '%s', not for current " GAMENOUN " '%s'\n", header + 0x14, machine->gamedrv->name);
 
 	/* enable compression */
 	mame_fcompress(portdata->playback_file, FCOMPRESS_MEDIUM);
diff -Nru src-old/emu/input.c src/emu/input.c
--- src-old/emu/input.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/input.c	2010-08-21 15:25:58.000000000 -0700
@@ -857,7 +857,7 @@
 	INT32 result = 0;
 	int curindex;
 
-	profiler_mark_start(PROFILER_INPUT);
+	g_profiler.start(PROFILER_INPUT);
 
 	/* return 0 for any disabled or invalid device classes */
 	if (devclass <= DEVICE_CLASS_INVALID || devclass >= DEVICE_CLASS_MAXIMUM || !device_list[devclass].enabled)
@@ -908,7 +908,7 @@
 	}
 
 exit:
-	profiler_mark_end();
+	g_profiler.stop();
 	return result;
 }
 
@@ -1353,7 +1353,7 @@
 		devindex[0] = 0;
 
 	/* determine the itemid part; look up in the table if we don't have a token */
-	if (item != NULL && item->token.len() != 0)
+	if (item != NULL && item->token)
 		devcode = item->token;
 	else
 	{
diff -Nru src-old/emu/inputseq.c src/emu/inputseq.c
--- src-old/emu/inputseq.c	2010-01-09 17:29:26.000000000 -0800
+++ src/emu/inputseq.c	2010-08-21 12:27:14.000000000 -0700
@@ -418,7 +418,7 @@
 		input_code code = seq->code[codenum];
 
 		/* if this is a code item which is not valid, don't copy it and remove any preceding ORs/NOTs */
-		if (!INPUT_CODE_IS_INTERNAL(code) && input_code_name(machine, codestr, code).len() == 0)
+		if (!INPUT_CODE_IS_INTERNAL(code) && !input_code_name(machine, codestr, code))
 		{
 			while (copycodenum > 0 && INPUT_CODE_IS_INTERNAL(seqcopy.code[copycodenum - 1]))
 				copycodenum--;
diff -Nru src-old/emu/machine/6522via.c src/emu/machine/6522via.c
--- src-old/emu/machine/6522via.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/6522via.c	2010-08-28 09:48:51.000000000 -0700
@@ -24,7 +24,7 @@
 
 #include "emu.h"
 #include "6522via.h"
-
+#include "devhelpr.h"
 
 /***************************************************************************
     PARAMETERS
@@ -34,70 +34,6 @@
 
 
 /***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-/******************* internal VIA data structure *******************/
-
-typedef struct _via6522_t via6522_t;
-struct _via6522_t
-{
-	devcb_resolved_read8 in_a_func;
-	devcb_resolved_read8 in_b_func;
-	devcb_resolved_read_line in_ca1_func;
-	devcb_resolved_read_line in_cb1_func;
-	devcb_resolved_read_line in_ca2_func;
-	devcb_resolved_read_line in_cb2_func;
-	devcb_resolved_write8 out_a_func;
-	devcb_resolved_write8 out_b_func;
-	devcb_resolved_write_line out_ca1_func;
-	devcb_resolved_write_line out_cb1_func;
-	devcb_resolved_write_line out_ca2_func;
-	devcb_resolved_write_line out_cb2_func;
-	devcb_resolved_write_line irq_func;
-
-	UINT8 in_a;
-	UINT8 in_ca1;
-	UINT8 in_ca2;
-	UINT8 out_a;
-	UINT8 out_ca2;
-	UINT8 ddr_a;
-
-	UINT8 in_b;
-	UINT8 in_cb1;
-	UINT8 in_cb2;
-	UINT8 out_b;
-	UINT8 out_cb2;
-	UINT8 ddr_b;
-
-	UINT8 t1cl;
-	UINT8 t1ch;
-	UINT8 t1ll;
-	UINT8 t1lh;
-	UINT8 t2cl;
-	UINT8 t2ch;
-	UINT8 t2ll;
-	UINT8 t2lh;
-
-	UINT8 sr;
-	UINT8 pcr;
-	UINT8 acr;
-	UINT8 ier;
-	UINT8 ifr;
-
-	emu_timer *t1;
-	attotime time1;
-	UINT8 t1_active;
-	emu_timer *t2;
-	attotime time2;
-	UINT8 t2_active;
-
-	emu_timer *shift_timer;
-	UINT8 shift_counter;
-};
-
-
-/***************************************************************************
     MACROS
 ***************************************************************************/
 
@@ -159,140 +95,203 @@
 #define INT_T1	0x40
 #define INT_ANY	0x80
 
-#define CLR_PA_INT(device)	via_clear_int (device, INT_CA1 | ((!CA2_IND_IRQ(get_token(device)->pcr)) ? INT_CA2: 0))
-#define CLR_PB_INT(device)	via_clear_int (device, INT_CB1 | ((!CB2_IND_IRQ(get_token(device)->pcr)) ? INT_CB2: 0))
+#define CLR_PA_INT()	clear_int(INT_CA1 | ((!CA2_IND_IRQ(m_pcr)) ? INT_CA2: 0))
+#define CLR_PB_INT()	clear_int(INT_CB1 | ((!CB2_IND_IRQ(m_pcr)) ? INT_CB2: 0))
 
 #define IFR_DELAY 3
 
-#define TIMER1_VALUE(v) (v->t1ll+(v->t1lh<<8))
-#define TIMER2_VALUE(v) (v->t2ll+(v->t2lh<<8))
+#define TIMER1_VALUE    (m_t1ll+(m_t1lh<<8))
+#define TIMER2_VALUE    (m_t2ll+(m_t2lh<<8))
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
 
-static TIMER_CALLBACK( via_shift_callback );
-static TIMER_CALLBACK( via_t1_timeout );
-static TIMER_CALLBACK( via_t2_timeout );
 
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+GENERIC_DEVICE_CONFIG_SETUP(via6522, "6522 VIA")
 
-INLINE via6522_t *get_token(running_device *device)
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void via6522_device_config::device_config_complete()
 {
-	assert(device != NULL);
-	assert((device->type() == VIA6522));
-	return (via6522_t *) downcast<legacy_device_base *>(device)->token();
+	// inherit a copy of the static data
+	const via6522_interface *intf = reinterpret_cast<const via6522_interface *>(static_config());
+	if (intf != NULL)
+		*static_cast<via6522_interface *>(this) = *intf;
+
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_in_a_func, 0, sizeof(m_in_a_func));
+    	memset(&m_in_b_func, 0, sizeof(m_in_b_func));
+    	memset(&m_in_ca1_func, 0, sizeof(m_in_ca1_func));
+    	memset(&m_in_cb1_func, 0, sizeof(m_in_cb1_func));
+    	memset(&m_in_ca2_func, 0, sizeof(m_in_ca2_func));
+    	memset(&m_in_cb2_func, 0, sizeof(m_in_cb2_func));
+    	memset(&m_out_a_func, 0, sizeof(m_out_a_func));
+    	memset(&m_out_b_func, 0, sizeof(m_out_b_func));
+    	memset(&m_out_ca2_func, 0, sizeof(m_out_ca2_func));
+    	memset(&m_out_cb2_func, 0, sizeof(m_out_cb2_func));
+    	memset(&m_irq_func, 0, sizeof(m_irq_func));
+	}
 }
 
 
-INLINE const via6522_interface *get_interface(running_device *device)
-{
-	assert(device != NULL);
-	assert((device->type() == VIA6522));
-	return (const via6522_interface *) device->baseconfig().static_config();
-}
 
+/***************************************************************************
+    INLINE FUNCTIONS
+***************************************************************************/
 
-INLINE attotime v_cycles_to_time(running_device *device, int c)
+attotime via6522_device::cycles_to_time(int c)
 {
-	return attotime_mul(ATTOTIME_IN_HZ(device->clock()), c);
+	return attotime_mul(ATTOTIME_IN_HZ(clock()), c);
 }
 
 
-INLINE UINT32 v_time_to_cycles(running_device *device, attotime t)
+UINT32 via6522_device::time_to_cycles(attotime t)
 {
-	return attotime_to_double(attotime_mul(t, device->clock()));
+	return attotime_to_double(attotime_mul(t, clock()));
 }
 
 
-INLINE UINT16 v_get_counter1_value(running_device *device)
+UINT16 via6522_device::get_counter1_value()
 {
-	via6522_t *v = get_token(device);
 	UINT16 val;
 
-	if (v->t1_active) {
-		val = v_time_to_cycles(device, timer_timeleft(v->t1)) - IFR_DELAY;
-	} else {
-		val = 0xFFFF - v_time_to_cycles(device, attotime_sub(timer_get_time(device->machine), v->time1));
+    if(m_t1_active)
+    {
+        val = time_to_cycles(timer_timeleft(m_t1)) - IFR_DELAY;
+	}
+    else
+    {
+        val = 0xffff - time_to_cycles(attotime_sub(timer_get_time(&m_machine), m_time1));
 	}
+
 	return val;
 }
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    DEVICE_START( via6522 )
--------------------------------------------------*/
-
-static DEVICE_START( via6522 )
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type VIA6522 = via6522_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  via6522_device - constructor
+//-------------------------------------------------
+
+via6522_device::via6522_device(running_machine &_machine, const via6522_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	via6522_t *v = get_token(device);
-	const via6522_interface *intf = get_interface(device);
 
-	memset(v, 0, sizeof(*v));
+}
 
-	devcb_resolve_read8(&v->in_a_func, &intf->in_a_func, device);
-	devcb_resolve_read8(&v->in_b_func, &intf->in_b_func, device);
-	devcb_resolve_read_line(&v->in_ca1_func, &intf->in_ca1_func, device);
-	devcb_resolve_read_line(&v->in_cb1_func, &intf->in_cb1_func, device);
-	devcb_resolve_read_line(&v->in_ca2_func, &intf->in_ca2_func, device);
-	devcb_resolve_read_line(&v->in_cb2_func, &intf->in_cb2_func, device);
-	devcb_resolve_write8(&v->out_a_func, &intf->out_a_func, device);
-	devcb_resolve_write8(&v->out_b_func, &intf->out_b_func, device);
-	devcb_resolve_write_line(&v->out_ca1_func, &intf->out_ca1_func, device);
-	devcb_resolve_write_line(&v->out_cb1_func, &intf->out_cb1_func, device);
-	devcb_resolve_write_line(&v->out_ca2_func, &intf->out_ca2_func, device);
-	devcb_resolve_write_line(&v->out_cb2_func, &intf->out_cb2_func, device);
-	devcb_resolve_write_line(&v->irq_func, &intf->irq_func, device);
-
-	v->t1ll = 0xf3; /* via at 0x9110 in vic20 show these values */
-	v->t1lh = 0xb5; /* ports are not written by kernel! */
-	v->t2ll = 0xff; /* taken from vice */
-	v->t2lh = 0xff;
-	v->time2 = v->time1 = timer_get_time(device->machine);
-	v->t1 = timer_alloc(device->machine, via_t1_timeout, (void *) device);
-	v->t2 = timer_alloc(device->machine, via_t2_timeout, (void *) device);
-	v->shift_timer = timer_alloc(device->machine, via_shift_callback, (void *) device);
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void via6522_device::device_start()
+{
+    devcb_resolve_read8(&m_in_a_func, &m_config.m_in_a_func, this);
+    devcb_resolve_read8(&m_in_b_func, &m_config.m_in_b_func, this);
+    devcb_resolve_read_line(&m_in_ca1_func, &m_config.m_in_ca1_func, this);
+    devcb_resolve_read_line(&m_in_cb1_func, &m_config.m_in_cb1_func, this);
+    devcb_resolve_read_line(&m_in_ca2_func, &m_config.m_in_ca2_func, this);
+    devcb_resolve_read_line(&m_in_cb2_func, &m_config.m_in_cb2_func, this);
+    devcb_resolve_write8(&m_out_a_func, &m_config.m_out_a_func, this);
+    devcb_resolve_write8(&m_out_b_func, &m_config.m_out_b_func, this);
+    devcb_resolve_write_line(&m_out_ca1_func, &m_config.m_out_ca1_func, this);
+    devcb_resolve_write_line(&m_out_cb1_func, &m_config.m_out_cb1_func, this);
+    devcb_resolve_write_line(&m_out_ca2_func, &m_config.m_out_ca2_func, this);
+    devcb_resolve_write_line(&m_out_cb2_func, &m_config.m_out_cb2_func, this);
+    devcb_resolve_write_line(&m_irq_func, &m_config.m_irq_func, this);
+
+    m_t1ll = 0xf3; /* via at 0x9110 in vic20 show these values */
+    m_t1lh = 0xb5; /* ports are not written by kernel! */
+    m_t2ll = 0xff; /* taken from vice */
+    m_t2lh = 0xff;
+    m_time2 = m_time1 = timer_get_time(&m_machine);
+    m_t1 = timer_alloc(&m_machine, t1_timeout_callback, (void *)this);
+    m_t2 = timer_alloc(&m_machine, t2_timeout_callback, (void *)this);
+    m_shift_timer = timer_alloc(&m_machine, shift_callback, (void *)this);
 
 	/* Default clock is from CPU1 */
-	if (device->clock() == 0)
-		device->set_unscaled_clock(device->machine->firstcpu->clock());
+	if (clock() == 0)
+    {
+		set_unscaled_clock(m_machine.firstcpu->clock());
+    }
 
 	/* save state register */
-	state_save_register_device_item(device, 0, v->in_a);
-	state_save_register_device_item(device, 0, v->in_ca1);
-	state_save_register_device_item(device, 0, v->in_ca2);
-	state_save_register_device_item(device, 0, v->out_a);
-	state_save_register_device_item(device, 0, v->out_ca2);
-	state_save_register_device_item(device, 0, v->ddr_a);
-	state_save_register_device_item(device, 0, v->in_b);
-	state_save_register_device_item(device, 0, v->in_cb1);
-	state_save_register_device_item(device, 0, v->in_cb2);
-	state_save_register_device_item(device, 0, v->out_b);
-	state_save_register_device_item(device, 0, v->out_cb2);
-	state_save_register_device_item(device, 0, v->ddr_b);
-	state_save_register_device_item(device, 0, v->t1cl);
-	state_save_register_device_item(device, 0, v->t1ch);
-	state_save_register_device_item(device, 0, v->t1ll);
-	state_save_register_device_item(device, 0, v->t1lh);
-	state_save_register_device_item(device, 0, v->t2cl);
-	state_save_register_device_item(device, 0, v->t2ch);
-	state_save_register_device_item(device, 0, v->t2ll);
-	state_save_register_device_item(device, 0, v->t2lh);
-	state_save_register_device_item(device, 0, v->sr);
-	state_save_register_device_item(device, 0, v->pcr);
-	state_save_register_device_item(device, 0, v->acr);
-	state_save_register_device_item(device, 0, v->ier);
-	state_save_register_device_item(device, 0, v->ifr);
-	state_save_register_device_item(device, 0, v->t1_active);
-	state_save_register_device_item(device, 0, v->t2_active);
-	state_save_register_device_item(device, 0, v->shift_counter);
+    state_save_register_device_item(this, 0, m_in_a);
+    state_save_register_device_item(this, 0, m_in_ca1);
+    state_save_register_device_item(this, 0, m_in_ca2);
+    state_save_register_device_item(this, 0, m_out_a);
+    state_save_register_device_item(this, 0, m_out_ca2);
+    state_save_register_device_item(this, 0, m_ddr_a);
+    state_save_register_device_item(this, 0, m_in_b);
+    state_save_register_device_item(this, 0, m_in_cb1);
+    state_save_register_device_item(this, 0, m_in_cb2);
+    state_save_register_device_item(this, 0, m_out_b);
+    state_save_register_device_item(this, 0, m_out_cb2);
+    state_save_register_device_item(this, 0, m_ddr_b);
+    state_save_register_device_item(this, 0, m_t1cl);
+    state_save_register_device_item(this, 0, m_t1ch);
+    state_save_register_device_item(this, 0, m_t1ll);
+    state_save_register_device_item(this, 0, m_t1lh);
+    state_save_register_device_item(this, 0, m_t2cl);
+    state_save_register_device_item(this, 0, m_t2ch);
+    state_save_register_device_item(this, 0, m_t2ll);
+    state_save_register_device_item(this, 0, m_t2lh);
+    state_save_register_device_item(this, 0, m_sr);
+    state_save_register_device_item(this, 0, m_pcr);
+    state_save_register_device_item(this, 0, m_acr);
+    state_save_register_device_item(this, 0, m_ier);
+    state_save_register_device_item(this, 0, m_ifr);
+    state_save_register_device_item(this, 0, m_t1_active);
+    state_save_register_device_item(this, 0, m_t2_active);
+    state_save_register_device_item(this, 0, m_shift_counter);
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void via6522_device::device_reset()
+{
+    m_in_a = 0;
+    m_in_ca1 = 0;
+    m_in_ca2 = 0;
+    m_out_a = 0;
+    m_out_ca2 = 0;
+    m_ddr_a = 0;
+    m_in_b = 0;
+    m_in_cb1 = 0;
+    m_in_cb2 = 0;
+    m_out_b = 0;
+    m_out_cb2 = 0;
+    m_ddr_b = 0;
+
+    m_t1cl = 0;
+    m_t1ch = 0;
+    m_t2cl = 0;
+    m_t2ch = 0;
+
+    m_sr = 0;
+    m_pcr = 0;
+    m_acr = 0;
+    m_ier = 0;
+    m_ifr = 0;
+    m_t1_active = 0;
+    m_t2_active = 0;
+    m_shift_counter = 0;
 }
 
 
@@ -300,18 +299,18 @@
     via_set_int - external interrupt check
 -------------------------------------------------*/
 
-static void via_set_int (running_device *device, int data)
+void via6522_device::set_int(int data)
 {
-	via6522_t *v = get_token(device);
-
-	v->ifr |= data;
+	m_ifr |= data;
 	if (TRACE_VIA)
-		logerror("%s:6522VIA chip %s: IFR = %02X\n", cpuexec_describe_context(device->machine), device->tag(), v->ifr);
+    {
+		logerror("%s:6522VIA chip %s: IFR = %02X\n", cpuexec_describe_context(&m_machine), tag(), m_ifr);
+    }
 
-	if (v->ier & v->ifr)
+	if (m_ier & m_ifr)
     {
-		v->ifr |= INT_ANY;
-		devcb_call_write_line(&v->irq_func, ASSERT_LINE);
+		m_ifr |= INT_ANY;
+		devcb_call_write_line(&m_irq_func, ASSERT_LINE);
     }
 }
 
@@ -320,20 +319,22 @@
     via_clear_int - external interrupt check
 -------------------------------------------------*/
 
-static void via_clear_int (running_device *device, int data)
+void via6522_device::clear_int(int data)
 {
-	via6522_t *v = get_token(device);
-
-	v->ifr = (v->ifr & ~data) & 0x7f;
+	m_ifr = (m_ifr & ~data) & 0x7f;
 
 	if (TRACE_VIA)
-		logerror("%s:6522VIA chip %s: IFR = %02X\n", cpuexec_describe_context(device->machine), device->tag(), v->ifr);
+    {
+		logerror("%s:6522VIA chip %s: IFR = %02X\n", cpuexec_describe_context(&m_machine), tag(), m_ifr);
+    }
 
-	if (v->ifr & v->ier)
-		v->ifr |= INT_ANY;
+	if (m_ifr & m_ier)
+    {
+		m_ifr |= INT_ANY;
+    }
 	else
 	{
-		devcb_call_write_line(&v->irq_func, CLEAR_LINE);
+		devcb_call_write_line(&m_irq_func, CLEAR_LINE);
 	}
 }
 
@@ -342,62 +343,72 @@
     via_shift
 -------------------------------------------------*/
 
-static void via_shift(running_device *device)
+void via6522_device::shift()
 {
-	via6522_t *v = get_token(device);
-
-	if (SO_O2_CONTROL(v->acr))
+	if (SO_O2_CONTROL(m_acr) || SO_T2_CONTROL(m_acr))
 	{
-		v->out_cb2 = (v->sr >> 7) & 1;
-		v->sr =  (v->sr << 1) | v->out_cb2;
+		m_out_cb2 = (m_sr >> 7) & 1;
+		m_sr =  (m_sr << 1) | m_out_cb2;
 
-		devcb_call_write_line(&v->out_cb2_func, v->out_cb2);
+		devcb_call_write_line(&m_out_cb2_func, m_out_cb2);
 
-		v->in_cb1=1;
+		m_in_cb1=1;
 
 		/* this should be one cycle wide */
-		devcb_call_write_line(&v->out_cb1_func, 0);
-		devcb_call_write_line(&v->out_cb1_func, 1);
+		devcb_call_write_line(&m_out_cb1_func, 0);
+		devcb_call_write_line(&m_out_cb1_func, 1);
 
-		v->shift_counter = (v->shift_counter + 1) % 8;
+		m_shift_counter = (m_shift_counter + 1) % 8;
 
-		if (v->shift_counter)
-			timer_adjust_oneshot(v->shift_timer, v_cycles_to_time(device, 2), 0);
+		if (m_shift_counter)
+        {
+			if (SO_O2_CONTROL(m_acr)) {
+				timer_adjust_oneshot(m_shift_timer, cycles_to_time(2), 0);
+			} else {
+				timer_adjust_oneshot(m_shift_timer, cycles_to_time((m_t2ll + 2)*2), 0);
+			}
+        }
 		else
 		{
-			if (!(v->ifr & INT_SR))
-				via_set_int(device, INT_SR);
+			if (!(m_ifr & INT_SR))
+            {
+				set_int(INT_SR);
+            }
 		}
 	}
-	if (SO_EXT_CONTROL(v->acr))
+	if (SO_EXT_CONTROL(m_acr))
 	{
-		v->out_cb2 = (v->sr >> 7) & 1;
-		v->sr =  (v->sr << 1) | v->out_cb2;
+        m_out_cb2 = (m_sr >> 7) & 1;
+        m_sr =  (m_sr << 1) | m_out_cb2;
 
-		devcb_call_write_line(&v->out_cb2_func, v->out_cb2);
+        devcb_call_write_line(&m_out_cb2_func, m_out_cb2);
 
-		v->shift_counter = (v->shift_counter + 1) % 8;
+        m_shift_counter = (m_shift_counter + 1) % 8;
 
-		if (v->shift_counter == 0)
+        if (m_shift_counter == 0)
 		{
-			if (!(v->ifr & INT_SR))
-				via_set_int(device, INT_SR);
+            if (!(m_ifr & INT_SR))
+            {
+				set_int(INT_SR);
+            }
 		}
 	}
-	if (SI_EXT_CONTROL(v->acr))
+    if (SI_EXT_CONTROL(m_acr))
 	{
-		if (v->in_cb2_func.read != NULL)
-			v->in_cb2 = devcb_call_read_line(&v->in_cb2_func);
+        if (m_in_cb2_func.read != NULL)
+        {
+            m_in_cb2 = devcb_call_read_line(&m_in_cb2_func);
+        }
 
-		v->sr =  (v->sr << 1) | (v->in_cb2 & 1);
+        m_sr =  (m_sr << 1) | (m_in_cb2 & 1);
 
-		v->shift_counter = (v->shift_counter + 1) % 8;
+        m_shift_counter = (m_shift_counter + 1) % 8;
 
-		if (v->shift_counter == 0)
+        if (m_shift_counter == 0)
 		{
-			if (!(v->ifr & INT_SR))
+            if (!(m_ifr & INT_SR))
 			{
-				via_set_int(device, INT_SR);
+				set_int(INT_SR);
 			}
 		}
 	}
@@ -408,10 +419,10 @@
     TIMER_CALLBACK( via_shift_callback )
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( via_shift_callback )
+TIMER_CALLBACK( via6522_device::shift_callback )
 {
-	running_device *device = (running_device *)ptr;
-	via_shift(device);
+    via6522_device *via = reinterpret_cast<via6522_device *>(ptr);
+    via->shift();
 }
 
 
@@ -419,32 +430,41 @@
     TIMER_CALLBACK( via_t1_timeout )
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( via_t1_timeout )
+TIMER_CALLBACK( via6522_device::t1_timeout_callback )
 {
-	running_device *device = (running_device *)ptr;
-	via6522_t *v = get_token(device);
+    via6522_device *via = reinterpret_cast<via6522_device *>(ptr);
+    via->t1_timeout();
+}
 
-	if (T1_CONTINUOUS (v->acr))
+void via6522_device::t1_timeout()
+{
+    if (T1_CONTINUOUS (m_acr))
     {
-		if (T1_SET_PB7(v->acr))
-			v->out_b ^= 0x80;
-		timer_adjust_oneshot(v->t1, v_cycles_to_time(device, TIMER1_VALUE(v) + IFR_DELAY), 0);
+        if (T1_SET_PB7(m_acr))
+        {
+            m_out_b ^= 0x80;
+        }
+        timer_adjust_oneshot(m_t1, cycles_to_time(TIMER1_VALUE + IFR_DELAY), 0);
     }
 	else
     {
-		if (T1_SET_PB7(v->acr))
-			v->out_b |= 0x80;
-		v->t1_active = 0;
-		v->time1 = timer_get_time(device->machine);
+        if (T1_SET_PB7(m_acr))
+        {
+            m_out_b |= 0x80;
+        }
+        m_t1_active = 0;
+        m_time1 = timer_get_time(&m_machine);
     }
-	if (v->ddr_b)
+    if (m_ddr_b)
 	{
-		UINT8 write_data = (v->out_b & v->ddr_b) | (v->ddr_b ^ 0xff);
-		devcb_call_write8(&v->out_b_func, 0, write_data);
+        UINT8 write_data = (m_out_b & m_ddr_b) | (m_ddr_b ^ 0xff);
+        devcb_call_write8(&m_out_b_func, 0, write_data);
 	}
 
-	if (!(v->ifr & INT_T1))
-		via_set_int (device, INT_T1);
+    if (!(m_ifr & INT_T1))
+    {
+		set_int(INT_T1);
+    }
 }
 
 
@@ -452,52 +472,21 @@
     TIMER_CALLBACK( via_t2_timeout )
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( via_t2_timeout )
+TIMER_CALLBACK( via6522_device::t2_timeout_callback )
 {
-	running_device *device = (running_device *)ptr;
-	via6522_t *v = get_token(device);
-
-	v->t2_active = 0;
-	v->time2 = timer_get_time(device->machine);
-
-	if (!(v->ifr & INT_T2))
-		via_set_int (device, INT_T2);
+    via6522_device *via = reinterpret_cast<via6522_device *>(ptr);
+    via->t2_timeout();
 }
 
-
-/*-------------------------------------------------
-    DEVICE_RESET( via6522 )
--------------------------------------------------*/
-
-static DEVICE_RESET( via6522 )
+void via6522_device::t2_timeout()
 {
-	via6522_t *v = get_token(device);
-	v->in_a = 0;
-	v->in_ca1 = 0;
-	v->in_ca2 = 0;
-	v->out_a = 0;
-	v->out_ca2 = 0;
-	v->ddr_a = 0;
-	v->in_b = 0;
-	v->in_cb1 = 0;
-	v->in_cb2 = 0;
-	v->out_b = 0;
-	v->out_cb2 = 0;
-	v->ddr_b = 0;
-
-	v->t1cl = 0;
-	v->t1ch = 0;
-	v->t2cl = 0;
-	v->t2ch = 0;
-
-	v->sr = 0;
-	v->pcr = 0;
-	v->acr = 0;
-	v->ier = 0;
-	v->ifr = 0;
-	v->t1_active = 0;
-	v->t2_active = 0;
-	v->shift_counter = 0;
+    m_t2_active = 0;
+    m_time2 = timer_get_time(&m_machine);
+
+    if (!(m_ifr & INT_T2))
+    {
+		set_int(INT_T2);
+    }
 }
 
 
@@ -505,9 +494,8 @@
     via_r - CPU interface for VIA read
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER(via_r)
+READ8_DEVICE_HANDLER_TRAMPOLINE(via6522, via_r)
 {
-	via6522_t *v = get_token(device);
 	int val = 0;
 
 	offset &= 0xf;
@@ -516,55 +504,67 @@
     {
     case VIA_PB:
 		/* update the input */
-		if (PB_LATCH_ENABLE(v->acr) == 0)
+        if (PB_LATCH_ENABLE(m_acr) == 0)
 		{
-			if (v->ddr_b != 0xff)
+			if (m_ddr_b != 0xff)
 			{
-				if (v->in_b_func.read != NULL)
-					v->in_b = devcb_call_read8(&v->in_b_func, 0);
+				if (m_in_b_func.read != NULL)
+                {
+					m_in_b = devcb_call_read8(&m_in_b_func, 0);
+                }
 				else
-					logerror("%s:6522VIA chip %s: Port B is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag());
+                {
+					logerror("%s:6522VIA chip %s: Port B is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag());
+                }
 			}
 		}
 
-		CLR_PB_INT(device);
+		CLR_PB_INT();
 
 		/* combine input and output values, hold DDRB bit 7 high if T1_SET_PB7 */
-		if (T1_SET_PB7(v->acr))
-			val = (v->out_b & (v->ddr_b | 0x80)) | (v->in_b & ~(v->ddr_b | 0x80));
+		if (T1_SET_PB7(m_acr))
+        {
+			val = (m_out_b & (m_ddr_b | 0x80)) | (m_in_b & ~(m_ddr_b | 0x80));
+        }
 		else
-			val = (v->out_b & v->ddr_b) + (v->in_b & ~v->ddr_b);
+        {
+			val = (m_out_b & m_ddr_b) + (m_in_b & ~m_ddr_b);
+        }
 		break;
 
     case VIA_PA:
 		/* update the input */
-		if (PA_LATCH_ENABLE(v->acr) == 0)
+		if (PA_LATCH_ENABLE(m_acr) == 0)
 		{
-			if (v->ddr_a != 0xff)
+			if (m_ddr_a != 0xff)
 			{
-				if (v->in_a_func.read != NULL)
-					v->in_a = devcb_call_read8(&v->in_a_func, 0);
+				if (m_in_a_func.read != NULL)
+                {
+					m_in_a = devcb_call_read8(&m_in_a_func, 0);
+                }
 				else
-					logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag());
+                {
+					logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag());
+                }
 			}
 		}
 
 		/* combine input and output values */
-		val = (v->out_a & v->ddr_a) + (v->in_a & ~v->ddr_a);
+		val = (m_out_a & m_ddr_a) + (m_in_a & ~m_ddr_a);
 
-		CLR_PA_INT(device);
+		CLR_PA_INT();
 
 		/* If CA2 is configured as output and in pulse or handshake mode,
            CA2 is set now */
-		if (CA2_AUTO_HS(v->pcr))
+		if (CA2_AUTO_HS(m_pcr))
 		{
-			if (v->out_ca2)
+			if (m_out_ca2)
 			{
 				/* set CA2 */
-				v->out_ca2 = 0;
+				m_out_ca2 = 0;
 
 				/* call the CA2 output function */
-				devcb_call_write_line(&v->out_ca2_func, 0);
+				devcb_call_write_line(&m_out_ca2_func, 0);
 			}
 		}
 
@@ -572,92 +572,113 @@
 
     case VIA_PANH:
 		/* update the input */
-		if (PA_LATCH_ENABLE(v->acr) == 0)
+		if (PA_LATCH_ENABLE(m_acr) == 0)
 		{
-			if (v->in_a_func.read != NULL)
-				v->in_a = devcb_call_read8(&v->in_a_func, 0);
+			if (m_in_a_func.read != NULL)
+            {
+				m_in_a = devcb_call_read8(&m_in_a_func, 0);
+            }
 			else
-				logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag());
+            {
+				logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag());
+            }
 		}
 
 		/* combine input and output values */
-		val = (v->out_a & v->ddr_a) + (v->in_a & ~v->ddr_a);
+		val = (m_out_a & m_ddr_a) + (m_in_a & ~m_ddr_a);
 		break;
 
     case VIA_DDRB:
-		val = v->ddr_b;
+		val = m_ddr_b;
 		break;
 
     case VIA_DDRA:
-		val = v->ddr_a;
+		val = m_ddr_a;
 		break;
 
     case VIA_T1CL:
-		via_clear_int (device, INT_T1);
-		val = v_get_counter1_value(device) & 0xFF;
+		clear_int(INT_T1);
+		val = get_counter1_value() & 0xFF;
 		break;
 
     case VIA_T1CH:
-		val = v_get_counter1_value(device) >> 8;
+		val = get_counter1_value() >> 8;
 		break;
 
     case VIA_T1LL:
-		val = v->t1ll;
+		val = m_t1ll;
 		break;
 
     case VIA_T1LH:
-		val = v->t1lh;
+		val = m_t1lh;
 		break;
 
     case VIA_T2CL:
-		via_clear_int (device, INT_T2);
-		if (v->t2_active)
-			val = v_time_to_cycles(device, timer_timeleft(v->t2)) & 0xff;
+		clear_int(INT_T2);
+		if (m_t2_active)
+        {
+			val = time_to_cycles(timer_timeleft(m_t2)) & 0xff;
+        }
 		else
 		{
-			if (T2_COUNT_PB6(v->acr))
-				val = v->t2cl;
+			if (T2_COUNT_PB6(m_acr))
+            {
+				val = m_t2cl;
+            }
 			else
-				val = (0x10000- (v_time_to_cycles(device, attotime_sub(timer_get_time(device->machine), v->time2)) & 0xffff) - 1) & 0xff;
+            {
+				val = (0x10000 - (time_to_cycles(attotime_sub(timer_get_time(&m_machine), m_time2)) & 0xffff) - 1) & 0xff;
+            }
 		}
 		break;
 
     case VIA_T2CH:
-		if (v->t2_active)
-			val = v_time_to_cycles(device, timer_timeleft(v->t2)) >> 8;
+		if (m_t2_active)
+        {
+			val = time_to_cycles(timer_timeleft(m_t2)) >> 8;
+        }
 		else
 		{
-			if (T2_COUNT_PB6(v->acr))
-				val = v->t2ch;
+			if (T2_COUNT_PB6(m_acr))
+            {
+				val = m_t2ch;
+            }
 			else
-				val = (0x10000- (v_time_to_cycles(device, attotime_sub(timer_get_time(device->machine), v->time2)) & 0xffff) - 1) >> 8;
+            {
+				val = (0x10000 - (time_to_cycles(attotime_sub(timer_get_time(&m_machine), m_time2)) & 0xffff) - 1) >> 8;
+            }
 		}
 		break;
 
     case VIA_SR:
-		val = v->sr;
-		via_clear_int(device, INT_SR);
-		if (SO_O2_CONTROL(v->acr))
+		val = m_sr;
+		clear_int(INT_SR);
+		if (SO_O2_CONTROL(m_acr))
+		{
+			m_shift_counter=0;
+			timer_adjust_oneshot(m_shift_timer, cycles_to_time(2), 0);
+		}
+		if (SO_T2_CONTROL(m_acr))
 		{
-			v->shift_counter=0;
-			timer_adjust_oneshot(v->shift_timer, v_cycles_to_time(device, 2), 0);
+			m_shift_counter=0;
+			timer_adjust_oneshot(m_shift_timer, cycles_to_time((m_t2ll + 2)*2), 0);
 		}
 		break;
 
     case VIA_PCR:
-		val = v->pcr;
+		val = m_pcr;
 		break;
 
     case VIA_ACR:
-		val = v->acr;
+		val = m_acr;
 		break;
 
     case VIA_IER:
-		val = v->ier | 0x80;
+		val = m_ier | 0x80;
 		break;
 
     case VIA_IFR:
-		val = v->ifr;
+		val = m_ifr;
 		break;
     }
 	return val;
@@ -668,519 +689,431 @@
     via_w - CPU interface for VIA write
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER(via_w)
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(via6522, via_w)
 {
-	via6522_t *v = get_token(device);
-
 	offset &=0x0f;
 
 	switch (offset)
     {
     case VIA_PB:
-		if (T1_SET_PB7(v->acr))
-			v->out_b = (v->out_b & 0x80) | (data  & 0x7f);
+		if (T1_SET_PB7(m_acr))
+			m_out_b = (m_out_b & 0x80) | (data  & 0x7f);
 		else
-			v->out_b = data;
+			m_out_b = data;
 
-		if (v->ddr_b)
+		if (m_ddr_b)
 		{
-			UINT8 write_data = (v->out_b & v->ddr_b) | (v->ddr_b ^ 0xff);
-			devcb_call_write8(&v->out_b_func, 0, write_data);
+			UINT8 write_data = (m_out_b & m_ddr_b) | (m_ddr_b ^ 0xff);
+			devcb_call_write8(&m_out_b_func, 0, write_data);
 		}
 
-		CLR_PB_INT(device);
+		CLR_PB_INT();
 
 		/* If CB2 is configured as output and in pulse or handshake mode,
            CB2 is set now */
-		if (CB2_AUTO_HS(v->pcr))
+		if (CB2_AUTO_HS(m_pcr))
 		{
-			if (v->out_cb2)
+			if (m_out_cb2)
 			{
 				/* set CB2 */
-				v->out_cb2 = 0;
+				m_out_cb2 = 0;
 
 				/* call the CB2 output function */
-				devcb_call_write_line(&v->out_cb2_func, 0);
+				devcb_call_write_line(&m_out_cb2_func, 0);
 			}
 		}
 		break;
 
     case VIA_PA:
-		v->out_a = data;
+		m_out_a = data;
 
-		if (v->ddr_a)
+		if (m_ddr_a)
 		{
-			UINT8 write_data = (v->out_a & v->ddr_a) | (v->ddr_a ^ 0xff);
-			devcb_call_write8(&v->out_a_func, 0, write_data);
+			UINT8 write_data = (m_out_a & m_ddr_a) | (m_ddr_a ^ 0xff);
+			devcb_call_write8(&m_out_a_func, 0, write_data);
 		}
 
-		CLR_PA_INT(device);
+		CLR_PA_INT();
 
 		/* If CA2 is configured as output and in pulse or handshake mode,
            CA2 is set now */
-		if (CA2_PULSE_OUTPUT(v->pcr))
+		if (CA2_PULSE_OUTPUT(m_pcr))
 		{
 			/* call the CA2 output function */
-			devcb_call_write_line(&v->out_ca2_func, 0);
-			devcb_call_write_line(&v->out_ca2_func, 1);
+			devcb_call_write_line(&m_out_ca2_func, 0);
+			devcb_call_write_line(&m_out_ca2_func, 1);
 
 			/* set CA2 (shouldn't be needed) */
-			v->out_ca2 = 1;
+			m_out_ca2 = 1;
 		}
-		else if (CA2_AUTO_HS(v->pcr))
+		else if (CA2_AUTO_HS(m_pcr))
 		{
-			if (v->out_ca2)
+			if (m_out_ca2)
 			{
 				/* set CA2 */
-				v->out_ca2 = 0;
+				m_out_ca2 = 0;
 
 				/* call the CA2 output function */
-				devcb_call_write_line(&v->out_ca2_func, 0);
+				devcb_call_write_line(&m_out_ca2_func, 0);
 			}
 		}
 
 		break;
 
     case VIA_PANH:
-		v->out_a = data;
+		m_out_a = data;
 
-		if (v->ddr_a)
+		if (m_ddr_a)
 		{
-			UINT8 write_data = (v->out_a & v->ddr_a) | (v->ddr_a ^ 0xff);
-			devcb_call_write8(&v->out_a_func, 0, write_data);
+			UINT8 write_data = (m_out_a & m_ddr_a) | (m_ddr_a ^ 0xff);
+			devcb_call_write8(&m_out_a_func, 0, write_data);
 		}
 
 		break;
 
     case VIA_DDRB:
     	/* EHC 03/04/2000 - If data direction changed, present output on the lines */
-    	if ( data != v->ddr_b )
+    	if ( data != m_ddr_b )
     	{
-			v->ddr_b = data;
+			m_ddr_b = data;
 
-			//if (v->ddr_b)
+			//if (m_ddr_b)
 			{
-				UINT8 write_data = (v->out_b & v->ddr_b) | (v->ddr_b ^ 0xff);
-				devcb_call_write8(&v->out_b_func, 0, write_data);
+				UINT8 write_data = (m_out_b & m_ddr_b) | (m_ddr_b ^ 0xff);
+				devcb_call_write8(&m_out_b_func, 0, write_data);
 			}
 		}
 		break;
 
     case VIA_DDRA:
     	/* EHC 03/04/2000 - If data direction changed, present output on the lines */
-    	if ( data != v->ddr_a )
+    	if ( data != m_ddr_a )
     	{
-			v->ddr_a = data;
+			m_ddr_a = data;
 
-			//if (v->ddr_a)
+			//if (m_ddr_a)
 			{
-				UINT8 write_data = (v->out_a & v->ddr_a) | (v->ddr_a ^ 0xff);
-				devcb_call_write8(&v->out_a_func, 0, write_data);
+				UINT8 write_data = (m_out_a & m_ddr_a) | (m_ddr_a ^ 0xff);
+				devcb_call_write8(&m_out_a_func, 0, write_data);
 			}
 		}
 		break;
 
     case VIA_T1CL:
     case VIA_T1LL:
-		v->t1ll = data;
+		m_t1ll = data;
 		break;
 
 	case VIA_T1LH:
-	    v->t1lh = data;
-	    via_clear_int (device, INT_T1);
+	    m_t1lh = data;
+	    clear_int(INT_T1);
 	    break;
 
     case VIA_T1CH:
-		v->t1ch = v->t1lh = data;
-		v->t1cl = v->t1ll;
+		m_t1ch = m_t1lh = data;
+		m_t1cl = m_t1ll;
 
-		via_clear_int (device, INT_T1);
+		clear_int(INT_T1);
 
-		if (T1_SET_PB7(v->acr))
+		if (T1_SET_PB7(m_acr))
 		{
-			v->out_b &= 0x7f;
+			m_out_b &= 0x7f;
 
-			//if (v->ddr_b)
+			//if (m_ddr_b)
 			{
-				UINT8 write_data = (v->out_b & v->ddr_b) | (v->ddr_b ^ 0xff);
-				devcb_call_write8(&v->out_b_func, 0, write_data);
+				UINT8 write_data = (m_out_b & m_ddr_b) | (m_ddr_b ^ 0xff);
+				devcb_call_write8(&m_out_b_func, 0, write_data);
 			}
 		}
-		timer_adjust_oneshot(v->t1, v_cycles_to_time(device, TIMER1_VALUE(v) + IFR_DELAY), 0);
-		v->t1_active = 1;
+		timer_adjust_oneshot(m_t1, cycles_to_time(TIMER1_VALUE + IFR_DELAY), 0);
+		m_t1_active = 1;
 		break;
 
     case VIA_T2CL:
-		v->t2ll = data;
+		m_t2ll = data;
 		break;
 
     case VIA_T2CH:
-		v->t2ch = v->t2lh = data;
-		v->t2cl = v->t2ll;
+		m_t2ch = m_t2lh = data;
+		m_t2cl = m_t2ll;
 
-		via_clear_int (device, INT_T2);
+		clear_int(INT_T2);
 
-		if (!T2_COUNT_PB6(v->acr))
+		if (!T2_COUNT_PB6(m_acr))
 		{
-			timer_adjust_oneshot(v->t2, v_cycles_to_time(device, TIMER2_VALUE(v) + IFR_DELAY), 0);
-			v->t2_active = 1;
+			timer_adjust_oneshot(m_t2, cycles_to_time(TIMER2_VALUE + IFR_DELAY), 0);
+			m_t2_active = 1;
 		}
 		else
 		{
-			v->time2 = timer_get_time(device->machine);
+			timer_adjust_oneshot(m_t2, cycles_to_time(TIMER2_VALUE), 0);
+			m_t2_active = 1;
+			m_time2 = timer_get_time(&m_machine);
 		}
 		break;
 
     case VIA_SR:
-		v->sr = data;
-		v->shift_counter=0;
-		via_clear_int(device, INT_SR);
-		if (SO_O2_CONTROL(v->acr))
+		m_sr = data;
+		m_shift_counter=0;
+		clear_int(INT_SR);
+		if (SO_O2_CONTROL(m_acr))
+		{
+			timer_set(&m_machine, cycles_to_time(2), (void *)this, 0, shift_callback);
+		}
+		if (SO_T2_CONTROL(m_acr))
 		{
-			timer_set(device->machine, v_cycles_to_time(device, 2), (void *) device, 0, via_shift_callback);
+			timer_set(&m_machine, cycles_to_time((m_t2ll + 2)*2), (void *)this, 0, shift_callback);
 		}
 		break;
 
     case VIA_PCR:
-		v->pcr = data;
+		m_pcr = data;
 
 		if (TRACE_VIA)
-			logerror("%s:6522VIA chip %s: PCR = %02X\n", cpuexec_describe_context(device->machine), device->tag(), data);
+        {
+			logerror("%s:6522VIA chip %s: PCR = %02X\n", cpuexec_describe_context(&m_machine), tag(), data);
+        }
 
-		if (CA2_FIX_OUTPUT(data) && CA2_OUTPUT_LEVEL(data) ^ v->out_ca2)
+		if (CA2_FIX_OUTPUT(data) && CA2_OUTPUT_LEVEL(data) ^ m_out_ca2)
 		{
-			v->out_ca2 = CA2_OUTPUT_LEVEL(data);
-			devcb_call_write_line(&v->out_ca2_func, v->out_ca2);
+			m_out_ca2 = CA2_OUTPUT_LEVEL(data);
+			devcb_call_write_line(&m_out_ca2_func, m_out_ca2);
 		}
 
-		if (CB2_FIX_OUTPUT(data) && CB2_OUTPUT_LEVEL(data) ^ v->out_cb2)
+		if (CB2_FIX_OUTPUT(data) && CB2_OUTPUT_LEVEL(data) ^ m_out_cb2)
 		{
-			v->out_cb2 = CB2_OUTPUT_LEVEL(data);
-			devcb_call_write_line(&v->out_cb2_func, v->out_cb2);
+			m_out_cb2 = CB2_OUTPUT_LEVEL(data);
+			devcb_call_write_line(&m_out_cb2_func, m_out_cb2);
 		}
 		break;
 
     case VIA_ACR:
 		{
-			UINT16 counter1 = v_get_counter1_value(device);
-			v->acr = data;
-			if (T1_SET_PB7(v->acr))
+			UINT16 counter1 = get_counter1_value();
+			m_acr = data;
+			if (T1_SET_PB7(m_acr))
 			{
-				if (v->t1_active)
-					v->out_b &= ~0x80;
+				if (m_t1_active)
+                {
+					m_out_b &= ~0x80;
+                }
 				else
-					v->out_b |= 0x80;
+                {
+					m_out_b |= 0x80;
+                }
 
-				//if (v->ddr_b)
+				//if (m_ddr_b)
 				{
-					UINT8 write_data = (v->out_b & v->ddr_b) | (v->ddr_b ^ 0xff);
-					devcb_call_write8(&v->out_b_func, 0, write_data);
+					UINT8 write_data = (m_out_b & m_ddr_b) | (m_ddr_b ^ 0xff);
+					devcb_call_write8(&m_out_b_func, 0, write_data);
 				}
 			}
 			if (T1_CONTINUOUS(data))
 			{
-				timer_adjust_oneshot(v->t1, v_cycles_to_time(device, counter1 + IFR_DELAY), 0);
-				v->t1_active = 1;
+				timer_adjust_oneshot(m_t1, cycles_to_time(counter1 + IFR_DELAY), 0);
+				m_t1_active = 1;
 			}
 		}
 		break;
 
 	case VIA_IER:
 		if (data & 0x80)
-			v->ier |= data & 0x7f;
+        {
+			m_ier |= data & 0x7f;
+        }
 		else
-			v->ier &= ~(data & 0x7f);
+        {
+			m_ier &= ~(data & 0x7f);
+        }
 
-		if (v->ifr & INT_ANY)
+		if (m_ifr & INT_ANY)
 		{
-			if (((v->ifr & v->ier) & 0x7f) == 0)
+			if (((m_ifr & m_ier) & 0x7f) == 0)
 			{
-				v->ifr &= ~INT_ANY;
-				devcb_call_write_line(&v->irq_func, CLEAR_LINE);
+				m_ifr &= ~INT_ANY;
+				devcb_call_write_line(&m_irq_func, CLEAR_LINE);
 			}
 		}
 		else
 		{
-			if ((v->ier & v->ifr) & 0x7f)
+			if ((m_ier & m_ifr) & 0x7f)
 			{
-				v->ifr |= INT_ANY;
-				devcb_call_write_line(&v->irq_func, ASSERT_LINE);
+				m_ifr |= INT_ANY;
+				devcb_call_write_line(&m_irq_func, ASSERT_LINE);
 			}
 		}
 		break;
 
 	case VIA_IFR:
 		if (data & INT_ANY)
+        {
 			data = 0x7f;
-		via_clear_int (device, data);
+        }
+		clear_int(data);
 		break;
     }
 }
 
 
 /*-------------------------------------------------
-    via_porta_w - interface setting VIA port
-    A input
+    ca1_w - interface setting VIA port CA1 input
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER(via_porta_w)
+//void via6522_device::via_ca1_w(UINT8 state)
+WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(via6522, via_ca1_w)
 {
-	via6522_t *v = get_token(device);
-
-	/* set the input, what could be easier? */
-	v->in_a = data;
-}
-
-
-/*-------------------------------------------------
-    via_ca1_r - interface retrieving VIA port
-    CA1 input
--------------------------------------------------*/
-
-READ_LINE_DEVICE_HANDLER(via_ca1_r)
-{
-	via6522_t *v = get_token(device);
-	return v->in_ca1;
-}
-
-
-/*-------------------------------------------------
-    via_ca1_w - interface setting VIA port
-    CA1 input
--------------------------------------------------*/
-
-WRITE_LINE_DEVICE_HANDLER(via_ca1_w)
-{
-	via6522_t *v = get_token(device);
-
 	/* handle the active transition */
-	if (state != v->in_ca1)
+	if (state != m_in_ca1)
     {
 		if (TRACE_VIA)
-			logerror("%s:6522VIA chip %s: CA1 = %02X\n", cpuexec_describe_context(device->machine), device->tag(), state);
+			logerror("%s:6522VIA chip %s: CA1 = %02X\n", cpuexec_describe_context(&m_machine), tag(), state);
 
-		if ((CA1_LOW_TO_HIGH(v->pcr) && state) || (CA1_HIGH_TO_LOW(v->pcr) && !state))
+		if ((CA1_LOW_TO_HIGH(m_pcr) && state) || (CA1_HIGH_TO_LOW(m_pcr) && !state))
 		{
-			if (PA_LATCH_ENABLE(v->acr))
+			if (PA_LATCH_ENABLE(m_acr))
 			{
-				if (v->in_a_func.read != NULL)
-					v->in_a = devcb_call_read8(&v->in_a_func, 0);
+				if (m_in_a_func.read != NULL)
+                {
+					m_in_a = devcb_call_read8(&m_in_a_func, 0);
+                }
 				else
-					logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag());
+                {
+                    logerror("%s:6522VIA chip %s: Port A is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag());
+                }
 			}
 
-			via_set_int (device, INT_CA1);
+			set_int(INT_CA1);
 
 			/* CA2 is configured as output and in pulse or handshake mode,
                CA2 is cleared now */
-			if (CA2_AUTO_HS(v->pcr))
+			if (CA2_AUTO_HS(m_pcr))
 			{
-				if (!v->out_ca2)
+				if (!m_out_ca2)
 				{
 					/* clear CA2 */
-					v->out_ca2 = 1;
+					m_out_ca2 = 1;
 
 					/* call the CA2 output function */
-					devcb_call_write_line(&v->out_ca2_func, 1);
+					devcb_call_write_line(&m_out_ca2_func, 1);
 				}
 			}
 		}
 
-		v->in_ca1 = state;
+		m_in_ca1 = state;
     }
 }
 
 
 /*-------------------------------------------------
-    via_ca2_r - interface retrieving VIA port
-    CA2 input
+    ca2_w - interface setting VIA port CA2 input
 -------------------------------------------------*/
 
-READ_LINE_DEVICE_HANDLER(via_ca2_r)
+//void via6522_device::via_ca2_w(UINT8 state)
+WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(via6522, via_ca2_w)
 {
-	via6522_t *v = get_token(device);
-	return v->in_ca2;
-}
-
-
-/*-------------------------------------------------
-    via_ca2_w - interface setting VIA port
-    CA2 input
--------------------------------------------------*/
-
-WRITE_LINE_DEVICE_HANDLER(via_ca2_w)
-{
-	via6522_t *v = get_token(device);
-
 	/* CA2 is in input mode */
-	if (CA2_INPUT(v->pcr))
+	if (CA2_INPUT(m_pcr))
     {
 		/* the new state has caused a transition */
-		if (v->in_ca2 != state)
+		if (m_in_ca2 != state)
 		{
 			/* handle the active transition */
-			if ((state && CA2_LOW_TO_HIGH(v->pcr)) || (!state && CA2_HIGH_TO_LOW(v->pcr)))
+			if ((state && CA2_LOW_TO_HIGH(m_pcr)) || (!state && CA2_HIGH_TO_LOW(m_pcr)))
 			{
 				/* mark the IRQ */
-				via_set_int (device, INT_CA2);
+				set_int(INT_CA2);
 			}
 			/* set the new value for CA2 */
-			v->in_ca2 = state;
+			m_in_ca2 = state;
 		}
     }
-
-
-}
-
-
-/*-------------------------------------------------
-    via_portb_r - interface retrieving VIA port
-    B input
--------------------------------------------------*/
-
-READ8_DEVICE_HANDLER(via_portb_r)
-{
-	via6522_t *v = get_token(device);
-	return v->in_b;
 }
 
 
 /*-------------------------------------------------
-    via_portb_w - interface setting VIA port
-    B input
+    cb1_w - interface setting VIA port CB1 input
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER(via_portb_w)
+//void via6522_device::via_cb1_w(UINT8 state)
+WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(via6522, via_cb1_w)
 {
-	via6522_t *v = get_token(device);
-
-	/* set the input, what could be easier? */
-	v->in_b = data;
-}
-
-
-/*-------------------------------------------------
-    via_cb1_r - interface retrieving VIA port
-    CB1 input
--------------------------------------------------*/
-
-READ_LINE_DEVICE_HANDLER(via_cb1_r)
-{
-	via6522_t *v = get_token(device);
-	return v->in_cb1;
-}
-
-
-/*-------------------------------------------------
-    via_cb1_w - interface setting VIA port
-    CB1 input
--------------------------------------------------*/
-
-WRITE_LINE_DEVICE_HANDLER(via_cb1_w)
-{
-	via6522_t *v = get_token(device);
-
 	/* handle the active transition */
-	if (state != v->in_cb1)
+	if (state != m_in_cb1)
     {
-		if ((CB1_LOW_TO_HIGH(v->pcr) && state) || (CB1_HIGH_TO_LOW(v->pcr) && !state))
+		if ((CB1_LOW_TO_HIGH(m_pcr) && state) || (CB1_HIGH_TO_LOW(m_pcr) && !state))
 		{
-			if (PB_LATCH_ENABLE(v->acr))
+			if (PB_LATCH_ENABLE(m_acr))
 			{
-				if (v->in_b_func.read != NULL)
-					v->in_b = devcb_call_read8(&v->in_b_func, 0);
+				if (m_in_b_func.read != NULL)
+                {
+					m_in_b = devcb_call_read8(&m_in_b_func, 0);
+                }
 				else
-					logerror("%s:6522VIA chip %s: Port B is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag());
+                {
+                    logerror("%s:6522VIA chip %s: Port B is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag());
+                }
 			}
-			if (SO_EXT_CONTROL(v->acr) || SI_EXT_CONTROL(v->acr))
-				via_shift (device);
+			if (SO_EXT_CONTROL(m_acr) || SI_EXT_CONTROL(m_acr))
+            {
+				shift();
+            }
 
-			via_set_int (device, INT_CB1);
+			set_int(INT_CB1);
 
 			/* CB2 is configured as output and in pulse or handshake mode,
                CB2 is cleared now */
-			if (CB2_AUTO_HS(v->pcr))
+			if (CB2_AUTO_HS(m_pcr))
 			{
-				if (!v->out_cb2)
+				if (!m_out_cb2)
 				{
 					/* clear CB2 */
-					v->out_cb2 = 1;
+					m_out_cb2 = 1;
 
 					/* call the CB2 output function */
-					devcb_call_write_line(&v->out_cb2_func, 1);
+					devcb_call_write_line(&m_out_cb2_func, 1);
 				}
 			}
 		}
-		v->in_cb1 = state;
+		m_in_cb1 = state;
     }
 }
 
 
 /*-------------------------------------------------
-    via_cb2_r - interface retrieving VIA port
-    CB2 input
+    cb2_w - interface setting VIA port CB2 input
 -------------------------------------------------*/
 
-READ_LINE_DEVICE_HANDLER(via_cb2_r)
+//void via6522_device::via_cb2_w(UINT8 state)
+WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(via6522, via_cb2_w)
 {
-	via6522_t *v = get_token(device);
-	return v->in_cb2;
-}
-
-
-/*-------------------------------------------------
-    via_cb2_w - interface setting VIA port
-    CB2 input
--------------------------------------------------*/
-
-WRITE_LINE_DEVICE_HANDLER(via_cb2_w)
-{
-	via6522_t *v = get_token(device);
-
 	/* CB2 is in input mode */
-	if (CB2_INPUT(v->pcr))
+	if (CB2_INPUT(m_pcr))
     {
 		/* the new state has caused a transition */
-		if (v->in_cb2 != state)
+		if (m_in_cb2 != state)
 		{
 			/* handle the active transition */
-			if ((state && CB2_LOW_TO_HIGH(v->pcr)) || (!state && CB2_HIGH_TO_LOW(v->pcr)))
+			if ((state && CB2_LOW_TO_HIGH(m_pcr)) || (!state && CB2_HIGH_TO_LOW(m_pcr)))
 			{
 				/* mark the IRQ */
-				via_set_int (device, INT_CB2);
+				set_int(INT_CB2);
 			}
 			/* set the new value for CB2 */
-			v->in_cb2 = state;
+			m_in_cb2 = state;
 		}
     }
 }
 
 
-/*-------------------------------------------------
-    DEVICE_GET_INFO( via6522 )
--------------------------------------------------*/
-
-DEVICE_GET_INFO(via6522)
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(via6522_t);				break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;								break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(via6522);	break;
-		case DEVINFO_FCT_STOP:							/* Nothing */								break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(via6522);	break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "6522 VIA");				break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "6522 VIA");				break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");						break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);					break;
-		case DEVINFO_STR_CREDITS:						/* Nothing */								break;
-	}
-}
 
+/***************************************************************************
+    TRAMPOLINES
+***************************************************************************/
 
-DEFINE_LEGACY_DEVICE(VIA6522, via6522);
+READ_LINE_DEVICE_HANDLER(via_ca1_r) { return downcast<via6522_device *>(device)->via_ca1_r(); }
+READ_LINE_DEVICE_HANDLER(via_ca2_r) { return downcast<via6522_device *>(device)->via_ca2_r(); }
+READ_LINE_DEVICE_HANDLER(via_cb1_r) { return downcast<via6522_device *>(device)->via_cb1_r(); }
+READ_LINE_DEVICE_HANDLER(via_cb2_r) { return downcast<via6522_device *>(device)->via_cb2_r(); }
+WRITE8_DEVICE_HANDLER(via_porta_w) { downcast<via6522_device *>(device)->via_porta_w(data); }
+READ8_DEVICE_HANDLER(via_portb_r) { return downcast<via6522_device *>(device)->via_portb_r(); }
+WRITE8_DEVICE_HANDLER(via_portb_w) { downcast<via6522_device *>(device)->via_portb_w(data); }
diff -Nru src-old/emu/machine/6522via.h src/emu/machine/6522via.h
--- src-old/emu/machine/6522via.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/6522via.h	2010-08-28 09:48:51.000000000 -0700
@@ -5,27 +5,34 @@
     This function emulates all the functionality of 6522
     versatile interface adapters.
 
-    This is based on the M6821 emulation in MAME.
+    This is based on the pre-existing 6821 emulation.
 
     Written by Mathis Rosenhauer
 
 **********************************************************************/
 
+#pragma once
+
 #ifndef __6522VIA_H__
 #define __6522VIA_H__
 
-#include "devlegcy.h"
+#include "emu.h"
 
 
-/***************************************************************************
-    MACROS / CONSTANTS
-***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(VIA6522, via6522);
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
 
 #define MDRV_VIA6522_ADD(_tag, _clock, _intrf) \
-	MDRV_DEVICE_ADD(_tag, VIA6522, _clock) \
-	MDRV_DEVICE_CONFIG(_intrf)
+    MDRV_DEVICE_ADD(_tag, VIA6522, _clock) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
+
+
+/***************************************************************************
+    MACROS / CONSTANTS
+***************************************************************************/
 
 #define	VIA_PB	    0
 #define	VIA_PA	    1
@@ -49,25 +56,163 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _via6522_interface via6522_interface;
-struct _via6522_interface
+
+// ======================> via6522_interface
+
+struct via6522_interface
 {
-	devcb_read8 in_a_func;
-	devcb_read8 in_b_func;
-	devcb_read_line in_ca1_func;
-	devcb_read_line in_cb1_func;
-	devcb_read_line in_ca2_func;
-	devcb_read_line in_cb2_func;
-	devcb_write8 out_a_func;
-	devcb_write8 out_b_func;
-	devcb_write_line out_ca1_func;
-	devcb_write_line out_cb1_func;
-	devcb_write_line out_ca2_func;
-	devcb_write_line out_cb2_func;
-	devcb_write_line irq_func;
+    devcb_read8 m_in_a_func;
+    devcb_read8 m_in_b_func;
+    devcb_read_line m_in_ca1_func;
+    devcb_read_line m_in_cb1_func;
+    devcb_read_line m_in_ca2_func;
+    devcb_read_line m_in_cb2_func;
+    devcb_write8 m_out_a_func;
+    devcb_write8 m_out_b_func;
+    devcb_write_line m_out_ca1_func;
+    devcb_write_line m_out_cb1_func;
+    devcb_write_line m_out_ca2_func;
+    devcb_write_line m_out_cb2_func;
+    devcb_write_line m_irq_func;
 };
 
 
+// ======================> via6522_device_config
+
+class via6522_device_config :   public device_config,
+                                public via6522_interface
+{
+    friend class via6522_device;
+
+    // construction/destruction
+    via6522_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+// ======================> via6522_device
+
+class via6522_device :  public device_t
+{
+    friend class via6522_device_config;
+    friend class dart_channel;
+
+    // construction/destruction
+    via6522_device(running_machine &_machine, const via6522_device_config &_config);
+
+public:
+    UINT8 via_r(UINT32 offset);
+    void via_w(UINT32 offset, UINT8 data);
+
+    void via_porta_w(UINT8 data) { m_in_a = data; }
+
+    UINT8 via_portb_r() { return m_in_b; }
+    void via_portb_w(UINT8 data) { m_in_b = data; }
+
+    UINT8 via_ca1_r() { return m_in_ca1; }
+    void via_ca1_w(UINT8 data);
+
+    UINT8 via_ca2_r() { return m_in_ca2; }
+    void via_ca2_w(UINT8 data);
+
+    UINT8 via_cb1_r() { return m_in_cb1; }
+    void via_cb1_w(UINT8 data);
+
+    UINT8 via_cb2_r() { return m_in_cb2; }
+    void via_cb2_w(UINT8 data);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+    static TIMER_CALLBACK( t1_timeout_callback );
+    static TIMER_CALLBACK( t2_timeout_callback );
+    static TIMER_CALLBACK( shift_callback );
+
+private:
+    attotime cycles_to_time(int c);
+    UINT32 time_to_cycles(attotime t);
+    UINT16 get_counter1_value();
+
+    void set_int(int data);
+    void clear_int(int data);
+    void shift();
+    void t1_timeout();
+    void t2_timeout();
+
+    devcb_resolved_read8 m_in_a_func;
+    devcb_resolved_read8 m_in_b_func;
+    devcb_resolved_read_line m_in_ca1_func;
+    devcb_resolved_read_line m_in_cb1_func;
+    devcb_resolved_read_line m_in_ca2_func;
+    devcb_resolved_read_line m_in_cb2_func;
+    devcb_resolved_write8 m_out_a_func;
+    devcb_resolved_write8 m_out_b_func;
+    devcb_resolved_write_line m_out_ca1_func;
+    devcb_resolved_write_line m_out_cb1_func;
+    devcb_resolved_write_line m_out_ca2_func;
+    devcb_resolved_write_line m_out_cb2_func;
+    devcb_resolved_write_line m_irq_func;
+
+    UINT8 m_in_a;
+    UINT8 m_in_ca1;
+    UINT8 m_in_ca2;
+    UINT8 m_out_a;
+    UINT8 m_out_ca2;
+    UINT8 m_ddr_a;
+
+    UINT8 m_in_b;
+    UINT8 m_in_cb1;
+    UINT8 m_in_cb2;
+    UINT8 m_out_b;
+    UINT8 m_out_cb2;
+    UINT8 m_ddr_b;
+
+    UINT8 m_t1cl;
+    UINT8 m_t1ch;
+    UINT8 m_t1ll;
+    UINT8 m_t1lh;
+    UINT8 m_t2cl;
+    UINT8 m_t2ch;
+    UINT8 m_t2ll;
+    UINT8 m_t2lh;
+
+    UINT8 m_sr;
+    UINT8 m_pcr;
+    UINT8 m_acr;
+    UINT8 m_ier;
+    UINT8 m_ifr;
+
+    emu_timer *m_t1;
+    attotime m_time1;
+    UINT8 m_t1_active;
+    emu_timer *m_t2;
+    attotime m_time2;
+    UINT8 m_t2_active;
+
+    emu_timer *m_shift_timer;
+    UINT8 m_shift_counter;
+
+    const via6522_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type VIA6522;
+
+
+
 /***************************************************************************
     PROTOTYPES
 ***************************************************************************/
diff -Nru src-old/emu/machine/6526cia.c src/emu/machine/6526cia.c
--- src-old/emu/machine/6526cia.c	2010-06-16 23:55:54.000000000 -0700
+++ src/emu/machine/6526cia.c	2010-08-30 08:20:58.000000000 -0700
@@ -41,368 +41,355 @@
 #define	CIA_CRA_SPMODE	0x40
 #define	CIA_CRA_TODIN	0x80
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-typedef struct _cia_timer cia_timer;
-typedef struct _cia_port cia_port;
-typedef struct _cia_state cia_state;
-
-struct _cia_timer
-{
-	UINT16		latch;
-	UINT16		count;
-	UINT8		mode;
-	UINT8		irq;
-	emu_timer *timer;
-	cia_state *	cia;
-};
-
-struct _cia_port
-{
-	UINT8		ddr;
-	UINT8		latch;
-	UINT8		in;
-	UINT8		out;
-	devcb_resolved_read8	read;
-	devcb_resolved_write8	write;
-	UINT8		mask_value; /* in READ operation the value can be forced by a extern electric circuit */
-};
-
-struct _cia_state
-{
-	running_device *device;
-	devcb_resolved_write_line out_irq_func;
-	devcb_resolved_write_line out_pc_func;
-	devcb_resolved_write_line out_cnt_func;
-	devcb_resolved_write_line out_sp_func;
-
-	cia_port		port[2];
-	cia_timer		timer[2];
-
-	/* Time Of the Day clock (TOD) */
-	UINT32			tod;
-	UINT32			tod_latch;
-	UINT8			tod_latched;
-	UINT8			tod_running;
-	UINT32			alarm;
-
-	/* Interrupts */
-	UINT8			icr;
-	UINT8			ics;
-	UINT8			irq;
-	int				flag;
-
-	/* Serial */
-	UINT8			loaded;
-	UINT8			sdr;
-	UINT8			sp;
-	UINT8			cnt;
-	UINT8			shift;
-	UINT8			serial;
-};
+//-------------------------------------------------
+//  mos6526_device_config - constructor
+//-------------------------------------------------
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
+mos6526_device_config::mos6526_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "MOS6526", tag, owner, clock)
+{
+}
 
-static TIMER_CALLBACK( cia_timer_proc );
-static void cia_timer_underflow(running_device *device, int timer);
-static TIMER_CALLBACK( cia_clock_tod_callback );
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
 
-INLINE cia_state *get_token(running_device *device)
+device_config *mos6526_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
 {
-	assert(device != NULL);
-	assert((device->type() == MOS6526R1) || (device->type() == MOS6526R2) || (device->type() == MOS8520));
-	return (cia_state *) downcast<legacy_device_base *>(device)->token();
+    return global_alloc(mos6526_device_config(mconfig, tag, owner, clock));
 }
 
-INLINE const mos6526_interface *get_interface(running_device *device)
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *mos6526_device_config::alloc_device(running_machine &machine) const
 {
-	assert(device != NULL);
-	assert((device->type() == MOS6526R1) || (device->type() == MOS6526R2) || (device->type() == MOS8520));
-	return (mos6526_interface *) device->baseconfig().static_config();
+    return auto_alloc(&machine, mos6526_device(machine, *this));
 }
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
 
-/*-------------------------------------------------
-    cia_set_port_mask_value
--------------------------------------------------*/
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
 
-void cia_set_port_mask_value(running_device *device, int port, int data)
+void mos6526_device_config::device_config_complete()
 {
-	cia_state *cia = get_token(device);
-	cia->port[port].mask_value = data;
+	// inherit a copy of the static data
+	const mos6526_interface *intf = reinterpret_cast<const mos6526_interface *>(static_config());
+	if (intf != NULL)
+		*static_cast<mos6526_interface *>(this) = *intf;
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_tod_clock = 0;
+    	memset(&m_out_irq_func, 0, sizeof(m_out_irq_func));
+    	memset(&m_out_pc_func, 0, sizeof(m_out_pc_func));
+    	memset(&m_out_cnt_func, 0, sizeof(m_out_cnt_func));
+    	memset(&m_out_sp_func, 0, sizeof(m_out_sp_func));
+    	memset(&m_in_pa_func, 0, sizeof(m_in_pa_func));
+    	memset(&m_out_pa_func, 0, sizeof(m_out_pa_func));
+    	memset(&m_in_pb_func, 0, sizeof(m_in_pb_func));
+    	memset(&m_out_pb_func, 0, sizeof(m_out_pb_func));
+	}
 }
 
-/*-------------------------------------------------
-    DEVICE_RESET( cia )
--------------------------------------------------*/
 
-static DEVICE_RESET( cia )
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type MOS6526R1 = mos6526_device_config::static_alloc_device_config;
+const device_type MOS6526R2 = mos6526_device_config::static_alloc_device_config;
+const device_type MOS8520 = mos6526_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  mos6526_device - constructor
+//-------------------------------------------------
+
+mos6526_device::mos6526_device(running_machine &_machine, const mos6526_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	int t;
-	cia_state *cia = get_token(device);
 
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void mos6526_device::device_reset()
+{
 	/* clear things out */
-	cia->port[0].latch = 0x00;
-	cia->port[0].in = 0x00;
-	cia->port[0].out = 0x00;
-	cia->port[0].mask_value = 0xff;
-	cia->port[1].latch = 0x00;
-	cia->port[1].in = 0x00;
-	cia->port[1].out = 0x00;
-	cia->port[1].mask_value = 0xff;
-	cia->tod = 0;
-	cia->tod_latch = 0;
-	cia->alarm = 0;
-	cia->icr = 0x00;
-	cia->ics = 0x00;
-	cia->irq = 0;
-	cia->shift = 0;
-	cia->loaded = 0;
-	cia->cnt = 1;
-	cia->sp = 0;
+	m_port[0].m_latch = 0x00;
+	m_port[0].m_in = 0x00;
+	m_port[0].m_out = 0x00;
+	m_port[0].m_mask_value = 0xff;
+	m_port[1].m_latch = 0x00;
+	m_port[1].m_in = 0x00;
+	m_port[1].m_out = 0x00;
+	m_port[1].m_mask_value = 0xff;
+	m_tod = 0;
+	m_tod_latch = 0;
+	m_alarm = 0;
+	m_icr = 0x00;
+	m_ics = 0x00;
+	m_irq = 0;
+	m_shift = 0;
+	m_loaded = 0;
+	m_cnt = 1;
+	m_sp = 0;
 
 	/* initialize data direction registers */
-	cia->port[0].ddr = !strcmp(device->tag(), "cia_0") ? 0x03 : 0xff;
-	cia->port[1].ddr = !strcmp(device->tag(), "cia_0") ? 0x00 : 0xff;
+	m_port[0].m_ddr = !strcmp(tag(), "cia_0") ? 0x03 : 0xff;
+	m_port[1].m_ddr = !strcmp(tag(), "cia_0") ? 0x00 : 0xff;
 
 	/* TOD running by default */
-	cia->tod_running = TRUE;
+	m_tod_running = TRUE;
 
 	/* initialize timers */
-	for (t = 0; t < 2; t++)
+	for(int t = 0; t < 2; t++)
 	{
-		cia_timer *timer = &cia->timer[t];
-
-		timer->latch = 0xffff;
-		timer->count = 0x0000;
-		timer->mode = 0x00;
+		cia_timer *timer = &m_timer[t];
+		timer->m_cia = this;
+		timer->m_clock = clock();
+		timer->m_latch = 0xffff;
+		timer->m_count = 0x0000;
+		timer->m_mode = 0x00;
 	}
 }
 
-/*-------------------------------------------------
-    DEVICE_VALIDITY_CHECK( cia )
--------------------------------------------------*/
 
-#if 0
-static DEVICE_VALIDITY_CHECK( cia )
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void mos6526_device::device_start()
 {
-	int error = FALSE;
+	/* clear out CIA structure, and copy the interface */
+	devcb_resolve_write_line(&m_out_irq_func, &m_config.m_out_irq_func, this);
+	devcb_resolve_write_line(&m_out_pc_func, &m_config.m_out_pc_func, this);
+	devcb_resolve_write_line(&m_out_cnt_func, &m_config.m_out_cnt_func, this);
+	devcb_resolve_write_line(&m_out_sp_func, &m_config.m_out_sp_func, this);
+	m_flag = 1;
+
+	/* setup ports */
+	devcb_resolve_read8(&m_port[0].m_read, &m_config.m_in_pa_func, this);
+	devcb_resolve_write8(&m_port[0].m_write, &m_config.m_out_pa_func, this);
+	devcb_resolve_read8(&m_port[1].m_read, &m_config.m_in_pb_func, this);
+	devcb_resolve_write8(&m_port[1].m_write, &m_config.m_out_pb_func, this);
 
-	if (device->clock() <= 0)
+	for (int p = 0; p < (sizeof(m_port) / sizeof(m_port[0])); p++)
 	{
-		mame_printf_error("%s: %s has a cia with an invalid clock\n", driver->source_file, driver->name);
-		error = TRUE;
+		m_port[p].m_mask_value = 0xff;
 	}
 
-	return error;
-}
-#endif
-
-/*-------------------------------------------------
-    cia_update_pc - pulse /pc output
--------------------------------------------------*/
+	/* setup timers */
+	for (int t = 0; t < (sizeof(m_timer) / sizeof(m_timer[0])); t++)
+	{
+		cia_timer *timer = &m_timer[t];
+		timer->m_timer = timer_alloc(&m_machine, timer_proc, (void*)this);
+		timer->m_cia = this;
+		timer->m_irq = 0x01 << t;
+	}
 
-static void cia_update_pc(running_device *device)
-{
-	cia_state *cia = get_token(device);
+	/* setup TOD timer, if appropriate */
+	if (m_config.m_tod_clock != 0)
+	{
+		timer_pulse(&m_machine, ATTOTIME_IN_HZ(m_config.m_tod_clock), (void *)this, 0, clock_tod_callback);
+	}
 
-	/* this should really be one cycle long */
-	devcb_call_write_line(&cia->out_pc_func, 0);
-	devcb_call_write_line(&cia->out_pc_func, 1);
+	/* state save support */
+	state_save_register_device_item(this, 0, m_port[0].m_ddr);
+	state_save_register_device_item(this, 0, m_port[0].m_latch);
+	state_save_register_device_item(this, 0, m_port[0].m_in);
+	state_save_register_device_item(this, 0, m_port[0].m_out);
+	state_save_register_device_item(this, 0, m_port[0].m_mask_value);
+	state_save_register_device_item(this, 0, m_port[1].m_ddr);
+	state_save_register_device_item(this, 0, m_port[1].m_latch);
+	state_save_register_device_item(this, 0, m_port[1].m_in);
+	state_save_register_device_item(this, 0, m_port[1].m_out);
+	state_save_register_device_item(this, 0, m_port[1].m_mask_value);
+	state_save_register_device_item(this, 0, m_timer[0].m_latch);
+	state_save_register_device_item(this, 0, m_timer[0].m_count);
+	state_save_register_device_item(this, 0, m_timer[0].m_mode);
+	state_save_register_device_item(this, 0, m_timer[0].m_irq);
+	state_save_register_device_item(this, 0, m_timer[1].m_latch);
+	state_save_register_device_item(this, 0, m_timer[1].m_count);
+	state_save_register_device_item(this, 0, m_timer[1].m_mode);
+	state_save_register_device_item(this, 0, m_timer[1].m_irq);
+	state_save_register_device_item(this, 0, m_tod);
+	state_save_register_device_item(this, 0, m_tod_latch);
+	state_save_register_device_item(this, 0, m_tod_latched);
+	state_save_register_device_item(this, 0, m_tod_running);
+	state_save_register_device_item(this, 0, m_alarm);
+	state_save_register_device_item(this, 0, m_icr);
+	state_save_register_device_item(this, 0, m_ics);
+	state_save_register_device_item(this, 0, m_irq);
+	state_save_register_device_item(this, 0, m_flag);
+	state_save_register_device_item(this, 0, m_loaded);
+	state_save_register_device_item(this, 0, m_sdr);
+	state_save_register_device_item(this, 0, m_sp);
+	state_save_register_device_item(this, 0, m_cnt);
+	state_save_register_device_item(this, 0, m_shift);
+	state_save_register_device_item(this, 0, m_serial);
 }
 
-/*-------------------------------------------------
-    cia_update_interrupts
--------------------------------------------------*/
 
-static void cia_update_interrupts(running_device *device)
+/*-------------------------------------------------
+    set_port_mask_value
+-------------------------------------------------*/
+
+void mos6526_device::set_port_mask_value(int port, int data)
 {
-	UINT8 new_irq;
-	cia_state *cia = get_token(device);
-
-	/* always update the high bit of ICS */
-	if (cia->ics & 0x7f)
-		cia->ics |= 0x80;
-	else
-		cia->ics &= ~0x80;
-
-	/* based on what is enabled, set/clear the IRQ via the custom chip */
-	new_irq = (cia->ics & cia->icr) ? 1 : 0;
-	if (cia->irq != new_irq)
-	{
-		cia->irq = new_irq;
-		devcb_call_write_line(&cia->out_irq_func, cia->irq);
-	}
+	m_port[port].m_mask_value = data;
 }
 
 /*-------------------------------------------------
-    is_timer_active
+    update_pc - pulse /pc output
 -------------------------------------------------*/
 
-static int is_timer_active(emu_timer *timer)
+void mos6526_device::update_pc()
 {
-	attotime t = timer_firetime(timer);
-	return attotime_compare(t, attotime_never) != 0;
+	/* this should really be one cycle long */
+	devcb_call_write_line(&m_out_pc_func, 0);
+	devcb_call_write_line(&m_out_pc_func, 1);
 }
 
 /*-------------------------------------------------
-    cia_timer_update - updates the count and
-    emu_timer for a given CIA timer
+    update_interrupts
 -------------------------------------------------*/
 
-static void cia_timer_update(cia_timer *timer, INT32 new_count)
+void mos6526_device::update_interrupts()
 {
-	int which = timer - timer->cia->timer;
-
-	/* sanity check arguments */
-	assert((new_count >= -1) && (new_count <= 0xffff));
-
-	/* update the timer count, if necessary */
-	if ((new_count == -1) && is_timer_active(timer->timer))
-	{
-		UINT16 current_count = attotime_to_double(attotime_mul(timer_timeelapsed(timer->timer), timer->cia->device->clock()));
-		timer->count = timer->count - MIN(timer->count, current_count);
-	}
-
-	/* set the timer if we are instructed to */
-	if (new_count != -1)
-		timer->count = new_count;
+	UINT8 new_irq;
 
-	/* now update the MAME timer */
-	if ((timer->mode & 0x01) && ((timer->mode & (which ? 0x60 : 0x20)) == 0x00))
+	/* always update the high bit of ICS */
+	if (m_ics & 0x7f)
 	{
-		/* timer is on and is connected to clock */
-		attotime period = attotime_mul(ATTOTIME_IN_HZ(timer->cia->device->clock()), (timer->count ? timer->count : 0x10000));
-		timer_adjust_oneshot(timer->timer, period, 0);
+		m_ics |= 0x80;
 	}
 	else
 	{
-		/* timer is off or not connected to clock */
-		timer_adjust_oneshot(timer->timer, attotime_never, 0);
+		m_ics &= ~0x80;
 	}
-}
-
-/*-------------------------------------------------
-    cia_get_timer - get the count
-    for a given CIA timer
--------------------------------------------------*/
-
-static UINT16 cia_get_timer(cia_timer *timer)
-{
-	UINT16 count;
 
-	if (is_timer_active(timer->timer))
+	/* based on what is enabled, set/clear the IRQ via the custom chip */
+	new_irq = (m_ics & m_icr) ? 1 : 0;
+	if (m_irq != new_irq)
 	{
-		UINT16 current_count = attotime_to_double(attotime_mul(timer_timeelapsed(timer->timer), timer->cia->device->clock()));
-		count = timer->count - MIN(timer->count, current_count);
+		m_irq = new_irq;
+		devcb_call_write_line(&m_out_irq_func, m_irq);
 	}
-	else
-		count = timer->count;
-
-	return count;
 }
 
+
 /*-------------------------------------------------
-    cia_timer_bump
+    timer_bump
 -------------------------------------------------*/
 
-static void cia_timer_bump(running_device *device, int timer)
+void mos6526_device::timer_bump(int timer)
 {
-	cia_state *cia = get_token(device);
-
-	cia_timer_update(&cia->timer[timer], -1);
+	m_timer[timer].update(timer, -1);
 
-	if (cia->timer[timer].count == 0x00)
-		cia_timer_underflow(device, timer);
+	if (m_timer[timer].m_count == 0x00)
+	{
+		timer_underflow(timer);
+	}
 	else
-		cia_timer_update(&cia->timer[timer], cia->timer[timer].count - 1);
+	{
+		m_timer[timer].update(timer, m_timer[timer].m_count - 1);
+	}
 }
 
 /*-------------------------------------------------
     cia_timer_underflow
 -------------------------------------------------*/
 
-static void cia_timer_underflow(running_device *device, int timer)
+void mos6526_device::timer_underflow(int timer)
 {
-	cia_state *cia = get_token(device);
-
 	assert((timer == 0) || (timer == 1));
 
 	/* set the status and update interrupts */
-	cia->ics |= cia->timer[timer].irq;
-	cia_update_interrupts(device);
+	m_ics |= m_timer[timer].m_irq;
+	update_interrupts();
 
 	/* if one-shot mode, turn it off */
-	if (cia->timer[timer].mode & 0x08)
-		cia->timer[timer].mode &= 0xfe;
+	if (m_timer[timer].m_mode & 0x08)
+	{
+		m_timer[timer].m_mode &= 0xfe;
+	}
 
 	/* reload the timer */
-	cia_timer_update(&cia->timer[timer], cia->timer[timer].latch);
+	m_timer[timer].update(timer, m_timer[timer].m_latch);
 
 	/* timer A has some interesting properties */
 	if (timer == 0)
 	{
 		/* such as cascading to timer B */
-		if ((cia->timer[1].mode & 0x41) == 0x41)
+		if ((m_timer[1].m_mode & 0x41) == 0x41)
 		{
-			if (cia->cnt || !(cia->timer[1].mode & 0x20))
-				cia_timer_bump(device, 1);
+			if (m_cnt || !(m_timer[1].m_mode & 0x20))
+			{
+				timer_bump(1);
+			}
 		}
 
 		/* also the serial line */
-		if ((cia->timer[timer].irq == 0x01) && (cia->timer[timer].mode & CIA_CRA_SPMODE))
+		if ((m_timer[timer].m_irq == 0x01) && (m_timer[timer].m_mode & CIA_CRA_SPMODE))
 		{
-			if (cia->loaded || cia->shift)
+			if (m_loaded || m_shift)
 			{
 				/* falling edge */
-				if (cia->cnt)
+				if (m_cnt)
 				{
-					if (cia->shift == 0)
+					if (m_shift == 0)
 					{
 						/* load shift register */
-						cia->loaded = 0;
-						cia->serial = cia->sdr;
+						m_loaded = 0;
+						m_serial = m_sdr;
 					}
 
 					/* transmit MSB */
-					cia->sp = BIT(cia->serial, 7);
-					devcb_call_write_line(&cia->out_sp_func, cia->sp);
+					m_sp = BIT(m_serial, 7);
+					devcb_call_write_line(&m_out_sp_func, m_sp);
 
 					/* toggle CNT */
-					cia->cnt = !cia->cnt;
-					devcb_call_write_line(&cia->out_cnt_func, cia->cnt);
+					m_cnt = !m_cnt;
+					devcb_call_write_line(&m_out_cnt_func, m_cnt);
 
 					/* shift data */
-					cia->serial <<= 1;
-					cia->shift++;
+					m_serial <<= 1;
+					m_shift++;
 
-					if (cia->shift == 8)
+					if (m_shift == 8)
 					{
 						/* signal interrupt */
-						cia->ics |= 0x08;
-						cia_update_interrupts(device);
+						m_ics |= 0x08;
+						update_interrupts();
 					}
 				}
 				else
 				{
 					/* toggle CNT */
-					cia->cnt = !cia->cnt;
-					devcb_call_write_line(&cia->out_cnt_func, cia->cnt);
+					m_cnt = !m_cnt;
+					devcb_call_write_line(&m_out_cnt_func, m_cnt);
 
-					if (cia->shift == 8)
+					if (m_shift == 8)
 					{
-						cia->shift = 0;
+						m_shift = 0;
 					}
 				}
 			}
@@ -414,12 +401,11 @@
     TIMER_CALLBACK( cia_timer_proc )
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( cia_timer_proc )
+TIMER_CALLBACK( mos6526_device::timer_proc )
 {
-	cia_timer *timer = (cia_timer *)ptr;
-	cia_state *cia = timer->cia;
+    mos6526_device *cia = reinterpret_cast<mos6526_device *>(ptr);
 
-	cia_timer_underflow(cia->device, timer - cia->timer);
+	cia->timer_underflow(param);
 }
 
 /*-------------------------------------------------
@@ -438,20 +424,20 @@
     cia6526_increment
 -------------------------------------------------*/
 
-static void cia6526_increment(cia_state *cia)
+void mos6526_device::increment()
 {
 	/* break down TOD value into components */
-	UINT8 subsecond	= (UINT8) (cia->tod >>  0);
-	UINT8 second	= (UINT8) (cia->tod >>  8);
-	UINT8 minute	= (UINT8) (cia->tod >> 16);
-	UINT8 hour		= (UINT8) (cia->tod >> 24);
+	UINT8 subsecond	= (UINT8) (m_tod >>  0);
+	UINT8 second	= (UINT8) (m_tod >>  8);
+	UINT8 minute	= (UINT8) (m_tod >> 16);
+	UINT8 hour		= (UINT8) (m_tod >> 24);
 
 	subsecond = bcd_increment(subsecond);
 	if (subsecond >= 0x10)
 	{
 		subsecond = 0x00;
 		second = bcd_increment(second);
-		if (second >= ((cia->timer[0].mode & 0x80) ? 0x50 : 0x60))
+		if (second >= ((m_timer[0].m_mode & 0x80) ? 0x50 : 0x60))
 		{
 			second = 0x00;
 			minute = bcd_increment(minute);
@@ -473,164 +459,124 @@
 	}
 
 	/* update the TOD with new value */
-	cia->tod = (((UINT32) subsecond)	<<  0)
-			 | (((UINT32) second)		<<  8)
-			 | (((UINT32) minute)		<< 16)
-			 | (((UINT32) hour)			<< 24);
+	m_tod = (((UINT32) subsecond)	<<  0)
+		  | (((UINT32) second)		<<  8)
+		  | (((UINT32) minute)		<< 16)
+		  | (((UINT32) hour)		<< 24);
 }
 
 /*-------------------------------------------------
     cia_clock_tod - Update TOD on CIA A
 -------------------------------------------------*/
 
-static void cia_clock_tod(running_device *device)
+void mos6526_device::clock_tod()
 {
-	cia_state *cia;
-
-	cia = get_token(device);
-
-	if (cia->tod_running)
+	if (m_tod_running)
 	{
-		if ((device->type() == MOS6526R1) || (device->type() == MOS6526R2))
+		if ((type() == MOS6526R1) || (type() == MOS6526R2))
 		{
 			/* The 6526 split the value into hours, minutes, seconds and
              * subseconds */
-			cia6526_increment(cia);
+			increment();
 		}
-		else if (device->type() == MOS8520)
+		else if (type() == MOS8520)
 		{
 			/* the 8520 has a straight 24-bit counter */
-			cia->tod++;
-			cia->tod &= 0xffffff;
+			m_tod++;
+			m_tod &= 0xffffff;
 		}
 
-		if (cia->tod == cia->alarm)
+		if (m_tod == m_alarm)
 		{
-			cia->ics |= 0x04;
-			cia_update_interrupts(device);
+			m_ics |= 0x04;
+			update_interrupts();
 		}
 	}
 }
 
+
 /*-------------------------------------------------
-    cia_clock_tod_callback
+    clock_tod_callback
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( cia_clock_tod_callback )
-{
-	running_device *device = (running_device *)ptr;
-	cia_clock_tod(device);
-}
-
-READ8_DEVICE_HANDLER( mos6526_pa_r )
-{
-	return (get_token(device)->port[0].latch | ~get_token(device)->port[0].ddr);
-}
-
-READ8_DEVICE_HANDLER( mos6526_pb_r )
-{
-	return (get_token(device)->port[1].latch | ~get_token(device)->port[1].ddr);
-}
-
-READ_LINE_DEVICE_HANDLER( mos6526_irq_r )
-{
-	cia_state *cia = get_token(device);
-
-	return cia->irq;
-}
-
-WRITE_LINE_DEVICE_HANDLER( mos6526_tod_w )
+TIMER_CALLBACK( mos6526_device::clock_tod_callback )
 {
-	if (state) cia_clock_tod(device);
+    mos6526_device *cia = reinterpret_cast<mos6526_device *>(ptr);
+	cia->clock_tod();
 }
 
-READ_LINE_DEVICE_HANDLER( mos6526_cnt_r )
-{
-	cia_state *cia = get_token(device);
 
-	return cia->cnt;
-}
+/*-------------------------------------------------
+    cnt_w
+-------------------------------------------------*/
 
-WRITE_LINE_DEVICE_HANDLER( mos6526_cnt_w )
+void mos6526_device::cnt_w(UINT8 state)
 {
-	cia_state *cia = get_token(device);
-
 	/* is this a rising edge? */
-	if (!cia->cnt && state)
+	if (!m_cnt && state)
 	{
-		if (cia->timer[0].mode & CIA_CRA_START)
+		if (m_timer[0].m_mode & CIA_CRA_START)
 		{
 			/* does timer #0 bump on CNT? */
-			if (cia->timer[0].mode & CIA_CRA_INMODE)
-				cia_timer_bump(device, 0);
+			if (m_timer[0].m_mode & CIA_CRA_INMODE)
+			{
+				timer_bump(0);
+			}
 		}
 
 		/* if the serial port is set to input, the CNT will shift the port */
-		if (!(cia->timer[0].mode & CIA_CRA_SPMODE))
+		if (!(m_timer[0].m_mode & CIA_CRA_SPMODE))
 		{
-			cia->serial <<= 1;
-			cia->shift++;
+			m_serial <<= 1;
+			m_shift++;
 
-			if (cia->sp) cia->serial |= 0x01;
+			if (m_sp)
+			{
+				m_serial |= 0x01;
+			}
 
-			if (cia->shift == 8)
+			if (m_shift == 8)
 			{
-				cia->sdr = cia->serial;
-				cia->serial = 0;
-				cia->shift = 0;
-				cia->ics |= 0x08;
-				cia_update_interrupts(device);
+				m_sdr = m_serial;
+				m_serial = 0;
+				m_shift = 0;
+				m_ics |= 0x08;
+				update_interrupts();
 			}
 		}
 
 		/* does timer #1 bump on CNT? */
-		if ((cia->timer[1].mode & 0x61) == 0x21)
-			cia_timer_bump(device, 1);
+		if ((m_timer[1].m_mode & 0x61) == 0x21)
+		{
+			timer_bump(1);
+		}
 	}
 
-	cia->cnt = state;
+	m_cnt = state;
 }
 
-READ_LINE_DEVICE_HANDLER( mos6526_sp_r )
+void mos6526_device::flag_w(UINT8 state)
 {
-	cia_state *cia = get_token(device);
-
-	return cia->sp;
-}
-
-WRITE_LINE_DEVICE_HANDLER( mos6526_sp_w )
-{
-	cia_state *cia = get_token(device);
-
-	cia->sp = state;
-}
-
-WRITE_LINE_DEVICE_HANDLER( mos6526_flag_w )
-{
-	cia_state *cia = get_token(device);
-
 	/* falling edge */
-	if (cia->flag && !state)
+	if (m_flag && !state)
 	{
-		cia->ics |= 0x10;
-		cia_update_interrupts(device);
+		m_ics |= 0x10;
+		update_interrupts();
 	}
 
-	cia->flag = state;
+	m_flag = state;
 }
 
 /*-------------------------------------------------
-    mos6526_r
+    reg_r
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( mos6526_r )
+UINT8 mos6526_device::reg_r(UINT8 offset)
 {
 	cia_timer *timer;
-	cia_state *cia;
 	cia_port *port;
 	UINT8 data = 0x00;
 
-	cia = get_token(device);
 	offset &= 0x0F;
 
 	switch(offset)
@@ -638,58 +584,66 @@
 		/* port A/B data */
 		case CIA_PRA:
 		case CIA_PRB:
-			port = &cia->port[offset & 1];
-			data = devcb_call_read8(&port->read, 0);
-			data = ((data & ~port->ddr) | (port->latch & port->ddr)) & port->mask_value;
+			port = &m_port[offset & 1];
+			data = devcb_call_read8(&port->m_read, 0);
+			data = ((data & ~port->m_ddr) | (port->m_latch & port->m_ddr)) & port->m_mask_value;
 
-			port->in = data;
+			port->m_in = data;
 
 			if (offset == CIA_PRB)
 			{
 				/* timer #0 can change PB6 */
-				if (cia->timer[0].mode & 0x02)
+				if (m_timer[0].m_mode & 0x02)
 				{
-					cia_timer_update(&cia->timer[0], -1);
-					if (cia->timer[0].count != 0)
+					m_timer[0].update(0, -1);
+					if (m_timer[0].m_count != 0)
+					{
 						data |= 0x40;
+					}
 					else
+					{
 						data &= ~0x40;
+					}
 				}
 
 				/* timer #1 can change PB7 */
-				if (cia->timer[1].mode & 0x02)
+				if (m_timer[1].m_mode & 0x02)
 				{
-					cia_timer_update(&cia->timer[1], -1);
-					if (cia->timer[1].count != 0)
+					m_timer[1].update(1, -1);
+					if (m_timer[1].m_count != 0)
+					{
 						data |= 0x80;
+					}
 					else
+					{
 						data &= ~0x80;
+					}
 				}
 
 				/* pulse /PC following the read */
-				cia_update_pc(device);
+				update_pc();
 			}
 			break;
 
 		/* port A/B direction */
 		case CIA_DDRA:
 		case CIA_DDRB:
-			port = &cia->port[offset & 1];
-			data = port->ddr;
+			port = &m_port[offset & 1];
+			data = port->m_ddr;
 			break;
 
 		/* timer A/B low byte */
 		case CIA_TALO:
 		case CIA_TBLO:
-			timer = &cia->timer[(offset >> 1) & 1];
-			data = cia_get_timer(timer) >> 0;
+			timer = &m_timer[(offset >> 1) & 1];
+			data = timer->get_count() >> 0;
 			break;
 
 		/* timer A/B high byte */
 		case CIA_TAHI:
 		case CIA_TBHI:
-			timer = &cia->timer[(offset >> 1) & 1];
-			data = cia_get_timer(timer) >> 8;
+			timer = &m_timer[(offset >> 1) & 1];
+			data = timer->get_count() >> 8;
 			break;
 
 		/* TOD counter */
@@ -697,48 +651,54 @@
 		case CIA_TOD1:
 		case CIA_TOD2:
 		case CIA_TOD3:
-			if (device->type() == MOS8520)
+			if (type() == MOS8520)
 			{
 				if (offset == CIA_TOD2)
 				{
-					cia->tod_latch = cia->tod;
-					cia->tod_latched = TRUE;
+					m_tod_latch = m_tod;
+					m_tod_latched = TRUE;
 				}
 			}
 			else
 			{
 				if (offset == CIA_TOD3)
 				{
-					cia->tod_latch = cia->tod;
-					cia->tod_latched = TRUE;
+					m_tod_latch = m_tod;
+					m_tod_latched = TRUE;
 				}
 			}
 			if (offset == CIA_TOD0)
-				cia->tod_latched = FALSE;
+			{
+				m_tod_latched = FALSE;
+			}
 
-			if (cia->tod_latched)
-				data = cia->tod_latch >> ((offset - CIA_TOD0) * 8);
+			if (m_tod_latched)
+			{
+				data = m_tod_latch >> ((offset - CIA_TOD0) * 8);
+			}
 			else
-				data = cia->tod >> ((offset - CIA_TOD0) * 8);
+			{
+				data = m_tod >> ((offset - CIA_TOD0) * 8);
+			}
 			break;
 
 		/* serial data ready */
 		case CIA_SDR:
-			data = cia->sdr;
+			data = m_sdr;
 			break;
 
 		/* interrupt status/clear */
 		case CIA_ICR:
-			data = cia->ics;
-			cia->ics = 0; /* clear on read */
-			cia_update_interrupts(device);
+			data = m_ics;
+			m_ics = 0; /* clear on read */
+			update_interrupts();
 			break;
 
 		/* timer A/B mode */
 		case CIA_CRA:
 		case CIA_CRB:
-			timer = &cia->timer[offset & 1];
-			data = timer->mode;
+			timer = &m_timer[offset & 1];
+			data = timer->m_mode;
 			break;
 	}
 
@@ -746,17 +706,15 @@
 }
 
 /*-------------------------------------------------
-    mos6526_w
+    reg_w
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( mos6526_w )
+void mos6526_device::reg_w(UINT8 offset, UINT8 data)
 {
 	cia_timer *timer;
-	cia_state *cia;
 	cia_port *port;
 	int shift;
 
-	cia = get_token(device);
 	offset &= 0x0F;
 
 	switch(offset)
@@ -764,48 +722,52 @@
 		/* port A/B data */
 		case CIA_PRA:
 		case CIA_PRB:
-			port = &cia->port[offset & 1];
-			port->latch = data;
-			port->out = (data & port->ddr) | (port->in & ~port->ddr);
-			devcb_call_write8(&port->write, 0, port->out);
+			port = &m_port[offset & 1];
+			port->m_latch = data;
+			port->m_out = (data & port->m_ddr) | (port->m_in & ~port->m_ddr);
+			devcb_call_write8(&port->m_write, 0, port->m_out);
 
 			/* pulse /PC following the write */
 			if (offset == CIA_PRB)
-				cia_update_pc(device);
+			{
+				update_pc();
+			}
 
 			break;
 
 		/* port A/B direction */
 		case CIA_DDRA:
 		case CIA_DDRB:
-			port = &cia->port[offset & 1];
-			port->ddr = data;
+			port = &m_port[offset & 1];
+			port->m_ddr = data;
 			break;
 
 		/* timer A/B latch low */
 		case CIA_TALO:
 		case CIA_TBLO:
-			timer = &cia->timer[(offset >> 1) & 1];
-			timer->latch = (timer->latch & 0xff00) | (data << 0);
+			timer = &m_timer[(offset >> 1) & 1];
+			timer->m_latch = (timer->m_latch & 0xff00) | (data << 0);
 			break;
 
 		/* timer A latch high */
 		case CIA_TAHI:
 		case CIA_TBHI:
-			timer = &cia->timer[(offset >> 1) & 1];
-			timer->latch = (timer->latch & 0x00ff) | (data << 8);
+			timer = &m_timer[(offset >> 1) & 1];
+			timer->m_latch = (timer->m_latch & 0x00ff) | (data << 8);
 
 			/* if the timer is one-shot, then force a start on it */
-			if (timer->mode & 0x08)
+			if (timer->m_mode & 0x08)
 			{
-				timer->mode |= 1;
-				cia_timer_update(timer, timer->latch);
+				timer->m_mode |= 1;
+				timer->update((offset >> 1) & 1, timer->m_latch);
 			}
 			else
 			{
 				/* if the timer is off, update the count */
-				if (!(timer->mode & 0x01))
-					cia_timer_update(timer, timer->latch);
+				if (!(timer->m_mode & 0x01))
+				{
+					timer->update((offset >> 1) & 1, timer->m_latch);
+				}
 			}
 			break;
 
@@ -817,191 +779,166 @@
 			shift = 8 * ((offset - CIA_TOD0));
 
 			/* alarm setting mode? */
-			if (cia->timer[1].mode & 0x80)
-				cia->alarm = (cia->alarm & ~(0xff << shift)) | (data << shift);
+			if (m_timer[1].m_mode & 0x80)
+			{
+				m_alarm = (m_alarm & ~(0xff << shift)) | (data << shift);
+			}
 			/* counter setting mode */
 			else
-				cia->tod = (cia->tod & ~(0xff << shift)) | (data << shift);
+			{
+				m_tod = (m_tod & ~(0xff << shift)) | (data << shift);
+			}
 
-			if (device->type() == MOS8520)
+			if (type() == MOS8520)
 			{
 				if (offset == CIA_TOD2)
-					cia->tod_running = FALSE;
+				{
+					m_tod_running = FALSE;
+				}
 			}
 			else
 			{
 				if (offset == CIA_TOD3)
-					cia->tod_running = FALSE;
+				{
+					m_tod_running = FALSE;
+				}
 			}
 			if (offset == CIA_TOD0)
-				cia->tod_running = TRUE;
+			{
+				m_tod_running = TRUE;
+			}
 			break;
 
 		/* serial data ready */
 		case CIA_SDR:
-			cia->sdr = data;
-			if (cia->timer[0].mode & 0x40)
-				cia->loaded = 1;
+			m_sdr = data;
+			if (m_timer[0].m_mode & 0x40)
+			{
+				m_loaded = 1;
+			}
 			break;
 
 		/* interrupt control register */
 		case CIA_ICR:
 			if (data & 0x80)
-				cia->icr |= data & 0x7f;
+			{
+				m_icr |= data & 0x7f;
+			}
 			else
-				cia->icr &= ~(data & 0x7f);
-			cia_update_interrupts(device);
+			{
+				m_icr &= ~(data & 0x7f);
+			}
+			update_interrupts();
 			break;
 
 		/* timer A/B modes */
 		case CIA_CRA:
 		case CIA_CRB:
-			timer = &cia->timer[offset & 1];
-			timer->mode = data & 0xef;
+			timer = &m_timer[offset & 1];
+			timer->m_mode = data & 0xef;
 
 			/* force load? */
 			if (data & 0x10)
-				cia_timer_update(timer, timer->latch);
+			{
+				timer->update(offset & 1, timer->m_latch);
+			}
 			else
-				cia_timer_update(timer, -1);
+			{
+				timer->update(offset & 1, -1);
+			}
 			break;
 	}
 }
 
 /*-------------------------------------------------
-    DEVICE_START( cia )
+    is_timer_active
 -------------------------------------------------*/
 
-static DEVICE_START( cia )
+static int is_timer_active(emu_timer *timer)
 {
-	int t, p;
-	cia_state *cia = get_token(device);
-	const mos6526_interface *intf = get_interface(device);
+	attotime t = timer_firetime(timer);
+	return attotime_compare(t, attotime_never) != 0;
+}
 
-	/* clear out CIA structure, and copy the interface */
-	memset(cia, 0, sizeof(*cia));
-	cia->device = device;
-	devcb_resolve_write_line(&cia->out_irq_func, &intf->out_irq_func, device);
-	devcb_resolve_write_line(&cia->out_pc_func, &intf->out_pc_func, device);
-	devcb_resolve_write_line(&cia->out_cnt_func, &intf->out_cnt_func, device);
-	devcb_resolve_write_line(&cia->out_sp_func, &intf->out_sp_func, device);
-	cia->flag = 1;
+/*-------------------------------------------------
+    update - updates the count and emu_timer for
+    a given CIA timer
+-------------------------------------------------*/
 
-	/* setup ports */
-	devcb_resolve_read8(&cia->port[0].read, &intf->in_pa_func, device);
-	devcb_resolve_write8(&cia->port[0].write, &intf->out_pa_func, device);
-	devcb_resolve_read8(&cia->port[1].read, &intf->in_pb_func, device);
-	devcb_resolve_write8(&cia->port[1].write, &intf->out_pb_func, device);
+void mos6526_device::cia_timer::update(int which, INT32 new_count)
+{
+	/* sanity check arguments */
+	assert((new_count >= -1) && (new_count <= 0xffff));
 
-	for (p = 0; p < (sizeof(cia->port) / sizeof(cia->port[0])); p++)
+	/* update the timer count, if necessary */
+	if ((new_count == -1) && is_timer_active(m_timer))
 	{
-		cia->port[p].mask_value = 0xff;
+		UINT16 current_count = attotime_to_double(attotime_mul(timer_timeelapsed(m_timer), m_clock));
+		m_count = m_count - MIN(m_count, current_count);
 	}
 
-	/* setup timers */
-	for (t = 0; t < (sizeof(cia->timer) / sizeof(cia->timer[0])); t++)
+	/* set the timer if we are instructed to */
+	if (new_count != -1)
 	{
-		cia_timer *timer = &cia->timer[t];
-		timer->timer = timer_alloc(device->machine, cia_timer_proc, timer);
-		timer->cia = cia;
-		timer->irq = 0x01 << t;
+		m_count = new_count;
 	}
 
-	/* setup TOD timer, if appropriate */
-	if (intf->tod_clock != 0)
-		timer_pulse(device->machine, ATTOTIME_IN_HZ(intf->tod_clock), (void *) device, 0, cia_clock_tod_callback);
-
-	/* state save support */
-	state_save_register_device_item(device, 0, cia->port[0].ddr);
-	state_save_register_device_item(device, 0, cia->port[0].latch);
-	state_save_register_device_item(device, 0, cia->port[0].in);
-	state_save_register_device_item(device, 0, cia->port[0].out);
-	state_save_register_device_item(device, 0, cia->port[0].mask_value);
-	state_save_register_device_item(device, 0, cia->port[1].ddr);
-	state_save_register_device_item(device, 0, cia->port[1].latch);
-	state_save_register_device_item(device, 0, cia->port[1].in);
-	state_save_register_device_item(device, 0, cia->port[1].out);
-	state_save_register_device_item(device, 0, cia->port[1].mask_value);
-	state_save_register_device_item(device, 0, cia->timer[0].latch);
-	state_save_register_device_item(device, 0, cia->timer[0].count);
-	state_save_register_device_item(device, 0, cia->timer[0].mode);
-	state_save_register_device_item(device, 0, cia->timer[0].irq);
-	state_save_register_device_item(device, 0, cia->timer[1].latch);
-	state_save_register_device_item(device, 0, cia->timer[1].count);
-	state_save_register_device_item(device, 0, cia->timer[1].mode);
-	state_save_register_device_item(device, 0, cia->timer[1].irq);
-	state_save_register_device_item(device, 0, cia->tod);
-	state_save_register_device_item(device, 0, cia->tod_latch);
-	state_save_register_device_item(device, 0, cia->tod_latched);
-	state_save_register_device_item(device, 0, cia->tod_running);
-	state_save_register_device_item(device, 0, cia->alarm);
-	state_save_register_device_item(device, 0, cia->icr);
-	state_save_register_device_item(device, 0, cia->ics);
-	state_save_register_device_item(device, 0, cia->irq);
-	state_save_register_device_item(device, 0, cia->flag);
-	state_save_register_device_item(device, 0, cia->loaded);
-	state_save_register_device_item(device, 0, cia->sdr);
-	state_save_register_device_item(device, 0, cia->sp);
-	state_save_register_device_item(device, 0, cia->cnt);
-	state_save_register_device_item(device, 0, cia->shift);
-	state_save_register_device_item(device, 0, cia->serial);
-}
-
-/*-------------------------------------------------
-    DEVICE_GET_INFO( cia6526r1 )
--------------------------------------------------*/
-
-DEVICE_GET_INFO(cia6526r1)
-{
-	switch (state)
+	/* now update the MAME timer */
+	if ((m_mode & 0x01) && ((m_mode & (which ? 0x60 : 0x20)) == 0x00))
 	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(cia_state);				break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;								break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(cia);		break;
-		case DEVINFO_FCT_STOP:							/* Nothing */								break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(cia);		break;
-//      case DEVINFO_FCT_VALIDITY_CHECK:                info->validity_check = DEVICE_VALIDITY_CHECK_NAME(cia); break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "MOS6526 rev1");			break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "MOS6526");					break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");						break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);					break;
-		case DEVINFO_STR_CREDITS:						/* Nothing */								break;
+		/* timer is on and is connected to clock */
+		attotime period = attotime_mul(ATTOTIME_IN_HZ(m_clock), (m_count ? m_count : 0x10000));
+		timer_adjust_oneshot(m_timer, period, which);
 	}
-}
-
-/*-------------------------------------------------
-    DEVICE_GET_INFO( cia8520 )
--------------------------------------------------*/
-
-DEVICE_GET_INFO(cia6526r2)
-{
-	switch (state)
+	else
 	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "MOS6526 rev2");			break;
-		default:	DEVICE_GET_INFO_CALL(cia6526r1);	break;
+		/* timer is off or not connected to clock */
+		timer_adjust_oneshot(m_timer, attotime_never, which);
 	}
 }
 
 /*-------------------------------------------------
-    DEVICE_GET_INFO( cia8520 )
+    get_count - get the count for a given CIA
+    timer
 -------------------------------------------------*/
 
-DEVICE_GET_INFO(cia8520)
+UINT16 mos6526_device::cia_timer::get_count()
 {
-	switch (state)
+	UINT16 count;
+
+	if (is_timer_active(m_timer))
+	{
+		UINT16 current_count = attotime_to_double(attotime_mul(timer_timeelapsed(m_timer), m_clock));
+		count = m_count - MIN(m_count, current_count);
+	}
+	else
 	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "MOS8520");				break;
-		default:	DEVICE_GET_INFO_CALL(cia6526r1);	break;
+		count = m_count;
 	}
+
+	return count;
 }
 
-DEFINE_LEGACY_DEVICE(MOS6526R1, cia6526r1);
-DEFINE_LEGACY_DEVICE(MOS6526R2, cia6526r2);
-DEFINE_LEGACY_DEVICE(MOS8520, cia8520);
+/***************************************************************************
+    TRAMPOLINES
+***************************************************************************/
+
+void cia_set_port_mask_value(running_device *device, int port, int data) { downcast<mos6526_device *>(device)->set_port_mask_value(port, data); }
+
+READ8_DEVICE_HANDLER( mos6526_r ) { return downcast<mos6526_device *>(device)->reg_r(offset); }
+WRITE8_DEVICE_HANDLER( mos6526_w ) { downcast<mos6526_device *>(device)->reg_w(offset, data); }
+
+READ8_DEVICE_HANDLER( mos6526_pa_r ) { return downcast<mos6526_device *>(device)->pa_r(offset); }
+READ8_DEVICE_HANDLER( mos6526_pb_r ) { return downcast<mos6526_device *>(device)->pb_r(offset); }
+
+READ_LINE_DEVICE_HANDLER( mos6526_irq_r ) { return downcast<mos6526_device *>(device)->irq_r(); }
+
+WRITE_LINE_DEVICE_HANDLER( mos6526_tod_w ) { downcast<mos6526_device *>(device)->tod_w(state); }
+
+READ_LINE_DEVICE_HANDLER( mos6526_cnt_r ) { return downcast<mos6526_device *>(device)->cnt_r(); }
+WRITE_LINE_DEVICE_HANDLER( mos6526_cnt_w ) { downcast<mos6526_device *>(device)->cnt_w(state); }
+
+READ_LINE_DEVICE_HANDLER( mos6526_sp_r ) { return downcast<mos6526_device *>(device)->sp_r(); }
+WRITE_LINE_DEVICE_HANDLER( mos6526_sp_w ) { downcast<mos6526_device *>(device)->sp_w(state); }
+
+WRITE_LINE_DEVICE_HANDLER( mos6526_flag_w ) { downcast<mos6526_device *>(device)->flag_w(state); }
diff -Nru src-old/emu/machine/6526cia.h src/emu/machine/6526cia.h
--- src-old/emu/machine/6526cia.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/6526cia.h	2010-08-28 10:50:23.000000000 -0700
@@ -30,18 +30,18 @@
 
 **********************************************************************/
 
+#pragma once
+
 #ifndef __6526CIA_H__
 #define __6526CIA_H__
 
-#include "devcb.h"
+#include "emu.h"
+
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(MOS6526R1, cia6526r1);
-DECLARE_LEGACY_DEVICE(MOS6526R2, cia6526r2);
-DECLARE_LEGACY_DEVICE(MOS8520, cia8520);
+	//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
 
 #define MDRV_MOS6526R1_ADD(_tag, _clock, _config) \
 	MDRV_DEVICE_ADD(_tag, MOS6526R1, _clock) \
@@ -65,23 +65,174 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _mos6526_interface mos6526_interface;
-struct _mos6526_interface
+
+// ======================> mos6526_interface
+
+struct mos6526_interface
 {
-	int tod_clock;
+	int m_tod_clock;
+
+	devcb_write_line	m_out_irq_func;
+	devcb_write_line	m_out_pc_func;
+	devcb_write_line	m_out_cnt_func;
+	devcb_write_line	m_out_sp_func;
 
-	devcb_write_line	out_irq_func;
-	devcb_write_line	out_pc_func;
-	devcb_write_line	out_cnt_func;
-	devcb_write_line	out_sp_func;
+	devcb_read8			m_in_pa_func;
+	devcb_write8		m_out_pa_func;
+
+	devcb_read8			m_in_pb_func;
+	devcb_write8		m_out_pb_func;
+};
+
+
+
+// ======================> mos6526_device_config
+
+class mos6526_device_config :   public device_config,
+                                public mos6526_interface
+{
+    friend class mos6526_device;
 
-	devcb_read8			in_pa_func;
-	devcb_write8		out_pa_func;
+    // construction/destruction
+    mos6526_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 
-	devcb_read8			in_pb_func;
-	devcb_write8		out_pb_func;
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
 };
 
+
+
+// ======================> mos6526_device
+
+class mos6526_device :  public device_t
+{
+    friend class mos6526_device_config;
+    friend class dart_channel;
+
+    // construction/destruction
+    mos6526_device(running_machine &_machine, const mos6526_device_config &_config);
+
+public:
+	UINT8 reg_r(UINT8 offset);
+	void reg_w(UINT8 offset, UINT8 data);
+
+	/* port access */
+	UINT8 pa_r(UINT8 offset) { return (m_port[0].m_latch | ~m_port[0].m_ddr); }
+	UINT8 pb_r(UINT8 offset) { return (m_port[1].m_latch | ~m_port[1].m_ddr); }
+
+	/* interrupt request */
+	UINT8 irq_r() { return m_irq; }
+
+	/* time of day clock */
+	void tod_w(UINT8 state) { if(state) clock_tod(); }
+
+	/* serial counter */
+	UINT8 cnt_r() { return m_cnt; }
+	void cnt_w(UINT8 state);
+
+	/* serial port */
+	UINT8 sp_r() { return m_sp; }
+	void sp_w(UINT8 state) { m_sp = state; }
+
+	/* flag */
+	void flag_w(UINT8 state);
+
+	/* port mask */
+	void set_port_mask_value(int port, int data);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( timer_proc );
+	static TIMER_CALLBACK( clock_tod_callback );
+
+private:
+
+	void update_pc();
+	void update_interrupts();
+	void timer_bump(int timer);
+	void timer_underflow(int timer);
+	void increment();
+	void clock_tod();
+
+	struct cia_timer
+	{
+	public:
+		cia_timer() { }
+
+		UINT16 get_count();
+		void update(int which, INT32 new_count);
+
+		UINT32			m_clock;
+		UINT16			m_latch;
+		UINT16			m_count;
+		UINT8			m_mode;
+		UINT8			m_irq;
+		emu_timer*		m_timer;
+		mos6526_device*	m_cia;
+	};
+
+	struct cia_port
+	{
+		UINT8		m_ddr;
+		UINT8		m_latch;
+		UINT8		m_in;
+		UINT8		m_out;
+		devcb_resolved_read8	m_read;
+		devcb_resolved_write8	m_write;
+		UINT8		m_mask_value; /* in READ operation the value can be forced by a extern electric circuit */
+	};
+
+	devcb_resolved_write_line m_out_irq_func;
+	devcb_resolved_write_line m_out_pc_func;
+	devcb_resolved_write_line m_out_cnt_func;
+	devcb_resolved_write_line m_out_sp_func;
+
+	cia_port		m_port[2];
+	cia_timer		m_timer[2];
+
+	/* Time Of the Day clock (TOD) */
+	UINT32			m_tod;
+	UINT32			m_tod_latch;
+	UINT8			m_tod_latched;
+	UINT8			m_tod_running;
+	UINT32			m_alarm;
+
+	/* Interrupts */
+	UINT8			m_icr;
+	UINT8			m_ics;
+	UINT8			m_irq;
+	int				m_flag;
+
+	/* Serial */
+	UINT8			m_loaded;
+	UINT8			m_sdr;
+	UINT8			m_sp;
+	UINT8			m_cnt;
+	UINT8			m_shift;
+	UINT8			m_serial;
+
+    const mos6526_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type MOS6526R1;
+extern const device_type MOS6526R2;
+extern const device_type MOS8520;
+
+
+
 /***************************************************************************
     FUNCTION PROTOTYPES
 ***************************************************************************/
diff -Nru src-old/emu/machine/6532riot.c src/emu/machine/6532riot.c
--- src-old/emu/machine/6532riot.c	2010-06-27 23:40:44.000000000 -0700
+++ src/emu/machine/6532riot.c	2010-08-28 09:48:51.000000000 -0700
@@ -31,76 +31,90 @@
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-typedef struct _riot6532_port riot6532_port;
-struct _riot6532_port
-{
-	UINT8					in;
-	UINT8					out;
-	UINT8					ddr;
-	devcb_resolved_read8	in_func;
-	devcb_resolved_write8	out_func;
-};
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
+//-------------------------------------------------
+//  riot6532_device_config - constructor
+//-------------------------------------------------
 
-typedef struct _riot6532_state riot6532_state;
-struct _riot6532_state
+riot6532_device_config::riot6532_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+	: device_config(mconfig, static_alloc_device_config, "6532 (RIOT)", tag, owner, clock)
 {
-	running_device *device;
-	const riot6532_interface *intf;
-	int				index;
-
-	riot6532_port	port[2];
+}
 
-	devcb_resolved_write_line	irq_func;
 
-	UINT8			irqstate;
-	UINT8			irqenable;
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
 
-	UINT8			pa7dir;		/* 0x80 = high-to-low, 0x00 = low-to-high */
-	UINT8			pa7prev;
+device_config *riot6532_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+	return global_alloc(riot6532_device_config(mconfig, tag, owner, clock));
+}
 
-	UINT8			timershift;
-	UINT8			timerstate;
-	emu_timer *		timer;
-};
 
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
 
+device_t *riot6532_device_config::alloc_device(running_machine &machine) const
+{
+	return auto_alloc(&machine, riot6532_device(machine, *this));
+}
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
 
-/*-------------------------------------------------
-    get_safe_token - convert a device's token
-    into a riot6532_state
--------------------------------------------------*/
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
 
-INLINE riot6532_state *get_safe_token(running_device *device)
+void riot6532_device_config::device_config_complete()
 {
-	assert(device != NULL);
-	assert(device->type() == RIOT6532);
-	return (riot6532_state *)downcast<legacy_device_base *>(device)->token();
+	// inherit a copy of the static data
+	const riot6532_interface *intf = reinterpret_cast<const riot6532_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<riot6532_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+		memset(&m_in_a_func, 0, sizeof(m_in_a_func));
+		memset(&m_in_b_func, 0, sizeof(m_in_b_func));
+		memset(&m_out_a_func, 0, sizeof(m_out_a_func));
+		memset(&m_out_b_func, 0, sizeof(m_out_b_func));
+		memset(&m_irq_func, 0, sizeof(m_irq_func));
+	}
 }
 
 
+
+/***************************************************************************
+    INTERNAL FUNCTIONS
+***************************************************************************/
+
 /*-------------------------------------------------
     update_irqstate - update the IRQ state
     based on interrupt enables
 -------------------------------------------------*/
 
-INLINE void update_irqstate(running_device *device)
+void riot6532_device::update_irqstate()
 {
-	riot6532_state *riot = get_safe_token(device);
-	int state = (riot->irqstate & riot->irqenable);
+	int state = (m_irqstate & m_irqenable);
 
-	if (riot->irq_func.write != NULL)
-		devcb_call_write_line(&riot->irq_func, (state != 0) ? ASSERT_LINE : CLEAR_LINE);
+	if (m_irq_func.write != NULL)
+	{
+		devcb_call_write_line(&m_irq_func, (state != 0) ? ASSERT_LINE : CLEAR_LINE);
+	}
 	else
-		logerror("%s:6532RIOT chip #%d: no irq callback function\n", cpuexec_describe_context(device->machine), riot->index);
+	{
+		logerror("%s:6532RIOT chip #%d: no irq callback function\n", cpuexec_describe_context(&m_machine), m_index);
+	}
 }
 
 
@@ -109,9 +123,9 @@
     according to the DDR
 -------------------------------------------------*/
 
-INLINE UINT8 apply_ddr(const riot6532_port *port)
+UINT8 riot6532_device::apply_ddr(const riot6532_port *port)
 {
-	return (port->out & port->ddr) | (port->in & ~port->ddr);
+	return (port->m_out & port->m_ddr) | (port->m_in & ~port->m_ddr);
 }
 
 
@@ -120,18 +134,17 @@
     and signal appropriately
 -------------------------------------------------*/
 
-INLINE void update_pa7_state(running_device *device)
+void riot6532_device::update_pa7_state()
 {
-	riot6532_state *riot = get_safe_token(device);
-	UINT8 data = apply_ddr(&riot->port[0]) & 0x80;
+	UINT8 data = apply_ddr(&m_port[0]) & 0x80;
 
 	/* if the state changed in the correct direction, set the PA7 flag and update IRQs */
-	if ((riot->pa7prev ^ data) && (riot->pa7dir ^ data) == 0)
+	if ((m_pa7prev ^ data) && (m_pa7dir ^ data) == 0)
 	{
-		riot->irqstate |= PA7_FLAG;
-		update_irqstate(device);
+		m_irqstate |= PA7_FLAG;
+		update_irqstate();
 	}
-	riot->pa7prev = data;
+	m_pa7prev = data;
 }
 
 
@@ -139,54 +152,59 @@
     get_timer - return the current timer value
 -------------------------------------------------*/
 
-INLINE UINT8 get_timer(riot6532_state *riot)
+UINT8 riot6532_device::get_timer()
 {
 	/* if idle, return 0 */
-	if (riot->timerstate == TIMER_IDLE)
+	if (m_timerstate == TIMER_IDLE)
+	{
 		return 0;
+	}
 
 	/* if counting, return the number of ticks remaining */
-	else if (riot->timerstate == TIMER_COUNTING)
-		return attotime_to_ticks(timer_timeleft(riot->timer), riot->device->clock()) >> riot->timershift;
+	else if (m_timerstate == TIMER_COUNTING)
+	{
+		return attotime_to_ticks(timer_timeleft(m_timer), clock()) >> m_timershift;
+	}
 
 	/* if finishing, return the number of ticks without the shift */
 	else
-		return attotime_to_ticks(timer_timeleft(riot->timer), riot->device->clock());
+	{
+		return attotime_to_ticks(timer_timeleft(m_timer), clock());
+	}
 }
 
 
 
-/***************************************************************************
-    INTERNAL FUNCTIONS
-***************************************************************************/
-
 /*-------------------------------------------------
     timer_end_callback - callback to process the
     timer
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( timer_end_callback )
+TIMER_CALLBACK( riot6532_device::timer_end_callback )
 {
-	running_device *device = (running_device *)ptr;
-	riot6532_state *riot = get_safe_token(device);
+	riot6532_device *via = reinterpret_cast<riot6532_device *>(ptr);
+	via->timer_end();
+}
 
-	assert(riot->timerstate != TIMER_IDLE);
+void riot6532_device::timer_end()
+{
+	assert(m_timerstate != TIMER_IDLE);
 
 	/* if we finished counting, switch to the finishing state */
-	if (riot->timerstate == TIMER_COUNTING)
+	if(m_timerstate == TIMER_COUNTING)
 	{
-		riot->timerstate = TIMER_FINISHING;
-		timer_adjust_oneshot(riot->timer, ticks_to_attotime(256, device->clock()), 0);
+		m_timerstate = TIMER_FINISHING;
+		timer_adjust_oneshot(m_timer, ticks_to_attotime(256, clock()), 0);
 
 		/* signal timer IRQ as well */
-		riot->irqstate |= TIMER_FLAG;
-		update_irqstate(device);
+		m_irqstate |= TIMER_FLAG;
+		update_irqstate();
 	}
 
 	/* if we finished finishing, keep spinning */
-	else if (riot->timerstate == TIMER_FINISHING)
+	else if (m_timerstate == TIMER_FINISHING)
 	{
-		timer_adjust_oneshot(riot->timer, ticks_to_attotime(256, device->clock()), 0);
+		timer_adjust_oneshot(m_timer, ticks_to_attotime(256, clock()), 0);
 	}
 }
 
@@ -202,33 +220,39 @@
 
 WRITE8_DEVICE_HANDLER( riot6532_w )
 {
-	riot6532_state *riot = get_safe_token(device);
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	via->reg_w(offset, data);
+}
 
+void riot6532_device::reg_w(UINT8 offset, UINT8 data)
+{
 	/* if A4 == 1 and A2 == 1, we are writing to the timer */
 	if ((offset & 0x14) == 0x14)
 	{
 		static const UINT8 timershift[4] = { 0, 3, 6, 10 };
-		attotime curtime = timer_get_time(device->machine);
+		attotime curtime = timer_get_time(&m_machine);
 		INT64 target;
 
 		/* A0-A1 contain the timer divisor */
-		riot->timershift = timershift[offset & 3];
+		m_timershift = timershift[offset & 3];
 
 		/* A3 contains the timer IRQ enable */
 		if (offset & 8)
-			riot->irqenable |= TIMER_FLAG;
+			m_irqenable |= TIMER_FLAG;
 		else
-			riot->irqenable &= ~TIMER_FLAG;
+			m_irqenable &= ~TIMER_FLAG;
 
 		/* writes here clear the timer flag */
-		if (riot->timerstate != TIMER_FINISHING || get_timer(riot) != 0xff)
-			riot->irqstate &= ~TIMER_FLAG;
-		update_irqstate(device);
+		if (m_timerstate != TIMER_FINISHING || get_timer() != 0xff)
+		{
+			m_irqstate &= ~TIMER_FLAG;
+		}
+		update_irqstate();
 
 		/* update the timer */
-		riot->timerstate = TIMER_COUNTING;
-		target = attotime_to_ticks(curtime, device->clock()) + 1 + (data << riot->timershift);
-		timer_adjust_oneshot(riot->timer, attotime_sub(ticks_to_attotime(target, device->clock()), curtime), 0);
+		m_timerstate = TIMER_COUNTING;
+		target = attotime_to_ticks(curtime, clock()) + 1 + (data << m_timershift);
+		timer_adjust_oneshot(m_timer, attotime_sub(ticks_to_attotime(target, clock()), curtime), 0);
 	}
 
 	/* if A4 == 0 and A2 == 1, we are writing to the edge detect control */
@@ -236,37 +260,49 @@
 	{
 		/* A1 contains the A7 IRQ enable */
 		if (offset & 2)
-			riot->irqenable |= PA7_FLAG;
+		{
+			m_irqenable |= PA7_FLAG;
+		}
 		else
-			riot->irqenable &= ~PA7_FLAG;
+		{
+			m_irqenable &= ~PA7_FLAG;
+		}
 
 		/* A0 specifies the edge detect direction: 0=negative, 1=positive */
-		riot->pa7dir = (offset & 1) << 7;
+		m_pa7dir = (offset & 1) << 7;
 	}
 
 	/* if A4 == anything and A2 == 0, we are writing to the I/O section */
 	else
 	{
 		/* A1 selects the port */
-		riot6532_port *port = &riot->port[(offset >> 1) & 1];
+		riot6532_port *port = &m_port[(offset >> 1) & 1];
 
 		/* if A0 == 1, we are writing to the port's DDR */
 		if (offset & 1)
-			port->ddr = data;
+		{
+			port->m_ddr = data;
+		}
 
 		/* if A0 == 0, we are writing to the port's output */
 		else
 		{
-			port->out = data;
-			if (port->out_func.write != NULL)
-				devcb_call_write8(&port->out_func, 0, data);
+			port->m_out = data;
+			if (port->m_out_func.write != NULL)
+			{
+				devcb_call_write8(&port->m_out_func, 0, data);
+			}
 			else
-				logerror("%s:6532RIOT chip %s: Port %c is being written to but has no handler. %02X\n", cpuexec_describe_context(device->machine), device->tag(), 'A' + (offset & 1), data);
+			{
+				logerror("%s:6532RIOT chip %s: Port %c is being written to but has no handler. %02X\n", cpuexec_describe_context(&m_machine), tag(), 'A' + (offset & 1), data);
+			}
 		}
 
 		/* writes to port A need to update the PA7 state */
-		if (port == &riot->port[0])
-			update_pa7_state(device);
+		if (port == &m_port[0])
+		{
+			update_pa7_state();
+		}
 	}
 }
 
@@ -277,60 +313,77 @@
 
 READ8_DEVICE_HANDLER( riot6532_r )
 {
-	riot6532_state *riot = get_safe_token(device);
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	return via->reg_r(offset);
+}
+
+UINT8 riot6532_device::reg_r(UINT8 offset)
+{
 	UINT8 val = 0;
 
 	/* if A2 == 1 and A0 == 1, we are reading interrupt flags */
 	if ((offset & 0x05) == 0x05)
 	{
-		val = riot->irqstate;
+		val = m_irqstate;
 
 		/* implicitly clears the PA7 flag */
-		riot->irqstate &= ~PA7_FLAG;
-		update_irqstate(device);
+		m_irqstate &= ~PA7_FLAG;
+		update_irqstate();
 	}
 
 	/* if A2 == 1 and A0 == 0, we are reading the timer */
 	else if ((offset & 0x05) == 0x04)
 	{
-		val = get_timer(riot);
+		val = get_timer();
 
 		/* A3 contains the timer IRQ enable */
 		if (offset & 8)
-			riot->irqenable |= TIMER_FLAG;
+		{
+			m_irqenable |= TIMER_FLAG;
+		}
 		else
-			riot->irqenable &= ~TIMER_FLAG;
+		{
+			m_irqenable &= ~TIMER_FLAG;
+		}
 
 		/* implicitly clears the timer flag */
-		if (riot->timerstate != TIMER_FINISHING || val != 0xff)
-			riot->irqstate &= ~TIMER_FLAG;
-		update_irqstate(device);
+		if (m_timerstate != TIMER_FINISHING || val != 0xff)
+		{
+			m_irqstate &= ~TIMER_FLAG;
+		}
+		update_irqstate();
 	}
 
 	/* if A2 == 0 and A0 == anything, we are reading from ports */
 	else
 	{
 		/* A1 selects the port */
-		riot6532_port *port = &riot->port[(offset >> 1) & 1];
+		riot6532_port *port = &m_port[(offset >> 1) & 1];
 
 		/* if A0 == 1, we are reading the port's DDR */
 		if (offset & 1)
-			val = port->ddr;
+		{
+			val = port->m_ddr;
+		}
 
 		/* if A0 == 0, we are reading the port as an input */
 		else
 		{
 			/* call the input callback if it exists */
-			if (port->in_func.read != NULL)
+			if (port->m_in_func.read != NULL)
 			{
-				port->in = devcb_call_read8(&port->in_func, 0);
+				port->m_in = devcb_call_read8(&port->m_in_func, 0);
 
 				/* changes to port A need to update the PA7 state */
-				if (port == &riot->port[0])
-					update_pa7_state(device);
+				if (port == &m_port[0])
+				{
+					update_pa7_state();
+				}
 			}
 			else
-				logerror("%s:6532RIOT chip %s: Port %c is being read but has no handler\n", cpuexec_describe_context(device->machine), device->tag(), 'A' + (offset & 1));
+			{
+				logerror("%s:6532RIOT chip %s: Port %c is being read but has no handler\n", cpuexec_describe_context(&m_machine), tag(), 'A' + (offset & 1));
+			}
 
 			/* apply the DDR to the result */
 			val = apply_ddr(port);
@@ -341,177 +394,185 @@
 
 
 /*-------------------------------------------------
-    riot6532_porta_in_set - set port A input
-    value
+    porta_in_set - set port A input value
 -------------------------------------------------*/
 
 void riot6532_porta_in_set(running_device *device, UINT8 data, UINT8 mask)
 {
-	riot6532_state *riot = get_safe_token(device);
-	riot->port[0].in = (riot->port[0].in & ~mask) | (data & mask);
-	update_pa7_state(device);
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	via->porta_in_set(data, mask);
+}
+
+void riot6532_device::porta_in_set(UINT8 data, UINT8 mask)
+{
+	m_port[0].m_in = (m_port[0].m_in & ~mask) | (data & mask);
+	update_pa7_state();
 }
 
 
 /*-------------------------------------------------
-    riot6532_portb_in_set - set port B input
-    value
+    portb_in_set - set port B input value
 -------------------------------------------------*/
 
 void riot6532_portb_in_set(running_device *device, UINT8 data, UINT8 mask)
 {
-	riot6532_state *riot = get_safe_token(device);
-	riot->port[1].in = (riot->port[1].in & ~mask) | (data & mask);
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	via->portb_in_set(data, mask);
+}
+
+void riot6532_device::portb_in_set(UINT8 data, UINT8 mask)
+{
+	m_port[1].m_in = (m_port[1].m_in & ~mask) | (data & mask);
 }
 
 
 /*-------------------------------------------------
-    riot6532_porta_in_get - return port A input
-    value
+    porta_in_get - return port A input value
 -------------------------------------------------*/
 
 UINT8 riot6532_porta_in_get(running_device *device)
 {
-	riot6532_state *riot = get_safe_token(device);
-	return riot->port[0].in;
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	return via->porta_in_get();
+}
+
+UINT8 riot6532_device::porta_in_get()
+{
+	return m_port[0].m_in;
 }
 
 
 /*-------------------------------------------------
-    riot6532_portb_in_get - return port B input
-    value
+    portb_in_get - return port B input value
 -------------------------------------------------*/
 
 UINT8 riot6532_portb_in_get(running_device *device)
 {
-	riot6532_state *riot = get_safe_token(device);
-	return riot->port[1].in;
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	return via->portb_in_get();
+}
+
+UINT8 riot6532_device::portb_in_get()
+{
+	return m_port[1].m_in;
 }
 
 
 /*-------------------------------------------------
-    riot6532_porta_in_get - return port A output
-    value
+    porta_in_get - return port A output value
 -------------------------------------------------*/
 
 UINT8 riot6532_porta_out_get(running_device *device)
 {
-	riot6532_state *riot = get_safe_token(device);
-	return riot->port[0].out;
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	return via->porta_out_get();
+}
+
+UINT8 riot6532_device::porta_out_get()
+{
+	return m_port[0].m_out;
 }
 
 
 /*-------------------------------------------------
-    riot6532_portb_in_get - return port B output
-    value
+    portb_in_get - return port B output value
 -------------------------------------------------*/
 
 UINT8 riot6532_portb_out_get(running_device *device)
 {
-	riot6532_state *riot = get_safe_token(device);
-	return riot->port[1].out;
+	riot6532_device *via = downcast<riot6532_device *>(device);
+	return via->portb_out_get();
 }
 
+UINT8 riot6532_device::portb_out_get()
+{
+	return m_port[1].m_out;
+}
 
-/***************************************************************************
-    DEVICE INTERFACE
-***************************************************************************/
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  riot6532_device - constructor
+//-------------------------------------------------
+
+riot6532_device::riot6532_device(running_machine &_machine, const riot6532_device_config &config)
+	: device_t(_machine, config),
+	  m_config(config)
+{
+}
 
 /*-------------------------------------------------
-    riot6532_portb_r - return port B output
-    value
+    device_start - device-specific startup
 -------------------------------------------------*/
 
-static DEVICE_START( riot6532 )
+void riot6532_device::device_start()
 {
-	riot6532_state *riot = get_safe_token(device);
-
 	/* validate arguments */
-	assert(device != NULL);
+	assert(this != NULL);
 
 	/* set static values */
-	riot->device = device;
-	riot->intf = (riot6532_interface *)device->baseconfig().static_config();
-	riot->index = device->machine->m_devicelist.index(RIOT6532, device->tag());
+	m_index = m_machine.m_devicelist.index(RIOT6532, tag());
 
 	/* configure the ports */
-	devcb_resolve_read8(&riot->port[0].in_func, &riot->intf->in_a_func, device);
-	devcb_resolve_write8(&riot->port[0].out_func, &riot->intf->out_a_func, device);
-	devcb_resolve_read8(&riot->port[1].in_func, &riot->intf->in_b_func, device);
-	devcb_resolve_write8(&riot->port[1].out_func, &riot->intf->out_b_func, device);
+	devcb_resolve_read8(&m_port[0].m_in_func, &m_config.m_in_a_func, this);
+	devcb_resolve_write8(&m_port[0].m_out_func, &m_config.m_out_a_func, this);
+	devcb_resolve_read8(&m_port[1].m_in_func, &m_config.m_in_b_func, this);
+	devcb_resolve_write8(&m_port[1].m_out_func, &m_config.m_out_b_func, this);
 
 	/* resolve irq func */
-	devcb_resolve_write_line(&riot->irq_func, &riot->intf->irq_func, device);
+	devcb_resolve_write_line(&m_irq_func, &m_config.m_irq_func, this);
 
 	/* allocate timers */
-	riot->timer = timer_alloc(device->machine, timer_end_callback, (void *)device);
+	m_timer = timer_alloc(&m_machine, timer_end_callback, (void *)this);
 
 	/* register for save states */
-	state_save_register_device_item(device, 0, riot->port[0].in);
-	state_save_register_device_item(device, 0, riot->port[0].out);
-	state_save_register_device_item(device, 0, riot->port[0].ddr);
-	state_save_register_device_item(device, 0, riot->port[1].in);
-	state_save_register_device_item(device, 0, riot->port[1].out);
-	state_save_register_device_item(device, 0, riot->port[1].ddr);
+	state_save_register_device_item(this, 0, m_port[0].m_in);
+	state_save_register_device_item(this, 0, m_port[0].m_out);
+	state_save_register_device_item(this, 0, m_port[0].m_ddr);
+	state_save_register_device_item(this, 0, m_port[1].m_in);
+	state_save_register_device_item(this, 0, m_port[1].m_out);
+	state_save_register_device_item(this, 0, m_port[1].m_ddr);
 
-	state_save_register_device_item(device, 0, riot->irqstate);
-	state_save_register_device_item(device, 0, riot->irqenable);
+	state_save_register_device_item(this, 0, m_irqstate);
+	state_save_register_device_item(this, 0, m_irqenable);
 
-	state_save_register_device_item(device, 0, riot->pa7dir);
-	state_save_register_device_item(device, 0, riot->pa7prev);
+	state_save_register_device_item(this, 0, m_pa7dir);
+	state_save_register_device_item(this, 0, m_pa7prev);
 
-	state_save_register_device_item(device, 0, riot->timershift);
-	state_save_register_device_item(device, 0, riot->timerstate);
+	state_save_register_device_item(this, 0, m_timershift);
+	state_save_register_device_item(this, 0, m_timerstate);
 }
 
 
-static DEVICE_RESET( riot6532 )
-{
-	riot6532_state *riot = get_safe_token(device);
 
+/*-------------------------------------------------
+    device_reset - device-specific reset
+-------------------------------------------------*/
+
+void riot6532_device::device_reset()
+{
 	/* reset I/O states */
-	riot->port[0].out = 0;
-	riot->port[0].ddr = 0;
-	riot->port[1].out = 0;
-	riot->port[1].ddr = 0;
+	m_port[0].m_out = 0;
+	m_port[0].m_ddr = 0;
+	m_port[1].m_out = 0;
+	m_port[1].m_ddr = 0;
 
 	/* reset IRQ states */
-	riot->irqenable = 0;
-	riot->irqstate = 0;
-	update_irqstate(device);
+	m_irqenable = 0;
+	m_irqstate = 0;
+	update_irqstate();
 
 	/* reset PA7 states */
-	riot->pa7dir = 0;
-	riot->pa7prev = 0;
+	m_pa7dir = 0;
+	m_pa7prev = 0;
 
 	/* reset timer states */
-	riot->timershift = 0;
-	riot->timerstate = TIMER_IDLE;
-	timer_adjust_oneshot(riot->timer, attotime_never, 0);
+	m_timershift = 0;
+	m_timerstate = TIMER_IDLE;
+	timer_adjust_oneshot(m_timer, attotime_never, 0);
 }
 
-
-DEVICE_GET_INFO( riot6532 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(riot6532_state);		break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;							break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(riot6532);break;
-		case DEVINFO_FCT_STOP:							/* Nothing */							break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(riot6532);break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "6532 (RIOT)");			break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "I/O devices");			break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");					break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);				break;
-		case DEVINFO_STR_CREDITS:						strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
-}
-
-
-DEFINE_LEGACY_DEVICE(RIOT6532, riot6532);
+const device_type RIOT6532 = riot6532_device_config::static_alloc_device_config;
diff -Nru src-old/emu/machine/6532riot.h src/emu/machine/6532riot.h
--- src-old/emu/machine/6532riot.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/6532riot.h	2010-08-22 20:31:52.000000000 -0700
@@ -4,10 +4,23 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __RIOT6532_H__
 #define __RIOT6532_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
+
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MDRV_RIOT6532_ADD(_tag, _clock, _intrf) \
+    MDRV_DEVICE_ADD(_tag, RIOT6532, _clock) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
 
 
 /***************************************************************************
@@ -15,30 +28,117 @@
 ***************************************************************************/
 
 
-typedef struct _riot6532_interface riot6532_interface;
-struct _riot6532_interface
+// ======================> riot6532_interface
+
+struct riot6532_interface
 {
-	devcb_read8			in_a_func;
-	devcb_read8			in_b_func;
-	devcb_write8		out_a_func;
-	devcb_write8		out_b_func;
-	devcb_write_line	irq_func;
+    devcb_read8         m_in_a_func;
+    devcb_read8         m_in_b_func;
+    devcb_write8        m_out_a_func;
+    devcb_write8        m_out_b_func;
+    devcb_write_line    m_irq_func;
 };
 
 
 
-/***************************************************************************
-    DEVICE CONFIGURATION MACROS
-***************************************************************************/
+// ======================> riot6532_device_config
 
-#define MDRV_RIOT6532_ADD(_tag, _clock, _intrf) \
-	MDRV_DEVICE_ADD(_tag, RIOT6532, _clock) \
-	MDRV_DEVICE_CONFIG(_intrf)
+class riot6532_device_config : public device_config,
+                               public riot6532_interface
+{
+    friend class riot6532_device;
+
+    // construction/destruction
+    riot6532_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> riot6532_device
+
+class riot6532_device :  public device_t
+{
+    friend class riot6532_device_config;
+
+    // construction/destruction
+    riot6532_device(running_machine &_machine, const riot6532_device_config &_config);
+
+public:
+    UINT8 reg_r(UINT8 offset);
+    void reg_w(UINT8 offset, UINT8 data);
+
+    void porta_in_set(UINT8 data, UINT8 mask);
+    void portb_in_set(UINT8 data, UINT8 mask);
+
+    UINT8 porta_in_get();
+    UINT8 portb_in_get();
+
+    UINT8 porta_out_get();
+    UINT8 portb_out_get();
+
+    void timer_end();
+
+protected:
+    class riot6532_port
+    {
+    public:
+        UINT8                   m_in;
+        UINT8                   m_out;
+        UINT8                   m_ddr;
+        devcb_resolved_read8    m_in_func;
+        devcb_resolved_write8   m_out_func;
+    };
+
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+    static TIMER_CALLBACK( timer_end_callback );
+
+private:
+    void update_irqstate();
+    UINT8 apply_ddr(const riot6532_port *port);
+    void update_pa7_state();
+    UINT8 get_timer();
+
+    int             m_index;
+
+    riot6532_port   m_port[2];
+
+    devcb_resolved_write_line   m_irq_func;
+
+    UINT8           m_irqstate;
+    UINT8           m_irqenable;
+
+    UINT8           m_pa7dir;     /* 0x80 = high-to-low, 0x00 = low-to-high */
+    UINT8           m_pa7prev;
+
+    UINT8           m_timershift;
+    UINT8           m_timerstate;
+    emu_timer *     m_timer;
+
+    const riot6532_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type RIOT6532;
 
 
 
 /***************************************************************************
-    FUNCTION PROTOTYPES
+    PROTOTYPES
 ***************************************************************************/
 
 READ8_DEVICE_HANDLER( riot6532_r );
@@ -53,9 +153,4 @@
 UINT8 riot6532_porta_out_get(running_device *device);
 UINT8 riot6532_portb_out_get(running_device *device);
 
-
-/* ----- device interface ----- */
-
-DECLARE_LEGACY_DEVICE(RIOT6532, riot6532);
-
 #endif
diff -Nru src-old/emu/machine/6821pia.c src/emu/machine/6821pia.c
--- src-old/emu/machine/6821pia.c	2010-07-16 04:59:31.000000000 -0700
+++ src/emu/machine/6821pia.c	2010-08-28 09:48:51.000000000 -0700
@@ -9,71 +9,6 @@
 
 
 /***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-typedef struct _pia6821_state pia6821_state;
-struct _pia6821_state
-{
-	devcb_resolved_read8 in_a_func;
-	devcb_resolved_read8 in_b_func;
-	devcb_resolved_read_line in_ca1_func;
-	devcb_resolved_read_line in_cb1_func;
-	devcb_resolved_read_line in_ca2_func;
-	devcb_resolved_read_line in_cb2_func;
-	devcb_resolved_write8 out_a_func;
-	devcb_resolved_write8 out_b_func;
-	devcb_resolved_write_line out_ca2_func;
-	devcb_resolved_write_line out_cb2_func;
-	devcb_resolved_write_line irq_a_func;
-	devcb_resolved_write_line irq_b_func;
-
-	UINT8 in_a;
-	UINT8 in_ca1;
-	UINT8 in_ca2;
-	UINT8 out_a;
-	UINT8 out_ca2;
-	UINT8 port_a_z_mask;
-	UINT8 ddr_a;
-	UINT8 ctl_a;
-	UINT8 irq_a1;
-	UINT8 irq_a2;
-	UINT8 irq_a_state;
-
-	UINT8 in_b;
-	UINT8 in_cb1;
-	UINT8 in_cb2;
-	UINT8 out_b;
-	UINT8 out_cb2;
-	UINT8 last_out_cb2_z;
-	UINT8 ddr_b;
-	UINT8 ctl_b;
-	UINT8 irq_b1;
-	UINT8 irq_b2;
-	UINT8 irq_b_state;
-
-	/* variables that indicate if access a line externally -
-       used to for logging purposes ONLY */
-	UINT8 in_a_pushed;
-	UINT8 out_a_needs_pulled;
-	UINT8 in_ca1_pushed;
-	UINT8 in_ca2_pushed;
-	UINT8 out_ca2_needs_pulled;
-	UINT8 in_b_pushed;
-	UINT8 out_b_needs_pulled;
-	UINT8 in_cb1_pushed;
-	UINT8 in_cb2_pushed;
-	UINT8 out_cb2_needs_pulled;
-	UINT8 logged_port_a_not_connected;
-	UINT8 logged_port_b_not_connected;
-	UINT8 logged_ca1_not_connected;
-	UINT8 logged_ca2_not_connected;
-	UINT8 logged_cb1_not_connected;
-	UINT8 logged_cb2_not_connected;
-};
-
-
-/***************************************************************************
     MACROS
 ***************************************************************************/
 
@@ -100,151 +35,203 @@
 #define C2_INPUT(c)				(!(((c) >> 5) & 0x01))
 
 
-/***************************************************************************
-    PROTOTYPES
-***************************************************************************/
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-INLINE pia6821_state *get_token(running_device *device)
+//-------------------------------------------------
+//  pia6821_device_config - constructor
+//-------------------------------------------------
+
+pia6821_device_config::pia6821_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "6822 PIA", tag, owner, clock)
 {
-	assert(device != NULL);
-	assert((device->type() == PIA6821) || (device->type() == PIA6822));
-	return (pia6821_state *) downcast<legacy_device_base *>(device)->token();
 }
 
 
-INLINE const pia6821_interface *get_interface(running_device *device)
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *pia6821_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
 {
-	assert(device != NULL);
-	assert((device->type() == PIA6821) || (device->type() == PIA6822));
-	return (const pia6821_interface *) device->baseconfig().static_config();
+    return global_alloc(pia6821_device_config(mconfig, tag, owner, clock));
 }
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    DEVICE_START( pia6821 )
--------------------------------------------------*/
+device_t *pia6821_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, pia6821_device(machine, *this));
+}
+
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
 
-static DEVICE_START( pia6821 )
+void pia6821_device_config::device_config_complete()
 {
-	pia6821_state *p = get_token(device);
-	const pia6821_interface *intf = get_interface(device);
+	// inherit a copy of the static data
+	const pia6821_interface *intf = reinterpret_cast<const pia6821_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<pia6821_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_in_a_func, 0, sizeof(m_in_a_func));
+    	memset(&m_in_b_func, 0, sizeof(m_in_b_func));
+    	memset(&m_in_ca1_func, 0, sizeof(m_in_ca1_func));
+    	memset(&m_in_cb1_func, 0, sizeof(m_in_cb1_func));
+    	memset(&m_in_ca2_func, 0, sizeof(m_in_ca2_func));
+    	memset(&m_in_cb2_func, 0, sizeof(m_in_cb2_func));
+    	memset(&m_out_a_func, 0, sizeof(m_out_a_func));
+    	memset(&m_out_b_func, 0, sizeof(m_out_b_func));
+    	memset(&m_out_ca2_func, 0, sizeof(m_out_ca2_func));
+    	memset(&m_out_cb2_func, 0, sizeof(m_out_cb2_func));
+    	memset(&m_irq_a_func, 0, sizeof(m_irq_a_func));
+    	memset(&m_irq_b_func, 0, sizeof(m_irq_b_func));
+	}
+}
+
 
-	/* clear structure */
-	memset(p, 0, sizeof(*p));
 
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type PIA6821 = pia6821_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  pia6821_device - constructor
+//-------------------------------------------------
+
+pia6821_device::pia6821_device(running_machine &_machine, const pia6821_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
+
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void pia6821_device::device_start()
+{
 	/* resolve callbacks */
-	devcb_resolve_read8(&p->in_a_func, &intf->in_a_func, device);
-	devcb_resolve_read8(&p->in_b_func, &intf->in_b_func, device);
-	devcb_resolve_read_line(&p->in_ca1_func, &intf->in_ca1_func, device);
-	devcb_resolve_read_line(&p->in_cb1_func, &intf->in_cb1_func, device);
-	devcb_resolve_read_line(&p->in_ca2_func, &intf->in_ca2_func, device);
-	devcb_resolve_read_line(&p->in_cb2_func, &intf->in_cb2_func, device);
-	devcb_resolve_write8(&p->out_a_func, &intf->out_a_func, device);
-	devcb_resolve_write8(&p->out_b_func, &intf->out_b_func, device);
-	devcb_resolve_write_line(&p->out_ca2_func, &intf->out_ca2_func, device);
-	devcb_resolve_write_line(&p->out_cb2_func, &intf->out_cb2_func, device);
-	devcb_resolve_write_line(&p->irq_a_func, &intf->irq_a_func, device);
-	devcb_resolve_write_line(&p->irq_b_func, &intf->irq_b_func, device);
-
-	state_save_register_device_item(device, 0, p->in_a);
-	state_save_register_device_item(device, 0, p->in_ca1);
-	state_save_register_device_item(device, 0, p->in_ca2);
-	state_save_register_device_item(device, 0, p->out_a);
-	state_save_register_device_item(device, 0, p->out_ca2);
-	state_save_register_device_item(device, 0, p->port_a_z_mask);
-	state_save_register_device_item(device, 0, p->ddr_a);
-	state_save_register_device_item(device, 0, p->ctl_a);
-	state_save_register_device_item(device, 0, p->irq_a1);
-	state_save_register_device_item(device, 0, p->irq_a2);
-	state_save_register_device_item(device, 0, p->irq_a_state);
-	state_save_register_device_item(device, 0, p->in_b);
-	state_save_register_device_item(device, 0, p->in_cb1);
-	state_save_register_device_item(device, 0, p->in_cb2);
-	state_save_register_device_item(device, 0, p->out_b);
-	state_save_register_device_item(device, 0, p->out_cb2);
-	state_save_register_device_item(device, 0, p->last_out_cb2_z);
-	state_save_register_device_item(device, 0, p->ddr_b);
-	state_save_register_device_item(device, 0, p->ctl_b);
-	state_save_register_device_item(device, 0, p->irq_b1);
-	state_save_register_device_item(device, 0, p->irq_b2);
-	state_save_register_device_item(device, 0, p->irq_b_state);
-	state_save_register_device_item(device, 0, p->in_a_pushed);
-	state_save_register_device_item(device, 0, p->out_a_needs_pulled);
-	state_save_register_device_item(device, 0, p->in_ca1_pushed);
-	state_save_register_device_item(device, 0, p->in_ca2_pushed);
-	state_save_register_device_item(device, 0, p->out_ca2_needs_pulled);
-	state_save_register_device_item(device, 0, p->in_b_pushed);
-	state_save_register_device_item(device, 0, p->out_b_needs_pulled);
-	state_save_register_device_item(device, 0, p->in_cb1_pushed);
-	state_save_register_device_item(device, 0, p->in_cb2_pushed);
-	state_save_register_device_item(device, 0, p->out_cb2_needs_pulled);
+    devcb_resolve_read8(&m_in_a_func, &m_config.m_in_a_func, this);
+    devcb_resolve_read8(&m_in_b_func, &m_config.m_in_b_func, this);
+    devcb_resolve_read_line(&m_in_ca1_func, &m_config.m_in_ca1_func, this);
+    devcb_resolve_read_line(&m_in_cb1_func, &m_config.m_in_cb1_func, this);
+    devcb_resolve_read_line(&m_in_ca2_func, &m_config.m_in_ca2_func, this);
+    devcb_resolve_read_line(&m_in_cb2_func, &m_config.m_in_cb2_func, this);
+    devcb_resolve_write8(&m_out_a_func, &m_config.m_out_a_func, this);
+    devcb_resolve_write8(&m_out_b_func, &m_config.m_out_b_func, this);
+    devcb_resolve_write_line(&m_out_ca2_func, &m_config.m_out_ca2_func, this);
+    devcb_resolve_write_line(&m_out_cb2_func, &m_config.m_out_cb2_func, this);
+    devcb_resolve_write_line(&m_irq_a_func, &m_config.m_irq_a_func, this);
+    devcb_resolve_write_line(&m_irq_b_func, &m_config.m_irq_b_func, this);
+
+    state_save_register_device_item(this, 0, m_in_a);
+    state_save_register_device_item(this, 0, m_in_ca1);
+    state_save_register_device_item(this, 0, m_in_ca2);
+    state_save_register_device_item(this, 0, m_out_a);
+    state_save_register_device_item(this, 0, m_out_ca2);
+    state_save_register_device_item(this, 0, m_port_a_z_mask);
+    state_save_register_device_item(this, 0, m_ddr_a);
+    state_save_register_device_item(this, 0, m_ctl_a);
+    state_save_register_device_item(this, 0, m_irq_a1);
+    state_save_register_device_item(this, 0, m_irq_a2);
+    state_save_register_device_item(this, 0, m_irq_a_state);
+    state_save_register_device_item(this, 0, m_in_b);
+    state_save_register_device_item(this, 0, m_in_cb1);
+    state_save_register_device_item(this, 0, m_in_cb2);
+    state_save_register_device_item(this, 0, m_out_b);
+    state_save_register_device_item(this, 0, m_out_cb2);
+    state_save_register_device_item(this, 0, m_last_out_cb2_z);
+    state_save_register_device_item(this, 0, m_ddr_b);
+    state_save_register_device_item(this, 0, m_ctl_b);
+    state_save_register_device_item(this, 0, m_irq_b1);
+    state_save_register_device_item(this, 0, m_irq_b2);
+    state_save_register_device_item(this, 0, m_irq_b_state);
+    state_save_register_device_item(this, 0, m_in_a_pushed);
+    state_save_register_device_item(this, 0, m_out_a_needs_pulled);
+    state_save_register_device_item(this, 0, m_in_ca1_pushed);
+    state_save_register_device_item(this, 0, m_in_ca2_pushed);
+    state_save_register_device_item(this, 0, m_out_ca2_needs_pulled);
+    state_save_register_device_item(this, 0, m_in_b_pushed);
+    state_save_register_device_item(this, 0, m_out_b_needs_pulled);
+    state_save_register_device_item(this, 0, m_in_cb1_pushed);
+    state_save_register_device_item(this, 0, m_in_cb2_pushed);
+    state_save_register_device_item(this, 0, m_out_cb2_needs_pulled);
 }
 
 
-/*-------------------------------------------------
-    DEVICE_RESET( pia6821 )
--------------------------------------------------*/
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
 
-static DEVICE_RESET( pia6821 )
+void pia6821_device::device_reset()
 {
-	pia6821_state *p = get_token(device);
-
 	/*
      * set default read values.
      *
      * ports A,CA1,CA2 default to 1
      * ports B,CB1,CB2 are three-state and undefined (set to 0)
      */
-	p->in_a = 0xff;
-	p->in_ca1 = TRUE;
-	p->in_ca2 = TRUE;
-	p->out_a = 0;
-	p->out_ca2 = 0;
-	p->port_a_z_mask = 0;
-	p->ddr_a = 0;
-	p->ctl_a = 0;
-	p->irq_a1 = 0;
-	p->irq_a2 = 0;
-	p->irq_a_state = 0;
-	p->in_b = 0;
-	p->in_cb1 = 0;
-	p->in_cb2 = 0;
-	p->out_b = 0;
-	p->out_cb2 = 0;
-	p->last_out_cb2_z = 0;
-	p->ddr_b = 0;
-	p->ctl_b = 0;
-	p->irq_b1 = 0;
-	p->irq_b2 = 0;
-	p->irq_b_state = 0;
-	p->in_a_pushed = 0;
-	p->out_a_needs_pulled = 0;
-	p->in_ca1_pushed = 0;
-	p->in_ca2_pushed = 0;
-	p->out_ca2_needs_pulled = 0;
-	p->in_b_pushed = 0;
-	p->out_b_needs_pulled = 0;
-	p->in_cb1_pushed = 0;
-	p->in_cb2_pushed = 0;
-	p->out_cb2_needs_pulled = 0;
-	p->logged_port_a_not_connected = 0;
-	p->logged_port_b_not_connected = 0;
-	p->logged_ca1_not_connected = 0;
-	p->logged_ca2_not_connected = 0;
-	p->logged_cb1_not_connected = 0;
-	p->logged_cb2_not_connected = 0;
+	m_in_a = 0xff;
+	m_in_ca1 = TRUE;
+	m_in_ca2 = TRUE;
+	m_out_a = 0;
+	m_out_ca2 = 0;
+	m_port_a_z_mask = 0;
+	m_ddr_a = 0;
+	m_ctl_a = 0;
+	m_irq_a1 = 0;
+	m_irq_a2 = 0;
+	m_irq_a_state = 0;
+	m_in_b = 0;
+	m_in_cb1 = 0;
+	m_in_cb2 = 0;
+	m_out_b = 0;
+	m_out_cb2 = 0;
+	m_last_out_cb2_z = 0;
+	m_ddr_b = 0;
+	m_ctl_b = 0;
+	m_irq_b1 = 0;
+	m_irq_b2 = 0;
+	m_irq_b_state = 0;
+	m_in_a_pushed = 0;
+	m_out_a_needs_pulled = 0;
+	m_in_ca1_pushed = 0;
+	m_in_ca2_pushed = 0;
+	m_out_ca2_needs_pulled = 0;
+	m_in_b_pushed = 0;
+	m_out_b_needs_pulled = 0;
+	m_in_cb1_pushed = 0;
+	m_in_cb2_pushed = 0;
+	m_out_cb2_needs_pulled = 0;
+	m_logged_port_a_not_connected = 0;
+	m_logged_port_b_not_connected = 0;
+	m_logged_ca1_not_connected = 0;
+	m_logged_ca2_not_connected = 0;
+	m_logged_cb1_not_connected = 0;
+	m_logged_cb2_not_connected = 0;
 
 
 	/* clear the IRQs */
-	devcb_call_write_line(&p->irq_a_func, FALSE);
-	devcb_call_write_line(&p->irq_b_func, FALSE);
+	devcb_call_write_line(&m_irq_a_func, FALSE);
+	devcb_call_write_line(&m_irq_b_func, FALSE);
 }
 
 
@@ -252,27 +239,24 @@
     update_interrupts
 -------------------------------------------------*/
 
-static void update_interrupts(running_device *device)
+void pia6821_device::update_interrupts()
 {
-	pia6821_state *p = get_token(device);
-	int new_state;
+    /* start with IRQ A */
+	int new_state = (m_irq_a1 && IRQ1_ENABLED(m_ctl_a)) || (m_irq_a2 && IRQ2_ENABLED(m_ctl_a));
 
-	/* start with IRQ A */
-	new_state = (p->irq_a1 && IRQ1_ENABLED(p->ctl_a)) || (p->irq_a2 && IRQ2_ENABLED(p->ctl_a));
-
-	if (new_state != p->irq_a_state)
+	if (new_state != m_irq_a_state)
 	{
-		p->irq_a_state = new_state;
-		devcb_call_write_line(&p->irq_a_func, p->irq_a_state);
+		m_irq_a_state = new_state;
+		devcb_call_write_line(&m_irq_a_func, m_irq_a_state);
 	}
 
 	/* then do IRQ B */
-	new_state = (p->irq_b1 && IRQ1_ENABLED(p->ctl_b)) || (p->irq_b2 && IRQ2_ENABLED(p->ctl_b));
+	new_state = (m_irq_b1 && IRQ1_ENABLED(m_ctl_b)) || (m_irq_b2 && IRQ2_ENABLED(m_ctl_b));
 
-	if (new_state != p->irq_b_state)
+	if (new_state != m_irq_b_state)
 	{
-		p->irq_b_state = new_state;
-		devcb_call_write_line(&p->irq_b_func, p->irq_b_state);
+		m_irq_b_state = new_state;
+		devcb_call_write_line(&m_irq_b_func, m_irq_b_state);
 	}
 }
 
@@ -281,28 +265,31 @@
     get_in_a_value
 -------------------------------------------------*/
 
-static UINT8 get_in_a_value(running_device *device)
+UINT8 pia6821_device::get_in_a_value()
 {
-	pia6821_state *p = get_token(device);
 	UINT8 port_a_data = 0;
 	UINT8 ret;
 
 	/* update the input */
-	if (p->in_a_func.read != NULL)
-		port_a_data = devcb_call_read8(&p->in_a_func, 0);
+	if (m_in_a_func.read != NULL)
+    {
+		port_a_data = devcb_call_read8(&m_in_a_func, 0);
+    }
 	else
 	{
-		if (p->in_a_pushed)
-			port_a_data = p->in_a;
+		if (m_in_a_pushed)
+        {
+			port_a_data = m_in_a;
+        }
 		else
 		{
 			/* mark all pins disconnected */
-			p->port_a_z_mask = 0xff;
+			m_port_a_z_mask = 0xff;
 
-			if (!p->logged_port_a_not_connected && (p->ddr_a != 0xff))
+			if (!m_logged_port_a_not_connected && (m_ddr_a != 0xff))
 			{
-				logerror("PIA #%s: Warning! No port A read handler. Assuming pins 0x%02X not connected\n", device->tag(), p->ddr_a ^ 0xff);
-				p->logged_port_a_not_connected = TRUE;
+				logerror("PIA #%s: Warning! No port A read handler. Assuming pins 0x%02X not connected\n", tag(), m_ddr_a ^ 0xff);
+				m_logged_port_a_not_connected = TRUE;
 			}
 		}
 	}
@@ -310,9 +297,9 @@
 	/* - connected pins are always read
        - disconnected pins read the output buffer in output mode
        - disconnected pins are HI in input mode */
-	ret = (~p->port_a_z_mask             & port_a_data) |
-	      ( p->port_a_z_mask &  p->ddr_a & p->out_a) |
-	      ( p->port_a_z_mask & ~p->ddr_a);
+	ret = (~m_port_a_z_mask             & port_a_data) |
+	      ( m_port_a_z_mask &  m_ddr_a & m_out_a) |
+	      ( m_port_a_z_mask & ~m_ddr_a);
 
 	return ret;
 }
@@ -322,31 +309,36 @@
     get_in_b_value
 -------------------------------------------------*/
 
-static UINT8 get_in_b_value(running_device *device)
+UINT8 pia6821_device::get_in_b_value()
 {
-	pia6821_state *p = get_token(device);
 	UINT8 ret;
 
-	if (p->ddr_b == 0xff)
+	if (m_ddr_b == 0xff)
+    {
 		/* all output, just return buffer */
-		ret = p->out_b;
+		ret = m_out_b;
+    }
 	else
 	{
 		UINT8 port_b_data;
 
 		/* update the input */
-		if (p->in_b_func.read != NULL)
-			port_b_data = devcb_call_read8(&p->in_b_func, 0);
+		if (m_in_b_func.read != NULL)
+        {
+			port_b_data = devcb_call_read8(&m_in_b_func, 0);
+        }
 		else
 		{
-			if (p->in_b_pushed)
-				port_b_data = p->in_b;
+			if (m_in_b_pushed)
+            {
+				port_b_data = m_in_b;
+            }
 			else
 			{
-				if (!p->logged_port_b_not_connected && (p->ddr_b != 0xff))
+				if (!m_logged_port_b_not_connected && (m_ddr_b != 0xff))
 				{
-					logerror("PIA #%s: Error! No port B read handler. Three-state pins 0x%02X are undefined\n", device->tag(), p->ddr_b ^ 0xff);
-					p->logged_port_b_not_connected = TRUE;
+					logerror("PIA #%s: Error! No port B read handler. Three-state pins 0x%02X are undefined\n", tag(), m_ddr_b ^ 0xff);
+					m_logged_port_b_not_connected = TRUE;
 				}
 
 				/* undefined -- need to return something */
@@ -355,7 +347,7 @@
 		}
 
 		/* the DDR determines if the pin or the output buffer is read */
-		ret = (p->out_b & p->ddr_b) | (port_b_data & ~p->ddr_b);
+		ret = (m_out_b & m_ddr_b) | (port_b_data & ~m_ddr_b);
 	}
 
 	return ret;
@@ -366,17 +358,20 @@
     get_out_a_value
 -------------------------------------------------*/
 
-static UINT8 get_out_a_value(running_device *device)
+UINT8 pia6821_device::get_out_a_value()
 {
-	pia6821_state *p = get_token(device);
 	UINT8 ret;
 
-	if (p->ddr_a == 0xff)
+	if (m_ddr_a == 0xff)
+    {
 		/* all output */
-		ret = p->out_a;
+		ret = m_out_a;
+    }
 	else
+    {
 		/* input pins don't change */
-		ret = (p->out_a & p->ddr_a) | (get_in_a_value(device) & ~p->ddr_a);
+		ret = (m_out_a & m_ddr_a) | (get_in_a_value() & ~m_ddr_a);
+    }
 
 	return ret;
 }
@@ -386,12 +381,10 @@
     get_out_b_value
 -------------------------------------------------*/
 
-static UINT8 get_out_b_value(running_device *device)
+UINT8 pia6821_device::get_out_b_value()
 {
-	pia6821_state *p = get_token(device);
-
 	/* input pins are high-impedance - we just send them as zeros for backwards compatibility */
-	return p->out_b & p->ddr_b;
+	return m_out_b & m_ddr_b;
 }
 
 
@@ -399,23 +392,25 @@
     set_out_ca2
 -------------------------------------------------*/
 
-static void set_out_ca2(running_device *device, int data)
+void pia6821_device::set_out_ca2(int data)
 {
-	pia6821_state *p = get_token(device);
-
-	if (data != p->out_ca2)
+	if (data != m_out_ca2)
 	{
-		p->out_ca2 = data;
+		m_out_ca2 = data;
 
 		/* send to output function */
-		if (p->out_ca2_func.write)
-			devcb_call_write_line(&p->out_ca2_func, p->out_ca2);
+		if (m_out_ca2_func.write)
+        {
+			devcb_call_write_line(&m_out_ca2_func, m_out_ca2);
+        }
 		else
 		{
-			if (p->out_ca2_needs_pulled)
-				logerror("PIA #%s: Warning! No port CA2 write handler. Previous value has been lost!\n", device->tag());
+			if (m_out_ca2_needs_pulled)
+            {
+				logerror("PIA #%s: Warning! No port CA2 write handler. Previous value has been lost!\n", tag());
+            }
 
-			p->out_ca2_needs_pulled = TRUE;
+			m_out_ca2_needs_pulled = TRUE;
 		}
 	}
 }
@@ -425,26 +420,28 @@
     set_out_cb2
 -------------------------------------------------*/
 
-static void set_out_cb2(running_device *device, int data)
+void pia6821_device::set_out_cb2(int data)
 {
-	pia6821_state *p = get_token(device);
-
-	int z = pia6821_get_output_cb2_z(device);
+	int z = pia6821_get_output_cb2_z(this);
 
-	if ((data != p->out_cb2) || (z != p->last_out_cb2_z))
+	if ((data != m_out_cb2) || (z != m_last_out_cb2_z))
 	{
-		p->out_cb2 = data;
-		p->last_out_cb2_z = z;
+		m_out_cb2 = data;
+		m_last_out_cb2_z = z;
 
 		/* send to output function */
-		if (p->out_cb2_func.write)
-			devcb_call_write_line(&p->out_cb2_func, p->out_cb2);
+		if (m_out_cb2_func.write)
+        {
+			devcb_call_write_line(&m_out_cb2_func, m_out_cb2);
+        }
 		else
 		{
-			if (p->out_cb2_needs_pulled)
-				logerror("PIA #%s: Warning! No port CB2 write handler. Previous value has been lost!\n", device->tag());
+			if (m_out_cb2_needs_pulled)
+            {
+				logerror("PIA #%s: Warning! No port CB2 write handler. Previous value has been lost!\n", tag());
+            }
 
-			p->out_cb2_needs_pulled = TRUE;
+			m_out_cb2_needs_pulled = TRUE;
 		}
 	}
 }
@@ -454,29 +451,29 @@
     port_a_r
 -------------------------------------------------*/
 
-static UINT8 port_a_r(running_device *device)
+UINT8 pia6821_device::port_a_r()
 {
-	pia6821_state *p = get_token(device);
-
-	UINT8 ret = get_in_a_value(device);
+	UINT8 ret = get_in_a_value();
 
 	/* IRQ flags implicitly cleared by a read */
-	p->irq_a1 = FALSE;
-	p->irq_a2 = FALSE;
-	update_interrupts(device);
+	m_irq_a1 = FALSE;
+	m_irq_a2 = FALSE;
+	update_interrupts();
 
 	/* CA2 is configured as output and in read strobe mode */
-	if (C2_OUTPUT(p->ctl_a) && C2_STROBE_MODE(p->ctl_a))
+	if(C2_OUTPUT(m_ctl_a) && C2_STROBE_MODE(m_ctl_a))
 	{
 		/* this will cause a transition low */
-		set_out_ca2(device, FALSE);
+		set_out_ca2(FALSE);
 
 		/* if the CA2 strobe is cleared by the E, reset it right away */
-		if (STROBE_E_RESET(p->ctl_a))
-			set_out_ca2(device, TRUE);
+		if(STROBE_E_RESET(m_ctl_a))
+        {
+			set_out_ca2(TRUE);
+        }
 	}
 
-	LOG(("PIA #%s: port A read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: port A read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -486,13 +483,11 @@
     ddr_a_r
 -------------------------------------------------*/
 
-static UINT8 ddr_a_r(running_device *device)
+UINT8 pia6821_device::ddr_a_r()
 {
-	pia6821_state *p = get_token(device);
-
-	UINT8 ret = p->ddr_a;
+	UINT8 ret = m_ddr_a;
 
-	LOG(("PIA #%s: DDR A read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: DDR A read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -502,25 +497,25 @@
     port_b_r
 -------------------------------------------------*/
 
-static UINT8 port_b_r(running_device *device)
+UINT8 pia6821_device::port_b_r()
 {
-	pia6821_state *p = get_token(device);
-
-	UINT8 ret = get_in_b_value(device);
+	UINT8 ret = get_in_b_value();
 
 	/* This read will implicitly clear the IRQ B1 flag.  If CB2 is in write-strobe
        mode with CB1 restore, and a CB1 active transition set the flag,
        clearing it will cause CB2 to go high again.  Note that this is different
        from what happens with port A. */
-	if (p->irq_b1 && C2_STROBE_MODE(p->ctl_b) && STROBE_C1_RESET(p->ctl_b))
-		set_out_cb2(device, TRUE);
+	if(m_irq_b1 && C2_STROBE_MODE(m_ctl_b) && STROBE_C1_RESET(m_ctl_b))
+    {
+		set_out_cb2(TRUE);
+    }
 
 	/* IRQ flags implicitly cleared by a read */
-	p->irq_b1 = FALSE;
-	p->irq_b2 = FALSE;
-	update_interrupts(device);
+	m_irq_b1 = FALSE;
+	m_irq_b2 = FALSE;
+	update_interrupts();
 
-	LOG(("PIA #%s: port B read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: port B read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -530,13 +525,11 @@
     ddr_b_r
 -------------------------------------------------*/
 
-static UINT8 ddr_b_r(running_device *device)
+UINT8 pia6821_device::ddr_b_r()
 {
-	pia6821_state *p = get_token(device);
-
-	UINT8 ret = p->ddr_b;
+	UINT8 ret = m_ddr_b;
 
-	LOG(("PIA #%s: DDR B read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: DDR B read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -546,39 +539,46 @@
     control_a_r
 -------------------------------------------------*/
 
-static UINT8 control_a_r(running_device *device)
+UINT8 pia6821_device::control_a_r()
 {
-	pia6821_state *p = get_token(device);
 	UINT8 ret;
 
 	/* update CA1 & CA2 if callback exists, these in turn may update IRQ's */
-	if (p->in_ca1_func.read != NULL)
-		pia6821_ca1_w(device, devcb_call_read_line(&p->in_ca1_func));
-	else if (!p->logged_ca1_not_connected && (!p->in_ca1_pushed))
+	if (m_in_ca1_func.read != NULL)
+    {
+		ca1_w(devcb_call_read_line(&m_in_ca1_func));
+    }
+	else if(!m_logged_ca1_not_connected && (!m_in_ca1_pushed))
+	{
+		logerror("PIA #%s: Warning! No CA1 read handler. Assuming pin not connected\n", tag());
+		m_logged_ca1_not_connected = TRUE;
+	}
+
+	if (m_in_ca2_func.read != NULL)
+    {
+		ca2_w(devcb_call_read_line(&m_in_ca2_func));
+    }
+	else if ( !m_logged_ca2_not_connected && C2_INPUT(m_ctl_a) && !m_in_ca2_pushed)
 	{
-		logerror("PIA #%s: Warning! No CA1 read handler. Assuming pin not connected\n", device->tag());
-		p->logged_ca1_not_connected = TRUE;
-	}
-
-	if (p->in_ca2_func.read != NULL)
-		pia6821_ca2_w(device, devcb_call_read_line(&p->in_ca2_func));
-	else if ( !p->logged_ca2_not_connected && C2_INPUT(p->ctl_a) && !p->in_ca2_pushed)
-	{
-		logerror("PIA #%s: Warning! No CA2 read handler. Assuming pin not connected\n", device->tag());
-		p->logged_ca2_not_connected = TRUE;
+		logerror("PIA #%s: Warning! No CA2 read handler. Assuming pin not connected\n", tag());
+		m_logged_ca2_not_connected = TRUE;
 	}
 
 	/* read control register */
-	ret = p->ctl_a;
+	ret = m_ctl_a;
 
 	/* set the IRQ flags if we have pending IRQs */
-	if (p->irq_a1)
+	if(m_irq_a1)
+    {
 		ret |= PIA_IRQ1;
+    }
 
-	if (p->irq_a2 && C2_INPUT(p->ctl_a))
+	if(m_irq_a2 && C2_INPUT(m_ctl_a))
+    {
 		ret |= PIA_IRQ2;
+    }
 
-	LOG(("PIA #%s: control A read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: control A read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -588,39 +588,46 @@
     control_b_r
 -------------------------------------------------*/
 
-static UINT8 control_b_r(running_device *device)
+UINT8 pia6821_device::control_b_r()
 {
-	pia6821_state *p = get_token(device);
 	UINT8 ret;
 
 	/* update CB1 & CB2 if callback exists, these in turn may update IRQ's */
-	if (p->in_cb1_func.read != NULL)
-		pia6821_cb1_w(device, devcb_call_read_line(&p->in_cb1_func));
-	else if (!p->logged_cb1_not_connected && !p->in_cb1_pushed)
-	{
-		logerror("PIA #%s: Error! no CB1 read handler. Three-state pin is undefined\n", device->tag());
-		p->logged_cb1_not_connected = TRUE;
-	}
-
-	if (p->in_cb2_func.read != NULL)
-		pia6821_cb2_w(device, devcb_call_read_line(&p->in_cb2_func));
-	else if (!p->logged_cb2_not_connected && C2_INPUT(p->ctl_b) && !p->in_cb2_pushed)
+	if(m_in_cb1_func.read != NULL)
+    {
+		cb1_w(devcb_call_read_line(&m_in_cb1_func));
+    }
+	else if(!m_logged_cb1_not_connected && !m_in_cb1_pushed)
+	{
+		logerror("PIA #%s: Error! no CB1 read handler. Three-state pin is undefined\n", tag());
+		m_logged_cb1_not_connected = TRUE;
+	}
+
+	if(m_in_cb2_func.read != NULL)
+    {
+		cb2_w(devcb_call_read_line(&m_in_cb2_func));
+    }
+	else if(!m_logged_cb2_not_connected && C2_INPUT(m_ctl_b) && !m_in_cb2_pushed)
 	{
-		logerror("PIA #%s: Error! No CB2 read handler. Three-state pin is undefined\n", device->tag());
-		p->logged_cb2_not_connected = TRUE;
+		logerror("PIA #%s: Error! No CB2 read handler. Three-state pin is undefined\n", tag());
+		m_logged_cb2_not_connected = TRUE;
 	}
 
 	/* read control register */
-	ret = p->ctl_b;
+	ret = m_ctl_b;
 
 	/* set the IRQ flags if we have pending IRQs */
-	if (p->irq_b1)
+	if(m_irq_b1)
+    {
 		ret |= PIA_IRQ1;
+    }
 
-	if (p->irq_b2 && C2_INPUT(p->ctl_b))
+	if(m_irq_b2 && C2_INPUT(m_ctl_b))
+    {
 		ret |= PIA_IRQ2;
+    }
 
-	LOG(("PIA #%s: control B read = %02X\n", device->tag(), ret));
+	LOG(("PIA #%s: control B read = %02X\n", tag(), ret));
 
 	return ret;
 }
@@ -632,32 +639,44 @@
 
 READ8_DEVICE_HANDLER( pia6821_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->reg_r(offset);
+}
+
+UINT8 pia6821_device::reg_r(UINT8 offset)
+{
 	UINT8 ret;
 
 	switch (offset & 0x03)
 	{
 		default: /* impossible */
 		case 0x00:
-			if (OUTPUT_SELECTED(p->ctl_a))
-				ret = port_a_r(device);
+			if (OUTPUT_SELECTED(m_ctl_a))
+            {
+				ret = port_a_r();
+            }
 			else
-				ret = ddr_a_r(device);
+            {
+				ret = ddr_a_r();
+            }
 			break;
 
 		case 0x01:
-			ret = control_a_r(device);
+			ret = control_a_r();
 			break;
 
 		case 0x02:
-			if (OUTPUT_SELECTED(p->ctl_b))
-				ret = port_b_r(device);
+			if (OUTPUT_SELECTED(m_ctl_b))
+            {
+				ret = port_b_r();
+            }
 			else
-				ret = ddr_b_r(device);
+            {
+				ret = ddr_b_r();
+            }
 			break;
 
 		case 0x03:
-			ret = control_b_r(device);
+			ret = control_b_r();
 			break;
 	}
 
@@ -671,18 +690,23 @@
 
 READ8_DEVICE_HANDLER( pia6821_alt_r )
 {
-	return pia6821_r(device, ((offset << 1) & 0x02) | ((offset >> 1) & 0x01));
+    return downcast<pia6821_device *>(device)->reg_r(((offset << 1) & 0x02) | ((offset >> 1) & 0x01));
 }
 
 
+
 /*-------------------------------------------------
     pia6821_get_port_b_z_mask
 -------------------------------------------------*/
 
 UINT8 pia6821_get_port_b_z_mask(running_device *device)
 {
-	pia6821_state *p = get_token(device);
-	return ~p->ddr_b;
+    return downcast<pia6821_device *>(device)->get_port_b_z_mask();
+}
+
+UINT8 pia6821_device::get_port_b_z_mask()
+{
+	return ~m_ddr_b;
 }
 
 
@@ -690,23 +714,25 @@
     send_to_out_a_func
 -------------------------------------------------*/
 
-static void send_to_out_a_func(running_device *device, const char* message)
+void pia6821_device::send_to_out_a_func(const char* message)
 {
-	pia6821_state *p = get_token(device);
-
 	/* input pins are pulled high */
-	UINT8 data = get_out_a_value(device);
+	UINT8 data = get_out_a_value();
 
-	LOG(("PIA #%s: %s = %02X\n", device->tag(), message, data));
+	LOG(("PIA #%s: %s = %02X\n", tag(), message, data));
 
-	if (p->out_a_func.write != NULL)
-		devcb_call_write8(&p->out_a_func, 0, data);
+	if(m_out_a_func.write != NULL)
+    {
+		devcb_call_write8(&m_out_a_func, 0, data);
+    }
 	else
 	{
-		if (p->out_a_needs_pulled)
-			logerror("PIA #%s: Warning! No port A write handler. Previous value has been lost!\n", device->tag());
+		if(m_out_a_needs_pulled)
+        {
+			logerror("PIA #%s: Warning! No port A write handler. Previous value has been lost!\n", tag());
+        }
 
-		p->out_a_needs_pulled = TRUE;
+		m_out_a_needs_pulled = TRUE;
 	}
 }
 
@@ -715,23 +741,25 @@
     send_to_out_b_func
 -------------------------------------------------*/
 
-static void send_to_out_b_func(running_device *device, const char* message)
+void pia6821_device::send_to_out_b_func(const char* message)
 {
-	pia6821_state *p = get_token(device);
-
 	/* input pins are high-impedance - we just send them as zeros for backwards compatibility */
-	UINT8 data = get_out_b_value(device);
+	UINT8 data = get_out_b_value();
 
-	LOG(("PIA #%s: %s = %02X\n", device->tag(), message, data));
+	LOG(("PIA #%s: %s = %02X\n", tag(), message, data));
 
-	if (p->out_b_func.write != NULL)
-		devcb_call_write8(&p->out_b_func, 0, data);
+	if(m_out_b_func.write != NULL)
+    {
+		devcb_call_write8(&m_out_b_func, 0, data);
+    }
 	else
 	{
-		if (p->out_b_needs_pulled)
-			logerror("PIA #%s: Warning! No port B write handler. Previous value has been lost!\n", device->tag());
+		if(m_out_b_needs_pulled)
+        {
+			logerror("PIA #%s: Warning! No port B write handler. Previous value has been lost!\n", tag());
+        }
 
-		p->out_b_needs_pulled = TRUE;
+		m_out_b_needs_pulled = TRUE;
 	}
 }
 
@@ -740,14 +768,12 @@
     port_a_w
 -------------------------------------------------*/
 
-static void port_a_w(running_device *device, UINT8 data)
+void pia6821_device::port_a_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
-
 	/* buffer the output value */
-	p->out_a = data;
+	m_out_a = data;
 
-	send_to_out_a_func(device, "port A write");
+	send_to_out_a_func("port A write");
 }
 
 
@@ -755,23 +781,27 @@
     ddr_a_w
 -------------------------------------------------*/
 
-static void ddr_a_w(running_device *device, UINT8 data)
+void pia6821_device::ddr_a_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
-
-	if (data == 0x00)
-		LOG(("PIA #%s: DDR A write = %02X (input mode)\n", device->tag(), data));
-	else if (data == 0xff)
-		LOG(("PIA #%s: DDR A write = %02X (output mode)\n", device->tag(), data));
+	if(data == 0x00)
+    {
+		LOG(("PIA #%s: DDR A write = %02X (input mode)\n", tag(), data));
+    }
+	else if(data == 0xff)
+    {
+		LOG(("PIA #%s: DDR A write = %02X (output mode)\n", tag(), data));
+    }
 	else
-		LOG(("PIA #%s: DDR A write = %02X (mixed mode)\n", device->tag(), data));
+    {
+		LOG(("PIA #%s: DDR A write = %02X (mixed mode)\n", tag(), data));
+    }
 
-	if (p->ddr_a != data)
+	if(m_ddr_a != data)
 	{
 		/* DDR changed, call the callback again */
-		p->ddr_a = data;
-		p->logged_port_a_not_connected = FALSE;
-		send_to_out_a_func(device, "port A write due to DDR change");
+		m_ddr_a = data;
+		m_logged_port_a_not_connected = FALSE;
+		send_to_out_a_func("port A write due to DDR change");
 	}
 }
 
@@ -780,24 +810,24 @@
     port_b_w
 -------------------------------------------------*/
 
-static void port_b_w(running_device *device, UINT8 data)
+void pia6821_device::port_b_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
-
 	/* buffer the output value */
-	p->out_b = data;
+	m_out_b = data;
 
-	send_to_out_b_func(device, "port B write");
+	send_to_out_b_func("port B write");
 
 	/* CB2 in write strobe mode */
-	if (C2_STROBE_MODE(p->ctl_b))
+	if(C2_STROBE_MODE(m_ctl_b))
 	{
 		/* this will cause a transition low */
-		set_out_cb2(device, FALSE);
+		set_out_cb2(FALSE);
 
 		/* if the CB2 strobe is cleared by the E, reset it right away */
-		if (STROBE_E_RESET(p->ctl_b))
-			set_out_cb2(device, TRUE);
+		if(STROBE_E_RESET(m_ctl_b))
+        {
+			set_out_cb2(TRUE);
+        }
 	}
 }
 
@@ -806,23 +836,27 @@
     ddr_b_w
 -------------------------------------------------*/
 
-static void ddr_b_w(running_device *device, UINT8 data)
+void pia6821_device::ddr_b_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
-
 	if (data == 0x00)
-		LOG(("PIA #%s: DDR B write = %02X (input mode)\n", device->tag(), data));
+    {
+		LOG(("PIA #%s: DDR B write = %02X (input mode)\n", tag(), data));
+    }
 	else if (data == 0xff)
-		LOG(("PIA #%s: DDR B write = %02X (output mode)\n", device->tag(), data));
+    {
+		LOG(("PIA #%s: DDR B write = %02X (output mode)\n", tag(), data));
+    }
 	else
-		LOG(("PIA #%s: DDR B write = %02X (mixed mode)\n", device->tag(), data));
+    {
+		LOG(("PIA #%s: DDR B write = %02X (mixed mode)\n", tag(), data));
+    }
 
-	if (p->ddr_b != data)
+	if(m_ddr_b != data)
 	{
 		/* DDR changed, call the callback again */
-		p->ddr_b = data;
-		p->logged_port_b_not_connected = FALSE;
-		send_to_out_b_func(device, "port B write due to DDR change");
+		m_ddr_b = data;
+		m_logged_port_b_not_connected = FALSE;
+		send_to_out_b_func("port B write due to DDR change");
 	}
 }
 
@@ -831,35 +865,37 @@
     control_a_w
 -------------------------------------------------*/
 
-static void control_a_w(running_device *device, UINT8 data)
+void pia6821_device::control_a_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
-
 	/* bit 7 and 6 are read only */
 	data &= 0x3f;
 
-	LOG(("PIA #%s: control A write = %02X\n", device->tag(), data));
+	LOG(("PIA #%s: control A write = %02X\n", tag(), data));
 
 	/* update the control register */
-	p->ctl_a = data;
+	m_ctl_a = data;
 
 	/* CA2 is configured as output */
-	if (C2_OUTPUT(p->ctl_a))
+	if(C2_OUTPUT(m_ctl_a))
 	{
 		int temp;
 
-		if (C2_SET_MODE(p->ctl_a))
+		if(C2_SET_MODE(m_ctl_a))
+        {
 			/* set/reset mode - bit value determines the new output */
-			temp = C2_SET(p->ctl_a);
+			temp = C2_SET(m_ctl_a);
+        }
 		else
+        {
 			/* strobe mode - output is always high unless strobed */
 			temp = TRUE;
+        }
 
-		set_out_ca2(device, temp);
+		set_out_ca2(temp);
 	}
 
 	/* update externals */
-	update_interrupts(device);
+	update_interrupts();
 }
 
 
@@ -867,30 +903,33 @@
     control_b_w
 -------------------------------------------------*/
 
-static void control_b_w(running_device *device, UINT8 data)
+void pia6821_device::control_b_w(UINT8 data)
 {
-	pia6821_state *p = get_token(device);
 	int temp;
 
 	/* bit 7 and 6 are read only */
 	data &= 0x3f;
 
-	LOG(("PIA #%s: control B write = %02X\n", device->tag(), data));
+	LOG(("PIA #%s: control B write = %02X\n", tag(), data));
 
 	/* update the control register */
-	p->ctl_b = data;
+	m_ctl_b = data;
 
-	if (C2_SET_MODE(p->ctl_b))
+	if (C2_SET_MODE(m_ctl_b))
+    {
 		/* set/reset mode - bit value determines the new output */
-		temp = C2_SET(p->ctl_b);
+		temp = C2_SET(m_ctl_b);
+    }
 	else
+    {
 		/* strobe mode - output is always high unless strobed */
 		temp = TRUE;
+    }
 
-	set_out_cb2(device, temp);
+	set_out_cb2(temp);
 
 	/* update externals */
-	update_interrupts(device);
+	update_interrupts();
 }
 
 
@@ -900,31 +939,42 @@
 
 WRITE8_DEVICE_HANDLER( pia6821_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->reg_w(offset, data);
+}
 
+void pia6821_device::reg_w(UINT8 offset, UINT8 data)
+{
 	switch (offset & 0x03)
 	{
 		default: /* impossible */
 		case 0x00:
-			if (OUTPUT_SELECTED(p->ctl_a))
-				port_a_w(device, data);
+			if (OUTPUT_SELECTED(m_ctl_a))
+            {
+				port_a_w(data);
+            }
 			else
-				ddr_a_w(device, data);
+            {
+				ddr_a_w(data);
+            }
 			break;
 
 		case 0x01:
-			control_a_w(device, data);
+			control_a_w( data);
 			break;
 
 		case 0x02:
-			if (OUTPUT_SELECTED(p->ctl_b))
-				port_b_w(device, data);
+			if(OUTPUT_SELECTED(m_ctl_b))
+            {
+				port_b_w(data);
+            }
 			else
-				ddr_b_w(device, data);
+            {
+				ddr_b_w(data);
+            }
 			break;
 
 		case 0x03:
-			control_b_w(device, data);
+			control_b_w(data);
 			break;
 	}
 }
@@ -936,7 +986,7 @@
 
 WRITE8_DEVICE_HANDLER( pia6821_alt_w )
 {
-	pia6821_w(device, ((offset << 1) & 0x02) | ((offset >> 1) & 0x01), data);
+    downcast<pia6821_device *>(device)->reg_w(((offset << 1) & 0x02) | ((offset >> 1) & 0x01), data);
 }
 
 
@@ -946,9 +996,12 @@
 
 void pia6821_set_port_a_z_mask(running_device *device, UINT8 data)
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->set_port_a_z_mask(data);
+}
 
-	p->port_a_z_mask = data;
+void pia6821_device::set_port_a_z_mask(UINT8 data)
+{
+	m_port_a_z_mask = data;
 }
 
 
@@ -958,9 +1011,12 @@
 
 READ8_DEVICE_HANDLER( pia6821_porta_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->porta_r();
+}
 
-	return p->in_a;
+UINT8 pia6821_device::porta_r()
+{
+	return m_in_a;
 }
 
 
@@ -970,15 +1026,18 @@
 
 void pia6821_set_input_a(running_device *device, UINT8 data, UINT8 z_mask)
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->set_input_a(data, z_mask);
+}
 
-	assert_always(p->in_a_func.read == NULL, "pia6821_porta_w() called when in_a_func implemented");
+void pia6821_device::set_input_a(UINT8 data, UINT8 z_mask)
+{
+	assert_always(m_in_a_func.read == NULL, "pia6821_porta_w() called when in_a_func implemented");
 
-	LOG(("PIA #%s: set input port A = %02X\n", device->tag(), data));
+	LOG(("PIA #%s: set input port A = %02X\n", tag(), data));
 
-	p->in_a = data;
-	p->port_a_z_mask = z_mask;
-	p->in_a_pushed = TRUE;
+	m_in_a = data;
+	m_port_a_z_mask = z_mask;
+	m_in_a_pushed = TRUE;
 }
 
 
@@ -988,7 +1047,12 @@
 
 WRITE8_DEVICE_HANDLER( pia6821_porta_w )
 {
-	pia6821_set_input_a(device, data, 0);
+    downcast<pia6821_device *>(device)->porta_w(data);
+}
+
+void pia6821_device::porta_w(UINT8 data)
+{
+	pia6821_set_input_a(this, data, 0);
 }
 
 
@@ -998,11 +1062,14 @@
 
 UINT8 pia6821_get_output_a(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_a();
+}
 
-	p->out_a_needs_pulled = FALSE;
+UINT8 pia6821_device::get_output_a()
+{
+	m_out_a_needs_pulled = FALSE;
 
-	return get_out_a_value(device);
+	return get_out_a_value();
 }
 
 
@@ -1012,9 +1079,12 @@
 
 READ_LINE_DEVICE_HANDLER( pia6821_ca1_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->ca1_r();
+}
 
-	return p->in_ca1;
+UINT8 pia6821_device::ca1_r()
+{
+	return m_in_ca1;
 }
 
 
@@ -1024,30 +1094,34 @@
 
 WRITE_LINE_DEVICE_HANDLER( pia6821_ca1_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->ca1_w(state);
+}
 
-	LOG(("PIA #%s: set input CA1 = %d\n", device->tag(), state));
+void pia6821_device::ca1_w(UINT8 state)
+{
+	LOG(("PIA #%s: set input CA1 = %d\n", tag(), state));
 
 	/* the new state has caused a transition */
-	if ((p->in_ca1 != state) &&
-		((state && C1_LOW_TO_HIGH(p->ctl_a)) || (!state && C1_HIGH_TO_LOW(p->ctl_a))))
+	if((m_in_ca1 != state) && ((state && C1_LOW_TO_HIGH(m_ctl_a)) || (!state && C1_HIGH_TO_LOW(m_ctl_a))))
 	{
-		LOG(("PIA #%s: CA1 triggering\n", device->tag()));
+		LOG(("PIA #%s: CA1 triggering\n", tag()));
 
 		/* mark the IRQ */
-		p->irq_a1 = TRUE;
+		m_irq_a1 = TRUE;
 
 		/* update externals */
-		update_interrupts(device);
+		update_interrupts();
 
 		/* CA2 is configured as output and in read strobe mode and cleared by a CA1 transition */
-		if (C2_OUTPUT(p->ctl_a) && C2_STROBE_MODE(p->ctl_a) && STROBE_C1_RESET(p->ctl_a))
-			set_out_ca2(device, TRUE);
+		if(C2_OUTPUT(m_ctl_a) && C2_STROBE_MODE(m_ctl_a) && STROBE_C1_RESET(m_ctl_a))
+        {
+			set_out_ca2(TRUE);
+        }
 	}
 
 	/* set the new value for CA1 */
-	p->in_ca1 = state;
-	p->in_ca1_pushed = TRUE;
+	m_in_ca1 = state;
+	m_in_ca1_pushed = TRUE;
 }
 
 
@@ -1057,9 +1131,12 @@
 
 READ_LINE_DEVICE_HANDLER( pia6821_ca2_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->ca2_r();
+}
 
-	return p->in_ca2;
+UINT8 pia6821_device::ca2_r()
+{
+	return m_in_ca2;
 }
 
 
@@ -1069,27 +1146,28 @@
 
 WRITE_LINE_DEVICE_HANDLER( pia6821_ca2_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->ca2_w(state);
+}
 
-	LOG(("PIA #%s: set input CA2 = %d\n", device->tag(), state));
+void pia6821_device::ca2_w(UINT8 state)
+{
+	LOG(("PIA #%s: set input CA2 = %d\n", tag(), state));
 
 	/* if input mode and the new state has caused a transition */
-	if (C2_INPUT(p->ctl_a) &&
-		(p->in_ca2 != state) &&
-		((state && C2_LOW_TO_HIGH(p->ctl_a)) || (!state && C2_HIGH_TO_LOW(p->ctl_a))))
+	if(C2_INPUT(m_ctl_a) && (m_in_ca2 != state) && ((state && C2_LOW_TO_HIGH(m_ctl_a)) || (!state && C2_HIGH_TO_LOW(m_ctl_a))))
 	{
-		LOG(("PIA #%s: CA2 triggering\n", device->tag()));
+		LOG(("PIA #%s: CA2 triggering\n", tag()));
 
 		/* mark the IRQ */
-		p->irq_a2 = TRUE;
+		m_irq_a2 = TRUE;
 
 		/* update externals */
-		update_interrupts(device);
+		update_interrupts();
 	}
 
 	/* set the new value for CA2 */
-	p->in_ca2 = state;
-	p->in_ca2_pushed = TRUE;
+	m_in_ca2 = state;
+	m_in_ca2_pushed = TRUE;
 }
 
 
@@ -1099,11 +1177,14 @@
 
 int pia6821_get_output_ca2(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_ca2();
+}
 
-	p->out_ca2_needs_pulled = FALSE;
+int pia6821_device::get_output_ca2()
+{
+	m_out_ca2_needs_pulled = FALSE;
 
-	return p->out_ca2;
+	return m_out_ca2;
 }
 
 
@@ -1115,14 +1196,16 @@
 
 int pia6821_get_output_ca2_z(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_ca2_z();
+}
 
-	p->out_ca2_needs_pulled = FALSE;
+int pia6821_device::get_output_ca2_z()
+{
+	m_out_ca2_needs_pulled = FALSE;
 
 	// If it's an output, output the bit, if it's an input, it's
 	// pulled up
-	return p->out_ca2 |
-	       C2_INPUT(p->ctl_a);
+	return m_out_ca2 | C2_INPUT(m_ctl_a);
 }
 
 
@@ -1132,9 +1215,12 @@
 
 READ8_DEVICE_HANDLER( pia6821_portb_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->portb_r();
+}
 
-	return p->in_b;
+UINT8 pia6821_device::portb_r()
+{
+	return m_in_b;
 }
 
 
@@ -1144,14 +1230,17 @@
 
 WRITE8_DEVICE_HANDLER( pia6821_portb_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->portb_w(data);
+}
 
-	assert_always(p->in_b_func.read == NULL, "pia_set_input_b() called when in_b_func implemented");
+void pia6821_device::portb_w(UINT8 data)
+{
+	assert_always(m_in_b_func.read == NULL, "pia_set_input_b() called when in_b_func implemented");
 
-	LOG(("PIA #%s: set input port B = %02X\n", device->tag(), data));
+	LOG(("PIA #%s: set input port B = %02X\n", tag(), data));
 
-	p->in_b = data;
-	p->in_b_pushed = TRUE;
+	m_in_b = data;
+	m_in_b_pushed = TRUE;
 }
 
 
@@ -1161,11 +1250,14 @@
 
 UINT8 pia6821_get_output_b(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_b();
+}
 
-	p->out_b_needs_pulled = FALSE;
+UINT8 pia6821_device::get_output_b()
+{
+	m_out_b_needs_pulled = FALSE;
 
-	return get_out_b_value(device);
+	return get_out_b_value();
 }
 
 
@@ -1175,9 +1267,12 @@
 
 READ_LINE_DEVICE_HANDLER( pia6821_cb1_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->cb1_r();
+}
 
-	return p->in_cb1;
+UINT8 pia6821_device::cb1_r()
+{
+	return m_in_cb1;
 }
 
 
@@ -1187,21 +1282,23 @@
 
 WRITE_LINE_DEVICE_HANDLER( pia6821_cb1_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->cb1_w(state);
+}
 
-	LOG(("PIA #%s: set input CB1 = %d\n", device->tag(), state));
+void pia6821_device::cb1_w(UINT8 state)
+{
+	LOG(("PIA #%s: set input CB1 = %d\n", tag(), state));
 
 	/* the new state has caused a transition */
-	if ((p->in_cb1 != state) &&
-		((state && C1_LOW_TO_HIGH(p->ctl_b)) || (!state && C1_HIGH_TO_LOW(p->ctl_b))))
+	if((m_in_cb1 != state) && ((state && C1_LOW_TO_HIGH(m_ctl_b)) || (!state && C1_HIGH_TO_LOW(m_ctl_b))))
 	{
-		LOG(("PIA #%s: CB1 triggering\n", device->tag()));
+		LOG(("PIA #%s: CB1 triggering\n", tag()));
 
 		/* mark the IRQ */
-		p->irq_b1 = 1;
+		m_irq_b1 = 1;
 
 		/* update externals */
-		update_interrupts(device);
+		update_interrupts();
 
 		/* If CB2 is configured as a write-strobe output which is reset by a CB1
            transition, this reset will only happen when a read from port B implicitly
@@ -1210,8 +1307,8 @@
 	}
 
 	/* set the new value for CB1 */
-	p->in_cb1 = state;
-	p->in_cb1_pushed = TRUE;
+	m_in_cb1 = state;
+	m_in_cb1_pushed = TRUE;
 }
 
 
@@ -1221,9 +1318,12 @@
 
 READ_LINE_DEVICE_HANDLER( pia6821_cb2_r )
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->cb2_r();
+}
 
-	return p->in_cb2;
+UINT8 pia6821_device::cb2_r()
+{
+	return m_in_cb2;
 }
 
 
@@ -1233,27 +1333,30 @@
 
 WRITE_LINE_DEVICE_HANDLER( pia6821_cb2_w )
 {
-	pia6821_state *p = get_token(device);
+    downcast<pia6821_device *>(device)->cb2_w(state);
+}
 
-	LOG(("PIA #%s: set input CB2 = %d\n", device->tag(), state));
+void pia6821_device::cb2_w(UINT8 state)
+{
+	LOG(("PIA #%s: set input CB2 = %d\n", tag(), state));
 
 	/* if input mode and the new state has caused a transition */
-	if (C2_INPUT(p->ctl_b) &&
-		(p->in_cb2 != state) &&
-		((state && C2_LOW_TO_HIGH(p->ctl_b)) || (!state && C2_HIGH_TO_LOW(p->ctl_b))))
+	if (C2_INPUT(m_ctl_b) &&
+		(m_in_cb2 != state) &&
+		((state && C2_LOW_TO_HIGH(m_ctl_b)) || (!state && C2_HIGH_TO_LOW(m_ctl_b))))
 	{
-		LOG(("PIA #%s: CB2 triggering\n", device->tag()));
+		LOG(("PIA #%s: CB2 triggering\n", tag()));
 
 		/* mark the IRQ */
-		p->irq_b2 = 1;
+		m_irq_b2 = 1;
 
 		/* update externals */
-		update_interrupts(device);
+		update_interrupts();
 	}
 
 	/* set the new value for CA2 */
-	p->in_cb2 = state;
-	p->in_cb2_pushed = TRUE;
+	m_in_cb2 = state;
+	m_in_cb2_pushed = TRUE;
 }
 
 
@@ -1263,11 +1366,14 @@
 
 int pia6821_get_output_cb2(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_cb2();
+}
 
-	p->out_cb2_needs_pulled = FALSE;
+int pia6821_device::get_output_cb2()
+{
+	m_out_cb2_needs_pulled = FALSE;
 
-	return p->out_cb2;
+	return m_out_cb2;
 }
 
 
@@ -1277,9 +1383,12 @@
 
 int pia6821_get_output_cb2_z(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_output_cb2_z();
+}
 
-	return !C2_OUTPUT(p->ctl_b);
+int pia6821_device::get_output_cb2_z()
+{
+	return !C2_OUTPUT(m_ctl_b);
 }
 
 
@@ -1289,9 +1398,12 @@
 
 int pia6821_get_irq_a(running_device *device)
 {
-	pia6821_state *p = get_token(device);
+    return downcast<pia6821_device *>(device)->get_irq_a();
+}
 
-	return p->irq_a_state;
+int pia6821_device::get_irq_a()
+{
+	return m_irq_a_state;
 }
 
 
@@ -1301,28 +1413,10 @@
 
 int pia6821_get_irq_b(running_device *device)
 {
-	pia6821_state *p = get_token(device);
-
-	return p->irq_b_state;
+    return downcast<pia6821_device *>(device)->get_irq_b();
 }
 
-
-/*-------------------------------------------------
-    device definition
--------------------------------------------------*/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID(p,s)				p##pia6821##s
-#define DEVTEMPLATE_FEATURES			DT_HAS_START | DT_HAS_RESET
-#define DEVTEMPLATE_NAME				"6821 PIA"
-#define DEVTEMPLATE_FAMILY				"6821 PIA"
-#include "devtempl.h"
-
-#define DEVTEMPLATE_DERIVED_ID(p,s)		p##pia6822##s
-#define DEVTEMPLATE_DERIVED_FEATURES	0
-#define DEVTEMPLATE_DERIVED_NAME		"6822 PIA"
-#include "devtempl.h"
-
-DEFINE_LEGACY_DEVICE(PIA6821, pia6821);
-DEFINE_LEGACY_DEVICE(PIA6822, pia6822);
+int pia6821_device::get_irq_b()
+{
+	return m_irq_b_state;
+}
diff -Nru src-old/emu/machine/6821pia.h src/emu/machine/6821pia.h
--- src-old/emu/machine/6821pia.h	2010-07-16 04:59:31.000000000 -0700
+++ src/emu/machine/6821pia.h	2010-08-25 20:27:52.000000000 -0700
@@ -3,52 +3,248 @@
     Motorola 6821 PIA interface and emulation
 
     Notes:
-        * pia6821_get_port_b_z_mask() gives the caller the bitmask
-          that show which bits are high-impendance when
-          reading port B, thus neither 0 or 1.
-          pia6821_get_output_cb2_z() returns the same
-          information for the CB2 pin
-        * pia6821_set_port_a_z_mask allows the input callback to
-          indicate which port A bits are disconnected.
-          For these bit, the read operation will return the
-          output buffer's contents
-        * the 'alt' interface functions are used when the A0 and A1
-          address bits are swapped
-        * all 'int' data or return values are Boolean
+        * get_port_b_z_mask() gives the caller the bitmask that shows
+          which bits are high-impendance when reading port B, and thus
+          neither 0 or 1. get_output_cb2_z() returns the same info
+          for the CB2 pin.
+        * set_port_a_z_mask allows the input callback to indicate
+          which port A bits are disconnected. For these bits, the
+          read operation will return the output buffer's contents.
+        * The 'alt' interface functions are used when the A0 and A1
+          address bits are swapped.
+        * All 'int' data or return values are bool, and should be
+          converted to bool at some point.
 
 **********************************************************************/
 
+#pragma once
+
 #ifndef __6821PIA_H__
 #define __6821PIA_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_PIA6821_ADD(_tag, _intrf) \
+    MDRV_DEVICE_ADD(_tag, PIA6821, 0) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
+#define MDRV_PIA6821_MODIFY(_tag, _intrf) \
+    MDRV_DEVICE_MODIFY(_tag) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
+#define MDRV_PIA6822_ADD(_tag, _intrf) \
+    MDRV_DEVICE_ADD(_tag, PIA6822, 0) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
+#define MDRV_PIA6822_MODIFY(_tag, _intrf) \
+    MDRV_DEVICE_MODIFY(_tag) \
+    MDRV_DEVICE_CONFIG(_intrf)
+
 
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-/*------------- PIA interface structure -----------------*/
 
-typedef struct _pia6821_interface pia6821_interface;
-struct _pia6821_interface
+// ======================> pia6821_interface
+
+struct pia6821_interface
+{
+    devcb_read8 m_in_a_func;
+    devcb_read8 m_in_b_func;
+    devcb_read_line m_in_ca1_func;
+    devcb_read_line m_in_cb1_func;
+    devcb_read_line m_in_ca2_func;
+    devcb_read_line m_in_cb2_func;
+    devcb_write8 m_out_a_func;
+    devcb_write8 m_out_b_func;
+    devcb_write_line m_out_ca2_func;
+    devcb_write_line m_out_cb2_func;
+    devcb_write_line m_irq_a_func;
+    devcb_write_line m_irq_b_func;
+};
+
+
+
+// ======================> pia6821_device_config
+
+class pia6821_device_config : public device_config,
+                              public pia6821_interface
+{
+    friend class pia6821_device;
+
+    // construction/destruction
+    pia6821_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> pia6821_device
+
+class pia6821_device :  public device_t
 {
-	devcb_read8 in_a_func;
-	devcb_read8 in_b_func;
-	devcb_read_line in_ca1_func;
-	devcb_read_line in_cb1_func;
-	devcb_read_line in_ca2_func;
-	devcb_read_line in_cb2_func;
-	devcb_write8 out_a_func;
-	devcb_write8 out_b_func;
-	devcb_write_line out_ca2_func;
-	devcb_write_line out_cb2_func;
-	devcb_write_line irq_a_func;
-	devcb_write_line irq_b_func;
+    friend class pia6821_device_config;
+
+    // construction/destruction
+    pia6821_device(running_machine &_machine, const pia6821_device_config &_config);
+
+public:
+
+    UINT8 reg_r(UINT8 offset);
+    void reg_w(UINT8 offset, UINT8 data);
+
+    UINT8 alt_r(UINT8 offset);
+    void alt_w(UINT8 offset, UINT8 data);
+
+    UINT8 get_port_b_z_mask();          /* see first note in .c */
+    void set_port_a_z_mask(UINT8 data); /* see second note in .c */
+
+    UINT8 porta_r();
+    void porta_w(UINT8 data);
+    void set_input_a(UINT8 data, UINT8 z_mask);
+    UINT8 get_output_a();
+
+    UINT8 ca1_r();
+    void ca1_w(UINT8 state);
+
+    UINT8 ca2_r();
+    void ca2_w(UINT8 state);
+    int get_output_ca2();
+    int get_output_ca2_z();
+
+    UINT8 portb_r();
+    void portb_w(UINT8 data);
+    UINT8 get_output_b();
+
+    UINT8 cb1_r();
+    void cb1_w(UINT8 state);
+
+    UINT8 cb2_r();
+    void cb2_w(UINT8 state);
+    int get_output_cb2();
+    int get_output_cb2_z();
+
+    int get_irq_a();
+    int get_irq_b();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+    void update_interrupts();
+
+    UINT8 get_in_a_value();
+    UINT8 get_in_b_value();
+
+    UINT8 get_out_a_value();
+    UINT8 get_out_b_value();
+
+    void set_out_ca2(int data);
+    void set_out_cb2(int data);
+
+    UINT8 port_a_r();
+    UINT8 ddr_a_r();
+    UINT8 control_a_r();
+
+    UINT8 port_b_r();
+    UINT8 ddr_b_r();
+    UINT8 control_b_r();
+
+    void send_to_out_a_func(const char* message);
+    void send_to_out_b_func(const char* message);
+
+    void port_a_w(UINT8 data);
+    void ddr_a_w(UINT8 data);
+
+    void port_b_w(UINT8 data);
+    void ddr_b_w(UINT8 data);
+
+    void control_a_w(UINT8 data);
+    void control_b_w(UINT8 data);
+
+    devcb_resolved_read8 m_in_a_func;
+    devcb_resolved_read8 m_in_b_func;
+    devcb_resolved_read_line m_in_ca1_func;
+    devcb_resolved_read_line m_in_cb1_func;
+    devcb_resolved_read_line m_in_ca2_func;
+    devcb_resolved_read_line m_in_cb2_func;
+    devcb_resolved_write8 m_out_a_func;
+    devcb_resolved_write8 m_out_b_func;
+    devcb_resolved_write_line m_out_ca2_func;
+    devcb_resolved_write_line m_out_cb2_func;
+    devcb_resolved_write_line m_irq_a_func;
+    devcb_resolved_write_line m_irq_b_func;
+
+    UINT8 m_in_a;
+    UINT8 m_in_ca1;
+    UINT8 m_in_ca2;
+    UINT8 m_out_a;
+    UINT8 m_out_ca2;
+    UINT8 m_port_a_z_mask;
+    UINT8 m_ddr_a;
+    UINT8 m_ctl_a;
+    UINT8 m_irq_a1;
+    UINT8 m_irq_a2;
+    UINT8 m_irq_a_state;
+
+    UINT8 m_in_b;
+    UINT8 m_in_cb1;
+    UINT8 m_in_cb2;
+    UINT8 m_out_b;
+    UINT8 m_out_cb2;
+    UINT8 m_last_out_cb2_z;
+    UINT8 m_ddr_b;
+    UINT8 m_ctl_b;
+    UINT8 m_irq_b1;
+    UINT8 m_irq_b2;
+    UINT8 m_irq_b_state;
+
+    /* variables that indicate if access a line externally -
+       used to for logging purposes ONLY */
+    UINT8 m_in_a_pushed;
+    UINT8 m_out_a_needs_pulled;
+    UINT8 m_in_ca1_pushed;
+    UINT8 m_in_ca2_pushed;
+    UINT8 m_out_ca2_needs_pulled;
+    UINT8 m_in_b_pushed;
+    UINT8 m_out_b_needs_pulled;
+    UINT8 m_in_cb1_pushed;
+    UINT8 m_in_cb2_pushed;
+    UINT8 m_out_cb2_needs_pulled;
+    UINT8 m_logged_port_a_not_connected;
+    UINT8 m_logged_port_b_not_connected;
+    UINT8 m_logged_ca1_not_connected;
+    UINT8 m_logged_ca2_not_connected;
+    UINT8 m_logged_cb1_not_connected;
+    UINT8 m_logged_cb2_not_connected;
+
+    const pia6821_device_config &m_config;
 };
 
-DECLARE_LEGACY_DEVICE(PIA6821, pia6821);
-DECLARE_LEGACY_DEVICE(PIA6822, pia6822);
+
+// device type definition
+extern const device_type PIA6821;
 
 
 
@@ -94,24 +290,4 @@
 int pia6821_get_irq_b(running_device *device);
 
 
-/***************************************************************************
-    DEVICE CONFIGURATION MACROS
-***************************************************************************/
-
-#define MDRV_PIA6821_ADD(_tag, _intrf) \
-	MDRV_DEVICE_ADD(_tag, PIA6821, 0) \
-	MDRV_DEVICE_CONFIG(_intrf)
-
-#define MDRV_PIA6821_MODIFY(_tag, _intrf) \
-	MDRV_DEVICE_MODIFY(_tag) \
-	MDRV_DEVICE_CONFIG(_intrf)
-
-#define MDRV_PIA6822_ADD(_tag, _intrf) \
-	MDRV_DEVICE_ADD(_tag, PIA6822, 0) \
-	MDRV_DEVICE_CONFIG(_intrf)
-
-#define MDRV_PIA6822_MODIFY(_tag, _intrf) \
-	MDRV_DEVICE_MODIFY(_tag) \
-	MDRV_DEVICE_CONFIG(_intrf)
-
-#endif /* __6821NEW_H__ */
+#endif /* __6821PIA_H__ */
diff -Nru src-old/emu/machine/6840ptm.c src/emu/machine/6840ptm.c
--- src-old/emu/machine/6840ptm.c	2010-07-08 07:10:23.000000000 -0700
+++ src/emu/machine/6840ptm.c	2010-08-28 09:48:51.000000000 -0700
@@ -35,29 +35,17 @@
 
 #include "emu.h"
 #include "6840ptm.h"
+#include "devhelpr.h"
 
 
 #define PTMVERBOSE 0
 #define PLOG(x) do { if (PTMVERBOSE) logerror x; } while (0)
 
 /***************************************************************************
-    PARAMETERS / PROTOTYPES
+    LOCAL VARIABLES
 ***************************************************************************/
 
-enum
-{
-	PTM_6840_CTRL1   = 0,
-	PTM_6840_CTRL2   = 1,
-	PTM_6840_STATUS  = 1,
-	PTM_6840_MSBBUF1 = 2,
-	PTM_6840_LSB1	 = 3,
-	PTM_6840_MSBBUF2 = 4,
-	PTM_6840_LSB2    = 5,
-	PTM_6840_MSBBUF3 = 6,
-	PTM_6840_LSB3    = 7,
-};
-
-static const char *const opmode[] =
+const char *const ptm6840_device::opmode[] =
 {
 	"000 continuous mode",
 	"001 freq comparison mode",
@@ -69,65 +57,141 @@
 	"111 pulse width comparison mode"
 };
 
-static void ptm6840_timeout(running_device *device, int idx);
-
 /***************************************************************************
-    TYPE DEFINITIONS
+    IMPLEMENTATION
 ***************************************************************************/
 
-typedef struct _ptm6840_state ptm6840_state;
-struct _ptm6840_state
-{
-	double internal_clock;
-	double external_clock[3];
-	devcb_resolved_write8 out_func[3];	// function to call when output[idx] changes
-	devcb_resolved_write_line irq_func;	// function called if IRQ line changes
-
-	UINT8 control_reg[3];
-	UINT8 output[3]; /* Output states */
-	UINT8 gate[3];   /* Input gate states */
-	UINT8 clock[3];  /* Clock states */
-	UINT8 enabled[3];
-	UINT8 mode[3];
-	UINT8 fired[3];
-	UINT8 t3_divisor;
-	UINT8 t3_scaler;
-	UINT8 IRQ;
-	UINT8 status_reg;
-	UINT8 status_read_since_int;
-	UINT8 lsb_buffer;
-	UINT8 msb_buffer;
+GENERIC_DEVICE_CONFIG_SETUP(ptm6840, "6840 PTM")
 
-	/* Each PTM has 3 timers */
-	emu_timer *timer[3];
+const device_type PTM6840 = ptm6840_device_config::static_alloc_device_config;
 
-	UINT16 latch[3];
-	UINT16 counter[3];
-};
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void ptm6840_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const ptm6840_interface *intf = reinterpret_cast<const ptm6840_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<ptm6840_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_internal_clock = 0.0;
+		m_external_clock[0] = 0.0;
+		m_external_clock[1] = 0.0;
+		m_external_clock[2] = 0.0;
+		memset(&m_irq_func, 0, sizeof(m_irq_func));
+    	memset(&m_out_func[0], 0, sizeof(m_out_func[0]));
+    	memset(&m_out_func[1], 0, sizeof(m_out_func[1]));
+    	memset(&m_out_func[2], 0, sizeof(m_out_func[2]));
+	}
+}
 
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+//-------------------------------------------------
+//  ptm6840_device - constructor
+//-------------------------------------------------
 
-INLINE ptm6840_state *get_safe_token(running_device *device)
+ptm6840_device::ptm6840_device(running_machine &_machine, const ptm6840_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert((device->type() == PTM6840));
-	return (ptm6840_state *)downcast<legacy_device_base *>(device)->token();
+
 }
 
-INLINE const ptm6840_interface *get_interface(running_device *device)
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ptm6840_device::device_start()
 {
-	assert(device != NULL);
-	assert((device->type() == PTM6840));
-	return (const ptm6840_interface *) device->baseconfig().static_config();
+	m_internal_clock = m_config.m_internal_clock;
+
+	/* resolve callbacks */
+	for (int i = 0; i < 3; i++)
+	{
+		devcb_resolve_write8(&m_out_func[i], &m_config.m_out_func[i], this);
+	}
+
+	for (int i = 0; i < 3; i++)
+	{
+		if ( m_config.m_external_clock[i] )
+		{
+			m_external_clock[i] = m_config.m_external_clock[i];
+		}
+		else
+		{
+			m_external_clock[i] = 1;
+		}
+	}
+
+
+	m_timer[0] = timer_alloc(&m_machine, ptm6840_timer1_cb, (void *)this);
+	m_timer[1] = timer_alloc(&m_machine, ptm6840_timer2_cb, (void *)this);
+	m_timer[2] = timer_alloc(&m_machine, ptm6840_timer3_cb, (void *)this);
+
+	for (int i = 0; i < 3; i++)
+	{
+		timer_enable(m_timer[i], FALSE);
+	}
+
+	devcb_resolve_write_line(&m_irq_func, &m_config.m_irq_func, this);
+
+	/* register for state saving */
+	state_save_register_device_item(this, 0, m_lsb_buffer);
+	state_save_register_device_item(this, 0, m_msb_buffer);
+	state_save_register_device_item(this, 0, m_status_read_since_int);
+	state_save_register_device_item(this, 0, m_status_reg);
+	state_save_register_device_item(this, 0, m_t3_divisor);
+	state_save_register_device_item(this, 0, m_t3_scaler);
+	state_save_register_device_item(this, 0, m_internal_clock);
+	state_save_register_device_item(this, 0, m_IRQ);
+
+	state_save_register_device_item_array(this, 0, m_control_reg);
+	state_save_register_device_item_array(this, 0, m_output);
+	state_save_register_device_item_array(this, 0, m_gate);
+	state_save_register_device_item_array(this, 0, m_clk);
+	state_save_register_device_item_array(this, 0, m_mode);
+	state_save_register_device_item_array(this, 0, m_fired);
+	state_save_register_device_item_array(this, 0, m_enabled);
+	state_save_register_device_item_array(this, 0, m_external_clock);
+	state_save_register_device_item_array(this, 0, m_counter);
+	state_save_register_device_item_array(this, 0, m_latch);
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ptm6840_device::device_reset()
+{
+	m_control_reg[2]		 = 0;
+	m_control_reg[1]		 = 0;
+	m_control_reg[0]		 = 1;
+	m_status_reg			 = 0;
+	m_t3_divisor			 = 1;
+	m_status_read_since_int = 0;
+	m_IRQ                   = 0;
+
+	for (int i = 0; i < 3; i++)
+	{
+		m_counter[i] = 0xffff;
+		m_latch[i]   = 0xffff;
+		m_output[i]  = 0;
+		m_fired[i]   = 0;
+	}
 }
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
 
 /*-------------------------------------------------
     ptm6840_get_status - Get enabled status
@@ -135,41 +199,55 @@
 
 int ptm6840_get_status( running_device *device, int clock )
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	return ptm6840->enabled[clock - 1];
+	return downcast<ptm6840_device*>(device)->ptm6840_get_status(clock);
+}
+
+int ptm6840_device::ptm6840_get_status( int clock )
+{
+	return m_enabled[clock - 1];
 }
 
+
+
 /*-------------------------------------------------
     ptm6840_get_irq - Get IRQ state
 -------------------------------------------------*/
 
 int ptm6840_get_irq( running_device *device )
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	return ptm6840->IRQ;
+	return downcast<ptm6840_device*>(device)->ptm6840_get_irq();
+}
+
+int ptm6840_device::ptm6840_get_irq()
+{
+	return m_IRQ;
 }
 
+
+
 /*-------------------------------------------------
     subtract_from_counter - Subtract from Counter
 -------------------------------------------------*/
 
-static void subtract_from_counter( running_device *device, int counter, int count )
+void ptm6840_device::subtract_from_counter(int counter, int count)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
 	double clock;
-	attotime duration;
 
 	/* Determine the clock frequency for this timer */
-	if (ptm6840->control_reg[counter] & 0x02)
-		clock = ptm6840->internal_clock;
+	if (m_control_reg[counter] & 0x02)
+	{
+		clock = m_internal_clock;
+	}
 	else
-		clock = ptm6840->external_clock[counter];
+	{
+		clock = m_external_clock[counter];
+	}
 
 	/* Dual-byte mode */
-	if (ptm6840->control_reg[counter] & 0x04)
+	if (m_control_reg[counter] & 0x04)
 	{
-		int lsb = ptm6840->counter[counter] & 0xff;
-		int msb = ptm6840->counter[counter] >> 8;
+		int lsb = m_counter[counter] & 0xff;
+		int msb = m_counter[counter] >> 8;
 
 		/* Count the clocks */
 		lsb -= count;
@@ -178,25 +256,25 @@
 		while (lsb < 0)
 		{
 			/* Borrow from the MSB */
-			lsb += (ptm6840->latch[counter] & 0xff) + 1;
+			lsb += (m_latch[counter] & 0xff) + 1;
 			msb--;
 
 			/* If MSB goes less than zero, we've expired */
 			if (msb < 0)
 			{
-				ptm6840_timeout(device, counter);
-				msb = (ptm6840->latch[counter] >> 8) + 1;
+				ptm6840_timeout(counter);
+				msb = (m_latch[counter] >> 8) + 1;
 			}
 		}
 
 		/* Store the result */
-		ptm6840->counter[counter] = (msb << 8) | lsb;
+		m_counter[counter] = (msb << 8) | lsb;
 	}
 
 	/* Word mode */
 	else
 	{
-		int word = ptm6840->counter[counter];
+		int word = m_counter[counter];
 
 		/* Count the clocks */
 		word -= count;
@@ -205,197 +283,214 @@
 		while (word < 0)
 		{
 			/* Borrow from the MSB */
-			word += ptm6840->latch[counter] + 1;
+			word += m_latch[counter] + 1;
 
 			/* We've expired */
-			ptm6840_timeout(device, counter);
+			ptm6840_timeout(counter);
 		}
 
 		/* Store the result */
-		ptm6840->counter[counter] = word;
+		m_counter[counter] = word;
 	}
 
-	if (ptm6840->enabled[counter])
+	if (m_enabled[counter])
 	{
-		duration = attotime_mul(ATTOTIME_IN_HZ(clock), ptm6840->counter[counter]);
+		attotime duration = attotime_mul(ATTOTIME_IN_HZ(clock), m_counter[counter]);
 
 		if (counter == 2)
-			duration = attotime_mul(duration, ptm6840->t3_divisor);
+		{
+			duration = attotime_mul(duration, m_t3_divisor);
+		}
 
-		timer_adjust_oneshot(ptm6840->timer[counter], duration, 0);
+		timer_adjust_oneshot(m_timer[counter], duration, 0);
 	}
 }
 
+
+
 /*-------------------------------------------------
     ptm_tick
 -------------------------------------------------*/
 
-static void ptm_tick( running_device *device, int counter, int count )
+void ptm6840_device::ptm_tick(int counter, int count)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-
 	if (counter == 2)
 	{
-		ptm6840->t3_scaler += count;
+		m_t3_scaler += count;
 
-		if ( ptm6840->t3_scaler > ptm6840->t3_divisor - 1)
+		if ( m_t3_scaler > m_t3_divisor - 1)
 		{
-			subtract_from_counter(device, counter, 1);
-			ptm6840->t3_scaler = 0;
+			subtract_from_counter(counter, 1);
+			m_t3_scaler = 0;
 		}
 	}
 	else
 	{
-		subtract_from_counter(device, counter, count);
+		subtract_from_counter(counter, count);
 	}
 }
 
+
+
 /*-------------------------------------------------
     update_interrupts - Update Internal Interrupts
 -------------------------------------------------*/
 
-INLINE void update_interrupts( running_device *device )
+void update_interrupts( running_device *device )
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	int new_state;
+	downcast<ptm6840_device*>(device)->update_interrupts();
+}
 
-	new_state = ((ptm6840->status_reg & 0x01) && (ptm6840->control_reg[0] & 0x40)) ||
-				((ptm6840->status_reg & 0x02) && (ptm6840->control_reg[1] & 0x40)) ||
-				((ptm6840->status_reg & 0x04) && (ptm6840->control_reg[2] & 0x40));
+void ptm6840_device::update_interrupts()
+{
+	int new_state = ((m_status_reg & 0x01) && (m_control_reg[0] & 0x40)) ||
+					((m_status_reg & 0x02) && (m_control_reg[1] & 0x40)) ||
+					((m_status_reg & 0x04) && (m_control_reg[2] & 0x40));
 
-	if (new_state != ptm6840->IRQ)
+	if (new_state != m_IRQ)
 	{
-		ptm6840->IRQ = new_state;
+		m_IRQ = new_state;
 
-		if (ptm6840->IRQ)
-			ptm6840->status_reg |= 0x80;
+		if (m_IRQ)
+		{
+			m_status_reg |= 0x80;
+		}
 		else
-			ptm6840->status_reg &= ~0x80;
+		{
+			m_status_reg &= ~0x80;
+		}
 
-		devcb_call_write_line(&ptm6840->irq_func, ptm6840->IRQ);
+		devcb_call_write_line(&m_irq_func, m_IRQ);
 	}
 }
 
+
+
 /*-------------------------------------------------
     compute_counter - Compute Counter
 -------------------------------------------------*/
 
-static UINT16 compute_counter( running_device *device, int counter )
+UINT16 ptm6840_device::compute_counter( int counter )
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
 	double clock;
-	int remaining = 0;
 
 	/* If there's no timer, return the count */
-	if (!ptm6840->enabled[counter])
+	if (!m_enabled[counter])
 	{
-		PLOG(("MC6840 #%s: read counter(%d): %d\n", device->tag(), counter, ptm6840->counter[counter]));
-		return ptm6840->counter[counter];
+		PLOG(("MC6840 #%s: read counter(%d): %d\n", tag(), counter, m_counter[counter]));
+		return m_counter[counter];
 	}
 
 	/* determine the clock frequency for this timer */
-	if (ptm6840->control_reg[counter] & 0x02)
+	if (m_control_reg[counter] & 0x02)
 	{
-		clock = ptm6840->internal_clock;
-		PLOG(("MC6840 #%s: %d internal clock freq %f \n", device->tag(), counter, clock));
+		clock = m_internal_clock;
+		PLOG(("MC6840 #%s: %d internal clock freq %f \n", tag(), counter, clock));
 	}
 	else
 	{
-		clock = ptm6840->external_clock[counter];
-		PLOG(("MC6840 #%s: %d external clock freq %f \n", device->tag(), counter, clock));
+		clock = m_external_clock[counter];
+		PLOG(("MC6840 #%s: %d external clock freq %f \n", tag(), counter, clock));
 	}
 	/* See how many are left */
-	remaining = attotime_to_double(attotime_mul(timer_timeleft(ptm6840->timer[counter]), clock));
+	int remaining = attotime_to_double(attotime_mul(timer_timeleft(m_timer[counter]), clock));
 
 	/* Adjust the count for dual byte mode */
-	if (ptm6840->control_reg[counter] & 0x04)
+	if (m_control_reg[counter] & 0x04)
 	{
-		int divisor = (ptm6840->counter[counter] & 0xff) + 1;
+		int divisor = (m_counter[counter] & 0xff) + 1;
 		int msb = remaining / divisor;
 		int lsb = remaining % divisor;
 		remaining = (msb << 8) | lsb;
 	}
-	PLOG(("MC6840 #%s: read counter(%d): %d\n", device->tag(), counter, remaining));
+	PLOG(("MC6840 #%s: read counter(%d): %d\n", tag(), counter, remaining));
 	return remaining;
 }
 
+
+
 /*-------------------------------------------------
     reload_count - Reload Counter
 -------------------------------------------------*/
 
-static void reload_count( running_device *device, int idx )
+void ptm6840_device::reload_count(int idx)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
 	double clock;
-	int count;
-	attotime duration;
 
 	/* Copy the latched value in */
-	ptm6840->counter[idx] = ptm6840->latch[idx];
+	m_counter[idx] = m_latch[idx];
 
 	/* Determine the clock frequency for this timer */
-	if (ptm6840->control_reg[idx] & 0x02)
+	if (m_control_reg[idx] & 0x02)
 	{
-		clock = ptm6840->internal_clock;
-		PLOG(("MC6840 #%s: %d internal clock freq %f \n", device->tag(), idx, clock));
+		clock = m_internal_clock;
+		PLOG(("MC6840 #%s: %d internal clock freq %f \n", tag(), idx, clock));
 	}
 	else
 	{
-		clock = ptm6840->external_clock[idx];
-		PLOG(("MC6840 #%s: %d external clock freq %f \n", device->tag(), idx, clock));
+		clock = m_external_clock[idx];
+		PLOG(("MC6840 #%s: %d external clock freq %f \n", tag(), idx, clock));
 	}
 
 	/* Determine the number of clock periods before we expire */
-	count = ptm6840->counter[idx];
-	if (ptm6840->control_reg[idx] & 0x04)
+	int count = m_counter[idx];
+	if (m_control_reg[idx] & 0x04)
+	{
 		count = ((count >> 8) + 1) * ((count & 0xff) + 1);
+	}
 	else
+	{
 		count = count + 1;
+	}
 
-	ptm6840->fired[idx] = 0;
+	m_fired[idx] = 0;
 
-	if ((ptm6840->mode[idx] == 4) || (ptm6840->mode[idx] == 6))
+	if ((m_mode[idx] == 4) || (m_mode[idx] == 6))
 	{
-		ptm6840->output[idx] = 1;
-		if (ptm6840->out_func[idx].write != NULL)
-			devcb_call_write8(&ptm6840->out_func[idx], 0, ptm6840->output[idx]);
+		m_output[idx] = 1;
+		if (m_out_func[idx].write != NULL)
+		{
+			devcb_call_write8(&m_out_func[idx], 0, m_output[idx]);
+		}
 	}
 
 	/* Set the timer */
-	PLOG(("MC6840 #%s: reload_count(%d): clock = %f  count = %d\n", device->tag(), idx, clock, count));
+	PLOG(("MC6840 #%s: reload_count(%d): clock = %f  count = %d\n", tag(), idx, clock, count));
 
-	duration = attotime_mul(ATTOTIME_IN_HZ(clock), count);
+	attotime duration = attotime_mul(ATTOTIME_IN_HZ(clock), count);
 	if (idx == 2)
-		duration = attotime_mul(duration, ptm6840->t3_divisor);
+	{
+		duration = attotime_mul(duration, m_t3_divisor);
+	}
 
-	PLOG(("MC6840 #%s: reload_count(%d): output = %lf\n", device->tag(), idx, attotime_to_double(duration)));
+	PLOG(("MC6840 #%s: reload_count(%d): output = %lf\n", tag(), idx, attotime_to_double(duration)));
 
 #if 0
-	if (!(ptm6840->control_reg[idx] & 0x02))
+	if (!(m_control_reg[idx] & 0x02))
 	{
-		if (!ptm6840->external_clock[idx])
+		if (!m_external_clock[idx])
 		{
-			ptm6840->enabled[idx] = 0;
-			timer_enable(ptm6840->timer[idx],FALSE);
+			m_enabled[idx] = 0;
+			timer_enable(m_timer[idx],FALSE);
 		}
 	}
 	else
 #endif
 	{
-		ptm6840->enabled[idx] = 1;
-		timer_adjust_oneshot(ptm6840->timer[idx], duration, 0);
-		timer_enable(ptm6840->timer[idx], TRUE);
+		m_enabled[idx] = 1;
+		timer_adjust_oneshot(m_timer[idx], duration, 0);
+		timer_enable(m_timer[idx], TRUE);
 	}
 }
 
 
+
 /*-------------------------------------------------
     ptm6840_read - Read Timer
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( ptm6840_read )
+READ8_DEVICE_HANDLER_TRAMPOLINE(ptm6840, ptm6840_read)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
 	int val;
 
 	switch ( offset )
@@ -408,9 +503,9 @@
 
 		case PTM_6840_STATUS:
 		{
-			PLOG(("%s: MC6840 #%s: Status read = %04X\n", cpuexec_describe_context(device->machine), device->tag(), ptm6840->status_reg));
-			ptm6840->status_read_since_int |= ptm6840->status_reg & 0x07;
-			val = ptm6840->status_reg;
+			PLOG(("%s: MC6840 #%s: Status read = %04X\n", cpuexec_describe_context(&m_machine), tag(), m_status_reg));
+			m_status_read_since_int |= m_status_reg & 0x07;
+			val = m_status_reg;
 			break;
 		}
 
@@ -419,18 +514,18 @@
 		case PTM_6840_MSBBUF3:
 		{
 			int idx = (offset - 2) / 2;
-			int result = compute_counter(device, idx);
+			int result = compute_counter(idx);
 
 			/* Clear the interrupt if the status has been read */
-			if (ptm6840->status_read_since_int & (1 << idx))
+			if (m_status_read_since_int & (1 << idx))
 			{
-				ptm6840->status_reg &= ~(1 << idx);
-				update_interrupts(device);
+				m_status_reg &= ~(1 << idx);
+				update_interrupts();
 			}
 
-			ptm6840->lsb_buffer = result & 0xff;
+			m_lsb_buffer = result & 0xff;
 
-			PLOG(("%s: MC6840 #%s: Counter %d read = %04X\n", cpuexec_describe_context(device->machine), device->tag(), idx, result >> 8));
+			PLOG(("%s: MC6840 #%s: Counter %d read = %04X\n", cpuexec_describe_context(&m_machine), tag(), idx, result >> 8));
 			val = result >> 8;
 			break;
 		}
@@ -439,7 +534,7 @@
 		case PTM_6840_LSB2:
 		case PTM_6840_LSB3:
 		{
-			val = ptm6840->lsb_buffer;
+			val = m_lsb_buffer;
 			break;
 		}
 
@@ -453,38 +548,33 @@
 	return val;
 }
 
+
 /*-------------------------------------------------
     ptm6840_write - Write Timer
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( ptm6840_write )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ptm6840, ptm6840_write)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	int idx;
-	int i;
-	UINT8 diffs;
-
 	switch ( offset )
 	{
 		case PTM_6840_CTRL1:
 		case PTM_6840_CTRL2:
 		{
-			idx = (offset == 1) ? 1 : (ptm6840->control_reg[1] & 0x01) ? 0 : 2;
-			diffs = data ^ ptm6840->control_reg[idx];
-			ptm6840->t3_divisor = (ptm6840->control_reg[2] & 0x01) ? 8 : 1;
-			ptm6840->mode[idx] = (data >> 3) & 0x07;
-			ptm6840->control_reg[idx] = data;
-
-			PLOG(("MC6840 #%s : Control register %d selected\n", device->tag(), idx));
-			PLOG(("operation mode   = %s\n", opmode[ ptm6840->mode[idx] ]));
-			PLOG(("value            = %04X\n", ptm6840->control_reg[idx]));
-			PLOG(("t3divisor        = %d\n", ptm6840->t3_divisor));
+			int idx = (offset == 1) ? 1 : (m_control_reg[1] & 0x01) ? 0 : 2;
+			UINT8 diffs = data ^ m_control_reg[idx];
+			m_t3_divisor = (m_control_reg[2] & 0x01) ? 8 : 1;
+			m_mode[idx] = (data >> 3) & 0x07;
+			m_control_reg[idx] = data;
+
+			PLOG(("MC6840 #%s : Control register %d selected\n", tag(), idx));
+			PLOG(("operation mode   = %s\n", opmode[ m_mode[idx] ]));
+			PLOG(("value            = %04X\n", m_control_reg[idx]));
+			PLOG(("t3divisor        = %d\n", m_t3_divisor));
 
-			if (!(ptm6840->control_reg[idx] & 0x80 ))
+			if (!(m_control_reg[idx] & 0x80 ))
 			{
 				/* Output cleared */
-				if (ptm6840->out_func[idx].write != NULL)
-					devcb_call_write8(&ptm6840->out_func[idx], 0, 0);
+				devcb_call_write8(&m_out_func[idx], 0, 0);
 			}
 			/* Reset? */
 			if (idx == 0 && (diffs & 0x01))
@@ -492,26 +582,30 @@
 				/* Holding reset down */
 				if (data & 0x01)
 				{
-					PLOG(("MC6840 #%s : Timer reset\n", device->tag()));
-					for (i = 0; i < 3; i++)
+					PLOG(("MC6840 #%s : Timer reset\n", tag()));
+					for (int i = 0; i < 3; i++)
 					{
-						timer_enable(ptm6840->timer[i], FALSE);
-						ptm6840->enabled[i] = 0;
+						timer_enable(m_timer[i], FALSE);
+						m_enabled[i] = 0;
 					}
 				}
 				/* Releasing reset */
 				else
 				{
-					for (i = 0; i < 3; i++)
-						reload_count(device, i);
+					for (int i = 0; i < 3; i++)
+					{
+						reload_count(i);
+					}
 				}
 
-				ptm6840->status_reg = 0;
-				update_interrupts(device);
+				m_status_reg = 0;
+				update_interrupts();
 
 				/* Changing the clock source? (e.g. Zwackery) */
 				if (diffs & 0x02)
-					reload_count(device, idx);
+				{
+					reload_count(idx);
+				}
 			}
 			break;
 		}
@@ -520,8 +614,8 @@
 		case PTM_6840_MSBBUF2:
 		case PTM_6840_MSBBUF3:
 		{
-			PLOG(("MC6840 #%s msbbuf%d = %02X\n", device->tag(), offset / 2, data));
-			ptm6840->msb_buffer = data;
+			PLOG(("MC6840 #%s msbbuf%d = %02X\n", tag(), offset / 2, data));
+			m_msb_buffer = data;
 			break;
 		}
 
@@ -529,87 +623,84 @@
 		case PTM_6840_LSB2:
 		case PTM_6840_LSB3:
 		{
-			idx = (offset - 3) / 2;
-			ptm6840->latch[idx] = (ptm6840->msb_buffer << 8) | (data & 0xff);
+			int idx = (offset - 3) / 2;
+			m_latch[idx] = (m_msb_buffer << 8) | (data & 0xff);
 
 			/* Clear the interrupt */
-			ptm6840->status_reg &= ~(1 << idx);
-			update_interrupts(device);
+			m_status_reg &= ~(1 << idx);
+			update_interrupts();
 
 			/* Reload the count if in an appropriate mode */
-			if (!(ptm6840->control_reg[idx] & 0x10))
-				reload_count(device,idx);
+			if (!(m_control_reg[idx] & 0x10))
+			{
+				reload_count(idx);
+			}
 
-			PLOG(("%s:MC6840 #%s: Counter %d latch = %04X\n", cpuexec_describe_context(device->machine), device->tag(), idx, ptm6840->latch[idx]));
+			PLOG(("%s:MC6840 #%s: Counter %d latch = %04X\n", cpuexec_describe_context(&m_machine), tag(), idx, m_latch[idx]));
 			break;
 		}
 	}
 }
 
+
 /*-------------------------------------------------
     ptm6840_timeout - Called if timer is mature
 -------------------------------------------------*/
 
-static void ptm6840_timeout( running_device *device, int idx )
+void ptm6840_device::ptm6840_timeout(int idx)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-
-	PLOG(("**ptm6840 %s t%d timeout**\n", device->tag(), idx + 1));
+	PLOG(("**ptm6840 %s t%d timeout**\n", tag(), idx + 1));
 
 	/* Set the interrupt flag */
-	ptm6840->status_reg |= (1 << idx);
-	ptm6840->status_read_since_int &= ~(1 << idx);
-	update_interrupts(device);
+	m_status_reg |= (1 << idx);
+	m_status_read_since_int &= ~(1 << idx);
+	update_interrupts();
 
-	if ( ptm6840->control_reg[idx] & 0x80 )
+	if ( m_control_reg[idx] & 0x80 )
 	{
-		if ((ptm6840->mode[idx] == 0)||(ptm6840->mode[idx] == 2))
+		if ((m_mode[idx] == 0)||(m_mode[idx] == 2))
 		{
-			ptm6840->output[idx] = ptm6840->output[idx] ? 0 : 1;
-			PLOG(("**ptm6840 %s t%d output %d **\n", device->tag(), idx + 1, ptm6840->output[idx]));
+			m_output[idx] = m_output[idx] ? 0 : 1;
+			PLOG(("**ptm6840 %s t%d output %d **\n", tag(), idx + 1, m_output[idx]));
 
-			if (ptm6840->out_func[idx].write != NULL)
-				devcb_call_write8(&ptm6840->out_func[idx], 0, ptm6840->output[idx]);
+			devcb_call_write8(&m_out_func[idx], 0, m_output[idx]);
 		}
-		if ((ptm6840->mode[idx] == 4)||(ptm6840->mode[idx] == 6))
+		if ((m_mode[idx] == 4)||(m_mode[idx] == 6))
 		{
-			if (!ptm6840->fired[idx])
+			if (!m_fired[idx])
 			{
-				ptm6840->output[idx] = 1;
-				PLOG(("**ptm6840 %s t%d output %d **\n", device->tag(), idx + 1, ptm6840->output[idx]));
+				m_output[idx] = 1;
+				PLOG(("**ptm6840 %s t%d output %d **\n", tag(), idx + 1, m_output[idx]));
 
-				if (ptm6840->out_func[idx].write != NULL)
-					devcb_call_write8(&ptm6840->out_func[idx], 0, ptm6840->output[idx]);
+				devcb_call_write8(&m_out_func[idx], 0, m_output[idx]);
 
 				/* No changes in output until reinit */
-				ptm6840->fired[idx] = 1;
+				m_fired[idx] = 1;
 			}
 		}
 	}
-	ptm6840->enabled[idx]= 0;
-	reload_count(device, idx);
+	m_enabled[idx]= 0;
+	reload_count(idx);
 }
 
+
 /*-------------------------------------------------
     TIMER_CALLBACKs for Timer 1, 2 & 3
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( ptm6840_timer1_cb )
+TIMER_CALLBACK( ptm6840_device::ptm6840_timer1_cb )
 {
-	running_device *device = (running_device *)ptr;
-	ptm6840_timeout(device, 0);
+	reinterpret_cast<ptm6840_device *>(ptr)->ptm6840_timeout(0);
 }
 
-static TIMER_CALLBACK( ptm6840_timer2_cb )
+TIMER_CALLBACK( ptm6840_device::ptm6840_timer2_cb )
 {
-	running_device *device = (running_device *)ptr;
-	ptm6840_timeout(device, 1);
+	reinterpret_cast<ptm6840_device *>(ptr)->ptm6840_timeout(1);
 }
 
-static TIMER_CALLBACK( ptm6840_timer3_cb )
+TIMER_CALLBACK( ptm6840_device::ptm6840_timer3_cb )
 {
-	running_device *device = (running_device *)ptr;
-	ptm6840_timeout(device, 2);
+	reinterpret_cast<ptm6840_device *>(ptr)->ptm6840_timeout(2);
 }
 
 
@@ -617,71 +708,74 @@
     ptm6840_set_gate - set gate status (0 or 1)
 -------------------------------------------------*/
 
-INLINE void ptm6840_set_gate( running_device *device, int state, int idx )
+void ptm6840_device::ptm6840_set_gate(int state, int idx)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-
-	if ( (ptm6840->mode[idx] == 0) || (ptm6840->mode[idx] == 2) || (ptm6840->mode[0] == 4) || (ptm6840->mode[idx] == 6) )
+	if ( (m_mode[idx] == 0) || (m_mode[idx] == 2) || (m_mode[0] == 4) || (m_mode[idx] == 6) )
 	{
-		if (state == 0 && ptm6840->gate[idx])
-			reload_count(device,idx);
+		if (state == 0 && m_gate[idx])
+		{
+			reload_count(idx);
+		}
 	}
-	ptm6840->gate[idx] = state;
+	m_gate[idx] = state;
 }
 
+
 /*-------------------------------------------------
     WRITE8_DEVICE_HANDLERs for Gate 1, 2 & 3
 -------------------------------------------------*/
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_g1 )
 {
-	ptm6840_set_gate(device, data, 0);
+	downcast<ptm6840_device*>(device)->ptm6840_set_gate(data, 0);
 }
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_g2 )
 {
-	ptm6840_set_gate(device, data, 1);
+	downcast<ptm6840_device*>(device)->ptm6840_set_gate(data, 1);
 }
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_g3 )
 {
-	ptm6840_set_gate(device, data, 2);
+	downcast<ptm6840_device*>(device)->ptm6840_set_gate(data, 2);
 }
 
+
 /*-------------------------------------------------
     ptm6840_set_clock - set clock status (0 or 1)
 -------------------------------------------------*/
 
-INLINE void ptm6840_set_clock( running_device *device, int state, int idx )
+void ptm6840_device::ptm6840_set_clock(int state, int idx)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-
-	ptm6840->clock[idx] = state;
+	m_clk[idx] = state;
 
-	if (!(ptm6840->control_reg[idx] & 0x02))
+	if (!(m_control_reg[idx] & 0x02))
 	{
 		if (state)
-			ptm_tick(device, idx, 1);
+		{
+			ptm_tick(idx, 1);
+		}
 	}
 }
 
+
 /*-------------------------------------------------
     WRITE8_DEVICE_HANDLERs for Clock 1, 2 & 3
 -------------------------------------------------*/
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_c1 )
 {
-	ptm6840_set_clock(device, data, 0);
+	downcast<ptm6840_device*>(device)->ptm6840_set_clock(data, 0);
 }
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_c2 )
 {
-	ptm6840_set_clock(device, data, 1);
+	downcast<ptm6840_device*>(device)->ptm6840_set_clock(data, 1);
 }
 
 WRITE8_DEVICE_HANDLER( ptm6840_set_c3 )
 {
-	ptm6840_set_clock(device, data, 2);
+	downcast<ptm6840_device*>(device)->ptm6840_set_clock(data, 2);
 }
 
 
@@ -689,27 +783,36 @@
     ptm6840_get_count - get count value
 -------------------------------------------------*/
 
-UINT16 ptm6840_get_count( running_device *device, int counter )
+UINT16 ptm6840_get_count(running_device *device, int counter)
+{
+	return downcast<ptm6840_device*>(device)->ptm6840_get_count(counter);
+}
+
+UINT16 ptm6840_device::ptm6840_get_count(int counter)
 {
-	return compute_counter(device, counter);
+	return compute_counter(counter);
 }
 
+
 /*------------------------------------------------------------
     ptm6840_set_ext_clock - set external clock frequency
 ------------------------------------------------------------*/
 
-void ptm6840_set_ext_clock( running_device *device, int counter, double clock )
+void ptm6840_set_ext_clock(running_device *device, int counter, double clock)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
+	downcast<ptm6840_device*>(device)->ptm6840_set_ext_clock(counter, clock);
+}
 
-	ptm6840->external_clock[counter] = clock;
+void ptm6840_device::ptm6840_set_ext_clock(int counter, double clock)
+{
+	m_external_clock[counter] = clock;
 
-	if (!(ptm6840->control_reg[counter] & 0x02))
+	if (!(m_control_reg[counter] & 0x02))
 	{
-		if (!ptm6840->external_clock[counter])
+		if (!m_external_clock[counter])
 		{
-			ptm6840->enabled[counter] = 0;
-			timer_enable(ptm6840->timer[counter], FALSE);
+			m_enabled[counter] = 0;
+			timer_enable(m_timer[counter], FALSE);
 		}
 	}
 	else
@@ -718,130 +821,41 @@
 		attotime duration;
 
 		/* Determine the number of clock periods before we expire */
-		count = ptm6840->counter[counter];
+		count = m_counter[counter];
 
-		if (ptm6840->control_reg[counter] & 0x04)
+		if (m_control_reg[counter] & 0x04)
+		{
 			count = ((count >> 8) + 1) * ((count & 0xff) + 1);
+		}
 		else
+		{
 			count = count + 1;
+		}
 
 		duration = attotime_mul(ATTOTIME_IN_HZ(clock), count);
 
 		if (counter == 2)
-			duration = attotime_mul(duration, ptm6840->t3_divisor);
+		{
+			duration = attotime_mul(duration, m_t3_divisor);
+		}
 
-		ptm6840->enabled[counter] = 1;
-		timer_adjust_oneshot(ptm6840->timer[counter], duration, 0);
-		timer_enable(ptm6840->timer[counter], TRUE);
+		m_enabled[counter] = 1;
+		timer_adjust_oneshot(m_timer[counter], duration, 0);
+		timer_enable(m_timer[counter], TRUE);
 	}
 }
 
+
 /*------------------------------------------------------------
     ptm6840_get_ext_clock - get external clock frequency
 ------------------------------------------------------------*/
 
 int ptm6840_get_ext_clock( running_device *device, int counter )
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	return ptm6840->external_clock[counter];
+	return downcast<ptm6840_device*>(device)->ptm6840_get_ext_clock(counter);
 }
 
-
-/*-------------------------------------------------
-    DEVICE_START( ptm6840 )
--------------------------------------------------*/
-
-static DEVICE_START( ptm6840 )
+int ptm6840_device::ptm6840_get_ext_clock(int counter)
 {
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	const ptm6840_interface *intf = get_interface(device);
-	int i;
-
-	ptm6840->internal_clock = intf->internal_clock;
-
-	/* resolve callbacks */
-	for (i = 0; i < 3; i++)
-	{
-		devcb_resolve_write8(&ptm6840->out_func[i], &intf->out_func[i], device);
-	}
-
-	for (i = 0; i < 3; i++)
-	{
-		if ( intf->external_clock[i] )
-			ptm6840->external_clock[i] = intf->external_clock[i];
-		else
-			ptm6840->external_clock[i] = 1;
-	}
-
-
-	ptm6840->timer[0] = timer_alloc(device->machine, ptm6840_timer1_cb, (void *)device);
-	ptm6840->timer[1] = timer_alloc(device->machine, ptm6840_timer2_cb, (void *)device);
-	ptm6840->timer[2] = timer_alloc(device->machine, ptm6840_timer3_cb, (void *)device);
-
-	for (i = 0; i < 3; i++)
-	{
-		timer_enable(ptm6840->timer[i], FALSE);
-	}
-
-	devcb_resolve_write_line(&ptm6840->irq_func, &intf->irq_func, device);
-
-	/* register for state saving */
-	state_save_register_device_item(device, 0, ptm6840->lsb_buffer);
-	state_save_register_device_item(device, 0, ptm6840->msb_buffer);
-	state_save_register_device_item(device, 0, ptm6840->status_read_since_int);
-	state_save_register_device_item(device, 0, ptm6840->status_reg);
-	state_save_register_device_item(device, 0, ptm6840->t3_divisor);
-	state_save_register_device_item(device, 0, ptm6840->t3_scaler);
-	state_save_register_device_item(device, 0, ptm6840->internal_clock);
-	state_save_register_device_item(device, 0, ptm6840->IRQ);
-
-	state_save_register_device_item_array(device, 0, ptm6840->control_reg);
-	state_save_register_device_item_array(device, 0, ptm6840->output);
-	state_save_register_device_item_array(device, 0, ptm6840->gate);
-	state_save_register_device_item_array(device, 0, ptm6840->clock);
-	state_save_register_device_item_array(device, 0, ptm6840->mode);
-	state_save_register_device_item_array(device, 0, ptm6840->fired);
-	state_save_register_device_item_array(device, 0, ptm6840->enabled);
-	state_save_register_device_item_array(device, 0, ptm6840->external_clock);
-	state_save_register_device_item_array(device, 0, ptm6840->counter);
-	state_save_register_device_item_array(device, 0, ptm6840->latch);
+	return m_external_clock[counter];
 }
-
-/*-------------------------------------------------
-    DEVICE_RESET( ptm6840 )
--------------------------------------------------*/
-
-static DEVICE_RESET( ptm6840 )
-{
-	ptm6840_state *ptm6840 = get_safe_token(device);
-	int i;
-
-	ptm6840->control_reg[2]		 = 0;
-	ptm6840->control_reg[1]		 = 0;
-	ptm6840->control_reg[0]		 = 1;
-	ptm6840->status_reg			 = 0;
-	ptm6840->t3_divisor			 = 1;
-	ptm6840->status_read_since_int = 0;
-	ptm6840->IRQ                   = 0;
-
-	for (i = 0; i < 3; i++)
-	{
-		ptm6840->counter[i] = 0xffff;
-		ptm6840->latch[i]   = 0xffff;
-		ptm6840->output[i]  = 0;
-		ptm6840->fired[i]   = 0;
-	}
-}
-
-/*-------------------------------------------------
-    device definition
--------------------------------------------------*/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID(p,s)		p##ptm6840##s
-#define DEVTEMPLATE_FEATURES	DT_HAS_START | DT_HAS_RESET
-#define DEVTEMPLATE_NAME		"6840 PTM"
-#include "devtempl.h"
-
-DEFINE_LEGACY_DEVICE(PTM6840, ptm6840);
diff -Nru src-old/emu/machine/6840ptm.h src/emu/machine/6840ptm.h
--- src-old/emu/machine/6840ptm.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/6840ptm.h	2010-08-25 21:44:49.000000000 -0700
@@ -6,18 +6,19 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __6840PTM_H__
 #define __6840PTM_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
 
 
 /***************************************************************************
-    MACROS / CONSTANTS
+    DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(PTM6840, ptm6840);
-
 #define MDRV_PTM6840_ADD(_tag, _config) \
 	MDRV_DEVICE_ADD(_tag, PTM6840, 0) \
 	MDRV_DEVICE_CONFIG(_config)
@@ -27,18 +28,145 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
+// ======================> ptm6840_interface
+
+struct ptm6840_interface
+{
+	double m_internal_clock;
+	double m_external_clock[3];
+
+	devcb_write8 m_out_func[3];		// function to call when output[idx] changes
+	devcb_write_line m_irq_func;	// function called if IRQ line changes
+};
+
+
+
+// ======================> ptm6840_device_config
+
+class ptm6840_device_config : public device_config,
+                               public ptm6840_interface
+{
+    friend class ptm6840_device;
+
+    // construction/destruction
+    ptm6840_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 
-typedef struct _ptm6840_interface ptm6840_interface;
-struct _ptm6840_interface
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> ptm6840_device
+
+class ptm6840_device :  public device_t
 {
-	double internal_clock;
-	double external_clock[3];
+    friend class ptm6840_device_config;
+
+    // construction/destruction
+    ptm6840_device(running_machine &_machine, const ptm6840_device_config &_config);
+
+public:
 
-	devcb_write8 out_func[3];	// function to call when output[idx] changes
-	devcb_write_line irq_func;	// function called if IRQ line changes
+	int ptm6840_get_status(int clock);		// get whether timer is enabled
+	int ptm6840_get_irq();					// get IRQ state
+	UINT16 ptm6840_get_count(int counter);	// get counter value
+	void ptm6840_set_ext_clock(int counter, double clock);	// set clock frequency
+	int ptm6840_get_ext_clock(int counter);	// get clock frequency
+
+	void ptm6840_set_g1(UINT32 offset, UINT8 data);	// set gate1 state
+	void ptm6840_set_g2(UINT32 offset, UINT8 data);	// set gate2 state
+	void ptm6840_set_g3(UINT32 offset, UINT8 data);	// set gate3 state
+	void ptm6840_set_c1(UINT32 offset, UINT8 data);	// set clock1 state
+	void ptm6840_set_c2(UINT32 offset, UINT8 data);	// set clock2 state
+	void ptm6840_set_c3(UINT32 offset, UINT8 data);	// set clock3 state
+
+	void ptm6840_write(UINT32 offset, UINT8 data);
+	UINT8 ptm6840_read(UINT32 offset);
+
+	void ptm6840_set_gate(int state, int idx);
+	void ptm6840_set_clock(int state, int idx);
+
+	void update_interrupts();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( ptm6840_timer1_cb );
+	static TIMER_CALLBACK( ptm6840_timer2_cb );
+	static TIMER_CALLBACK( ptm6840_timer3_cb );
+
+private:
+
+	void subtract_from_counter(int counter, int count);
+	void ptm_tick(int counter, int count);
+
+	void ptm6840_timeout(int idx);
+
+	UINT16 compute_counter(int counter);
+	void reload_count(int idx);
+
+	enum
+	{
+		PTM_6840_CTRL1   = 0,
+		PTM_6840_CTRL2   = 1,
+		PTM_6840_STATUS  = 1,
+		PTM_6840_MSBBUF1 = 2,
+		PTM_6840_LSB1	 = 3,
+		PTM_6840_MSBBUF2 = 4,
+		PTM_6840_LSB2    = 5,
+		PTM_6840_MSBBUF3 = 6,
+		PTM_6840_LSB3    = 7,
+	};
+
+	double m_internal_clock;
+	double m_external_clock[3];
+
+	devcb_resolved_write8 m_out_func[3];	// function to call when output[idx] changes
+	devcb_resolved_write_line m_irq_func;	// function called if IRQ line changes
+
+	UINT8 m_control_reg[3];
+	UINT8 m_output[3]; /* Output states */
+	UINT8 m_gate[3];   /* Input gate states */
+	UINT8 m_clk[3];  /* Clock states */
+	UINT8 m_enabled[3];
+	UINT8 m_mode[3];
+	UINT8 m_fired[3];
+	UINT8 m_t3_divisor;
+	UINT8 m_t3_scaler;
+	UINT8 m_IRQ;
+	UINT8 m_status_reg;
+	UINT8 m_status_read_since_int;
+	UINT8 m_lsb_buffer;
+	UINT8 m_msb_buffer;
+
+	/* Each PTM has 3 timers */
+	emu_timer *m_timer[3];
+
+	UINT16 m_latch[3];
+	UINT16 m_counter[3];
+
+    const ptm6840_device_config &m_config;
+
+	static const char *const opmode[];
 };
 
 
+// device type definition
+extern const device_type PTM6840;
+
+
+
 /***************************************************************************
     PROTOTYPES
 ***************************************************************************/
diff -Nru src-old/emu/machine/6850acia.c src/emu/machine/6850acia.c
--- src-old/emu/machine/6850acia.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/6850acia.c	2010-08-28 09:48:51.000000000 -0700
@@ -8,6 +8,7 @@
 
 #include "emu.h"
 #include "6850acia.h"
+#include "devhelpr.h"
 
 
 /***************************************************************************
@@ -20,95 +21,18 @@
 #define CR7		0x80
 
 #define TXD(_data) \
-	devcb_call_write_line(&acia_p->out_tx_func, _data)
+	devcb_call_write_line(&m_out_tx_func, _data)
 
 #define RTS(_data) \
-	devcb_call_write_line(&acia_p->out_rts_func, _data)
-
-static void acia6850_check_interrupts(running_device *device);
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-enum serial_state
-{
-	START,
-	DATA,
-	PARITY,
-	STOP,
-	STOP2,
-};
-
-enum _parity_type
-{
-	NONE,
-	ODD,
-	EVEN
-};
-typedef enum _parity_type parity_type;
-
-typedef struct _acia6850_t acia6850_t;
-struct _acia6850_t
-{
-	devcb_resolved_read_line	in_rx_func;
-	devcb_resolved_write_line	out_tx_func;
-	devcb_resolved_read_line	in_cts_func;
-	devcb_resolved_write_line	out_rts_func;
-	devcb_resolved_read_line	in_dcd_func;
-	devcb_resolved_write_line	out_irq_func;
-
-	UINT8		ctrl;
-	UINT8		status;
-
-	UINT8		tdr;
-	UINT8		rdr;
-	UINT8		rx_shift;
-	UINT8		tx_shift;
-
-	UINT8		rx_counter;
-	UINT8		tx_counter;
-
-	int			rx_clock;
-	int			tx_clock;
-
-	int			divide;
-
-	/* Counters */
-	int			tx_bits;
-	int			rx_bits;
-	int			tx_parity;
-	int			rx_parity;
-
-	/* TX/RX state */
-	int			bits;
-	parity_type	parity;
-	int			stopbits;
-	int			tx_int;
-
-	/* Signals */
-	int			overrun;
-	int			reset;
-	int			rts;
-	int			brk;
-	int			first_reset;
-	int			status_read;
-	enum		serial_state rx_state;
-	enum		serial_state tx_state;
-	int			irq;
-
-	emu_timer	*rx_timer;
-	emu_timer	*tx_timer;
-};
-
+	devcb_call_write_line(&m_out_rts_func, _data)
 
 /***************************************************************************
     LOCAL VARIABLES
 ***************************************************************************/
 
-static const int ACIA6850_DIVIDE[3] = { 1, 16, 64 };
+const int acia6850_device::ACIA6850_DIVIDE[3] = { 1, 16, 64 };
 
-static const int ACIA6850_WORD[8][3] =
+const int acia6850_device::ACIA6850_WORD[8][3] =
 {
 	{ 7, EVEN, 2 },
 	{ 7, ODD,  2 },
@@ -121,153 +45,167 @@
 };
 
 
+
 /***************************************************************************
-    PROTOTYPES
+    LIVE DEVICE
 ***************************************************************************/
 
-static TIMER_CALLBACK( receive_event );
-static TIMER_CALLBACK( transmit_event );
+const device_type ACIA6850 = acia6850_device_config::static_alloc_device_config;
 
+GENERIC_DEVICE_CONFIG_SETUP(acia6850, "6850 ACIA")
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
 
-INLINE acia6850_t *get_token(running_device *device)
+void acia6850_device_config::device_config_complete()
 {
-	assert(device != NULL);
-	assert(device->type() == ACIA6850);
-	return (acia6850_t *) downcast<legacy_device_base *>(device)->token();
+	// inherit a copy of the static data
+	const acia6850_interface *intf = reinterpret_cast<const acia6850_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<acia6850_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_tx_clock = 0;
+		m_rx_clock = 0;
+    	memset(&m_in_rx_func, 0, sizeof(m_in_rx_func));
+    	memset(&m_out_tx_func, 0, sizeof(m_out_tx_func));
+    	memset(&m_in_cts_func, 0, sizeof(m_in_cts_func));
+    	memset(&m_out_rts_func, 0, sizeof(m_out_rts_func));
+    	memset(&m_in_dcd_func, 0, sizeof(m_in_dcd_func));
+    	memset(&m_out_irq_func, 0, sizeof(m_out_irq_func));
+	}
 }
 
 
-INLINE acia6850_interface *get_interface(running_device *device)
+//-------------------------------------------------
+//  acia6850_device - constructor
+//-------------------------------------------------
+
+acia6850_device::acia6850_device(running_machine &_machine, const acia6850_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert(device->type() == ACIA6850);
-	return (acia6850_interface *) device->baseconfig().static_config();
+
 }
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    DEVICE_RESET( acia6850 )
--------------------------------------------------*/
-
-static DEVICE_RESET( acia6850 )
+void acia6850_device::device_start()
 {
-	acia6850_t *acia_p = get_token(device);
+	/* resolve callbacks */
+	devcb_resolve_read_line(&m_in_rx_func, &m_config.m_in_rx_func, this);
+	devcb_resolve_write_line(&m_out_tx_func, &m_config.m_out_tx_func, this);
+	devcb_resolve_read_line(&m_in_cts_func, &m_config.m_in_cts_func, this);
+	devcb_resolve_write_line(&m_out_rts_func, &m_config.m_out_rts_func, this);
+	devcb_resolve_read_line(&m_in_dcd_func, &m_config.m_in_dcd_func, this);
+	devcb_resolve_write_line(&m_out_irq_func, &m_config.m_out_irq_func, this);
+
+	m_rx_clock = m_config.m_rx_clock;
+	m_tx_clock = m_config.m_tx_clock;
+	m_tx_counter = 0;
+	m_rx_counter = 0;
+	m_rx_timer = timer_alloc(&m_machine, receive_event_callback, (void *)this);
+	m_tx_timer = timer_alloc(&m_machine, transmit_event_callback, (void *)this);
+	m_first_reset = 1;
+	m_status_read = 0;
+	m_brk = 0;
+
+	timer_reset(m_rx_timer, attotime_never);
+	timer_reset(m_tx_timer, attotime_never);
+
+	state_save_register_device_item(this, 0, m_ctrl);
+	state_save_register_device_item(this, 0, m_status);
+	state_save_register_device_item(this, 0, m_rx_clock);
+	state_save_register_device_item(this, 0, m_tx_clock);
+	state_save_register_device_item(this, 0, m_rx_counter);
+	state_save_register_device_item(this, 0, m_tx_counter);
+	state_save_register_device_item(this, 0, m_rx_shift);
+	state_save_register_device_item(this, 0, m_tx_shift);
+	state_save_register_device_item(this, 0, m_rdr);
+	state_save_register_device_item(this, 0, m_tdr);
+	state_save_register_device_item(this, 0, m_rx_bits);
+	state_save_register_device_item(this, 0, m_tx_bits);
+	state_save_register_device_item(this, 0, m_rx_parity);
+	state_save_register_device_item(this, 0, m_tx_parity);
+	state_save_register_device_item(this, 0, m_tx_int);
+
+	state_save_register_device_item(this, 0, m_divide);
+	state_save_register_device_item(this, 0, m_overrun);
+	state_save_register_device_item(this, 0, m_reset);
+	state_save_register_device_item(this, 0, m_first_reset);
+	state_save_register_device_item(this, 0, m_rts);
+	state_save_register_device_item(this, 0, m_brk);
+	state_save_register_device_item(this, 0, m_status_read);
+}
 
-	int cts = devcb_call_read_line(&acia_p->in_cts_func);
-	int dcd = devcb_call_read_line(&acia_p->in_dcd_func);
 
-	acia_p->status = (cts << 3) | (dcd << 2) | ACIA6850_STATUS_TDRE;
-	acia_p->tdr = 0;
-	acia_p->rdr = 0;
-	acia_p->tx_shift = 0;
-	acia_p->rx_shift = 0;
-	acia_p->tx_counter = 0;
-	acia_p->rx_counter = 0;
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void acia6850_device::device_reset()
+{
+	int cts = devcb_call_read_line(&m_in_cts_func);
+	int dcd = devcb_call_read_line(&m_in_dcd_func);
+
+	m_status = (cts << 3) | (dcd << 2) | ACIA6850_STATUS_TDRE;
+	m_tdr = 0;
+	m_rdr = 0;
+	m_tx_shift = 0;
+	m_rx_shift = 0;
+	m_tx_counter = 0;
+	m_rx_counter = 0;
 
 	TXD(1);
-	acia_p->overrun = 0;
-	acia_p->status_read = 0;
-	acia_p->brk = 0;
+	m_overrun = 0;
+	m_status_read = 0;
+	m_brk = 0;
 
-	acia_p->rx_state = START;
-	acia_p->tx_state = START;
-	acia_p->irq = 0;
+	m_rx_state = START;
+	m_tx_state = START;
+	m_irq = 0;
 
-	devcb_call_write_line(&acia_p->out_irq_func, 1);
+	devcb_call_write_line(&m_out_irq_func, 1);
 
-	if (acia_p->first_reset)
+	if (m_first_reset)
 	{
-		acia_p->first_reset = 0;
+		m_first_reset = 0;
 
 		RTS(1);
 	}
 	else
 	{
-		RTS(acia_p->rts);
+		RTS(m_rts);
 	}
 }
 
 
 
 /*-------------------------------------------------
-    DEVICE_START( acia6850 )
--------------------------------------------------*/
-
-static DEVICE_START( acia6850 )
-{
-	acia6850_t *acia_p = get_token(device);
-	acia6850_interface *intf = get_interface(device);
-
-	/* resolve callbacks */
-	devcb_resolve_read_line(&acia_p->in_rx_func, &intf->in_rx_func, device);
-	devcb_resolve_write_line(&acia_p->out_tx_func, &intf->out_tx_func, device);
-	devcb_resolve_read_line(&acia_p->in_cts_func, &intf->in_cts_func, device);
-	devcb_resolve_write_line(&acia_p->out_rts_func, &intf->out_rts_func, device);
-	devcb_resolve_read_line(&acia_p->in_dcd_func, &intf->in_dcd_func, device);
-	devcb_resolve_write_line(&acia_p->out_irq_func, &intf->out_irq_func, device);
-
-	acia_p->rx_clock = intf->rx_clock;
-	acia_p->tx_clock = intf->tx_clock;
-	acia_p->tx_counter = 0;
-	acia_p->rx_counter = 0;
-	acia_p->rx_timer = timer_alloc(device->machine, receive_event, (void *) device);
-	acia_p->tx_timer = timer_alloc(device->machine, transmit_event, (void *) device);
-	acia_p->first_reset = 1;
-	acia_p->status_read = 0;
-	acia_p->brk = 0;
-
-	timer_reset(acia_p->rx_timer, attotime_never);
-	timer_reset(acia_p->tx_timer, attotime_never);
-
-	state_save_register_device_item(device, 0, acia_p->ctrl);
-	state_save_register_device_item(device, 0, acia_p->status);
-	state_save_register_device_item(device, 0, acia_p->rx_clock);
-	state_save_register_device_item(device, 0, acia_p->tx_clock);
-	state_save_register_device_item(device, 0, acia_p->rx_counter);
-	state_save_register_device_item(device, 0, acia_p->tx_counter);
-	state_save_register_device_item(device, 0, acia_p->rx_shift);
-	state_save_register_device_item(device, 0, acia_p->tx_shift);
-	state_save_register_device_item(device, 0, acia_p->rdr);
-	state_save_register_device_item(device, 0, acia_p->tdr);
-	state_save_register_device_item(device, 0, acia_p->rx_bits);
-	state_save_register_device_item(device, 0, acia_p->tx_bits);
-	state_save_register_device_item(device, 0, acia_p->rx_parity);
-	state_save_register_device_item(device, 0, acia_p->tx_parity);
-	state_save_register_device_item(device, 0, acia_p->tx_int);
-
-	state_save_register_device_item(device, 0, acia_p->divide);
-	state_save_register_device_item(device, 0, acia_p->overrun);
-	state_save_register_device_item(device, 0, acia_p->reset);
-	state_save_register_device_item(device, 0, acia_p->first_reset);
-	state_save_register_device_item(device, 0, acia_p->rts);
-	state_save_register_device_item(device, 0, acia_p->brk);
-	state_save_register_device_item(device, 0, acia_p->status_read);
-}
-
-
-/*-------------------------------------------------
     acia6850_stat_r - Read Status Register
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( acia6850_stat_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(acia6850, acia6850_stat_r)
 {
 	UINT8 status;
 
-	acia6850_t *acia_p = get_token(device);
-
-	acia_p->status_read = 1;
-	status = acia_p->status;
+	m_status_read = 1;
+	status = m_status;
 
 	if (status & ACIA6850_STATUS_CTS)
+	{
 		status &= ~ACIA6850_STATUS_TDRE;
+	}
 
 	return status;
 }
@@ -277,10 +215,8 @@
     acia6850_ctrl_w - Write Control Register
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( acia6850_ctrl_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(acia6850, acia6850_ctrl_w )
 {
-	acia6850_t *acia_p = get_token(device);
-
 	int wordsel;
 	int divide;
 
@@ -290,109 +226,107 @@
 
 	if (divide == 3)
 	{
-		acia_p->reset = 1;
-		device->reset();
+		m_reset = 1;
+		device_reset();
 	}
 	else
 	{
-		acia_p->reset = 0;
-		acia_p->divide = ACIA6850_DIVIDE[divide];
+		m_reset = 0;
+		m_divide = ACIA6850_DIVIDE[divide];
 	}
 
 	// Word Select Bits
 
 	wordsel = (data & CR4_2) >> 2;
 
-	acia_p->bits = ACIA6850_WORD[wordsel][0];
-	acia_p->parity = (parity_type)ACIA6850_WORD[wordsel][1];
-	acia_p->stopbits = ACIA6850_WORD[wordsel][2];
+	m_bits = ACIA6850_WORD[wordsel][0];
+	m_parity = (parity_type)ACIA6850_WORD[wordsel][1];
+	m_stopbits = ACIA6850_WORD[wordsel][2];
 
 	// Transmitter Control Bits
 
 	switch ((data & CR6_5) >> 5)
 	{
 	case 0:
-		acia_p->rts = 0;
-		RTS(acia_p->rts);
+		m_rts = 0;
+		RTS(m_rts);
 
-		acia_p->tx_int = 0;
-		acia_p->brk = 0;
+		m_tx_int = 0;
+		m_brk = 0;
 		break;
 
 	case 1:
-		acia_p->rts = 0;
-		RTS(acia_p->rts);
+		m_rts = 0;
+		RTS(m_rts);
 
-		acia_p->tx_int = 1;
-		acia_p->brk = 0;
+		m_tx_int = 1;
+		m_brk = 0;
 		break;
 
 	case 2:
-		acia_p->rts = 1;
-		RTS(acia_p->rts);
+		m_rts = 1;
+		RTS(m_rts);
 
-		acia_p->tx_int = 0;
-		acia_p->brk = 0;
+		m_tx_int = 0;
+		m_brk = 0;
 		break;
 
 	case 3:
-		acia_p->rts = 0;
-		RTS(acia_p->rts);
+		m_rts = 0;
+		RTS(m_rts);
 
-		acia_p->tx_int = 0;
-		acia_p->brk = 1;
+		m_tx_int = 0;
+		m_brk = 1;
 		break;
 	}
 
-	acia6850_check_interrupts(device);
+	check_interrupts();
 
 	// After writing the word type, set the rx/tx clocks (provided the divide values have changed)
 
-	if ((acia_p->ctrl ^ data) & CR1_0)
+	if ((m_ctrl ^ data) & CR1_0)
 	{
-		if (!acia_p->reset)
+		if (!m_reset)
 		{
-			if (acia_p->rx_clock)
+			if (m_rx_clock)
 			{
-				attotime rx_period = attotime_mul(ATTOTIME_IN_HZ(acia_p->rx_clock), acia_p->divide);
-				timer_adjust_periodic(acia_p->rx_timer, rx_period, 0, rx_period);
+				attotime rx_period = attotime_mul(ATTOTIME_IN_HZ(m_rx_clock), m_divide);
+				timer_adjust_periodic(m_rx_timer, rx_period, 0, rx_period);
 			}
 
-			if (acia_p->tx_clock)
+			if (m_tx_clock)
 			{
-				attotime tx_period = attotime_mul(ATTOTIME_IN_HZ(acia_p->tx_clock), acia_p->divide);
-				timer_adjust_periodic(acia_p->tx_timer, tx_period, 0, tx_period);
+				attotime tx_period = attotime_mul(ATTOTIME_IN_HZ(m_tx_clock), m_divide);
+				timer_adjust_periodic(m_tx_timer, tx_period, 0, tx_period);
 			}
 		}
 	}
-	acia_p->ctrl = data;
+	m_ctrl = data;
 }
 
 
 /*-------------------------------------------------
-    acia6850_check_interrupts
+    check_interrupts
 -------------------------------------------------*/
 
-static void acia6850_check_interrupts(running_device *device)
+void acia6850_device::check_interrupts()
 {
-	acia6850_t *acia_p = get_token(device);
-
-	int irq = (acia_p->tx_int && (acia_p->status & ACIA6850_STATUS_TDRE) && (~acia_p->status & ACIA6850_STATUS_CTS)) ||
-		((acia_p->ctrl & 0x80) && ((acia_p->status & (ACIA6850_STATUS_RDRF|ACIA6850_STATUS_DCD)) || acia_p->overrun));
+	int irq = (m_tx_int && (m_status & ACIA6850_STATUS_TDRE) && (~m_status & ACIA6850_STATUS_CTS)) ||
+		((m_ctrl & 0x80) && ((m_status & (ACIA6850_STATUS_RDRF|ACIA6850_STATUS_DCD)) || m_overrun));
 
-	if (irq != acia_p->irq)
+	if (irq != m_irq)
 	{
-		acia_p->irq = irq;
+		m_irq = irq;
 
 		if (irq)
 		{
-			acia_p->status |= ACIA6850_STATUS_IRQ;
-			devcb_call_write_line(&acia_p->out_irq_func, 0);
+			m_status |= ACIA6850_STATUS_IRQ;
+			devcb_call_write_line(&m_out_irq_func, 0);
 		}
 		else
 		{
-			acia_p->status &= ~ACIA6850_STATUS_IRQ;
-			devcb_call_write_line(&acia_p->out_irq_func, 1);
+			m_status &= ~ACIA6850_STATUS_IRQ;
+			devcb_call_write_line(&m_out_irq_func, 1);
 		}
 	}
 }
@@ -402,19 +336,17 @@
     acia6850_data_w - Write transmit register
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( acia6850_data_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(acia6850, acia6850_data_w)
 {
-	acia6850_t *acia_p = get_token(device);
-
-	if (!acia_p->reset)
+	if (!m_reset)
 	{
-		acia_p->tdr = data;
-		acia_p->status &= ~ACIA6850_STATUS_TDRE;
-		acia6850_check_interrupts(device);
+		m_tdr = data;
+		m_status &= ~ACIA6850_STATUS_TDRE;
+		check_interrupts();
 	}
 	else
 	{
-		logerror("%s:ACIA %p: Data write while in reset!\n", cpuexec_describe_context(device->machine), device);
+		logerror("%s:ACIA %p: Data write while in reset!\n", cpuexec_describe_context(&m_machine), this);
 	}
 }
 
@@ -423,34 +355,32 @@
     acia6850_data_r - Read character
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( acia6850_data_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(acia6850, acia6850_data_r)
 {
-	acia6850_t *acia_p = get_token(device);
+	m_status &= ~(ACIA6850_STATUS_RDRF | ACIA6850_STATUS_IRQ | ACIA6850_STATUS_PE);
 
-	acia_p->status &= ~(ACIA6850_STATUS_RDRF | ACIA6850_STATUS_IRQ | ACIA6850_STATUS_PE);
-
-	if (acia_p->status_read)
+	if (m_status_read)
 	{
-		int dcd = devcb_call_read_line(&acia_p->in_dcd_func);
+		int dcd = devcb_call_read_line(&m_in_dcd_func);
 
-		acia_p->status_read = 0;
-		acia_p->status &= ~(ACIA6850_STATUS_OVRN | ACIA6850_STATUS_DCD);
+		m_status_read = 0;
+		m_status &= ~(ACIA6850_STATUS_OVRN | ACIA6850_STATUS_DCD);
 
 		if (dcd)
 		{
-			acia_p->status |= ACIA6850_STATUS_DCD;
+			m_status |= ACIA6850_STATUS_DCD;
 		}
 	}
 
-	if (acia_p->overrun == 1)
+	if (m_overrun == 1)
 	{
-		acia_p->status |= ACIA6850_STATUS_OVRN;
-		acia_p->overrun = 0;
+		m_status |= ACIA6850_STATUS_OVRN;
+		m_overrun = 0;
 	}
 
-	acia6850_check_interrupts(device);
+	check_interrupts();
 
-	return acia_p->rdr;
+	return m_rdr;
 }
 
 
@@ -458,15 +388,13 @@
     tx_tick - Transmit a bit
 -------------------------------------------------*/
 
-static void tx_tick(running_device *device)
+void acia6850_device::tx_tick()
 {
-	acia6850_t *acia_p = get_token(device);
-
-	switch (acia_p->tx_state)
+	switch (m_tx_state)
 	{
 		case START:
 		{
-			if (acia_p->brk)
+			if (m_brk)
 			{
 				// transmit break
 
@@ -474,16 +402,20 @@
 			}
 			else
 			{
-				int _cts = devcb_call_read_line(&acia_p->in_cts_func);
+				int _cts = devcb_call_read_line(&m_in_cts_func);
 
 				if (_cts)
-					acia_p->status |= ACIA6850_STATUS_CTS;
+				{
+					m_status |= ACIA6850_STATUS_CTS;
+				}
 				else
-					acia_p->status &= ~ACIA6850_STATUS_CTS;
+				{
+					m_status &= ~ACIA6850_STATUS_CTS;
+				}
 
-				acia6850_check_interrupts(device);
+				check_interrupts();
 
-				if (acia_p->status & ACIA6850_STATUS_TDRE)
+				if (m_status & ACIA6850_STATUS_TDRE)
 				{
 					// transmitter idle
 					TXD(1);
@@ -492,42 +424,48 @@
 				{
 					// transmit character
 
-					//logerror("ACIA6850 #%u: TX DATA %x\n", which, acia_p->tdr);
+					//logerror("ACIA6850 #%u: TX DATA %x\n", which, m_tdr);
 					//logerror("ACIA6850 #%u: TX START BIT\n", which);
 
 					TXD(0);
 
-					acia_p->tx_bits = acia_p->bits;
-					acia_p->tx_shift = acia_p->tdr;
-					acia_p->tx_parity = 0;
-					acia_p->tx_state = DATA;
+					m_tx_bits = m_bits;
+					m_tx_shift = m_tdr;
+					m_tx_parity = 0;
+					m_tx_state = DATA;
 				}
 			}
 			break;
 		}
 		case DATA:
 		{
-			int val = acia_p->tx_shift & 1;
+			int val = m_tx_shift & 1;
 			//logerror("ACIA6850 #%u: TX DATA BIT %x\n", which, val);
 
 			TXD(val);
-			acia_p->tx_parity ^= val;
-			acia_p->tx_shift >>= 1;
+			m_tx_parity ^= val;
+			m_tx_shift >>= 1;
 
-			if (--(acia_p->tx_bits) == 0)
-				acia_p->tx_state = (acia_p->parity == NONE) ? STOP : PARITY;
+			if (--(m_tx_bits) == 0)
+			{
+				m_tx_state = (m_parity == NONE) ? STOP : PARITY;
+			}
 
 			break;
 		}
 		case PARITY:
 		{
-			if (acia_p->parity == EVEN)
-				TXD((acia_p->tx_parity & 1) ? 1 : 0);
+			if (m_parity == EVEN)
+			{
+				TXD((m_tx_parity & 1) ? 1 : 0);
+			}
 			else
-				TXD((acia_p->tx_parity & 1) ? 0 : 1);
+			{
+				TXD((m_tx_parity & 1) ? 0 : 1);
+			}
 
-			//logerror("ACIA6850 #%u: TX PARITY BIT %x\n", which, *acia_p->tx_pin);
-			acia_p->tx_state = STOP;
+			//logerror("ACIA6850 #%u: TX PARITY BIT %x\n", which, *m_tx_pin);
+			m_tx_state = STOP;
 			break;
 		}
 		case STOP:
@@ -535,14 +473,14 @@
 			//logerror("ACIA6850 #%u: TX STOP BIT\n", which);
 			TXD(1);
 
-			if (acia_p->stopbits == 1)
+			if (m_stopbits == 1)
 			{
-				acia_p->tx_state = START;
-				acia_p->status |= ACIA6850_STATUS_TDRE;
+				m_tx_state = START;
+				m_status |= ACIA6850_STATUS_TDRE;
 			}
 			else
 			{
-				acia_p->tx_state = STOP2;
+				m_tx_state = STOP2;
 			}
 			break;
 		}
@@ -550,8 +488,8 @@
 		{
 			//logerror("ACIA6850 #%u: TX STOP BIT\n", which);
 			TXD(1);
-			acia_p->tx_state = START;
-			acia_p->status |= ACIA6850_STATUS_TDRE;
+			m_tx_state = START;
+			m_status |= ACIA6850_STATUS_TDRE;
 			break;
 		}
 	}
@@ -559,39 +497,43 @@
 
 
 /*-------------------------------------------------
-    TIMER_CALLBACK( transmit_event )
+    transmit_event
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( transmit_event )
+TIMER_CALLBACK( acia6850_device::transmit_event_callback ) { reinterpret_cast<acia6850_device *>(ptr)->transmit_event(); }
+
+void acia6850_device::transmit_event()
 {
-	running_device *device = (running_device *)ptr;
-	acia6850_t *acia_p = get_token(device);
-	tx_tick(device);
-	acia_p->tx_counter = 0;
+	tx_tick();
+	m_tx_counter = 0;
 }
 
 
 /*-------------------------------------------------
-    acia6850_tx_clock_in - As above, but using the tx pin
+    tx_clock_in - As above, but using the tx pin
 -------------------------------------------------*/
 
-void acia6850_tx_clock_in(running_device *device)
-{
-	acia6850_t *acia_p = get_token(device);
+void acia6850_tx_clock_in(running_device *device) { downcast<acia6850_device*>(device)->tx_clock_in(); }
 
-	int _cts = devcb_call_read_line(&acia_p->in_cts_func);
+void acia6850_device::tx_clock_in()
+{
+	int _cts = devcb_call_read_line(&m_in_cts_func);
 
 	if (_cts)
-		acia_p->status |= ACIA6850_STATUS_CTS;
+	{
+		m_status |= ACIA6850_STATUS_CTS;
+	}
 	else
-		acia_p->status &= ~ACIA6850_STATUS_CTS;
+	{
+		m_status &= ~ACIA6850_STATUS_CTS;
+	}
 
-	acia_p->tx_counter ++;
+	m_tx_counter ++;
 
-	if ( acia_p->tx_counter > acia_p->divide-1)
+	if ( m_tx_counter > m_divide - 1)
 	{
-		tx_tick(device);
-		acia_p->tx_counter = 0;
+		tx_tick();
+		m_tx_counter = 0;
 	}
 
 }
@@ -601,87 +543,85 @@
     rx_tick - Receive a bit
 -------------------------------------------------*/
 
-static void rx_tick(running_device *device)
+void acia6850_device::rx_tick()
 {
-	acia6850_t *acia_p = get_token(device);
-
-	int dcd = devcb_call_read_line(&acia_p->in_dcd_func);
+	int dcd = devcb_call_read_line(&m_in_dcd_func);
 
 	if (dcd)
 	{
-		acia_p->status |= ACIA6850_STATUS_DCD;
-		acia6850_check_interrupts(device);
+		m_status |= ACIA6850_STATUS_DCD;
+		check_interrupts();
 	}
-	else if ((acia_p->status & (ACIA6850_STATUS_DCD|ACIA6850_STATUS_IRQ)) == ACIA6850_STATUS_DCD)
+	else if ((m_status & (ACIA6850_STATUS_DCD | ACIA6850_STATUS_IRQ)) == ACIA6850_STATUS_DCD)
 	{
-		acia_p->status &= ~ACIA6850_STATUS_DCD;
+		m_status &= ~ACIA6850_STATUS_DCD;
 	}
 
-	if (acia_p->status & ACIA6850_STATUS_DCD)
+	if (m_status & ACIA6850_STATUS_DCD)
 	{
-		acia_p->rx_state = START;
+		m_rx_state = START;
 	}
 	else
 	{
-		int rxd = devcb_call_read_line(&acia_p->in_rx_func);
+		int rxd = devcb_call_read_line(&m_in_rx_func);
 
-		switch (acia_p->rx_state)
+		switch (m_rx_state)
 		{
 			case START:
 			{
 				if (rxd == 0)
 				{
 					//logerror("ACIA6850 #%u: RX START BIT\n", which);
-					acia_p->rx_shift = 0;
-					acia_p->rx_parity = 0;
-					acia_p->rx_bits = acia_p->bits;
-					acia_p->rx_state = DATA;
+					m_rx_shift = 0;
+					m_rx_parity = 0;
+					m_rx_bits = m_bits;
+					m_rx_state = DATA;
 				}
 				break;
 			}
 			case DATA:
 			{
 				//logerror("ACIA6850 #%u: RX DATA BIT %x\n", which, rxd);
-				acia_p->rx_shift |= rxd ? 0x80 : 0;
-				acia_p->rx_parity ^= rxd;
+				m_rx_shift |= rxd ? 0x80 : 0;
+				m_rx_parity ^= rxd;
 
-				if (--acia_p->rx_bits == 0)
+				if (--m_rx_bits == 0)
 				{
-					if (acia_p->status & ACIA6850_STATUS_RDRF)
+					if (m_status & ACIA6850_STATUS_RDRF)
 					{
-						acia_p->overrun = 1;
-						acia6850_check_interrupts(device);
+						m_overrun = 1;
+						check_interrupts();
 					}
 
-					acia_p->rx_state = acia_p->parity == NONE ? STOP : PARITY;
+					m_rx_state = m_parity == NONE ? STOP : PARITY;
 				}
 				else
 				{
-					acia_p->rx_shift >>= 1;
+					m_rx_shift >>= 1;
 				}
 				break;
 			}
 			case PARITY:
 			{
 				//logerror("ACIA6850 #%u: RX PARITY BIT %x\n", which, rxd);
-				acia_p->rx_parity ^= rxd;
+				m_rx_parity ^= rxd;
 
-				if (acia_p->parity == EVEN)
+				if (m_parity == EVEN)
 				{
-					if (acia_p->rx_parity)
+					if (m_rx_parity)
 					{
-						acia_p->status |= ACIA6850_STATUS_PE;
+						m_status |= ACIA6850_STATUS_PE;
 					}
 				}
 				else
 				{
-					if (!acia_p->rx_parity)
+					if (!m_rx_parity)
 					{
-						acia_p->status |= ACIA6850_STATUS_PE;
+						m_status |= ACIA6850_STATUS_PE;
 					}
 				}
 
-				acia_p->rx_state = STOP;
+				m_rx_state = STOP;
 				break;
 			}
 			case STOP:
@@ -689,29 +629,29 @@
 				if (rxd == 1)
 				{
 					//logerror("ACIA6850 #%u: RX STOP BIT\n", which);
-					if (acia_p->stopbits == 1)
+					if (m_stopbits == 1)
 					{
-						acia_p->status &= ~ACIA6850_STATUS_FE;
+						m_status &= ~ACIA6850_STATUS_FE;
 
-						if (!(acia_p->status & ACIA6850_STATUS_RDRF))
+						if (!(m_status & ACIA6850_STATUS_RDRF))
 						{
-							//logerror("ACIA6850 #%u: RX DATA %x\n", which, acia_p->rx_shift);
-							acia_p->rdr = acia_p->rx_shift;
-							acia_p->status |= ACIA6850_STATUS_RDRF;
-							acia6850_check_interrupts(device);
+							//logerror("ACIA6850 #%u: RX DATA %x\n", which, m_rx_shift);
+							m_rdr = m_rx_shift;
+							m_status |= ACIA6850_STATUS_RDRF;
+							check_interrupts();
 						}
 
-						acia_p->rx_state = START;
+						m_rx_state = START;
 					}
 					else
 					{
-						acia_p->rx_state = STOP2;
+						m_rx_state = STOP2;
 					}
 				}
 				else
 				{
-					acia_p->status |= ACIA6850_STATUS_FE;
-					acia_p->rx_state = START;
+					m_status |= ACIA6850_STATUS_FE;
+					m_rx_state = START;
 				}
 				break;
 			}
@@ -720,22 +660,22 @@
 				if (rxd == 1)
 				{
 					//logerror("ACIA6850 #%u: RX STOP BIT\n", which);
-					acia_p->status &= ~ACIA6850_STATUS_FE;
+					m_status &= ~ACIA6850_STATUS_FE;
 
-					if (!(acia_p->status & ACIA6850_STATUS_RDRF))
+					if (!(m_status & ACIA6850_STATUS_RDRF))
 					{
-						//logerror("ACIA6850 #%u: RX DATA %x\n", which, acia_p->rx_shift);
-						acia_p->rdr = acia_p->rx_shift;
-						acia_p->status |= ACIA6850_STATUS_RDRF;
-						acia6850_check_interrupts(device);
+						//logerror("ACIA6850 #%u: RX DATA %x\n", which, m_rx_shift);
+						m_rdr = m_rx_shift;
+						m_status |= ACIA6850_STATUS_RDRF;
+						check_interrupts();
 					}
 
-					acia_p->rx_state = START;
+					m_rx_state = START;
 				}
 				else
 				{
-					acia_p->status |= ACIA6850_STATUS_FE;
-					acia_p->rx_state = START;
+					m_status |= ACIA6850_STATUS_FE;
+					m_rx_state = START;
 				}
 				break;
 			}
@@ -745,45 +685,45 @@
 
 
 /*-------------------------------------------------
-    TIMER_CALLBACK( receive_event ) - Called on
-    receive timer event
+    TIMER_CALLBACK( receive_event_callback ) -
+    Called on receive timer event
 -------------------------------------------------*/
 
-static TIMER_CALLBACK( receive_event )
+TIMER_CALLBACK( acia6850_device::receive_event_callback ) { reinterpret_cast<acia6850_device *>(ptr)->receive_event(); }
+
+void acia6850_device::receive_event()
 {
-	running_device *device = (running_device *)ptr;
-	acia6850_t *acia_p = get_token(device);
-	rx_tick(device);
-	acia_p->rx_counter = 0;
+	rx_tick();
+	m_rx_counter = 0;
 }
 
 
 /*-------------------------------------------------
-    acia6850_rx_clock_in - As above, but using the rx pin
+    rx_clock_in - As above, but using the rx pin
 -------------------------------------------------*/
 
-void acia6850_rx_clock_in(running_device *device)
-{
-	acia6850_t *acia_p = get_token(device);
+void acia6850_rx_clock_in(running_device *device) { downcast<acia6850_device*>(device)->rx_clock_in(); }
 
-	int dcd = devcb_call_read_line(&acia_p->in_dcd_func);
+void acia6850_device::rx_clock_in()
+{
+	int dcd = devcb_call_read_line(&m_in_dcd_func);
 
 	if (dcd)
 	{
-		acia_p->status |= ACIA6850_STATUS_DCD;
-		acia6850_check_interrupts(device);
+		m_status |= ACIA6850_STATUS_DCD;
+		check_interrupts();
 	}
-	else if ((acia_p->status & (ACIA6850_STATUS_DCD|ACIA6850_STATUS_IRQ)) == ACIA6850_STATUS_DCD)
+	else if ((m_status & (ACIA6850_STATUS_DCD|ACIA6850_STATUS_IRQ)) == ACIA6850_STATUS_DCD)
 	{
-		acia_p->status &= ~ACIA6850_STATUS_DCD;
+		m_status &= ~ACIA6850_STATUS_DCD;
 	}
 
-	acia_p->rx_counter ++;
+	m_rx_counter ++;
 
-	if ( acia_p->rx_counter > acia_p->divide-1)
+	if ( m_rx_counter > m_divide - 1)
 	{
-		rx_tick(device);
-		acia_p->rx_counter = 0;
+		rx_tick();
+		m_rx_counter = 0;
 	}
 }
 
@@ -795,8 +735,7 @@
 
 void acia6850_set_rx_clock(running_device *device, int clock)
 {
-	acia6850_t *acia_p = get_token(device);
-	acia_p->rx_clock = clock;
+	downcast<acia6850_device*>(device)->set_rx_clock(clock);
 }
 
 
@@ -807,35 +746,5 @@
 
 void acia6850_set_tx_clock(running_device *device, int clock)
 {
-	acia6850_t *acia_p = get_token(device);
-	acia_p->tx_clock = clock;
-}
-
-
-/*-------------------------------------------------
-    DEVICE_GET_INFO( acia6850 )
--------------------------------------------------*/
-
-DEVICE_GET_INFO( acia6850 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(acia6850_t);					break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;									break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(acia6850);		break;
-		case DEVINFO_FCT_STOP:							/* Nothing */									break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(acia6850);		break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "6850 ACIA");					break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "6850 ACIA");					break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");							break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);						break;
-		case DEVINFO_STR_CREDITS:						/* Nothing */									break;
-	}
+	downcast<acia6850_device*>(device)->set_tx_clock(clock);
 }
-
-DEFINE_LEGACY_DEVICE(ACIA6850, acia6850);
diff -Nru src-old/emu/machine/6850acia.h src/emu/machine/6850acia.h
--- src-old/emu/machine/6850acia.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/6850acia.h	2010-08-25 21:44:49.000000000 -0700
@@ -6,18 +6,19 @@
 
 *********************************************************************/
 
+#pragma once
+
 #ifndef __ACIA6850_H__
 #define __ACIA6850_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
 
 
 /***************************************************************************
-    MACROS
+    EXTERNAL MACROS
 ***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(ACIA6850, acia6850);
-
 #define ACIA6850_STATUS_RDRF	0x01
 #define ACIA6850_STATUS_TDRE	0x02
 #define ACIA6850_STATUS_DCD		0x04
@@ -27,6 +28,12 @@
 #define ACIA6850_STATUS_PE		0x40
 #define ACIA6850_STATUS_IRQ		0x80
 
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
 #define MDRV_ACIA6850_ADD(_tag, _config) \
 	MDRV_DEVICE_ADD(_tag, ACIA6850, 0) \
 	MDRV_DEVICE_CONFIG(_config)
@@ -39,25 +46,175 @@
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _acia6850_interface acia6850_interface;
-struct _acia6850_interface
+
+// ======================> acia6850_interface
+
+struct acia6850_interface
 {
-	int	tx_clock;
-	int	rx_clock;
+	int	m_tx_clock;
+	int	m_rx_clock;
 
-	devcb_read_line		in_rx_func;
-	devcb_write_line	out_tx_func;
+	devcb_read_line		m_in_rx_func;
+	devcb_write_line	m_out_tx_func;
 
-	devcb_read_line		in_cts_func;
-	devcb_write_line	out_rts_func;
-	devcb_read_line		in_dcd_func;
+	devcb_read_line		m_in_cts_func;
+	devcb_write_line	m_out_rts_func;
+	devcb_read_line		m_in_dcd_func;
 
-	devcb_write_line	out_irq_func;
+	devcb_write_line	m_out_irq_func;
 };
 
 
+
+// ======================> acia6850_device_config
+
+class acia6850_device_config : public device_config,
+                               public acia6850_interface
+{
+    friend class acia6850_device;
+
+    // construction/destruction
+    acia6850_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> acia6850_device
+
+class acia6850_device :  public device_t
+{
+    friend class acia6850_device_config;
+
+    // construction/destruction
+    acia6850_device(running_machine &_machine, const acia6850_device_config &_config);
+
+public:
+
+	void acia6850_tx_clock_in();
+	void acia6850_rx_clock_in();
+
+	void acia6850_set_rx_clock(int clock);
+	void acia6850_set_tx_clock(int clock);
+
+	void acia6850_ctrl_w(UINT32 offset, UINT8 data);
+	UINT8 acia6850_stat_r(UINT32 offset);
+	void acia6850_data_w(UINT32 offset, UINT8 data);
+	UINT8 acia6850_data_r(UINT32 offset);
+
+	void tx_clock_in();
+	void rx_clock_in();
+
+	void set_rx_clock(int clock) { m_rx_clock = clock; }
+	void set_tx_clock(int clock) { m_tx_clock = clock; }
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( transmit_event_callback );
+	static TIMER_CALLBACK( receive_event_callback );
+
+private:
+
+	void check_interrupts();
+
+	void tx_tick();
+	void transmit_event();
+
+	void rx_tick();
+	void receive_event();
+
+	enum serial_state
+	{
+		START,
+		DATA,
+		PARITY,
+		STOP,
+		STOP2,
+	};
+
+	enum parity_type
+	{
+		NONE,
+		ODD,
+		EVEN
+	};
+
+	devcb_resolved_read_line	m_in_rx_func;
+	devcb_resolved_write_line	m_out_tx_func;
+	devcb_resolved_read_line	m_in_cts_func;
+	devcb_resolved_write_line	m_out_rts_func;
+	devcb_resolved_read_line	m_in_dcd_func;
+	devcb_resolved_write_line	m_out_irq_func;
+
+	UINT8		m_ctrl;
+	UINT8		m_status;
+
+	UINT8		m_tdr;
+	UINT8		m_rdr;
+	UINT8		m_rx_shift;
+	UINT8		m_tx_shift;
+
+	UINT8		m_rx_counter;
+	UINT8		m_tx_counter;
+
+	int			m_rx_clock;
+	int			m_tx_clock;
+
+	int			m_divide;
+
+	/* Counters */
+	int			m_tx_bits;
+	int			m_rx_bits;
+	int			m_tx_parity;
+	int			m_rx_parity;
+
+	/* TX/RX state */
+	int			m_bits;
+	parity_type	m_parity;
+	int			m_stopbits;
+	int			m_tx_int;
+
+	/* Signals */
+	int			m_overrun;
+	int			m_reset;
+	int			m_rts;
+	int			m_brk;
+	int			m_first_reset;
+	int			m_status_read;
+	serial_state m_rx_state;
+	serial_state m_tx_state;
+	int			m_irq;
+
+	emu_timer	*m_rx_timer;
+	emu_timer	*m_tx_timer;
+
+    const acia6850_device_config &m_config;
+
+	static const int ACIA6850_DIVIDE[3];
+	static const int ACIA6850_WORD[8][3];
+};
+
+
+// device type definition
+extern const device_type ACIA6850;
+
+
+
 /***************************************************************************
-    FUNCTION PROTOTYPES
+    PROTOTYPES
 ***************************************************************************/
 
 void acia6850_tx_clock_in(running_device *device) ATTR_NONNULL(1);
diff -Nru src-old/emu/machine/74123.c src/emu/machine/74123.c
--- src-old/emu/machine/74123.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/74123.c	2010-08-30 08:20:58.000000000 -0700
@@ -14,48 +14,145 @@
 #define	LOG		(0)
 
 
-typedef struct _ttl74123_t ttl74123_t;
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-struct _ttl74123_t
+//-------------------------------------------------
+//  ttl74123_device_config - constructor
+//-------------------------------------------------
+
+ttl74123_device_config::ttl74123_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+	: device_config(mconfig, static_alloc_device_config, "TTL74123", tag, owner, clock)
+{
+}
+
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *ttl74123_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+	return global_alloc(ttl74123_device_config(mconfig, tag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *ttl74123_device_config::alloc_device(running_machine &machine) const
+{
+	return auto_alloc(&machine, ttl74123_device(machine, *this));
+}
+
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void ttl74123_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const ttl74123_interface *intf = reinterpret_cast<const ttl74123_interface *>(static_config());
+	if (intf != NULL)
+		*static_cast<ttl74123_interface *>(this) = *intf;
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_connection_type = TTL74123_NOT_GROUNDED_NO_DIODE;
+		m_res = 1.0;
+		m_cap = 1.0;
+		m_a = 0;
+		m_b = 0;
+		m_clear = 0;
+    	memset(&m_output_changed_cb, 0, sizeof(m_output_changed_cb));
+	}
+}
+
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  ttl74123_device - constructor
+//-------------------------------------------------
+
+ttl74123_device::ttl74123_device(running_machine &_machine, const ttl74123_device_config &config)
+	: device_t(_machine, config),
+	  m_config(config)
 {
-	const ttl74123_config *intf;
 
-	UINT8 a;			/* pin 1/9 */
-	UINT8 b;			/* pin 2/10 */
-	UINT8 clear;		/* pin 3/11 */
-	emu_timer *timer;
-};
+}
+
 
-/* ----------------------------------------------------------------------- */
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
 
-INLINE ttl74123_t *get_safe_token(running_device *device) {
-	assert( device != NULL );
-	assert( device->type() == TTL74123 );
-	return ( ttl74123_t * ) downcast<legacy_device_base *>(device)->token();
+void ttl74123_device::device_start()
+{
+	m_timer = timer_alloc(&m_machine, clear_callback, (void *)this);
+
+	/* start with the defaults */
+	m_a = m_config.m_a;
+	m_b = m_config.m_b;
+	m_clear = m_config.m_clear;
+
+	/* register for state saving */
+	state_save_register_device_item(this, 0, m_a);
+	state_save_register_device_item(this, 0, m_b);
+	state_save_register_device_item(this, 0, m_clear);
 }
 
 
-static attotime compute_duration(ttl74123_t *chip)
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ttl74123_device::device_reset()
+{
+	set_output();
+}
+
+
+
+//-------------------------------------------------
+//  compute_duration - compute timer duration
+//-------------------------------------------------
+
+attotime ttl74123_device::compute_duration()
 {
 	double duration;
 
-	switch (chip->intf->connection_type)
+	switch (m_config.m_connection_type)
 	{
 	case TTL74123_NOT_GROUNDED_NO_DIODE:
-		duration = 0.28 * chip->intf->res * chip->intf->cap * (1.0 + (700.0 / chip->intf->res));
+		duration = 0.28 * m_config.m_res * m_config.m_cap * (1.0 + (700.0 / m_config.m_res));
 		break;
 
 	case TTL74123_NOT_GROUNDED_DIODE:
-		duration = 0.25 * chip->intf->res * chip->intf->cap * (1.0 + (700.0 / chip->intf->res));
+		duration = 0.25 * m_config.m_res * m_config.m_cap * (1.0 + (700.0 / m_config.m_res));
 		break;
 
 	case TTL74123_GROUNDED:
 	default:
-		if (chip->intf->cap < CAP_U(0.1))
+		if (m_config.m_cap < CAP_U(0.1))
+		{
 			/* this is really a curve - a very flat one in the 0.1uF-.01uF range */
-			duration = 0.32 * chip->intf->res * chip->intf->cap;
+			duration = 0.32 * m_config.m_res * m_config.m_cap;
+		}
 		else
-			duration = 0.33 * chip->intf->res * chip->intf->cap;
+		{
+			duration = 0.33 * m_config.m_res * m_config.m_cap;
+		}
 		break;
 	}
 
@@ -63,179 +160,185 @@
 }
 
 
-static int timer_running(ttl74123_t *chip)
+//-------------------------------------------------
+//  timer_running - is the timer running?
+//-------------------------------------------------
+
+int ttl74123_device::timer_running()
 {
-	return (attotime_compare(timer_timeleft(chip->timer), attotime_zero) > 0) &&
-		   (attotime_compare(timer_timeleft(chip->timer), attotime_never) != 0);
+	return (attotime_compare(timer_timeleft(m_timer), attotime_zero) > 0) &&
+		   (attotime_compare(timer_timeleft(m_timer), attotime_never) != 0);
 }
 
 
-static TIMER_CALLBACK( output_callback )
+/*-------------------------------------------------
+    TIMER_CALLBACK( output_callback )
+-------------------------------------------------*/
+
+TIMER_CALLBACK( ttl74123_device::output_callback )
 {
-	running_device *device = (running_device *)ptr;
-	ttl74123_t *chip = get_safe_token(device);
+	ttl74123_device *dev = reinterpret_cast<ttl74123_device*>(ptr);
+	dev->output(param);
+}
 
-	chip->intf->output_changed_cb(device, 0, param);
+void ttl74123_device::output(INT32 param)
+{
+	m_config.m_output_changed_cb(this, 0, param);
 }
 
 
-static void set_output(running_device *device)
+//-------------------------------------------------
+//  set_output - set the output line state
+//-------------------------------------------------
+
+void ttl74123_device::set_output()
 {
-	ttl74123_t *chip = get_safe_token(device);
-	int output = timer_running(chip);
+	int output = timer_running();
 
-	timer_set( device->machine, attotime_zero, (void *) device, output, output_callback );
+	timer_set( &m_machine, attotime_zero, (void *)this, output, output_callback );
 
-	if (LOG) logerror("74123 %s:  Output: %d\n", device->tag(), output);
+	if (LOG) logerror("74123 %s:  Output: %d\n", tag(), output);
 }
 
 
-static TIMER_CALLBACK( clear_callback )
-{
-	running_device *device = (running_device *)ptr;
-	ttl74123_t *chip = get_safe_token(device);
-	int output = timer_running(chip);
+/*-------------------------------------------------
+    TIMER_CALLBACK( clear_callback )
+-------------------------------------------------*/
 
-	chip->intf->output_changed_cb(device, 0, output);
+TIMER_CALLBACK( ttl74123_device::clear_callback )
+{
+	ttl74123_device *dev = reinterpret_cast<ttl74123_device*>(ptr);
+	dev->clear();
 }
 
+void ttl74123_device::clear()
+{
+	int output = timer_running();
 
+	m_config.m_output_changed_cb(this, 0, output);
+}
 
 
-static void start_pulse(running_device *device)
-{
-	ttl74123_t *chip = get_safe_token(device);
+//-------------------------------------------------
+//  start_pulse - begin timing
+//-------------------------------------------------
 
-	attotime duration = compute_duration(chip);
+void ttl74123_device::start_pulse()
+{
+	attotime duration = compute_duration();
 
-	if (timer_running(chip))
+	if(timer_running())
 	{
 		/* retriggering, but not if we are called to quickly */
-		attotime delay_time = attotime_make(0, ATTOSECONDS_PER_SECOND * chip->intf->cap * 220);
+		attotime delay_time = attotime_make(0, ATTOSECONDS_PER_SECOND * m_config.m_cap * 220);
 
-		if (attotime_compare(timer_timeelapsed(chip->timer), delay_time) >= 0)
+		if(attotime_compare(timer_timeelapsed(m_timer), delay_time) >= 0)
 		{
-			timer_adjust_oneshot(chip->timer, duration, 0);
+			timer_adjust_oneshot(m_timer, duration, 0);
 
-			if (LOG) logerror("74123 %s:  Retriggering pulse.  Duration: %f\n", device->tag(), attotime_to_double(duration));
+			if (LOG) logerror("74123 %s:  Retriggering pulse.  Duration: %f\n", tag(), attotime_to_double(duration));
 		}
 		else
 		{
-			if (LOG) logerror("74123 %s:  Retriggering failed.\n", device->tag());
+			if (LOG) logerror("74123 %s:  Retriggering failed.\n", tag());
 		}
 	}
 	else
 	{
 		/* starting */
-		timer_adjust_oneshot(chip->timer, duration, 0);
+		timer_adjust_oneshot(m_timer, duration, 0);
 
-		set_output(device);
+		set_output();
 
-		if (LOG) logerror("74123 %s:  Starting pulse.  Duration: %f\n", device->tag(), attotime_to_double(duration));
+		if (LOG) logerror("74123 %s:  Starting pulse.  Duration: %f\n", tag(), attotime_to_double(duration));
 	}
 }
 
 
+//-------------------------------------------------
+//  a_w - write register a data
+//-------------------------------------------------
+
 WRITE8_DEVICE_HANDLER( ttl74123_a_w )
 {
-	ttl74123_t *chip = get_safe_token(device);
+	ttl74123_device *dev = downcast<ttl74123_device *>(device);
+	dev->a_w(data);
+}
 
+void ttl74123_device::a_w(UINT8 data)
+{
 	/* start/regtrigger pulse if B=HI and falling edge on A (while clear is HI) */
-	if (!data && chip->a && chip->b && chip->clear)
-		start_pulse(device);
+	if (!data && m_a && m_b && m_clear)
+	{
+		start_pulse();
+	}
 
-	chip->a = data;
+	m_a = data;
 }
 
 
+//-------------------------------------------------
+//  b_w - write register b data
+//-------------------------------------------------
+
 WRITE8_DEVICE_HANDLER( ttl74123_b_w )
 {
-	ttl74123_t *chip = get_safe_token(device);
+	ttl74123_device *dev = downcast<ttl74123_device *>(device);
+	dev->b_w(data);
+}
 
+void ttl74123_device::b_w(UINT8 data)
+{
 	/* start/regtrigger pulse if A=LO and rising edge on B (while clear is HI) */
-	if (data && !chip->b && !chip->a && chip->clear)
-		start_pulse(device);
+	if (data && !m_b && !m_a && m_clear)
+	{
+		start_pulse();
+	}
 
-	chip->b = data;
+	m_b = data;
 }
 
 
+//-------------------------------------------------
+//  clear_w - write register clear data
+//-------------------------------------------------
+
 WRITE8_DEVICE_HANDLER( ttl74123_clear_w )
 {
-	ttl74123_t *chip = get_safe_token(device);
+	ttl74123_device *dev = downcast<ttl74123_device *>(device);
+	dev->clear_w(data);
+}
 
+void ttl74123_device::clear_w(UINT8 data)
+{
 	/* start/regtrigger pulse if B=HI and A=LO and rising edge on clear */
-	if (data && !chip->a && chip->b && !chip->clear)
-		start_pulse(device);
-	else if (!data) 	/* clear the output  */
+	if (data && !m_a && m_b && !m_clear)
 	{
-		timer_adjust_oneshot(chip->timer, attotime_zero, 0);
-
-		if (LOG) logerror("74123 #%s:  Cleared\n", device->tag() );
+		start_pulse();
 	}
-	chip->clear = data;
-}
+	else if (!data)	 /* clear the output  */
+	{
+		timer_adjust_oneshot(m_timer, attotime_zero, 0);
 
-WRITE8_DEVICE_HANDLER( ttl74123_reset_w )
-{
-	set_output(device);
+		if (LOG) logerror("74123 #%s:  Cleared\n", tag() );
+	}
+	m_clear = data;
 }
 
-/* ----------------------------------------------------------------------- */
 
-/* device interface */
+//-------------------------------------------------
+//  reset_w - reset device
+//-------------------------------------------------
 
-static DEVICE_START( ttl74123 )
-{
-	ttl74123_t *chip = get_safe_token(device);
-
-	/* validate arguments */
-	chip->intf = (ttl74123_config *)device->baseconfig().static_config();
-
-	assert_always(chip->intf, "No interface specified");
-	assert_always((chip->intf->connection_type != TTL74123_GROUNDED) || (chip->intf->cap >= CAP_U(0.01)), "Only capacitors >= 0.01uF supported for GROUNDED type");
-	assert_always(chip->intf->cap >= CAP_P(1000), "Only capacitors >= 1000pF supported ");
-
-	chip->timer = timer_alloc(device->machine, clear_callback, (void *) device);
-
-	/* start with the defaults */
-	chip->a = chip->intf->a;
-    chip->b = chip->intf->b;
-	chip->clear = chip->intf->clear;
-
-	/* register for state saving */
-	state_save_register_device_item(device, 0, chip->a);
-	state_save_register_device_item(device, 0, chip->b);
-	state_save_register_device_item(device, 0, chip->clear);
-}
-
-
-static DEVICE_RESET( ttl74123 )
+WRITE8_DEVICE_HANDLER( ttl74123_reset_w )
 {
-	set_output(device);
+	ttl74123_device *dev = downcast<ttl74123_device *>(device);
+	dev->reset_w();
 }
 
-
-DEVICE_GET_INFO( ttl74123 )
+void ttl74123_device::reset_w()
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(ttl74123_t);						break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;										break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(ttl74123);			break;
-		case DEVINFO_FCT_STOP:							/* Nothing */										break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(ttl74123);			break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "74123");							break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "TTL");								break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");								break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);							break;
-		case DEVINFO_STR_CREDITS:						strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
+	set_output();
 }
 
-DEFINE_LEGACY_DEVICE(TTL74123, ttl74123);
+const device_type TTL74123 = ttl74123_device_config::static_alloc_device_config;
diff -Nru src-old/emu/machine/74123.h src/emu/machine/74123.h
--- src-old/emu/machine/74123.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/74123.h	2010-08-22 22:42:12.000000000 -0700
@@ -43,18 +43,23 @@
 
 *****************************************************************************/
 
-#ifndef TTL74123_H
-#define TTL74123_H
+#pragma once
 
-#include "devlegcy.h"
+#ifndef __TTL74123_H__
+#define __TTL74123_H__
 
-DECLARE_LEGACY_DEVICE(TTL74123, ttl74123);
+#include "emu.h"
+
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
 
 #define MDRV_TTL74123_ADD(_tag, _config) \
 	MDRV_DEVICE_ADD(_tag, TTL74123, 0) \
 	MDRV_DEVICE_CONFIG(_config)
 
-
 /* constants for the different ways the cap/res can be connected.
    This determines the formula for calculating the pulse width */
 #define TTL74123_NOT_GROUNDED_NO_DIODE		(1)
@@ -62,26 +67,104 @@
 #define TTL74123_GROUNDED					(3)
 
 
-typedef struct _ttl74123_config ttl74123_config;
-struct _ttl74123_config
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+
+// ======================> ttl74123_interface
+
+struct ttl74123_interface
+{
+    int m_connection_type;  /* the hook up type - one of the constants above */
+    double m_res;           /* resistor connected to RCext */
+    double m_cap;           /* capacitor connected to Cext and RCext */
+    int m_a;                /* initial/constant value of the A pin */
+    int m_b;                /* initial/constant value of the B pin */
+    int m_clear;            /* initial/constant value of the Clear pin */
+    write8_device_func  m_output_changed_cb;
+};
+
+
+
+// ======================> ttl74123_device_config
+
+class ttl74123_device_config : public device_config,
+                              public ttl74123_interface
 {
-	int connection_type;	/* the hook up type - one of the constants above */
-	double res;				/* resistor connected to RCext */
-	double cap;				/* capacitor connected to Cext and RCext */
-	int a;					/* initial/constant value of the A pin */
-	int b;					/* initial/constant value of the B pin */
-	int clear;				/* initial/constant value of the Clear pin */
-	write8_device_func	output_changed_cb;
+    friend class ttl74123_device;
+
+    // construction/destruction
+    ttl74123_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
 };
 
-/* write inputs */
+
+
+// ======================> ttl74123_device
+
+class ttl74123_device :  public device_t
+{
+    friend class ttl74123_device_config;
+
+    // construction/destruction
+    ttl74123_device(running_machine &_machine, const ttl74123_device_config &_config);
+
+public:
+
+    void a_w(UINT8 data);
+    void b_w(UINT8 data);
+    void clear_w(UINT8 data);
+    void reset_w();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+    static TIMER_CALLBACK( output_callback );
+    static TIMER_CALLBACK( clear_callback );
+
+private:
+
+    int timer_running();
+    void start_pulse();
+    void output(INT32 param);
+    void set_output();
+    attotime compute_duration();
+    void clear();
+
+    UINT8 m_a;            /* pin 1/9 */
+    UINT8 m_b;            /* pin 2/10 */
+    UINT8 m_clear;        /* pin 3/11 */
+    emu_timer *m_timer;
+
+    const ttl74123_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type TTL74123;
+
+
+
+/***************************************************************************
+    PROTOTYPES
+***************************************************************************/
 
 WRITE8_DEVICE_HANDLER( ttl74123_a_w );
 WRITE8_DEVICE_HANDLER( ttl74123_b_w );
 WRITE8_DEVICE_HANDLER( ttl74123_clear_w );
-
-/* reset the latch */
-
-WRITE8_DEVICE_HANDLER( ttl74123_reset_w );
+WRITE8_DEVICE_HANDLER( ttl74123_reset_w ); /* reset the latch */
 
 #endif
diff -Nru src-old/emu/machine/7474.c src/emu/machine/7474.c
--- src-old/emu/machine/7474.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/7474.c	2010-08-30 08:20:58.000000000 -0700
@@ -40,170 +40,284 @@
 #include "emu.h"
 #include "7474.h"
 
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+//-------------------------------------------------
+//  ttl7474_device_config - constructor
+//-------------------------------------------------
 
-typedef struct _ttl7474_state ttl7474_state;
-struct _ttl7474_state
+ttl7474_device_config::ttl7474_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "7474", tag, owner, clock)
 {
-	/* callbacks */
-	devcb_resolved_write_line output_cb;
-	devcb_resolved_write_line comp_output_cb;
+}
+
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *ttl7474_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+    return global_alloc(ttl7474_device_config(mconfig, tag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
 
-	/* inputs */
-	UINT8 clear;			/* pin 1/13 */
-	UINT8 preset;			/* pin 4/10 */
-	UINT8 clock;			/* pin 3/11 */
-	UINT8 d;				/* pin 2/12 */
+device_t *ttl7474_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, ttl7474_device(machine, *this));
+}
 
-	/* outputs */
-	UINT8 output;			/* pin 5/9 */
-	UINT8 output_comp;	/* pin 6/8 */
 
-	/* internal */
-	UINT8 last_clock;
-	UINT8 last_output;
-	UINT8 last_output_comp;
+//-------------------------------------------------
+//  static_set_target_tag - configuration helper
+//  to set the target tag
+//-------------------------------------------------
+
+void ttl7474_device_config::static_set_target_tag(device_config *device, const char *tag)
+{
+	ttl7474_device_config *ttl7474 = downcast<ttl7474_device_config *>(device);
+	ttl7474->m_output_cb.tag = tag;
+	ttl7474->m_comp_output_cb.tag = tag;
+}
+
 
-	running_device *device;
-};
+//-------------------------------------------------
+//  static_set_output_cb - configuration helper
+//  to set the output callback
+//-------------------------------------------------
 
-INLINE ttl7474_state *get_safe_token(running_device *device)
+void ttl7474_device_config::static_set_output_cb(device_config *device, write_line_device_func callback)
 {
-	assert(device != NULL);
-	assert(device->type() == TTL7474);
+	ttl7474_device_config *ttl7474 = downcast<ttl7474_device_config *>(device);
+	if (callback != NULL)
+	{
+		ttl7474->m_output_cb.type = DEVCB_TYPE_DEVICE;
+		ttl7474->m_output_cb.writeline = callback;
+	}
+	else
+		ttl7474->m_output_cb.type = DEVCB_TYPE_NULL;
+}
+
+
+//-------------------------------------------------
+//  static_set_comp_output_cb - configuration
+//  helper to set the comp. output callback
+//-------------------------------------------------
+
+void ttl7474_device_config::static_set_comp_output_cb(device_config *device, write_line_device_func callback)
+{
+	ttl7474_device_config *ttl7474 = downcast<ttl7474_device_config *>(device);
+	if (callback != NULL)
+	{
+		ttl7474->m_comp_output_cb.type = DEVCB_TYPE_DEVICE;
+		ttl7474->m_comp_output_cb.writeline = callback;
+	}
+	else
+		ttl7474->m_comp_output_cb.type = DEVCB_TYPE_NULL;
+}
+
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+//-------------------------------------------------
+//  ttl7474_device - constructor
+//-------------------------------------------------
+
+ttl7474_device::ttl7474_device(running_machine &_machine, const ttl7474_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
+    init();
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ttl7474_device::device_start()
+{
+    state_save_register_device_item(this, 0, m_clear);
+    state_save_register_device_item(this, 0, m_preset);
+    state_save_register_device_item(this, 0, m_clk);
+    state_save_register_device_item(this, 0, m_d);
+    state_save_register_device_item(this, 0, m_output);
+    state_save_register_device_item(this, 0, m_output_comp);
+    state_save_register_device_item(this, 0, m_last_clock);
+    state_save_register_device_item(this, 0, m_last_output);
+    state_save_register_device_item(this, 0, m_last_output_comp);
+
+	devcb_resolve_write_line(&m_output_cb, &m_config.m_output_cb, this);
+	devcb_resolve_write_line(&m_comp_output_cb, &m_config.m_comp_output_cb, this);
+}
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
 
-	return (ttl7474_state *)downcast<legacy_device_base *>(device)->token();
+void ttl7474_device::device_reset()
+{
+    init();
 }
 
 
-static void ttl7474_update(ttl7474_state *state)
+//-------------------------------------------------
+//  update - update internal state
+//-------------------------------------------------
+
+void ttl7474_device::update()
 {
-	if (!state->preset && state->clear)			  /* line 1 in truth table */
+    if (!m_preset && m_clear)       	/* line 1 in truth table */
 	{
-		state->output	 = 1;
-		state->output_comp = 0;
+        m_output    = 1;
+        m_output_comp = 0;
 	}
-	else if (state->preset && !state->clear)	  /* line 2 in truth table */
+    else if (m_preset && !m_clear)      /* line 2 in truth table */
 	{
-		state->output	 = 0;
-		state->output_comp = 1;
+        m_output    = 0;
+        m_output_comp = 1;
 	}
-	else if (!state->preset && !state->clear)	  /* line 3 in truth table */
+    else if (!m_preset && !m_clear)     /* line 3 in truth table */
 	{
-		state->output	 = 1;
-		state->output_comp = 1;
+        m_output    = 1;
+        m_output_comp = 1;
 	}
-	else if (!state->last_clock && state->clock)  /* line 4 in truth table */
+    else if (!m_last_clock && m_clk)	/* line 4 in truth table */
 	{
-		state->output	 =  state->d;
-		state->output_comp = !state->d;
+        m_output    =  m_d;
+        m_output_comp = !m_d;
 	}
 
-	state->last_clock = state->clock;
+    m_last_clock = m_clk;
 
 
 	/* call callback if any of the outputs changed */
-	if (state->output != state->last_output)
+    if (m_output != m_last_output)
 	{
-		state->last_output = state->output;
-		if (state->output_cb.write != NULL)
-			devcb_call_write_line(&state->output_cb, state->output);
+        m_last_output = m_output;
+		devcb_call_write_line(&m_output_cb, m_output);
 	}
 	/* call callback if any of the outputs changed */
-	if (state->output_comp != state->last_output_comp)
+    if (m_output_comp != m_last_output_comp)
 	{
-		state->last_output_comp = state->output_comp;
-		if (state->comp_output_cb.write != NULL)
-			devcb_call_write_line(&state->comp_output_cb, state->output_comp);
+        m_last_output_comp = m_output_comp;
+		devcb_call_write_line(&m_comp_output_cb, m_output_comp);
 	}
 }
 
 
+//-------------------------------------------------
+//  clear_w - set the clear line state
+//-------------------------------------------------
+
 WRITE_LINE_DEVICE_HANDLER( ttl7474_clear_w )
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	dev_state->clear = state & 1;
-	ttl7474_update(dev_state);
+    downcast<ttl7474_device *>(device)->clear_w(state);
 }
 
-WRITE_LINE_DEVICE_HANDLER( ttl7474_preset_w )
+void ttl7474_device::clear_w(UINT8 state)
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	dev_state->preset = state & 1;
-	ttl7474_update(dev_state);
+    m_clear = state & 1;
+	update();
 }
 
-WRITE_LINE_DEVICE_HANDLER( ttl7474_clock_w )
+
+//-------------------------------------------------
+//  clear_w - set the clear line state
+//-------------------------------------------------
+
+WRITE_LINE_DEVICE_HANDLER( ttl7474_preset_w )
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	dev_state->clock = state & 1;
-	ttl7474_update(dev_state);
+    downcast<ttl7474_device *>(device)->preset_w(state);
 }
 
-WRITE_LINE_DEVICE_HANDLER( ttl7474_d_w )
+void ttl7474_device::preset_w(UINT8 state)
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	dev_state->d = state & 1;
-	ttl7474_update(dev_state);
+    m_preset = state & 1;
+	update();
 }
 
 
-READ_LINE_DEVICE_HANDLER( ttl7474_output_r )
+//-------------------------------------------------
+//  clock_w - set the clock line state
+//-------------------------------------------------
+
+WRITE_LINE_DEVICE_HANDLER( ttl7474_clock_w )
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	return dev_state->output;
+    downcast<ttl7474_device *>(device)->clock_w(state);
 }
 
-READ_LINE_DEVICE_HANDLER( ttl7474_output_comp_r )
+void ttl7474_device::clock_w(UINT8 state)
 {
-	ttl7474_state *dev_state = get_safe_token(device);
-	return dev_state->output_comp;
+    m_clk = state & 1;
+	update();
 }
 
 
-static DEVICE_START( ttl7474 )
+//-------------------------------------------------
+//  d_w - set the d line state
+//-------------------------------------------------
+
+WRITE_LINE_DEVICE_HANDLER( ttl7474_d_w )
 {
-	ttl7474_config *config = (ttl7474_config *)downcast<const legacy_device_config_base &>(device->baseconfig()).inline_config();
-	ttl7474_state *state = get_safe_token(device);
+    downcast<ttl7474_device *>(device)->d_w(state);
+}
 
-	devcb_resolve_write_line(&state->output_cb, &config->output_cb, device);
-	devcb_resolve_write_line(&state->comp_output_cb, &config->comp_output_cb, device);
+void ttl7474_device::d_w(UINT8 state)
+{
+    m_d = state & 1;
+	update();
+}
 
-    state->device = device;
 
-    state_save_register_device_item(device, 0, state->clear);
-    state_save_register_device_item(device, 0, state->preset);
-    state_save_register_device_item(device, 0, state->clock);
-    state_save_register_device_item(device, 0, state->d);
-    state_save_register_device_item(device, 0, state->output);
-    state_save_register_device_item(device, 0, state->output_comp);
-    state_save_register_device_item(device, 0, state->last_clock);
-    state_save_register_device_item(device, 0, state->last_output);
-    state_save_register_device_item(device, 0, state->last_output_comp);
-}
+//-------------------------------------------------
+//  output_r - get the output line state
+//-------------------------------------------------
 
+READ_LINE_DEVICE_HANDLER( ttl7474_output_r )
+{
+    return downcast<ttl7474_device *>(device)->output_r();
+}
 
-static DEVICE_RESET( ttl7474 )
+UINT8 ttl7474_device::output_r()
 {
-	ttl7474_state *state = get_safe_token(device);
+    return m_output;
+}
 
-	/* all inputs are open first */
-    state->clear = 1;
-    state->preset = 1;
-    state->clock = 1;
-    state->d = 1;
 
-    state->last_clock = 1;
-    state->last_output = -1;
-    state->last_output_comp = -1;
-}
+//-----------------------------------------------------
+//  output_comp_r - get the output-compare line state
+//-----------------------------------------------------
 
+READ_LINE_DEVICE_HANDLER( ttl7474_output_comp_r )
+{
+    return downcast<ttl7474_device *>(device)->output_comp_r();
+}
 
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
+UINT8 ttl7474_device::output_comp_r()
+{
+    return m_output_comp;
+}
 
-#define DEVTEMPLATE_ID(p,s)		p##ttl7474##s
-#define DEVTEMPLATE_FEATURES	DT_HAS_START | DT_HAS_RESET | DT_HAS_INLINE_CONFIG
-#define DEVTEMPLATE_NAME		"7474"
-#define DEVTEMPLATE_FAMILY		"TTL"
-#include "devtempl.h"
+void ttl7474_device::init()
+{
+    m_clear = 1;
+    m_preset = 1;
+    m_clk = 1;
+    m_d = 1;
+
+    m_output = -1;
+    m_last_clock = 1;
+    m_last_output = -1;
+}
 
-DEFINE_LEGACY_DEVICE(TTL7474, ttl7474);
+const device_type MACHINE_TTL7474 = ttl7474_device_config::static_alloc_device_config;
diff -Nru src-old/emu/machine/7474.h src/emu/machine/7474.h
--- src-old/emu/machine/7474.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/7474.h	2010-08-30 08:20:58.000000000 -0700
@@ -37,33 +37,140 @@
 
 *****************************************************************************/
 
-#ifndef TTL7474_H
-#define TTL7474_H
+#pragma once
 
-#include "devlegcy.h"
+#ifndef __TTL7474_H__
+#define __TTL7474_H__
 
+#include "emu.h"
 
-typedef struct _ttl7474_config ttl7474_config;
-struct _ttl7474_config
+
+
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MDRV_7474_ADD(_tag, _target_tag, _output_cb, _comp_output_cb) \
+    MDRV_DEVICE_ADD(_tag, MACHINE_TTL7474, 0) \
+    MDRV_7474_TARGET_TAG(_target_tag) \
+    MDRV_7474_OUTPUT_CB(_output_cb) \
+    MDRV_7474_COMP_OUTPUT_CB(_comp_output_cb)
+
+#define MDRV_7474_REPLACE(_tag, _target_tag, _output_cb, _comp_output_cb) \
+    MDRV_DEVICE_REPLACE(_tag, TTL7474, 0) \
+    MDRV_7474_TARGET_TAG(_target_tag) \
+    MDRV_7474_OUTPUT_CB(_output_cb) \
+    MDRV_7474_COMP_OUTPUT_CB(_comp_output_cb)
+
+#define MDRV_7474_TARGET_TAG(_target_tag) \
+	ttl7474_device_config::static_set_target_tag(device, _target_tag); \
+
+#define MDRV_7474_OUTPUT_CB(_cb) \
+	ttl7474_device_config::static_set_output_cb(device, _cb); \
+
+#define MDRV_7474_COMP_OUTPUT_CB(_cb) \
+	ttl7474_device_config::static_set_comp_output_cb(device, _cb); \
+
+
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> ttl7474_device_config
+
+class ttl7474_device_config :  public device_config
 {
-	devcb_write_line output_cb;
-	devcb_write_line comp_output_cb;
+    friend class ttl7474_device;
+
+    // construction/destruction
+    ttl7474_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+	// inline configuration helpers
+	static void static_set_target_tag(device_config *device, const char *tag);
+	static void static_set_output_cb(device_config *device, write_line_device_func callback);
+	static void static_set_comp_output_cb(device_config *device, write_line_device_func callback);
+
+protected:
+    // internal state goes here
+    devcb_write_line m_output_cb;
+    devcb_write_line m_comp_output_cb;
 };
 
 
-#define MDRV_7474_ADD(_tag, _target_tag, _output_cb, _comp_output_cb) \
-	MDRV_DEVICE_ADD(_tag, TTL7474, 0) \
-	MDRV_DEVICE_CONFIG_WRITE_LINE(ttl7474_config, output_cb, _target_tag, _output_cb) \
-	MDRV_DEVICE_CONFIG_WRITE_LINE(ttl7474_config, comp_output_cb, _target_tag, _comp_output_cb)
 
+// ======================> ttl7474_device
+
+class ttl7474_device : public device_t
+{
+    friend class ttl7474_device_config;
+
+    // construction/destruction
+    ttl7474_device(running_machine &_machine, const ttl7474_device_config &config);
+
+public:
+    void clear_w(UINT8 state);
+    void preset_w(UINT8 state);
+    void clock_w(UINT8 state);
+    void d_w(UINT8 state);
+    UINT8 output_r();
+    UINT8 output_comp_r();    /* NOT strictly the same as !ttl7474_output_r() */
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+    // internal state
+    const ttl7474_device_config &m_config;
+
+private:
+    /* callbacks */
+    devcb_resolved_write_line m_output_cb;
+    devcb_resolved_write_line m_comp_output_cb;
+
+    /* inputs */
+    UINT8 m_clear;              /* pin 1/13 */
+    UINT8 m_preset;             /* pin 4/10 */
+    UINT8 m_clk;            	/* pin 3/11 */
+    UINT8 m_d;                  /* pin 2/12 */
+
+    /* outputs */
+    UINT8 m_output;             /* pin 5/9 */
+    UINT8 m_output_comp;        /* pin 6/8 */
+
+    /* internal */
+    UINT8 m_last_clock;
+    UINT8 m_last_output;
+    UINT8 m_last_output_comp;
+
+    void update();
+    void init();
+};
+
+
+// device type definition
+extern const device_type MACHINE_TTL7474;
+
+
+
+//**************************************************************************
+//  READ/WRITE HANDLERS
+//**************************************************************************
 
 WRITE_LINE_DEVICE_HANDLER( ttl7474_clear_w );
 WRITE_LINE_DEVICE_HANDLER( ttl7474_preset_w );
 WRITE_LINE_DEVICE_HANDLER( ttl7474_clock_w );
 WRITE_LINE_DEVICE_HANDLER( ttl7474_d_w );
 READ_LINE_DEVICE_HANDLER( ttl7474_output_r );
-READ_LINE_DEVICE_HANDLER( ttl7474_output_comp_r );	/* NOT strictly the same as !ttl7474_output_r() */
+READ_LINE_DEVICE_HANDLER( ttl7474_output_comp_r );    /* NOT strictly the same as !ttl7474_output_r() */
 
-DECLARE_LEGACY_DEVICE(TTL7474, ttl7474);
 
-#endif
+#endif /* __TTL7474_H__ */
diff -Nru src-old/emu/machine/8237dma.c src/emu/machine/8237dma.c
--- src-old/emu/machine/8237dma.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/8237dma.c	2010-08-30 08:20:58.000000000 -0700
@@ -21,74 +21,11 @@
 #include "emu.h"
 #include "memconv.h"
 #include "8237dma.h"
+#include "devhelpr.h"
 
-
-/* States that the i8237 device can be in */
-typedef enum {
-	DMA8237_SI,			/* Idle state */
-	DMA8237_S0,			/* HRQ has been triggered, waiting to receive HLDA */
-//  DMA8237_SW,         /* Wait state */
-
-	/* Normal transfer states */
-	DMA8237_S1,			/* Output A8-A15; only used when A8-A15 really needs to be output */
-	DMA8237_S2,			/* Output A0-A7 */
-	DMA8237_S3,			/* Initiate read; skipped in compressed timing. On the S2->S3 transition DACK is set. */
-	DMA8237_S4,			/* Perform read/write */
-
-	/* Memory to memory transfer states */
-	DMA8237_S11,		/* Output A8-A15 */
-//  DMA8237_S12,        /* Output A0-A7 */
-//  DMA8237_S13,        /* Initiate read */
-//  DMA8237_S14,        /* Perform read/write */
-//  DMA8237_S21,        /* Output A8-A15 */
-//  DMA8237_S22,        /* Output A0-A7 */
-//  DMA8237_S23,        /* Initiate read */
-//  DMA8237_S24,        /* Perform read/write */
-} dma8237_state;
-
-
-typedef struct _i8237_t i8237_t;
-struct _i8237_t
-{
-	devcb_resolved_write_line	out_hrq_func;
-	devcb_resolved_write_line	out_eop_func;
-	devcb_resolved_read8		in_memr_func;
-	devcb_resolved_write8		out_memw_func;
-
-	emu_timer *timer;
-
-	struct
-	{
-		devcb_resolved_read8		in_ior_func;
-		devcb_resolved_write8		out_iow_func;
-		devcb_resolved_write_line	out_dack_func;
-		UINT16 base_address;
-		UINT16 base_count;
-		UINT16 address;
-		UINT16 count;
-		UINT8 mode;
-		int high_address_changed;
-	} chan[4];
-
-	UINT32 msb : 1;
-	UINT32 eop : 1;
-	UINT8 temp;
-	UINT8 temporary_data;
-	UINT8 command;
-	UINT8 drq;
-	UINT8 mask;
-	UINT8 hrq;
-	UINT8 hlda;
-
-	/* bits  0- 3 :  Terminal count for channels 0-3
-     * bits  4- 7 :  Transfer in progress for channels 0-3 */
-	UINT8 status;
-
-	dma8237_state state;		/* State the device is currently in */
-	int service_channel;		/* Channel we will be servicing */
-	int last_service_channel;	/* Previous channel we serviced; used to determine channel priority. */
-};
-
+/***************************************************************************
+    MACROS
+***************************************************************************/
 
 #define DMA_MODE_CHANNEL(mode)		((mode) & 0x03)
 #define DMA_MODE_OPERATION(mode)	((mode) & 0x0c)
@@ -107,30 +44,126 @@
 #define DMA8237_CASCADE_MODE	0xc0
 
 
-/* ----------------------------------------------------------------------- */
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+GENERIC_DEVICE_CONFIG_SETUP(i8237, "Intel 8237")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void i8237_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const i8237_interface *intf = reinterpret_cast<const i8237_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<i8237_interface *>(this) = *intf;
+	}
 
-INLINE i8237_t *get_safe_token(running_device *device) {
-	assert( device != NULL );
-	assert( device->type() == I8237 );
-	return ( i8237_t *) downcast<legacy_device_base *>(device)->token();
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_out_hrq_func, 0, sizeof(m_out_hrq_func));
+    	memset(&m_out_eop_func, 0, sizeof(m_out_eop_func));
+    	memset(&m_in_memr_func, 0, sizeof(m_in_memr_func));
+    	memset(&m_out_memw_func, 0, sizeof(m_out_memw_func));
+    	memset(&m_in_ior_func[0], 0, sizeof(m_in_ior_func[0]));
+    	memset(&m_in_ior_func[1], 0, sizeof(m_in_ior_func[1]));
+    	memset(&m_in_ior_func[2], 0, sizeof(m_in_ior_func[2]));
+    	memset(&m_in_ior_func[3], 0, sizeof(m_in_ior_func[3]));
+    	memset(&m_out_iow_func[0], 0, sizeof(m_out_iow_func[0]));
+    	memset(&m_out_iow_func[1], 0, sizeof(m_out_iow_func[1]));
+    	memset(&m_out_iow_func[2], 0, sizeof(m_out_iow_func[2]));
+    	memset(&m_out_iow_func[3], 0, sizeof(m_out_iow_func[3]));
+    	memset(&m_out_dack_func[0], 0, sizeof(m_out_dack_func[0]));
+    	memset(&m_out_dack_func[1], 0, sizeof(m_out_dack_func[1]));
+    	memset(&m_out_dack_func[2], 0, sizeof(m_out_dack_func[2]));
+    	memset(&m_out_dack_func[3], 0, sizeof(m_out_dack_func[3]));
+	}
 }
 
 
-/* ----------------------------------------------------------------------- */
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type I8237 = i8237_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  i8237_device - constructor
+//-------------------------------------------------
+
+i8237_device::i8237_device(running_machine &_machine, const i8237_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
+
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void i8237_device::device_start()
+{
+	/* resolve callbacks */
+	devcb_resolve_write_line(&m_out_hrq_func, &m_config.m_out_hrq_func, this);
+	devcb_resolve_write_line(&m_out_eop_func, &m_config.m_out_eop_func, this);
+	devcb_resolve_read8(&m_in_memr_func, &m_config.m_in_memr_func, this);
+	devcb_resolve_write8(&m_out_memw_func, &m_config.m_out_memw_func, this);
+
+	for (int i = 0; i < 4; i++)
+	{
+		devcb_resolve_read8(&m_chan[i].m_in_ior_func, &m_config.m_in_ior_func[i], this);
+		devcb_resolve_write8(&m_chan[i].m_out_iow_func, &m_config.m_out_iow_func[i], this);
+		devcb_resolve_write_line(&m_chan[i].m_out_dack_func, &m_config.m_out_dack_func[i], this);
+	}
+
+	m_timer = timer_alloc(&m_machine, i8237_timerproc_callback, (void *)this);
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void i8237_device::device_reset()
+{
+	m_status = 0x0F;
+	m_eop = 1;
+	m_state = DMA8237_SI;
+	m_last_service_channel = 3;
+
+	m_mask = 0x00;
+	m_status = 0x0F;
+	m_hrq = 0;
+	m_hlda = 0;
+	m_chan[0].m_mode = 0;
+	m_chan[1].m_mode = 0;
+	m_chan[2].m_mode = 0;
+	m_chan[3].m_mode = 0;
+
+	timer_adjust_periodic(m_timer, ATTOTIME_IN_HZ(clock()), 0, ATTOTIME_IN_HZ(clock()));
+}
 
 
-INLINE void dma8237_do_read( running_device *device )
+void i8237_device::i8237_do_read()
 {
-	i8237_t	*i8237 = get_safe_token( device );
-	int			channel = i8237->service_channel;
+	int channel = m_service_channel;
 
-	switch( DMA_MODE_OPERATION( i8237->chan[ channel ].mode ) )
+	switch( DMA_MODE_OPERATION( m_chan[ channel ].m_mode ) )
 	{
 	case DMA8237_WRITE_TRANSFER:
-		i8237->temporary_data = devcb_call_read8(&i8237->chan[channel].in_ior_func, 0);
+		m_temporary_data = devcb_call_read8(&m_chan[channel].m_in_ior_func, 0);
 		break;
 	case DMA8237_READ_TRANSFER:
-		i8237->temporary_data = devcb_call_read8(&i8237->in_memr_func, i8237->chan[ channel ].address);
+		m_temporary_data = devcb_call_read8(&m_in_memr_func, m_chan[ channel ].m_address);
 		break;
 	case DMA8237_VERIFY_TRANSFER:
 	case DMA8237_ILLEGAL_TRANSFER:
@@ -139,18 +172,17 @@
 }
 
 
-INLINE void dma8237_do_write( running_device *device )
+void i8237_device::i8237_do_write()
 {
-	i8237_t	*i8237 = get_safe_token( device );
-	int			channel = i8237->service_channel;
+	int channel = m_service_channel;
 
-	switch( DMA_MODE_OPERATION( i8237->chan[ channel ].mode ) )
+	switch( DMA_MODE_OPERATION( m_chan[ channel ].m_mode ) )
 	{
 	case DMA8237_WRITE_TRANSFER:
-		devcb_call_write8(&i8237->out_memw_func, i8237->chan[ channel ].address, i8237->temporary_data);
+		devcb_call_write8(&m_out_memw_func, m_chan[ channel ].m_address, m_temporary_data);
 		break;
 	case DMA8237_READ_TRANSFER:
-		devcb_call_write8(&i8237->chan[channel].out_iow_func, 0, i8237->temporary_data);
+		devcb_call_write8(&m_chan[channel].m_out_iow_func, 0, m_temporary_data);
 		break;
 	case DMA8237_VERIFY_TRANSFER:
 	case DMA8237_ILLEGAL_TRANSFER:
@@ -159,235 +191,252 @@
 }
 
 
-INLINE void dma8237_advance( running_device *device )
+void i8237_device::i8237_advance()
 {
-	i8237_t	*i8237 = get_safe_token( device );
-	int			channel = i8237->service_channel;
-	int			mode = i8237->chan[channel].mode;
+	int channel = m_service_channel;
+	int mode = m_chan[channel].m_mode;
 
 	switch ( DMA_MODE_OPERATION( mode ) )
 	{
 	case DMA8237_VERIFY_TRANSFER:
 	case DMA8237_WRITE_TRANSFER:
 	case DMA8237_READ_TRANSFER:
-		i8237->chan[channel].high_address_changed = 0;
+		m_chan[channel].m_high_address_changed = 0;
 
 		if ( DMA_MODE_DIRECTION( mode ) )
 		{
-			i8237->chan[channel].address -= 1;
-			if ( ( i8237->chan[channel].address & 0xFF ) == 0xFF )
-				i8237->chan[channel].high_address_changed  = 1;
+			m_chan[channel].m_address -= 1;
+			if ( ( m_chan[channel].m_address & 0xFF ) == 0xFF )
+			{
+				m_chan[channel].m_high_address_changed  = 1;
+			}
 		}
 		else
 		{
-			i8237->chan[channel].address += 1;
-			if ( ( i8237->chan[channel].address & 0xFF ) == 0x00 )
-				i8237->chan[channel].high_address_changed = 1;
+			m_chan[channel].m_address += 1;
+			if ( ( m_chan[channel].m_address & 0xFF ) == 0x00 )
+			{
+				m_chan[channel].m_high_address_changed = 1;
+			}
 		}
 
-		i8237->chan[channel].count--;
+		m_chan[channel].m_count--;
 
-		if ( i8237->chan[channel].count == 0xFFFF )
+		if ( m_chan[channel].m_count == 0xFFFF )
 		{
 			/* Set TC bit for this channel */
-			i8237->status |= ( 0x01 << channel );
+			m_status |= ( 0x01 << channel );
 
 			if ( DMA_MODE_AUTO_INIT( mode ) )
 			{
-				i8237->chan[channel].address = i8237->chan[channel].base_address;
-				i8237->chan[channel].count = i8237->chan[channel].base_count;
-				i8237->chan[channel].high_address_changed = 1;
+				m_chan[channel].m_address = m_chan[channel].m_base_address;
+				m_chan[channel].m_count = m_chan[channel].m_base_count;
+				m_chan[channel].m_high_address_changed = 1;
 			}
 			else
 			{
-				i8237->mask |= ( 0x01 << channel );
+				m_mask |= ( 0x01 << channel );
 			}
 		}
 		break;
 	case DMA8237_ILLEGAL_TRANSFER:
 		break;
 	}
-
 }
 
-static void set_dack(i8237_t *i8237, int channel)
-{
-	int i;
 
-	for (i = 0; i < 4; i++)
+void i8237_device::i8327_set_dack(int channel)
+{
+	for (int i = 0; i < 4; i++)
 	{
-		int state = (i == channel) ^ !BIT(i8237->command, 7);
+		int state = (i == channel) ^ !BIT(m_command, 7);
 
-		devcb_call_write_line(&i8237->chan[i].out_dack_func, state);
+		devcb_call_write_line(&m_chan[i].m_out_dack_func, state);
 	}
 }
 
-static TIMER_CALLBACK( dma8237_timerproc )
+
+TIMER_CALLBACK( i8237_device::i8237_timerproc_callback )
 {
-	running_device *device = (running_device *)ptr;
-	i8237_t	*i8237 = get_safe_token(device);
+	reinterpret_cast<i8237_device*>(ptr)->i8237_timerproc();
+}
 
+
+void i8237_device::i8237_timerproc()
+{
 	/* Check if operation is disabled */
-	if ( i8237->command & 0x04 )
+	if ( m_command & 0x04 )
+	{
 		return;
+	}
 
-	switch ( i8237->state ) {
+	switch ( m_state )
+	{
 
 	case DMA8237_SI:
+	{
 		/* Make sure EOP is high */
-		if ( ! i8237->eop )
+		if ( !m_eop )
 		{
-			i8237->eop = 1;
-			devcb_call_write_line(&i8237->out_eop_func, i8237->eop ? ASSERT_LINE : CLEAR_LINE);
+			m_eop = 1;
+			devcb_call_write_line(&m_out_eop_func, m_eop ? ASSERT_LINE : CLEAR_LINE);
 		}
 
 		/* Check if a new DMA request has been received. */
+		/* Bit 6 of the command register determines whether the DREQ signals are active
+          high or active low. */
+		UINT16 pending_request = ( ( m_command & 0x40 ) ? ~m_drq : m_drq ) & ~m_mask;
+
+		if ( pending_request & 0x0f )
 		{
-			/* Bit 6 of the command register determines whether the DREQ signals are active
-              high or active low. */
-			UINT16 pending_request = ( ( i8237->command & 0x40 ) ? ~i8237->drq : i8237->drq ) & ~i8237->mask;
+			int prio_channel = 0;
 
-			if ( pending_request & 0x0f )
+			/* Determine the channel that should be serviced */
+			int channel = ( m_command & 0x10 ) ? m_last_service_channel : 3;
+			for ( int i = 0; i < 4; i++ )
 			{
-				int i, channel, prio_channel = 0;
-
-				/* Determine the channel that should be serviced */
-				channel = ( i8237->command & 0x10 ) ? i8237->last_service_channel : 3;
-				for ( i = 0; i < 4; i++ )
+				if ( pending_request & ( 1 << channel ) )
 				{
-					if ( pending_request & ( 1 << channel ) )
-						prio_channel = channel;
-					channel = ( channel - 1 ) & 0x03;
+					prio_channel = channel;
 				}
+				channel = ( channel - 1 ) & 0x03;
+			}
 
-				/* Store the channel we will be servicing and go to the next state */
-				i8237->service_channel = prio_channel;
-				i8237->last_service_channel = prio_channel;
-				i8237->hrq = 1;
-				devcb_call_write_line(&i8237->out_hrq_func, i8237->hrq);
-				i8237->state = DMA8237_S0;
+			/* Store the channel we will be servicing and go to the next state */
+			m_service_channel = prio_channel;
+			m_last_service_channel = prio_channel;
+			m_hrq = 1;
+			devcb_call_write_line(&m_out_hrq_func, m_hrq);
+			m_state = DMA8237_S0;
 
-				timer_enable( i8237->timer, 1 );
-			}
-			else
-			{
-				timer_enable( i8237->timer, 0 );
-			}
+			timer_enable( m_timer, 1 );
+		}
+		else
+		{
+			timer_enable( m_timer, 0 );
 		}
 		break;
+	}
 
 	case DMA8237_S0:
 		/* S0 is the first of the DMA service. We have requested a hold but are waiting
           for confirmation. */
-		if ( i8237->hlda )
+		if ( m_hlda )
 		{
-			if ( i8237->command & 0x01 )
+			if ( m_command & 0x01 )
 			{
 				/* Memory-to-memory transfers */
-				i8237->state = DMA8237_S11;
+				m_state = DMA8237_S11;
 			}
 			else
 			{
 				/* Regular transfers */
-				i8237->state = DMA8237_S1;
+				m_state = DMA8237_S1;
 			}
 		}
 		break;
 
 	case DMA8237_S1:	/* Output A8-A15 */
-		i8237->state = DMA8237_S2;
+		m_state = DMA8237_S2;
 		break;
 
 	case DMA8237_S2:	/* Output A7-A0 */
 		/* set DACK */
-		set_dack(i8237, i8237->service_channel);
+		i8327_set_dack(m_service_channel);
 
 		/* Check for compressed timing */
-		if ( i8237->command & 0x08 )
-			i8237->state = DMA8237_S4;
+		if ( m_command & 0x08 )
+		{
+			m_state = DMA8237_S4;
+		}
 		else
-			i8237->state = DMA8237_S3;
+		{
+			m_state = DMA8237_S3;
+		}
 		break;
 
 	case DMA8237_S3:	/* Initiate read */
-		dma8237_do_read( device );
-		i8237->state = DMA8237_S4;
+		i8237_do_read();
+		m_state = DMA8237_S4;
 		break;
 
 	case DMA8237_S4:	/* Perform read/write */
 		/* Perform read when in compressed timing mode */
-		if ( i8237->command & 0x08 )
-			dma8237_do_read( device );
+		if ( m_command & 0x08 )
+		{
+			i8237_do_read();
+		}
 
 		/* Perform write */
-		dma8237_do_write( device );
+		i8237_do_write();
+
 
 		/* Advance */
-		dma8237_advance( device );
+		i8237_advance();
 
 		{
-			int channel = i8237->service_channel;
+			int channel = m_service_channel;
 
-			switch( DMA_MODE_TRANSFERMODE( i8237->chan[channel].mode ) )
+			switch( DMA_MODE_TRANSFERMODE( m_chan[channel].m_mode ) )
 			{
 			case DMA8237_DEMAND_MODE:
 				/* Check for terminal count or EOP signal or DREQ begin de-asserted */
-				if ( ( i8237->status & ( 0x01 << channel ) ) || ! i8237->eop || ! ( i8237->drq & ( 0x01 << channel ) ) )
+				if ( ( m_status & ( 0x01 << channel ) ) || !m_eop || !( m_drq & ( 0x01 << channel ) ) )
 				{
-					i8237->hrq = 0;
-					i8237->hlda = 0;
-					devcb_call_write_line(&i8237->out_hrq_func, i8237->hrq);
-					i8237->state = DMA8237_SI;
+					m_hrq = 0;
+					m_hlda = 0;
+					devcb_call_write_line(&m_out_hrq_func, m_hrq);
+					m_state = DMA8237_SI;
 				}
 				else
 				{
-					i8237->state = i8237->chan[channel].high_address_changed ? DMA8237_S1 : DMA8237_S2;
+					m_state = m_chan[channel].m_high_address_changed ? DMA8237_S1 : DMA8237_S2;
 				}
 				break;
 
 			case DMA8237_SINGLE_MODE:
-				i8237->hrq = 0;
-				i8237->hlda = 0;
-				devcb_call_write_line(&i8237->out_hrq_func, i8237->hrq);
-				i8237->state = DMA8237_SI;
+				m_hrq = 0;
+				m_hlda = 0;
+				devcb_call_write_line(&m_out_hrq_func, m_hrq);
+				m_state = DMA8237_SI;
 				break;
 
 			case DMA8237_BLOCK_MODE:
 				/* Check for terminal count or EOP signal */
-				if ( ( i8237->status & ( 0x01 << channel ) ) || ! i8237->eop )
+				if ( ( m_status & ( 0x01 << channel ) ) || !m_eop )
 				{
-					i8237->hrq = 0;
-					i8237->hlda = 0;
-					devcb_call_write_line(&i8237->out_hrq_func, i8237->hrq);
-					i8237->state = DMA8237_SI;
+					m_hrq = 0;
+					m_hlda = 0;
+					devcb_call_write_line(&m_out_hrq_func, m_hrq);
+					m_state = DMA8237_SI;
 				}
 				else
 				{
-					i8237->state = i8237->chan[channel].high_address_changed ? DMA8237_S1 : DMA8237_S2;
+					m_state = m_chan[channel].m_high_address_changed ? DMA8237_S1 : DMA8237_S2;
 				}
 				break;
 
 			case DMA8237_CASCADE_MODE:
-				if ( ! ( i8237->drq & ( 0x01 << channel ) ) )
+				if ( ! ( m_drq & ( 0x01 << channel ) ) )
 				{
-					i8237->hrq = 0;
-					i8237->hlda = 0;
-					devcb_call_write_line(&i8237->out_hrq_func, i8237->hrq);
-					i8237->state = DMA8237_SI;
+					m_hrq = 0;
+					m_hlda = 0;
+					devcb_call_write_line(&m_out_hrq_func, m_hrq);
+					m_state = DMA8237_SI;
 				}
 				break;
 			}
 
 			/* Check if EOP output needs to be asserted */
-			if ( i8237->status & ( 0x01 << channel ) )
+			if ( m_status & ( 0x01 << channel ) )
 			{
-				i8237->eop = 0;
-				devcb_call_write_line(&i8237->out_eop_func, i8237->eop ? ASSERT_LINE : CLEAR_LINE);
+				m_eop = 0;
+				devcb_call_write_line(&m_out_eop_func, m_eop ? ASSERT_LINE : CLEAR_LINE);
 			}
 		}
 
 		/* clear DACK */
-		set_dack(i8237, -1);
+		i8327_set_dack(-1);
 		break;
 
 	case DMA8237_S11:	/* Output A8-A15 */
@@ -396,14 +445,8 @@
 }
 
 
-
-
-/* ----------------------------------------------------------------------- */
-
-
-READ8_DEVICE_HANDLER( i8237_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(i8237, i8237_r)
 {
-	i8237_t	*i8237 = get_safe_token(device);
 	UINT8 data = 0xFF;
 
 	offset &= 0x0F;
@@ -414,8 +457,8 @@
 	case 4:
 	case 6:
 		/* DMA address register */
-		data = i8237->chan[offset / 2].address >> (i8237->msb ? 8 : 0);
-		i8237->msb ^= 1;
+		data = m_chan[offset / 2].m_address >> (m_msb ? 8 : 0);
+		m_msb ^= 1;
 		break;
 
 	case 1:
@@ -423,26 +466,26 @@
 	case 5:
 	case 7:
 		/* DMA count register */
-		data = i8237->chan[offset / 2].count >> (i8237->msb ? 8 : 0);
-		i8237->msb ^= 1;
+		data = m_chan[offset / 2].m_count >> (m_msb ? 8 : 0);
+		m_msb ^= 1;
 		break;
 
 	case 8:
 		/* DMA status register */
-		data = (UINT8) i8237->status;
+		data = (UINT8) m_status;
 
 		/* TC bits are cleared on a status read */
-		i8237->status &= 0xF0;
+		m_status &= 0xF0;
 		break;
 
 	case 10:
 		/* DMA mask register */
-		data = i8237->mask;
+		data = m_mask;
 		break;
 
 	case 13:
 		/* DMA master clear */
-		data = i8237->temp;
+		data = m_temp;
 		break;
 
 	case 9:		/* DMA write request register */
@@ -458,12 +501,8 @@
 }
 
 
-
-WRITE8_DEVICE_HANDLER( i8237_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(i8237, i8237_w)
 {
-	i8237_t	*i8237 = get_safe_token(device);
-	int channel;
-
 	offset &= 0x0F;
 
 	logerror("i8237_w: offset = %02x, data = %02x\n", offset, data );
@@ -473,205 +512,144 @@
 	case 2:
 	case 4:
 	case 6:
+	{
 		/* DMA address register */
-		channel = offset / 2;
-		if (i8237->msb)
+		int channel = offset / 2;
+		if (m_msb)
 		{
-			i8237->chan[channel].base_address = ( i8237->chan[channel].base_address & 0x00FF ) | ( data << 8 );
-			i8237->chan[channel].address = ( i8237->chan[channel].address & 0x00FF ) | ( data << 8 );
+			m_chan[channel].m_base_address = ( m_chan[channel].m_base_address & 0x00FF ) | ( data << 8 );
+			m_chan[channel].m_address = ( m_chan[channel].m_address & 0x00FF ) | ( data << 8 );
 		}
 		else
 		{
-			i8237->chan[channel].base_address = ( i8237->chan[channel].base_address & 0xFF00 ) | data;
-			i8237->chan[channel].address = ( i8237->chan[channel].address & 0xFF00 ) | data;
+			m_chan[channel].m_base_address = ( m_chan[channel].m_base_address & 0xFF00 ) | data;
+			m_chan[channel].m_address = ( m_chan[channel].m_address & 0xFF00 ) | data;
 		}
-		i8237->msb ^= 1;
+		m_msb ^= 1;
 		break;
+	}
 
 	case 1:
 	case 3:
 	case 5:
 	case 7:
+	{
 		/* DMA count register */
-		channel = offset / 2;
-		if (i8237->msb)
+		int channel = offset / 2;
+		if (m_msb)
 		{
-			i8237->chan[channel].base_count = ( i8237->chan[channel].base_count & 0x00FF ) | ( data << 8 );
-			i8237->chan[channel].count = ( i8237->chan[channel].count & 0x00FF ) | ( data << 8 );
+			m_chan[channel].m_base_count = ( m_chan[channel].m_base_count & 0x00FF ) | ( data << 8 );
+			m_chan[channel].m_count = ( m_chan[channel].m_count & 0x00FF ) | ( data << 8 );
 		}
 		else
 		{
-			i8237->chan[channel].base_count = ( i8237->chan[channel].base_count & 0xFF00 ) | data;
-			i8237->chan[channel].count = ( i8237->chan[channel].count & 0xFF00 ) | data;
+			m_chan[channel].m_base_count = ( m_chan[channel].m_base_count & 0xFF00 ) | data;
+			m_chan[channel].m_count = ( m_chan[channel].m_count & 0xFF00 ) | data;
 		}
-		i8237->msb ^= 1;
+		m_msb ^= 1;
 		break;
+	}
 
 	case 8:
 		/* DMA command register */
-		i8237->command = data;
-		timer_enable( i8237->timer, ( i8237->command & 0x04 ) ? 0 : 1 );
+		m_command = data;
+		timer_enable( m_timer, ( m_command & 0x04 ) ? 0 : 1 );
 		break;
 
 	case 9:
+	{
 		/* DMA request register */
-		channel = DMA_MODE_CHANNEL(data);
+		int channel = DMA_MODE_CHANNEL(data);
 		if ( data & 0x04 )
 		{
-			i8237->drq |= 0x01 << channel;
-			timer_enable( i8237->timer, ( i8237->command & 0x04 ) ? 0 : 1 );
+			m_drq |= 0x01 << channel;
+			timer_enable( m_timer, ( m_command & 0x04 ) ? 0 : 1 );
 		}
 		else
 		{
-			i8237->status &= ~ ( 0x10 << channel );
-			i8237->drq &= ~ ( 0x01 << channel );
+			m_status &= ~ ( 0x10 << channel );
+			m_drq &= ~ ( 0x01 << channel );
 		}
 		break;
+	}
 
 	case 10:
+	{
 		/* DMA mask register */
-		channel = DMA_MODE_CHANNEL(data);
+		int channel = DMA_MODE_CHANNEL(data);
 		if (data & 0x04)
-			i8237->mask |= 0x11 << channel;
+		{
+			m_mask |= 0x11 << channel;
+		}
 		else
-			i8237->mask &= ~(0x11 << channel);
+		{
+			m_mask &= ~(0x11 << channel);
+		}
 		break;
+	}
 
 	case 11:
+	{
 		/* DMA mode register */
-		channel = DMA_MODE_CHANNEL(data);
-		i8237->chan[channel].mode = data;
+		int channel = DMA_MODE_CHANNEL(data);
+		m_chan[channel].m_mode = data;
 		/* Apparently mode writes also clear the TC bit(?) */
-		i8237->status &= ~ ( 1 << channel );
+		m_status &= ~ ( 1 << channel );
 		break;
+	}
 
 	case 12:
 		/* DMA clear byte pointer flip-flop */
-		i8237->temp = data;
-		i8237->msb = 0;
+		m_temp = data;
+		m_msb = 0;
 		break;
 
 	case 13:
 		/* DMA master clear */
-		i8237->msb = 0;
-		i8237->mask = 0x0f;
-		i8237->state = DMA8237_SI;
-		i8237->status &= 0xF0;
+		m_msb = 0;
+		m_mask = 0x0f;
+		m_state = DMA8237_SI;
+		m_status &= 0xF0;
 		break;
 
 	case 14:
 		/* DMA clear mask register */
-		i8237->mask &= ~data;
-		i8237->mask = 0;
+		m_mask &= ~data;
+		m_mask = 0;
 		break;
 
 	case 15:
 		/* DMA write mask register */
-		i8237->mask = data & 0x0f;
+		m_mask = data & 0x0f;
 		break;
 	}
 }
 
 
-
-static void dma8237_drq_write(running_device *device, int channel, int state)
+void i8237_device::i8237_drq_write(int channel, int state)
 {
-	i8237_t	*i8237 = get_safe_token( device );
-
 	if (state)
-		i8237->drq |= ( 0x01 << channel );
+	{
+		m_drq |= ( 0x01 << channel );
+	}
 	else
-		i8237->drq &= ~( 0x01 << channel );
-
-	timer_enable( i8237->timer, ( i8237->command & 0x04 ) ? 0 : 1 );
-}
-
-WRITE_LINE_DEVICE_HANDLER( i8237_hlda_w )
-{
-	i8237_t	*i8237 = get_safe_token( device );
-
-	i8237->hlda = state;
-}
-
-WRITE_LINE_DEVICE_HANDLER( i8237_ready_w )
-{
-}
-
-WRITE_LINE_DEVICE_HANDLER( i8237_dreq0_w ) { dma8237_drq_write(device, 0, state); }
-WRITE_LINE_DEVICE_HANDLER( i8237_dreq1_w ) { dma8237_drq_write(device, 1, state); }
-WRITE_LINE_DEVICE_HANDLER( i8237_dreq2_w ) { dma8237_drq_write(device, 2, state); }
-WRITE_LINE_DEVICE_HANDLER( i8237_dreq3_w ) { dma8237_drq_write(device, 3, state); }
-
-WRITE_LINE_DEVICE_HANDLER( i8237_eop_w )
-{
-}
-
-
-static DEVICE_START( i8237 ) {
-	i8237_t	*i8237 = get_safe_token(device);
-	i8237_interface *intf = (i8237_interface *)device->baseconfig().static_config();
-	int i;
-
-	/* resolve callbacks */
-	devcb_resolve_write_line(&i8237->out_hrq_func, &intf->out_hrq_func, device);
-	devcb_resolve_write_line(&i8237->out_eop_func, &intf->out_eop_func, device);
-	devcb_resolve_read8(&i8237->in_memr_func, &intf->in_memr_func, device);
-	devcb_resolve_write8(&i8237->out_memw_func, &intf->out_memw_func, device);
-
-	for (i = 0; i < 4; i++)
 	{
-		devcb_resolve_read8(&i8237->chan[i].in_ior_func, &intf->in_ior_func[i], device);
-		devcb_resolve_write8(&i8237->chan[i].out_iow_func, &intf->out_iow_func[i], device);
-		devcb_resolve_write_line(&i8237->chan[i].out_dack_func, &intf->out_dack_func[i], device);
+		m_drq &= ~( 0x01 << channel );
 	}
 
-	i8237->timer = timer_alloc(device->machine, dma8237_timerproc, (void *)device);
-}
-
-
-static DEVICE_RESET( i8237 ) {
-	i8237_t	*i8237 = get_safe_token(device);
-
-	i8237->status = 0x0F;
-	i8237->eop = 1;
-	i8237->state = DMA8237_SI;
-	i8237->last_service_channel = 3;
-
-	i8237->mask = 0x00;
-	i8237->status = 0x0F;
-	i8237->hrq = 0;
-	i8237->hlda = 0;
-	i8237->chan[0].mode = 0;
-	i8237->chan[1].mode = 0;
-	i8237->chan[2].mode = 0;
-	i8237->chan[3].mode = 0;
-
-	timer_adjust_periodic(i8237->timer,
-		ATTOTIME_IN_HZ(device->clock()),
-		0,
-		ATTOTIME_IN_HZ(device->clock()));
+	timer_enable( m_timer, ( m_command & 0x04 ) ? 0 : 1 );
 }
 
 
-DEVICE_GET_INFO( i8237 ) {
-	switch ( state ) {
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:				info->i = sizeof(i8237_t);				break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:		info->i = 0;								break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(i8237);	break;
-		case DEVINFO_FCT_STOP:						/* nothing */								break;
-		case DEVINFO_FCT_RESET:						info->reset = DEVICE_RESET_NAME(i8237);	break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "Intel 8237");			break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Intel 8080");					break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.01");					break;
-		case DEVINFO_STR_SOURCE_FILE:				strcpy(info->s, __FILE__);					break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright the MAME and MESS Teams");	break;
-	}
-}
 
+/***************************************************************************
+    TRAMPOLINES
+***************************************************************************/
 
-DEFINE_LEGACY_DEVICE(I8237, i8237);
+WRITE_LINE_DEVICE_HANDLER( i8237_hlda_w ) { downcast<i8237_device*>(device)->i8237_hlda_w(state); }
+WRITE_LINE_DEVICE_HANDLER( i8237_ready_w ) { }
+WRITE_LINE_DEVICE_HANDLER( i8237_dreq0_w ) { downcast<i8237_device*>(device)->i8237_drq_write(0, state); }
+WRITE_LINE_DEVICE_HANDLER( i8237_dreq1_w ) { downcast<i8237_device*>(device)->i8237_drq_write(1, state); }
+WRITE_LINE_DEVICE_HANDLER( i8237_dreq2_w ) { downcast<i8237_device*>(device)->i8237_drq_write(2, state); }
+WRITE_LINE_DEVICE_HANDLER( i8237_dreq3_w ) { downcast<i8237_device*>(device)->i8237_drq_write(3, state); }
+WRITE_LINE_DEVICE_HANDLER( i8237_eop_w ) { }
diff -Nru src-old/emu/machine/8237dma.h src/emu/machine/8237dma.h
--- src-old/emu/machine/8237dma.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/8237dma.h	2010-08-26 15:00:49.000000000 -0700
@@ -30,18 +30,19 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __I8237__
 #define __I8237__
 
-#include "devlegcy.h"
+#include "emu.h"
+
 
 
 /***************************************************************************
-    MACROS / CONSTANTS
+    DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(I8237, i8237);
-
 #define MDRV_I8237_ADD(_tag, _clock, _config) \
 	MDRV_DEVICE_ADD(_tag, I8237, _clock) \
 	MDRV_DEVICE_CONFIG(_config)
@@ -49,26 +50,164 @@
 #define I8237_INTERFACE(_name) \
 	const i8237_interface (_name) =
 
+
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _i8237_interface i8237_interface;
-struct _i8237_interface
+
+// ======================> i8237_interface
+
+struct i8237_interface
 {
-	devcb_write_line	out_hrq_func;
-	devcb_write_line	out_eop_func;
+	devcb_write_line	m_out_hrq_func;
+	devcb_write_line	m_out_eop_func;
 
 	/* accessors to main memory */
-	devcb_read8			in_memr_func;
-	devcb_write8		out_memw_func;
+	devcb_read8			m_in_memr_func;
+	devcb_write8		m_out_memw_func;
 
 	/* channel accessors */
-	devcb_read8			in_ior_func[4];
-	devcb_write8		out_iow_func[4];
-	devcb_write_line	out_dack_func[4];
+	devcb_read8			m_in_ior_func[4];
+	devcb_write8		m_out_iow_func[4];
+	devcb_write_line	m_out_dack_func[4];
+};
+
+
+
+// ======================> i8237_device_config
+
+class i8237_device_config : public device_config,
+                            public i8237_interface
+{
+    friend class i8237_device;
+
+    // construction/destruction
+    i8237_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
 };
 
+
+
+// ======================> i8237_device
+
+class i8237_device :  public device_t
+{
+    friend class i8237_device_config;
+
+    // construction/destruction
+    i8237_device(running_machine &_machine, const i8237_device_config &_config);
+
+public:
+
+	/* register access */
+	UINT8 i8237_r(UINT32 offset);
+	void i8237_w(UINT32 offset, UINT8 data);
+
+	/* hold acknowledge */
+	void i8237_hlda_w(UINT8 state) { m_hlda = state; }
+
+	/* data request */
+	void i8237_drq_write(int channel, int state);
+
+	void i8237_timerproc();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( i8237_timerproc_callback );
+	static TIMER_CALLBACK( receive_event_callback );
+
+private:
+
+	void i8237_do_read();
+	void i8237_do_write();
+	void i8237_advance();
+	void i8327_set_dack(int channel);
+
+	/* States that the i8237 device can be in */
+	enum dma8237_state
+	{
+		DMA8237_SI,			/* Idle state */
+		DMA8237_S0,			/* HRQ has been triggered, waiting to receive HLDA */
+	//  DMA8237_SW,         /* Wait state */
+
+		/* Normal transfer states */
+		DMA8237_S1,			/* Output A8-A15; only used when A8-A15 really needs to be output */
+		DMA8237_S2,			/* Output A0-A7 */
+		DMA8237_S3,			/* Initiate read; skipped in compressed timing. On the S2->S3 transition DACK is set. */
+		DMA8237_S4,			/* Perform read/write */
+
+		/* Memory to memory transfer states */
+		DMA8237_S11,		/* Output A8-A15 */
+	//  DMA8237_S12,        /* Output A0-A7 */
+	//  DMA8237_S13,        /* Initiate read */
+	//  DMA8237_S14,        /* Perform read/write */
+	//  DMA8237_S21,        /* Output A8-A15 */
+	//  DMA8237_S22,        /* Output A0-A7 */
+	//  DMA8237_S23,        /* Initiate read */
+	//  DMA8237_S24,        /* Perform read/write */
+	};
+
+	devcb_resolved_write_line	m_out_hrq_func;
+	devcb_resolved_write_line	m_out_eop_func;
+	devcb_resolved_read8		m_in_memr_func;
+	devcb_resolved_write8		m_out_memw_func;
+
+	emu_timer *m_timer;
+
+	struct
+	{
+		devcb_resolved_read8		m_in_ior_func;
+		devcb_resolved_write8		m_out_iow_func;
+		devcb_resolved_write_line	m_out_dack_func;
+		UINT16 m_base_address;
+		UINT16 m_base_count;
+		UINT16 m_address;
+		UINT16 m_count;
+		UINT8 m_mode;
+		int m_high_address_changed;
+	} m_chan[4];
+
+	UINT32 m_msb : 1;
+	UINT32 m_eop : 1;
+	UINT8 m_temp;
+	UINT8 m_temporary_data;
+	UINT8 m_command;
+	UINT8 m_drq;
+	UINT8 m_mask;
+	UINT8 m_hrq;
+	UINT8 m_hlda;
+
+	/* bits  0- 3 :  Terminal count for channels 0-3
+     * bits  4- 7 :  Transfer in progress for channels 0-3 */
+	UINT8 m_status;
+
+	dma8237_state m_state;		/* State the device is currently in */
+	int m_service_channel;		/* Channel we will be servicing */
+	int m_last_service_channel;	/* Previous channel we serviced; used to determine channel priority. */
+
+    const i8237_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type I8237;
+
+
+
 /***************************************************************************
     PROTOTYPES
 ***************************************************************************/
diff -Nru src-old/emu/machine/8255ppi.c src/emu/machine/8255ppi.c
--- src-old/emu/machine/8255ppi.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/8255ppi.c	2010-08-28 09:48:51.000000000 -0700
@@ -92,96 +92,163 @@
 
 #include "emu.h"
 #include "8255ppi.h"
+#include "devhelpr.h"
 
-typedef struct _ppi8255 ppi8255_t;
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-struct _ppi8255
+GENERIC_DEVICE_CONFIG_SETUP(ppi8255, "Intel PPI8255")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void ppi8255_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const ppi8255_interface *intf = reinterpret_cast<const ppi8255_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<ppi8255_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_port_a_read, 0, sizeof(m_port_a_read));
+    	memset(&m_port_b_read, 0, sizeof(m_port_b_read));
+    	memset(&m_port_c_read, 0, sizeof(m_port_c_read));
+    	memset(&m_port_a_write, 0, sizeof(m_port_a_write));
+    	memset(&m_port_b_write, 0, sizeof(m_port_b_write));
+    	memset(&m_port_c_write, 0, sizeof(m_port_c_write));
+	}
+}
+
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type PPI8255 = ppi8255_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  ppi8255_device - constructor
+//-------------------------------------------------
+
+ppi8255_device::ppi8255_device(running_machine &_machine, const ppi8255_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	const ppi8255_interface	*intf;
 
-	devcb_resolved_read8 port_read[3];
-	devcb_resolved_write8 port_write[3];
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ppi8255_device::device_start()
+{
+	devcb_resolve_read8(&m_port_read[0], &m_config.m_port_a_read, this);
+	devcb_resolve_read8(&m_port_read[1], &m_config.m_port_b_read, this);
+	devcb_resolve_read8(&m_port_read[2], &m_config.m_port_c_read, this);
 
-	/* mode flags */
-	UINT8 group_a_mode;
-	UINT8 group_b_mode;
-	UINT8 port_a_dir;
-	UINT8 port_b_dir;
-	UINT8 port_ch_dir;
-	UINT8 port_cl_dir;
+	devcb_resolve_write8(&m_port_write[0], &m_config.m_port_a_write, this);
+	devcb_resolve_write8(&m_port_write[1], &m_config.m_port_b_write, this);
+	devcb_resolve_write8(&m_port_write[2], &m_config.m_port_c_write, this);
 
-	/* handshake signals (1=asserted; 0=non-asserted) */
-	UINT8 obf_a;
-	UINT8 obf_b;
-	UINT8 ibf_a;
-	UINT8 ibf_b;
-	UINT8 inte_a;
-	UINT8 inte_b;
-	UINT8 inte_1;
-	UINT8 inte_2;
+	/* register for state saving */
+	state_save_register_device_item(this, 0, m_group_a_mode);
+	state_save_register_device_item(this, 0, m_group_b_mode);
+	state_save_register_device_item(this, 0, m_port_a_dir);
+	state_save_register_device_item(this, 0, m_port_b_dir);
+	state_save_register_device_item(this, 0, m_port_ch_dir);
+	state_save_register_device_item(this, 0, m_port_cl_dir);
+	state_save_register_device_item(this, 0, m_obf_a);
+	state_save_register_device_item(this, 0, m_obf_b);
+	state_save_register_device_item(this, 0, m_ibf_a);
+	state_save_register_device_item(this, 0, m_ibf_b);
+	state_save_register_device_item(this, 0, m_inte_a);
+	state_save_register_device_item(this, 0, m_inte_b);
+	state_save_register_device_item(this, 0, m_inte_1);
+	state_save_register_device_item(this, 0, m_inte_2);
+	state_save_register_device_item_array(this, 0, m_in_mask);
+	state_save_register_device_item_array(this, 0, m_out_mask);
+	state_save_register_device_item_array(this, 0, m_read);
+	state_save_register_device_item_array(this, 0, m_latch);
+}
 
-	UINT8 in_mask[3];	/* input mask */
-	UINT8 out_mask[3];	/* output mask */
-	UINT8 read[3];		/* data read from ports */
-	UINT8 latch[3];		/* data written to ports */
-	UINT8 output[3];	/* actual output data */
-	UINT8 control;		/* mode control word */
-};
 
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
 
-static void set_mode(running_device *device, int data, int call_handlers);
-static void ppi8255_write_port(running_device *device, int port);
+void ppi8255_device::device_reset()
+{
+	m_group_a_mode = 0;
+	m_group_b_mode = 0;
+	m_port_a_dir = 0;
+	m_port_b_dir = 0;
+	m_port_ch_dir = 0;
+	m_port_cl_dir = 0;
+	m_obf_a = m_ibf_a = 0;
+	m_obf_b = m_ibf_b = 0;
+	m_inte_a = m_inte_b = m_inte_1 = m_inte_2 = 0;
 
+	for (int i = 0; i < 3; i++)
+	{
+		m_in_mask[i] = m_out_mask[i] = m_read[i] = m_latch[i] = m_output[i] = 0;
+	}
 
-INLINE ppi8255_t *get_safe_token(running_device *device) {
-	assert( device != NULL );
-	assert( device->type() == PPI8255 );
-	return ( ppi8255_t * ) downcast<legacy_device_base *>(device)->token();
+	set_mode(0x9b, 0);   /* Mode 0, all ports set to input */
 }
 
 
-INLINE void ppi8255_get_handshake_signals(ppi8255_t *ppi8255, int is_read, UINT8 *result)
+void ppi8255_device::ppi8255_get_handshake_signals(int is_read, UINT8 *result)
 {
 	UINT8 handshake = 0x00;
 	UINT8 mask = 0x00;
 
 	/* group A */
-	if (ppi8255->group_a_mode == 1)
+	if (m_group_a_mode == 1)
 	{
-		if (ppi8255->port_a_dir)
+		if (m_port_a_dir)
 		{
-			handshake |= ppi8255->ibf_a ? 0x20 : 0x00;
-			handshake |= (ppi8255->ibf_a && ppi8255->inte_a) ? 0x08 : 0x00;
+			handshake |= m_ibf_a ? 0x20 : 0x00;
+			handshake |= (m_ibf_a && m_inte_a) ? 0x08 : 0x00;
 			mask |= 0x28;
 		}
 		else
 		{
-			handshake |= ppi8255->obf_a ? 0x00 : 0x80;
-			handshake |= (ppi8255->obf_a && ppi8255->inte_a) ? 0x08 : 0x00;
+			handshake |= m_obf_a ? 0x00 : 0x80;
+			handshake |= (m_obf_a && m_inte_a) ? 0x08 : 0x00;
 			mask |= 0x88;
 		}
 	}
-	else if (ppi8255->group_a_mode == 2)
+	else if (m_group_a_mode == 2)
 	{
-		handshake |= ppi8255->obf_a ? 0x00 : 0x80;
-		handshake |= ppi8255->ibf_a ? 0x20 : 0x00;
-		handshake |= ((ppi8255->obf_a && ppi8255->inte_1) || (ppi8255->ibf_a && ppi8255->inte_2)) ? 0x08 : 0x00;
+		handshake |= m_obf_a ? 0x00 : 0x80;
+		handshake |= m_ibf_a ? 0x20 : 0x00;
+		handshake |= ((m_obf_a && m_inte_1) || (m_ibf_a && m_inte_2)) ? 0x08 : 0x00;
 		mask |= 0xA8;
 	}
 
 	/* group B */
-	if (ppi8255->group_b_mode == 1)
+	if (m_group_b_mode == 1)
 	{
-		if (ppi8255->port_b_dir)
+		if (m_port_b_dir)
 		{
-			handshake |= ppi8255->ibf_b ? 0x02 : 0x00;
-			handshake |= (ppi8255->ibf_b && ppi8255->inte_b) ? 0x01 : 0x00;
+			handshake |= m_ibf_b ? 0x02 : 0x00;
+			handshake |= (m_ibf_b && m_inte_b) ? 0x01 : 0x00;
 			mask |= 0x03;
 		}
 		else
 		{
-			handshake |= ppi8255->obf_b ? 0x00 : 0x02;
-			handshake |= (ppi8255->obf_b && ppi8255->inte_b) ? 0x01 : 0x00;
+			handshake |= m_obf_b ? 0x00 : 0x02;
+			handshake |= (m_obf_b && m_inte_b) ? 0x01 : 0x00;
 			mask |= 0x03;
 		}
 	}
@@ -192,92 +259,90 @@
 
 
 
-static void ppi8255_input(running_device *device, int port, UINT8 data)
+void ppi8255_device::ppi8255_input(int port, UINT8 data)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
 	int changed = 0;
 
-	ppi8255->read[port] = data;
+	m_read[port] = data;
 
 	/* port C is special */
 	if (port == 2)
 	{
-		if (((ppi8255->group_a_mode == 1) && (ppi8255->port_a_dir == 0)) || (ppi8255->group_a_mode == 2))
+		if (((m_group_a_mode == 1) && (m_port_a_dir == 0)) || (m_group_a_mode == 2))
 		{
 			/* is !ACKA asserted? */
-			if (ppi8255->obf_a && !(data & 0x40))
+			if (m_obf_a && !(data & 0x40))
 			{
-				ppi8255->obf_a = 0;
+				m_obf_a = 0;
 				changed = 1;
 			}
 		}
 
-		if (((ppi8255->group_a_mode == 1) && (ppi8255->port_a_dir == 1)) || (ppi8255->group_a_mode == 2))
+		if (((m_group_a_mode == 1) && (m_port_a_dir == 1)) || (m_group_a_mode == 2))
 		{
 			/* is !STBA asserted? */
-			if (!ppi8255->ibf_a && !(data & 0x10))
+			if (!m_ibf_a && !(data & 0x10))
 			{
-				ppi8255->ibf_a = 1;
+				m_ibf_a = 1;
 				changed = 1;
 			}
 		}
 
-		if ((ppi8255->group_b_mode == 1) && (ppi8255->port_b_dir == 0))
+		if ((m_group_b_mode == 1) && (m_port_b_dir == 0))
 		{
 			/* is !ACKB asserted? */
-			if (ppi8255->obf_b && !(data & 0x04))
+			if (m_obf_b && !(data & 0x04))
 			{
-				ppi8255->obf_b = 0;
+				m_obf_b = 0;
 				changed = 1;
 			}
 		}
 
-		if ((ppi8255->group_b_mode == 1) && (ppi8255->port_b_dir == 1))
+		if ((m_group_b_mode == 1) && (m_port_b_dir == 1))
 		{
 			/* is !STBB asserted? */
-			if (!ppi8255->ibf_b && !(data & 0x04))
+			if (!m_ibf_b && !(data & 0x04))
 			{
-				ppi8255->ibf_b = 1;
+				m_ibf_b = 1;
 				changed = 1;
 			}
 		}
 
 		if (changed)
-			ppi8255_write_port(device, 2);
+		{
+			ppi8255_write_port(2);
+		}
 	}
 }
 
 
 
-static UINT8 ppi8255_read_port(running_device *device, int port)
+UINT8 ppi8255_device::ppi8255_read_port(int port)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
 	UINT8 result = 0x00;
 
-	if (ppi8255->in_mask[port])
+	if (m_in_mask[port])
 	{
-		if (ppi8255->port_read[port].read != NULL)
-			ppi8255_input(device, port, devcb_call_read8(&ppi8255->port_read[port], 0));
-
-		result |= ppi8255->read[port] & ppi8255->in_mask[port];
+		ppi8255_input(port, devcb_call_read8(&m_port_read[port], 0));
+		result |= m_read[port] & m_in_mask[port];
 	}
-	result |= ppi8255->latch[port] & ppi8255->out_mask[port];
+	result |= m_latch[port] & m_out_mask[port];
 
 	switch (port)
 	{
 	case 0:
 		/* clear input buffer full flag */
-		ppi8255->ibf_a = 0;
+		m_ibf_a = 0;
 		break;
 
 	case 1:
 		/* clear input buffer full flag */
-		ppi8255->ibf_b = 0;
+		m_ibf_b = 0;
 		break;
 
 	case 2:
 		/* read special port 2 signals */
-		ppi8255_get_handshake_signals(ppi8255, 1, &result);
+		ppi8255_get_handshake_signals(1, &result);
 		break;
 	}
 
@@ -286,9 +351,8 @@
 
 
 
-READ8_DEVICE_HANDLER( ppi8255_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(ppi8255, ppi8255_r)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
 	UINT8 result = 0;
 
 	offset %= 4;
@@ -298,11 +362,11 @@
 		case 0: /* Port A read */
 		case 1: /* Port B read */
 		case 2: /* Port C read */
-			result = ppi8255_read_port(device, offset);
+			result = ppi8255_read_port(offset);
 			break;
 
 		case 3: /* Control word */
-			result = ppi8255->control;
+			result = m_control;
 			break;
 	}
 
@@ -311,29 +375,25 @@
 
 
 
-static void ppi8255_write_port(running_device *device, int port)
+void ppi8255_device::ppi8255_write_port(int port)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	UINT8 write_data;
-
-	write_data = ppi8255->latch[port] & ppi8255->out_mask[port];
-	write_data |= 0xFF & ~ppi8255->out_mask[port];
+	UINT8 write_data = m_latch[port] & m_out_mask[port];
+	write_data |= 0xFF & ~m_out_mask[port];
 
 	/* write out special port 2 signals */
 	if (port == 2)
-		ppi8255_get_handshake_signals(ppi8255, 0, &write_data);
+	{
+		ppi8255_get_handshake_signals(0, &write_data);
+	}
 
-	ppi8255->output[port] = write_data;
-	if (ppi8255->port_write[port].write != NULL)
-		devcb_call_write8(&ppi8255->port_write[port], 0, write_data);
+	m_output[port] = write_data;
+	devcb_call_write8(&m_port_write[port], 0, write_data);
 }
 
 
 
-WRITE8_DEVICE_HANDLER( ppi8255_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ppi8255, ppi8255_w)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-
 	offset %= 4;
 
 	switch( offset )
@@ -341,24 +401,24 @@
 		case 0: /* Port A write */
 		case 1: /* Port B write */
 		case 2: /* Port C write */
-			ppi8255->latch[offset] = data;
-			ppi8255_write_port(device, offset);
+			m_latch[offset] = data;
+			ppi8255_write_port(offset);
 
 			switch(offset)
 			{
 				case 0:
-					if (!ppi8255->port_a_dir && (ppi8255->group_a_mode != 0))
+					if (!m_port_a_dir && (m_group_a_mode != 0))
 					{
-						ppi8255->obf_a = 1;
-						ppi8255_write_port(device, 2);
+						m_obf_a = 1;
+						ppi8255_write_port(2);
 					}
 					break;
 
 				case 1:
-					if (!ppi8255->port_b_dir && (ppi8255->group_b_mode != 0))
+					if (!m_port_b_dir && (m_group_b_mode != 0))
 					{
-						ppi8255->obf_b = 1;
-						ppi8255_write_port(device, 2);
+						m_obf_b = 1;
+						ppi8255_write_port(2);
 					}
 					break;
 			}
@@ -367,129 +427,134 @@
 		case 3: /* Control word */
 			if (data & 0x80)
 			{
-				set_mode(device, data & 0x7f, 1);
+				set_mode(data & 0x7f, 1);
 			}
 			else
 			{
 				/* bit set/reset */
-				int bit;
-
-				bit = (data >> 1) & 0x07;
+				int bit = (data >> 1) & 0x07;
 
 				if (data & 1)
-					ppi8255->latch[2] |= (1<<bit);	/* set bit */
+				{
+					m_latch[2] |= (1 << bit);	/* set bit */
+				}
 				else
-					ppi8255->latch[2] &= ~(1<<bit);	/* reset bit */
+				{
+					m_latch[2] &= ~(1 << bit);	/* reset bit */
+				}
 
-				if (ppi8255->group_b_mode == 1)
+				if (m_group_b_mode == 1)
 				{
-					if (bit == 2) ppi8255->inte_b = data & 1;
+					if (bit == 2)
+					{
+						m_inte_b = data & 1;
+					}
 				}
 
-				if (ppi8255->group_a_mode == 1)
+				if (m_group_a_mode == 1)
 				{
-					if (bit == 4 && ppi8255->port_a_dir) ppi8255->inte_a = data & 1;
-					if (bit == 6 && !ppi8255->port_a_dir) ppi8255->inte_a = data & 1;
+					if (bit == 4 && m_port_a_dir)
+					{
+						m_inte_a = data & 1;
+					}
+					if (bit == 6 && !m_port_a_dir)
+					{
+						m_inte_a = data & 1;
+					}
 				}
 
-				if (ppi8255->group_a_mode == 2)
+				if (m_group_a_mode == 2)
 				{
-					if (bit == 4) ppi8255->inte_2 = data & 1;
-					if (bit == 6) ppi8255->inte_1 = data & 1;
+					if (bit == 4)
+					{
+						m_inte_2 = data & 1;
+					}
+					if (bit == 6)
+					{
+						m_inte_1 = data & 1;
+					}
 				}
 
-				ppi8255_write_port(device, 2);
+				ppi8255_write_port(2);
 			}
 			break;
 	}
 }
 
 
-void ppi8255_set_port_a_read(running_device *device, const devcb_read8 *config)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_read8(&ppi8255->port_read[0], config, device);
-}
-
-void ppi8255_set_port_b_read(running_device *device, const devcb_read8 *config)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_read8(&ppi8255->port_read[1], config, device);
-}
-
-void ppi8255_set_port_c_read(running_device *device, const devcb_read8 *config)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_read8(&ppi8255->port_read[2], config, device);
-}
-
-
-void ppi8255_set_port_a_write(running_device *device, const devcb_write8 *config)
+void ppi8255_device::set_mode(int data, int call_handlers)
 {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_write8(&ppi8255->port_write[0], config, device);
-}
-
-void ppi8255_set_port_b_write(running_device *device, const devcb_write8 *config)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_write8(&ppi8255->port_write[1], config, device);
-}
-
-void ppi8255_set_port_c_write(running_device *device, const devcb_write8 *config)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	devcb_resolve_write8(&ppi8255->port_write[2], config, device);
-}
-
-
-static void set_mode(running_device *device, int data, int call_handlers)
-{
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	int i;
-
 	/* parse out mode */
-	ppi8255->group_a_mode = (data >> 5) & 3;
-	ppi8255->group_b_mode = (data >> 2) & 1;
-	ppi8255->port_a_dir = (data >> 4) & 1;
-	ppi8255->port_b_dir = (data >> 1) & 1;
-	ppi8255->port_ch_dir = (data >> 3) & 1;
-	ppi8255->port_cl_dir = (data >> 0) & 1;
+	m_group_a_mode = (data >> 5) & 3;
+	m_group_b_mode = (data >> 2) & 1;
+	m_port_a_dir = (data >> 4) & 1;
+	m_port_b_dir = (data >> 1) & 1;
+	m_port_ch_dir = (data >> 3) & 1;
+	m_port_cl_dir = (data >> 0) & 1;
 
 	/* normalize group_a_mode */
-	if (ppi8255->group_a_mode == 3)
-		ppi8255->group_a_mode = 2;
+	if (m_group_a_mode == 3)
+	{
+		m_group_a_mode = 2;
+	}
 
 	/* Port A direction */
-	if (ppi8255->group_a_mode == 2)
-		ppi8255->in_mask[0] = 0xFF, ppi8255->out_mask[0] = 0xFF;	/* bidirectional */
+	if (m_group_a_mode == 2)
+	{
+		m_in_mask[0] = 0xFF;
+		m_out_mask[0] = 0xFF;	/* bidirectional */
+	}
 	else
-		if (ppi8255->port_a_dir)
-			ppi8255->in_mask[0] = 0xFF, ppi8255->out_mask[0] = 0x00;	/* input */
+	{
+		if (m_port_a_dir)
+		{
+			m_in_mask[0] = 0xFF;
+			m_out_mask[0] = 0x00;	/* input */
+		}
 		else
-			ppi8255->in_mask[0] = 0x00, ppi8255->out_mask[0] = 0xFF;	/* output */
+		{
+			m_in_mask[0] = 0x00;
+			m_out_mask[0] = 0xFF;	/* output */
+		}
+	}
 
 	/* Port B direction */
-	if (ppi8255->port_b_dir)
-		ppi8255->in_mask[1] = 0xFF, ppi8255->out_mask[1] = 0x00;	/* input */
+	if (m_port_b_dir)
+	{
+		m_in_mask[1] = 0xFF;
+		m_out_mask[1] = 0x00;	/* input */
+	}
 	else
-		ppi8255->in_mask[1] = 0x00, ppi8255->out_mask[1] = 0xFF;	/* output */
+	{
+		m_in_mask[1] = 0x00;
+		m_out_mask[1] = 0xFF;	/* output */
+	}
 
 	/* Port C upper direction */
-	if (ppi8255->port_ch_dir)
-		ppi8255->in_mask[2] = 0xF0, ppi8255->out_mask[2] = 0x00;	/* input */
+	if (m_port_ch_dir)
+	{
+		m_in_mask[2] = 0xF0;
+		m_out_mask[2] = 0x00;	/* input */
+	}
 	else
-		ppi8255->in_mask[2] = 0x00, ppi8255->out_mask[2] = 0xF0;	/* output */
+	{
+		m_in_mask[2] = 0x00;
+		m_out_mask[2] = 0xF0;	/* output */
+	}
 
 	/* Port C lower direction */
-	if (ppi8255->port_cl_dir)
-		ppi8255->in_mask[2] |= 0x0F;	/* input */
+	if (m_port_cl_dir)
+	{
+		m_in_mask[2] |= 0x0F;	/* input */
+	}
 	else
-		ppi8255->out_mask[2] |= 0x0F;	/* output */
+	{
+		m_out_mask[2] |= 0x0F;	/* output */
+	}
 
 	/* now depending on the group modes, certain Port C lines may be replaced
      * with varying control signals */
-	switch(ppi8255->group_a_mode)
+	switch(m_group_a_mode)
 	{
 		case 0:	/* Group A mode 0 */
 			/* no changes */
@@ -497,18 +562,18 @@
 
 		case 1:	/* Group A mode 1 */
 			/* bits 5-3 are reserved by Group A mode 1 */
-			ppi8255->in_mask[2] &= ~0x38;
-			ppi8255->out_mask[2] &= ~0x38;
+			m_in_mask[2] &= ~0x38;
+			m_out_mask[2] &= ~0x38;
 			break;
 
 		case 2: /* Group A mode 2 */
 			/* bits 7-3 are reserved by Group A mode 2 */
-			ppi8255->in_mask[2] &= ~0xF8;
-			ppi8255->out_mask[2] &= ~0xF8;
+			m_in_mask[2] &= ~0xF8;
+			m_out_mask[2] &= ~0xF8;
 			break;
 	}
 
-	switch(ppi8255->group_b_mode)
+	switch(m_group_b_mode)
 	{
 		case 0:	/* Group B mode 0 */
 			/* no changes */
@@ -516,129 +581,90 @@
 
 		case 1:	/* Group B mode 1 */
 			/* bits 2-0 are reserved by Group B mode 1 */
-			ppi8255->in_mask[2] &= ~0x07;
-			ppi8255->out_mask[2] &= ~0x07;
+			m_in_mask[2] &= ~0x07;
+			m_out_mask[2] &= ~0x07;
 			break;
 	}
 
 	/* KT: 25-Dec-99 - 8255 resets latches when mode set */
-	ppi8255->latch[0] = ppi8255->latch[1] = ppi8255->latch[2] = 0;
+	m_latch[0] = m_latch[1] = m_latch[2] = 0;
 
 	if (call_handlers)
 	{
-		for (i = 0; i < 3; i++)
-			ppi8255_write_port(device, i);
+		for (int i = 0; i < 3; i++)
+		{
+			ppi8255_write_port(i);
+		}
 	}
 
 	/* reset flip-flops */
-	ppi8255->obf_a = ppi8255->ibf_a = 0;
-	ppi8255->obf_b = ppi8255->ibf_b = 0;
-	ppi8255->inte_a = ppi8255->inte_b = ppi8255->inte_1 = ppi8255->inte_2 = 0;
+	m_obf_a = m_ibf_a = 0;
+	m_obf_b = m_ibf_b = 0;
+	m_inte_a = m_inte_b = m_inte_1 = m_inte_2 = 0;
 
 	/* store control word */
-	ppi8255->control = data;
+	m_control = data;
 }
 
+void ppi8255_set_port_a_read(running_device *device, const devcb_read8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_read(0, config);
+}
 
-void ppi8255_set_port_a( running_device *device, UINT8 data ) { ppi8255_input(device, 0, data); }
-void ppi8255_set_port_b( running_device *device, UINT8 data ) { ppi8255_input(device, 1, data); }
-void ppi8255_set_port_c( running_device *device, UINT8 data ) { ppi8255_input(device, 2, data); }
-
-UINT8 ppi8255_get_port_a( running_device *device ) {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
+void ppi8255_set_port_b_read(running_device *device, const devcb_read8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_read(1, config);
+}
 
-	return ppi8255->output[0];
+void ppi8255_set_port_c_read(running_device *device, const devcb_read8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_read(2, config);
 }
 
-UINT8 ppi8255_get_port_b( running_device *device ) {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
 
-	return ppi8255->output[1];
+void ppi8255_set_port_a_write(running_device *device, const devcb_write8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_write(0, config);
 }
 
-UINT8 ppi8255_get_port_c( running_device *device ) {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
+void ppi8255_set_port_b_write(running_device *device, const devcb_write8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_write(1, config);
+}
 
-	return ppi8255->output[2];
+void ppi8255_set_port_c_write(running_device *device, const devcb_write8 *config)
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port_write(2, config);
 }
 
 
-static DEVICE_START( ppi8255 ) {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
+void ppi8255_set_port_a( running_device *device, UINT8 data )
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port(0, data);
+}
 
-	ppi8255->intf = (const ppi8255_interface *)device->baseconfig().static_config();
+void ppi8255_set_port_b( running_device *device, UINT8 data )
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port(1, data);
+}
 
-	devcb_resolve_read8(&ppi8255->port_read[0], &ppi8255->intf->port_a_read, device);
-	devcb_resolve_read8(&ppi8255->port_read[1], &ppi8255->intf->port_b_read, device);
-	devcb_resolve_read8(&ppi8255->port_read[2], &ppi8255->intf->port_c_read, device);
+void ppi8255_set_port_c( running_device *device, UINT8 data )
+{
+	downcast<ppi8255_device*>(device)->ppi8255_set_port(2, data);
+}
 
-	devcb_resolve_write8(&ppi8255->port_write[0], &ppi8255->intf->port_a_write, device);
-	devcb_resolve_write8(&ppi8255->port_write[1], &ppi8255->intf->port_b_write, device);
-	devcb_resolve_write8(&ppi8255->port_write[2], &ppi8255->intf->port_c_write, device);
 
-	/* register for state saving */
-	state_save_register_device_item(device, 0, ppi8255->group_a_mode);
-	state_save_register_device_item(device, 0, ppi8255->group_b_mode);
-	state_save_register_device_item(device, 0, ppi8255->port_a_dir);
-	state_save_register_device_item(device, 0, ppi8255->port_b_dir);
-	state_save_register_device_item(device, 0, ppi8255->port_ch_dir);
-	state_save_register_device_item(device, 0, ppi8255->port_cl_dir);
-	state_save_register_device_item(device, 0, ppi8255->obf_a);
-	state_save_register_device_item(device, 0, ppi8255->obf_b);
-	state_save_register_device_item(device, 0, ppi8255->ibf_a);
-	state_save_register_device_item(device, 0, ppi8255->ibf_b);
-	state_save_register_device_item(device, 0, ppi8255->inte_a);
-	state_save_register_device_item(device, 0, ppi8255->inte_b);
-	state_save_register_device_item(device, 0, ppi8255->inte_1);
-	state_save_register_device_item(device, 0, ppi8255->inte_2);
-	state_save_register_device_item_array(device, 0, ppi8255->in_mask);
-	state_save_register_device_item_array(device, 0, ppi8255->out_mask);
-	state_save_register_device_item_array(device, 0, ppi8255->read);
-	state_save_register_device_item_array(device, 0, ppi8255->latch);
-}
-
-
-static DEVICE_RESET( ppi8255 ) {
-	ppi8255_t	*ppi8255 = get_safe_token(device);
-	int			i;
-
-	ppi8255->group_a_mode = 0;
-	ppi8255->group_b_mode = 0;
-	ppi8255->port_a_dir = 0;
-	ppi8255->port_b_dir = 0;
-	ppi8255->port_ch_dir = 0;
-	ppi8255->port_cl_dir = 0;
-	ppi8255->obf_a = ppi8255->ibf_a = 0;
-	ppi8255->obf_b = ppi8255->ibf_b = 0;
-	ppi8255->inte_a = ppi8255->inte_b = ppi8255->inte_1 = ppi8255->inte_2 = 0;
-
-	for ( i = 0; i < 3; i++ ) {
-		ppi8255->in_mask[i] = ppi8255->out_mask[i] = ppi8255->read[i] = ppi8255->latch[i] = ppi8255->output[i] = 0;
-	}
-
-	set_mode(device, 0x9b, 0);   /* Mode 0, all ports set to input */
-}
-
-
-DEVICE_GET_INFO(ppi8255) {
-	switch ( state ) {
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:				info->i = sizeof(ppi8255_t);				break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:		info->i = 0;								break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(ppi8255);	break;
-		case DEVINFO_FCT_STOP:						/* nothing */								break;
-		case DEVINFO_FCT_RESET:						info->reset = DEVICE_RESET_NAME(ppi8255);	break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "Intel PPI8255");			break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "PPI8255");					break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.00");					break;
-		case DEVINFO_STR_SOURCE_FILE:				strcpy(info->s, __FILE__);					break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright the MAME and MESS Teams"); break;
-	}
+UINT8 ppi8255_get_port_a( running_device *device )
+{
+	return downcast<ppi8255_device*>(device)->ppi8255_get_port(0);
 }
 
+UINT8 ppi8255_get_port_b( running_device *device )
+{
+	return downcast<ppi8255_device*>(device)->ppi8255_get_port(1);
+}
 
-DEFINE_LEGACY_DEVICE(PPI8255, ppi8255);
+UINT8 ppi8255_get_port_c( running_device *device )
+{
+	return downcast<ppi8255_device*>(device)->ppi8255_get_port(2);
+}
diff -Nru src-old/emu/machine/8255ppi.h src/emu/machine/8255ppi.h
--- src-old/emu/machine/8255ppi.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/8255ppi.h	2010-08-28 09:48:51.000000000 -0700
@@ -6,29 +6,13 @@
 
 *********************************************************************/
 
-#ifndef __8255PPI_H_
-#define __8255PPI_H_
+#pragma once
 
-#include "devlegcy.h"
+#ifndef __8255PPI_H__
+#define __8255PPI_H__
 
+#include "emu.h"
 
-DECLARE_LEGACY_DEVICE(PPI8255, ppi8255);
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-typedef struct _ppi8255_interface ppi8255_interface;
-struct _ppi8255_interface
-{
-	devcb_read8 port_a_read;
-	devcb_read8 port_b_read;
-	devcb_read8 port_c_read;
-	devcb_write8 port_a_write;
-	devcb_write8 port_b_write;
-	devcb_write8 port_c_write;
-};
 
 
 /***************************************************************************
@@ -44,11 +28,136 @@
 	MDRV_DEVICE_CONFIG(_intrf)
 
 
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+
+// ======================> ppi8255_interface
+
+struct ppi8255_interface
+{
+	devcb_read8 m_port_a_read;
+	devcb_read8 m_port_b_read;
+	devcb_read8 m_port_c_read;
+	devcb_write8 m_port_a_write;
+	devcb_write8 m_port_b_write;
+	devcb_write8 m_port_c_write;
+};
+
+
+// ======================> ppi8255_device_config
+
+class ppi8255_device_config : public device_config,
+                              public ppi8255_interface
+{
+    friend class ppi8255_device;
+
+    // construction/destruction
+    ppi8255_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+// ======================> ppi8255_device
+
+class ppi8255_device :  public device_t
+{
+    friend class ppi8255_device_config;
+
+    // construction/destruction
+    ppi8255_device(running_machine &_machine, const ppi8255_device_config &_config);
+
+public:
+
+	UINT8 ppi8255_r(UINT32 offset);
+	void ppi8255_w(UINT32 offset, UINT8 data);
+
+	void ppi8255_set_port_read(int which, const devcb_read8 *config) { devcb_resolve_read8(&m_port_read[which], config, this); }
+	void ppi8255_set_port_write(int which, const devcb_write8 *config) { devcb_resolve_write8(&m_port_write[which], config, this); }
+
+	void ppi8255_set_port(int which, UINT8 data) { ppi8255_input(which, data); }
+	UINT8 ppi8255_get_port(int which) { return m_output[which]; }
+
+	void ppi8255_set_port_a(UINT8 data);
+	void ppi8255_set_port_b(UINT8 data);
+	void ppi8255_set_port_c(UINT8 data);
+
+	UINT8 ppi8255_get_port_a();
+	UINT8 ppi8255_get_port_b();
+	UINT8 ppi8255_get_port_c();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( callback );
+
+private:
+
+	void ppi8255_get_handshake_signals(int is_read, UINT8 *result);
+	void ppi8255_input(int port, UINT8 data);
+
+	UINT8 ppi8255_read_port(int port);
+	void ppi8255_write_port(int port);
+
+	void set_mode(int data, int call_handlers);
+
+	devcb_resolved_read8 m_port_read[3];
+	devcb_resolved_write8 m_port_write[3];
+
+	/* mode flags */
+	UINT8 m_group_a_mode;
+	UINT8 m_group_b_mode;
+	UINT8 m_port_a_dir;
+	UINT8 m_port_b_dir;
+	UINT8 m_port_ch_dir;
+	UINT8 m_port_cl_dir;
+
+	/* handshake signals (1=asserted; 0=non-asserted) */
+	UINT8 m_obf_a;
+	UINT8 m_obf_b;
+	UINT8 m_ibf_a;
+	UINT8 m_ibf_b;
+	UINT8 m_inte_a;
+	UINT8 m_inte_b;
+	UINT8 m_inte_1;
+	UINT8 m_inte_2;
+
+	UINT8 m_in_mask[3];		/* input mask */
+	UINT8 m_out_mask[3];	/* output mask */
+	UINT8 m_read[3];		/* data read from ports */
+	UINT8 m_latch[3];		/* data written to ports */
+	UINT8 m_output[3];		/* actual output data */
+	UINT8 m_control;		/* mode control word */
+
+    const ppi8255_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type PPI8255;
+
+
+
+/***************************************************************************
+    PROTOTYPES
+***************************************************************************/
 
 READ8_DEVICE_HANDLER( ppi8255_r );
 WRITE8_DEVICE_HANDLER( ppi8255_w );
 
-
 void ppi8255_set_port_a_read( running_device *device, const devcb_read8 *config );
 void ppi8255_set_port_b_read( running_device *device, const devcb_read8 *config );
 void ppi8255_set_port_c_read( running_device *device, const devcb_read8 *config );
diff -Nru src-old/emu/machine/8257dma.c src/emu/machine/8257dma.c
--- src-old/emu/machine/8257dma.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/8257dma.c	2010-08-28 09:48:51.000000000 -0700
@@ -32,6 +32,7 @@
 #include "emu.h"
 #include "memconv.h"
 #include "8257dma.h"
+#include "devhelpr.h"
 
 #define I8257_STATUS_UPDATE		0x10
 #define I8257_STATUS_TC_CH3		0x08
@@ -39,186 +40,273 @@
 #define I8257_STATUS_TC_CH1		0x02
 #define I8257_STATUS_TC_CH0		0x01
 
-
-typedef struct _dma8257_t i8257_t;
-struct _dma8257_t
-{
-	devcb_resolved_write_line	out_hrq_func;
-	devcb_resolved_write_line	out_tc_func;
-	devcb_resolved_write_line	out_mark_func;
-	devcb_resolved_read8		in_memr_func;
-	devcb_resolved_write8		out_memw_func;
-	devcb_resolved_read8		in_ior_func[I8257_NUM_CHANNELS];
-	devcb_resolved_write8		out_iow_func[I8257_NUM_CHANNELS];
-
-	emu_timer *timer;
-	emu_timer *msbflip_timer;
-
-	UINT16 registers[I8257_NUM_CHANNELS*2];
-
-	UINT16 address[I8257_NUM_CHANNELS];
-	UINT16 count[I8257_NUM_CHANNELS];
-	UINT8  rwmode[I8257_NUM_CHANNELS];
-
-	UINT8 mode;
-	UINT8 rr;
-
-	UINT8 msb;
-	UINT8 drq;
-
-	/* bits  0- 3 :  Terminal count for channels 0-3 */
-	UINT8 status;
-};
-
 #define DMA_MODE_AUTOLOAD(mode)		((mode) & 0x80)
 #define DMA_MODE_TCSTOP(mode)		((mode) & 0x40)
 #define DMA_MODE_EXWRITE(mode)		((mode) & 0x20)
 #define DMA_MODE_ROTPRIO(mode)		((mode) & 0x10)
 #define DMA_MODE_CH_EN(mode, chan)	((mode) & (1 << (chan)))
 
-static TIMER_CALLBACK( dma8257_timerproc );
-static TIMER_CALLBACK( dma8257_msbflip_timerproc );
-static void dma8257_update_status(running_device *device);
 
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+GENERIC_DEVICE_CONFIG_SETUP(i8257, "DMA8257")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void i8257_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const i8257_interface *intf = reinterpret_cast<const i8257_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<i8257_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_out_hrq_func, 0, sizeof(m_out_hrq_func));
+    	memset(&m_out_tc_func, 0, sizeof(m_out_tc_func));
+    	memset(&m_out_mark_func, 0, sizeof(m_out_mark_func));
+    	memset(&m_in_memr_func, 0, sizeof(m_in_memr_func));
+    	memset(&m_out_memw_func, 0, sizeof(m_out_memw_func));
+    	memset(&m_in_ior_func[0], 0, sizeof(m_in_ior_func[0]));
+    	memset(&m_in_ior_func[1], 0, sizeof(m_in_ior_func[1]));
+    	memset(&m_in_ior_func[2], 0, sizeof(m_in_ior_func[2]));
+    	memset(&m_in_ior_func[3], 0, sizeof(m_in_ior_func[3]));
+    	memset(&m_out_iow_func[0], 0, sizeof(m_out_iow_func[0]));
+    	memset(&m_out_iow_func[1], 0, sizeof(m_out_iow_func[1]));
+    	memset(&m_out_iow_func[2], 0, sizeof(m_out_iow_func[2]));
+    	memset(&m_out_iow_func[3], 0, sizeof(m_out_iow_func[3]));
+	}
+}
+
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type I8257 = i8257_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  i8257_device - constructor
+//-------------------------------------------------
+
+i8257_device::i8257_device(running_machine &_machine, const i8257_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
+
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void i8257_device::device_start()
+{
+	/* validate arguments */
+	assert(this != NULL);
+
+	/* resolve callbacks */
+	devcb_resolve_write_line(&m_out_hrq_func, &m_config.m_out_hrq_func, this);
+	devcb_resolve_write_line(&m_out_tc_func, &m_config.m_out_tc_func, this);
+	devcb_resolve_write_line(&m_out_mark_func, &m_config.m_out_mark_func, this);
+	devcb_resolve_read8(&m_in_memr_func, &m_config.m_in_memr_func, this);
+	devcb_resolve_write8(&m_out_memw_func, &m_config.m_out_memw_func, this);
+
+	for (int i = 0; i < I8257_NUM_CHANNELS; i++)
+	{
+		devcb_resolve_read8(&m_in_ior_func[i], &m_config.m_in_ior_func[i], this);
+		devcb_resolve_write8(&m_out_iow_func[i], &m_config.m_out_iow_func[i], this);
+	}
+
+	/* set initial values */
+	m_status = 0x0f;
+	m_timer = timer_alloc(&m_machine, i8257_timerproc_callback, (void *) this);
+	m_msbflip_timer = timer_alloc(&m_machine, i8257_msbflip_timerproc_callback, (void *) this);
+
+	/* register for state saving */
+	state_save_register_device_item_array(this, 0, m_address);
+	state_save_register_device_item_array(this, 0, m_count);
+	state_save_register_device_item_array(this, 0, m_rwmode);
+	state_save_register_device_item_array(this, 0, m_registers);
+	state_save_register_device_item(this, 0, m_mode);
+	state_save_register_device_item(this, 0, m_rr);
+	state_save_register_device_item(this, 0, m_msb);
+	state_save_register_device_item(this, 0, m_drq);
+	state_save_register_device_item(this, 0, m_status);
+}
 
-/* ----------------------------------------------------------------------- */
 
-INLINE i8257_t *get_safe_token(running_device *device) {
-	assert( device != NULL );
-	assert( device->type() == I8257 );
-	return ( i8257_t * ) downcast<legacy_device_base *>(device)->token();
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void i8257_device::device_reset()
+{
+	m_status &= 0xf0;
+	m_mode = 0;
+	i8257_update_status();
 }
 
-static int dma8257_do_operation(running_device *device, int channel)
+
+int i8257_device::i8257_do_operation(int channel)
 {
-	i8257_t *i8257 = get_safe_token(device);
 	int done;
 	UINT8 data;
-	UINT8 mode;
 
-	mode = i8257->rwmode[channel];
-	if (i8257->count[channel] == 0x0000)
+	UINT8 mode = m_rwmode[channel];
+	if (m_count[channel] == 0x0000)
 	{
-		i8257->status |=  (0x01 << channel);
+		m_status |=  (0x01 << channel);
 
-		devcb_call_write_line(&i8257->out_tc_func, ASSERT_LINE);
+		devcb_call_write_line(&m_out_tc_func, ASSERT_LINE);
 	}
 	switch(mode) {
 	case 1:
-		if (&i8257->in_memr_func.target != NULL) {
-			data = devcb_call_read8(&i8257->in_memr_func, i8257->address[channel]);
-		} else {
+		if (&m_in_memr_func.target != NULL)
+		{
+			data = devcb_call_read8(&m_in_memr_func, m_address[channel]);
+		}
+		else
+		{
 			data = 0;
 			logerror("8257: No memory read function defined.\n");
 		}
-		if (&i8257->out_iow_func[channel].target != NULL) {
-			devcb_call_write8(&i8257->out_iow_func[channel], 0, data);
-		} else {
+		if (&m_out_iow_func[channel].target != NULL)
+		{
+			devcb_call_write8(&m_out_iow_func[channel], 0, data);
+		}
+		else
+		{
 			logerror("8257: No channel write function for channel %d defined.\n",channel);
 		}
 
-		i8257->address[channel]++;
-		i8257->count[channel]--;
-		done = (i8257->count[channel] == 0xFFFF);
+		m_address[channel]++;
+		m_count[channel]--;
+		done = (m_count[channel] == 0xFFFF);
 		break;
 
 	case 2:
-		if (&i8257->in_ior_func[channel].target != NULL) {
-			data = devcb_call_read8(&i8257->in_ior_func[channel], 0);
-		} else {
+		if (&m_in_ior_func[channel].target != NULL)
+		{
+			data = devcb_call_read8(&m_in_ior_func[channel], 0);
+		}
+		else
+		{
 			data = 0;
 			logerror("8257: No channel read function for channel %d defined.\n",channel);
 		}
 
-		if (&i8257->out_memw_func.target != NULL) {
-			devcb_call_write8(&i8257->out_memw_func, i8257->address[channel], data);
-		} else {
+		if (&m_out_memw_func.target != NULL)
+		{
+			devcb_call_write8(&m_out_memw_func, m_address[channel], data);
+		}
+		else
+		{
 			logerror("8257: No memory write function defined.\n");
 		}
-		i8257->address[channel]++;
-		i8257->count[channel]--;
-		done = (i8257->count[channel] == 0xFFFF);
+		m_address[channel]++;
+		m_count[channel]--;
+		done = (m_count[channel] == 0xFFFF);
 		break;
 	case 0: /* verify */
-		i8257->address[channel]++;
-		i8257->count[channel]--;
-		done = (i8257->count[channel] == 0xFFFF);
+		m_address[channel]++;
+		m_count[channel]--;
+		done = (m_count[channel] == 0xFFFF);
 		break;
 	default:
-		fatalerror("dma8257_do_operation: invalid mode!\n");
+		fatalerror("i8257_do_operation: invalid mode!\n");
 		break;
 	}
 	if (done)
 	{
-		if ((channel==2) && DMA_MODE_AUTOLOAD(i8257->mode)) {
+		if ((channel==2) && DMA_MODE_AUTOLOAD(m_mode))
+		{
 			/* in case of autoload at the end channel 3 info is */
 			/* copied to channel 2 info                         */
-			i8257->registers[4] = i8257->registers[6];
-			i8257->registers[5] = i8257->registers[7];
+			m_registers[4] = m_registers[6];
+			m_registers[5] = m_registers[7];
 		}
 
-		devcb_call_write_line(&i8257->out_tc_func, CLEAR_LINE);
+		devcb_call_write_line(&m_out_tc_func, CLEAR_LINE);
 	}
 	return done;
 }
 
 
+TIMER_CALLBACK( i8257_device::i8257_timerproc_callback )
+{
+	reinterpret_cast<i8257_device*>(ptr)->i8257_timerproc();
+}
 
-static TIMER_CALLBACK( dma8257_timerproc )
+void i8257_device::i8257_timerproc()
 {
-	running_device *device = (running_device *)ptr;
-	i8257_t *i8257 = get_safe_token(device);
 	int i, channel = 0, rr;
 	int done;
 
-	rr = DMA_MODE_ROTPRIO(i8257->mode) ? i8257->rr : 0;
+	rr = DMA_MODE_ROTPRIO(m_mode) ? m_rr : 0;
 	for (i = 0; i < I8257_NUM_CHANNELS; i++)
 	{
 		channel = (i + rr) % I8257_NUM_CHANNELS;
-		if ((i8257->status & (1 << channel)) == 0)
-			if (i8257->mode & i8257->drq & (1 << channel))
+		if ((m_status & (1 << channel)) == 0)
+		{
+			if (m_mode & m_drq & (1 << channel))
+			{
 				break;
+			}
+		}
 	}
-	done = dma8257_do_operation(device, channel);
+	done = i8257_do_operation(channel);
 
-	i8257->rr = (channel + 1) & 0x03;
+	m_rr = (channel + 1) & 0x03;
 
 	if (done)
 	{
-		i8257->drq    &= ~(0x01 << channel);
-		dma8257_update_status(device);
-		if (!(DMA_MODE_AUTOLOAD(i8257->mode) && channel==2)) {
-			if (DMA_MODE_TCSTOP(i8257->mode)) {
-				i8257->mode &= ~(0x01 << channel);
+		m_drq &= ~(0x01 << channel);
+		i8257_update_status();
+		if (!(DMA_MODE_AUTOLOAD(m_mode) && channel==2))
+		{
+			if (DMA_MODE_TCSTOP(m_mode))
+			{
+				m_mode &= ~(0x01 << channel);
 			}
 		}
 	}
 }
 
 
-
-static TIMER_CALLBACK( dma8257_msbflip_timerproc )
+TIMER_CALLBACK( i8257_device::i8257_msbflip_timerproc_callback )
 {
-	running_device *device = (running_device *)ptr;
-	i8257_t *i8257 = get_safe_token(device);
-	i8257->msb ^= 1;
+	reinterpret_cast<i8257_device*>(ptr)->i8257_msbflip_timerproc();
 }
 
+void i8257_device::i8257_msbflip_timerproc()
+{
+	m_msb ^= 1;
+}
 
 
-static void dma8257_update_status(running_device *device)
+void i8257_device::i8257_update_status()
 {
-	i8257_t *i8257 = get_safe_token(device);
 	UINT16 pending_transfer;
 	attotime next;
 
 	/* no transfer is active right now; is there a transfer pending right now? */
-	pending_transfer = i8257->drq & (i8257->mode & 0x0F);
+	pending_transfer = m_drq & (m_mode & 0x0F);
 
 	if (pending_transfer)
 	{
-		next = ATTOTIME_IN_HZ(device->clock() / 4 );
-		timer_adjust_periodic(i8257->timer,
+		next = ATTOTIME_IN_HZ(clock() / 4 );
+		timer_adjust_periodic(m_timer,
 			attotime_zero,
 			0,
 			/* 1 byte transferred in 4 clock cycles */
@@ -227,30 +315,26 @@
 	else
 	{
 		/* no transfers active right now */
-		timer_reset(i8257->timer, attotime_never);
+		timer_reset(m_timer, attotime_never);
 	}
 
 	/* set the halt line */
-	devcb_call_write_line(&i8257->out_hrq_func, pending_transfer ? ASSERT_LINE : CLEAR_LINE);
+	devcb_call_write_line(&m_out_hrq_func, pending_transfer ? ASSERT_LINE : CLEAR_LINE);
 }
 
 
-
-/* ----------------------------------------------------------------------- */
-
-static void prepare_msb_flip(i8257_t *i8257)
+void i8257_device::i8257_prepare_msb_flip()
 {
-	timer_adjust_oneshot(i8257->msbflip_timer, attotime_zero, 0);
+	timer_adjust_oneshot(m_msbflip_timer, attotime_zero, 0);
 }
 
 
-
-READ8_DEVICE_HANDLER( i8257_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(i8257, i8257_r)
 {
-	i8257_t *i8257 = get_safe_token(device);
 	UINT8 data = 0xFF;
 
-	switch(offset) {
+	switch(offset)
+	{
 	case 0:
 	case 1:
 	case 2:
@@ -260,15 +344,15 @@
 	case 6:
 	case 7:
 		/* DMA address/count register */
-		data = ( i8257->registers[offset] >> (i8257->msb ? 8 : 0) ) & 0xFF;
-		prepare_msb_flip(i8257);
+		data = ( m_registers[offset] >> (m_msb ? 8 : 0) ) & 0xFF;
+		i8257_prepare_msb_flip();
 		break;
 
 	case 8:
 		/* DMA status register */
-		data = (UINT8) i8257->status;
+		data = (UINT8) m_status;
 		/* read resets status ! */
-		i8257->status &= 0xF0;
+		m_status &= 0xF0;
 
 		break;
 
@@ -281,12 +365,10 @@
 }
 
 
-
-WRITE8_DEVICE_HANDLER( i8257_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(i8257, i8257_w)
 {
-	i8257_t *i8257 = get_safe_token(device);
-
-	switch(offset) {
+	switch(offset)
+	{
 	case 0:
 	case 1:
 	case 2:
@@ -296,30 +378,40 @@
 	case 6:
 	case 7:
 		/* DMA address/count register */
-		if (i8257->msb)
-			i8257->registers[offset] |= ((UINT16) data) << 8;
+		if (m_msb)
+		{
+			m_registers[offset] |= ((UINT16) data) << 8;
+		}
 		else
-			i8257->registers[offset] = data;
+		{
+			m_registers[offset] = data;
+		}
 
-		if (DMA_MODE_AUTOLOAD(i8257->mode)) {
+		if (DMA_MODE_AUTOLOAD(m_mode))
+		{
 			/* in case of autoload when inserting channel 2 info */
 			/* it is automaticaly copied to channel 3 info       */
-			switch(offset) {
+			switch(offset)
+			{
 				case 4:
 				case 5:
-					if (i8257->msb)
-						i8257->registers[offset+2] |= ((UINT16) data) << 8;
+					if (m_msb)
+					{
+						m_registers[offset+2] |= ((UINT16) data) << 8;
+					}
 					else
-						i8257->registers[offset+2] = data;
+					{
+						m_registers[offset+2] = data;
+					}
 			}
 		}
 
-		prepare_msb_flip(i8257);
+		i8257_prepare_msb_flip();
 		break;
 
 	case 8:
 		/* DMA mode register */
-		i8257->mode = data;
+		m_mode = data;
 		break;
 
 	default:
@@ -329,128 +421,42 @@
 }
 
 
+TIMER_CALLBACK( i8257_device::i8257_drq_write_callback )
+{
+	reinterpret_cast<i8257_device*>(ptr)->i8257_drq_write_timerproc(param);
+}
 
-static TIMER_CALLBACK( dma8257_drq_write_callback )
+void i8257_device::i8257_drq_write_timerproc(INT32 param)
 {
-	running_device *device = (running_device *)ptr;
-	i8257_t *i8257 = get_safe_token(device);
 	int channel = param >> 1;
 	int state = param & 0x01;
 
 	/* normalize state */
 	if (state)
 	{
-		i8257->drq |= 0x01 << channel;
-		i8257->address[channel] =  i8257->registers[channel * 2];
-		i8257->count[channel] =  i8257->registers[channel * 2 + 1] & 0x3FFF;
-		i8257->rwmode[channel] =  i8257->registers[channel * 2 + 1] >> 14;
+		m_drq |= 0x01 << channel;
+		m_address[channel] =  m_registers[channel * 2];
+		m_count[channel] =  m_registers[channel * 2 + 1] & 0x3FFF;
+		m_rwmode[channel] =  m_registers[channel * 2 + 1] >> 14;
 		/* clear channel TC */
-		i8257->status &= ~(0x01 << channel);
+		m_status &= ~(0x01 << channel);
 	}
 	else
-		i8257->drq &= ~(0x01 << channel);
-
-	dma8257_update_status(device);
-}
-
+		m_drq &= ~(0x01 << channel);
 
-
-static WRITE8_DEVICE_HANDLER( dma8257_drq_w )
-{
-	int param = (offset << 1) | (data ? 1 : 0);
-
-	timer_call_after_resynch(device->machine, (void *) device, param, dma8257_drq_write_callback);
+	i8257_update_status();
 }
 
-WRITE_LINE_DEVICE_HANDLER( i8257_hlda_w )
+void i8257_device::i8257_drq_w(int channel, int state)
 {
-}
+	int param = (channel << 1) | (state ? 1 : 0);
 
-WRITE_LINE_DEVICE_HANDLER( i8257_ready_w )
-{
+	timer_call_after_resynch(&m_machine, (void *)this, param, i8257_drq_write_callback);
 }
 
-WRITE_LINE_DEVICE_HANDLER( i8257_drq0_w ) { dma8257_drq_w(device, 0, state); }
-WRITE_LINE_DEVICE_HANDLER( i8257_drq1_w ) { dma8257_drq_w(device, 1, state); }
-WRITE_LINE_DEVICE_HANDLER( i8257_drq2_w ) { dma8257_drq_w(device, 2, state); }
-WRITE_LINE_DEVICE_HANDLER( i8257_drq3_w ) { dma8257_drq_w(device, 3, state); }
-
-
-/* ----------------------------------------------------------------------- */
-
-/* device interface */
-
-static DEVICE_START( i8257 )
-{
-	i8257_t *i8257 = get_safe_token(device);
-	i8257_interface *intf = (i8257_interface *)device->baseconfig().static_config();
-	int i;
-
-	/* validate arguments */
-	assert(device != NULL);
-
-	/* resolve callbacks */
-	devcb_resolve_write_line(&i8257->out_hrq_func, &intf->out_hrq_func, device);
-	devcb_resolve_write_line(&i8257->out_tc_func, &intf->out_tc_func, device);
-	devcb_resolve_write_line(&i8257->out_mark_func, &intf->out_mark_func, device);
-	devcb_resolve_read8(&i8257->in_memr_func, &intf->in_memr_func, device);
-	devcb_resolve_write8(&i8257->out_memw_func, &intf->out_memw_func, device);
-
-	for (i = 0; i < I8257_NUM_CHANNELS; i++)
-	{
-		devcb_resolve_read8(&i8257->in_ior_func[i], &intf->in_ior_func[i], device);
-		devcb_resolve_write8(&i8257->out_iow_func[i], &intf->out_iow_func[i], device);
-	}
-
-	/* set initial values */
-	i8257->status = 0x0f;
-	i8257->timer = timer_alloc(device->machine, dma8257_timerproc, (void *) device);
-	i8257->msbflip_timer = timer_alloc(device->machine, dma8257_msbflip_timerproc, (void *) device);
-
-	/* register for state saving */
-	state_save_register_device_item_array(device, 0, i8257->address);
-	state_save_register_device_item_array(device, 0, i8257->count);
-	state_save_register_device_item_array(device, 0, i8257->rwmode);
-	state_save_register_device_item_array(device, 0, i8257->registers);
-	state_save_register_device_item(device, 0, i8257->mode);
-	state_save_register_device_item(device, 0, i8257->rr);
-	state_save_register_device_item(device, 0, i8257->msb);
-	state_save_register_device_item(device, 0, i8257->drq);
-	state_save_register_device_item(device, 0, i8257->status);
-}
-
-
-static DEVICE_RESET( i8257 )
-{
-	i8257_t *i8257 = get_safe_token(device);
-
-	i8257->status &= 0xf0;
-	i8257->mode = 0;
-	dma8257_update_status(device);
-}
-
-
-DEVICE_GET_INFO( i8257 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(i8257_t);			break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = 0;							break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(i8257);break;
-		case DEVINFO_FCT_STOP:							/* Nothing */							break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME(i8257);break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "DMA8257");				break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "DMA controllers");		break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");					break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);				break;
-		case DEVINFO_STR_CREDITS:						strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
-}
-
-
-DEFINE_LEGACY_DEVICE(I8257, i8257);
+WRITE_LINE_DEVICE_HANDLER( i8257_hlda_w ) { }
+WRITE_LINE_DEVICE_HANDLER( i8257_ready_w ) { }
+WRITE_LINE_DEVICE_HANDLER( i8257_drq0_w ) { downcast<i8257_device*>(device)->i8257_drq_w(0, state); }
+WRITE_LINE_DEVICE_HANDLER( i8257_drq1_w ) { downcast<i8257_device*>(device)->i8257_drq_w(1, state); }
+WRITE_LINE_DEVICE_HANDLER( i8257_drq2_w ) { downcast<i8257_device*>(device)->i8257_drq_w(2, state); }
+WRITE_LINE_DEVICE_HANDLER( i8257_drq3_w ) { downcast<i8257_device*>(device)->i8257_drq_w(3, state); }
diff -Nru src-old/emu/machine/8257dma.h src/emu/machine/8257dma.h
--- src-old/emu/machine/8257dma.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/8257dma.h	2010-08-26 15:00:49.000000000 -0700
@@ -30,18 +30,19 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __I8257__
 #define __I8257__
 
-#include "devlegcy.h"
+#include "emu.h"
+
 
 
 /***************************************************************************
-    MACROS / CONSTANTS
+    DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(I8257, i8257);
-
 #define MDRV_I8257_ADD(_tag, _clock, _config) \
 	MDRV_DEVICE_ADD(_tag, I8257, _clock) \
 	MDRV_DEVICE_CONFIG(_config)
@@ -51,26 +52,127 @@
 
 #define I8257_NUM_CHANNELS		(4)
 
+
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _i8257_interface i8257_interface;
-struct _i8257_interface
+
+// ======================> i8257_interface
+
+struct i8257_interface
 {
-	devcb_write_line	out_hrq_func;
-	devcb_write_line	out_tc_func;
-	devcb_write_line	out_mark_func;
+	devcb_write_line	m_out_hrq_func;
+	devcb_write_line	m_out_tc_func;
+	devcb_write_line	m_out_mark_func;
 
 	/* accessors to main memory */
-	devcb_read8			in_memr_func;
-	devcb_write8		out_memw_func;
+	devcb_read8			m_in_memr_func;
+	devcb_write8		m_out_memw_func;
 
 	/* channel accesors */
-	devcb_read8			in_ior_func[I8257_NUM_CHANNELS];
-	devcb_write8		out_iow_func[I8257_NUM_CHANNELS];
+	devcb_read8			m_in_ior_func[I8257_NUM_CHANNELS];
+	devcb_write8		m_out_iow_func[I8257_NUM_CHANNELS];
 };
 
+
+
+// ======================> i8257_device_config
+
+class i8257_device_config : public device_config,
+                            public i8257_interface
+{
+    friend class i8257_device;
+
+    // construction/destruction
+    i8257_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> i8257_device
+
+class i8257_device :  public device_t
+{
+    friend class i8257_device_config;
+
+    // construction/destruction
+    i8257_device(running_machine &_machine, const i8257_device_config &_config);
+
+public:
+
+	/* register access */
+	UINT8 i8257_r(UINT32 offset);
+	void i8257_w(UINT32 offset, UINT8 data);
+
+	/* data request */
+	void i8257_drq_w(int channel, int state);
+
+	void i8257_timerproc();
+	void i8257_msbflip_timerproc();
+	void i8257_drq_write_timerproc(INT32 param);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( i8257_timerproc_callback );
+	static TIMER_CALLBACK( i8257_msbflip_timerproc_callback );
+	static TIMER_CALLBACK( i8257_drq_write_callback );
+
+private:
+
+	int i8257_do_operation(int channel);
+	void i8257_update_status();
+	void i8257_prepare_msb_flip();
+
+	devcb_resolved_write_line	m_out_hrq_func;
+	devcb_resolved_write_line	m_out_tc_func;
+	devcb_resolved_write_line	m_out_mark_func;
+	devcb_resolved_read8		m_in_memr_func;
+	devcb_resolved_write8		m_out_memw_func;
+	devcb_resolved_read8		m_in_ior_func[I8257_NUM_CHANNELS];
+	devcb_resolved_write8		m_out_iow_func[I8257_NUM_CHANNELS];
+
+	emu_timer *m_timer;
+	emu_timer *m_msbflip_timer;
+
+	UINT16 m_registers[I8257_NUM_CHANNELS*2];
+
+	UINT16 m_address[I8257_NUM_CHANNELS];
+	UINT16 m_count[I8257_NUM_CHANNELS];
+	UINT8  m_rwmode[I8257_NUM_CHANNELS];
+
+	UINT8 m_mode;
+	UINT8 m_rr;
+
+	UINT8 m_msb;
+	UINT8 m_drq;
+
+	/* bits  0- 3 :  Terminal count for channels 0-3 */
+	UINT8 m_status;
+
+    const i8257_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type I8257;
+
+
+
 /***************************************************************************
     PROTOTYPES
 ***************************************************************************/
diff -Nru src-old/emu/machine/at28c16.c src/emu/machine/at28c16.c
--- src-old/emu/machine/at28c16.c	2010-07-10 12:29:41.000000000 -0700
+++ src/emu/machine/at28c16.c	2010-08-19 01:27:05.000000000 -0700
@@ -155,7 +155,7 @@
 	UINT16 default_value = 0xff;
 	for( offs_t offs = 0; offs < AT28C16_TOTAL_BYTES; offs++ )
 	{
-		memory_write_byte( m_addrspace[ 0 ], offs, default_value );
+		m_addrspace[ 0 ]->write_byte( offs, default_value );
 	}
 
 	/* populate from a memory region if present */
@@ -173,7 +173,7 @@
 
 		for( offs_t offs = 0; offs < AT28C16_DATA_BYTES; offs++ )
 		{
-			memory_write_byte( m_addrspace[ 0 ], offs, m_region->u8( offs ) );
+			m_addrspace[ 0 ]->write_byte( offs, m_region->u8( offs ) );
 		}
 	}
 }
@@ -192,7 +192,7 @@
 
 	for( offs_t offs = 0; offs < AT28C16_TOTAL_BYTES; offs++ )
 	{
-		memory_write_byte( m_addrspace[ 0 ], offs, buffer[ offs ] );
+		m_addrspace[ 0 ]->write_byte( offs, buffer[ offs ] );
 	}
 
 	auto_free( &m_machine, buffer );
@@ -209,7 +209,7 @@
 
 	for( offs_t offs = 0; offs < AT28C16_TOTAL_BYTES; offs++ )
 	{
-		buffer[ offs ] = memory_read_byte( m_addrspace[ 0 ], offs );
+		buffer[ offs ] = m_addrspace[ 0 ]->read_byte( offs );
 	}
 
 	mame_fwrite( &file, buffer, AT28C16_TOTAL_BYTES );
@@ -241,7 +241,7 @@
 		{
 			for( offs_t offs = 0; offs < AT28C16_TOTAL_BYTES; offs++ )
 			{
-				memory_write_byte( m_addrspace[ 0 ], offs, 0xff );
+				m_addrspace[ 0 ]->write_byte( offs, 0xff );
 			}
 
 			m_last_write = 0xff;
@@ -256,9 +256,9 @@
 		}
 
 //      logerror( "%s: AT28C16: write( %04x, %02x )\n", cpuexec_describe_context(machine), offset, data );
-		if( m_last_write < 0 && memory_read_byte( m_addrspace[ 0 ], offset ) != data )
+		if( m_last_write < 0 && m_addrspace[ 0 ]->read_byte( offset ) != data )
 		{
-			memory_write_byte( m_addrspace[ 0 ], offset, data );
+			m_addrspace[ 0 ]->write_byte( offset, data );
 			m_last_write = data;
 			timer_adjust_oneshot( m_write_timer, ATTOTIME_IN_USEC( 200 ), 0 );
 		}
@@ -286,7 +286,7 @@
 			offset += AT28C16_ID_BYTES;
 		}
 
-		UINT8 data = memory_read_byte( m_addrspace[ 0 ], offset );
+		UINT8 data = m_addrspace[ 0 ]->read_byte( offset );
 //      logerror( "%s: AT28C16: read( %04x ) data %02x\n", cpuexec_describe_context(machine), offset, data );
 		return data;
 	}
diff -Nru src-old/emu/machine/devhelpr.h src/emu/machine/devhelpr.h
--- src-old/emu/machine/devhelpr.h	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/machine/devhelpr.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,72 @@
+/**********************************************************************
+
+    Generic modern device trampolines and other helpers, to minimize
+    the amount of redundant copy/pasting between modernized devices.
+
+**********************************************************************/
+
+#ifndef __DEVHELPR_H__
+#define __DEVHELPR_H__
+
+#define READ32_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	READ32_DEVICE_HANDLER( funcname ) \
+	{ return downcast<devname##_device*>(device)->funcname(offset); } \
+	UINT32 devname##_device::funcname(UINT32 offset)
+
+#define WRITE32_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	WRITE32_DEVICE_HANDLER( funcname ) \
+	{ downcast<devname##_device*>(device)->funcname(offset, data, mem_mask); } \
+	void devname##_device::funcname(UINT32 offset, UINT32 data, UINT32 mem_mask)
+
+#define READ8_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	READ8_DEVICE_HANDLER( funcname ) \
+	{ return downcast<devname##_device*>(device)->funcname(offset); } \
+	UINT8 devname##_device::funcname(UINT32 offset)
+
+#define WRITE8_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	WRITE8_DEVICE_HANDLER( funcname ) \
+	{ downcast<devname##_device*>(device)->funcname(offset, data); } \
+	void devname##_device::funcname(UINT32 offset, UINT8 data)
+
+#define READ_LINE_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	READ_LINE_DEVICE_HANDLER( funcname ) \
+	{ return downcast<devname##_device *>(device)->funcname(); } \
+	void devname##_device::funcname()
+
+#define WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(devname, funcname) \
+	WRITE_LINE_DEVICE_HANDLER( funcname ) \
+	{ return downcast<devname##_device *>(device)->funcname(state); } \
+	void devname##_device::funcname(UINT8 state)
+
+#define GENERIC_DEVICE_CONFIG_SETUP(devname, devtag) \
+	devname##_device_config::devname##_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock) \
+	    : device_config(mconfig, static_alloc_device_config, devtag, tag, owner, clock) \
+	{ } \
+	\
+	device_config *devname##_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock) \
+	{ return global_alloc(devname##_device_config(mconfig, tag, owner, clock)); } \
+	\
+	device_t *devname##_device_config::alloc_device(running_machine &machine) const \
+	{ return auto_alloc(&machine, devname##_device(machine, *this)); }
+
+#define GENERIC_DEVICE_DERIVED_CONFIG(basename, devname) \
+	class devname##_device_config : public basename##_device_config \
+	{ \
+		friend class devname##_device; \
+		devname##_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock); \
+	public: \
+		static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock); \
+		virtual device_t *alloc_device(running_machine &machine) const; \
+	}; \
+	\
+	class devname##_device : public basename##_device \
+	{ \
+		friend class basename##_device; \
+		friend class devname##_device_config; \
+		devname##_device(running_machine &_machine, const devname##_device_config &config); \
+	protected: \
+		virtual void device_start(); \
+		virtual void device_reset(); \
+	};
+
+#endif // __DEVHELPR_H__
diff -Nru src-old/emu/machine/ds1302.c src/emu/machine/ds1302.c
--- src-old/emu/machine/ds1302.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/machine/ds1302.c	2010-08-28 09:48:51.000000000 -0700
@@ -22,57 +22,118 @@
 
 #include "emu.h"
 #include "ds1302.h"
+#include "devhelpr.h"
 
 
 /***************************************************************************
-    TYPE DEFINITIONS
+    INLINE FUNCTIONS
 ***************************************************************************/
 
-typedef struct _ds1302_state ds1302_state;
-struct _ds1302_state
+INLINE UINT8 convert_to_bcd(int val)
 {
+	return ((val / 10) << 4) | (val % 10);
+}
 
-	UINT32 shift_in;
-	UINT8  shift_out;
-	UINT8  icount;
-	UINT8  last_clk;
-	UINT8  last_cmd;
-	UINT8  sram[0x20];
-};
 
 /***************************************************************************
-    INLINE FUNCTIONS
+    IMPLEMENTATION
 ***************************************************************************/
 
-INLINE ds1302_state *get_safe_token(running_device *device)
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+//-------------------------------------------------
+//  ds1302_device_config - constructor
+//-------------------------------------------------
+
+ds1302_device_config::ds1302_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "Dallas DS1302 RTC", tag, owner, clock)
 {
-	assert(device != NULL);
-	assert(device->type() == DS1302);
-	return (ds1302_state *)downcast<legacy_device_base *>(device)->token();
 }
 
-INLINE UINT8 convert_to_bcd(int val)
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *ds1302_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
 {
-	return ((val / 10) << 4) | (val % 10);
+    return global_alloc(ds1302_device_config(mconfig, tag, owner, clock));
 }
 
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *ds1302_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, ds1302_device(machine, *this));
+}
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type DS1302 = ds1302_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  ds1302_device - constructor
+//-------------------------------------------------
+
+ds1302_device::ds1302_device(running_machine &_machine, const ds1302_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
+
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ds1302_device::device_start()
+{
+	state_save_register_device_item(this, 0, m_shift_in);
+	state_save_register_device_item(this, 0, m_shift_out);
+	state_save_register_device_item(this, 0, m_icount);
+	state_save_register_device_item(this, 0, m_last_clk);
+	state_save_register_device_item(this, 0, m_last_cmd);
+	state_save_register_device_item_array(this, 0, m_sram);
+}
+
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ds1302_device::device_reset()
+{
+	m_shift_in  = 0;
+	m_shift_out = 0;
+	m_icount    = 0;
+	m_last_clk  = 0;
+	m_last_cmd  = 0;
+}
+
 
 /*-------------------------------------------------
     ds1302_dat_w
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( ds1302_dat_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_dat_w)
 {
-	ds1302_state *ds1302 = get_safe_token(device);
-
 	if (data)
-		ds1302->shift_in |= (1 << ds1302->icount);
+	{
+		m_shift_in |= (1 << m_icount);
+	}
 	else
-		ds1302->shift_in &= ~(1 << ds1302->icount);
+	{
+		m_shift_in &= ~(1 << m_icount);
+	}
 }
 
 
@@ -80,86 +141,94 @@
     ds1302_clk_w
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( ds1302_clk_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_clk_w)
 {
-	ds1302_state *ds1302 = get_safe_token(device);
-
-	if (data != ds1302->last_clk)
+	if (data != m_last_clk)
 	{
 		if (data)	//Rising, shift in command
 		{
-			ds1302->icount++;
-			if(ds1302->icount == 8)	//Command start
+			m_icount++;
+			if(m_icount == 8)	//Command start
 			{
 				system_time systime;
-				device->machine->base_datetime(systime);
+				m_machine.base_datetime(systime);
 
-				switch(ds1302->shift_in)
+				switch(m_shift_in)
 				{
 					case 0x81:	//Sec
-						ds1302->shift_out = convert_to_bcd(systime.local_time.second);
+						m_shift_out = convert_to_bcd(systime.local_time.second);
 						break;
+
 					case 0x83:	//Min
-						ds1302->shift_out = convert_to_bcd(systime.local_time.minute);
+						m_shift_out = convert_to_bcd(systime.local_time.minute);
 						break;
+
 					case 0x85:	//Hour
-						ds1302->shift_out = convert_to_bcd(systime.local_time.hour);
+						m_shift_out = convert_to_bcd(systime.local_time.hour);
 						break;
+
 					case 0x87:	//Day
-						ds1302->shift_out = convert_to_bcd(systime.local_time.mday);
+						m_shift_out = convert_to_bcd(systime.local_time.mday);
 						break;
+
 					case 0x89:	//Month
-						ds1302->shift_out = convert_to_bcd(systime.local_time.month + 1);
+						m_shift_out = convert_to_bcd(systime.local_time.month + 1);
 						break;
+
 					case 0x8b:	//weekday
-						ds1302->shift_out = convert_to_bcd(systime.local_time.weekday);
+						m_shift_out = convert_to_bcd(systime.local_time.weekday);
 						break;
+
 					case 0x8d:	//Year
-						ds1302->shift_out = convert_to_bcd(systime.local_time.year % 100);
+						m_shift_out = convert_to_bcd(systime.local_time.year % 100);
 						break;
+
 					default:
-						ds1302->shift_out = 0x0;
+						m_shift_out = 0x0;
 				}
 
-				if(ds1302->shift_in > 0xc0)
-					ds1302->shift_out = ds1302->sram[(ds1302->shift_in >> 1) & 0x1f];
-				ds1302->last_cmd = ds1302->shift_in & 0xff;
-				ds1302->icount++;
+				if(m_shift_in > 0xc0)
+				{
+					m_shift_out = m_sram[(m_shift_in >> 1) & 0x1f];
+				}
+				m_last_cmd = m_shift_in & 0xff;
+				m_icount++;
 			}
 
-			if(ds1302->icount == 17 && !(ds1302->last_cmd & 1))
+			if(m_icount == 17 && !(m_last_cmd & 1))
 			{
-				UINT8 val = (ds1302->shift_in >> 9) & 0xff;
+				UINT8 val = (m_shift_in >> 9) & 0xff;
 
-				switch(ds1302->last_cmd)
+				switch(m_last_cmd)
 				{
 					case 0x80:	//Sec
-
 						break;
-					case 0x82:	//Min
 
+					case 0x82:	//Min
 						break;
-					case 0x84:	//Hour
 
+					case 0x84:	//Hour
 						break;
-					case 0x86:	//Day
 
+					case 0x86:	//Day
 						break;
-					case 0x88:	//Month
 
+					case 0x88:	//Month
 						break;
-					case 0x8a:	//weekday
 
+					case 0x8a:	//weekday
 						break;
-					case 0x8c:	//Year
 
+					case 0x8c:	//Year
 						break;
+
 					default:
-						ds1302->shift_out = 0x0;
+						m_shift_out = 0x0;
 				}
-				if(ds1302->last_cmd > 0xc0)
+
+				if(m_last_cmd > 0xc0)
 				{
-					ds1302->sram[(ds1302->last_cmd >> 1) & 0x1f] = val;
+					m_sram[(m_last_cmd >> 1) & 0x1f] = val;
 				}
 
 
@@ -167,7 +236,7 @@
 			}
 		}
 	}
-	ds1302->last_clk = data;
+	m_last_clk = data;
 }
 
 
@@ -175,56 +244,7 @@
     ds1302_read
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( ds1302_read )
+READ8_DEVICE_HANDLER_TRAMPOLINE(ds1302, ds1302_read)
 {
-	ds1302_state *ds1302 = get_safe_token(device);
-	return (ds1302->shift_out & (1 << (ds1302->icount - 9))) ? 1 : 0;
+	return (m_shift_out & (1 << (m_icount - 9))) ? 1 : 0;
 }
-
-
-/*-------------------------------------------------
-    DEVICE_START( ds1302 )
--------------------------------------------------*/
-
-static DEVICE_START( ds1302 )
-{
-	ds1302_state *ds1302 = get_safe_token(device);
-
-	/* register for state saving */
-	state_save_register_device_item(device, 0, ds1302->shift_in);
-	state_save_register_device_item(device, 0, ds1302->shift_out);
-	state_save_register_device_item(device, 0, ds1302->icount);
-	state_save_register_device_item(device, 0, ds1302->last_clk);
-	state_save_register_device_item(device, 0, ds1302->last_cmd);
-	state_save_register_device_item_array(device, 0, ds1302->sram);
-}
-
-/*-------------------------------------------------
-    DEVICE_START( ds1302 )
--------------------------------------------------*/
-
-static DEVICE_RESET( ds1302 )
-{
-	ds1302_state *ds1302 = get_safe_token(device);
-
-	ds1302->shift_in  = 0;
-	ds1302->shift_out = 0;
-	ds1302->icount    = 0;
-	ds1302->last_clk  = 0;
-	ds1302->last_cmd  = 0;
-}
-
-/*-------------------------------------------------
-    DEVICE_GET_INFO( ds1302 )
--------------------------------------------------*/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID(p,s)		p##ds1302##s
-#define DEVTEMPLATE_FEATURES	DT_HAS_START | DT_HAS_RESET
-#define DEVTEMPLATE_NAME		"Dallas DS1302 RTC"
-#define DEVTEMPLATE_FAMILY		"Dallas DS1302 RTC"
-#include "devtempl.h"
-
-
-DEFINE_LEGACY_DEVICE(DS1302, ds1302);
diff -Nru src-old/emu/machine/ds1302.h src/emu/machine/ds1302.h
--- src-old/emu/machine/ds1302.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/ds1302.h	2010-08-26 17:17:25.000000000 -0700
@@ -6,22 +6,86 @@
 
 **********************************************************************/
 
+#pragma once
+
 #ifndef __DS1302_H__
 #define __DS1302_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
 
 /***************************************************************************
-    MACROS / CONSTANTS
+    DEVICE CONFIGURATION MACROS
 ***************************************************************************/
 
-DECLARE_LEGACY_DEVICE(DS1302, ds1302);
-
 #define MDRV_DS1302_ADD(_tag) \
 	MDRV_DEVICE_ADD(_tag, DS1302, 0)
 
 
 /***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+
+// ======================> ds1302_device_config
+
+class ds1302_device_config : public device_config
+{
+    friend class ds1302_device;
+
+    // construction/destruction
+    ds1302_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+};
+
+
+
+// ======================> ds1302_device
+
+class ds1302_device :  public device_t
+{
+    friend class ds1302_device_config;
+
+    // construction/destruction
+    ds1302_device(running_machine &_machine, const ds1302_device_config &_config);
+
+public:
+
+	void ds1302_dat_w(UINT32 offset, UINT8 data);
+	void ds1302_clk_w(UINT32 offset, UINT8 data);
+	UINT8 ds1302_read(UINT32 offset);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+	UINT32 m_shift_in;
+	UINT8  m_shift_out;
+	UINT8  m_icount;
+	UINT8  m_last_clk;
+	UINT8  m_last_cmd;
+	UINT8  m_sram[0x20];
+
+    const ds1302_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type DS1302;
+
+
+
+/***************************************************************************
     PROTOTYPES
 ***************************************************************************/
 
diff -Nru src-old/emu/machine/ds2404.c src/emu/machine/ds2404.c
--- src-old/emu/machine/ds2404.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/ds2404.c	2010-08-27 04:57:53.000000000 -0700
@@ -1,51 +1,146 @@
-/* Dallas DS2404 RTC/NVRAM */
+/**********************************************************************
+
+    DALLAS DS2404
+
+    RTC + BACKUP RAM
+
+**********************************************************************/
 
 #include "emu.h"
 #include "ds2404.h"
 #include <time.h>
+#include "devhelpr.h"
+
+/***************************************************************************
+    IMPLEMENTATION
+***************************************************************************/
+
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+//-------------------------------------------------
+//  ds2404_device_config - constructor
+//-------------------------------------------------
+
+ds2404_device_config::ds2404_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "DS2404", tag, owner, clock),
+      device_config_nvram_interface(mconfig, *this)
+{
+}
+
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *ds2404_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+    return global_alloc(ds2404_device_config(mconfig, tag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *ds2404_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, ds2404_device(machine, *this));
+}
 
-typedef enum {
-	DS2404_STATE_IDLE = 1,				/* waiting for ROM command, in 1-wire mode */
-	DS2404_STATE_COMMAND,				/* waiting for memory command */
-	DS2404_STATE_ADDRESS1,				/* waiting for address bits 0-7 */
-	DS2404_STATE_ADDRESS2,				/* waiting for address bits 8-15 */
-	DS2404_STATE_OFFSET,				/* waiting for ending offset */
-	DS2404_STATE_INIT_COMMAND,
-	DS2404_STATE_READ_MEMORY,			/* Read Memory command active */
-	DS2404_STATE_WRITE_SCRATCHPAD,		/* Write Scratchpad command active */
-	DS2404_STATE_READ_SCRATCHPAD,		/* Read Scratchpad command active */
-	DS2404_STATE_COPY_SCRATCHPAD		/* Copy Scratchpad command active */
-} DS2404_STATE;
-
-typedef struct _ds2404_state ds2404_state;
-struct _ds2404_state {
-	UINT16 address;
-	UINT16 offset;
-	UINT16 end_offset;
-	UINT8 a1, a2;
-	UINT8 sram[512];	/* 4096 bits */
-	UINT8 ram[32];		/* scratchpad ram, 256 bits */
-	UINT8 rtc[5];		/* 40-bit RTC counter */
-	DS2404_STATE state[8];
-	int state_ptr;
-};
-
-INLINE ds2404_state *get_safe_token(running_device *device)
+
+//-------------------------------------------------
+//  static_set_ref_year - configuration helper
+//  to set the reference year
+//-------------------------------------------------
+
+void ds2404_device_config::static_set_ref_year(device_config *device, UINT32 year)
 {
-	assert(device != NULL);
-	assert(device->type() == DS2404);
+	ds2404_device_config *ds2404 = downcast<ds2404_device_config *>(device);
+	ds2404->m_ref_year = year;
+}
+
+
+//-------------------------------------------------
+//  static_set_ref_month - configuration helper
+//  to set the reference month
+//-------------------------------------------------
 
-	return (ds2404_state *)downcast<legacy_device_base *>(device)->token();
+void ds2404_device_config::static_set_ref_month(device_config *device, UINT8 month)
+{
+	ds2404_device_config *ds2404 = downcast<ds2404_device_config *>(device);
+	ds2404->m_ref_month = month;
 }
 
 
-static void ds2404_rom_cmd(ds2404_state *state, UINT8 cmd)
+//-------------------------------------------------
+//  static_set_ref_day - configuration helper
+//  to set the reference day
+//-------------------------------------------------
+
+void ds2404_device_config::static_set_ref_day(device_config *device, UINT8 day)
+{
+	ds2404_device_config *ds2404 = downcast<ds2404_device_config *>(device);
+	ds2404->m_ref_day = day;
+}
+
+
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type DS2404 = ds2404_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  ds2404_device - constructor
+//-------------------------------------------------
+
+ds2404_device::ds2404_device(running_machine &_machine, const ds2404_device_config &config)
+    : device_t(_machine, config),
+	  device_nvram_interface(_machine, config, *this),
+      m_config(config)
+{
+}
+
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ds2404_device::device_start()
+{
+	struct tm ref_tm;
+
+	memset(&ref_tm, 0, sizeof(ref_tm));
+	ref_tm.tm_year = m_config.m_ref_year - 1900;
+	ref_tm.tm_mon = m_config.m_ref_month - 1;
+	ref_tm.tm_mday = m_config.m_ref_day;
+
+	time_t ref_time = mktime(&ref_tm);
+
+	time_t current_time;
+	time(&current_time);
+	current_time -= ref_time;
+
+	m_rtc[0] = 0x0;
+	m_rtc[1] = (current_time >> 0) & 0xff;
+	m_rtc[2] = (current_time >> 8) & 0xff;
+	m_rtc[3] = (current_time >> 16) & 0xff;
+	m_rtc[4] = (current_time >> 24) & 0xff;
+
+	emu_timer *timer = timer_alloc(&m_machine, ds2404_tick_callback, (void *)this);
+	timer_adjust_periodic(timer, ATTOTIME_IN_HZ(256), 0, ATTOTIME_IN_HZ(256));
+}
+
+
+void ds2404_device::ds2404_rom_cmd(UINT8 cmd)
 {
 	switch(cmd)
 	{
 		case 0xcc:		/* Skip ROM */
-			state->state[0] = DS2404_STATE_COMMAND;
-			state->state_ptr = 0;
+			m_state[0] = DS2404_STATE_COMMAND;
+			m_state_ptr = 0;
 			break;
 
 		default:
@@ -54,33 +149,33 @@
 	}
 }
 
-static void ds2404_cmd(ds2404_state *state, UINT8 cmd)
+void ds2404_device::ds2404_cmd(UINT8 cmd)
 {
 	switch(cmd)
 	{
 		case 0x0f:		/* Write scratchpad */
-			state->state[0] = DS2404_STATE_ADDRESS1;
-			state->state[1] = DS2404_STATE_ADDRESS2;
-			state->state[2] = DS2404_STATE_INIT_COMMAND;
-			state->state[3] = DS2404_STATE_WRITE_SCRATCHPAD;
-			state->state_ptr = 0;
+			m_state[0] = DS2404_STATE_ADDRESS1;
+			m_state[1] = DS2404_STATE_ADDRESS2;
+			m_state[2] = DS2404_STATE_INIT_COMMAND;
+			m_state[3] = DS2404_STATE_WRITE_SCRATCHPAD;
+			m_state_ptr = 0;
 			break;
 
 		case 0x55:		/* Copy scratchpad */
-			state->state[0] = DS2404_STATE_ADDRESS1;
-			state->state[1] = DS2404_STATE_ADDRESS2;
-			state->state[2] = DS2404_STATE_OFFSET;
-			state->state[3] = DS2404_STATE_INIT_COMMAND;
-			state->state[4] = DS2404_STATE_COPY_SCRATCHPAD;
-			state->state_ptr = 0;
+			m_state[0] = DS2404_STATE_ADDRESS1;
+			m_state[1] = DS2404_STATE_ADDRESS2;
+			m_state[2] = DS2404_STATE_OFFSET;
+			m_state[3] = DS2404_STATE_INIT_COMMAND;
+			m_state[4] = DS2404_STATE_COPY_SCRATCHPAD;
+			m_state_ptr = 0;
 			break;
 
 		case 0xf0:		/* Read memory */
-			state->state[0] = DS2404_STATE_ADDRESS1;
-			state->state[1] = DS2404_STATE_ADDRESS2;
-			state->state[2] = DS2404_STATE_INIT_COMMAND;
-			state->state[3] = DS2404_STATE_READ_MEMORY;
-			state->state_ptr = 0;
+			m_state[0] = DS2404_STATE_ADDRESS1;
+			m_state[1] = DS2404_STATE_ADDRESS2;
+			m_state[2] = DS2404_STATE_INIT_COMMAND;
+			m_state[3] = DS2404_STATE_READ_MEMORY;
+			m_state_ptr = 0;
 			break;
 
 		default:
@@ -89,50 +184,47 @@
 	}
 }
 
-static UINT8 ds2404_readmem(ds2404_state *state)
+UINT8 ds2404_device::ds2404_readmem()
 {
-	if( state->address < 0x200 )
+	if( m_address < 0x200 )
 	{
-		return state->sram[ state->address ];
+		return m_sram[ m_address ];
 	}
-	else if( state->address >= 0x202 && state->address <= 0x206 )
+	else if( m_address >= 0x202 && m_address <= 0x206 )
 	{
-		return state->rtc[ state->address - 0x202 ];
+		return m_rtc[ m_address - 0x202 ];
 	}
 	return 0;
 }
 
-static void ds2404_writemem(ds2404_state *state, UINT8 value)
+void ds2404_device::ds2404_writemem(UINT8 value)
 {
-	if( state->address < 0x200 )
+	if( m_address < 0x200 )
 	{
-		state->sram[ state->address ] = value;
+		m_sram[ m_address ] = value;
 	}
-	else if( state->address >= 0x202 && state->address <= 0x206 )
+	else if( m_address >= 0x202 && m_address <= 0x206 )
 	{
-		state->rtc[ state->address - 0x202 ] = value;
+		m_rtc[ m_address - 0x202 ] = value;
 	}
 }
 
-WRITE8_DEVICE_HANDLER( ds2404_1w_reset_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds2404, ds2404_1w_reset_w)
 {
-	ds2404_state *state = get_safe_token(device);
-	state->state[0] = DS2404_STATE_IDLE;
-	state->state_ptr = 0;
+	m_state[0] = DS2404_STATE_IDLE;
+	m_state_ptr = 0;
 }
 
-WRITE8_DEVICE_HANDLER( ds2404_3w_reset_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds2404, ds2404_3w_reset_w)
 {
-	ds2404_state *state = get_safe_token(device);
-	state->state[0] = DS2404_STATE_COMMAND;
-	state->state_ptr = 0;
+	m_state[0] = DS2404_STATE_COMMAND;
+	m_state_ptr = 0;
 }
 
-READ8_DEVICE_HANDLER( ds2404_data_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(ds2404, ds2404_data_r)
 {
-	ds2404_state *state = get_safe_token(device);
-	UINT8 value;
-	switch( state->state[state->state_ptr] )
+	UINT8 value = 0;
+	switch(m_state[m_state_ptr])
 	{
 		case DS2404_STATE_IDLE:
 		case DS2404_STATE_COMMAND:
@@ -143,14 +235,14 @@
 			break;
 
 		case DS2404_STATE_READ_MEMORY:
-			value = ds2404_readmem(state);
-			return value;
+			value = ds2404_readmem();
+			break;
 
 		case DS2404_STATE_READ_SCRATCHPAD:
-			if( state->offset < 0x20 ) {
-				value = state->ram[state->offset];
-				state->offset++;
-				return value;
+			if(m_offset < 0x20)
+			{
+				value = m_ram[m_offset];
+				m_offset++;
 			}
 			break;
 
@@ -160,37 +252,34 @@
 		case DS2404_STATE_COPY_SCRATCHPAD:
 			break;
 	}
-	return 0;
+	return value;
 }
 
-WRITE8_DEVICE_HANDLER( ds2404_data_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds2404, ds2404_data_w)
 {
-	ds2404_state *state = get_safe_token(device);
-	int i;
-
-	switch( state->state[state->state_ptr] )
+	switch( m_state[m_state_ptr] )
 	{
 		case DS2404_STATE_IDLE:
-			ds2404_rom_cmd(state, data & 0xff);
+			ds2404_rom_cmd(data & 0xff);
 			break;
 
 		case DS2404_STATE_COMMAND:
-			ds2404_cmd(state, data & 0xff);
+			ds2404_cmd(data & 0xff);
 			break;
 
 		case DS2404_STATE_ADDRESS1:
-			state->a1 = data & 0xff;
-			state->state_ptr++;
+			m_a1 = data & 0xff;
+			m_state_ptr++;
 			break;
 
 		case DS2404_STATE_ADDRESS2:
-			state->a2 = data & 0xff;
-			state->state_ptr++;
+			m_a2 = data & 0xff;
+			m_state_ptr++;
 			break;
 
 		case DS2404_STATE_OFFSET:
-			state->end_offset = data & 0xff;
-			state->state_ptr++;
+			m_end_offset = data & 0xff;
+			m_state_ptr++;
 			break;
 
 		case DS2404_STATE_INIT_COMMAND:
@@ -203,10 +292,13 @@
 			break;
 
 		case DS2404_STATE_WRITE_SCRATCHPAD:
-			if( state->offset < 0x20 ) {
-				state->ram[state->offset] = data & 0xff;
-				state->offset++;
-			} else {
+			if( m_offset < 0x20 )
+			{
+				m_ram[m_offset] = data & 0xff;
+				m_offset++;
+			}
+			else
+			{
 				/* Set OF flag */
 			}
 			break;
@@ -215,8 +307,9 @@
 			break;
 	}
 
-	if( state->state[state->state_ptr] == DS2404_STATE_INIT_COMMAND ) {
-		switch( state->state[state->state_ptr+1] )
+	if( m_state[m_state_ptr] == DS2404_STATE_INIT_COMMAND )
+	{
+		switch( m_state[m_state_ptr + 1] )
 		{
 			case DS2404_STATE_IDLE:
 			case DS2404_STATE_COMMAND:
@@ -227,37 +320,37 @@
 				break;
 
 			case DS2404_STATE_READ_MEMORY:
-				state->address = (state->a2 << 8) | state->a1;
-				state->address -= 1;
+				m_address = (m_a2 << 8) | m_a1;
+				m_address -= 1;
 				break;
 
 			case DS2404_STATE_WRITE_SCRATCHPAD:
-				state->address = (state->a2 << 8) | state->a1;
-				state->offset = state->address & 0x1f;
+				m_address = (m_a2 << 8) | m_a1;
+				m_offset = m_address & 0x1f;
 				break;
 
 			case DS2404_STATE_READ_SCRATCHPAD:
-				state->address = (state->a2 << 8) | state->a1;
-				state->offset = state->address & 0x1f;
+				m_address = (m_a2 << 8) | m_a1;
+				m_offset = m_address & 0x1f;
 				break;
 
 			case DS2404_STATE_COPY_SCRATCHPAD:
-				state->address = (state->a2 << 8) | state->a1;
+				m_address = (m_a2 << 8) | m_a1;
 
-				for( i=0; i <= state->end_offset; i++ ) {
-					ds2404_writemem( state, state->ram[i] );
-					state->address++;
+				for(int i = 0; i <= m_end_offset; i++)
+				{
+					ds2404_writemem(m_ram[i]);
+					m_address++;
 				}
 				break;
 		}
-		state->state_ptr++;
+		m_state_ptr++;
 	}
 }
 
-WRITE8_DEVICE_HANDLER( ds2404_clk_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ds2404, ds2404_clk_w)
 {
-	ds2404_state *state = get_safe_token(device);
-	switch( state->state[state->state_ptr] )
+	switch( m_state[m_state_ptr] )
 	{
 		case DS2404_STATE_IDLE:
 		case DS2404_STATE_COMMAND:
@@ -268,7 +361,7 @@
 			break;
 
 		case DS2404_STATE_READ_MEMORY:
-			state->address++;
+			m_address++;
 			break;
 
 		case DS2404_STATE_READ_SCRATCHPAD:
@@ -282,14 +375,17 @@
 	}
 }
 
-static TIMER_CALLBACK( ds2404_tick )
+TIMER_CALLBACK( ds2404_device::ds2404_tick_callback )
+{
+	reinterpret_cast<ds2404_device*>(ptr)->ds2404_tick();
+}
+
+void ds2404_device::ds2404_tick()
 {
-	ds2404_state *state = get_safe_token((running_device *)ptr);
-	int i;
-	for( i = 0; i < 5; i++ )
+	for(int i = 0; i < 5; i++)
 	{
-		state->rtc[ i ]++;
-		if( state->rtc[ i ] != 0 )
+		m_rtc[ i ]++;
+		if(m_rtc[ i ] != 0)
 		{
 			break;
 		}
@@ -297,62 +393,34 @@
 }
 
 
-static DEVICE_START( ds2404 )
-{
-	ds2404_config *config = (ds2404_config *)downcast<const legacy_device_config_base &>(device->baseconfig()).inline_config();
-	ds2404_state *state = get_safe_token(device);
-
-	struct tm ref_tm;
-	time_t ref_time;
-	time_t current_time;
-	emu_timer *timer;
-
-	memset( &ref_tm, 0, sizeof( ref_tm ) );
-	ref_tm.tm_year = config->ref_year - 1900;
-	ref_tm.tm_mon = config->ref_month - 1;
-	ref_tm.tm_mday = config->ref_day;
-
-	ref_time = mktime( &ref_tm );
-
-	time( &current_time );
-	current_time -= ref_time;
-
-	state->rtc[ 0 ] = 0x0;
-	state->rtc[ 1 ] = ( current_time >> 0 ) & 0xff;
-	state->rtc[ 2 ] = ( current_time >> 8 ) & 0xff;
-	state->rtc[ 3 ] = ( current_time >> 16 ) & 0xff;
-	state->rtc[ 4 ] = ( current_time >> 24 ) & 0xff;
+//-------------------------------------------------
+//  nvram_default - called to initialize NVRAM to
+//  its default state
+//-------------------------------------------------
 
-	timer = timer_alloc( device->machine, ds2404_tick , (void *)device);
-	timer_adjust_periodic( timer, ATTOTIME_IN_HZ( 256 ), 0, ATTOTIME_IN_HZ( 256 ) );
-}
-
-
-static DEVICE_RESET( ds2404 )
+void ds2404_device::nvram_default()
 {
+	memset(m_sram, 0, sizeof(m_sram));
 }
 
 
-static DEVICE_NVRAM( ds2404 )
-{
-	ds2404_state *state = get_safe_token(device);
+//-------------------------------------------------
+//  nvram_read - called to read NVRAM from the
+//  .nv file
+//-------------------------------------------------
 
-	if (read_or_write)
-		mame_fwrite(file, state->sram, sizeof(state->sram));
-	else if (file)
-		mame_fread(file, state->sram, sizeof(state->sram));
-	else
-		memset(state->sram, 0, sizeof(state->sram));
+void ds2404_device::nvram_read(mame_file &file)
+{
+	mame_fread(&file, m_sram, sizeof(m_sram));
 }
 
 
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
+//-------------------------------------------------
+//  nvram_write - called to write NVRAM to the
+//  .nv file
+//-------------------------------------------------
 
-#define DEVTEMPLATE_ID(p,s)		p##ds2404##s
-#define DEVTEMPLATE_FEATURES	DT_HAS_START | DT_HAS_RESET | DT_HAS_NVRAM | DT_HAS_INLINE_CONFIG
-#define DEVTEMPLATE_NAME		"DS2404"
-#define DEVTEMPLATE_FAMILY		"NVRAM"
-#include "devtempl.h"
-
-
-DEFINE_LEGACY_NVRAM_DEVICE(DS2404, ds2404);
+void ds2404_device::nvram_write(mame_file &file)
+{
+	mame_fwrite(&file, m_sram, sizeof(m_sram));
+}
diff -Nru src-old/emu/machine/ds2404.h src/emu/machine/ds2404.h
--- src-old/emu/machine/ds2404.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/ds2404.h	2010-08-26 19:13:09.000000000 -0700
@@ -1,23 +1,157 @@
-#ifndef DS2404_H
-#define DS2404_H
+/**********************************************************************
 
-#include "devlegcy.h"
+    DALLAS DS2404
 
-typedef struct _ds2404_config ds2404_config;
-struct _ds2404_config
-{
-	UINT32	ref_year;
-	UINT8	ref_month;
-	UINT8	ref_day;
-};
+    RTC + BACKUP RAM
+
+**********************************************************************/
+
+#ifndef __DS2404_H__
+#define __DS2404_H__
+
+#include "emu.h"
 
 
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
 #define MDRV_DS2404_ADD(_tag, _ref_year, _ref_month, _ref_day) \
 	MDRV_DEVICE_ADD(_tag, DS2404, 0) \
-	MDRV_DEVICE_CONFIG_DATA32(ds2404_config, ref_year, _ref_year) \
-	MDRV_DEVICE_CONFIG_DATA32(ds2404_config, ref_month, _ref_month) \
-	MDRV_DEVICE_CONFIG_DATA32(ds2404_config, ref_day, _ref_day)
+	MDRV_DS2404_REF_YEAR(_ref_year) \
+	MDRV_DS2404_REF_MONTH(_ref_month) \
+	MDRV_DS2404_REF_DAY(_ref_day)
+
+#define MDRV_DS2404_REF_YEAR(_ref_year) \
+	ds2404_device_config::static_set_ref_year(device, _ref_year);
+
+#define MDRV_DS2404_REF_MONTH(_ref_month) \
+	ds2404_device_config::static_set_ref_month(device, _ref_month);
 
+#define MDRV_DS2404_REF_DAY(_ref_day) \
+	ds2404_device_config::static_set_ref_day(device, _ref_day);
+
+
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// ======================> ds2404_device_config
+
+class ds2404_device_config :  public device_config,
+							  public device_config_nvram_interface
+{
+    friend class ds2404_device;
+
+    // construction/destruction
+    ds2404_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+	// inline configuration helpers
+	static void static_set_ref_year(device_config *device, UINT32 m_ref_year);
+	static void static_set_ref_month(device_config *device, UINT8 m_ref_month);
+	static void static_set_ref_day(device_config *device, UINT8 m_ref_day);
+
+protected:
+    // internal state goes here
+	UINT32	m_ref_year;
+	UINT8	m_ref_month;
+	UINT8	m_ref_day;
+};
+
+
+
+// ======================> ds2404_device
+
+class ds2404_device :  public device_t,
+					   public device_nvram_interface
+{
+    friend class ds2404_device_config;
+
+    // construction/destruction
+    ds2404_device(running_machine &_machine, const ds2404_device_config &_config);
+
+public:
+
+	/* 1-wire interface reset  */
+	void ds2404_1w_reset_w(UINT32 offset, UINT8 data);
+
+	/* 3-wire interface reset  */
+	void ds2404_3w_reset_w(UINT32 offset, UINT8 data);
+
+	UINT8 ds2404_data_r(UINT32 offset);
+	void ds2404_data_w(UINT32 offset, UINT8 data);
+	void ds2404_clk_w(UINT32 offset, UINT8 data);
+
+	void ds2404_tick();
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset() { }
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	// device_nvram_interface overrides
+	virtual void nvram_default();
+	virtual void nvram_read(mame_file &file);
+	virtual void nvram_write(mame_file &file);
+
+	static TIMER_CALLBACK( ds2404_tick_callback );
+
+private:
+
+	void ds2404_rom_cmd(UINT8 cmd);
+	void ds2404_cmd(UINT8 cmd);
+
+	UINT8 ds2404_readmem();
+	void ds2404_writemem(UINT8 value);
+
+	enum DS2404_STATE
+	{
+		DS2404_STATE_IDLE = 1,				/* waiting for ROM command, in 1-wire mode */
+		DS2404_STATE_COMMAND,				/* waiting for memory command */
+		DS2404_STATE_ADDRESS1,				/* waiting for address bits 0-7 */
+		DS2404_STATE_ADDRESS2,				/* waiting for address bits 8-15 */
+		DS2404_STATE_OFFSET,				/* waiting for ending offset */
+		DS2404_STATE_INIT_COMMAND,
+		DS2404_STATE_READ_MEMORY,			/* Read Memory command active */
+		DS2404_STATE_WRITE_SCRATCHPAD,		/* Write Scratchpad command active */
+		DS2404_STATE_READ_SCRATCHPAD,		/* Read Scratchpad command active */
+		DS2404_STATE_COPY_SCRATCHPAD		/* Copy Scratchpad command active */
+	};
+
+	UINT16 m_address;
+	UINT16 m_offset;
+	UINT16 m_end_offset;
+	UINT8 m_a1;
+	UINT8 m_a2;
+	UINT8 m_sram[512];	/* 4096 bits */
+	UINT8 m_ram[32];	/* scratchpad ram, 256 bits */
+	UINT8 m_rtc[5];		/* 40-bit RTC counter */
+	DS2404_STATE m_state[8];
+	int m_state_ptr;
+
+    const ds2404_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type DS2404;
+
+
+
+/***************************************************************************
+    PROTOTYPES
+***************************************************************************/
 
 /* 1-wire interface reset */
 WRITE8_DEVICE_HANDLER( ds2404_1w_reset_w );
@@ -29,7 +163,4 @@
 WRITE8_DEVICE_HANDLER( ds2404_data_w );
 WRITE8_DEVICE_HANDLER( ds2404_clk_w );
 
-/* device get info callback */
-DECLARE_LEGACY_NVRAM_DEVICE(DS2404, ds2404);
-
 #endif
diff -Nru src-old/emu/machine/eeprom.c src/emu/machine/eeprom.c
--- src-old/emu/machine/eeprom.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/machine/eeprom.c	2010-08-30 08:20:58.000000000 -0700
@@ -107,28 +107,55 @@
 
 
 //-------------------------------------------------
-//  device_config_complete - perform any
-//  operations now that the configuration is
-//  complete
-//-------------------------------------------------
-
-void eeprom_device_config::device_config_complete()
-{
-	// extract inline configuration from raw data
-	const eeprom_interface *intf = reinterpret_cast<const eeprom_interface *>(m_inline_data[INLINE_INTERFACE]);
-	m_default_data = reinterpret_cast<const UINT8 *>(m_inline_data[INLINE_DATAPTR]);
-	m_default_data_size = m_inline_data[INLINE_DATASIZE];
-	m_default_value = m_inline_data[INLINE_DEFVALUE];
-
-	// inherit a copy of the static data
-	if (intf != NULL)
-		*static_cast<eeprom_interface *>(this) = *intf;
-
-	// now describe our address space
-	if (m_data_bits == 8)
-		m_space_config = address_space_config("eeprom", ENDIANNESS_BIG, 8,  m_address_bits, 0, *ADDRESS_MAP_NAME(eeprom_map8));
+//  static_set_interface - configuration helper
+//  to set the interface
+//-------------------------------------------------
+
+void eeprom_device_config::static_set_interface(device_config *device, const eeprom_interface &interface)
+{
+	eeprom_device_config *eeprom = downcast<eeprom_device_config *>(device);
+	*static_cast<eeprom_interface *>(eeprom) = interface;
+
+	// describe our address space
+	if (eeprom->m_data_bits == 8)
+		eeprom->m_space_config = address_space_config("eeprom", ENDIANNESS_BIG, 8,  eeprom->m_address_bits, 0, *ADDRESS_MAP_NAME(eeprom_map8));
 	else
-		m_space_config = address_space_config("eeprom", ENDIANNESS_BIG, 16, m_address_bits * 2, 0, *ADDRESS_MAP_NAME(eeprom_map16));
+		eeprom->m_space_config = address_space_config("eeprom", ENDIANNESS_BIG, 16, eeprom->m_address_bits * 2, 0, *ADDRESS_MAP_NAME(eeprom_map16));
+}
+
+
+//-------------------------------------------------
+//  static_set_default_data - configuration helpers
+//  to set the default data
+//-------------------------------------------------
+
+void eeprom_device_config::static_set_default_data(device_config *device, const UINT8 *data, UINT32 size)
+{
+	eeprom_device_config *eeprom = downcast<eeprom_device_config *>(device);
+if (eeprom->m_data_bits != 8) mame_printf_warning("16-bit EEPROM set with 8-bit data\n");
+//  assert(eeprom->m_data_bits == 8);
+	eeprom->m_default_data = data;
+	eeprom->m_default_data_size = size;
+}
+
+void eeprom_device_config::static_set_default_data(device_config *device, const UINT16 *data, UINT32 size)
+{
+	eeprom_device_config *eeprom = downcast<eeprom_device_config *>(device);
+if (eeprom->m_data_bits != 16) mame_printf_warning("8-bit EEPROM set with 16-bit data\n");
+//  assert(eeprom->m_data_bits == 16);
+	eeprom->m_default_data = reinterpret_cast<const UINT8 *>(data);
+	eeprom->m_default_data_size = size;
+}
+
+
+//-------------------------------------------------
+//  static_set_default_value - configuration helper
+//  to set the default value
+//-------------------------------------------------
+
+void eeprom_device_config::static_set_default_value(device_config *device, UINT16 value)
+{
+	downcast<eeprom_device_config *>(device)->m_default_value = 0x10000 | value;
 }
 
 
@@ -141,12 +168,7 @@
 {
 	bool error = false;
 
-	if (m_inline_data[INLINE_INTERFACE] == 0)
-	{
-		mame_printf_error("%s: %s eeprom device '%s' did not specify an interface\n", driver.source_file, driver.name, tag());
-		error = true;
-	}
-	else if (m_data_bits != 8 && m_data_bits != 16)
+	if (m_data_bits != 8 && m_data_bits != 16)
 	{
 		mame_printf_error("%s: %s eeprom device '%s' specified invalid data width %d\n", driver.source_file, driver.name, tag(), m_data_bits);
 		error = true;
@@ -239,14 +261,14 @@
 		default_value = m_config.m_default_value;
 	for (offs_t offs = 0; offs < eeprom_length; offs++)
 		if (m_config.m_data_bits == 8)
-			memory_write_byte(m_addrspace[0], offs, default_value);
+			m_addrspace[0]->write_byte(offs, default_value);
 		else
-			memory_write_word(m_addrspace[0], offs * 2, default_value);
+			m_addrspace[0]->write_word(offs * 2, default_value);
 
 	/* handle hard-coded data from the driver */
 	if (m_config.m_default_data != NULL)
 		for (offs_t offs = 0; offs < m_config.m_default_data_size; offs++)
-			memory_write_byte(m_addrspace[0], offs, m_config.m_default_data[offs]);
+			m_addrspace[0]->write_byte(offs, m_config.m_default_data[offs]);
 
 	/* populate from a memory region if present */
 	if (m_region != NULL)
@@ -260,9 +282,9 @@
 
 		for (offs_t offs = 0; offs < eeprom_length; offs++)
 			if (m_config.m_data_bits == 8)
-				memory_write_byte(m_addrspace[0], offs, m_region->u8(offs));
+				m_addrspace[0]->write_byte(offs, m_region->u8(offs));
 			else
-				memory_write_word(m_addrspace[0], offs * 2, m_region->u16(offs));
+				m_addrspace[0]->write_word(offs * 2, m_region->u16(offs));
 	}
 }
 
@@ -280,7 +302,7 @@
 	UINT8 *buffer = auto_alloc_array(&m_machine, UINT8, eeprom_bytes);
 	mame_fread(&file, buffer, eeprom_bytes);
 	for (offs_t offs = 0; offs < eeprom_bytes; offs++)
-		memory_write_byte(m_addrspace[0], offs, buffer[offs]);
+		m_addrspace[0]->write_byte(offs, buffer[offs]);
 	auto_free(&m_machine, buffer);
 }
 
@@ -297,7 +319,7 @@
 
 	UINT8 *buffer = auto_alloc_array(&m_machine, UINT8, eeprom_bytes);
 	for (offs_t offs = 0; offs < eeprom_bytes; offs++)
-		buffer[offs] = memory_read_byte(m_addrspace[0], offs);
+		buffer[offs] = m_addrspace[0]->read_byte(offs);
 	mame_fwrite(&file, buffer, eeprom_bytes);
 	auto_free(&m_machine, buffer);
 }
@@ -391,9 +413,9 @@
 				{
 					m_read_address = (m_read_address + 1) & ((1 << m_config.m_address_bits) - 1);
 					if (m_config.m_data_bits == 16)
-						m_data_bits = memory_read_word(m_addrspace[0], m_read_address * 2);
+						m_data_bits = m_addrspace[0]->read_word(m_read_address * 2);
 					else
-						m_data_bits = memory_read_byte(m_addrspace[0], m_read_address);
+						m_data_bits = m_addrspace[0]->read_byte(m_read_address);
 					m_clock_count = 0;
 logerror("EEPROM read %04x from address %02x\n",m_data_bits,m_read_address);
 				}
@@ -439,9 +461,9 @@
 			if (m_serial_buffer[i] == '1') address |= 1;
 		}
 		if (m_config.m_data_bits == 16)
-			m_data_bits = memory_read_word(m_addrspace[0], address * 2);
+			m_data_bits = m_addrspace[0]->read_word(address * 2);
 		else
-			m_data_bits = memory_read_byte(m_addrspace[0], address);
+			m_data_bits = m_addrspace[0]->read_byte(address);
 		m_read_address = address;
 		m_clock_count = 0;
 		m_sending = 1;
@@ -463,9 +485,9 @@
 		if (m_locked == 0)
 		{
 			if (m_config.m_data_bits == 16)
-				memory_write_word(m_addrspace[0], address * 2, 0x0000);
+				m_addrspace[0]->write_word(address * 2, 0x0000);
 			else
-				memory_write_byte(m_addrspace[0], address, 0x00);
+				m_addrspace[0]->write_byte(address, 0x00);
 		}
 		else
 logerror("Error: EEPROM is m_locked\n");
@@ -492,9 +514,9 @@
 		if (m_locked == 0)
 		{
 			if (m_config.m_data_bits == 16)
-				memory_write_word(m_addrspace[0], address * 2, data);
+				m_addrspace[0]->write_word(address * 2, data);
 			else
-				memory_write_byte(m_addrspace[0], address, data);
+				m_addrspace[0]->write_byte(address, data);
 		}
 		else
 logerror("Error: EEPROM is m_locked\n");
diff -Nru src-old/emu/machine/eeprom.h src/emu/machine/eeprom.h
--- src-old/emu/machine/eeprom.h	2010-06-29 02:02:17.000000000 -0700
+++ src/emu/machine/eeprom.h	2010-08-26 08:21:19.000000000 -0700
@@ -19,7 +19,7 @@
 
 #define MDRV_EEPROM_ADD(_tag, _interface) \
 	MDRV_DEVICE_ADD(_tag, EEPROM, 0) \
-	MDRV_DEVICE_INLINE_DATAPTR(eeprom_device_config::INLINE_INTERFACE, &_interface)
+	eeprom_device_config::static_set_interface(device, _interface); \
 
 #define MDRV_EEPROM_93C46_ADD(_tag) \
 	MDRV_EEPROM_ADD(_tag, eeprom_interface_93C46)
@@ -28,11 +28,10 @@
 	MDRV_EEPROM_ADD(_tag, eeprom_interface_93C66B)
 
 #define MDRV_EEPROM_DATA(_data, _size) \
-	MDRV_DEVICE_INLINE_DATAPTR(eeprom_device_config::INLINE_DATAPTR, &_data) \
-	MDRV_DEVICE_INLINE_DATA16(eeprom_device_config::INLINE_DATASIZE, _size)
+	eeprom_device_config::static_set_default_data(device, _data, _size); \
 
 #define MDRV_EEPROM_DEFAULT_VALUE(_value) \
-	MDRV_DEVICE_INLINE_DATA32(eeprom_device_config::INLINE_DEFVALUE, 0x10000 | ((_value) & 0xffff))
+	eeprom_device_config::static_set_default_value(device, _value); \
 
 
 
@@ -76,28 +75,26 @@
 	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 	virtual device_t *alloc_device(running_machine &machine) const;
 
-	// inline configuration indexes
-	enum
-	{
-		INLINE_INTERFACE,
-		INLINE_DATAPTR,
-		INLINE_DATASIZE,
-		INLINE_DEFVALUE
-	};
+	// inline configuration helpers
+	static void static_set_interface(device_config *deviec, const eeprom_interface &interface);
+	static void static_set_default_data(device_config *device, const UINT8 *data, UINT32 size);
+	static void static_set_default_data(device_config *device, const UINT16 *data, UINT32 size);
+	static void static_set_default_value(device_config *device, UINT16 value);
 
 protected:
 	// device_config overrides
-	virtual void device_config_complete();
 	virtual bool device_validity_check(const game_driver &driver) const;
 
 	// device_config_memory_interface overrides
 	virtual const address_space_config *memory_space_config(int spacenum = 0) const;
 
 	// device-specific configuration
+	address_space_config		m_space_config;
+
+	// internal state
 	const UINT8 *				m_default_data;
 	int 						m_default_data_size;
 	UINT32						m_default_value;
-	address_space_config		m_space_config;
 };
 
 
diff -Nru src-old/emu/machine/f3853.c src/emu/machine/f3853.c
--- src-old/emu/machine/f3853.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/f3853.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,233 +1,288 @@
-/*
-  fairchild f3853 smi static ram interface
-  with integrated interrupt controller and timer
+/**********************************************************************
 
-  databook found at www.freetradezone.com
-*/
+    Fairchild F3853 SRAM interface with integrated interrupt
+    controller and timer (SMI)
+
+    This chip is a timer shift register, basically the same as in the
+    F3851.
+
+    Based on a datasheet obtained from www.freetradezone.com
+
+    The SMI does not have DC0 and DC1, only DC0; as a result, it does
+    not respond to the main CPU's DC0/DC1 swap instruction.  This may
+    lead to two devices responding to the same DC0 address and
+    attempting to place their bytes on the data bus simultaneously!
+
+    8-bit shift register:
+    Feedback in0 = !((out3 ^ out4) ^ (out5 ^ out7))
+    Interrupts are at 0xfe
+    0xff stops the register (0xfe is never reached)
+
+**********************************************************************/
 
 #include "emu.h"
 #include "f3853.h"
+#include "devhelpr.h"
+
+/***************************************************************************
+    MACROS
+***************************************************************************/
+
+#define INTERRUPT_VECTOR(external) ( external ? m_low | ( m_high << 8 ) | 0x80 \
+: ( m_low | ( m_high << 8 ) ) & ~0x80 )
+
+
+
+/***************************************************************************
+    IMPLEMENTATION
+***************************************************************************/
+
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+//-------------------------------------------------
+//  f3853_device_config - constructor
+//-------------------------------------------------
+
+f3853_device_config::f3853_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, "F3853", tag, owner, clock)
+{
+}
+
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *f3853_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+    return global_alloc(f3853_device_config(mconfig, tag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *f3853_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, f3853_device(machine, *this));
+}
+
 
-/*
-  the smi does not have DC0 and DC1, only DC0
-  it is not reacting to the cpus DC0/DC1 swap instruction
-  --> might lead to 2 devices having reacting to the same DC0 address
-  and placing their bytes to the databus!
-*/
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
 
+void f3853_device_config::device_config_complete()
+{
+	// inherit a copy of the static data
+	const f3853_interface *intf = reinterpret_cast<const f3853_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<f3853_interface *>(this) = *intf;
+	}
 
-typedef struct _f3853 f3853_t;
-struct _f3853 {
-    const f3853_config *config;
+	// or initialize to defaults if none provided
+	else
+	{
+		memset(&m_interrupt_request, 0, sizeof(m_interrupt_request));
+	}
+}
 
-    UINT8 high,low; // bit 7 set to 0 for timer interrupt, to 1 for external interrupt
-    int external_enable;
-    int timer_enable;
 
-    int request_flipflop;
 
-    int priority_line; /* inverted level*/
-    int external_interrupt_line;/* inverted level */
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
 
-    emu_timer *timer;
-};
+const device_type F3853 = f3853_device_config::static_alloc_device_config;
 
-/*
-   8 bit shift register
-   feedback in0 = not ( (out3 xor out4) xor (out5 xor out7) )
-   interrupt at 0xfe
-   0xff stops register (0xfe never reached!)
-*/
-static UINT8 f3853_value_to_cycle[0x100];
+//-------------------------------------------------
+//  f3853_device - constructor
+//-------------------------------------------------
 
+f3853_device::f3853_device(running_machine &_machine, const f3853_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
+{
 
-static TIMER_CALLBACK( f3853_timer_callback );
-#define INTERRUPT_VECTOR(external) ( external ? f3853->low | ( f3853->high << 8 ) | 0x80 \
-					: ( f3853->low | ( f3853->high << 8 ) ) & ~0x80 )
+}
 
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
 
-INLINE f3853_t *get_safe_token(running_device *device)
+void f3853_device::device_start()
 {
-	assert( device != NULL );
-	assert( device->type() == F3853 );
-	return ( f3853_t * ) downcast<legacy_device_base *>(device)->token();
+	UINT8 reg = 0xfe;
+	for(INT32 i=254 /* Known to get 0xfe after 255 cycles */; i >= 0; i--)
+	{
+		INT32 o7 = (reg & 0x80) ? TRUE : FALSE;
+		INT32 o5 = (reg & 0x20) ? TRUE : FALSE;
+		INT32 o4 = (reg & 0x10) ? TRUE : FALSE;
+		INT32 o3 = (reg & 0x08) ? TRUE : FALSE;
+		m_value_to_cycle[reg] = i;
+		reg <<= 1;
+		if(!((o7 != o5) != (o4 != o3)))
+		{
+			reg |= 1;
+		}
+	}
+
+	m_timer = timer_alloc(&m_machine, f3853_timer_callback, (void *)this );
+
+	state_save_register_device_item(this, 0, m_high );
+	state_save_register_device_item(this, 0, m_low );
+	state_save_register_device_item(this, 0, m_external_enable );
+	state_save_register_device_item(this, 0, m_timer_enable );
+	state_save_register_device_item(this, 0, m_request_flipflop );
+	state_save_register_device_item(this, 0, m_priority_line );
+	state_save_register_device_item(this, 0, m_external_interrupt_line );
 }
 
 
-static void f3853_set_interrupt_request_line(running_device *device)
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void f3853_device::device_reset()
 {
-	f3853_t	*f3853 = get_safe_token( device );
+	m_high = 0;
+	m_low = 0;
+	m_external_enable = 0;
+	m_timer_enable = 0;
+	m_request_flipflop = 0;
+	m_priority_line = FALSE;
+	m_external_interrupt_line = TRUE;
 
-    if ( ! f3853->config->interrupt_request )
+	timer_enable(m_timer, 0);
+}
+
+
+void f3853_device::f3853_set_interrupt_request_line()
+{
+    if(!m_config.m_interrupt_request)
+    {
 		return;
+	}
 
-	if ( f3853->external_enable && ! f3853->priority_line )
-		f3853->config->interrupt_request(device, INTERRUPT_VECTOR(TRUE), TRUE);
-	else if ( f3853->timer_enable && ! f3853->priority_line && f3853->request_flipflop)
-		f3853->config->interrupt_request(device, INTERRUPT_VECTOR(FALSE), TRUE);
+	if(m_external_enable && !m_priority_line)
+	{
+		m_config.m_interrupt_request(this, INTERRUPT_VECTOR(TRUE), TRUE);
+	}
+	else if( m_timer_enable && !m_priority_line && m_request_flipflop)
+	{
+		m_config.m_interrupt_request(this, INTERRUPT_VECTOR(FALSE), TRUE);
+	}
 	else
-		f3853->config->interrupt_request(device, 0, FALSE);
+	{
+		m_config.m_interrupt_request(this, 0, FALSE);
+	}
 }
 
 
-static void f3853_timer_start(running_device *device, UINT8 value)
+void f3853_device::f3853_timer_start(UINT8 value)
 {
-	f3853_t	*f3853 = get_safe_token( device );
-
-	attotime period = (value != 0xff) ? attotime_mul(ATTOTIME_IN_HZ(device->clock()), f3853_value_to_cycle[value]*31) : attotime_never;
+	attotime period = (value != 0xff) ? attotime_mul(ATTOTIME_IN_HZ(clock()), m_value_to_cycle[value]*31) : attotime_never;
 
-	timer_adjust_oneshot(f3853->timer, period, 0);
+	timer_adjust_oneshot(m_timer, period, 0);
 }
 
 
-static TIMER_CALLBACK( f3853_timer_callback )
+TIMER_CALLBACK( f3853_device::f3853_timer_callback )
 {
-	running_device *device = (running_device *)ptr;
-	f3853_t	*f3853 = get_safe_token( device );
+	reinterpret_cast<f3853_device*>(ptr)->f3853_timer();
+}
 
-    if (f3853->timer_enable)
+void f3853_device::f3853_timer()
+{
+    if(m_timer_enable)
 	{
-		f3853->request_flipflop = TRUE;
-		f3853_set_interrupt_request_line( device );
+		m_request_flipflop = TRUE;
+		f3853_set_interrupt_request_line();
     }
-    f3853_timer_start( device, 0xfe);
+    f3853_timer_start(0xfe);
 }
 
 
 void f3853_set_external_interrupt_in_line(running_device *device, int level)
 {
-	f3853_t	*f3853 = get_safe_token( device );
+	downcast<f3853_device*>(device)->f3853_set_external_interrupt_in_line(level);
+}
 
-    if ( f3853->external_interrupt_line && ! level && f3853->external_enable)
-	f3853->request_flipflop = TRUE;
-    f3853->external_interrupt_line = level;
-    f3853_set_interrupt_request_line( device );
+void f3853_device::f3853_set_external_interrupt_in_line(int level)
+{
+    if(m_external_interrupt_line && !level && m_external_enable)
+    {
+		m_request_flipflop = TRUE;
+	}
+    m_external_interrupt_line = level;
+    f3853_set_interrupt_request_line();
 }
 
 
 void f3853_set_priority_in_line(running_device *device, int level)
 {
-	f3853_t	*f3853 = get_safe_token( device );
+	downcast<f3853_device*>(device)->f3853_set_priority_in_line(level);
+}
 
-    f3853->priority_line = level;
-    f3853_set_interrupt_request_line( device );
+void f3853_device::f3853_set_priority_in_line(int level)
+{
+    m_priority_line = level;
+    f3853_set_interrupt_request_line();
 }
 
 
-READ8_DEVICE_HANDLER(f3853_r)
+READ8_DEVICE_HANDLER_TRAMPOLINE(f3853, f3853_r)
 {
-	f3853_t	*f3853 = get_safe_token( device );
-    UINT8 data=0;
+    UINT8 data = 0;
 
     switch (offset)
 	{
     case 0:
-		data = f3853->high;
+		data = m_high;
 		break;
+
     case 1:
-		data = f3853->low;
+		data = m_low;
 		break;
-    case 2: // interrupt control; not readable
-    case 3: // timer; not readable
+
+    case 2: // Interrupt control; not readable
+    case 3: // Timer; not readable
 		break;
     }
+
     return data;
 }
 
 
-WRITE8_DEVICE_HANDLER(f3853_w)
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(f3853, f3853_w)
 {
-	f3853_t	*f3853 = get_safe_token( device );
-	switch (offset)
+	switch(offset)
 	{
 	case 0:
-		f3853->high = data;
+		m_high = data;
 		break;
+
 	case 1:
-		f3853->low = data;
+		m_low = data;
 		break;
+
 	case 2: //interrupt control
-		f3853->external_enable = ((data&3)==1);
-		f3853->timer_enable = ((data&3)==3);
-		f3853_set_interrupt_request_line( device );
+		m_external_enable = ((data & 3) == 1);
+		m_timer_enable = ((data & 3) == 3);
+		f3853_set_interrupt_request_line();
 		break;
+
 	case 3: //timer
-		f3853->request_flipflop = FALSE;
-		f3853_set_interrupt_request_line( device );
-		f3853_timer_start( device, data );
+		m_request_flipflop = FALSE;
+		f3853_set_interrupt_request_line();
+		f3853_timer_start(data);
 		break;
 	}
 }
-
-
-static DEVICE_START( f3853 )
-{
-	f3853_t *f3853 = get_safe_token( device );
-	UINT8 reg=0xfe;
-	int i;
-
-	f3853->config = (const f3853_config *)device->baseconfig().static_config();
-
-	for (i=254/*known to get 0xfe after 255 cycles*/; i>=0; i--)
-	{
-		int o7 = ( reg & 0x80 ) ? TRUE : FALSE;
-		int o5 = ( reg & 0x20 ) ? TRUE : FALSE;
-		int o4 = ( reg & 0x10 ) ? TRUE : FALSE;
-		int o3 = ( reg & 8 ) ? TRUE : FALSE;
-		f3853_value_to_cycle[reg]=i;
-		reg<<=1;
-		if (!((o7!=o5)!=(o4!=o3))) reg|=1;
-	}
-
-	f3853->timer = timer_alloc( device->machine, f3853_timer_callback, (void *)device );
-
-	state_save_register_device_item( device, 0, f3853->high );
-	state_save_register_device_item( device, 0, f3853->low );
-	state_save_register_device_item( device, 0, f3853->external_enable );
-	state_save_register_device_item( device, 0, f3853->timer_enable );
-	state_save_register_device_item( device, 0, f3853->request_flipflop );
-	state_save_register_device_item( device, 0, f3853->priority_line );
-	state_save_register_device_item( device, 0, f3853->external_interrupt_line );
-}
-
-
-static DEVICE_RESET( f3853 )
-{
-	f3853_t	*f3853 = get_safe_token( device );
-
-	f3853->high = 0;
-	f3853->low = 0;
-	f3853->external_enable = 0;
-	f3853->timer_enable = 0;
-	f3853->request_flipflop = 0;
-	f3853->priority_line = FALSE;
-	f3853->external_interrupt_line = TRUE;
-
-	timer_enable( f3853->timer, 0 );
-}
-
-
-DEVICE_GET_INFO( f3853 )
-{
-	switch ( state )
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:				info->i = sizeof(f3853_t);						break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:		info->i = 0;									break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:						info->start = DEVICE_START_NAME(f3853);			break;
-		case DEVINFO_FCT_STOP:						/* nothing */									break;
-		case DEVINFO_FCT_RESET:						info->reset = DEVICE_RESET_NAME(f3853);			break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:						strcpy(info->s, "F3853");						break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "F8");							break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.0");							break;
-		case DEVINFO_STR_SOURCE_FILE:				strcpy(info->s, __FILE__);						break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright the MAME and MESS Teams"); break;
-	}
-}
-
-
-DEFINE_LEGACY_DEVICE(F3853, f3853);
diff -Nru src-old/emu/machine/f3853.h src/emu/machine/f3853.h
--- src-old/emu/machine/f3853.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/f3853.h	2010-08-30 08:20:58.000000000 -0700
@@ -1,41 +1,128 @@
-/*
-  fairchild f3853 static ram interface smi
-  with integrated interrupt controller and timer
+/**********************************************************************
 
-  timer shift register basically the same as in f3851!
-*/
+    Fairchild F3853 SRAM interface with integrated interrupt
+    controller and timer
+
+    This chip is a timer shift register, basically the same as in the
+    F3851.
+
+**********************************************************************/
 
 #pragma once
 
 #ifndef __F3853_H__
 #define __F3853_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
+
+
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MDRV_F3853_ADD(_tag, _clock, _intrf) \
+	MDRV_DEVICE_ADD(_tag, F3853, _clock) \
+	MDRV_DEVICE_CONFIG(_intrf)
+
 
-DECLARE_LEGACY_DEVICE(F3853, f3853);
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _f3853_config f3853_config;
-struct _f3853_config
+
+// ======================> f3853_interface
+
+struct f3853_interface
 {
-    void (*interrupt_request)(running_device *device, UINT16 addr, int level);
+    void (*m_interrupt_request)(running_device *device, UINT16 addr, int level);
 };
 
 
-/***************************************************************************
-    DEVICE CONFIGURATION MACROS
-***************************************************************************/
+// ======================> f3853_device_config
 
-#define MDRV_F3853_ADD(_tag, _clock, _intrf) \
-	MDRV_DEVICE_ADD(_tag, F3853, _clock) \
-	MDRV_DEVICE_CONFIG(_intrf)
+class f3853_device_config :   public device_config,
+							  public f3853_interface
+{
+    friend class f3853_device;
+
+    // construction/destruction
+    f3853_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+// ======================> f3853_device
 
+class f3853_device :  public device_t
+{
+    friend class f3853_device_config;
+
+    // construction/destruction
+    f3853_device(running_machine &_machine, const f3853_device_config &_config);
+
+public:
+
+	UINT8 f3853_r(UINT32 offset);
+	void f3853_w(UINT32 offset, UINT8 data);
+
+	void f3853_set_external_interrupt_in_line(int level);
+	void f3853_set_priority_in_line(int level);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+	static TIMER_CALLBACK( f3853_timer_callback );
+
+private:
+
+	void f3853_set_interrupt_request_line();
+	void f3853_timer_start(UINT8 value);
+	void f3853_timer();
+
+    UINT8 m_high;
+    UINT8 m_low; // Bit 7 is set to 0 for timer interrupts, 1 for external interrupts
+    INT32 m_external_enable;
+    INT32 m_timer_enable;
+
+    INT32 m_request_flipflop;
+
+    INT32 m_priority_line;				/* inverted level*/
+    INT32 m_external_interrupt_line;	/* inverted level */
+
+    emu_timer *m_timer;
+
+	UINT8 m_value_to_cycle[0x100];
+
+    const f3853_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type F3853;
+
+
+
+/***************************************************************************
+    PROTOTYPES
+***************************************************************************/
 
-READ8_DEVICE_HANDLER(f3853_r);
-WRITE8_DEVICE_HANDLER(f3853_w);
+READ8_DEVICE_HANDLER( f3853_r );
+WRITE8_DEVICE_HANDLER( f3853_w );
 
 void f3853_set_external_interrupt_in_line(running_device *device, int level);
 void f3853_set_priority_in_line(running_device *device, int level);
diff -Nru src-old/emu/machine/generic.c src/emu/machine/generic.c
--- src-old/emu/machine/generic.c	2010-07-06 20:30:06.000000000 -0700
+++ src/emu/machine/generic.c	2010-08-18 23:57:51.000000000 -0700
@@ -816,7 +816,7 @@
 -------------------------------------------------*/
 
 WRITE8_HANDLER( watchdog_reset_w ) { watchdog_reset(space->machine); }
-READ8_HANDLER( watchdog_reset_r ) { watchdog_reset(space->machine); return space->unmap; }
+READ8_HANDLER( watchdog_reset_r ) { watchdog_reset(space->machine); return space->unmap(); }
 
 
 /*-------------------------------------------------
@@ -824,7 +824,7 @@
 -------------------------------------------------*/
 
 WRITE16_HANDLER( watchdog_reset16_w ) {	watchdog_reset(space->machine); }
-READ16_HANDLER( watchdog_reset16_r ) { watchdog_reset(space->machine); return space->unmap; }
+READ16_HANDLER( watchdog_reset16_r ) { watchdog_reset(space->machine); return space->unmap(); }
 
 
 /*-------------------------------------------------
@@ -832,7 +832,7 @@
 -------------------------------------------------*/
 
 WRITE32_HANDLER( watchdog_reset32_w ) {	watchdog_reset(space->machine); }
-READ32_HANDLER( watchdog_reset32_r ) { watchdog_reset(space->machine); return space->unmap; }
+READ32_HANDLER( watchdog_reset32_r ) { watchdog_reset(space->machine); return space->unmap(); }
 
 
 
diff -Nru src-old/emu/machine/i2cmem.c src/emu/machine/i2cmem.c
--- src-old/emu/machine/i2cmem.c	2010-07-10 12:31:17.000000000 -0700
+++ src/emu/machine/i2cmem.c	2010-08-30 08:20:58.000000000 -0700
@@ -110,6 +110,18 @@
 
 
 //-------------------------------------------------
+//  static_set_interface - set the device
+//  configuration
+//-------------------------------------------------
+
+void i2cmem_device_config::static_set_interface(device_config *device, const i2cmem_interface &interface)
+{
+	i2cmem_device_config *i2cmem = downcast<i2cmem_device_config *>(device);
+	*static_cast<i2cmem_interface *>(i2cmem) = interface;
+}
+
+
+//-------------------------------------------------
 //  device_config_complete - perform any
 //  operations now that the configuration is
 //  complete
@@ -117,15 +129,6 @@
 
 void i2cmem_device_config::device_config_complete()
 {
-	// extract inline configuration from raw data
-	const i2cmem_interface *intf = reinterpret_cast<const i2cmem_interface *>( m_inline_data[ INLINE_INTERFACE ] );
-
-	// inherit a copy of the static data
-	if( intf != NULL )
-	{
-		*static_cast<i2cmem_interface *>(this) = *intf;
-	}
-
 	m_space_config = address_space_config( "i2cmem", ENDIANNESS_BIG, 8,  m_address_bits, 0, *ADDRESS_MAP_NAME( i2cmem_map8 ) );
 }
 
@@ -138,13 +141,6 @@
 bool i2cmem_device_config::device_validity_check( const game_driver &driver ) const
 {
 	bool error = false;
-
-	if( m_inline_data[ INLINE_INTERFACE ] == 0 )
-	{
-		mame_printf_error( "%s: %s i2cmem device '%s' did not specify an interface\n", driver.source_file, driver.name, tag() );
-		error = true;
-	}
-
 	return error;
 }
 
@@ -183,9 +179,9 @@
 	m_sdar( 1 ),
 	m_state( STATE_IDLE )
 {
-	if( m_page_size > 0 )
+	if( m_config.m_page_size > 0 )
 	{
-		m_page = auto_alloc_array( machine, UINT8, m_page_size );
+		m_page = auto_alloc_array( machine, UINT8, m_config.m_page_size );
 	}
 }
 
@@ -208,7 +204,7 @@
 	state_save_register_device_item( this, 0, m_shift );
 	state_save_register_device_item( this, 0, m_devsel );
 	state_save_register_device_item( this, 0, m_byteaddr );
-	state_save_register_device_item_pointer( this, 0, m_page, m_page_size );
+	state_save_register_device_item_pointer( this, 0, m_page, m_config.m_page_size );
 }
 
 
@@ -233,7 +229,7 @@
 	UINT16 default_value = 0xff;
 	for( offs_t offs = 0; offs < i2cmem_bytes; offs++ )
 	{
-		memory_write_byte( m_addrspace[ 0 ], offs, default_value );
+		m_addrspace[ 0 ]->write_byte( offs, default_value );
 	}
 
 	/* populate from a memory region if present */
@@ -251,7 +247,7 @@
 
 		for( offs_t offs = 0; offs < i2cmem_bytes; offs++ )
 		{
-			memory_write_byte( m_addrspace[ 0 ], offs, m_region->u8( offs ) );
+			m_addrspace[ 0 ]->write_byte( offs, m_region->u8( offs ) );
 		}
 	}
 }
@@ -271,7 +267,7 @@
 
 	for( offs_t offs = 0; offs < i2cmem_bytes; offs++ )
 	{
-		memory_write_byte( m_addrspace[ 0 ], offs, buffer[ offs ] );
+		m_addrspace[ 0 ]->write_byte( offs, buffer[ offs ] );
 	}
 
 	auto_free( &m_machine, buffer );
@@ -289,7 +285,7 @@
 
 	for( offs_t offs = 0; offs < i2cmem_bytes; offs++ )
 	{
-		buffer[ offs ] = memory_read_byte( m_addrspace[ 0 ], offs );
+		buffer[ offs ] = m_addrspace[ 0 ]->read_byte( offs );
 	}
 
 	mame_fwrite( &file, buffer, i2cmem_bytes );
@@ -384,7 +380,6 @@
 	}
 }
 
-
 WRITE_LINE_DEVICE_HANDLER( i2cmem_scl_write )
 {
 	downcast<i2cmem_device *>( device )->set_scl_line( state );
@@ -451,21 +446,21 @@
 							verboselog( this, 0, "write not enabled\n" );
 							m_state = STATE_IDLE;
 						}
-						else if( m_page_size > 0 )
+						else if( m_config.m_page_size > 0 )
 						{
 							m_page[ m_page_offset ] = m_shift;
 							verboselog( this, 1, "page[ %04x ] <- %02x\n", m_page_offset, m_page[ m_page_offset ] );
 
 							m_page_offset++;
-							if( m_page_offset == m_page_size )
+							if( m_page_offset == m_config.m_page_size )
 							{
-								int offset = data_offset() & ~( m_page_size - 1 );
+								int offset = data_offset() & ~( m_config.m_page_size - 1 );
 
-								verboselog( this, 1, "data[ %04x to %04x ] = page\n", offset, offset + m_page_size - 1 );
+								verboselog( this, 1, "data[ %04x to %04x ] = page\n", offset, offset + m_config.m_page_size - 1 );
 
-								for( int i = 0; i < m_page_size; i++ )
+								for( int i = 0; i < m_config.m_page_size; i++ )
 								{
-									memory_write_byte( m_addrspace[ 0 ], offset + i, m_page[ i ] );
+									m_addrspace[ 0 ]->write_byte( offset + i, m_page[ i ] );
 								}
 
 								m_page_offset = 0;
@@ -476,7 +471,7 @@
 							int offset = data_offset();
 
 							verboselog( this, 1, "data[ %04x ] <- %02x\n", offset, m_shift );
-							memory_write_byte( m_addrspace[ 0 ], offset, m_shift );
+							m_addrspace[ 0 ]->write_byte( offset, m_shift );
 
 							m_byteaddr++;
 						}
@@ -509,7 +504,7 @@
 					{
 						int offset = data_offset();
 
-						m_shift = memory_read_byte( m_addrspace[ 0 ], offset );
+						m_shift = m_addrspace[ 0 ]->read_byte( offset );
 						verboselog( this, 1, "data[ %04x ] -> %02x\n", offset, m_shift );
 						m_byteaddr++;
 					}
diff -Nru src-old/emu/machine/i2cmem.h src/emu/machine/i2cmem.h
--- src-old/emu/machine/i2cmem.h	2010-07-07 06:05:02.000000000 -0700
+++ src/emu/machine/i2cmem.h	2010-08-26 08:21:19.000000000 -0700
@@ -26,7 +26,7 @@
 
 #define MDRV_I2CMEM_ADD( _tag, _interface ) \
 	MDRV_DEVICE_ADD( _tag, I2CMEM, 0 ) \
-	MDRV_DEVICE_INLINE_DATAPTR( i2cmem_device_config::INLINE_INTERFACE, &_interface )
+	i2cmem_device_config::static_set_interface(device, _interface);
 
 
 //**************************************************************************
@@ -61,11 +61,8 @@
 	static device_config *static_alloc_device_config( const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock );
 	virtual device_t *alloc_device( running_machine &machine ) const;
 
-	// inline configuration indexes
-	enum
-	{
-		INLINE_INTERFACE
-	};
+	// inline configuration
+	static void static_set_interface(device_config *device, const i2cmem_interface &interface);
 
 protected:
 	// device_config overrides
@@ -135,7 +132,6 @@
 	int m_byteaddr;
 	UINT8 *m_page;
 	int m_page_offset;
-	int m_page_size;
 };
 
 
diff -Nru src-old/emu/machine/i8243.c src/emu/machine/i8243.c
--- src-old/emu/machine/i8243.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/i8243.c	2010-08-27 05:17:06.000000000 -0700
@@ -10,57 +10,106 @@
 
 #include "emu.h"
 #include "i8243.h"
+#include "devhelpr.h"
 
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+GENERIC_DEVICE_CONFIG_SETUP(i8243, "I8243")
+
+//-------------------------------------------------
+//  static_set_read_handler - configuration helper
+//  to set the read handler
+//-------------------------------------------------
+
+void i8243_device_config::static_set_read_handler(device_config *device, read8_device_func callback)
+{
+	i8243_device_config *i8243 = downcast<i8243_device_config *>(device);
+	if(callback != NULL)
+	{
+		i8243->m_readhandler.type = DEVCB_TYPE_SELF;
+		i8243->m_readhandler.readdevice = callback;
+	}
+	else
+	{
+		i8243->m_readhandler.type = DEVCB_TYPE_NULL;
+	}
+}
+
+
+//-------------------------------------------------
+//  static_set_write_handler - configuration helper
+//  to set the write handler
+//-------------------------------------------------
+
+void i8243_device_config::static_set_write_handler(device_config *device, write8_device_func callback)
+{
+	i8243_device_config *i8243 = downcast<i8243_device_config *>(device);
+	if(callback != NULL)
+	{
+		i8243->m_writehandler.type = DEVCB_TYPE_SELF;
+		i8243->m_writehandler.writedevice = callback;
+	}
+	else
+	{
+		i8243->m_writehandler.type = DEVCB_TYPE_NULL;
+	}
+}
 
-/* live processor state */
-typedef struct _i8243_state i8243_state;
-struct _i8243_state
-{
-	UINT8		p[4];				/* 4 ports' worth of data */
-	UINT8		p2out;				/* port 2 bits that will be returned */
-	UINT8		p2;					/* most recent port 2 value */
-	UINT8		opcode;				/* latched opcode */
-	UINT8		prog;				/* previous PROG state */
-};
 
 
 /***************************************************************************
-    INLINE FUNCTIONS
+    LIVE DEVICE
 ***************************************************************************/
 
-INLINE i8243_state *get_safe_token(running_device *device)
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type I8243 = i8243_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  i8243_device - constructor
+//-------------------------------------------------
+
+i8243_device::i8243_device(running_machine &_machine, const i8243_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert(device->type() == I8243);
-	return (i8243_state *)downcast<legacy_device_base *>(device)->token();
+
 }
 
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
 
-INLINE i8243_config *get_safe_config(running_device *device)
+void i8243_device::device_start()
 {
-	assert(device != NULL);
-	assert(device->type() == I8243);
-	return (i8243_config *)downcast<const legacy_device_config_base &>(device->baseconfig()).inline_config();
+	devcb_resolve_read8(&m_readhandler, &m_config.m_readhandler, this);
+	devcb_resolve_write8(&m_writehandler, &m_config.m_writehandler, this);
 }
 
 
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void i8243_device::device_reset()
+{
+	m_p2 = 0x0f;
+	m_p2out = 0x0f;
+	m_prog = 1;
+}
 
-/***************************************************************************
-    DEVICE INTERFACE
-***************************************************************************/
 
 /*-------------------------------------------------
     i8243_p2_r - handle a read from port 2
 -------------------------------------------------*/
 
-READ8_DEVICE_HANDLER( i8243_p2_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(i8243, i8243_p2_r)
 {
-	i8243_state *i8243 = get_safe_token(device);
-	return i8243->p2out;
+	return m_p2out;
 }
 
 
@@ -68,10 +117,9 @@
     i8243_p2_r - handle a write to port 2
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( i8243_p2_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(i8243, i8243_p2_w)
 {
-	i8243_state *i8243 = get_safe_token(device);
-	i8243->p2 = data & 0x0f;
+	m_p2 = data & 0x0f;
 }
 
 
@@ -80,110 +128,49 @@
     line state
 -------------------------------------------------*/
 
-WRITE8_DEVICE_HANDLER( i8243_prog_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(i8243, i8243_prog_w)
 {
-	i8243_state *i8243 = get_safe_token(device);
-	i8243_config *config = get_safe_config(device);
-
 	/* only care about low bit */
 	data &= 1;
 
 	/* on high->low transition state, latch opcode/port */
-	if (i8243->prog && !data)
+	if(m_prog && !data)
 	{
-		i8243->opcode = i8243->p2;
+		m_opcode = m_p2;
 
 		/* if this is a read opcode, copy result to p2out */
-		if ((i8243->opcode >> 2) == MCS48_EXPANDER_OP_READ)
+		if((m_opcode >> 2) == MCS48_EXPANDER_OP_READ)
 		{
-			if (config->readhandler != NULL)
-				i8243->p[i8243->opcode & 3] = (*config->readhandler)(device, i8243->opcode & 3);
-			i8243->p2out = i8243->p[i8243->opcode & 3] & 0x0f;
+			if (m_readhandler.read != NULL)
+			{
+				m_p[m_opcode & 3] = devcb_call_read8(&m_readhandler, m_opcode & 3);
+			}
+			m_p2out = m_p[m_opcode & 3] & 0x0f;
 		}
 	}
 
 	/* on low->high transition state, act on opcode */
-	else if (!i8243->prog && data)
+	else if(!m_prog && data)
 	{
-		switch (i8243->opcode >> 2)
+		switch(m_opcode >> 2)
 		{
 			case MCS48_EXPANDER_OP_WRITE:
-				i8243->p[i8243->opcode & 3] = i8243->p2 & 0x0f;
-				if (config->writehandler != NULL)
-					(*config->writehandler)(device, i8243->opcode & 3, i8243->p[i8243->opcode & 3]);
+				m_p[m_opcode & 3] = m_p2 & 0x0f;
+				devcb_call_write8(&m_writehandler, m_opcode & 3, m_p[m_opcode & 3]);
 				break;
 
 			case MCS48_EXPANDER_OP_OR:
-				i8243->p[i8243->opcode & 3] |= i8243->p2 & 0x0f;
-				if (config->writehandler != NULL)
-					(*config->writehandler)(device, i8243->opcode & 3, i8243->p[i8243->opcode & 3]);
+				m_p[m_opcode & 3] |= m_p2 & 0x0f;
+				devcb_call_write8(&m_writehandler, m_opcode & 3, m_p[m_opcode & 3]);
 				break;
 
 			case MCS48_EXPANDER_OP_AND:
-				i8243->p[i8243->opcode & 3] &= i8243->p2 & 0x0f;
-				if (config->writehandler != NULL)
-					(*config->writehandler)(device, i8243->opcode & 3, i8243->p[i8243->opcode & 3]);
+				m_p[m_opcode & 3] &= m_p2 & 0x0f;
+				devcb_call_write8(&m_writehandler, m_opcode & 3, m_p[m_opcode & 3]);
 				break;
 		}
 	}
 
 	/* remember the state */
-	i8243->prog = data;
+	m_prog = data;
 }
-
-
-
-/***************************************************************************
-    DEVICE INTERFACE
-***************************************************************************/
-
-/*-------------------------------------------------
-    DEVICE_START( i8243 )
--------------------------------------------------*/
-
-static DEVICE_START( i8243 )
-{
-}
-
-
-/*-------------------------------------------------
-    DEVICE_RESET( i8243 )
--------------------------------------------------*/
-
-static DEVICE_RESET( i8243 )
-{
-	i8243_state *i8243 = get_safe_token(device);
-
-	i8243->p2 = 0x0f;
-	i8243->p2out = 0x0f;
-	i8243->prog = 1;
-}
-
-
-/*-------------------------------------------------
-    DEVICE_GET_INFO( i8243 )
--------------------------------------------------*/
-
-DEVICE_GET_INFO( i8243 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(i8243_state);			break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:			info->i = sizeof(i8243_config);			break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:			info->start = DEVICE_START_NAME(i8243);					break;
-		case DEVINFO_FCT_RESET:			info->reset = DEVICE_RESET_NAME(i8243);					break;
-
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "I8243");				break;
-		case DEVINFO_STR_FAMILY:						strcpy(info->s, "MCS-48");				break;
-		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");					break;
-		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);				break;
-		case DEVINFO_STR_CREDITS:						/* Nothing */							break;
-	}
-}
-
-
-DEFINE_LEGACY_DEVICE(I8243, i8243);
diff -Nru src-old/emu/machine/i8243.h src/emu/machine/i8243.h
--- src-old/emu/machine/i8243.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/i8243.h	2010-08-26 21:51:58.000000000 -0700
@@ -13,39 +13,100 @@
 #ifndef __I8243_H__
 #define __I8243_H__
 
-#include "devlegcy.h"
+#include "emu.h"
 #include "cpu/mcs48/mcs48.h"
 
 
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_I8243_ADD(_tag, _read, _write) \
+	MDRV_DEVICE_ADD(_tag, I8243, 0) \
+	MDRV_I8243_READHANDLER(_read) \
+	MDRV_I8243_WRITEHANDLER(_write) \
+
+#define MDRV_I8243_READHANDLER(_read) \
+	i8243_device_config::static_set_read_handler(device, _read); \
+
+#define MDRV_I8243_WRITEHANDLER(_write) \
+	i8243_device_config::static_set_write_handler(device, _write); \
+
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _i8243_config i8243_config;
-struct _i8243_config
+
+// ======================> i8243_device_config
+
+class i8243_device_config : public device_config
 {
-	read8_device_func		readhandler;
-	write8_device_func		writehandler;
+    friend class i8243_device;
+
+    // construction/destruction
+    i8243_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+	// inline configuration helpers
+	static void static_set_read_handler(device_config *device, read8_device_func callback);
+	static void static_set_write_handler(device_config *device, write8_device_func callback);
+
+protected:
+	devcb_read8		m_readhandler;
+	devcb_write8	m_writehandler;
 };
 
 
+// ======================> i8243_device
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+class i8243_device :  public device_t
+{
+    friend class i8243_device_config;
 
-DECLARE_LEGACY_DEVICE(I8243, i8243);
+    // construction/destruction
+    i8243_device(running_machine &_machine, const i8243_device_config &_config);
 
+public:
 
-#define MDRV_I8243_ADD(_tag, _read, _write) \
-	MDRV_DEVICE_ADD(_tag, I8243, 0) \
-	MDRV_DEVICE_CONFIG_DATAPTR(i8243_config, readhandler, _read) \
-	MDRV_DEVICE_CONFIG_DATAPTR(i8243_config, writehandler, _write)
+	UINT8 i8243_p2_r(UINT32 offset);
+	void i8243_p2_w(UINT32 offset, UINT8 data);
+
+	void i8243_prog_w(UINT32 offset, UINT8 data);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+	UINT8		m_p[4];				/* 4 ports' worth of data */
+	UINT8		m_p2out;			/* port 2 bits that will be returned */
+	UINT8		m_p2;				/* most recent port 2 value */
+	UINT8		m_opcode;			/* latched opcode */
+	UINT8		m_prog;				/* previous PROG state */
+
+	devcb_resolved_read8	m_readhandler;
+	devcb_resolved_write8	m_writehandler;
+
+    const i8243_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type I8243;
 
 
 
 /***************************************************************************
-    FUNCTION PROTOTYPES
+    PROTOTYPES
 ***************************************************************************/
 
 READ8_DEVICE_HANDLER( i8243_p2_r );
diff -Nru src-old/emu/machine/idectrl.c src/emu/machine/idectrl.c
--- src-old/emu/machine/idectrl.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/idectrl.c	2010-08-19 01:27:05.000000000 -0700
@@ -126,7 +126,7 @@
 	UINT8			verify_only;
 
 	UINT8			dma_active;
-	const address_space *dma_space;
+	address_space *dma_space;
 	UINT8			dma_address_xor;
 	UINT8			dma_last_buffer;
 	offs_t			dma_address;
@@ -693,17 +693,17 @@
 			}
 
 			/* fetch the address */
-			ide->dma_address = memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor);
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
+			ide->dma_address = ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor);
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
 			ide->dma_address &= 0xfffffffe;
 
 			/* fetch the length */
-			ide->dma_bytes_left = memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor);
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
+			ide->dma_bytes_left = ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor);
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
 			ide->dma_last_buffer = (ide->dma_bytes_left >> 31) & 1;
 			ide->dma_bytes_left &= 0xfffe;
 			if (ide->dma_bytes_left == 0)
@@ -713,7 +713,7 @@
 		}
 
 		/* write the next byte */
-		memory_write_byte(ide->dma_space, ide->dma_address++, *data++);
+		ide->dma_space->write_byte(ide->dma_address++, *data++);
 		ide->dma_bytes_left--;
 	}
 }
@@ -897,17 +897,17 @@
 			}
 
 			/* fetch the address */
-			ide->dma_address = memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor);
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
-			ide->dma_address |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
+			ide->dma_address = ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor);
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
+			ide->dma_address |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
 			ide->dma_address &= 0xfffffffe;
 
 			/* fetch the length */
-			ide->dma_bytes_left = memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor);
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
-			ide->dma_bytes_left |= memory_read_byte(ide->dma_space, ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
+			ide->dma_bytes_left = ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor);
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 8;
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 16;
+			ide->dma_bytes_left |= ide->dma_space->read_byte(ide->dma_descriptor++ ^ ide->dma_address_xor) << 24;
 			ide->dma_last_buffer = (ide->dma_bytes_left >> 31) & 1;
 			ide->dma_bytes_left &= 0xfffe;
 			if (ide->dma_bytes_left == 0)
@@ -917,7 +917,7 @@
 		}
 
 		/* read the next byte */
-		*data++ = memory_read_byte(ide->dma_space, ide->dma_address++);
+		*data++ = ide->dma_space->read_byte(ide->dma_address++);
 		ide->dma_bytes_left--;
 	}
 }
@@ -1819,7 +1819,7 @@
 		ide->dma_space = memory->space(config->bmspace);
 		if (ide->dma_space == NULL)
 			throw emu_fatalerror("IDE controller '%s' bus master target '%s' does not have specified space %d!", device->tag(), config->bmcpu, config->bmspace);
-		ide->dma_address_xor = (ide->dma_space->endianness == ENDIANNESS_LITTLE) ? 0 : 3;
+		ide->dma_address_xor = (ide->dma_space->endianness() == ENDIANNESS_LITTLE) ? 0 : 3;
 	}
 
 	/* get and copy the geometry */
diff -Nru src-old/emu/machine/ins8154.c src/emu/machine/ins8154.c
--- src-old/emu/machine/ins8154.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/ins8154.c	2010-08-27 05:11:31.000000000 -0700
@@ -11,6 +11,7 @@
 
 #include "emu.h"
 #include "ins8154.h"
+#include "devhelpr.h"
 
 
 /***************************************************************************
@@ -30,85 +31,147 @@
 
 
 /***************************************************************************
-    TYPE DEFINITIONS
+    IMPLEMENTATION
 ***************************************************************************/
 
-typedef struct _ins8154_state ins8154_state;
-struct _ins8154_state
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+GENERIC_DEVICE_CONFIG_SETUP(ins8154, "INS8154")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void ins8154_device_config::device_config_complete()
 {
-	/* i/o lines */
-	devcb_resolved_read8 in_a_func;
-	devcb_resolved_write8 out_a_func;
-	devcb_resolved_read8 in_b_func;
-	devcb_resolved_write8 out_b_func;
-	devcb_resolved_write_line out_irq_func;
-
-	/* registers */
-	UINT8 in_a;  /* Input Latch Port A */
-	UINT8 in_b;  /* Input Latch Port B */
-	UINT8 out_a; /* Output Latch Port A */
-	UINT8 out_b; /* Output Latch Port B */
-	UINT8 mdr;   /* Mode Definition Register */
-	UINT8 odra;  /* Output Definition Register Port A */
-	UINT8 odrb;  /* Output Definition Register Port B */
-};
+	// inherit a copy of the static data
+	const ins8154_interface *intf = reinterpret_cast<const ins8154_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<ins8154_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+    	memset(&m_in_a_func, 0, sizeof(m_in_a_func));
+    	memset(&m_in_b_func, 0, sizeof(m_in_b_func));
+    	memset(&m_out_a_func, 0, sizeof(m_out_a_func));
+    	memset(&m_out_b_func, 0, sizeof(m_out_b_func));
+    	memset(&m_out_irq_func, 0, sizeof(m_out_irq_func));
+	}
+}
 
 
-/*****************************************************************************
-    INLINE FUNCTIONS
-*****************************************************************************/
 
-INLINE ins8154_state *get_safe_token(running_device *device)
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type INS8154 = ins8154_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  ins8154_device - constructor
+//-------------------------------------------------
+
+ins8154_device::ins8154_device(running_machine &_machine, const ins8154_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert(device->type() == INS8154);
 
-	return (ins8154_state *)downcast<legacy_device_base *>(device)->token();
 }
 
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void ins8154_device::device_start()
+{
+	/* resolve callbacks */
+	devcb_resolve_read8(&m_in_a_func, &m_config.m_in_a_func, this);
+	devcb_resolve_write8(&m_out_a_func, &m_config.m_out_a_func, this);
+	devcb_resolve_read8(&m_in_b_func, &m_config.m_in_b_func, this);
+	devcb_resolve_write8(&m_out_b_func, &m_config.m_out_b_func, this);
+	devcb_resolve_write_line(&m_out_irq_func, &m_config.m_out_irq_func, this);
+
+	/* register for state saving */
+	state_save_register_device_item(this, 0, m_in_a);
+	state_save_register_device_item(this, 0, m_in_b);
+	state_save_register_device_item(this, 0, m_out_a);
+	state_save_register_device_item(this, 0, m_out_b);
+	state_save_register_device_item(this, 0, m_mdr);
+	state_save_register_device_item(this, 0, m_odra);
+	state_save_register_device_item(this, 0, m_odrb);
+}
 
-/***************************************************************************
-    IMPLEMENTATION
-***************************************************************************/
 
-READ8_DEVICE_HANDLER( ins8154_r )
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void ins8154_device::device_reset()
+{
+	m_in_a = 0;
+	m_in_b = 0;
+	m_out_a = 0;
+	m_out_b = 0;
+	m_mdr = 0;
+	m_odra = 0;
+	m_odrb = 0;
+}
+
+
+READ8_DEVICE_HANDLER_TRAMPOLINE(ins8154, ins8154_r)
 {
-	ins8154_state *ins8154 = get_safe_token(device);
 	UINT8 val = 0xff;
 
 	if (offset > 0x24)
 	{
 		if (VERBOSE)
-			logerror("%s: INS8154 '%s' Read from invalid offset %02x!\n", cpuexec_describe_context(device->machine), device->tag(), offset);
+		{
+			logerror("%s: INS8154 '%s' Read from invalid offset %02x!\n", cpuexec_describe_context(&m_machine), tag(), offset);
+		}
 		return 0xff;
 	}
 
 	switch (offset)
 	{
 	case 0x20:
-		if (ins8154->in_a_func.read != NULL)
-			val = devcb_call_read8(&ins8154->in_a_func, 0);
-		ins8154->in_a = val;
+		if(m_in_a_func.read != NULL)
+		{
+			val = devcb_call_read8(&m_in_a_func, 0);
+		}
+		m_in_a = val;
 		break;
 
 	case 0x21:
-		if (ins8154->in_b_func.read != NULL)
-			val = devcb_call_read8(&ins8154->in_b_func, 0);
-		ins8154->in_b = val;
+		if(m_in_b_func.read != NULL)
+		{
+			val = devcb_call_read8(&m_in_b_func, 0);
+		}
+		m_in_b = val;
 		break;
 
 	default:
 		if (offset < 0x08)
 		{
-			if (ins8154->in_a_func.read != NULL)
-				val = (devcb_call_read8(&ins8154->in_a_func, 0) << (8 - offset)) & 0x80;
-			ins8154->in_a = val;
+			if(m_in_a_func.read != NULL)
+			{
+				val = (devcb_call_read8(&m_in_a_func, 0) << (8 - offset)) & 0x80;
+			}
+			m_in_a = val;
 		}
 		else
 		{
-			if (ins8154->in_b_func.read != NULL)
-				val = (devcb_call_read8(&ins8154->in_b_func, 0) << (8 - (offset >> 4))) & 0x80;
-			ins8154->in_b = val;
+			if(m_in_b_func.read != NULL)
+			{
+				val = (devcb_call_read8(&m_in_b_func, 0) << (8 - (offset >> 4))) & 0x80;
+			}
+			m_in_b = val;
 		}
 		break;
 	}
@@ -116,68 +179,74 @@
 	return val;
 }
 
-WRITE8_DEVICE_HANDLER( ins8154_porta_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ins8154, ins8154_porta_w)
 {
-	ins8154_state *ins8154 = get_safe_token(device);
-
-	ins8154->out_a = data;
+	m_out_a = data;
 
 	/* Test if any pins are set as outputs */
-	if (ins8154->odra)
-		devcb_call_write8(&ins8154->out_a_func, 0, (data & ins8154->odra) | (ins8154->odra ^ 0xff));
+	if (m_odra)
+	{
+		devcb_call_write8(&m_out_a_func, 0, (data & m_odra) | (m_odra ^ 0xff));
+	}
 }
 
-WRITE8_DEVICE_HANDLER( ins8154_portb_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ins8154, ins8154_portb_w)
 {
-	ins8154_state *ins8154 = get_safe_token(device);
-
-	ins8154->out_b = data;
+	m_out_b = data;
 
 	/* Test if any pins are set as outputs */
-	if (ins8154->odrb)
-		devcb_call_write8(&ins8154->out_b_func, 0, (data & ins8154->odrb) | (ins8154->odrb ^ 0xff));
+	if (m_odrb)
+	{
+		devcb_call_write8(&m_out_b_func, 0, (data & m_odrb) | (m_odrb ^ 0xff));
+	}
 }
 
-WRITE8_DEVICE_HANDLER( ins8154_w )
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(ins8154, ins8154_w)
 {
-	ins8154_state *ins8154 = get_safe_token(device);
-
 	if (offset > 0x24)
 	{
 		if (VERBOSE)
-			logerror("%s: INS8154 '%s' Write %02x to invalid offset %02x!\n", cpuexec_describe_context(device->machine), device->tag(), data, offset);
+		{
+			logerror("%s: INS8154 '%s' Write %02x to invalid offset %02x!\n", cpuexec_describe_context(&m_machine), tag(), data, offset);
+		}
 		return;
 	}
 
 	switch (offset)
 	{
 	case 0x20:
-		ins8154_porta_w(device, 0, data);
+		ins8154_porta_w(0, data);
 		break;
 
 	case 0x21:
-		ins8154_portb_w(device, 0, data);
+		ins8154_portb_w(0, data);
 		break;
 
 	case 0x22:
 		if (VERBOSE)
-			logerror("%s: INS8154 '%s' ODRA set to %02x\n", cpuexec_describe_context(device->machine), device->tag(), data);
+		{
+			logerror("%s: INS8154 '%s' ODRA set to %02x\n", cpuexec_describe_context(&m_machine), tag(), data);
+		}
 
-		ins8154->odra = data;
+		m_odra = data;
 		break;
 
 	case 0x23:
 		if (VERBOSE)
-			logerror("%s: INS8154 '%s' ODRB set to %02x\n", cpuexec_describe_context(device->machine), device->tag(), data);
+		{
+			logerror("%s: INS8154 '%s' ODRB set to %02x\n", cpuexec_describe_context(&m_machine), tag(), data);
+		}
 
-		ins8154->odrb = data;
+		m_odrb = data;
 		break;
 
 	case 0x24:
 		if (VERBOSE)
-			logerror("%s: INS8154 '%s' MDR set to %02x\n", cpuexec_describe_context(device->machine), device->tag(), data);
+		{
+			logerror("%s: INS8154 '%s' MDR set to %02x\n", cpuexec_describe_context(&m_machine), tag(), data);
+		}
 
-		ins8154->mdr = data;
+		m_mdr = data;
 		break;
 
 	default:
@@ -186,11 +255,11 @@
 			/* Set bit */
 			if (offset < 0x08)
 			{
-				ins8154_porta_w(device, 0, ins8154->out_a |= offset & 0x07);
+				ins8154_porta_w(0, m_out_a |= offset & 0x07);
 			}
 			else
 			{
-				ins8154_portb_w(device, 0, ins8154->out_b |= (offset >> 4) & 0x07);
+				ins8154_portb_w(0, m_out_b |= (offset >> 4) & 0x07);
 			}
 		}
 		else
@@ -198,75 +267,14 @@
 			/* Clear bit */
 			if (offset < 0x08)
 			{
-				ins8154_porta_w(device, 0, ins8154->out_a & ~(offset & 0x07));
+				ins8154_porta_w(0, m_out_a & ~(offset & 0x07));
 			}
 			else
 			{
-				ins8154_portb_w(device, 0, ins8154->out_b & ~((offset >> 4) & 0x07));
+				ins8154_portb_w(0, m_out_b & ~((offset >> 4) & 0x07));
 			}
 		}
 
 		break;
 	}
 }
-
-
-/*****************************************************************************
-    DEVICE INTERFACE
-*****************************************************************************/
-
-static DEVICE_START( ins8154 )
-{
-	ins8154_state *ins8154 = get_safe_token(device);
-	const ins8154_interface *intf = (const ins8154_interface *)device->baseconfig().static_config();
-
-	/* validate some basic stuff */
-	assert(intf != NULL);
-
-	/* resolve callbacks */
-	devcb_resolve_read8(&ins8154->in_a_func, &intf->in_a_func, device);
-	devcb_resolve_write8(&ins8154->out_a_func, &intf->out_a_func, device);
-	devcb_resolve_read8(&ins8154->in_b_func, &intf->in_b_func, device);
-	devcb_resolve_write8(&ins8154->out_b_func, &intf->out_b_func, device);
-	devcb_resolve_write_line(&ins8154->out_irq_func, &intf->out_irq_func, device);
-
-	/* register for state saving */
-	state_save_register_device_item(device, 0, ins8154->in_a);
-	state_save_register_device_item(device, 0, ins8154->in_b);
-	state_save_register_device_item(device, 0, ins8154->out_a);
-	state_save_register_device_item(device, 0, ins8154->out_b);
-	state_save_register_device_item(device, 0, ins8154->mdr);
-	state_save_register_device_item(device, 0, ins8154->odra);
-	state_save_register_device_item(device, 0, ins8154->odrb);
-}
-
-static DEVICE_RESET( ins8154 )
-{
-	ins8154_state *ins8154 = get_safe_token(device);
-
-	ins8154->in_a = 0;
-	ins8154->in_b = 0;
-	ins8154->out_a = 0;
-	ins8154->out_b = 0;
-	ins8154->mdr = 0;
-	ins8154->odra = 0;
-	ins8154->odrb = 0;
-}
-
-
-/***************************************************************************
-    DEVICE GETINFO
-***************************************************************************/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID(p,s)				p##ins8154##s
-#define DEVTEMPLATE_FEATURES			DT_HAS_START | DT_HAS_RESET
-#define DEVTEMPLATE_NAME				"INS8154"
-#define DEVTEMPLATE_FAMILY				"INS8154"
-#define DEVTEMPLATE_VERSION				"1.1"
-#define DEVTEMPLATE_CREDITS				"Copyright MESS Team"
-#include "devtempl.h"
-
-
-DEFINE_LEGACY_DEVICE(INS8154, ins8154);
diff -Nru src-old/emu/machine/ins8154.h src/emu/machine/ins8154.h
--- src-old/emu/machine/ins8154.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/ins8154.h	2010-08-26 22:37:56.000000000 -0700
@@ -28,32 +28,117 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __INS8154_H__
 #define __INS8154_H__
 
-#include "devlegcy.h"
-#include "devcb.h"
+#include "emu.h"
+
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_INS8154_ADD(_tag, _intrf) \
+	MDRV_DEVICE_ADD(_tag, INS8154, 0) \
+	MDRV_DEVICE_CONFIG(_intrf)
 
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _ins8154_interface ins8154_interface;
-struct _ins8154_interface
+
+// ======================> ins8154_interface
+
+struct ins8154_interface
+{
+	devcb_read8			m_in_a_func;
+	devcb_write8		m_out_a_func;
+	devcb_read8			m_in_b_func;
+	devcb_write8		m_out_b_func;
+	devcb_write_line	m_out_irq_func;
+};
+
+
+
+// ======================> ins8154_device_config
+
+class ins8154_device_config : public device_config,
+                              public ins8154_interface
+{
+    friend class ins8154_device;
+
+    // construction/destruction
+    ins8154_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> ins8154_device
+
+class ins8154_device :  public device_t
 {
-	devcb_read8			in_a_func;
-	devcb_write8		out_a_func;
-	devcb_read8			in_b_func;
-	devcb_write8		out_b_func;
-	devcb_write_line	out_irq_func;
+    friend class ins8154_device_config;
+
+    // construction/destruction
+    ins8154_device(running_machine &_machine, const ins8154_device_config &_config);
+
+public:
+
+	UINT8 ins8154_r(UINT32 offset);
+	void ins8154_w(UINT32 offset, UINT8 data);
+
+	void ins8154_porta_w(UINT32 offset, UINT8 data);
+	void ins8154_portb_w(UINT32 offset, UINT8 data);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset();
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+	/* i/o lines */
+	devcb_resolved_read8 m_in_a_func;
+	devcb_resolved_write8 m_out_a_func;
+	devcb_resolved_read8 m_in_b_func;
+	devcb_resolved_write8 m_out_b_func;
+	devcb_resolved_write_line m_out_irq_func;
+
+	/* registers */
+	UINT8 m_in_a;  /* Input Latch Port A */
+	UINT8 m_in_b;  /* Input Latch Port B */
+	UINT8 m_out_a; /* Output Latch Port A */
+	UINT8 m_out_b; /* Output Latch Port B */
+	UINT8 m_mdr;   /* Mode Definition Register */
+	UINT8 m_odra;  /* Output Definition Register Port A */
+	UINT8 m_odrb;  /* Output Definition Register Port B */
+
+    const ins8154_device_config &m_config;
 };
 
-DECLARE_LEGACY_DEVICE(INS8154, ins8154);
+
+// device type definition
+extern const device_type INS8154;
+
 
 
 /***************************************************************************
-    FUNCTION PROTOTYPES
+    PROTOTYPES
 ***************************************************************************/
 
 READ8_DEVICE_HANDLER( ins8154_r );
@@ -63,13 +148,4 @@
 WRITE8_DEVICE_HANDLER( ins8154_portb_w );
 
 
-/***************************************************************************
-    DEVICE CONFIGURATION MACROS
-***************************************************************************/
-
-#define MDRV_INS8154_ADD(_tag, _intrf) \
-	MDRV_DEVICE_ADD(_tag, INS8154, 0) \
-	MDRV_DEVICE_CONFIG(_intrf)
-
-
 #endif /* __INS8154_H__ */
diff -Nru src-old/emu/machine/k033906.c src/emu/machine/k033906.c
--- src-old/emu/machine/k033906.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/k033906.c	2010-08-28 09:48:51.000000000 -0700
@@ -7,72 +7,97 @@
 #include "emu.h"
 #include "k033906.h"
 #include "video/voodoo.h"
+#include "devhelpr.h"
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
 
-typedef struct _k033906_state k033906_state;
-struct _k033906_state
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+GENERIC_DEVICE_CONFIG_SETUP(k033906, "Konami 033906")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void k033906_device_config::device_config_complete()
 {
-	UINT32 *     reg;
-	UINT32 *     ram;
+	// inherit a copy of the static data
+	const k033906_interface *intf = reinterpret_cast<const k033906_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<k033906_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_voodoo_tag = NULL;
+	}
+}
+
 
-	int          reg_set;	// 1 = access reg / 0 = access ram
 
-	running_device *voodoo;
-};
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
 
-/*****************************************************************************
-    INLINE FUNCTIONS
-*****************************************************************************/
+const device_type K033906 = k033906_device_config::static_alloc_device_config;
 
-INLINE k033906_state *k033906_get_safe_token( running_device *device )
+//-------------------------------------------------
+//  k033906_device - constructor
+//-------------------------------------------------
+
+k033906_device::k033906_device(running_machine &_machine, const k033906_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert(device->type() == K033906);
 
-	return (k033906_state *)downcast<legacy_device_base *>(device)->token();
 }
 
-INLINE const k033906_interface *k033906_get_interface( running_device *device )
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void k033906_device::device_start()
 {
-	assert(device != NULL);
-	assert((device->type() == K033906));
-	return (const k033906_interface *) device->baseconfig().static_config();
+	m_voodoo = m_machine.device(m_config.m_voodoo_tag);
+
+	m_reg = auto_alloc_array(&m_machine, UINT32, 256);
+	m_ram = auto_alloc_array(&m_machine, UINT32, 32768);
+
+	m_reg_set = 0;
+
+	state_save_register_device_item_pointer(this, 0, m_reg, 256);
+	state_save_register_device_item_pointer(this, 0, m_ram, 32768);
+	state_save_register_device_item(this, 0, m_reg_set);
 }
 
-/*****************************************************************************
-    DEVICE HANDLERS
-*****************************************************************************/
 
-WRITE_LINE_DEVICE_HANDLER( k033906_set_reg )
+WRITE_LINE_DEVICE_HANDLER_TRAMPOLINE(k033906, k033906_set_reg)
 {
-	k033906_state *k033906 = k033906_get_safe_token(device);
-	k033906->reg_set = state & 1;
+	m_reg_set = state & 1;
 }
 
-static UINT32 k033906_reg_r( running_device *device, int reg )
+UINT32 k033906_device::k033906_reg_r(int reg)
 {
-	k033906_state *k033906 = k033906_get_safe_token(device);
-
 	switch (reg)
 	{
 		case 0x00:		return 0x0001121a;			// PCI Vendor ID (0x121a = 3dfx), Device ID (0x0001 = Voodoo)
 		case 0x02:		return 0x04000000;			// Revision ID
-		case 0x04:		return k033906->reg[0x04];		// memBaseAddr
-		case 0x0f:		return k033906->reg[0x0f];		// interrupt_line, interrupt_pin, min_gnt, max_lat
+		case 0x04:		return m_reg[0x04];			// memBaseAddr
+		case 0x0f:		return m_reg[0x0f];			// interrupt_line, interrupt_pin, min_gnt, max_lat
 
 		default:
-			fatalerror("%s: k033906_reg_r: %08X", cpuexec_describe_context(device->machine), reg);
+			fatalerror("%s: k033906_reg_r: %08X", cpuexec_describe_context(&m_machine), reg);
 	}
 	return 0;
 }
 
-static void k033906_reg_w( running_device *device, int reg, UINT32 data )
+void k033906_device::k033906_reg_w(int reg, UINT32 data)
 {
-	k033906_state *k033906 = k033906_get_safe_token(device);
-
 	switch (reg)
 	{
 		case 0x00:
@@ -84,21 +109,25 @@
 		case 0x04:		// memBaseAddr
 		{
 			if (data == 0xffffffff)
-				k033906->reg[0x04] = 0xff000000;
+			{
+				m_reg[0x04] = 0xff000000;
+			}
 			else
-				k033906->reg[0x04] = data & 0xff000000;
+			{
+				m_reg[0x04] = data & 0xff000000;
+			}
 			break;
 		}
 
 		case 0x0f:		// interrupt_line, interrupt_pin, min_gnt, max_lat
 		{
-			k033906->reg[0x0f] = data;
+			m_reg[0x0f] = data;
 			break;
 		}
 
 		case 0x10:		// initEnable
 		{
-			voodoo_set_init_enable(k033906->voodoo, data);
+			voodoo_set_init_enable(m_voodoo, data);
 			break;
 		}
 
@@ -110,63 +139,30 @@
 			break;
 
 		default:
-			fatalerror("%s:K033906_w: %08X, %08X", cpuexec_describe_context(device->machine), data, reg);
+			fatalerror("%s:K033906_w: %08X, %08X", cpuexec_describe_context(&m_machine), data, reg);
 	}
 }
 
-READ32_DEVICE_HANDLER( k033906_r )
+READ32_DEVICE_HANDLER_TRAMPOLINE(k033906, k033906_r)
 {
-	k033906_state *k033906 = k033906_get_safe_token(device);
-
-	if (k033906->reg_set)
-		return k033906_reg_r(device, offset);
+	if(m_reg_set)
+	{
+		return k033906_reg_r(offset);
+	}
 	else
-		return k033906->ram[offset];
+	{
+		return m_ram[offset];
+	}
 }
 
-WRITE32_DEVICE_HANDLER( k033906_w )
+WRITE32_DEVICE_HANDLER_TRAMPOLINE(k033906, k033906_w)
 {
-	k033906_state *k033906 = k033906_get_safe_token(device);
-
-	if (k033906->reg_set)
-		k033906_reg_w(device, offset, data);
+	if(m_reg_set)
+	{
+		k033906_reg_w(offset, data);
+	}
 	else
-		k033906->ram[offset] = data;
-}
-
-
-/*****************************************************************************
-    DEVICE INTERFACE
-*****************************************************************************/
-
-static DEVICE_START( k033906 )
-{
-	k033906_state *k033906 = k033906_get_safe_token(device);
-	const k033906_interface *intf = k033906_get_interface(device);
-
-	k033906->voodoo = device->machine->device(intf->voodoo);
-
-	k033906->reg = auto_alloc_array(device->machine, UINT32, 256);
-	k033906->ram = auto_alloc_array(device->machine, UINT32, 32768);
-
-	k033906->reg_set = 0;
-
-	state_save_register_device_item_pointer(device, 0, k033906->reg, 256);
-	state_save_register_device_item_pointer(device, 0, k033906->ram, 32768);
-	state_save_register_device_item(device, 0, k033906->reg_set);
+	{
+		m_ram[offset] = data;
+	}
 }
-
-/*-------------------------------------------------
-    device definition
--------------------------------------------------*/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID( p, s )	p##k033906##s
-#define DEVTEMPLATE_FEATURES	      DT_HAS_START
-#define DEVTEMPLATE_NAME		"Konami 033906"
-#define DEVTEMPLATE_FAMILY		"Konami PCI Bridge 033906"
-#include "devtempl.h"
-
-
-DEFINE_LEGACY_DEVICE(K033906, k033906);
diff -Nru src-old/emu/machine/k033906.h src/emu/machine/k033906.h
--- src-old/emu/machine/k033906.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/k033906.h	2010-08-28 00:51:12.000000000 -0700
@@ -4,36 +4,106 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __K033906_H__
 #define __K033906_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_K033906_ADD(_tag, _config) \
+	MDRV_DEVICE_ADD(_tag, K033906, 0) \
+	MDRV_DEVICE_CONFIG(_config)
 
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _k033906_interface k033906_interface;
-struct _k033906_interface
+
+// ======================> k033906_interface
+
+struct k033906_interface
 {
-	const char         *voodoo;
+	const char         *m_voodoo_tag;
 };
 
-DECLARE_LEGACY_DEVICE(K033906, k033906);
 
 
-/***************************************************************************
-    MACROS / CONSTANTS
-***************************************************************************/
+// ======================> k033906_device_config
+
+class k033906_device_config : public device_config,
+                              public k033906_interface
+{
+    friend class k033906_device;
+
+    // construction/destruction
+    k033906_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> k033906_device
+
+class k033906_device :  public device_t
+{
+    friend class k033906_device_config;
+
+    // construction/destruction
+    k033906_device(running_machine &_machine, const k033906_device_config &_config);
+
+public:
+
+	UINT32 k033906_r(UINT32 offset);
+	void k033906_w(UINT32 offset, UINT32 data, UINT32 mem_mask);
+	void k033906_set_reg(UINT8 state);
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset() { }
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+	UINT32 k033906_reg_r(int reg);
+	void k033906_reg_w(int reg, UINT32 data);
+
+	/* i/o lines */
+	UINT32 *     m_reg;
+	UINT32 *     m_ram;
+
+	int          m_reg_set;	// 1 = access reg / 0 = access ram
+
+	running_device *m_voodoo;
+
+    const k033906_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type K033906;
 
-#define MDRV_K033906_ADD(_tag, _config) \
-	MDRV_DEVICE_ADD(_tag, K033906, 0) \
-	MDRV_DEVICE_CONFIG(_config)
 
 
 /***************************************************************************
-    DEVICE I/O FUNCTIONS
+    PROTOTYPES
 ***************************************************************************/
 
 extern READ32_DEVICE_HANDLER( k033906_r );
diff -Nru src-old/emu/machine/k056230.c src/emu/machine/k056230.c
--- src-old/emu/machine/k056230.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/k056230.c	2010-08-28 12:56:49.000000000 -0700
@@ -6,44 +6,81 @@
 
 #include "emu.h"
 #include "k056230.h"
+#include "devhelpr.h"
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
 
-typedef struct _k056230_state k056230_state;
-struct _k056230_state
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+GENERIC_DEVICE_CONFIG_SETUP(k056230, "Konami 056230")
+
+//-------------------------------------------------
+//  device_config_complete - perform any
+//  operations now that the configuration is
+//  complete
+//-------------------------------------------------
+
+void k056230_device_config::device_config_complete()
 {
-	UINT32  *    ram;
-	int          is_thunderh;
+	// inherit a copy of the static data
+	const k056230_interface *intf = reinterpret_cast<const k056230_interface *>(static_config());
+	if (intf != NULL)
+	{
+		*static_cast<k056230_interface *>(this) = *intf;
+	}
+
+	// or initialize to defaults if none provided
+	else
+	{
+		m_cpu = NULL;
+		m_is_thunderh = 0;
+	}
+}
+
 
-	running_device *cpu;
-};
 
-/*****************************************************************************
-    INLINE FUNCTIONS
-*****************************************************************************/
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
 
-INLINE k056230_state *k056230_get_safe_token( running_device *device )
+const device_type K0506230 = k056230_device_config::static_alloc_device_config;
+
+//-------------------------------------------------
+//  k056230_device - constructor
+//-------------------------------------------------
+
+k056230_device::k056230_device(running_machine &_machine, const k056230_device_config &config)
+    : device_t(_machine, config),
+      m_config(config)
 {
-	assert(device != NULL);
-	assert(device->type() == K056230);
 
-	return (k056230_state *)downcast<legacy_device_base *>(device)->token();
 }
 
-INLINE const k056230_interface *k056230_get_interface( running_device *device )
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void k056230_device::device_start()
 {
-	assert(device != NULL);
-	assert((device->type() == K056230));
-	return (const k056230_interface *) device->baseconfig().static_config();
+	if(m_config.m_cpu)
+	{
+		m_cpu = m_machine.device(m_config.m_cpu);
+	}
+	else
+	{
+		m_cpu = NULL;
+	}
+
+	m_is_thunderh = m_config.m_is_thunderh;
+
+	m_ram = auto_alloc_array(&m_machine, UINT32, 0x2000);
+
+	state_save_register_device_item_pointer(this, 0, m_ram, 0x2000);
 }
 
-/*****************************************************************************
-    DEVICE HANDLERS
-*****************************************************************************/
 
-READ8_DEVICE_HANDLER( k056230_r )
+READ8_DEVICE_HANDLER_TRAMPOLINE(k056230, k056230_r)
 {
 	switch (offset)
 	{
@@ -58,17 +95,23 @@
 	return 0;
 }
 
-static TIMER_CALLBACK( network_irq_clear )
+TIMER_CALLBACK( k056230_device::network_irq_clear_callback )
 {
-	k056230_state *k056230 = (k056230_state *)ptr;
-	cpu_set_input_line(k056230->cpu, INPUT_LINE_IRQ2, CLEAR_LINE);
+	reinterpret_cast<k056230_device*>(ptr)->network_irq_clear();
 }
 
-WRITE8_DEVICE_HANDLER( k056230_w )
+void k056230_device::network_irq_clear()
 {
-	k056230_state *k056230 = k056230_get_safe_token(device);
+	if(m_cpu)
+	{
+		cpu_set_input_line(m_cpu, INPUT_LINE_IRQ2, CLEAR_LINE);
+	}
+}
 
-	switch (offset)
+
+WRITE8_DEVICE_HANDLER_TRAMPOLINE(k056230, k056230_w)
+{
+	switch(offset)
 	{
 		case 0:		// Mode register
 		{
@@ -76,13 +119,16 @@
 		}
 		case 1:		// Control register
 		{
-			if (data & 0x20)
+			if(data & 0x20)
 			{
 				// Thunder Hurricane breaks otherwise...
-				if (!k056230->is_thunderh)
+				if(!m_is_thunderh)
 				{
-					cpu_set_input_line(k056230->cpu, INPUT_LINE_IRQ2, ASSERT_LINE);
-					timer_set(device->machine, ATTOTIME_IN_USEC(10), k056230, 0, network_irq_clear);
+					if(m_cpu)
+					{
+						cpu_set_input_line(m_cpu, INPUT_LINE_IRQ2, ASSERT_LINE);
+					}
+					timer_set(&m_machine, ATTOTIME_IN_USEC(10), (void*)this, 0, network_irq_clear_callback);
 				}
 			}
 //          else
@@ -97,50 +143,14 @@
 //  mame_printf_debug("k056230_w: %d, %02X at %08X\n", offset, data, cpu_get_pc(space->cpu));
 }
 
-READ32_DEVICE_HANDLER( lanc_ram_r )
+READ32_DEVICE_HANDLER_TRAMPOLINE(k056230, lanc_ram_r)
 {
-	k056230_state *k056230 = k056230_get_safe_token(device);
-
 	//mame_printf_debug("LANC_RAM_r: %08X, %08X at %08X\n", offset, mem_mask, cpu_get_pc(space->cpu));
-	return k056230->ram[offset & 0x7ff];
+	return m_ram[offset & 0x7ff];
 }
 
-WRITE32_DEVICE_HANDLER( lanc_ram_w )
+WRITE32_DEVICE_HANDLER_TRAMPOLINE(k056230, lanc_ram_w)
 {
-	k056230_state *k056230 = k056230_get_safe_token(device);
-
 	//mame_printf_debug("LANC_RAM_w: %08X, %08X, %08X at %08X\n", data, offset, mem_mask, cpu_get_pc(space->cpu));
-	COMBINE_DATA(k056230->ram + (offset & 0x7ff));
-}
-
-/*****************************************************************************
-    DEVICE INTERFACE
-*****************************************************************************/
-
-static DEVICE_START( k056230 )
-{
-	k056230_state *k056230 = k056230_get_safe_token(device);
-	const k056230_interface *intf = k056230_get_interface(device);
-
-	k056230->cpu = device->machine->device(intf->cpu);
-	k056230->is_thunderh = intf->is_thunderh;
-
-	k056230->ram = auto_alloc_array(device->machine, UINT32, 0x2000);
-
-	state_save_register_device_item_pointer(device, 0, k056230->ram, 0x2000);
+	COMBINE_DATA(m_ram + (offset & 0x7ff));
 }
-
-/*-------------------------------------------------
-    device definition
--------------------------------------------------*/
-
-static const char DEVTEMPLATE_SOURCE[] = __FILE__;
-
-#define DEVTEMPLATE_ID( p, s )	p##k056230##s
-#define DEVTEMPLATE_FEATURES	      DT_HAS_START
-#define DEVTEMPLATE_NAME		"Konami 056230"
-#define DEVTEMPLATE_FAMILY		"Konami Network Board 056230"
-#include "devtempl.h"
-
-
-DEFINE_LEGACY_DEVICE(K056230, k056230);
diff -Nru src-old/emu/machine/k056230.h src/emu/machine/k056230.h
--- src-old/emu/machine/k056230.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/k056230.h	2010-08-28 12:56:49.000000000 -0700
@@ -4,37 +4,107 @@
 
 ***************************************************************************/
 
+#pragma once
+
 #ifndef __K056230_H__
 #define __K056230_H__
 
-#include "devlegcy.h"
+#include "emu.h"
+
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_K056230_ADD(_tag, _config) \
+	MDRV_DEVICE_ADD(_tag, K0506230, 0) \
+	MDRV_DEVICE_CONFIG(_config)
 
 
 /***************************************************************************
     TYPE DEFINITIONS
 ***************************************************************************/
 
-typedef struct _k056230_interface k056230_interface;
-struct _k056230_interface
+
+// ======================> k056230_interface
+
+struct k056230_interface
 {
-	const char         *cpu;
-	int                is_thunderh;
+	const char         *m_cpu;
+	int                m_is_thunderh;
 };
 
-DECLARE_LEGACY_DEVICE(K056230, k056230);
 
 
-/***************************************************************************
-    MACROS / CONSTANTS
-***************************************************************************/
+// ======================> k056230_device_config
+
+class k056230_device_config : public device_config,
+                              public k056230_interface
+{
+    friend class k056230_device;
+
+    // construction/destruction
+    k056230_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+    // allocators
+    static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+    virtual device_t *alloc_device(running_machine &machine) const;
+
+protected:
+    // device_config overrides
+    virtual void device_config_complete();
+};
+
+
+
+// ======================> k056230_device
+
+class k056230_device :  public device_t
+{
+    friend class k056230_device_config;
+
+    // construction/destruction
+    k056230_device(running_machine &_machine, const k056230_device_config &_config);
+
+public:
+
+	UINT32 lanc_ram_r(UINT32 offset);
+	void lanc_ram_w(UINT32 offset, UINT32 data, UINT32 mem_mask);
+
+	UINT8 k056230_r(UINT32 offset);
+	void k056230_w(UINT32 offset, UINT8 data);
+
+	static TIMER_CALLBACK( network_irq_clear_callback );
+
+protected:
+    // device-level overrides
+    virtual void device_start();
+    virtual void device_reset() { }
+    virtual void device_post_load() { }
+    virtual void device_clock_changed() { }
+
+private:
+
+	void network_irq_clear();
+
+	UINT32 *m_ram;
+	int		m_is_thunderh;
+
+	running_device *m_cpu;
+
+    const k056230_device_config &m_config;
+};
+
+
+// device type definition
+extern const device_type K0506230;
 
-#define MDRV_K056230_ADD(_tag, _config) \
-	MDRV_DEVICE_ADD(_tag, K056230, 0) \
-	MDRV_DEVICE_CONFIG(_config)
 
 
 /***************************************************************************
-    DEVICE I/O FUNCTIONS
+    PROTOTYPES
 ***************************************************************************/
 
 extern READ32_DEVICE_HANDLER( lanc_ram_r );
diff -Nru src-old/emu/machine/latch8.c src/emu/machine/latch8.c
--- src-old/emu/machine/latch8.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/latch8.c	2010-08-19 00:26:14.000000000 -0700
@@ -83,7 +83,7 @@
 	if (latch8->has_read)
 	{
 		/*  temporary hack until all relevant systems are devices */
-		const address_space *space = cpu_get_address_space(device->machine->firstcpu, ADDRESS_SPACE_PROGRAM);
+		address_space *space = cpu_get_address_space(device->machine->firstcpu, ADDRESS_SPACE_PROGRAM);
 		int i;
 		for (i=0; i<8; i++)
 		{
diff -Nru src-old/emu/machine/ldcore.h src/emu/machine/ldcore.h
--- src-old/emu/machine/ldcore.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/ldcore.h	2010-08-26 08:21:19.000000000 -0700
@@ -148,7 +148,7 @@
 	size_t					statesize;				/* size of the state */
 	const char *			name;					/* name of the player */
 	const rom_entry *		romregion;				/* pointer to ROM region information */
-	const machine_config_token *machine_config;		/* pointer to machine configuration */
+	machine_config_constructor machine_config;		/* pointer to machine configuration */
 	laserdisc_init_func		init;					/* initialization callback */
 	laserdisc_vsync_func	vsync;					/* vsync begin callback */
 	laserdisc_update_func	update;					/* update callback (line 16) */
diff -Nru src-old/emu/machine/pci.c src/emu/machine/pci.c
--- src-old/emu/machine/pci.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/machine/pci.c	2010-08-27 00:21:13.000000000 -0700
@@ -81,8 +81,13 @@
 	running_device *	busdevice;
 	const pci_bus_config *	config;
 	running_device *	device[32];
+	pci_bus_state *		siblings[8];
+	UINT8				siblings_busnum[8];
+	int					siblings_count;
 	offs_t					address;
-	INT8					devicenum;
+	INT8					devicenum; // device number we are addressing
+	INT8					busnum; // pci bus number we are addressing
+	pci_bus_state *		busnumaddr; // pci bus we are addressing
 };
 
 
@@ -93,7 +98,7 @@
 
 /*-------------------------------------------------
     get_safe_token - makes sure that the passed
-    in device is, in fact, an IDE controller
+    in device is, in fact, a PCI bus
 -------------------------------------------------*/
 
 INLINE pci_bus_state *get_safe_token(running_device *device)
@@ -123,12 +128,12 @@
 		case 1:
 			if (pcibus->devicenum != -1)
 			{
-				pci_read_func read = pcibus->config->device[pcibus->devicenum].read_callback;
+				pci_read_func read = pcibus->busnumaddr->config->device[pcibus->devicenum].read_callback;
 				if (read != NULL)
 				{
 					function = (pcibus->address >> 8) & 0x07;
 					reg = (pcibus->address >> 0) & 0xfc;
-					result = (*read)(device, pcibus->device[pcibus->devicenum], function, reg, mem_mask);
+					result = (*read)(pcibus->busnumaddr->busdevice, pcibus->busnumaddr->device[pcibus->devicenum], function, reg, mem_mask);
 				}
 			}
 			break;
@@ -142,6 +147,26 @@
 
 
 
+static pci_bus_state *pci_search_bustree(int busnum, int devicenum, pci_bus_state *pcibus)
+{
+int a;
+pci_bus_state *ret;
+
+	if (pcibus->config->busnum == busnum)
+	{
+		return pcibus;
+	}
+	for (a = 0; a < pcibus->siblings_count; a++)
+	{
+		ret = pci_search_bustree(busnum, devicenum, pcibus->siblings[a]);
+		if (ret != NULL)
+			return ret;
+	}
+	return NULL;
+}
+
+
+
 WRITE32_DEVICE_HANDLER( pci_32le_w )
 {
 	pci_bus_state *pcibus = get_safe_token(device);
@@ -161,20 +186,31 @@
 			{
 				int busnum = (pcibus->address >> 16) & 0xff;
 				int devicenum = (pcibus->address >> 11) & 0x1f;
-				pcibus->devicenum = (busnum == pcibus->config->busnum) ? devicenum : -1;
+				pcibus->busnumaddr = pci_search_bustree(busnum, devicenum, pcibus);
+				if (pcibus->busnumaddr != NULL)
+				{
+					pcibus->busnum = busnum;
+					pcibus->devicenum = devicenum;
+				}
+				else
+					pcibus->devicenum = -1;
+				if (LOG_PCI)
+					logerror("  bus:%d device:%d\n", busnum, devicenum);
 			}
 			break;
 
 		case 1:
 			if (pcibus->devicenum != -1)
 			{
-				pci_write_func write = pcibus->config->device[pcibus->devicenum].write_callback;
+				pci_write_func write = pcibus->busnumaddr->config->device[pcibus->devicenum].write_callback;
 				if (write != NULL)
 				{
 					int function = (pcibus->address >> 8) & 0x07;
 					int reg = (pcibus->address >> 0) & 0xfc;
-					(*write)(device, pcibus->device[pcibus->devicenum], function, reg, data, mem_mask);
+					(*write)(pcibus->busnumaddr->busdevice, pcibus->busnumaddr->device[pcibus->devicenum], function, reg, data, mem_mask);
 				}
+				if (LOG_PCI)
+					logerror("  function:%d register:%d\n", (pcibus->address >> 8) & 0x07, (pcibus->address >> 0) & 0xfc);
 			}
 			break;
 	}
@@ -186,13 +222,42 @@
 WRITE64_DEVICE_HANDLER(pci_64be_w) { write64be_with_32le_device_handler(pci_32le_w, device, offset, data, mem_mask); }
 
 
-
+int pci_add_sibling( running_machine *machine, char *pcitag, char *sibling )
+{
+	running_device *device1 = machine->device(pcitag);
+	running_device *device2 = machine->device(sibling);
+	pci_bus_state *pcibus1 = get_safe_token(device1);
+	pci_bus_state *pcibus2 = get_safe_token(device2);
+	pci_bus_config *config2;
+
+	if ((device1 == NULL) || (device2 == NULL) || (pcibus1 == NULL) || (pcibus2 == NULL))
+		return 0;
+	if (pcibus1->siblings_count == 8)
+		return 0;
+	config2 = (pci_bus_config *)downcast<const legacy_device_config_base &>(device2->baseconfig()).inline_config();
+	pcibus1->siblings[pcibus1->siblings_count] = get_safe_token(device2);
+	pcibus1->siblings_busnum[pcibus1->siblings_count] = config2->busnum;
+	pcibus1->siblings_count++;
+	return 1;
+}
 
 
 /***************************************************************************
     DEVICE INTERFACE
 ***************************************************************************/
 
+
+static STATE_POSTLOAD( pci_bus_postload )
+{
+	pci_bus_state *pcibus = (pci_bus_state *)param;
+
+	if (pcibus->devicenum != -1)
+	{
+		pcibus->busnumaddr = pci_search_bustree(pcibus->busnum, pcibus->devicenum, pcibus);
+	}
+}
+
+
 /*-------------------------------------------------
     device start callback
 -------------------------------------------------*/
@@ -219,9 +284,15 @@
 		if (pcibus->config->device[devicenum].devtag != NULL)
 			pcibus->device[devicenum] = device->machine->device(pcibus->config->device[devicenum].devtag);
 
+	if (pcibus->config->father != NULL)
+		pci_add_sibling(device->machine, (char *)pcibus->config->father, (char *)device->tag());
+
 	/* register pci states */
 	state_save_register_device_item(device, 0, pcibus->address);
 	state_save_register_device_item(device, 0, pcibus->devicenum);
+	state_save_register_device_item(device, 0, pcibus->busnum);
+
+	state_save_register_postload(device->machine, pci_bus_postload, pcibus);
 }
 
 
diff -Nru src-old/emu/machine/pci.h src/emu/machine/pci.h
--- src-old/emu/machine/pci.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/pci.h	2010-08-27 00:21:13.000000000 -0700
@@ -32,6 +32,7 @@
 {
 	UINT8				busnum;
 	pci_device_entry	device[32];
+	const char *		father;
 };
 
 
@@ -49,6 +50,8 @@
 	MDRV_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(pci_bus_config, device, _devnum, pci_device_entry, read_callback, _configread) \
 	MDRV_DEVICE_CONFIG_DATAPTR_ARRAY_MEMBER(pci_bus_config, device, _devnum, pci_device_entry, write_callback, _configwrite)
 
+#define MDRV_PCI_BUS_SIBLING(_father_tag) \
+	MDRV_DEVICE_CONFIG_DATAPTR(pci_bus_config, father, _father_tag)
 
 
 /***************************************************************************
@@ -61,6 +64,7 @@
 READ64_DEVICE_HANDLER( pci_64be_r );
 WRITE64_DEVICE_HANDLER( pci_64be_w );
 
+int pci_add_sibling( running_machine *machine, char *pcitag, char *sibling );
 
 /* ----- device interface ----- */
 
diff -Nru src-old/emu/machine/timekpr.c src/emu/machine/timekpr.c
--- src-old/emu/machine/timekpr.c	2010-07-08 07:32:53.000000000 -0700
+++ src/emu/machine/timekpr.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,43 +1,22 @@
-/*
- * STmicroelectronics TIMEKEEPER SRAM
- *
- * Supports:
- *           M48T02
- *           M48T35
- *           M48T58
- *           MK48T08
- *
- */
+/***************************************************************************
+
+    timekpr.h
+
+    Various ST Microelectronics timekeeper SRAM implementations:
+        - M48T02
+        - M48T35
+        - M48T58
+        - MK48T08
+
+***************************************************************************/
 
 #include "emu.h"
 #include "machine/timekpr.h"
 
-typedef struct
-{
-	UINT8 control;
-	UINT8 seconds;
-	UINT8 minutes;
-	UINT8 hours;
-	UINT8 day;
-	UINT8 date;
-	UINT8 month;
-	UINT8 year;
-	UINT8 century;
-	UINT8 *data;
-	UINT8 *default_data;
-	running_device *device;
-	int size;
-	int offset_control;
-	int offset_seconds;
-	int offset_minutes;
-	int offset_hours;
-	int offset_day;
-	int offset_date;
-	int offset_month;
-	int offset_year;
-	int offset_century;
-	int offset_flags;
-} timekeeper_state;
+
+/***************************************************************************
+    MACROS
+***************************************************************************/
 
 #define MASK_SECONDS ( 0x7f )
 #define MASK_MINUTES ( 0x7f )
@@ -64,6 +43,71 @@
 
 #define FLAGS_BL ( 0x10 ) /* MK48T08: not emulated */
 
+#define TIMEKPR_DEV_DERIVED_CTOR(devtype) \
+	devtype##_device::devtype##_device(running_machine &_machine, const devtype##_device_config &config) \
+		: timekeeper_device(_machine, config) \
+	{ }
+
+#define TIMEKPR_DEVCFG_DERIVED_CTOR(devtype, name) \
+	devtype##_device_config::devtype##_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock) \
+    : timekeeper_device_config(mconfig, name, tag, owner, clock) \
+	{ }
+
+#define TIMEKPR_DEVCFG_DERIVED_STATIC_ALLOC(devtype) \
+	device_config *devtype##_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock) \
+	{ return global_alloc(devtype##_device_config(mconfig, tag, owner, clock)); }
+
+#define TIMEKPR_DEVCFG_DERIVED_DEV_ALLOC(devtype) \
+	device_t *devtype##_device_config::alloc_device(running_machine &machine) const \
+	{ return auto_alloc(&machine, devtype##_device(machine, *this)); }
+
+#define TIMEKPR_DERIVE(devtype, name) \
+	TIMEKPR_DEV_DERIVED_CTOR(devtype) \
+	TIMEKPR_DEVCFG_DERIVED_CTOR(devtype, name) \
+	TIMEKPR_DEVCFG_DERIVED_STATIC_ALLOC(devtype) \
+	TIMEKPR_DEVCFG_DERIVED_DEV_ALLOC(devtype)
+
+
+//**************************************************************************
+//  DEVICE CONFIGURATION
+//**************************************************************************
+
+//-------------------------------------------------
+//  timekeeper_device_config - constructor
+//-------------------------------------------------
+
+timekeeper_device_config::timekeeper_device_config(const machine_config &mconfig, const char *type, const char *tag, const device_config *owner, UINT32 clock)
+    : device_config(mconfig, static_alloc_device_config, type, tag, owner, clock),
+	  device_config_nvram_interface(mconfig, *this)
+{
+
+}
+
+
+//-------------------------------------------------
+//  static_alloc_device_config - allocate a new
+//  configuration object
+//-------------------------------------------------
+
+device_config *timekeeper_device_config::static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock)
+{
+    return global_alloc(timekeeper_device_config(mconfig, "TIMEKEEPER", tag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  alloc_device - allocate a new device object
+//-------------------------------------------------
+
+device_t *timekeeper_device_config::alloc_device(running_machine &machine) const
+{
+    return auto_alloc(&machine, timekeeper_device(machine, *this));
+}
+
+/***************************************************************************
+    INLINE FUNCTIONS
+***************************************************************************/
+
 INLINE UINT8 make_bcd(UINT8 data)
 {
 	return ( ( ( data / 10 ) % 10 ) << 4 ) + ( data % 10 );
@@ -105,19 +149,6 @@
 	}
 }
 
-static void counters_to_ram( timekeeper_state *c )
-{
-	counter_to_ram( c->data, c->offset_control, c->control );
-	counter_to_ram( c->data, c->offset_seconds, c->seconds );
-	counter_to_ram( c->data, c->offset_minutes, c->minutes );
-	counter_to_ram( c->data, c->offset_hours, c->hours );
-	counter_to_ram( c->data, c->offset_day, c->day );
-	counter_to_ram( c->data, c->offset_date, c->date );
-	counter_to_ram( c->data, c->offset_month, c->month );
-	counter_to_ram( c->data, c->offset_year, c->year );
-	counter_to_ram( c->data, c->offset_century, c->century );
-}
-
 static int counter_from_ram( UINT8 *data, int offset )
 {
 	if( offset >= 0 )
@@ -127,52 +158,216 @@
 	return 0;
 }
 
-static void counters_from_ram( timekeeper_state *c )
+//**************************************************************************
+//  LIVE DEVICE
+//**************************************************************************
+
+const device_type M48T02 = m48t02_device_config::static_alloc_device_config;
+const device_type M48T35 = m48t35_device_config::static_alloc_device_config;
+const device_type M48T58 = m48t58_device_config::static_alloc_device_config;
+const device_type MK48T08 = mk48t08_device_config::static_alloc_device_config;
+
+TIMEKPR_DERIVE(m48t02, "M48T02")
+TIMEKPR_DERIVE(m48t35, "M48T35")
+TIMEKPR_DERIVE(m48t58, "M48T58")
+TIMEKPR_DERIVE(mk48t08, "MK48T08")
+
+//-------------------------------------------------
+//  timekeeper_device - constructor
+//-------------------------------------------------
+
+timekeeper_device::timekeeper_device(running_machine &_machine, const timekeeper_device_config &config)
+    : device_t(_machine, config),
+	  device_nvram_interface(_machine, config, *this),
+      m_config(config)
 {
-	c->control = counter_from_ram( c->data, c->offset_control );
-	c->seconds = counter_from_ram( c->data, c->offset_seconds );
-	c->minutes = counter_from_ram( c->data, c->offset_minutes );
-	c->hours = counter_from_ram( c->data, c->offset_hours );
-	c->day = counter_from_ram( c->data, c->offset_day );
-	c->date = counter_from_ram( c->data, c->offset_date );
-	c->month = counter_from_ram( c->data, c->offset_month );
-	c->year = counter_from_ram( c->data, c->offset_year );
-	c->century = counter_from_ram( c->data, c->offset_century );
+
 }
 
-static TIMER_CALLBACK( timekeeper_tick )
+//-------------------------------------------------
+//  device_start - device-specific startup
+//-------------------------------------------------
+
+void timekeeper_device::device_start()
 {
-	timekeeper_state *c = (timekeeper_state *) ptr;
+	emu_timer *timer;
+	attotime duration;
+	system_time systime;
 
-	int carry;
+	/* validate some basic stuff */
+	assert(this != NULL);
+
+	m_machine.base_datetime(systime);
+
+	m_control = 0;
+	m_seconds = make_bcd( systime.local_time.second );
+	m_minutes = make_bcd( systime.local_time.minute );
+	m_hours = make_bcd( systime.local_time.hour );
+	m_day = make_bcd( systime.local_time.weekday + 1 );
+	m_date = make_bcd( systime.local_time.mday );
+	m_month = make_bcd( systime.local_time.month + 1 );
+	m_year = make_bcd( systime.local_time.year % 100 );
+	m_century = make_bcd( systime.local_time.year / 100 );
+	m_data = auto_alloc_array( &m_machine, UINT8, m_size );
+
+	m_default_data = *region();
+	if (m_default_data)
+	{
+		assert( region()->bytes() == m_size );
+	}
+
+	state_save_register_device_item( this, 0, m_control );
+	state_save_register_device_item( this, 0, m_seconds );
+	state_save_register_device_item( this, 0, m_minutes );
+	state_save_register_device_item( this, 0, m_hours );
+	state_save_register_device_item( this, 0, m_day );
+	state_save_register_device_item( this, 0, m_date );
+	state_save_register_device_item( this, 0, m_month );
+	state_save_register_device_item( this, 0, m_year );
+	state_save_register_device_item( this, 0, m_century );
+	state_save_register_device_item_pointer( this, 0, m_data, m_size );
+
+	timer = timer_alloc( &m_machine, timekeeper_tick_callback, (void *)this );
+	duration = ATTOTIME_IN_SEC(1);
+	timer_adjust_periodic( timer, duration, 0, duration );
+}
 
-	if( ( c->seconds & SECONDS_ST ) != 0 ||
-		( c->control & CONTROL_W ) != 0 )
+void m48t02_device::device_start()
+{
+	m_offset_control = 0x7f8;
+	m_offset_seconds = 0x7f9;
+	m_offset_minutes = 0x7fa;
+	m_offset_hours = 0x7fb;
+	m_offset_day = 0x7fc;
+	m_offset_date = 0x7fd;
+	m_offset_month = 0x7fe;
+	m_offset_year = 0x7ff;
+	m_offset_century = -1;
+	m_offset_flags = -1;
+	m_size = 0x800;
+
+	timekeeper_device::device_start();
+}
+
+void m48t35_device::device_start()
+{
+	m_offset_control = 0x7ff8;
+	m_offset_seconds = 0x7ff9;
+	m_offset_minutes = 0x7ffa;
+	m_offset_hours = 0x7ffb;
+	m_offset_day = 0x7ffc;
+	m_offset_date = 0x7ffd;
+	m_offset_month = 0x7ffe;
+	m_offset_year = 0x7fff;
+	m_offset_century = -1;
+	m_offset_flags = -1;
+	m_size = 0x8000;
+
+	timekeeper_device::device_start();
+}
+
+void m48t58_device::device_start()
+{
+	m_offset_control = 0x1ff8;
+	m_offset_seconds = 0x1ff9;
+	m_offset_minutes = 0x1ffa;
+	m_offset_hours = 0x1ffb;
+	m_offset_day = 0x1ffc;
+	m_offset_date = 0x1ffd;
+	m_offset_month = 0x1ffe;
+	m_offset_year = 0x1fff;
+	m_offset_century = -1;
+	m_offset_flags = -1;
+	m_size = 0x2000;
+
+	timekeeper_device::device_start();
+}
+
+void mk48t08_device::device_start()
+{
+	m_offset_control = 0x1ff8;
+	m_offset_seconds = 0x1ff9;
+	m_offset_minutes = 0x1ffa;
+	m_offset_hours = 0x1ffb;
+	m_offset_day = 0x1ffc;
+	m_offset_date = 0x1ffd;
+	m_offset_month = 0x1ffe;
+	m_offset_year = 0x1fff;
+	m_offset_century = 0x1ff1;
+	m_offset_flags = 0x1ff0;
+	m_size = 0x2000;
+
+	timekeeper_device::device_start();
+}
+
+//-------------------------------------------------
+//  device_reset - device-specific reset
+//-------------------------------------------------
+
+void timekeeper_device::device_reset() { }
+void m48t02_device::device_reset() { }
+void m48t35_device::device_reset() { }
+void m48t58_device::device_reset() { }
+void mk48t08_device::device_reset() { }
+
+void timekeeper_device::counters_to_ram()
+{
+	counter_to_ram( m_data, m_offset_control, m_control );
+	counter_to_ram( m_data, m_offset_seconds, m_seconds );
+	counter_to_ram( m_data, m_offset_minutes, m_minutes );
+	counter_to_ram( m_data, m_offset_hours, m_hours );
+	counter_to_ram( m_data, m_offset_day, m_day );
+	counter_to_ram( m_data, m_offset_date, m_date );
+	counter_to_ram( m_data, m_offset_month, m_month );
+	counter_to_ram( m_data, m_offset_year, m_year );
+	counter_to_ram( m_data, m_offset_century, m_century );
+}
+
+void timekeeper_device::counters_from_ram()
+{
+	m_control = counter_from_ram( m_data, m_offset_control );
+	m_seconds = counter_from_ram( m_data, m_offset_seconds );
+	m_minutes = counter_from_ram( m_data, m_offset_minutes );
+	m_hours = counter_from_ram( m_data, m_offset_hours );
+	m_day = counter_from_ram( m_data, m_offset_day );
+	m_date = counter_from_ram( m_data, m_offset_date );
+	m_month = counter_from_ram( m_data, m_offset_month );
+	m_year = counter_from_ram( m_data, m_offset_year );
+	m_century = counter_from_ram( m_data, m_offset_century );
+}
+
+TIMER_CALLBACK( timekeeper_device::timekeeper_tick_callback )
+{
+    reinterpret_cast<timekeeper_device *>(ptr)->timekeeper_tick();
+}
+
+void timekeeper_device::timekeeper_tick()
+{
+	if( ( m_seconds & SECONDS_ST ) != 0 ||
+		( m_control & CONTROL_W ) != 0 )
 	{
 		return;
 	}
 
-	carry = inc_bcd( &c->seconds, MASK_SECONDS, 0x00, 0x59 );
+	int carry = inc_bcd( &m_seconds, MASK_SECONDS, 0x00, 0x59 );
 	if( carry )
 	{
-		carry = inc_bcd( &c->minutes, MASK_MINUTES, 0x00, 0x59 );
+		carry = inc_bcd( &m_minutes, MASK_MINUTES, 0x00, 0x59 );
 	}
 	if( carry )
 	{
-		carry = inc_bcd( &c->hours, MASK_HOURS, 0x00, 0x23 );
+		carry = inc_bcd( &m_hours, MASK_HOURS, 0x00, 0x23 );
 	}
 
 	if( carry )
 	{
-		UINT8 month;
-		UINT8 year;
 		UINT8 maxdays;
 		static const UINT8 daysinmonth[] = { 0x31, 0x28, 0x31, 0x30, 0x31, 0x30, 0x31, 0x31, 0x30, 0x31, 0x30, 0x31 };
 
-		inc_bcd( &c->day, MASK_DAY, 0x01, 0x07 );
+		inc_bcd( &m_day, MASK_DAY, 0x01, 0x07 );
 
-		month = from_bcd( c->month );
-		year = from_bcd( c->year );
+		UINT8 month = from_bcd( m_month );
+		UINT8 year = from_bcd( m_year );
 
 		if( month == 2 && ( year % 4 ) == 0 )
 		{
@@ -187,347 +382,119 @@
 			maxdays = 0x31;
 		}
 
-		carry = inc_bcd( &c->date, MASK_DATE, 0x01, maxdays );
+		carry = inc_bcd( &m_date, MASK_DATE, 0x01, maxdays );
 	}
 	if( carry )
 	{
-		carry = inc_bcd( &c->month, MASK_MONTH, 0x01, 0x12 );
+		carry = inc_bcd( &m_month, MASK_MONTH, 0x01, 0x12 );
 	}
 	if( carry )
 	{
-		carry = inc_bcd( &c->year, MASK_YEAR, 0x00, 0x99 );
+		carry = inc_bcd( &m_year, MASK_YEAR, 0x00, 0x99 );
 	}
 	if( carry )
 	{
-		carry = inc_bcd( &c->century, MASK_CENTURY, 0x00, 0x99 );
+		carry = inc_bcd( &m_century, MASK_CENTURY, 0x00, 0x99 );
 
-		if( c->device->type() == M48T35 ||
-			c->device->type() == M48T58 )
+		if( type() == M48T35 ||
+			type() == M48T58 )
 		{
-			if( ( c->day & DAY_CEB ) != 0 )
+			if( ( m_day & DAY_CEB ) != 0 )
 			{
-				c->day ^= DAY_CB;
+				m_day ^= DAY_CB;
 			}
 		}
 	}
 
-	if( ( c->control & CONTROL_R ) == 0 )
+	if( ( m_control & CONTROL_R ) == 0 )
 	{
-		counters_to_ram( c );
+		counters_to_ram();
 	}
 }
 
-/*-------------------------------------------------
-    get_safe_token - makes sure that the passed
-    in device is the right type
--------------------------------------------------*/
-
-INLINE timekeeper_state *get_safe_token(running_device *device)
-{
-	assert(device != NULL);
-	assert((device->type() == M48T02) ||
-		   (device->type() == M48T35) ||
-		   (device->type() == M48T58) ||
-		   (device->type() == MK48T08));
-
-	return (timekeeper_state *)downcast<legacy_device_base *>(device)->token();
-}
-
-/* memory handlers */
-
-WRITE8_DEVICE_HANDLER( timekeeper_w )
+void timekeeper_device::write(UINT16 offset, UINT8 data)
 {
-	timekeeper_state *c = get_safe_token(device);
-
-	if( offset == c->offset_control )
+	if( offset == m_offset_control )
 	{
-		if( ( c->control & CONTROL_W ) != 0 &&
+		if( ( m_control & CONTROL_W ) != 0 &&
 			( data & CONTROL_W ) == 0 )
 		{
-			counters_from_ram( c );
+			counters_from_ram();
 		}
-		c->control = data;
+		m_control = data;
 	}
-	else if( offset == c->offset_day )
+	else if( offset == m_offset_day )
 	{
-		if( c->device->type() == M48T35 ||
-			c->device->type() == M48T58 )
+		if( type() == M48T35 ||
+			type() == M48T58 )
 		{
-			c->day = ( c->day & ~DAY_CEB ) | ( data & DAY_CEB );
+			m_day = ( m_day & ~DAY_CEB ) | ( data & DAY_CEB );
 		}
 	}
-	else if( offset == c->offset_date && c->device->type() == M48T58 )
+	else if( offset == m_offset_date && type() == M48T58 )
 	{
 		data &= ~DATE_BL;
 	}
-	else if( offset == c->offset_flags && c->device->type() == MK48T08 )
+	else if( offset == m_offset_flags && type() == MK48T08 )
 	{
 		data &= ~FLAGS_BL;
 	}
 
-//  logerror( "%s: timekeeper_write( %s, %04x, %02x )\n", cpuexec_describe_context(machine), c->device->tag, offset, data );
-	c->data[ offset ] = data;
-}
-
-READ8_DEVICE_HANDLER( timekeeper_r )
-{
-	timekeeper_state *c = get_safe_token(device);
-	UINT8 data = c->data[ offset ];
-//  logerror( "%s: timekeeper_read( %s, %04x ) %02x\n", cpuexec_describe_context(machine), c->device->tag, offset, data );
-	return data;
-}
-
-/*-------------------------------------------------
-    device start callback
--------------------------------------------------*/
-
-static DEVICE_START(timekeeper)
-{
-	timekeeper_state *c = get_safe_token(device);
-	emu_timer *timer;
-	attotime duration;
-	system_time systime;
-
-	/* validate some basic stuff */
-	assert(device != NULL);
-//  assert(device->baseconfig().static_config() != NULL);
-	assert(downcast<const legacy_device_config_base &>(device->baseconfig()).inline_config() == NULL);
-	assert(device->machine != NULL);
-	assert(device->machine->config != NULL);
-
-	device->machine->base_datetime(systime);
-
-	c->device = device;
-	c->control = 0;
-	c->seconds = make_bcd( systime.local_time.second );
-	c->minutes = make_bcd( systime.local_time.minute );
-	c->hours = make_bcd( systime.local_time.hour );
-	c->day = make_bcd( systime.local_time.weekday + 1 );
-	c->date = make_bcd( systime.local_time.mday );
-	c->month = make_bcd( systime.local_time.month + 1 );
-	c->year = make_bcd( systime.local_time.year % 100 );
-	c->century = make_bcd( systime.local_time.year / 100 );
-	c->data = auto_alloc_array( device->machine, UINT8, c->size );
-
-	c->default_data = *device->region();
-	if (c->default_data)
-		assert( device->region()->bytes() == c->size );
-
-	state_save_register_device_item( device, 0, c->control );
-	state_save_register_device_item( device, 0, c->seconds );
-	state_save_register_device_item( device, 0, c->minutes );
-	state_save_register_device_item( device, 0, c->hours );
-	state_save_register_device_item( device, 0, c->day );
-	state_save_register_device_item( device, 0, c->date );
-	state_save_register_device_item( device, 0, c->month );
-	state_save_register_device_item( device, 0, c->year );
-	state_save_register_device_item( device, 0, c->century );
-	state_save_register_device_item_pointer( device, 0, c->data, c->size );
-
-	timer = timer_alloc( device->machine, timekeeper_tick, c );
-	duration = ATTOTIME_IN_SEC(1);
-	timer_adjust_periodic( timer, duration, 0, duration );
-}
-
-static DEVICE_START(m48t02)
-{
-	timekeeper_state *c = get_safe_token(device);
-
-	c->offset_control = 0x7f8;
-	c->offset_seconds = 0x7f9;
-	c->offset_minutes = 0x7fa;
-	c->offset_hours = 0x7fb;
-	c->offset_day = 0x7fc;
-	c->offset_date = 0x7fd;
-	c->offset_month = 0x7fe;
-	c->offset_year = 0x7ff;
-	c->offset_century = -1;
-	c->offset_flags = -1;
-	c->size = 0x800;
-
-	DEVICE_START_CALL( timekeeper );
+	m_data[ offset ] = data;
 }
 
-static DEVICE_START(m48t35)
+UINT8 timekeeper_device::read(UINT16 offset)
 {
-	timekeeper_state *c = get_safe_token(device);
-
-	c->offset_control = 0x7ff8;
-	c->offset_seconds = 0x7ff9;
-	c->offset_minutes = 0x7ffa;
-	c->offset_hours = 0x7ffb;
-	c->offset_day = 0x7ffc;
-	c->offset_date = 0x7ffd;
-	c->offset_month = 0x7ffe;
-	c->offset_year = 0x7fff;
-	c->offset_century = -1;
-	c->offset_flags = -1;
-	c->size = 0x8000;
-
-	DEVICE_START_CALL( timekeeper );
-}
-
-static DEVICE_START(m48t58)
-{
-	timekeeper_state *c = get_safe_token(device);
-
-	c->offset_control = 0x1ff8;
-	c->offset_seconds = 0x1ff9;
-	c->offset_minutes = 0x1ffa;
-	c->offset_hours = 0x1ffb;
-	c->offset_day = 0x1ffc;
-	c->offset_date = 0x1ffd;
-	c->offset_month = 0x1ffe;
-	c->offset_year = 0x1fff;
-	c->offset_century = -1;
-	c->offset_flags = -1;
-	c->size = 0x2000;
-
-	DEVICE_START_CALL( timekeeper );
-}
-
-static DEVICE_START(mk48t08)
-{
-	timekeeper_state *c = get_safe_token(device);
-
-	c->offset_control = 0x1ff8;
-	c->offset_seconds = 0x1ff9;
-	c->offset_minutes = 0x1ffa;
-	c->offset_hours = 0x1ffb;
-	c->offset_day = 0x1ffc;
-	c->offset_date = 0x1ffd;
-	c->offset_month = 0x1ffe;
-	c->offset_year = 0x1fff;
-	c->offset_century = 0x1ff1;
-	c->offset_flags = 0x1ff0;
-	c->size = 0x2000;
-
-	DEVICE_START_CALL( timekeeper );
+	return m_data[ offset ];
 }
 
-/*-------------------------------------------------
-    device reset callback
--------------------------------------------------*/
+//-------------------------------------------------
+//  nvram_default - called to initialize NVRAM to
+//  its default state
+//-------------------------------------------------
 
-static DEVICE_RESET(timekeeper)
+void timekeeper_device::nvram_default()
 {
-}
-
-static DEVICE_NVRAM(timekeeper)
-{
-	timekeeper_state *c = get_safe_token(device);
-
-	if( read_or_write )
+	if( m_default_data != NULL )
 	{
-		mame_fwrite( file, c->data, c->size );
+		memcpy( m_data, m_default_data, m_size );
 	}
 	else
 	{
-		if( file )
-		{
-			mame_fread( file, c->data, c->size );
-		}
-		else
-		{
-			if( c->default_data != NULL )
-			{
-				memcpy( c->data, c->default_data, c->size );
-			}
-			else
-			{
-				memset( c->data, 0xff, c->size );
-			}
-		}
-
-		counters_to_ram( c );
+		memset( m_data, 0xff, m_size );
 	}
 }
 
-/*-------------------------------------------------
-    device get info callback
--------------------------------------------------*/
-
-static DEVICE_GET_INFO(timekeeper)
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as 64-bit signed integers --- */
-		case DEVINFO_INT_TOKEN_BYTES:			info->i = sizeof(timekeeper_state); break;
-		case DEVINFO_INT_INLINE_CONFIG_BYTES:	info->i = 0; break; // sizeof(timekeeper_config)
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:					info->start = DEVICE_START_NAME(timekeeper); break;
-		case DEVINFO_FCT_STOP:					/* nothing */ break;
-		case DEVINFO_FCT_RESET:					info->reset = DEVICE_RESET_NAME(timekeeper); break;
-		case DEVINFO_FCT_NVRAM:					info->nvram = DEVICE_NVRAM_NAME(timekeeper); break;
 
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:					strcpy(info->s, "Timekeeper"); break;
-		case DEVINFO_STR_FAMILY:				strcpy(info->s, "EEPROM"); break;
-		case DEVINFO_STR_VERSION:				strcpy(info->s, "1.0"); break;
-		case DEVINFO_STR_SOURCE_FILE:			strcpy(info->s, __FILE__); break;
-		case DEVINFO_STR_CREDITS:				strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
-	}
-}
+//-------------------------------------------------
+//  nvram_read - called to read NVRAM from the
+//  .nv file
+//-------------------------------------------------
 
-DEVICE_GET_INFO( m48t02 )
+void timekeeper_device::nvram_read(mame_file &file)
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "M48T02");					break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(m48t02);	break;
+	mame_fread( &file, m_data, m_size );
 
-		default:										DEVICE_GET_INFO_CALL(timekeeper);			break;
-	}
+	counters_to_ram();
 }
 
-DEVICE_GET_INFO( m48t35 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "M48T35");					break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(m48t35);	break;
 
-		default:										DEVICE_GET_INFO_CALL(timekeeper);			break;
-	}
-}
+//-------------------------------------------------
+//  nvram_write - called to write NVRAM to the
+//  .nv file
+//-------------------------------------------------
 
-DEVICE_GET_INFO( m48t58 )
+void timekeeper_device::nvram_write(mame_file &file)
 {
-	switch (state)
-	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "M48T58");					break;
-
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(m48t58);	break;
-
-		default:										DEVICE_GET_INFO_CALL(timekeeper);			break;
-	}
+	mame_fwrite( &file, m_data, m_size );
 }
 
-DEVICE_GET_INFO( mk48t08 )
-{
-	switch (state)
-	{
-		/* --- the following bits of info are returned as NULL-terminated strings --- */
-		case DEVINFO_STR_NAME:							strcpy(info->s, "MK48T08");					break;
 
-		/* --- the following bits of info are returned as pointers to data or functions --- */
-		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(mk48t08);	break;
 
-		default:										DEVICE_GET_INFO_CALL(timekeeper);			break;
-	}
-}
+/***************************************************************************
+    TRAMPOLINES
+***************************************************************************/
 
+WRITE8_DEVICE_HANDLER( timekeeper_w ) { downcast<timekeeper_device *>(device)->write(offset, data); }
+READ8_DEVICE_HANDLER( timekeeper_r ) { return downcast<timekeeper_device*>(device)->read(offset); }
 
-DEFINE_LEGACY_NVRAM_DEVICE(M48T02, m48t02);
-DEFINE_LEGACY_NVRAM_DEVICE(M48T35, m48t35);
-DEFINE_LEGACY_NVRAM_DEVICE(M48T58, m48t58);
-DEFINE_LEGACY_NVRAM_DEVICE(MK48T08, mk48t08);
diff -Nru src-old/emu/machine/timekpr.h src/emu/machine/timekpr.h
--- src-old/emu/machine/timekpr.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/machine/timekpr.h	2010-08-30 08:20:58.000000000 -0700
@@ -1,52 +1,161 @@
-/*
- * STmicroelectronics TIMEKEEPER SRAM
- *
- * Supports:
- *           M48T02
- *           M48T35
- *           M48T58
- *           MK48T08
- *
- */
+/***************************************************************************
 
-#if !defined( TIMEKPR_H )
-#define TIMEKPR_H ( 1 )
+    timekpr.h
 
-#include "devlegcy.h"
+    Various ST Microelectronics timekeeper SRAM implementations:
+        - M48T02
+        - M48T35
+        - M48T58
+        - MK48T08
 
-typedef struct _timekeeper_config timekeeper_config;
-struct _timekeeper_config
-{
-	const char *data;
-};
+***************************************************************************/
 
-DECLARE_LEGACY_NVRAM_DEVICE(M48T02, m48t02);
+#pragma once
 
-#define MDRV_M48T02_ADD(_tag) \
-	MDRV_DEVICE_ADD(_tag, M48T02, 0)
+#ifndef __TIMEKPR_H__
+#define __TIMEKPR_H__
 
+#include "emu.h"
+#include "devhelpr.h"
 
-DECLARE_LEGACY_NVRAM_DEVICE(M48T35, m48t35);
 
-#define MDRV_M48T35_ADD(_tag) \
-	MDRV_DEVICE_ADD(_tag, M48T35, 0)
 
+//**************************************************************************
+//  INTERFACE CONFIGURATION MACROS
+//**************************************************************************
+
+#define MDRV_M48T02_ADD(_tag) \
+	MDRV_DEVICE_ADD(_tag, M48T02, 0)
 
-DECLARE_LEGACY_NVRAM_DEVICE(M48T58, m48t58);
+#define MDRV_M48T35_ADD(_tag) \
+	MDRV_DEVICE_ADD(_tag, M48T35, 0)
 
 #define MDRV_M48T58_ADD(_tag) \
 	MDRV_DEVICE_ADD(_tag, M48T58, 0)
 
-
-DECLARE_LEGACY_NVRAM_DEVICE(MK48T08, mk48t08);
-
 #define MDRV_MK48T08_ADD(_tag) \
 	MDRV_DEVICE_ADD(_tag, MK48T08, 0)
 
 
-/* memory handlers */
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+
+// ======================> timekeeper_config
+
+struct timekeeper_config
+{
+	const UINT8 *m_data;
+};
+
+// ======================> timekeeper_device_config
+
+class timekeeper_device_config :	public device_config,
+									public device_config_nvram_interface,
+									public timekeeper_config
+{
+	friend class timekeeper_device;
+	friend class m48t02_device_config;
+	friend class m48t35_device_config;
+	friend class m48t58_device_config;
+	friend class mk48t08_device_config;
+
+protected:
+	// construction/destruction
+	timekeeper_device_config(const machine_config &mconfig, const char *type, const char *tag, const device_config *owner, UINT32 clock);
+
+public:
+	// allocators
+	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
+	virtual device_t *alloc_device(running_machine &machine) const;
+};
+
+
+// ======================> timekeeper_device
+
+class timekeeper_device :	public device_t,
+							public device_nvram_interface
+{
+	friend class timekeeper_device_config;
+	friend class m48t02_device;
+	friend class m48t35_device;
+	friend class m48t58_device;
+	friend class mk48t08_device;
+
+	// construction/destruction
+	timekeeper_device(running_machine &_machine, const timekeeper_device_config &config);
+
+public:
+	void timekeeper_tick();
+
+	void write(UINT16 offset, UINT8 data);
+	UINT8 read(UINT16 offset);
+
+protected:
+	// device-level overrides
+	virtual void device_start();
+	virtual void device_reset();
+
+	// device_nvram_interface overrides
+	virtual void nvram_default();
+	virtual void nvram_read(mame_file &file);
+	virtual void nvram_write(mame_file &file);
+
+	// internal state
+	const timekeeper_device_config &m_config;
+
+	static TIMER_CALLBACK( timekeeper_tick_callback );
+
+private:
+	void counters_to_ram();
+	void counters_from_ram();
+
+	UINT8 m_control;
+	UINT8 m_seconds;
+	UINT8 m_minutes;
+	UINT8 m_hours;
+	UINT8 m_day;
+	UINT8 m_date;
+	UINT8 m_month;
+	UINT8 m_year;
+	UINT8 m_century;
+
+	UINT8 *m_data;
+	UINT8 *m_default_data;
+
+	int m_size;
+	int m_offset_control;
+	int m_offset_seconds;
+	int m_offset_minutes;
+	int m_offset_hours;
+	int m_offset_day;
+	int m_offset_date;
+	int m_offset_month;
+	int m_offset_year;
+	int m_offset_century;
+	int m_offset_flags;
+};
+
+GENERIC_DEVICE_DERIVED_CONFIG(timekeeper, m48t02)
+GENERIC_DEVICE_DERIVED_CONFIG(timekeeper, m48t35)
+GENERIC_DEVICE_DERIVED_CONFIG(timekeeper, m48t58)
+GENERIC_DEVICE_DERIVED_CONFIG(timekeeper, mk48t08)
+
+// device type definition
+extern const device_type M48T02;
+extern const device_type M48T35;
+extern const device_type M48T58;
+extern const device_type MK48T08;
+
+
+
+//**************************************************************************
+//  READ/WRITE HANDLERS
+//**************************************************************************
 
 WRITE8_DEVICE_HANDLER( timekeeper_w );
 READ8_DEVICE_HANDLER( timekeeper_r );
 
-#endif
+#endif // __TIMEKPR_H__
diff -Nru src-old/emu/machine/tmp68301.c src/emu/machine/tmp68301.c
--- src-old/emu/machine/tmp68301.c	2010-07-07 14:01:36.000000000 -0700
+++ src/emu/machine/tmp68301.c	2010-08-13 01:54:21.000000000 -0700
@@ -11,7 +11,7 @@
 #include "emu.h"
 #include "machine/tmp68301.h"
 
-UINT16 *tmp68301_regs;
+static UINT16 tmp68301_regs[0x400];
 
 static UINT8 tmp68301_IE[3];		// 3 External Interrupt Lines
 static emu_timer *tmp68301_timer[3];		// 3 Timers
@@ -155,6 +155,11 @@
 	}
 }
 
+READ16_HANDLER( tmp68301_regs_r )
+{
+	return tmp68301_regs[offset];
+}
+
 WRITE16_HANDLER( tmp68301_regs_w )
 {
 	COMBINE_DATA(&tmp68301_regs[offset]);
diff -Nru src-old/emu/machine/tmp68301.h src/emu/machine/tmp68301.h
--- src-old/emu/machine/tmp68301.h	2009-12-21 09:10:00.000000000 -0800
+++ src/emu/machine/tmp68301.h	2010-08-13 01:54:21.000000000 -0700
@@ -6,7 +6,7 @@
 MACHINE_RESET( tmp68301 );
 
 // Hardware Registers
-extern UINT16 *tmp68301_regs;
+READ16_HANDLER( tmp68301_regs_r );
 WRITE16_HANDLER( tmp68301_regs_w );
 
 // Interrupts
diff -Nru src-old/emu/machine/z80dart.c src/emu/machine/z80dart.c
--- src-old/emu/machine/z80dart.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/machine/z80dart.c	2010-08-30 08:20:58.000000000 -0700
@@ -5,6 +5,12 @@
     Copyright (c) 2008, The MESS Team.
     Visit http://mamedev.org for licensing and usage restrictions.
 
+    The z80dart/z80sio itself is based on an older intel serial chip, the i8274 MPSC
+    (see http://doc.chipfind.ru/pdf/intel/8274.pdf), which also has almost identical
+    behavior, except lacks the interrupt daisy chaining and has its own interrupt/dma
+    scheme which uses write register 2 on channel A, that register which is unused on
+    the z80dart and z80sio.
+
 ***************************************************************************/
 
 /*
@@ -15,6 +21,8 @@
     - wr0 reset tx interrupt pending
     - wait/ready
     - 1.5 stop bits
+    - synchronous mode (Z80-SIO/1,2)
+    - SDLC mode (Z80-SIO/1,2)
 
 */
 
@@ -41,6 +49,12 @@
 
 enum
 {
+	CHANNEL_A = 0,
+	CHANNEL_B
+};
+
+enum
+{
 	STATE_START = 0,
 	STATE_DATA,
 	STATE_PARITY,
@@ -56,70 +70,91 @@
 	INT_SPECIAL
 };
 
-const int Z80DART_RR0_RX_CHAR_AVAILABLE		= 0x01;
-const int Z80DART_RR0_INTERRUPT_PENDING		= 0x02;
-const int Z80DART_RR0_TX_BUFFER_EMPTY		= 0x04;
-const int Z80DART_RR0_DCD					= 0x08;
-const int Z80DART_RR0_RI					= 0x10;
-const int Z80DART_RR0_CTS					= 0x20;
-const int Z80DART_RR0_BREAK					= 0x80; // not supported
-
-const int Z80DART_RR1_ALL_SENT				= 0x01;
-const int Z80DART_RR1_PARITY_ERROR			= 0x10;
-const int Z80DART_RR1_RX_OVERRUN_ERROR		= 0x20;
-const int Z80DART_RR1_FRAMING_ERROR			= 0x40;
-
-const int Z80DART_WR0_REGISTER_MASK			= 0x07;
-const int Z80DART_WR0_COMMAND_MASK			= 0x38;
-const int Z80DART_WR0_NULL_CODE				= 0x00;
-const int Z80DART_WR0_RESET_EXT_STATUS		= 0x10;
-const int Z80DART_WR0_CHANNEL_RESET			= 0x18;
-const int Z80DART_WR0_ENABLE_INT_NEXT_RX	= 0x20;
-const int Z80DART_WR0_RESET_TX_INT			= 0x28; // not supported
-const int Z80DART_WR0_ERROR_RESET			= 0x30;
-const int Z80DART_WR0_RETURN_FROM_INT		= 0x38; // not supported
-
-const int Z80DART_WR1_EXT_INT_ENABLE		= 0x01;
-const int Z80DART_WR1_TX_INT_ENABLE			= 0x02;
-const int Z80DART_WR1_STATUS_VECTOR			= 0x04;
-const int Z80DART_WR1_RX_INT_ENABLE_MASK	= 0x18;
-const int Z80DART_WR1_RX_INT_DISABLE		= 0x00;
-const int Z80DART_WR1_RX_INT_FIRST			= 0x08;
-const int Z80DART_WR1_RX_INT_ALL_PARITY		= 0x10; // not supported
-const int Z80DART_WR1_RX_INT_ALL			= 0x18;
-const int Z80DART_WR1_WRDY_ON_RX_TX			= 0x20; // not supported
-const int Z80DART_WR1_WRDY_FUNCTION			= 0x40; // not supported
-const int Z80DART_WR1_WRDY_ENABLE			= 0x80; // not supported
-
-const int Z80DART_WR3_RX_ENABLE				= 0x01;
-const int Z80DART_WR3_AUTO_ENABLES			= 0x20;
-const int Z80DART_WR3_RX_WORD_LENGTH_MASK	= 0xc0;
-const int Z80DART_WR3_RX_WORD_LENGTH_5		= 0x00;
-const int Z80DART_WR3_RX_WORD_LENGTH_7		= 0x40;
-const int Z80DART_WR3_RX_WORD_LENGTH_6		= 0x80;
-const int Z80DART_WR3_RX_WORD_LENGTH_8		= 0xc0;
-
-const int Z80DART_WR4_PARITY_ENABLE			= 0x01; // not supported
-const int Z80DART_WR4_PARITY_EVEN			= 0x02; // not supported
-const int Z80DART_WR4_STOP_BITS_MASK		= 0x0c;
-const int Z80DART_WR4_STOP_BITS_1			= 0x04;
-const int Z80DART_WR4_STOP_BITS_1_5			= 0x08; // not supported
-const int Z80DART_WR4_STOP_BITS_2			= 0x0c;
-const int Z80DART_WR4_CLOCK_MODE_MASK		= 0xc0;
-const int Z80DART_WR4_CLOCK_MODE_X1			= 0x00;
-const int Z80DART_WR4_CLOCK_MODE_X16		= 0x40;
-const int Z80DART_WR4_CLOCK_MODE_X32		= 0x80;
-const int Z80DART_WR4_CLOCK_MODE_X64		= 0xc0;
-
-const int Z80DART_WR5_RTS					= 0x02;
-const int Z80DART_WR5_TX_ENABLE				= 0x08;
-const int Z80DART_WR5_SEND_BREAK			= 0x10;
-const int Z80DART_WR5_TX_WORD_LENGTH_MASK	= 0xc0;
-const int Z80DART_WR5_TX_WORD_LENGTH_5		= 0x00;
-const int Z80DART_WR5_TX_WORD_LENGTH_7		= 0x40;
-const int Z80DART_WR5_TX_WORD_LENGTH_6		= 0x80;
-const int Z80DART_WR5_TX_WORD_LENGTH_8		= 0xc0;
-const int Z80DART_WR5_DTR					= 0x80;
+const int RR0_RX_CHAR_AVAILABLE		= 0x01;
+const int RR0_INTERRUPT_PENDING		= 0x02;
+const int RR0_TX_BUFFER_EMPTY		= 0x04;
+const int RR0_DCD					= 0x08;
+const int RR0_RI					= 0x10;
+const int RR0_SYNC_HUNT				= 0x10; // not supported
+const int RR0_CTS					= 0x20;
+const int RR0_TX_UNDERRUN			= 0x40; // not supported
+const int RR0_BREAK_ABORT			= 0x80; // not supported
+
+const int RR1_ALL_SENT				= 0x01;
+const int RR1_RESIDUE_CODE_MASK		= 0x0e; // not supported
+const int RR1_PARITY_ERROR			= 0x10;
+const int RR1_RX_OVERRUN_ERROR		= 0x20;
+const int RR1_CRC_FRAMING_ERROR		= 0x40;
+const int RR1_END_OF_FRAME			= 0x80; // not supported
+
+const int WR0_REGISTER_MASK			= 0x07;
+const int WR0_COMMAND_MASK			= 0x38;
+const int WR0_NULL					= 0x00;
+const int WR0_SEND_ABORT			= 0x08; // not supported
+const int WR0_RESET_EXT_STATUS		= 0x10;
+const int WR0_CHANNEL_RESET			= 0x18;
+const int WR0_ENABLE_INT_NEXT_RX	= 0x20;
+const int WR0_RESET_TX_INT			= 0x28; // not supported
+const int WR0_ERROR_RESET			= 0x30;
+const int WR0_RETURN_FROM_INT		= 0x38; // not supported
+const int WR0_CRC_RESET_CODE_MASK	= 0xc0; // not supported
+const int WR0_CRC_RESET_NULL		= 0x00; // not supported
+const int WR0_CRC_RESET_RX			= 0x40; // not supported
+const int WR0_CRC_RESET_TX			= 0x80; // not supported
+const int WR0_CRC_RESET_TX_UNDERRUN	= 0xc0; // not supported
+
+const int WR1_EXT_INT_ENABLE		= 0x01;
+const int WR1_TX_INT_ENABLE			= 0x02;
+const int WR1_STATUS_VECTOR			= 0x04;
+const int WR1_RX_INT_MODE_MASK		= 0x18;
+const int WR1_RX_INT_DISABLE		= 0x00;
+const int WR1_RX_INT_FIRST			= 0x08;
+const int WR1_RX_INT_ALL_PARITY		= 0x10; // not supported
+const int WR1_RX_INT_ALL			= 0x18;
+const int WR1_WRDY_ON_RX_TX			= 0x20; // not supported
+const int WR1_WRDY_FUNCTION			= 0x40; // not supported
+const int WR1_WRDY_ENABLE			= 0x80; // not supported
+
+const int WR3_RX_ENABLE				= 0x01;
+const int WR3_SYNC_CHAR_LOAD_INHIBIT= 0x02; // not supported
+const int WR3_ADDRESS_SEARCH_MODE	= 0x04; // not supported
+const int WR3_RX_CRC_ENABLE			= 0x08; // not supported
+const int WR3_ENTER_HUNT_PHASE		= 0x10; // not supported
+const int WR3_AUTO_ENABLES			= 0x20;
+const int WR3_RX_WORD_LENGTH_MASK	= 0xc0;
+const int WR3_RX_WORD_LENGTH_5		= 0x00;
+const int WR3_RX_WORD_LENGTH_7		= 0x40;
+const int WR3_RX_WORD_LENGTH_6		= 0x80;
+const int WR3_RX_WORD_LENGTH_8		= 0xc0;
+
+const int WR4_PARITY_ENABLE			= 0x01; // not supported
+const int WR4_PARITY_EVEN			= 0x02; // not supported
+const int WR4_STOP_BITS_MASK		= 0x0c;
+const int WR4_STOP_BITS_1			= 0x04;
+const int WR4_STOP_BITS_1_5			= 0x08; // not supported
+const int WR4_STOP_BITS_2			= 0x0c;
+const int WR4_SYNC_MODE_MASK		= 0x30; // not supported
+const int WR4_SYNC_MODE_8_BIT		= 0x00; // not supported
+const int WR4_SYNC_MODE_16_BIT		= 0x10; // not supported
+const int WR4_SYNC_MODE_SDLC		= 0x20; // not supported
+const int WR4_SYNC_MODE_EXT			= 0x30; // not supported
+const int WR4_CLOCK_RATE_MASK		= 0xc0;
+const int WR4_CLOCK_RATE_X1			= 0x00;
+const int WR4_CLOCK_RATE_X16		= 0x40;
+const int WR4_CLOCK_RATE_X32		= 0x80;
+const int WR4_CLOCK_RATE_X64		= 0xc0;
+
+const int WR5_TX_CRC_ENABLE			= 0x01; // not supported
+const int WR5_RTS					= 0x02;
+const int WR5_CRC16					= 0x04; // not supported
+const int WR5_TX_ENABLE				= 0x08;
+const int WR5_SEND_BREAK			= 0x10;
+const int WR5_TX_WORD_LENGTH_MASK	= 0xc0;
+const int WR5_TX_WORD_LENGTH_5		= 0x00;
+const int WR5_TX_WORD_LENGTH_7		= 0x40;
+const int WR5_TX_WORD_LENGTH_6		= 0x80;
+const int WR5_TX_WORD_LENGTH_8		= 0xc0;
+const int WR5_DTR					= 0x80;
 
 
 
@@ -193,17 +228,19 @@
 	// or initialize to defaults if none provided
 	else
 	{
-		m_rx_clock_a = m_tx_clock_a = m_rx_tx_clock_b = 0;
+		m_rx_clock_a = m_tx_clock_a = m_rx_clock_b = m_tx_clock_b = 0;
 		memset(&m_in_rxda_func, 0, sizeof(m_in_rxda_func));
 		memset(&m_out_txda_func, 0, sizeof(m_out_txda_func));
 		memset(&m_out_dtra_func, 0, sizeof(m_out_dtra_func));
 		memset(&m_out_rtsa_func, 0, sizeof(m_out_rtsa_func));
 		memset(&m_out_wrdya_func, 0, sizeof(m_out_wrdya_func));
+		memset(&m_out_synca_func, 0, sizeof(m_out_synca_func));
 		memset(&m_in_rxdb_func, 0, sizeof(m_in_rxdb_func));
 		memset(&m_out_txdb_func, 0, sizeof(m_out_txdb_func));
 		memset(&m_out_dtrb_func, 0, sizeof(m_out_dtrb_func));
 		memset(&m_out_rtsb_func, 0, sizeof(m_out_rtsb_func));
 		memset(&m_out_wrdyb_func, 0, sizeof(m_out_wrdyb_func));
+		memset(&m_out_syncb_func, 0, sizeof(m_out_syncb_func));
 		memset(&m_out_int_func, 0, sizeof(m_out_int_func));
 	}
 }
@@ -223,6 +260,8 @@
 	  device_z80daisy_interface(_machine, config, *this),
 	  m_config(config)
 {
+	for (int i = 0; i < 8; i++)
+		m_int_state[i] = 0;
 }
 
 
@@ -235,28 +274,35 @@
 	// resolve callbacks
 	devcb_resolve_write_line(&m_out_int_func, &m_config.m_out_int_func, this);
 
-	m_channel[Z80DART_CH_A].start(this, Z80DART_CH_A, m_config.m_in_rxda_func, m_config.m_out_txda_func, m_config.m_out_dtra_func, m_config.m_out_rtsa_func, m_config.m_out_wrdya_func);
-	m_channel[Z80DART_CH_B].start(this, Z80DART_CH_B, m_config.m_in_rxdb_func, m_config.m_out_txdb_func, m_config.m_out_dtrb_func, m_config.m_out_rtsb_func, m_config.m_out_wrdyb_func);
+	m_channel[CHANNEL_A].start(this, CHANNEL_A, m_config.m_in_rxda_func, m_config.m_out_txda_func, m_config.m_out_dtra_func, m_config.m_out_rtsa_func, m_config.m_out_wrdya_func, m_config.m_out_synca_func);
+	m_channel[CHANNEL_B].start(this, CHANNEL_B, m_config.m_in_rxdb_func, m_config.m_out_txdb_func, m_config.m_out_dtrb_func, m_config.m_out_rtsb_func, m_config.m_out_wrdyb_func, m_config.m_out_syncb_func);
 
 	if (m_config.m_rx_clock_a != 0)
 	{
 		// allocate channel A receive timer
-		m_rxca_timer = timer_alloc(&m_machine, dart_channel::static_rxca_tick, (void *)&m_channel[Z80DART_CH_A]);
+		m_rxca_timer = timer_alloc(&m_machine, dart_channel::static_rxc_tick, (void *)&m_channel[CHANNEL_A]);
 		timer_adjust_periodic(m_rxca_timer, attotime_zero, 0, ATTOTIME_IN_HZ(m_config.m_rx_clock_a));
 	}
 
 	if (m_config.m_tx_clock_a != 0)
 	{
 		// allocate channel A transmit timer
-		m_txca_timer = timer_alloc(&m_machine, dart_channel::static_txca_tick, (void *)&m_channel[Z80DART_CH_A]);
+		m_txca_timer = timer_alloc(&m_machine, dart_channel::static_txc_tick, (void *)&m_channel[CHANNEL_A]);
 		timer_adjust_periodic(m_txca_timer, attotime_zero, 0, ATTOTIME_IN_HZ(m_config.m_tx_clock_a));
 	}
 
-	if (m_config.m_rx_tx_clock_b != 0)
+	if (m_config.m_rx_clock_b != 0)
+	{
+		// allocate channel B receive timer
+		m_rxcb_timer = timer_alloc(&m_machine, dart_channel::static_rxc_tick, (void *)&m_channel[CHANNEL_B]);
+		timer_adjust_periodic(m_rxcb_timer, attotime_zero, 0, ATTOTIME_IN_HZ(m_config.m_rx_clock_b));
+	}
+
+	if (m_config.m_tx_clock_b != 0)
 	{
-		// allocate channel B receive/transmit timer
-		m_rxtxcb_timer = timer_alloc(&m_machine, dart_channel::static_rxtxcb_tick, (void *)&m_channel[Z80DART_CH_B]);
-		timer_adjust_periodic(m_rxtxcb_timer, attotime_zero, 0, ATTOTIME_IN_HZ(m_config.m_rx_tx_clock_b));
+		// allocate channel B transmit timer
+		m_txcb_timer = timer_alloc(&m_machine, dart_channel::static_txc_tick, (void *)&m_channel[CHANNEL_B]);
+		timer_adjust_periodic(m_txcb_timer, attotime_zero, 0, ATTOTIME_IN_HZ(m_config.m_tx_clock_b));
 	}
 
 	state_save_register_device_item_array(this, 0, m_int_state);
@@ -271,7 +317,7 @@
 {
 	LOG(("Z80DART \"%s\" Reset\n", tag()));
 
-	for (int channel = Z80DART_CH_A; channel <= Z80DART_CH_B; channel++)
+	for (int channel = CHANNEL_A; channel <= CHANNEL_B; channel++)
 	{
 		m_channel[channel].reset();
 	}
@@ -334,18 +380,18 @@
 		{
 			// clear interrupt, switch to the IEO state, and update the IRQs
 			m_int_state[i] = Z80_DAISY_IEO;
-			m_channel[Z80DART_CH_A].m_rr[0] &= ~Z80DART_RR0_INTERRUPT_PENDING;
+			m_channel[CHANNEL_A].m_rr[0] &= ~RR0_INTERRUPT_PENDING;
 			check_interrupts();
 
-			LOG(("Z80DART \"%s\" : Interrupt Acknowledge Vector %02x\n", tag(), m_channel[Z80DART_CH_B].m_rr[2]));
+			LOG(("Z80DART \"%s\" : Interrupt Acknowledge Vector %02x\n", tag(), m_channel[CHANNEL_B].m_rr[2]));
 
-			return m_channel[Z80DART_CH_B].m_rr[2];
+			return m_channel[CHANNEL_B].m_rr[2];
 		}
 	}
 
 	logerror("z80dart_irq_ack: failed to find an interrupt to ack!\n");
 
-	return m_channel[Z80DART_CH_B].m_rr[2];
+	return m_channel[CHANNEL_B].m_rr[2];
 }
 
 
@@ -399,7 +445,7 @@
 void z80dart_device::take_interrupt(int priority)
 {
 	m_int_state[priority] |= Z80_DAISY_INT;
-	m_channel[Z80DART_CH_A].m_rr[0] |= Z80DART_RR0_INTERRUPT_PENDING;
+	m_channel[CHANNEL_A].m_rr[0] |= RR0_INTERRUPT_PENDING;
 
 	// check for interrupt
 	check_interrupts();
@@ -436,7 +482,8 @@
 	  m_tx_bits(0),
 	  m_tx_parity(0),
 	  m_dtr(0),
-	  m_rts(0)
+	  m_rts(0),
+	  m_sync(0)
 {
 	memset(&m_in_rxd_func, 0, sizeof(m_in_rxd_func));
 	memset(&m_out_txd_func, 0, sizeof(m_out_txd_func));
@@ -454,7 +501,7 @@
 //  start - channel startup
 //-------------------------------------------------
 
-void z80dart_device::dart_channel::start(z80dart_device *device, int index, const devcb_read_line &in_rxd, const devcb_write_line &out_txd, const devcb_write_line &out_dtr, const devcb_write_line &out_rts, const devcb_write_line &out_wrdy)
+void z80dart_device::dart_channel::start(z80dart_device *device, int index, const devcb_read_line &in_rxd, const devcb_write_line &out_txd, const devcb_write_line &out_dtr, const devcb_write_line &out_rts, const devcb_write_line &out_wrdy, const devcb_write_line &out_sync)
 {
 	m_index = index;
 	m_device = device;
@@ -464,6 +511,7 @@
 	devcb_resolve_write_line(&m_out_dtr_func, &out_dtr, m_device);
 	devcb_resolve_write_line(&m_out_rts_func, &out_rts, m_device);
 	devcb_resolve_write_line(&m_out_wrdy_func, &out_wrdy, m_device);
+	devcb_resolve_write_line(&m_out_sync_func, &out_sync, m_device);
 
 	state_save_register_device_item_array(m_device, m_index, m_rr);
 	state_save_register_device_item_array(m_device, m_index, m_wr);
@@ -490,6 +538,7 @@
 	state_save_register_device_item(m_device, m_index, m_tx_parity);
 	state_save_register_device_item(m_device, m_index, m_dtr);
 	state_save_register_device_item(m_device, m_index, m_rts);
+	state_save_register_device_item(m_device, m_index, m_sync);
 }
 
 
@@ -504,7 +553,7 @@
 
 	LOG(("Z80DART \"%s\" Channel %c : Interrupt Request %u\n", m_device->tag(), 'A' + m_index, level));
 
-	if ((m_index == Z80DART_CH_B) && (m_wr[1] & Z80DART_WR1_STATUS_VECTOR))
+	if ((m_index == CHANNEL_B) && (m_wr[1] & WR1_STATUS_VECTOR))
 	{
 		// status affects vector
 		vector = (m_wr[2] & 0xf1) | (!m_index << 3) | (level << 1);
@@ -526,12 +575,12 @@
 {
 	int clocks = 1;
 
-	switch (m_wr[4] & Z80DART_WR4_CLOCK_MODE_MASK)
+	switch (m_wr[4] & WR4_CLOCK_RATE_MASK)
 	{
-	case Z80DART_WR4_CLOCK_MODE_X1:		clocks = 1;		break;
-	case Z80DART_WR4_CLOCK_MODE_X16:	clocks = 16;	break;
-	case Z80DART_WR4_CLOCK_MODE_X32:	clocks = 32;	break;
-	case Z80DART_WR4_CLOCK_MODE_X64:	clocks = 64;	break;
+	case WR4_CLOCK_RATE_X1:		clocks = 1;		break;
+	case WR4_CLOCK_RATE_X16:	clocks = 16;	break;
+	case WR4_CLOCK_RATE_X32:	clocks = 32;	break;
+	case WR4_CLOCK_RATE_X64:	clocks = 64;	break;
 	}
 
 	return clocks;
@@ -546,11 +595,11 @@
 {
 	float bits = 1;
 
-	switch (m_wr[4] & Z80DART_WR4_STOP_BITS_MASK)
+	switch (m_wr[4] & WR4_STOP_BITS_MASK)
 	{
-	case Z80DART_WR4_STOP_BITS_1:		bits = 1;		break;
-	case Z80DART_WR4_STOP_BITS_1_5:		bits = 1.5;		break;
-	case Z80DART_WR4_STOP_BITS_2:		bits = 2;		break;
+	case WR4_STOP_BITS_1:		bits = 1;		break;
+	case WR4_STOP_BITS_1_5:		bits = 1.5;		break;
+	case WR4_STOP_BITS_2:		bits = 2;		break;
 	}
 
 	return bits;
@@ -565,12 +614,12 @@
 {
 	int bits = 5;
 
-	switch (m_wr[3] & Z80DART_WR3_RX_WORD_LENGTH_MASK)
+	switch (m_wr[3] & WR3_RX_WORD_LENGTH_MASK)
 	{
-	case Z80DART_WR3_RX_WORD_LENGTH_5:	bits = 5;		break;
-	case Z80DART_WR3_RX_WORD_LENGTH_6:	bits = 6;		break;
-	case Z80DART_WR3_RX_WORD_LENGTH_7:	bits = 7;		break;
-	case Z80DART_WR3_RX_WORD_LENGTH_8:	bits = 8;		break;
+	case WR3_RX_WORD_LENGTH_5:	bits = 5;		break;
+	case WR3_RX_WORD_LENGTH_6:	bits = 6;		break;
+	case WR3_RX_WORD_LENGTH_7:	bits = 7;		break;
+	case WR3_RX_WORD_LENGTH_8:	bits = 8;		break;
 	}
 
 	return bits;
@@ -585,12 +634,12 @@
 {
 	int bits = 5;
 
-	switch (m_wr[5] & Z80DART_WR5_TX_WORD_LENGTH_MASK)
+	switch (m_wr[5] & WR5_TX_WORD_LENGTH_MASK)
 	{
-	case Z80DART_WR5_TX_WORD_LENGTH_5:	bits = 5;	break;
-	case Z80DART_WR5_TX_WORD_LENGTH_6:	bits = 6;	break;
-	case Z80DART_WR5_TX_WORD_LENGTH_7:	bits = 7;	break;
-	case Z80DART_WR5_TX_WORD_LENGTH_8:	bits = 8;	break;
+	case WR5_TX_WORD_LENGTH_5:	bits = 5;	break;
+	case WR5_TX_WORD_LENGTH_6:	bits = 6;	break;
+	case WR5_TX_WORD_LENGTH_7:	bits = 7;	break;
+	case WR5_TX_WORD_LENGTH_8:	bits = 8;	break;
 	}
 
 	return bits;
@@ -604,18 +653,18 @@
 void z80dart_device::dart_channel::reset()
 {
 	// disable receiver
-	m_wr[3] &= ~Z80DART_WR3_RX_ENABLE;
+	m_wr[3] &= ~WR3_RX_ENABLE;
 	m_rx_state = STATE_START;
 
 	// disable transmitter
-	m_wr[5] &= ~Z80DART_WR5_TX_ENABLE;
+	m_wr[5] &= ~WR5_TX_ENABLE;
 	m_tx_state = STATE_START;
 
 	// reset external lines
 	RTS(1);
 	DTR(1);
 
-	if (m_index == Z80DART_CH_A)
+	if (m_index == CHANNEL_A)
 	{
 		// reset interrupt logic
 		int i;
@@ -636,7 +685,7 @@
 
 int z80dart_device::dart_channel::detect_start_bit()
 {
-	if (!(m_wr[3] & Z80DART_WR3_RX_ENABLE)) return 0;
+	if (!(m_wr[3] & WR3_RX_ENABLE)) return 0;
 
 	return !RXD;
 }
@@ -677,27 +726,27 @@
 
 void z80dart_device::dart_channel::detect_parity_error()
 {
-	int parity = (m_wr[1] & Z80DART_WR4_PARITY_EVEN) ? 1 : 0;
+	int parity = (m_wr[1] & WR4_PARITY_EVEN) ? 1 : 0;
 
 	if (RXD != (m_rx_parity ^ parity))
 	{
 		// parity error detected
-		m_rx_error |= Z80DART_RR1_PARITY_ERROR;
+		m_rx_error |= RR1_PARITY_ERROR;
 
-		switch (m_wr[1] & Z80DART_WR1_RX_INT_ENABLE_MASK)
+		switch (m_wr[1] & WR1_RX_INT_MODE_MASK)
 		{
-		case Z80DART_WR1_RX_INT_FIRST:
+		case WR1_RX_INT_FIRST:
 			if (!m_rx_first)
 			{
 				take_interrupt(INT_SPECIAL);
 			}
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL_PARITY:
+		case WR1_RX_INT_ALL_PARITY:
 			take_interrupt(INT_SPECIAL);
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL:
+		case WR1_RX_INT_ALL:
 			take_interrupt(INT_RECEIVE);
 			break;
 		}
@@ -714,19 +763,19 @@
 	if (!RXD)
 	{
 		// framing error detected
-		m_rx_error |= Z80DART_RR1_FRAMING_ERROR;
+		m_rx_error |= RR1_CRC_FRAMING_ERROR;
 
-		switch (m_wr[1] & Z80DART_WR1_RX_INT_ENABLE_MASK)
+		switch (m_wr[1] & WR1_RX_INT_MODE_MASK)
 		{
-		case Z80DART_WR1_RX_INT_FIRST:
+		case WR1_RX_INT_FIRST:
 			if (!m_rx_first)
 			{
 				take_interrupt(INT_SPECIAL);
 			}
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL_PARITY:
-		case Z80DART_WR1_RX_INT_ALL:
+		case WR1_RX_INT_ALL_PARITY:
+		case WR1_RX_INT_ALL:
 			take_interrupt(INT_SPECIAL);
 			break;
 		}
@@ -766,7 +815,7 @@
 		if (character_completed())
 		{
 			// all data bits received
-			if (m_wr[4] & Z80DART_WR4_PARITY_ENABLE)
+			if (m_wr[4] & WR4_PARITY_ENABLE)
 			{
 				// next bit is the parity bit
 				m_rx_state = STATE_PARITY;
@@ -836,7 +885,7 @@
 	switch (m_tx_state)
 	{
 	case STATE_START:
-		if ((m_wr[5] & Z80DART_WR5_TX_ENABLE) && !(m_rr[0] & Z80DART_RR0_TX_BUFFER_EMPTY))
+		if ((m_wr[5] & WR5_TX_ENABLE) && !(m_rr[0] & RR0_TX_BUFFER_EMPTY))
 		{
 			// transmit start bit
 			TXD(0);
@@ -845,14 +894,14 @@
 			m_tx_shift = m_tx_data;
 
 			// empty transmit buffer
-			m_rr[0] |= Z80DART_RR0_TX_BUFFER_EMPTY;
+			m_rr[0] |= RR0_TX_BUFFER_EMPTY;
 
-			if (m_wr[1] & Z80DART_WR1_TX_INT_ENABLE)
+			if (m_wr[1] & WR1_TX_INT_ENABLE)
 				take_interrupt(INT_TRANSMIT);
 
 			m_tx_state = STATE_DATA;
 		}
-		else if (m_wr[5] & Z80DART_WR5_SEND_BREAK)
+		else if (m_wr[5] & WR5_SEND_BREAK)
 		{
 			// transmit break
 			TXD(0);
@@ -875,7 +924,7 @@
 
 		if (m_rx_bits == word_length)
 		{
-			if (m_wr[4] & Z80DART_WR4_PARITY_ENABLE)
+			if (m_wr[4] & WR4_PARITY_ENABLE)
 				m_tx_state = STATE_PARITY;
 			else
 			{
@@ -907,10 +956,10 @@
 		TXD(1);
 
 		// if transmit buffer is empty
-		if (m_rr[0] & Z80DART_RR0_TX_BUFFER_EMPTY)
+		if (m_rr[0] & RR0_TX_BUFFER_EMPTY)
 		{
 			// then all characters have been sent
-			m_rr[1] |= Z80DART_RR1_ALL_SENT;
+			m_rr[1] |= RR1_ALL_SENT;
 
 			// when the RTS bit is reset, the _RTS output goes high after the transmitter empties
 			if (!m_rts)
@@ -931,7 +980,7 @@
 {
 	UINT8 data = 0;
 
-	int reg = m_wr[0] & Z80DART_WR0_REGISTER_MASK;
+	int reg = m_wr[0] & WR0_REGISTER_MASK;
 
 	switch (reg)
 	{
@@ -942,7 +991,7 @@
 
 	case 2:
 		// channel B only
-		if (m_index == Z80DART_CH_B)
+		if (m_index == CHANNEL_B)
 			data = m_rr[reg];
 		break;
 	}
@@ -959,7 +1008,7 @@
 
 void z80dart_device::dart_channel::control_write(UINT8 data)
 {
-	int reg = m_wr[0] & Z80DART_WR0_REGISTER_MASK;
+	int reg = m_wr[0] & WR0_REGISTER_MASK;
 
 	LOG(("Z80DART \"%s\" Channel %c : Control Register Write '%02x'\n", m_device->tag(), 'A' + m_index, data));
 
@@ -969,51 +1018,61 @@
 	if (reg != 0)
 	{
 		// mask out register index
-		m_wr[0] &= ~Z80DART_WR0_REGISTER_MASK;
+		m_wr[0] &= ~WR0_REGISTER_MASK;
 	}
 
 	switch (reg)
 	{
 	case 0:
-		switch (data & Z80DART_WR0_COMMAND_MASK)
+		switch (data & WR0_COMMAND_MASK)
 		{
-		case Z80DART_WR0_RESET_EXT_STATUS:
+		case WR0_NULL:
+			LOG(("Z80DART \"%s\" Channel %c : Null\n", m_device->tag(), 'A' + m_index));
+			break;
+
+		case WR0_SEND_ABORT:
+			LOG(("Z80DART \"%s\" Channel %c : Send Abort\n", m_device->tag(), 'A' + m_index));
+			logerror("Z80DART \"%s\" Channel %c : unsupported command: Send Abort\n", m_device->tag(), 'A' + m_index);
+			break;
+
+		case WR0_RESET_EXT_STATUS:
 			// reset external/status interrupt
-			m_rr[0] &= ~(Z80DART_RR0_DCD | Z80DART_RR0_RI | Z80DART_RR0_CTS | Z80DART_RR0_BREAK);
+			m_rr[0] &= ~(RR0_DCD | RR0_RI | RR0_CTS | RR0_BREAK_ABORT);
 
-			if (!m_dcd) m_rr[0] |= Z80DART_RR0_DCD;
-			if (m_ri) m_rr[0] |= Z80DART_RR0_RI;
-			if (m_cts) m_rr[0] |= Z80DART_RR0_CTS;
+			if (!m_dcd) m_rr[0] |= RR0_DCD;
+			if (m_ri) m_rr[0] |= RR0_RI;
+			if (m_cts) m_rr[0] |= RR0_CTS;
 
 			m_rx_rr0_latch = 0;
 
 			LOG(("Z80DART \"%s\" Channel %c : Reset External/Status Interrupt\n", m_device->tag(), 'A' + m_index));
 			break;
 
-		case Z80DART_WR0_CHANNEL_RESET:
+		case WR0_CHANNEL_RESET:
 			// channel reset
 			LOG(("Z80DART \"%s\" Channel %c : Channel Reset\n", m_device->tag(), 'A' + m_index));
 			reset();
 			break;
 
-		case Z80DART_WR0_ENABLE_INT_NEXT_RX:
+		case WR0_ENABLE_INT_NEXT_RX:
 			// enable interrupt on next receive character
 			LOG(("Z80DART \"%s\" Channel %c : Enable Interrupt on Next Received Character\n", m_device->tag(), 'A' + m_index));
 			m_rx_first = 1;
 			break;
 
-		case Z80DART_WR0_RESET_TX_INT:
+		case WR0_RESET_TX_INT:
 			// reset transmitter interrupt pending
 			LOG(("Z80DART \"%s\" Channel %c : Reset Transmitter Interrupt Pending\n", m_device->tag(), 'A' + m_index));
+			logerror("Z80DART \"%s\" Channel %c : unsupported command: Reset Transmitter Interrupt Pending\n", m_device->tag(), 'A' + m_index);
 			break;
 
-		case Z80DART_WR0_ERROR_RESET:
+		case WR0_ERROR_RESET:
 			// error reset
 			LOG(("Z80DART \"%s\" Channel %c : Error Reset\n", m_device->tag(), 'A' + m_index));
-			m_rr[1] &= ~(Z80DART_RR1_FRAMING_ERROR | Z80DART_RR1_RX_OVERRUN_ERROR | Z80DART_RR1_PARITY_ERROR);
+			m_rr[1] &= ~(RR1_CRC_FRAMING_ERROR | RR1_RX_OVERRUN_ERROR | RR1_PARITY_ERROR);
 			break;
 
-		case Z80DART_WR0_RETURN_FROM_INT:
+		case WR0_RETURN_FROM_INT:
 			// return from interrupt
 			LOG(("Z80DART \"%s\" Channel %c : Return from Interrupt\n", m_device->tag(), 'A' + m_index));
 			m_device->z80daisy_irq_reti();
@@ -1022,26 +1081,26 @@
 		break;
 
 	case 1:
-		LOG(("Z80DART \"%s\" Channel %c : External Interrupt Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR1_EXT_INT_ENABLE) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Transmit Interrupt Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR1_TX_INT_ENABLE) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Status Affects Vector %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR1_STATUS_VECTOR) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Wait/Ready Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR1_WRDY_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : External Interrupt Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR1_EXT_INT_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Transmit Interrupt Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR1_TX_INT_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Status Affects Vector %u\n", m_device->tag(), 'A' + m_index, (data & WR1_STATUS_VECTOR) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Wait/Ready Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR1_WRDY_ENABLE) ? 1 : 0));
 
-		switch (data & Z80DART_WR1_RX_INT_ENABLE_MASK)
+		switch (data & WR1_RX_INT_MODE_MASK)
 		{
-		case Z80DART_WR1_RX_INT_DISABLE:
+		case WR1_RX_INT_DISABLE:
 			LOG(("Z80DART \"%s\" Channel %c : Receiver Interrupt Disabled\n", m_device->tag(), 'A' + m_index));
 			break;
 
-		case Z80DART_WR1_RX_INT_FIRST:
+		case WR1_RX_INT_FIRST:
 			LOG(("Z80DART \"%s\" Channel %c : Receiver Interrupt on First Character\n", m_device->tag(), 'A' + m_index));
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL_PARITY:
+		case WR1_RX_INT_ALL_PARITY:
 			LOG(("Z80DART \"%s\" Channel %c : Receiver Interrupt on All Characters, Parity Affects Vector\n", m_device->tag(), 'A' + m_index));
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL:
+		case WR1_RX_INT_ALL:
 			LOG(("Z80DART \"%s\" Channel %c : Receiver Interrupt on All Characters\n", m_device->tag(), 'A' + m_index));
 			break;
 		}
@@ -1056,26 +1115,26 @@
 		break;
 
 	case 3:
-		LOG(("Z80DART \"%s\" Channel %c : Receiver Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR3_RX_ENABLE) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Auto Enables %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR3_AUTO_ENABLES) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Receiver Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR3_RX_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Auto Enables %u\n", m_device->tag(), 'A' + m_index, (data & WR3_AUTO_ENABLES) ? 1 : 0));
 		LOG(("Z80DART \"%s\" Channel %c : Receiver Bits/Character %u\n", m_device->tag(), 'A' + m_index, get_rx_word_length()));
 		break;
 
 	case 4:
-		LOG(("Z80DART \"%s\" Channel %c : Parity Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR4_PARITY_ENABLE) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Parity %s\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR4_PARITY_EVEN) ? "Even" : "Odd"));
+		LOG(("Z80DART \"%s\" Channel %c : Parity Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR4_PARITY_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Parity %s\n", m_device->tag(), 'A' + m_index, (data & WR4_PARITY_EVEN) ? "Even" : "Odd"));
 		LOG(("Z80DART \"%s\" Channel %c : Stop Bits %f\n", m_device->tag(), 'A' + m_index, get_stop_bits()));
 		LOG(("Z80DART \"%s\" Channel %c : Clock Mode %uX\n", m_device->tag(), 'A' + m_index, get_clock_mode()));
 		break;
 
 	case 5:
-		LOG(("Z80DART \"%s\" Channel %c : Transmitter Enable %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR5_TX_ENABLE) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Transmitter Enable %u\n", m_device->tag(), 'A' + m_index, (data & WR5_TX_ENABLE) ? 1 : 0));
 		LOG(("Z80DART \"%s\" Channel %c : Transmitter Bits/Character %u\n", m_device->tag(), 'A' + m_index, get_tx_word_length()));
-		LOG(("Z80DART \"%s\" Channel %c : Send Break %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR5_SEND_BREAK) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Request to Send %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR5_RTS) ? 1 : 0));
-		LOG(("Z80DART \"%s\" Channel %c : Data Terminal Ready %u\n", m_device->tag(), 'A' + m_index, (data & Z80DART_WR5_DTR) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Send Break %u\n", m_device->tag(), 'A' + m_index, (data & WR5_SEND_BREAK) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Request to Send %u\n", m_device->tag(), 'A' + m_index, (data & WR5_RTS) ? 1 : 0));
+		LOG(("Z80DART \"%s\" Channel %c : Data Terminal Ready %u\n", m_device->tag(), 'A' + m_index, (data & WR5_DTR) ? 1 : 0));
 
-		if (data & Z80DART_WR5_RTS)
+		if (data & WR5_RTS)
 		{
 			// when the RTS bit is set, the _RTS output goes low
 			RTS(0);
@@ -1089,9 +1148,19 @@
 		}
 
 		// data terminal ready output follows the state programmed into the DTR bit*/
-		m_dtr = (data & Z80DART_WR5_DTR) ? 0 : 1;
+		m_dtr = (data & WR5_DTR) ? 0 : 1;
 		DTR(m_dtr);
 		break;
+
+	case 6:
+		LOG(("Z80DART \"%s\" Channel %c : Transmit Sync %02x\n", m_device->tag(), 'A' + m_index, data));
+		m_sync = (m_sync & 0xff00) | data;
+		break;
+
+	case 7:
+		LOG(("Z80DART \"%s\" Channel %c : Receive Sync %02x\n", m_device->tag(), 'A' + m_index, data));
+		m_sync = (data << 8) | (m_sync & 0xff);
+		break;
 	}
 }
 
@@ -1110,7 +1179,7 @@
 		data = m_rx_data_fifo[m_rx_fifo];
 
 		// load error status from the FIFO, retain overrun and parity errors
-		m_rr[1] = (m_rr[1] & (Z80DART_RR1_RX_OVERRUN_ERROR | Z80DART_RR1_PARITY_ERROR)) | m_rx_error_fifo[m_rx_fifo];
+		m_rr[1] = (m_rr[1] & (RR1_RX_OVERRUN_ERROR | RR1_PARITY_ERROR)) | m_rx_error_fifo[m_rx_fifo];
 
 		// decrease FIFO pointer
 		m_rx_fifo--;
@@ -1118,7 +1187,7 @@
 		if (m_rx_fifo < 0)
 		{
 			// no more characters available in the FIFO
-			m_rr[0] &= ~ Z80DART_RR0_RX_CHAR_AVAILABLE;
+			m_rr[0] &= ~ RR0_RX_CHAR_AVAILABLE;
 		}
 	}
 
@@ -1136,8 +1205,8 @@
 {
 	m_tx_data = data;
 
-	m_rr[0] &= ~Z80DART_RR0_TX_BUFFER_EMPTY;
-	m_rr[1] &= ~Z80DART_RR1_ALL_SENT;
+	m_rr[0] &= ~RR0_TX_BUFFER_EMPTY;
+	m_rr[1] &= ~RR1_ALL_SENT;
 
 	LOG(("Z80DART \"%s\" Channel %c : Data Register Write '%02x'\n", m_device->tag(), 'A' + m_index, data));
 }
@@ -1154,19 +1223,19 @@
 	if (m_rx_fifo == 2)
 	{
 		// receive overrun error detected
-		m_rx_error |= Z80DART_RR1_RX_OVERRUN_ERROR;
+		m_rx_error |= RR1_RX_OVERRUN_ERROR;
 
-		switch (m_wr[1] & Z80DART_WR1_RX_INT_ENABLE_MASK)
+		switch (m_wr[1] & WR1_RX_INT_MODE_MASK)
 		{
-		case Z80DART_WR1_RX_INT_FIRST:
+		case WR1_RX_INT_FIRST:
 			if (!m_rx_first)
 			{
 				take_interrupt(INT_SPECIAL);
 			}
 			break;
 
-		case Z80DART_WR1_RX_INT_ALL_PARITY:
-		case Z80DART_WR1_RX_INT_ALL:
+		case WR1_RX_INT_ALL_PARITY:
+		case WR1_RX_INT_ALL:
 			take_interrupt(INT_SPECIAL);
 			break;
 		}
@@ -1180,12 +1249,12 @@
 	m_rx_data_fifo[m_rx_fifo] = data;
 	m_rx_error_fifo[m_rx_fifo] = m_rx_error;
 
-	m_rr[0] |= Z80DART_RR0_RX_CHAR_AVAILABLE;
+	m_rr[0] |= RR0_RX_CHAR_AVAILABLE;
 
 	// receive interrupt
-	switch (m_wr[1] & Z80DART_WR1_RX_INT_ENABLE_MASK)
+	switch (m_wr[1] & WR1_RX_INT_MODE_MASK)
 	{
-	case Z80DART_WR1_RX_INT_FIRST:
+	case WR1_RX_INT_FIRST:
 		if (m_rx_first)
 		{
 			take_interrupt(INT_RECEIVE);
@@ -1194,8 +1263,8 @@
 		}
 		break;
 
-	case Z80DART_WR1_RX_INT_ALL_PARITY:
-	case Z80DART_WR1_RX_INT_ALL:
+	case WR1_RX_INT_ALL_PARITY:
+	case WR1_RX_INT_ALL:
 		take_interrupt(INT_RECEIVE);
 		break;
 	}
@@ -1214,8 +1283,8 @@
 	{
 		// enable transmitter if in auto enables mode
 		if (!state)
-			if (m_wr[3] & Z80DART_WR3_AUTO_ENABLES)
-				m_wr[5] |= Z80DART_WR5_TX_ENABLE;
+			if (m_wr[3] & WR3_AUTO_ENABLES)
+				m_wr[5] |= WR5_TX_ENABLE;
 
 		// set clear to send
 		m_cts = state;
@@ -1223,12 +1292,12 @@
 		if (!m_rx_rr0_latch)
 		{
 			if (!m_cts)
-				m_rr[0] |= Z80DART_RR0_CTS;
+				m_rr[0] |= RR0_CTS;
 			else
-				m_rr[0] &= ~Z80DART_RR0_CTS;
+				m_rr[0] &= ~RR0_CTS;
 
 			// trigger interrupt
-			if (m_wr[1] & Z80DART_WR1_EXT_INT_ENABLE)
+			if (m_wr[1] & WR1_EXT_INT_ENABLE)
 			{
 				// trigger interrupt
 				take_interrupt(INT_EXTERNAL);
@@ -1253,8 +1322,8 @@
 	{
 		// enable receiver if in auto enables mode
 		if (!state)
-			if (m_wr[3] & Z80DART_WR3_AUTO_ENABLES)
-				m_wr[3] |= Z80DART_WR3_RX_ENABLE;
+			if (m_wr[3] & WR3_AUTO_ENABLES)
+				m_wr[3] |= WR3_RX_ENABLE;
 
 		// set data carrier detect
 		m_dcd = state;
@@ -1262,11 +1331,11 @@
 		if (!m_rx_rr0_latch)
 		{
 			if (m_dcd)
-				m_rr[0] |= Z80DART_RR0_DCD;
+				m_rr[0] |= RR0_DCD;
 			else
-				m_rr[0] &= ~Z80DART_RR0_DCD;
+				m_rr[0] &= ~RR0_DCD;
 
-			if (m_wr[1] & Z80DART_WR1_EXT_INT_ENABLE)
+			if (m_wr[1] & WR1_EXT_INT_ENABLE)
 			{
 				// trigger interrupt
 				take_interrupt(INT_EXTERNAL);
@@ -1295,11 +1364,11 @@
 		if (!m_rx_rr0_latch)
 		{
 			if (m_ri)
-				m_rr[0] |= Z80DART_RR0_RI;
+				m_rr[0] |= RR0_RI;
 			else
-				m_rr[0] &= ~Z80DART_RR0_RI;
+				m_rr[0] &= ~RR0_RI;
 
-			if (m_wr[1] & Z80DART_WR1_EXT_INT_ENABLE)
+			if (m_wr[1] & WR1_EXT_INT_ENABLE)
 			{
 				// trigger interrupt
 				take_interrupt(INT_EXTERNAL);
@@ -1313,6 +1382,16 @@
 
 
 //-------------------------------------------------
+//  sync_w - sync handler
+//-------------------------------------------------
+
+void z80dart_device::dart_channel::sync_w(int state)
+{
+	LOG(("Z80DART \"%s\" Channel %c : SYNC %u\n", m_device->tag(), 'A' + m_index, state));
+}
+
+
+//-------------------------------------------------
 //  rx_w - receive clock
 //-------------------------------------------------
 
@@ -1365,16 +1444,20 @@
 WRITE8_DEVICE_HANDLER( z80dart_c_w ) { downcast<z80dart_device *>(device)->control_write(offset & 1, data); }
 WRITE8_DEVICE_HANDLER( z80dart_d_w ) { downcast<z80dart_device *>(device)->data_write(offset & 1, data); }
 
-WRITE_LINE_DEVICE_HANDLER( z80dart_ctsa_w ) { downcast<z80dart_device *>(device)->cts_w(Z80DART_CH_A, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_ctsb_w ) { downcast<z80dart_device *>(device)->cts_w(Z80DART_CH_B, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_dcda_w ) { downcast<z80dart_device *>(device)->dcd_w(Z80DART_CH_A, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_dcdb_w ) { downcast<z80dart_device *>(device)->dcd_w(Z80DART_CH_B, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_ria_w ) { downcast<z80dart_device *>(device)->ri_w(Z80DART_CH_A, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_rib_w ) { downcast<z80dart_device *>(device)->ri_w(Z80DART_CH_B, state); }
-
-WRITE_LINE_DEVICE_HANDLER( z80dart_rxca_w ) { downcast<z80dart_device *>(device)->rx_w(Z80DART_CH_A, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_txca_w ) { downcast<z80dart_device *>(device)->tx_w(Z80DART_CH_A, state); }
-WRITE_LINE_DEVICE_HANDLER( z80dart_rxtxcb_w ) { downcast<z80dart_device *>(device)->rx_w(Z80DART_CH_B, state); downcast<z80dart_device *>(device)->tx_w(Z80DART_CH_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_ctsa_w ) { downcast<z80dart_device *>(device)->cts_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_ctsb_w ) { downcast<z80dart_device *>(device)->cts_w(CHANNEL_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_dcda_w ) { downcast<z80dart_device *>(device)->dcd_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_dcdb_w ) { downcast<z80dart_device *>(device)->dcd_w(CHANNEL_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_ria_w ) { downcast<z80dart_device *>(device)->ri_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_rib_w ) { downcast<z80dart_device *>(device)->ri_w(CHANNEL_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_synca_w ) { downcast<z80dart_device *>(device)->sync_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_syncb_w ) { downcast<z80dart_device *>(device)->sync_w(CHANNEL_B, state); }
+
+WRITE_LINE_DEVICE_HANDLER( z80dart_rxca_w ) { downcast<z80dart_device *>(device)->rx_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_txca_w ) { downcast<z80dart_device *>(device)->tx_w(CHANNEL_A, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_rxcb_w ) { downcast<z80dart_device *>(device)->rx_w(CHANNEL_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_txcb_w ) { downcast<z80dart_device *>(device)->tx_w(CHANNEL_B, state); }
+WRITE_LINE_DEVICE_HANDLER( z80dart_rxtxcb_w ) { downcast<z80dart_device *>(device)->rx_w(CHANNEL_B, state); downcast<z80dart_device *>(device)->tx_w(CHANNEL_B, state); }
 
 READ8_DEVICE_HANDLER( z80dart_cd_ba_r )
 {
@@ -1407,3 +1490,8 @@
 }
 
 const device_type Z80DART = z80dart_device_config::static_alloc_device_config;
+const device_type Z80SIO0 = z80dart_device_config::static_alloc_device_config; // FIXME
+const device_type Z80SIO1 = z80dart_device_config::static_alloc_device_config; // FIXME
+const device_type Z80SIO2 = z80dart_device_config::static_alloc_device_config; // FIXME
+const device_type Z80SIO3 = z80dart_device_config::static_alloc_device_config; // FIXME
+const device_type Z80SIO4 = z80dart_device_config::static_alloc_device_config; // FIXME
diff -Nru src-old/emu/machine/z80dart.h src/emu/machine/z80dart.h
--- src-old/emu/machine/z80dart.h	2010-06-29 02:02:17.000000000 -0700
+++ src/emu/machine/z80dart.h	2010-08-22 08:29:52.000000000 -0700
@@ -16,7 +16,7 @@
                    IEO   7 |             | 34  B/_A
                    _M1   8 |             | 33  C/_D
                    Vdd   9 |             | 32  _RD
-               _W/RDYA  10 |  Z80-DART   | 31  GND
+               _W/RDYA  10 |   Z80-DART  | 31  GND
                   _RIA  11 |             | 30  _W/RDYB
                   RxDA  12 |             | 29  _RIB
                  _RxCA  13 |             | 28  RxDB
@@ -28,6 +28,72 @@
                  _DCDA  19 |             | 22  _DCDB
                    CLK  20 |_____________| 21  _RESET
 
+                            _____   _____
+                    D1   1 |*    \_/     | 40  D0
+                    D3   2 |             | 39  D2
+                    D5   3 |             | 38  D4
+                    D7   4 |             | 37  D6
+                  _INT   5 |             | 36  _IORQ
+                   IEI   6 |             | 35  _CE
+                   IEO   7 |             | 34  B/_A
+                   _M1   8 |             | 33  C/_D
+                   Vdd   9 |             | 32  _RD
+               _W/RDYA  10 |  Z80-SIO/0  | 31  GND
+                _SYNCA  11 |             | 30  _W/RDYB
+                  RxDA  12 |             | 29  _SYNCB
+                 _RxCA  13 |             | 28  RxDB
+                 _TxCA  14 |             | 27  _RxTxCB
+                  TxDA  15 |             | 26  TxDB
+                 _DTRA  16 |             | 25  _DTRB
+                 _RTSA  17 |             | 24  _RTSB
+                 _CTSA  18 |             | 23  _CTSB
+                 _DCDA  19 |             | 22  _DCDB
+                   CLK  20 |_____________| 21  _RESET
+
+                            _____   _____
+                    D1   1 |*    \_/     | 40  D0
+                    D3   2 |             | 39  D2
+                    D5   3 |             | 38  D4
+                    D7   4 |             | 37  D6
+                  _INT   5 |             | 36  _IORQ
+                   IEI   6 |             | 35  _CE
+                   IEO   7 |             | 34  B/_A
+                   _M1   8 |             | 33  C/_D
+                   Vdd   9 |             | 32  _RD
+               _W/RDYA  10 |  Z80-SIO/1  | 31  GND
+                _SYNCA  11 |             | 30  _W/RDYB
+                  RxDA  12 |             | 29  _SYNCB
+                 _RxCA  13 |             | 28  RxDB
+                 _TxCA  14 |             | 27  _RxCB
+                  TxDA  15 |             | 26  _TxCB
+                 _DTRA  16 |             | 25  TxDB
+                 _RTSA  17 |             | 24  _RTSB
+                 _CTSA  18 |             | 23  _CTSB
+                 _DCDA  19 |             | 22  _DCDB
+                   CLK  20 |_____________| 21  _RESET
+
+                            _____   _____
+                    D1   1 |*    \_/     | 40  D0
+                    D3   2 |             | 39  D2
+                    D5   3 |             | 38  D4
+                    D7   4 |             | 37  D6
+                  _INT   5 |             | 36  _IORQ
+                   IEI   6 |             | 35  _CE
+                   IEO   7 |             | 34  B/_A
+                   _M1   8 |             | 33  C/_D
+                   Vdd   9 |             | 32  _RD
+               _W/RDYA  10 |  Z80-SIO/2  | 31  GND
+                _SYNCA  11 |             | 30  _W/RDYB
+                  RxDA  12 |             | 29  _RxDB
+                 _RxCA  13 |             | 28  _RxCB
+                 _TxCA  14 |             | 27  _TxCB
+                  TxDA  15 |             | 26  TxDB
+                 _DTRA  16 |             | 25  _DTRB
+                 _RTSA  17 |             | 24  _RTSB
+                 _CTSA  18 |             | 23  _CTSB
+                 _DCDA  19 |             | 22  _DCDB
+                   CLK  20 |_____________| 21  _RESET
+
 ***************************************************************************/
 
 #ifndef __Z80DART_H__
@@ -38,23 +104,31 @@
 
 
 //**************************************************************************
-//  CONSTANTS
+//  DEVICE CONFIGURATION MACROS
 //**************************************************************************
 
-enum
-{
-	Z80DART_CH_A = 0,
-	Z80DART_CH_B
-};
+#define MDRV_Z80DART_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80DART, _clock) \
+	MDRV_DEVICE_CONFIG(_config)
 
+#define MDRV_Z80SIO0_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80SIO0, _clock) \
+	MDRV_DEVICE_CONFIG(_config)
 
+#define MDRV_Z80SIO1_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80SIO1, _clock) \
+	MDRV_DEVICE_CONFIG(_config)
 
-//**************************************************************************
-//  DEVICE CONFIGURATION MACROS
-//**************************************************************************
+#define MDRV_Z80SIO2_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80SIO2, _clock) \
+	MDRV_DEVICE_CONFIG(_config)
 
-#define MDRV_Z80DART_ADD(_tag, _clock, _config) \
-	MDRV_DEVICE_ADD(_tag, Z80DART, _clock) \
+#define MDRV_Z80SIO3_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80SIO3, _clock) \
+	MDRV_DEVICE_CONFIG(_config)
+
+#define MDRV_Z80SIO4_ADD(_tag, _clock, _config) \
+	MDRV_DEVICE_ADD(_tag, Z80SIO4, _clock) \
 	MDRV_DEVICE_CONFIG(_config)
 
 #define MDRV_Z80DART_REMOVE(_tag) \
@@ -76,19 +150,22 @@
 {
 	int m_rx_clock_a;			// channel A receive clock
 	int m_tx_clock_a;			// channel A transmit clock
-	int m_rx_tx_clock_b;		// channel B receive/transmit clock
+	int m_rx_clock_b;			// channel B receive clock
+	int m_tx_clock_b;			// channel B transmit clock
 
 	devcb_read_line		m_in_rxda_func;
 	devcb_write_line	m_out_txda_func;
 	devcb_write_line	m_out_dtra_func;
 	devcb_write_line	m_out_rtsa_func;
 	devcb_write_line	m_out_wrdya_func;
+	devcb_write_line	m_out_synca_func;
 
 	devcb_read_line		m_in_rxdb_func;
 	devcb_write_line	m_out_txdb_func;
 	devcb_write_line	m_out_dtrb_func;
 	devcb_write_line	m_out_rtsb_func;
 	devcb_write_line	m_out_wrdyb_func;
+	devcb_write_line	m_out_syncb_func;
 
 	devcb_write_line	m_out_int_func;
 };
@@ -147,6 +224,7 @@
 	void ri_w(int which, int state) { m_channel[which].ri_w(state); }
 	void rx_w(int which, int state) { m_channel[which].rx_w(state); }
 	void tx_w(int which, int state) { m_channel[which].tx_w(state); }
+	void sync_w(int which, int state) { m_channel[which].sync_w(state); }
 
 private:
 	// device-level overrides
@@ -170,7 +248,7 @@
 	public:
 		dart_channel();
 
-		void start(z80dart_device *device, int index, const devcb_read_line &in_rxd, const devcb_write_line &out_txd, const devcb_write_line &out_dtr, const devcb_write_line &out_rts, const devcb_write_line &out_wrdy);
+		void start(z80dart_device *device, int index, const devcb_read_line &in_rxd, const devcb_write_line &out_txd, const devcb_write_line &out_dtr, const devcb_write_line &out_rts, const devcb_write_line &out_wrdy, const devcb_write_line &out_sync);
 		void reset();
 
 		UINT8 control_read();
@@ -186,6 +264,7 @@
 		void ri_w(int state);
 		void rx_w(int state);
 		void tx_w(int state);
+		void sync_w(int state);
 
 	private:
 		void take_interrupt(int level);
@@ -201,9 +280,8 @@
 		void receive();
 		void transmit();
 
-		static TIMER_CALLBACK( static_rxca_tick ) { reinterpret_cast<dart_channel *>(ptr)->rx_w(1); }
-		static TIMER_CALLBACK( static_txca_tick ) { reinterpret_cast<dart_channel *>(ptr)->tx_w(1); }
-		static TIMER_CALLBACK( static_rxtxcb_tick ) { reinterpret_cast<dart_channel *>(ptr)->rx_w(1); reinterpret_cast<dart_channel *>(ptr)->tx_w(1); }
+		static TIMER_CALLBACK( static_rxc_tick ) { reinterpret_cast<dart_channel *>(ptr)->rx_w(1); }
+		static TIMER_CALLBACK( static_txc_tick ) { reinterpret_cast<dart_channel *>(ptr)->tx_w(1); }
 
 		z80dart_device *m_device;
 		int	m_index;
@@ -213,6 +291,7 @@
 		devcb_resolved_write_line	m_out_dtr_func;
 		devcb_resolved_write_line	m_out_rts_func;
 		devcb_resolved_write_line	m_out_wrdy_func;
+		devcb_resolved_write_line	m_out_sync_func;
 
 		// register state
 		UINT8 m_rr[3];				// read register
@@ -248,6 +327,9 @@
 
 		int m_dtr;					// data terminal ready
 		int m_rts;					// request to send
+
+		// synchronous state
+		UINT16 m_sync;				// sync character
 	};
 
 	// internal state
@@ -259,17 +341,18 @@
 	// timers
 	emu_timer *						m_rxca_timer;
 	emu_timer *						m_txca_timer;
-	emu_timer *						m_rxtxcb_timer;
+	emu_timer *						m_rxcb_timer;
+	emu_timer *						m_txcb_timer;
 };
 
 
 // device type definition
 extern const device_type Z80DART;
-/*
-#define Z8470   DEVICE_GET_INFO_NAME(z8470)
-#define LH0081  DEVICE_GET_INFO_NAME(lh0088)
-#define MK3881  DEVICE_GET_INFO_NAME(mk3888)
-*/
+extern const device_type Z80SIO0;
+extern const device_type Z80SIO1;
+extern const device_type Z80SIO2;
+extern const device_type Z80SIO3;
+extern const device_type Z80SIO4;
 
 
 
@@ -295,6 +378,8 @@
 // serial clocks
 WRITE_LINE_DEVICE_HANDLER( z80dart_rxca_w );
 WRITE_LINE_DEVICE_HANDLER( z80dart_txca_w );
+WRITE_LINE_DEVICE_HANDLER( z80dart_rxcb_w );
+WRITE_LINE_DEVICE_HANDLER( z80dart_txcb_w );
 WRITE_LINE_DEVICE_HANDLER( z80dart_rxtxcb_w );
 
 // ring indicator
@@ -309,5 +394,8 @@
 WRITE_LINE_DEVICE_HANDLER( z80dart_ctsa_w );
 WRITE_LINE_DEVICE_HANDLER( z80dart_ctsb_w );
 
+// sync
+WRITE_LINE_DEVICE_HANDLER( z80dart_synca_w );
+WRITE_LINE_DEVICE_HANDLER( z80dart_syncb_w );
 
 #endif
diff -Nru src-old/emu/machine.c src/emu/machine.c
--- src-old/emu/machine.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/machine.c	2010-08-21 16:13:26.000000000 -0700
@@ -203,6 +203,8 @@
 	// allocate the driver data (after devices)
 	if (m_config.m_driver_data_alloc != NULL)
 		m_driver_data = (*m_config.m_driver_data_alloc)(*this);
+	else
+		m_driver_data = auto_alloc(this, driver_data_t(*this));
 
 	// find devices
 	primary_screen = screen_first(*this);
@@ -243,7 +245,7 @@
 	{
 		cpu_device *cpu = downcast<cpu_device *>(&executing->device());
 		if (cpu != NULL)
-			m_context.printf("'%s' (%s)", cpu->tag(), core_i64_hex_format(cpu->pc(), cpu->space(AS_PROGRAM)->logaddrchars));
+			m_context.printf("'%s' (%s)", cpu->tag(), core_i64_hex_format(cpu->pc(), cpu->space(AS_PROGRAM)->logaddrchars()));
 		else
 			m_context.printf("'%s'", cpu->tag());
 	}
@@ -267,6 +269,8 @@
 	output_init(this);
 	state_init(this);
 	state_save_allow_registration(this, true);
+	state_save_register_presave(this, pre_save_static, NULL);
+	state_save_register_postload(this, post_load_static, NULL);
 	palette_init(this);
 	render_init(this);
 	ui_init(this);
@@ -338,12 +342,9 @@
 		debugger_init(this);
 
 	// call the driver's _START callbacks
-	if (m_config.m_machine_start != NULL)
-		(*m_config.m_machine_start)(this);
-	if (m_config.m_sound_start != NULL)
-		(*m_config.m_sound_start)(this);
-	if (m_config.m_video_start != NULL)
-		(*m_config.m_video_start)(this);
+	m_driver_data->machine_start();
+	m_driver_data->sound_start();
+	m_driver_data->video_start();
 
 	// if we're coming in with a savegame request, process it now
 	const char *savegame = options_get_string(&m_options, OPTION_STATE);
@@ -403,7 +404,7 @@
 		m_hard_reset_pending = false;
 		while ((!m_hard_reset_pending && !m_exit_pending) || m_saveload_schedule != SLS_NONE)
 		{
-			profiler_mark_start(PROFILER_EXTRA);
+			g_profiler.start(PROFILER_EXTRA);
 
 			// execute CPUs if not paused
 			if (!m_paused)
@@ -417,7 +418,7 @@
 			if (m_saveload_schedule != SLS_NONE)
 				handle_saveload();
 
-			profiler_mark_end();
+			g_profiler.stop();
 		}
 
 		// and out via the exit phase
@@ -713,7 +714,7 @@
 	// process only if there is a target
 	if (m_logerror_list != NULL)
 	{
-		profiler_mark_start(PROFILER_LOGERROR);
+		g_profiler.start(PROFILER_LOGERROR);
 
 		// dump to the buffer
 		vsnprintf(giant_string_buffer, ARRAY_LENGTH(giant_string_buffer), format, args);
@@ -722,7 +723,7 @@
 		for (logerror_callback_item *cb = m_logerror_list; cb != NULL; cb = cb->m_next)
 			(*cb->m_func)(*this, giant_string_buffer);
 
-		profiler_mark_end();
+		g_profiler.stop();
 	}
 }
 
@@ -789,7 +790,7 @@
 	file_error filerr = FILERR_NONE;
 
 	// if no name, bail
-	if (m_saveload_pending_file.len() == 0)
+	if (!m_saveload_pending_file)
 		goto cancel;
 
 	// if there are anonymous timers, we can't save just yet, and we can't load yet either
@@ -863,6 +864,28 @@
 
 
 //-------------------------------------------------
+//  pre_save_static - callback to prepare for
+//  state saving
+//-------------------------------------------------
+
+STATE_PRESAVE( running_machine::pre_save_static )
+{
+	machine->m_driver_data->pre_save();
+}
+
+
+//-------------------------------------------------
+//  post_load_static - callback to update after
+//  static loading
+//-------------------------------------------------
+
+STATE_POSTLOAD( running_machine::post_load_static )
+{
+	machine->m_driver_data->post_load();
+}
+
+
+//-------------------------------------------------
 //  soft_reset - actually perform a soft-reset
 //  of the system
 //-------------------------------------------------
@@ -880,12 +903,9 @@
 	call_notifiers(MACHINE_NOTIFY_RESET);
 
 	// run the driver's reset callbacks
-	if (m_config.m_machine_reset != NULL)
-		(*m_config.m_machine_reset)(this);
-	if (m_config.m_sound_reset != NULL)
-		(*m_config.m_sound_reset)(this);
-	if (m_config.m_video_reset != NULL)
-		(*m_config.m_video_reset)(this);
+	m_driver_data->machine_reset();
+	m_driver_data->sound_reset();
+	m_driver_data->video_reset();
 
 	// now we're running
 	m_current_phase = MACHINE_PHASE_RUNNING;
@@ -988,6 +1008,135 @@
 }
 
 
+//-------------------------------------------------
+//  machine_start - default implementation which
+//  calls to the legacy machine_start function
+//-------------------------------------------------
+
+void driver_data_t::machine_start()
+{
+	if (m_machine.m_config.m_machine_start != NULL)
+		(*m_machine.m_config.m_machine_start)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  machine_reset - default implementation which
+//  calls to the legacy machine_reset function
+//-------------------------------------------------
+
+void driver_data_t::machine_reset()
+{
+	if (m_machine.m_config.m_machine_reset != NULL)
+		(*m_machine.m_config.m_machine_reset)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  sound_start - default implementation which
+//  calls to the legacy sound_start function
+//-------------------------------------------------
+
+void driver_data_t::sound_start()
+{
+	if (m_machine.m_config.m_sound_start != NULL)
+		(*m_machine.m_config.m_sound_start)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  sound_reset - default implementation which
+//  calls to the legacy sound_reset function
+//-------------------------------------------------
+
+void driver_data_t::sound_reset()
+{
+	if (m_machine.m_config.m_sound_reset != NULL)
+		(*m_machine.m_config.m_sound_reset)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  palette_init - default implementation which
+//  calls to the legacy palette_init function
+//-------------------------------------------------
+
+void driver_data_t::palette_init(const UINT8 *color_prom)
+{
+	if (m_machine.m_config.m_init_palette != NULL)
+		(*m_machine.m_config.m_init_palette)(&m_machine, color_prom);
+}
+
+
+//-------------------------------------------------
+//  video_start - default implementation which
+//  calls to the legacy video_start function
+//-------------------------------------------------
+
+void driver_data_t::video_start()
+{
+	if (m_machine.m_config.m_video_start != NULL)
+		(*m_machine.m_config.m_video_start)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  video_reset - default implementation which
+//  calls to the legacy video_reset function
+//-------------------------------------------------
+
+void driver_data_t::video_reset()
+{
+	if (m_machine.m_config.m_video_reset != NULL)
+		(*m_machine.m_config.m_video_reset)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  video_update - default implementation which
+//  calls to the legacy video_update function
+//-------------------------------------------------
+
+bool driver_data_t::video_update(screen_device &screen, bitmap_t &bitmap, const rectangle &cliprect)
+{
+	if (m_machine.m_config.m_video_update != NULL)
+		return (*m_machine.m_config.m_video_update)(&screen, &bitmap, &cliprect);
+	return 0;
+}
+
+
+//-------------------------------------------------
+//  video_eof - default implementation which
+//  calls to the legacy video_eof function
+//-------------------------------------------------
+
+void driver_data_t::video_eof()
+{
+	if (m_machine.m_config.m_video_eof != NULL)
+		(*m_machine.m_config.m_video_eof)(&m_machine);
+}
+
+
+//-------------------------------------------------
+//  pre_save - default implementation which
+//  does nothing
+//-------------------------------------------------
+
+void driver_data_t::pre_save()
+{
+}
+
+
+//-------------------------------------------------
+//  post_load - default implementation which
+//  does nothing
+//-------------------------------------------------
+
+void driver_data_t::post_load()
+{
+}
+
+
 
 //**************************************************************************
 //  SYSTEM TIME
diff -Nru src-old/emu/machine.h src/emu/machine.h
--- src-old/emu/machine.h	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/machine.h	2010-08-30 08:20:58.000000000 -0700
@@ -158,12 +158,29 @@
 
 
 // base class for all driver data structures
-class driver_data_t
+class driver_data_t : public bindable_object
 {
+	friend class running_machine;
+
 public:
 	driver_data_t(running_machine &machine);
 	virtual ~driver_data_t();
 
+	virtual void machine_start();
+	virtual void machine_reset();
+
+	virtual void sound_start();
+	virtual void sound_reset();
+
+	virtual void palette_init(const UINT8 *color_prom);
+	virtual void video_start();
+	virtual void video_reset();
+	virtual bool video_update(screen_device &screen, bitmap_t &bitmap, const rectangle &cliprect);
+	virtual void video_eof();
+
+	virtual void pre_save();
+	virtual void post_load();
+
 	running_machine &	m_machine;
 };
 
@@ -271,7 +288,7 @@
 
 
 // description of the currently-running machine
-class running_machine
+class running_machine : public bindable_object
 {
 	DISABLE_COPYING(running_machine);
 
@@ -298,7 +315,7 @@
 	machine_phase phase() const { return m_current_phase; }
 	bool paused() const { return m_paused || (m_current_phase != MACHINE_PHASE_RUNNING); }
 	bool scheduled_event_pending() const { return m_exit_pending || m_hard_reset_pending; }
-	bool save_or_load_pending() const { return (m_saveload_pending_file.len() != 0); }
+	bool save_or_load_pending() const { return (m_saveload_pending_file); }
 	bool exit_pending() const { return m_exit_pending; }
 	bool new_driver_pending() const { return (m_new_driver_pending != NULL); }
 	const char *new_driver_name() const { return m_new_driver_pending->name; }
@@ -346,6 +363,7 @@
 
 	// CPU information
 	cpu_device *			firstcpu;			// first CPU (allows for quick iteration via typenext)
+	address_space *			m_nonspecific_space;// a dummy address_space used for legacy compatibility
 
 	// game-related information
 	const game_driver *		gamedrv;			// points to the definition of the game machine
@@ -405,6 +423,8 @@
 	void set_saveload_filename(const char *filename);
 	void fill_systime(system_time &systime, time_t t);
 	void handle_saveload();
+	static STATE_PRESAVE( pre_save_static );
+	static STATE_POSTLOAD( post_load_static );
 
 	static TIMER_CALLBACK( static_soft_reset );
 	void soft_reset();
diff -Nru src-old/emu/mconfig.c src/emu/mconfig.c
--- src-old/emu/mconfig.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/mconfig.c	2010-08-30 08:20:58.000000000 -0700
@@ -49,7 +49,7 @@
 //  machine_config - constructor
 //-------------------------------------------------
 
-machine_config::machine_config(const machine_config_token *tokens)
+machine_config::machine_config(machine_config_constructor constructor)
 	: m_driver_data_alloc(NULL),
 	  m_minimum_quantum(attotime_zero),
 	  m_perfect_cpu_quantum(NULL),
@@ -72,8 +72,25 @@
 	  m_sound_reset(NULL),
 	  m_parse_level(0)
 {
-	// parse tokens into the config
-	detokenize(tokens);
+	// construct the config
+	(*constructor)(*this, NULL);
+
+	// process any device-specific machine configurations
+	for (device_config *devconfig = m_devicelist.first(); devconfig != NULL; devconfig = devconfig->next())
+		if (!devconfig->m_config_complete)
+		{
+			machine_config_constructor additions = devconfig->machine_config_additions();
+			if (additions != NULL)
+				(*additions)(*this, devconfig);
+		}
+
+	// then notify all devices that their configuration is complete
+	for (device_config *devconfig = m_devicelist.first(); devconfig != NULL; devconfig = devconfig->next())
+		if (!devconfig->m_config_complete)
+		{
+			devconfig->config_complete();
+			devconfig->m_config_complete = true;
+		}
 }
 
 
@@ -87,219 +104,56 @@
 
 
 //-------------------------------------------------
-//  detokenize - detokenize a machine config
+//  device_add - configuration helper to add a
+//  new device
 //-------------------------------------------------
 
-void machine_config::detokenize(const machine_config_token *tokens, const device_config *owner)
+device_config *machine_config::device_add(device_config *owner, const char *tag, device_type type, UINT32 clock)
 {
-	device_config *device = NULL;
 	astring tempstring;
+	const char *fulltag = owner->subtag(tempstring, tag);
+	return m_devicelist.append(fulltag, (*type)(*this, fulltag, owner, clock));
+}
 
-	// increase the parse level
-	m_parse_level++;
 
-	// loop over tokens until we hit the end
-	UINT32 entrytype = MCONFIG_TOKEN_INVALID;
-	while (entrytype != MCONFIG_TOKEN_END)
-	{
-		device_type devtype;
-		const char *tag;
-		UINT64 data64;
-		UINT32 clock;
-
-		// unpack the token from the first entry
-		TOKEN_GET_UINT32_UNPACK1(tokens, entrytype, 8);
-		switch (entrytype)
-		{
-			// end
-			case MCONFIG_TOKEN_END:
-				break;
-
-			// including
-			case MCONFIG_TOKEN_INCLUDE:
-				detokenize(TOKEN_GET_PTR(tokens, tokenptr), owner);
-				break;
-
-			// device management
-			case MCONFIG_TOKEN_DEVICE_ADD:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, clock, 32);
-				devtype = TOKEN_GET_PTR(tokens, devtype);
-				tag = owner->subtag(tempstring, TOKEN_GET_STRING(tokens));
-				device = m_devicelist.append(tag, (*devtype)(*this, tag, owner, clock));
-				break;
-
-			case MCONFIG_TOKEN_DEVICE_REPLACE:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT64_UNPACK2(tokens, entrytype, 8, clock, 32);
-				devtype = TOKEN_GET_PTR(tokens, devtype);
-				tag = owner->subtag(tempstring, TOKEN_GET_STRING(tokens));
-				device = m_devicelist.replace(tag, (*devtype)(*this, tag, owner, clock));
-				break;
-
-			case MCONFIG_TOKEN_DEVICE_REMOVE:
-				tag = TOKEN_GET_STRING(tokens);
-				m_devicelist.remove(owner->subtag(tempstring, tag));
-				device = NULL;
-				break;
-
-			case MCONFIG_TOKEN_DEVICE_MODIFY:
-				tag = TOKEN_GET_STRING(tokens);
-				device = m_devicelist.find(owner->subtag(tempstring, tag));
-				if (device == NULL)
-					fatalerror("Unable to find device: tag=%s\n", tempstring.cstr());
-				break;
-
-			case MCONFIG_TOKEN_DEVICE_CLOCK:
-			case MCONFIG_TOKEN_DEVICE_CONFIG:
-			case MCONFIG_TOKEN_DEVICE_INLINE_DATA16:
-			case MCONFIG_TOKEN_DEVICE_INLINE_DATA32:
-			case MCONFIG_TOKEN_DEVICE_INLINE_DATA64:
-
-			case MCONFIG_TOKEN_DIEXEC_DISABLE:
-			case MCONFIG_TOKEN_DIEXEC_VBLANK_INT:
-			case MCONFIG_TOKEN_DIEXEC_PERIODIC_INT:
-
-			case MCONFIG_TOKEN_DIMEMORY_MAP:
-
-			case MCONFIG_TOKEN_DISOUND_ROUTE:
-			case MCONFIG_TOKEN_DISOUND_RESET:
-
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_1:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_2:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_3:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_4:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_5:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_6:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_7:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_8:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_9:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_DATA32:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_DATA64:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_DATAFP32:
-			case MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_FREE:
-				assert(device != NULL);
-				device->process_token(entrytype, tokens);
-				break;
-
-
-			// core parameters
-			case MCONFIG_TOKEN_DRIVER_DATA:
-				m_driver_data_alloc = TOKEN_GET_PTR(tokens, driver_data_alloc);
-				break;
-
-			case MCONFIG_TOKEN_QUANTUM_TIME:
-				TOKEN_EXTRACT_UINT64(tokens, data64);
-				m_minimum_quantum = UINT64_ATTOTIME_TO_ATTOTIME(data64);
-				break;
-
-			case MCONFIG_TOKEN_QUANTUM_PERFECT_CPU:
-				m_perfect_cpu_quantum = TOKEN_GET_STRING(tokens);
-				break;
-
-			case MCONFIG_TOKEN_WATCHDOG_VBLANK:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, m_watchdog_vblank_count, 24);
-				break;
-
-			case MCONFIG_TOKEN_WATCHDOG_TIME:
-				TOKEN_EXTRACT_UINT64(tokens, data64);
-				m_watchdog_time = UINT64_ATTOTIME_TO_ATTOTIME(data64);
-				break;
-
-			// core functions
-			case MCONFIG_TOKEN_MACHINE_START:
-				m_machine_start = TOKEN_GET_PTR(tokens, machine_start);
-				break;
-
-			case MCONFIG_TOKEN_MACHINE_RESET:
-				m_machine_reset = TOKEN_GET_PTR(tokens, machine_reset);
-				break;
-
-			case MCONFIG_TOKEN_NVRAM_HANDLER:
-				m_nvram_handler = TOKEN_GET_PTR(tokens, nvram_handler);
-				break;
-
-			case MCONFIG_TOKEN_MEMCARD_HANDLER:
-				m_memcard_handler = TOKEN_GET_PTR(tokens, memcard_handler);
-				break;
-
-			// core video parameters
-			case MCONFIG_TOKEN_VIDEO_ATTRIBUTES:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, m_video_attributes, 24);
-				break;
-
-			case MCONFIG_TOKEN_GFXDECODE:
-				m_gfxdecodeinfo = TOKEN_GET_PTR(tokens, gfxdecode);
-				break;
-
-			case MCONFIG_TOKEN_PALETTE_LENGTH:
-				TOKEN_UNGET_UINT32(tokens);
-				TOKEN_GET_UINT32_UNPACK2(tokens, entrytype, 8, m_total_colors, 24);
-				break;
-
-			case MCONFIG_TOKEN_DEFAULT_LAYOUT:
-				m_default_layout = TOKEN_GET_STRING(tokens);
-				break;
-
-			// core video functions
-			case MCONFIG_TOKEN_PALETTE_INIT:
-				m_init_palette = TOKEN_GET_PTR(tokens, palette_init);
-				break;
-
-			case MCONFIG_TOKEN_VIDEO_START:
-				m_video_start = TOKEN_GET_PTR(tokens, video_start);
-				break;
-
-			case MCONFIG_TOKEN_VIDEO_RESET:
-				m_video_reset = TOKEN_GET_PTR(tokens, video_reset);
-				break;
-
-			case MCONFIG_TOKEN_VIDEO_EOF:
-				m_video_eof = TOKEN_GET_PTR(tokens, video_eof);
-				break;
-
-			case MCONFIG_TOKEN_VIDEO_UPDATE:
-				m_video_update = TOKEN_GET_PTR(tokens, video_update);
-				break;
-
-			// core sound functions
-			case MCONFIG_TOKEN_SOUND_START:
-				m_sound_start = TOKEN_GET_PTR(tokens, sound_start);
-				break;
-
-			case MCONFIG_TOKEN_SOUND_RESET:
-				m_sound_reset = TOKEN_GET_PTR(tokens, sound_reset);
-				break;
-
-			default:
-				fatalerror("Invalid token %d in machine config\n", entrytype);
-				break;
-		}
-	}
+//-------------------------------------------------
+//  device_replace - configuration helper to
+//  replace one device with a new device
+//-------------------------------------------------
+
+device_config *machine_config::device_replace(device_config *owner, const char *tag, device_type type, UINT32 clock)
+{
+	astring tempstring;
+	const char *fulltag = owner->subtag(tempstring, tag);
+	return m_devicelist.replace(fulltag, (*type)(*this, fulltag, owner, clock));
+}
+
+
+//-------------------------------------------------
+//  device_remove - configuration helper to
+//  remove a device
+//-------------------------------------------------
+
+device_config *machine_config::device_remove(device_config *owner, const char *tag)
+{
+	astring tempstring;
+	const char *fulltag = owner->subtag(tempstring, tag);
+	m_devicelist.remove(fulltag);
+	return NULL;
+}
 
-	// if we started at parse level 0 (and are thus at level 1), do post-processing
-	if (m_parse_level == 1)
-	{
-		// process any device-specific machine configurations
-		for (const device_config *devconfig = m_devicelist.first(); devconfig != NULL; devconfig = devconfig->next())
-			if (!devconfig->m_config_complete)
-			{
-				tokens = devconfig->machine_config_tokens();
-				if (tokens != NULL)
-					detokenize(tokens, devconfig);
-			}
-
-		// then notify all devices that their configuration is complete
-		for (device_config *devconfig = m_devicelist.first(); devconfig != NULL; devconfig = devconfig->next())
-			if (!devconfig->m_config_complete)
-			{
-				devconfig->config_complete();
-				devconfig->m_config_complete = true;
-			}
-	}
 
-	// bump down the parse level
-	m_parse_level--;
+//-------------------------------------------------
+//  device_find - configuration helper to
+//  locate a device
+//-------------------------------------------------
+
+device_config *machine_config::device_find(device_config *owner, const char *tag)
+{
+	astring tempstring;
+	const char *fulltag = owner->subtag(tempstring, tag);
+	device_config *device = m_devicelist.find(fulltag);
+	if (device == NULL)
+		throw emu_fatalerror("Unable to find device: tag=%s\n", fulltag);
+	return device;
 }
diff -Nru src-old/emu/mconfig.h src/emu/mconfig.h
--- src-old/emu/mconfig.h	2010-08-04 08:37:08.000000000 -0700
+++ src/emu/mconfig.h	2010-08-26 08:21:19.000000000 -0700
@@ -47,6 +47,42 @@
 #define __MCONFIG_H__
 
 
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
+
+// by convention, tags should all lowercase and between 2-15 characters
+#define MIN_TAG_LENGTH			2
+#define MAX_TAG_LENGTH			15
+
+
+
+// ----- flags for video_attributes -----
+
+// should VIDEO_UPDATE by called at the start of VBLANK or at the end?
+#define	VIDEO_UPDATE_BEFORE_VBLANK		0x0000
+#define	VIDEO_UPDATE_AFTER_VBLANK		0x0004
+
+// indicates VIDEO_UPDATE will add container bits its
+#define VIDEO_SELF_RENDER				0x0008
+
+// automatically extend the palette creating a darker copy for shadows
+#define VIDEO_HAS_SHADOWS				0x0010
+
+// automatically extend the palette creating a brighter copy for highlights
+#define VIDEO_HAS_HIGHLIGHTS			0x0020
+
+// Mish 181099:  See comments in video/generic.c for details
+#define VIDEO_BUFFERS_SPRITERAM			0x0040
+
+// force VIDEO_UPDATE to be called even for skipped frames
+#define VIDEO_ALWAYS_UPDATE				0x0080
+
+// calls VIDEO_UPDATE for every visible scanline, even for skipped frames
+#define VIDEO_UPDATE_SCANLINE			0x0100
+
+
+
 #define NVRAM_HANDLER_NAME(name)	nvram_handler_##name
 #define NVRAM_HANDLER(name)			void NVRAM_HANDLER_NAME(name)(running_machine *machine, mame_file *file, int read_or_write)
 #define NVRAM_HANDLER_CALL(name)	NVRAM_HANDLER_NAME(name)(machine, file, read_or_write)
@@ -106,8 +142,18 @@
 #define video_update_0				NULL
 
 
+
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// forward references
+struct gfx_decode_entry;
 class driver_data_t;
 
+
+
+// various callback functions
 typedef void   (*nvram_handler_func)(running_machine *machine, mame_file *file, int read_or_write);
 typedef void   (*memcard_handler_func)(running_machine *machine, mame_file *file, int action);
 typedef void   (*machine_start_func)(running_machine *machine);
@@ -118,128 +164,14 @@
 typedef void   (*video_reset_func)(running_machine *machine);
 typedef void   (*palette_init_func)(running_machine *machine, const UINT8 *color_prom);
 typedef void   (*video_eof_func)(running_machine *machine);
-typedef UINT32 (*video_update_func)(device_t *screen, bitmap_t *bitmap, const rectangle *cliprect);
+typedef UINT32 (*video_update_func)(screen_device *screen, bitmap_t *bitmap, const rectangle *cliprect);
 typedef driver_data_t *(*driver_data_alloc_func)(running_machine &machine);
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-// by convention, tags should all lowercase and between 2-15 characters
-#define MIN_TAG_LENGTH			2
-#define MAX_TAG_LENGTH			15
-
-
-// token types
-enum
-{
-	MCONFIG_TOKEN_INVALID,
-	MCONFIG_TOKEN_END,
-	MCONFIG_TOKEN_INCLUDE,
-
-	MCONFIG_TOKEN_DRIVER_DATA,
-	MCONFIG_TOKEN_QUANTUM_TIME,
-	MCONFIG_TOKEN_QUANTUM_PERFECT_CPU,
-	MCONFIG_TOKEN_WATCHDOG_VBLANK,
-	MCONFIG_TOKEN_WATCHDOG_TIME,
-
-	MCONFIG_TOKEN_MACHINE_START,
-	MCONFIG_TOKEN_MACHINE_RESET,
-	MCONFIG_TOKEN_NVRAM_HANDLER,
-	MCONFIG_TOKEN_MEMCARD_HANDLER,
-
-	MCONFIG_TOKEN_VIDEO_ATTRIBUTES,
-	MCONFIG_TOKEN_GFXDECODE,
-	MCONFIG_TOKEN_PALETTE_LENGTH,
-	MCONFIG_TOKEN_DEFAULT_LAYOUT,
-
-	MCONFIG_TOKEN_PALETTE_INIT,
-	MCONFIG_TOKEN_VIDEO_START,
-	MCONFIG_TOKEN_VIDEO_RESET,
-	MCONFIG_TOKEN_VIDEO_EOF,
-	MCONFIG_TOKEN_VIDEO_UPDATE,
-
-	MCONFIG_TOKEN_SOUND_START,
-	MCONFIG_TOKEN_SOUND_RESET,
-
-	MCONFIG_TOKEN_DEVICE_ADD,
-	MCONFIG_TOKEN_DEVICE_REPLACE,
-	MCONFIG_TOKEN_DEVICE_REMOVE,
-	MCONFIG_TOKEN_DEVICE_MODIFY,
-
-	// device-specific tokens
-	MCONFIG_TOKEN_DEVICE_CLOCK,
-	MCONFIG_TOKEN_DEVICE_CONFIG,
-	MCONFIG_TOKEN_DEVICE_INLINE_DATA16,
-	MCONFIG_TOKEN_DEVICE_INLINE_DATA32,
-	MCONFIG_TOKEN_DEVICE_INLINE_DATA64,
-
-	// execute interface-specific tokens
-	MCONFIG_TOKEN_DIEXEC_DISABLE,
-	MCONFIG_TOKEN_DIEXEC_VBLANK_INT,
-	MCONFIG_TOKEN_DIEXEC_PERIODIC_INT,
-
-	// memory interface-specific tokens
-	MCONFIG_TOKEN_DIMEMORY_MAP,
-
-	// sound interface-specific tokens
-	MCONFIG_TOKEN_DISOUND_ROUTE,
-	MCONFIG_TOKEN_DISOUND_RESET,
-
-	// legacy custom tokens
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_1,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_2,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_3,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_4,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_5,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_6,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_7,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_8,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_9,
-
-	MCONFIG_TOKEN_DEVICE_CONFIG_DATA32,
-	MCONFIG_TOKEN_DEVICE_CONFIG_DATA64,
-	MCONFIG_TOKEN_DEVICE_CONFIG_DATAFP32,
-	MCONFIG_TOKEN_DEVICE_CONFIG_CUSTOM_FREE,
-};
-
-
-// ----- flags for video_attributes -----
-
-// should VIDEO_UPDATE by called at the start of VBLANK or at the end?
-#define	VIDEO_UPDATE_BEFORE_VBLANK		0x0000
-#define	VIDEO_UPDATE_AFTER_VBLANK		0x0004
-
-// indicates VIDEO_UPDATE will add container bits its
-#define VIDEO_SELF_RENDER				0x0008
-
-// automatically extend the palette creating a darker copy for shadows
-#define VIDEO_HAS_SHADOWS				0x0010
-
-// automatically extend the palette creating a brighter copy for highlights
-#define VIDEO_HAS_HIGHLIGHTS			0x0020
-
-// Mish 181099:  See comments in video/generic.c for details
-#define VIDEO_BUFFERS_SPRITERAM			0x0040
-
-// force VIDEO_UPDATE to be called even for skipped frames
-#define VIDEO_ALWAYS_UPDATE				0x0080
-
-// calls VIDEO_UPDATE for every visible scanline, even for skipped frames
-#define VIDEO_UPDATE_SCANLINE			0x0100
-
-
-
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
-
-// forward references
-struct gfx_decode_entry;
-
+// ======================> address_map_entry
 
+// machine configuration definition
 class machine_config
 {
 	DISABLE_COPYING(machine_config);
@@ -247,11 +179,9 @@
 	friend class running_machine;
 
 public:
-	machine_config(const machine_config_token *tokens);
+	machine_config(machine_config_constructor constructor);
 	~machine_config();
 
-	void detokenize(const machine_config_token *tokens, const device_config *owner = NULL);
-
 	driver_data_alloc_func	m_driver_data_alloc;		// allocator for driver data
 
 	attotime				m_minimum_quantum;			// minimum scheduling quantum
@@ -281,176 +211,129 @@
 
 	device_config_list		m_devicelist;				// list of device configs
 
+	// helpers during configuration; not for general use
+	device_config *device_add(device_config *owner, const char *tag, device_type type, UINT32 clock);
+	device_config *device_replace(device_config *owner, const char *tag, device_type type, UINT32 clock);
+	device_config *device_remove(device_config *owner, const char *tag);
+	device_config *device_find(device_config *owner, const char *tag);
+
 private:
 	int						m_parse_level;				// nested parsing level
 };
 
 
 
-/***************************************************************************
-    MACROS FOR BUILDING MACHINE DRIVERS
-***************************************************************************/
-
-// this type is used to encode machine configuration definitions
-union machine_config_token
-{
-	TOKEN_COMMON_FIELDS
-	const machine_config_token *tokenptr;
-	const gfx_decode_entry *gfxdecode;
-	address_map_constructor addrmap;
-	device_type devtype;
-	nvram_handler_func nvram_handler;
-	memcard_handler_func memcard_handler;
-	machine_start_func machine_start;
-	machine_reset_func machine_reset;
-	sound_start_func sound_start;
-	sound_reset_func sound_reset;
-	video_start_func video_start;
-	video_reset_func video_reset;
-	palette_init_func palette_init;
-	video_eof_func video_eof;
-	video_update_func video_update;
-	device_interrupt_func cpu_interrupt;
-	driver_data_alloc_func driver_data_alloc;
-};
-
-
-// helper macro for returning the size of a field within a struct; similar to offsetof()
-#define structsizeof(_struct, _field) sizeof(((_struct *)NULL)->_field)
-
-#define DEVCONFIG_OFFSETOF(_class, _member)	\
-	((FPTR)&static_cast<_class *>(reinterpret_cast<device_config *>(1000000))->_member - 1000000)
-
-#define DEVCONFIG_SIZEOF(_class, _member)	\
-	sizeof(reinterpret_cast<_class *>(NULL)->_member)
-
+//**************************************************************************
+//  MACHINE CONFIG MACROS
+//**************************************************************************
 
 // start/end tags for the machine driver
-#define MACHINE_DRIVER_NAME(_name) \
-	machine_config_##_name
+#define MACHINE_DRIVER_NAME(_name) construct_machine_config_##_name
 
 #define MACHINE_DRIVER_START(_name) \
-	const machine_config_token MACHINE_DRIVER_NAME(_name)[] = {
+void MACHINE_DRIVER_NAME(_name)(machine_config &config, device_config *owner) \
+{ \
+	device_config *device = NULL; \
+	const char *tag; \
+	astring tempstring; \
+	(void)device; \
+	(void)tag; \
 
 #define MACHINE_DRIVER_END \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_END, 8) };
+}
 
 // use this to declare external references to a machine driver
 #define MACHINE_DRIVER_EXTERN(_name) \
-	extern const machine_config_token MACHINE_DRIVER_NAME(_name)[]
+	extern void MACHINE_DRIVER_NAME(_name)(machine_config &config, device_config *owner)
 
 
 // importing data from other machine drivers
 #define MDRV_IMPORT_FROM(_name) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_INCLUDE, 8), \
-	TOKEN_PTR(tokenptr, MACHINE_DRIVER_NAME(_name)),
+	MACHINE_DRIVER_NAME(_name)(config, owner);
 
 
 // core parameters
 #define MDRV_DRIVER_DATA(_class) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DRIVER_DATA, 8), \
-	TOKEN_PTR(m_driver_data_alloc, _class::alloc),
+	config.m_driver_data_alloc = &_class::alloc; \
 
 #define MDRV_QUANTUM_TIME(_time) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_QUANTUM_TIME, 8), \
-	TOKEN_UINT64(UINT64_ATTOTIME_IN_##_time),
+	config.m_minimum_quantum = ATTOTIME_IN_##_time; \
 
 #define MDRV_QUANTUM_PERFECT_CPU(_cputag) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_QUANTUM_PERFECT_CPU, 8), \
-	TOKEN_STRING(_cputag),
+	config.m_perfect_cpu_quantum = _cputag; \
 
 #define MDRV_WATCHDOG_VBLANK_INIT(_count) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_WATCHDOG_VBLANK, 8, _count, 24),
+	config.m_watchdog_vblank_count = _count; \
 
 #define MDRV_WATCHDOG_TIME_INIT(_time) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_WATCHDOG_TIME, 8), \
-	TOKEN_UINT64(UINT64_ATTOTIME_IN_##_time),
+	config.m_watchdog_time = ATTOTIME_IN_##_time; \
 
 
 // core functions
 #define MDRV_MACHINE_START(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_MACHINE_START, 8), \
-	TOKEN_PTR(machine_start, MACHINE_START_NAME(_func)),
+	config.m_machine_start = MACHINE_START_NAME(_func); \
 
 #define MDRV_MACHINE_RESET(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_MACHINE_RESET, 8), \
-	TOKEN_PTR(machine_reset, MACHINE_RESET_NAME(_func)),
+	config.m_machine_reset = MACHINE_RESET_NAME(_func); \
 
 #define MDRV_NVRAM_HANDLER(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_NVRAM_HANDLER, 8), \
-	TOKEN_PTR(nvram_handler, NVRAM_HANDLER_NAME(_func)),
+	config.m_nvram_handler = NVRAM_HANDLER_NAME(_func); \
 
 #define MDRV_MEMCARD_HANDLER(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_MEMCARD_HANDLER, 8), \
-	TOKEN_PTR(memcard_handler, MEMCARD_HANDLER_NAME(_func)),
+	config.m_memcard_handler = MEMCARD_HANDLER_NAME(_func); \
 
 
 // core video parameters
 #define MDRV_VIDEO_ATTRIBUTES(_flags) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_VIDEO_ATTRIBUTES, 8, _flags, 24),
+	config.m_video_attributes = _flags; \
 
 #define MDRV_GFXDECODE(_gfx) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_GFXDECODE, 8), \
-	TOKEN_PTR(gfxdecode, GFXDECODE_NAME(_gfx)),
+	config.m_gfxdecodeinfo = GFXDECODE_NAME(_gfx); \
 
 #define MDRV_PALETTE_LENGTH(_length) \
-	TOKEN_UINT32_PACK2(MCONFIG_TOKEN_PALETTE_LENGTH, 8, _length, 24),
+	config.m_total_colors = _length; \
 
 #define MDRV_DEFAULT_LAYOUT(_layout) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DEFAULT_LAYOUT, 8), \
-	TOKEN_STRING(&(_layout)[0]),
+	config.m_default_layout = &(_layout)[0]; \
 
 
 // core video functions
 #define MDRV_PALETTE_INIT(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_PALETTE_INIT, 8), \
-	TOKEN_PTR(palette_init, PALETTE_INIT_NAME(_func)),
+	config.m_init_palette = PALETTE_INIT_NAME(_func); \
 
 #define MDRV_VIDEO_START(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_VIDEO_START, 8), \
-	TOKEN_PTR(video_start, VIDEO_START_NAME(_func)),
+	config.m_video_start = VIDEO_START_NAME(_func); \
 
 #define MDRV_VIDEO_RESET(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_VIDEO_RESET, 8), \
-	TOKEN_PTR(video_reset, VIDEO_RESET_NAME(_func)),
+	config.m_video_reset = VIDEO_RESET_NAME(_func); \
 
 #define MDRV_VIDEO_EOF(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_VIDEO_EOF, 8), \
-	TOKEN_PTR(video_eof, VIDEO_EOF_NAME(_func)),
+	config.m_video_eof = VIDEO_EOF_NAME(_func); \
 
 #define MDRV_VIDEO_UPDATE(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_VIDEO_UPDATE, 8), \
-	TOKEN_PTR(video_update, VIDEO_UPDATE_NAME(_func)),
+	config.m_video_update = VIDEO_UPDATE_NAME(_func); \
 
 
 // core sound functions
 #define MDRV_SOUND_START(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_SOUND_START, 8), \
-	TOKEN_PTR(sound_start, SOUND_START_NAME(_func)),
+	config.m_sound_start = SOUND_START_NAME(_func); \
 
 #define MDRV_SOUND_RESET(_func) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_SOUND_RESET, 8), \
-	TOKEN_PTR(sound_reset, SOUND_RESET_NAME(_func)),
+	config.m_sound_reset = SOUND_RESET_NAME(_func); \
 
 
 // add/remove devices
 #define MDRV_DEVICE_ADD(_tag, _type, _clock) \
-	TOKEN_UINT64_PACK2(MCONFIG_TOKEN_DEVICE_ADD, 8, _clock, 32), \
-	TOKEN_PTR(devtype, _type), \
-	TOKEN_STRING(_tag),
+	device = config.device_add(owner, _tag, _type, _clock); \
 
 #define MDRV_DEVICE_REPLACE(_tag, _type, _clock) \
-	TOKEN_UINT64_PACK2(MCONFIG_TOKEN_DEVICE_REPLACE, 8, _clock, 32), \
-	TOKEN_PTR(devtype, _type), \
-	TOKEN_STRING(_tag),
+	device = config.device_replace(owner, _tag, _type, _clock); \
 
 #define MDRV_DEVICE_REMOVE(_tag) \
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DEVICE_REMOVE, 8), \
-	TOKEN_STRING(_tag),
+	device = config.device_remove(owner, _tag); \
 
 #define MDRV_DEVICE_MODIFY(_tag)	\
-	TOKEN_UINT32_PACK1(MCONFIG_TOKEN_DEVICE_MODIFY, 8), \
-	TOKEN_STRING(_tag),
+	device = config.device_find(owner, _tag); \
 
 
 #endif	/* __MCONFIG_H__ */
diff -Nru src-old/emu/memconv.h src/emu/memconv.h
--- src-old/emu/memconv.h	2009-01-01 09:11:54.000000000 -0800
+++ src/emu/memconv.h	2010-08-19 00:26:14.000000000 -0700
@@ -85,7 +85,7 @@
  *
  *************************************/
 
-INLINE UINT16 read16be_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT16 mem_mask)
+INLINE UINT16 read16be_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT16 mem_mask)
 {
 	UINT16 result = 0;
 	if (ACCESSING_BITS_8_15)
@@ -96,7 +96,7 @@
 }
 
 
-INLINE void write16be_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask)
+INLINE void write16be_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask)
 {
 	if (ACCESSING_BITS_8_15)
 		(*handler)(space, offset * 2 + 0, data >> 8);
@@ -111,7 +111,7 @@
  *
  *************************************/
 
-INLINE UINT16 read16le_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT16 mem_mask)
+INLINE UINT16 read16le_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT16 mem_mask)
 {
 	UINT16 result = 0;
 	if (ACCESSING_BITS_0_7)
@@ -122,7 +122,7 @@
 }
 
 
-INLINE void write16le_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask)
+INLINE void write16le_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask)
 {
 	if (ACCESSING_BITS_0_7)
 		(*handler)(space, offset * 2 + 0, data >> 0);
@@ -137,7 +137,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32be_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32be_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	if (ACCESSING_BITS_16_31)
@@ -148,7 +148,7 @@
 }
 
 
-INLINE void write32be_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32be_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	if (ACCESSING_BITS_16_31)
 		write16be_with_write8_handler(handler, space, offset * 2 + 0, data >> 16, mem_mask >> 16);
@@ -163,7 +163,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32le_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32le_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	if (ACCESSING_BITS_0_15)
@@ -174,7 +174,7 @@
 }
 
 
-INLINE void write32le_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32le_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	if (ACCESSING_BITS_0_15)
 		write16le_with_write8_handler(handler, space, offset * 2 + 0, data, mem_mask);
@@ -189,7 +189,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32be_with_16be_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32be_with_16be_handler(read16_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	if (ACCESSING_BITS_16_31)
@@ -200,7 +200,7 @@
 }
 
 
-INLINE void write32be_with_16be_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32be_with_16be_handler(write16_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	if (ACCESSING_BITS_16_31)
 		(*handler)(space, offset * 2 + 0, data >> 16, mem_mask >> 16);
@@ -215,7 +215,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32le_with_16le_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32le_with_16le_handler(read16_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	if (ACCESSING_BITS_0_15)
@@ -226,7 +226,7 @@
 }
 
 
-INLINE void write32le_with_16le_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32le_with_16le_handler(write16_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	if (ACCESSING_BITS_0_15)
 		(*handler)(space, offset * 2 + 0, data, mem_mask);
@@ -241,7 +241,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32be_with_16le_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32be_with_16le_handler(read16_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	mem_mask = FLIPENDIAN_INT32(mem_mask);
@@ -250,7 +250,7 @@
 }
 
 
-INLINE void write32be_with_16le_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32be_with_16le_handler(write16_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	data = FLIPENDIAN_INT32(data);
 	mem_mask = FLIPENDIAN_INT32(mem_mask);
@@ -264,7 +264,7 @@
  *
  *************************************/
 
-INLINE UINT32 read32le_with_16be_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT32 mem_mask)
+INLINE UINT32 read32le_with_16be_handler(read16_space_func handler, address_space *space, offs_t offset, UINT32 mem_mask)
 {
 	UINT32 result = 0;
 	mem_mask = FLIPENDIAN_INT32(mem_mask);
@@ -273,7 +273,7 @@
 }
 
 
-INLINE void write32le_with_16be_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
+INLINE void write32le_with_16be_handler(write16_space_func handler, address_space *space, offs_t offset, UINT32 data, UINT32 mem_mask)
 {
 	data = FLIPENDIAN_INT32(data);
 	mem_mask = FLIPENDIAN_INT32(mem_mask);
@@ -287,7 +287,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64be_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64be_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_32_63)
@@ -298,7 +298,7 @@
 }
 
 
-INLINE void write64be_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64be_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_32_63)
 		write32be_with_write8_handler(handler, space, offset * 2 + 0, data >> 32, mem_mask >> 32);
@@ -313,7 +313,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64le_with_read8_handler(read8_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64le_with_read8_handler(read8_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_0_31)
@@ -324,7 +324,7 @@
 }
 
 
-INLINE void write64le_with_write8_handler(write8_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64le_with_write8_handler(write8_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_0_31)
 		write32le_with_write8_handler(handler, space, offset * 2 + 0, data >> 0, mem_mask >> 0);
@@ -339,7 +339,7 @@
  *
  *************************************/
 
-INLINE UINT32 read64be_with_16be_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT32 read64be_with_16be_handler(read16_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_32_63)
@@ -350,7 +350,7 @@
 }
 
 
-INLINE void write64be_with_16be_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64be_with_16be_handler(write16_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_32_63)
 		write32be_with_16be_handler(handler, space, offset * 2 + 0, data >> 32, mem_mask >> 32);
@@ -365,7 +365,7 @@
  *
  *************************************/
 
-INLINE UINT32 read64le_with_16le_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT32 read64le_with_16le_handler(read16_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_0_31)
@@ -376,7 +376,7 @@
 }
 
 
-INLINE void write64le_with_16le_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64le_with_16le_handler(write16_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_0_31)
 		write32le_with_16le_handler(handler, space, offset * 2 + 0, data >> 0, mem_mask >> 0);
@@ -391,7 +391,7 @@
  *
  *************************************/
 
-INLINE UINT32 read64be_with_16le_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT32 read64be_with_16le_handler(read16_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_32_63)
@@ -402,7 +402,7 @@
 }
 
 
-INLINE void write64be_with_16le_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64be_with_16le_handler(write16_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_32_63)
 		write32be_with_16le_handler(handler, space, offset * 2 + 0, data >> 32, mem_mask >> 32);
@@ -417,7 +417,7 @@
  *
  *************************************/
 
-INLINE UINT32 read64le_with_16be_handler(read16_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT32 read64le_with_16be_handler(read16_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_0_31)
@@ -428,7 +428,7 @@
 }
 
 
-INLINE void write64le_with_16be_handler(write16_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64le_with_16be_handler(write16_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_0_31)
 		write32le_with_16be_handler(handler, space, offset * 2 + 0, data >> 0, mem_mask >> 0);
@@ -443,7 +443,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64be_with_32be_handler(read32_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64be_with_32be_handler(read32_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_32_63)
@@ -454,7 +454,7 @@
 }
 
 
-INLINE void write64be_with_32be_handler(write32_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64be_with_32be_handler(write32_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_32_63)
 		(*handler)(space, offset * 2 + 0, data >> 32, mem_mask >> 32);
@@ -469,7 +469,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64le_with_32le_handler(read32_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64le_with_32le_handler(read32_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result = 0;
 	if (ACCESSING_BITS_0_31)
@@ -480,7 +480,7 @@
 }
 
 
-INLINE void write64le_with_32le_handler(write32_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64le_with_32le_handler(write32_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	if (ACCESSING_BITS_0_31)
 		(*handler)(space, offset * 2 + 0, data >> 0, mem_mask >> 0);
@@ -495,7 +495,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64be_with_32le_handler(read32_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64be_with_32le_handler(read32_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result;
 	mem_mask = FLIPENDIAN_INT64(mem_mask);
@@ -504,7 +504,7 @@
 }
 
 
-INLINE void write64be_with_32le_handler(write32_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64be_with_32le_handler(write32_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	data = FLIPENDIAN_INT64(data);
 	mem_mask = FLIPENDIAN_INT64(mem_mask);
@@ -518,7 +518,7 @@
  *
  *************************************/
 
-INLINE UINT64 read64le_with_32be_handler(read32_space_func handler, const address_space *space, offs_t offset, UINT64 mem_mask)
+INLINE UINT64 read64le_with_32be_handler(read32_space_func handler, address_space *space, offs_t offset, UINT64 mem_mask)
 {
 	UINT64 result;
 	mem_mask = FLIPENDIAN_INT64(mem_mask);
@@ -527,7 +527,7 @@
 }
 
 
-INLINE void write64le_with_32be_handler(write32_space_func handler, const address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
+INLINE void write64le_with_32be_handler(write32_space_func handler, address_space *space, offs_t offset, UINT64 data, UINT64 mem_mask)
 {
 	data = FLIPENDIAN_INT64(data);
 	mem_mask = FLIPENDIAN_INT64(mem_mask);
diff -Nru src-old/emu/memory.c src/emu/memory.c
--- src-old/emu/memory.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/memory.c	2010-08-30 08:20:58.000000000 -0700
@@ -4,8 +4,36 @@
 
     Functions which handle device memory access.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ****************************************************************************
 
@@ -177,2041 +205,2723 @@
 #include "debug/debugcpu.h"
 
 
-/***************************************************************************
-    DEBUGGING
-***************************************************************************/
+//**************************************************************************
+//  DEBUGGING
+//**************************************************************************
 
 #define MEM_DUMP		(0)
 #define VERBOSE			(0)
-#define ALLOW_ONLY_AUTO_MALLOC_BANKS	0
+#define TEST_HANDLER	(0)
 
-#define VPRINTF(x)	do { if (VERBOSE) mame_printf_debug x; } while (0)
+#define VPRINTF(x)	do { if (VERBOSE) printf x; } while (0)
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
-
-/* banking constants */
-#define MAX_BANK_ENTRIES		4096					/* maximum number of possible bank values */
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-/* address map lookup table definitions */
-#define LEVEL1_BITS				18						/* number of address bits in the level 1 table */
-#define LEVEL2_BITS				(32 - LEVEL1_BITS)		/* number of address bits in the level 2 table */
-#define SUBTABLE_COUNT			64						/* number of slots reserved for subtables */
-#define SUBTABLE_BASE			(256 - SUBTABLE_COUNT)	/* first index of a subtable */
-#define ENTRY_COUNT				(SUBTABLE_BASE)			/* number of legitimate (non-subtable) entries */
-#define SUBTABLE_ALLOC			8						/* number of subtables to allocate at a time */
-
-/* shares are initially mapped to this invalid pointer */
-#define UNMAPPED_SHARE_PTR		((void *)-1)
+// banking constants
+const int BANK_ENTRY_UNSPECIFIED = -1;
 
-/* other address map constants */
-#define MEMORY_BLOCK_CHUNK		65536					/* minimum chunk size of allocated memory blocks */
+// shares are initially mapped to this invalid pointer
+static void *UNMAPPED_SHARE_PTR = ((void *)-1);
 
-/* read or write constants */
-enum _read_or_write
-{
-	ROW_READ,
-	ROW_WRITE
-};
-typedef enum _read_or_write read_or_write;
+// other address map constants
+const int MEMORY_BLOCK_CHUNK = 65536;					// minimum chunk size of allocated memory blocks
 
-/* static data access handler constants */
+// static data access handler constants
 enum
 {
-	STATIC_INVALID = 0,									/* invalid - should never be used */
-	STATIC_BANK1 = 1,									/* first memory bank */
-	STATIC_BANKMAX = 122,								/* last memory bank */
-	STATIC_RAM,											/* RAM - reads/writes map to dynamic banks */
-	STATIC_ROM,											/* ROM - reads = RAM; writes = UNMAP */
-	STATIC_NOP,											/* NOP - reads = unmapped value; writes = no-op */
-	STATIC_UNMAP,										/* unmapped - same as NOP except we log errors */
-	STATIC_WATCHPOINT,									/* watchpoint - used internally */
-	STATIC_COUNT										/* total number of static handlers */
+	STATIC_INVALID = 0,									// invalid - should never be used
+	STATIC_BANK1 = 1,									// first memory bank
+	STATIC_BANKMAX = 122,								// last memory bank
+	STATIC_RAM,											// RAM - reads/writes map to dynamic banks
+	STATIC_ROM,											// ROM - reads = RAM; writes = UNMAP
+	STATIC_NOP,											// NOP - reads = unmapped value; writes = no-op
+	STATIC_UNMAP,										// unmapped - same as NOP except we log errors
+	STATIC_WATCHPOINT,									// watchpoint - used internally
+	STATIC_COUNT										// total number of static handlers
 };
 
 
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
-
-/* table lookup helpers */
-#define LEVEL1_INDEX(a)			((a) >> LEVEL2_BITS)
-#define LEVEL2_INDEX(e,a)		((1 << LEVEL1_BITS) + (((e) - SUBTABLE_BASE) << LEVEL2_BITS) + ((a) & ((1 << LEVEL2_BITS) - 1)))
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-/* helper macros */
-#define HANDLER_IS_RAM(h)		((FPTR)(h) == STATIC_RAM)
-#define HANDLER_IS_ROM(h)		((FPTR)(h) == STATIC_ROM)
-#define HANDLER_IS_BANK(h)		((FPTR)(h) >= STATIC_BANK1 && (FPTR)(h) <= STATIC_BANKMAX)
-#define HANDLER_IS_STATIC(h)	((FPTR)(h) < STATIC_COUNT)
 
-#define HANDLER_TO_BANK(h)		((UINT32)(FPTR)(h))
-
-#define SUBTABLE_PTR(tabledata, entry) (&(tabledata)->table[(1 << LEVEL1_BITS) + (((entry) - SUBTABLE_BASE) << LEVEL2_BITS)])
+// ======================> memory_block
 
+// a memory block is a chunk of RAM associated with a range of memory in a device's address space
+class memory_block
+{
+	DISABLE_COPYING(memory_block);
 
+	friend class simple_list<memory_block>;
+	friend resource_pool_object<memory_block>::~resource_pool_object();
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+public:
+	// construction/destruction
+	memory_block(address_space &space, offs_t bytestart, offs_t byteend, void *memory = NULL);
+	~memory_block();
 
-/* a memory block is a chunk of RAM associated with a range of memory in a device's address space */
-typedef struct _memory_block memory_block;
-struct _memory_block
-{
-	memory_block *			next;					/* next memory block in the list */
-	const address_space *	space;					/* which address space are we associated with? */
-	UINT8					isallocated;			/* did we allocate this ourselves? */
-	offs_t					bytestart, byteend;		/* byte-normalized start/end for verifying a match */
-	UINT8 *					data;					/* pointer to the data for this block */
-};
+	// getters
+	memory_block *next() const { return m_next; }
+	offs_t bytestart() const { return m_bytestart; }
+	offs_t byteend() const { return m_byteend; }
+	UINT8 *data() const { return m_data; }
 
-/* a bank reference is an entry in a list of address spaces that reference a given bank */
-typedef struct _bank_reference bank_reference;
-struct _bank_reference
-{
-	bank_reference *		next;					/* link to the next reference */
-	const address_space *	space;					/* address space that references us */
-};
+	// is the given range contained by this memory block?
+	bool contains(address_space &space, offs_t bytestart, offs_t byteend) const
+	{
+		return (&space == &m_space && m_bytestart <= bytestart && m_byteend >= byteend);
+	}
 
-/* a bank is a global pointer to memory that can be shared across devices and changed dynamically */
-typedef struct _bank_info bank_info;
-struct _bank_info
-{
-	bank_info *				next;					/* next bank in sequence */
-	UINT8					index;					/* array index for this handler */
-	UINT8					read;					/* is this bank used for reads? */
-	UINT8					write;					/* is this bank used for writes? */
-	void *					handler;				/* handler for this bank */
-	bank_reference *		reflist;				/* linked list of address spaces referencing this bank */
-	offs_t					bytestart;				/* byte-adjusted start offset */
-	offs_t					byteend;				/* byte-adjusted end offset */
-	UINT16					curentry;				/* current entry */
-	void *					entry[MAX_BANK_ENTRIES];/* array of entries for this bank */
-	void *					entryd[MAX_BANK_ENTRIES];/* array of decrypted entries for this bank */
-	char *					name;					/* friendly name for this bank */
-	char					tag[1];					/* tag associated with this bank */
+private:
+	// internal state
+	memory_block *			m_next;					// next memory block in the list
+	running_machine &		m_machine;				// need the machine to free our memory
+	address_space &			m_space;				// which address space are we associated with?
+	bool					m_isallocated;			// did we allocate this ourselves?
+	offs_t					m_bytestart, m_byteend;	// byte-normalized start/end for verifying a match
+	UINT8 *					m_data;					// pointer to the data for this block
 };
 
-/* In memory.h: typedef struct _direct_range direct_range; */
-struct _direct_range
-{
-    direct_range *			next;					/* pointer to the next range in the list */
-    offs_t					bytestart;				/* starting byte offset of the range */
-    offs_t					byteend;				/* ending byte offset of the range */
-};
 
-/* In memory.h: typedef struct _handler_data handler_data */
-struct _handler_data
-{
-	memory_handler			handler;				/* function pointer for handler */
-	void *					object;					/* object associated with the handler */
-	const char *			name;					/* name of the handler */
-	memory_handler			subhandler;				/* function pointer for subhandler */
-	void *					subobject;				/* object associated with the subhandler */
-	UINT8					subunits;				/* number of subunits to access */
-	UINT8					subshift[8];			/* shift amounts for up to 8 subunits */
-	offs_t					bytestart;				/* byte-adjusted start address for handler */
-	offs_t					byteend;				/* byte-adjusted end address for handler */
-	offs_t					bytemask;				/* byte-adjusted mask against the final address */
-	UINT8 **				bankbaseptr;			/* pointer to the bank base */
-};
+// ======================> memory_bank
 
-/* In memory.h: typedef struct _subtable_data subtable_data; */
-struct _subtable_data
+// a memory bank is a global pointer to memory that can be shared across devices and changed dynamically
+class memory_bank
 {
-	UINT8					checksum_valid;			/* is the checksum valid */
-	UINT32					checksum;				/* checksum over all the bytes */
-	UINT32					usecount;				/* number of times this has been used */
-};
+	friend class simple_list<memory_bank>;
+	friend resource_pool_object<memory_bank>::~resource_pool_object();
 
-struct _memory_private
-{
-	UINT8					initialized;					/* have we completed initialization? */
+	// a bank reference is an entry in a list of address spaces that reference a given bank
+	class bank_reference
+	{
+		friend class simple_list<bank_reference>;
+		friend resource_pool_object<bank_reference>::~resource_pool_object();
 
-	const address_space *	spacelist;						/* list of address spaces */
+	public:
+		// construction/destruction
+		bank_reference(address_space &space, read_or_write readorwrite)
+			: m_next(NULL),
+			  m_space(space),
+			  m_readorwrite(readorwrite) { }
 
-	UINT8 *					bank_ptr[STATIC_COUNT];			/* array of bank pointers */
-	UINT8 *					bankd_ptr[STATIC_COUNT];		/* array of decrypted bank pointers */
+		// getters
+		bank_reference *next() const { return m_next; }
+		address_space &space() const { return m_space; }
 
-	memory_block *			memory_block_list;				/* head of the list of memory blocks */
+		// does this reference match the space+read/write combination?
+		bool matches(address_space &space, read_or_write readorwrite) const
+		{
+			return (&space == &m_space && (readorwrite == ROW_READWRITE || readorwrite == m_readorwrite));
+		}
 
-	tagmap_t<bank_info *>	bankmap;						/* map for fast bank lookups */
-	bank_info * 			banklist;						/* data gathered for each bank */
-	UINT8					banknext;						/* next bank to allocate */
+	private:
+		// internal state
+		bank_reference *		m_next;				// link to the next reference
+		address_space &			m_space;			// address space that references us
+		read_or_write			m_readorwrite;		// used for read or write?
+	};
 
-	tagmap_t<void *>		sharemap;						/* map for share lookups */
+	// a bank_entry contains a raw and decrypted pointer
+	struct bank_entry
+	{
+		UINT8 *			m_raw;
+		UINT8 *			m_decrypted;
+	};
 
-	UINT8 *					wptable;						/* watchpoint-fill table */
+public:
+	// construction/destruction
+	memory_bank(address_space &space, int index, offs_t bytestart, offs_t byteend, const char *tag = NULL);
+	~memory_bank();
+
+	// getters
+	memory_bank *next() const { return m_next; }
+	int index() const { return m_index; }
+	int entry() const { return m_curentry; }
+	bool anonymous() const { return m_anonymous; }
+	offs_t bytestart() const { return m_bytestart; }
+	void *base() const { return *m_baseptr; }
+	void *base_decrypted() const { return *m_basedptr; }
+	const char *tag() const { return m_tag; }
+	const char *name() const { return m_name; }
+
+	// compare a range against our range
+	bool matches_exactly(offs_t bytestart, offs_t byteend) const { return (m_bytestart == bytestart && m_byteend == byteend); }
+	bool fully_covers(offs_t bytestart, offs_t byteend) const { return (m_bytestart <= bytestart && m_byteend >= byteend); }
+	bool is_covered_by(offs_t bytestart, offs_t byteend) const { return (m_bytestart >= bytestart && m_byteend <= byteend); }
+	bool straddles(offs_t bytestart, offs_t byteend) const { return (m_bytestart < byteend && m_byteend > bytestart); }
+
+	// track and verify address space references to this bank
+	bool references_space(address_space &space, read_or_write readorwrite) const;
+	void add_reference(address_space &space, read_or_write readorwrite);
+
+	// set the base explicitly
+	void set_base(void *base);
+	void set_base_decrypted(void *base);
+
+	// configure and set entries
+	void configure(int entrynum, void *base);
+	void configure_decrypted(int entrynum, void *base);
+	void set_entry(int entrynum);
+
+private:
+	// internal helpers
+	void invalidate_references();
+	void expand_entries(int entrynum);
+
+	// internal state
+	memory_bank *			m_next;					// next bank in sequence
+	running_machine &		m_machine;				// need the machine to free our memory
+	UINT8 **				m_baseptr;				// pointer to our base pointer in the global array
+	UINT8 **				m_basedptr;				// same for the decrypted base pointer
+	UINT8					m_index;				// array index for this handler
+	bool					m_anonymous;			// are we anonymous or explicit?
+	offs_t					m_bytestart;			// byte-adjusted start offset
+	offs_t					m_byteend;				// byte-adjusted end offset
+	int						m_curentry;				// current entry
+	bank_entry *			m_entry;				// array of entries (dynamically allocated)
+	int						m_entry_count;			// number of allocated entries
+	astring					m_name;					// friendly name for this bank
+	astring					m_tag;					// tag for this bank
+	simple_list<bank_reference> m_reflist;			// linked list of address spaces referencing this bank
 };
 
 
+// ======================> handler_entry
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
+// a handler entry contains information about a memory handler
+class handler_entry : public bindable_object
+{
+	DISABLE_COPYING(handler_entry);
 
-#define ACCESSOR_GROUP(width) \
-{ \
-	memory_read_byte_##width, \
-	memory_read_word_##width, \
-	memory_read_word_masked_##width, \
-	memory_read_dword_##width, \
-	memory_read_dword_masked_##width, \
-	memory_read_qword_##width, \
-	memory_read_qword_masked_##width, \
-	memory_write_byte_##width, \
-	memory_write_word_##width, \
-	memory_write_word_masked_##width, \
-	memory_write_dword_##width, \
-	memory_write_dword_masked_##width, \
-	memory_write_qword_##width, \
-	memory_write_qword_masked_##width \
-}
-
-static const data_accessors memory_accessors[4][2] =
-{
-	{ ACCESSOR_GROUP(8le),  ACCESSOR_GROUP(8be)  },
-	{ ACCESSOR_GROUP(16le), ACCESSOR_GROUP(16be) },
-	{ ACCESSOR_GROUP(32le), ACCESSOR_GROUP(32be) },
-	{ ACCESSOR_GROUP(64le), ACCESSOR_GROUP(64be) }
-};
+protected:
+	// construction/destruction
+	handler_entry(UINT8 width, endianness_t endianness, UINT8 **rambaseptr);
+	virtual ~handler_entry();
 
+public:
+	// getters
+	bool populated() const { return m_populated; }
+	offs_t bytestart() const { return m_bytestart; }
+	offs_t byteend() const { return m_byteend; }
+	offs_t bytemask() const { return m_bytemask; }
+	virtual const char *name() const = 0;
 
+	// return offset within the range referenced by this handler
+	offs_t byteoffset(offs_t byteaddress) const { return (byteaddress - m_bytestart) & m_bytemask; }
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
+	// return a pointer to the backing RAM at the given offset
+	UINT8 *ramptr(offs_t offset = 0) const { return *m_rambaseptr + offset; }
 
-/* internal initialization */
-static void memory_init_spaces(running_machine *machine);
-static void memory_init_preflight(running_machine *machine);
-static void memory_init_populate(running_machine *machine);
-static void memory_init_map_entry(address_space *space, const address_map_entry *entry, read_or_write readorwrite);
-static void memory_init_allocate(running_machine *machine);
-static void memory_init_locate(running_machine *machine);
-static void memory_exit(running_machine &machine);
-
-/* memory mapping helpers */
-static void space_map_range(address_space *space, read_or_write readorwrite, int handlerbits, int handlerunitmask, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, genf *handler, void *object, const char *handler_name);
-static void *space_find_backing_memory(const address_space *space, offs_t addrstart, offs_t addrend);
-static int space_needs_backing_store(const address_space *space, const address_map_entry *entry);
+	// see if we are an exact match to the given parameters
+	bool matches_exactly(offs_t bytestart, offs_t byteend, offs_t bytemask) const
+	{
+		return (m_populated && m_bytestart == bytestart && m_byteend == byteend && m_bytemask == bytemask);
+	}
 
-/* banking helpers */
-static genf *bank_find_or_allocate(const address_space *space, const char *tag, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite);
-static STATE_POSTLOAD( bank_reattach );
+	// get the start/end address with the given mirror
+	void mirrored_start_end(offs_t byteaddress, offs_t &start, offs_t &end) const
+	{
+		offs_t mirrorbits = (byteaddress - m_bytestart) & ~m_bytemask;
+		start = m_bytestart | mirrorbits;
+		end = m_byteend | mirrorbits;
+	}
 
-/* table management */
-static UINT8 table_assign_handler(const address_space *space, handler_data **table, void *object, genf *handler, const char *handler_name, offs_t bytestart, offs_t byteend, offs_t bytemask);
-static void table_compute_subhandler(handler_data **table, UINT8 entry, read_or_write readorwrite, int spacebits, int spaceendian, int handlerbits, int handlerunitmask);
-static void table_populate_range(address_table *tabledata, offs_t bytestart, offs_t byteend, UINT8 handler);
-static void table_populate_range_mirrored(address_space *space, address_table *tabledata, offs_t bytestart, offs_t byteend, offs_t bytemirror, UINT8 handler);
-static UINT8 table_derive_range(const address_table *table, offs_t byteaddress, offs_t *bytestart, offs_t *byteend);
-
-/* subtable management */
-static UINT8 subtable_alloc(address_table *tabledata);
-static void subtable_realloc(address_table *tabledata, UINT8 subentry);
-static int subtable_merge(address_table *tabledata);
-static void subtable_release(address_table *tabledata, UINT8 subentry);
-static UINT8 *subtable_open(address_table *tabledata, offs_t l1index);
-static void subtable_close(address_table *tabledata, offs_t l1index);
-
-/* direct memory ranges */
-static direct_range *direct_range_find(address_space *space, offs_t byteaddress, UINT8 *entry);
-static void direct_range_remove_intersecting(address_space *space, offs_t bytestart, offs_t byteend);
-
-/* memory block allocation */
-static void *block_allocate(const address_space *space, offs_t bytestart, offs_t byteend, void *memory);
-static address_map_entry *block_assign_intersecting(address_space *space, offs_t bytestart, offs_t byteend, UINT8 *base);
-
-/* internal handlers */
-static memory_handler get_stub_handler(read_or_write readorwrite, int spacedbits, int handlerdbits);
-static genf *get_static_handler(int handlerbits, int readorwrite, int which);
-
-/* debugging */
-static const char *handler_to_string(const address_space *space, const address_table *table, UINT8 entry);
-static void dump_map(FILE *file, const address_space *space, const address_table *table);
-static void mem_dump(running_machine *machine);
-
-/* input port handlers */
-static UINT8 input_port_read8(const input_port_config *port, offs_t offset);
-static UINT16 input_port_read16(const input_port_config *port, offs_t offset, UINT16 mem_mask);
-static UINT32 input_port_read32(const input_port_config *port, offs_t offset, UINT32 mem_mask);
-static UINT64 input_port_read64(const input_port_config *port, offs_t offset, UINT64 mem_mask);
-
-/* output port handlers */
-static void input_port_write8(const input_port_config *port, offs_t offset, UINT8 data);
-static void input_port_write16(const input_port_config *port, offs_t offset, UINT16 data, UINT16 mem_mask);
-static void input_port_write32(const input_port_config *port, offs_t offset, UINT32 data, UINT32 mem_mask);
-static void input_port_write64(const input_port_config *port, offs_t offset, UINT64 data, UINT64 mem_mask);
+	// configure the handler addresses, and mark as populated
+	void configure(offs_t bytestart, offs_t byteend, offs_t bytemask)
+	{
+		m_populated = true;
+		m_bytestart = bytestart;
+		m_byteend = byteend;
+		m_bytemask = bytemask;
+	}
 
+	// apply a global mask
+	void apply_mask(offs_t bytemask) { m_bytemask &= bytemask; }
 
+protected:
+	// internal helpers
+	void configure_subunits(UINT64 handlermask, int handlerbits);
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
+	// internal state
+	bool					m_populated;			// populated?
+	UINT8					m_datawidth;
+	endianness_t			m_endianness;
+	offs_t					m_bytestart;			// byte-adjusted start address for handler
+	offs_t					m_byteend;				// byte-adjusted end address for handler
+	offs_t					m_bytemask;				// byte-adjusted mask against the final address
+	UINT8 **				m_rambaseptr;			// pointer to the bank base
+	UINT8					m_subunits;				// for width stubs, the number of subunits
+	UINT8					m_subshift[8];			// for width stubs, the shift of each subunit
+};
 
-/*-------------------------------------------------
-    force_opbase_update - ensure that we update
-    the opcode base
--------------------------------------------------*/
 
-INLINE void force_opbase_update(const address_space *space)
+// ======================> handler_entry_read
+
+// a read-access-specific extension of handler_entry
+class handler_entry_read : public handler_entry
 {
-	address_space *spacerw = (address_space *)space;
-	spacerw->direct.byteend = 0;
-	spacerw->direct.bytestart = 1;
-}
+public:
+	// construction/destruction
+	handler_entry_read(UINT8 width, endianness_t endianness, UINT8 **rambaseptr)
+		: handler_entry(width, endianness, rambaseptr)
+	{
+		m_legacy_object.space = NULL;
+		m_legacy_handler.space8 = NULL;
+	}
+
+	// getters
+	virtual const char *name() const;
+
+	// configure delegate callbacks
+	void set_delegate(read8_delegate delegate, UINT64 mask = 0);
+	void set_delegate(read16_delegate delegate, UINT64 mask = 0);
+	void set_delegate(read32_delegate delegate, UINT64 mask = 0);
+	void set_delegate(read64_delegate delegate, UINT64 mask = 0);
+
+	// configure legacy address space functions
+	void set_legacy_func(address_space &space, read8_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, read16_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, read32_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, read64_space_func func, const char *name, UINT64 mask = 0);
+
+	// configure legacy device functions
+	void set_legacy_func(device_t &device, read8_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, read16_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, read32_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, read64_device_func func, const char *name, UINT64 mask = 0);
+
+	// configure I/O port access
+	void set_ioport(const input_port_config &ioport);
+
+	// read via the underlying delegates
+	UINT8 read8(address_space &space, offs_t offset, UINT8 mask) const { return m_read8(space, offset, mask); }
+	UINT16 read16(address_space &space, offs_t offset, UINT16 mask) const { return m_read16(space, offset, mask); }
+	UINT32 read32(address_space &space, offs_t offset, UINT32 mask) const { return m_read32(space, offset, mask); }
+	UINT64 read64(address_space &space, offs_t offset, UINT64 mask) const { return m_read64(space, offset, mask); }
+
+private:
+	// stubs for converting between address sizes
+	UINT16 read_stub_16_from_8(address_space &space, offs_t offset, UINT16 mask);
+	UINT32 read_stub_32_from_8(address_space &space, offs_t offset, UINT32 mask);
+	UINT64 read_stub_64_from_8(address_space &space, offs_t offset, UINT64 mask);
+	UINT32 read_stub_32_from_16(address_space &space, offs_t offset, UINT32 mask);
+	UINT64 read_stub_64_from_16(address_space &space, offs_t offset, UINT64 mask);
+	UINT64 read_stub_64_from_32(address_space &space, offs_t offset, UINT64 mask);
+
+	// stubs for calling legacy read handlers
+	UINT8 read_stub_legacy(address_space &space, offs_t offset, UINT8 mask);
+	UINT16 read_stub_legacy(address_space &space, offs_t offset, UINT16 mask);
+	UINT32 read_stub_legacy(address_space &space, offs_t offset, UINT32 mask);
+	UINT64 read_stub_legacy(address_space &space, offs_t offset, UINT64 mask);
+
+	// stubs for reading I/O ports
+	template<typename _UintType>
+	_UintType read_stub_ioport(address_space &space, offs_t offset, _UintType mask) { return input_port_read_direct(m_ioport); }
+
+	// internal state
+	read8_delegate				m_read8;
+	read16_delegate				m_read16;
+	read32_delegate				m_read32;
+	read64_delegate				m_read64;
+	const input_port_config *	m_ioport;
+
+	// unions to hold legacy objects and callbacks
+	union
+	{
+		address_space *	space;
+		device_t *				device;
+	} m_legacy_object;
+
+	union
+	{
+		read8_space_func		space8;
+		read16_space_func		space16;
+		read32_space_func		space32;
+		read64_space_func		space64;
+		read8_device_func		device8;
+		read16_device_func		device16;
+		read32_device_func		device32;
+		read64_device_func		device64;
+	} m_legacy_handler;
+};
 
 
-/*-------------------------------------------------
-    adjust_addresses - adjust addresses for a
-    given address space in a standard fashion
--------------------------------------------------*/
+// ======================> handler_entry_write
 
-INLINE void adjust_addresses(const address_space *space, offs_t *start, offs_t *end, offs_t *mask, offs_t *mirror)
+// a write-access-specific extension of handler_entry
+class handler_entry_write : public handler_entry
 {
-	/* adjust start/end/mask values */
-	if (*mask == 0)
-		*mask = space->addrmask & ~*mirror;
-	else
-		*mask &= space->addrmask;
-	*start &= ~*mirror & space->addrmask;
-	*end &= ~*mirror & space->addrmask;
-
-	/* adjust to byte values */
-	*start = memory_address_to_byte(space, *start);
-	*end = memory_address_to_byte_end(space, *end);
-	*mask = memory_address_to_byte_end(space, *mask);
-	*mirror = memory_address_to_byte(space, *mirror);
-}
+public:
+	// construction/destruction
+	handler_entry_write(UINT8 width, endianness_t endianness, UINT8 **rambaseptr)
+		: handler_entry(width, endianness, rambaseptr)
+	{
+		m_legacy_object.space = NULL;
+		m_legacy_handler.space8 = NULL;
+	}
+
+	// getters
+	virtual const char *name() const;
+
+	// configure delegate callbacks
+	void set_delegate(write8_delegate delegate, UINT64 mask = 0);
+	void set_delegate(write16_delegate delegate, UINT64 mask = 0);
+	void set_delegate(write32_delegate delegate, UINT64 mask = 0);
+	void set_delegate(write64_delegate delegate, UINT64 mask = 0);
+
+	// configure legacy address space functions
+	void set_legacy_func(address_space &space, write8_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, write16_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, write32_space_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(address_space &space, write64_space_func func, const char *name, UINT64 mask = 0);
+
+	// configure legacy device functions
+	void set_legacy_func(device_t &device, write8_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, write16_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, write32_device_func func, const char *name, UINT64 mask = 0);
+	void set_legacy_func(device_t &device, write64_device_func func, const char *name, UINT64 mask = 0);
+
+	// configure I/O port access
+	void set_ioport(const input_port_config &ioport);
+
+	// write via the underlying delegates
+	void write8(address_space &space, offs_t offset, UINT8 data, UINT8 mask) const { m_write8(space, offset, data, mask); }
+	void write16(address_space &space, offs_t offset, UINT16 data, UINT16 mask) const { m_write16(space, offset, data, mask); }
+	void write32(address_space &space, offs_t offset, UINT32 data, UINT32 mask) const { m_write32(space, offset, data, mask); }
+	void write64(address_space &space, offs_t offset, UINT64 data, UINT64 mask) const { m_write64(space, offset, data, mask); }
+
+private:
+	// stubs for converting between address sizes
+	void write_stub_16_from_8(address_space &space, offs_t offset, UINT16 data, UINT16 mask);
+	void write_stub_32_from_8(address_space &space, offs_t offset, UINT32 data, UINT32 mask);
+	void write_stub_64_from_8(address_space &space, offs_t offset, UINT64 data, UINT64 mask);
+	void write_stub_32_from_16(address_space &space, offs_t offset, UINT32 data, UINT32 mask);
+	void write_stub_64_from_16(address_space &space, offs_t offset, UINT64 data, UINT64 mask);
+	void write_stub_64_from_32(address_space &space, offs_t offset, UINT64 data, UINT64 mask);
+
+	// stubs for calling legacy write handlers
+	void write_stub_legacy(address_space &space, offs_t offset, UINT8 data, UINT8 mask);
+	void write_stub_legacy(address_space &space, offs_t offset, UINT16 data, UINT16 mask);
+	void write_stub_legacy(address_space &space, offs_t offset, UINT32 data, UINT32 mask);
+	void write_stub_legacy(address_space &space, offs_t offset, UINT64 data, UINT64 mask);
+
+	// stubs for writing I/O ports
+	template<typename _UintType>
+	void write_stub_ioport(address_space &space, offs_t offset, _UintType data, _UintType mask) { input_port_write_direct(m_ioport, data, mask); }
+
+	// internal state
+	write8_delegate				m_write8;
+	write16_delegate			m_write16;
+	write32_delegate			m_write32;
+	write64_delegate			m_write64;
+	const input_port_config *	m_ioport;
+
+	// unions to hold legacy objects and callbacks
+	union
+	{
+		address_space *	space;
+		device_t *				device;
+	} m_legacy_object;
+
+	union
+	{
+		write8_space_func		space8;
+		write16_space_func		space16;
+		write32_space_func		space32;
+		write64_space_func		space64;
+		write8_device_func		device8;
+		write16_device_func		device16;
+		write32_device_func		device32;
+		write64_device_func		device64;
+	} m_legacy_handler;
+};
 
 
-/*-------------------------------------------------
-    bank_references_space - return true if the
-    given bank is referenced by a particular
-    address space
--------------------------------------------------*/
+// ======================> address_table
 
-INLINE int bank_references_space(const bank_info *bank, const address_space *space)
+// address_table contains information about read/write accesses within an address space
+class address_table : public bindable_object
 {
-	bank_reference *ref;
+	// address map lookup table definitions
+	static const int LEVEL1_BITS	= 18;						// number of address bits in the level 1 table
+	static const int LEVEL2_BITS	= 32 - LEVEL1_BITS;			// number of address bits in the level 2 table
+	static const int SUBTABLE_COUNT	= 64;						// number of slots reserved for subtables
+	static const int SUBTABLE_BASE	= 256 - SUBTABLE_COUNT;		// first index of a subtable
+	static const int ENTRY_COUNT	= SUBTABLE_BASE;			// number of legitimate (non-subtable) entries
+	static const int SUBTABLE_ALLOC	= 8;						// number of subtables to allocate at a time
+
+	inline int level2_bits() const { return m_large ? LEVEL2_BITS : 0; }
+
+public:
+	// construction/destruction
+	address_table(address_space &space, bool large);
+	~address_table();
+
+	// getters
+	virtual handler_entry &handler(UINT32 index) const = 0;
+	bool watchpoints_enabled() const { return (m_live_lookup == s_watchpoint_table); }
+
+	// address lookups
+	UINT32 lookup_live(offs_t byteaddress) const { return m_large ? lookup_live_large(byteaddress) : lookup_live_small(byteaddress); }
+	UINT32 lookup_live_small(offs_t byteaddress) const { return m_live_lookup[byteaddress]; }
+
+	UINT32 lookup_live_large(offs_t byteaddress) const
+	{
+		UINT32 entry = m_live_lookup[level1_index_large(byteaddress)];
+		if (entry >= SUBTABLE_BASE)
+			entry = m_live_lookup[level2_index_large(entry, byteaddress)];
+		return entry;
+	}
 
-	for (ref = bank->reflist; ref != NULL; ref = ref->next)
-		if (ref->space == space)
-			return TRUE;
-	return FALSE;
-}
+	UINT32 lookup(offs_t byteaddress) const
+	{
+		UINT32 entry = m_live_lookup[level1_index(byteaddress)];
+		if (entry >= SUBTABLE_BASE)
+			entry = m_live_lookup[level2_index(entry, byteaddress)];
+		return entry;
+	}
+
+	// enable watchpoints by swapping in the watchpoint table
+	void enable_watchpoints(bool enable = true) { m_live_lookup = enable ? s_watchpoint_table : m_table; }
+
+	// table mapping helpers
+	UINT8 map_range(offs_t bytestart, offs_t byteend, offs_t bytemask, offs_t bytemirror, UINT8 staticentry = 0);
+	UINT8 derive_range(offs_t byteaddress, offs_t &bytestart, offs_t &byteend) const;
+
+	// misc helpers
+	void mask_all_handlers(offs_t mask);
+	const char *handler_name(UINT8 entry) const;
+
+protected:
+	// determine table indexes based on the address
+	UINT32 level1_index_large(offs_t address) const { return address >> LEVEL2_BITS; }
+	UINT32 level2_index_large(UINT8 l1entry, offs_t address) const { return (1 << LEVEL1_BITS) + ((l1entry - SUBTABLE_BASE) << LEVEL2_BITS) + (address & ((1 << LEVEL2_BITS) - 1)); }
+	UINT32 level1_index(offs_t address) const { return m_large ? level1_index_large(address) : address; }
+	UINT32 level2_index(UINT8 l1entry, offs_t address) const { return m_large ? level2_index_large(l1entry, address) : 0; }
+
+	// table population/depopulation
+	void populate_range_mirrored(offs_t bytestart, offs_t byteend, offs_t bytemirror, UINT8 handler);
+	void populate_range(offs_t bytestart, offs_t byteend, UINT8 handler);
+	void depopulate_unused();
+
+	// subtable management
+	UINT8 subtable_alloc();
+	void subtable_realloc(UINT8 subentry);
+	int subtable_merge();
+	void subtable_release(UINT8 subentry);
+	UINT8 *subtable_open(offs_t l1index);
+	void subtable_close(offs_t l1index);
+	UINT8 *subtable_ptr(UINT8 entry) { return &m_table[level2_index(entry, 0)]; }
+
+	// internal state
+	UINT8 *					m_table;					// pointer to base of table
+	UINT8 *					m_live_lookup;				// current lookup
+	address_space &			m_space;					// pointer back to the space
+	bool					m_large;					// large memory model?
+
+	// subtable_data is an internal class with information about each subtable
+	class subtable_data
+	{
+	public:
+		subtable_data()
+			: m_checksum_valid(false),
+			  m_checksum(0),
+			  m_usecount(0) { }
+
+		bool				m_checksum_valid;			// is the checksum valid
+		UINT32				m_checksum;					// checksum over all the bytes
+		UINT32				m_usecount;					// number of times this has been used
+	};
+	subtable_data *			m_subtable;					// info about each subtable
+	UINT8					m_subtable_alloc;			// number of subtables allocated
+
+	// static global read-only watchpoint table
+	static UINT8			s_watchpoint_table[1 << LEVEL1_BITS];
+};
 
 
-/*-------------------------------------------------
-    add_bank_reference - add a new address space
-    reference to a bank
--------------------------------------------------*/
+// ======================> address_table_read
 
-INLINE void add_bank_reference(bank_info *bank, const address_space *space)
+// read access-specific version of an address table
+class address_table_read : public address_table
 {
-	bank_reference **refptr;
+public:
+	// construction/destruction
+	address_table_read(address_space &space, bool large);
+	~address_table_read();
 
-	/* make sure we don't already have a reference to the bank */
-	for (refptr = &bank->reflist; *refptr != NULL; refptr = &(*refptr)->next)
-		if ((*refptr)->space == space)
-			return;
+	// getters
+	virtual handler_entry &handler(UINT32 index) const;
+	handler_entry_read &handler_read(UINT32 index) const { assert(index < ARRAY_LENGTH(m_handlers)); return *m_handlers[index]; }
 
-	/* allocate a new entry and fill it */
-	(*refptr) = auto_alloc(space->machine, bank_reference);
-	(*refptr)->next = NULL;
-	(*refptr)->space = space;
-}
+private:
+	// internal unmapped handler
+	template<typename _UintType>
+	_UintType unmap_r(address_space &space, offs_t offset, _UintType mask)
+	{
+		if (m_space.log_unmap() && !m_space.debugger_access())
+			logerror("%s: unmapped %s memory read from %s & %s\n",
+						cpuexec_describe_context(&m_space.m_machine), m_space.name(),
+						core_i64_hex_format(m_space.byte_to_address(offset * sizeof(_UintType)), m_space.addrchars()),
+						core_i64_hex_format(mask, 2 * sizeof(_UintType)));
+		return m_space.unmap();
+	}
 
+	// internal no-op handler
+	template<typename _UintType>
+	_UintType nop_r(address_space &space, offs_t offset, _UintType mask)
+	{
+		return m_space.unmap();
+	}
 
-/*-------------------------------------------------
-    read_byte_generic - read a byte from an
-    arbitrary address space
--------------------------------------------------*/
+	// internal watchpoint handler
+	template<typename _UintType>
+	_UintType watchpoint_r(address_space &space, offs_t offset, _UintType mask)
+	{
+		m_space.device().debug()->memory_read_hook(m_space, offset * sizeof(_UintType), mask);
 
-INLINE UINT8 read_byte_generic(const address_space *space, offs_t byteaddress)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-	UINT8 result;
+		UINT8 *oldtable = m_live_lookup;
+		m_live_lookup = m_table;
+		_UintType result;
+		if (sizeof(_UintType) == 1) result = m_space.read_byte(offset);
+		if (sizeof(_UintType) == 2) result = m_space.read_word(offset << 1, mask);
+		if (sizeof(_UintType) == 4) result = m_space.read_dword(offset << 2, mask);
+		if (sizeof(_UintType) == 8) result = m_space.read_qword(offset << 3, mask);
+		m_live_lookup = oldtable;
+		return result;
+	}
 
-	profiler_mark_start(PROFILER_MEMREAD);
+	// internal state
+	handler_entry_read *		m_handlers[256];		// array of user-installed handlers
+};
 
-	byteaddress &= space->bytemask;
-	entry = space->readlookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->readlookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->read.handlers[entry];
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-		result = (*handler->bankbaseptr)[byteoffset];
-	else
-		result = (*handler->handler.read.shandler8)((const address_space *)handler->object, byteoffset);
+// ======================> address_table_write
 
-	profiler_mark_end();
-	return result;
-}
+// write access-specific version of an address table
+class address_table_write : public address_table
+{
+public:
+	// construction/destruction
+	address_table_write(address_space &space, bool large);
+	~address_table_write();
 
+	// getters
+	virtual handler_entry &handler(UINT32 index) const;
+	handler_entry_write &handler_write(UINT32 index) const { assert(index < ARRAY_LENGTH(m_handlers)); return *m_handlers[index]; }
 
-/*-------------------------------------------------
-    write_byte_generic - write a byte to an
-    arbitrary address space
--------------------------------------------------*/
-
-INLINE void write_byte_generic(const address_space *space, offs_t byteaddress, UINT8 data)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-
-	profiler_mark_start(PROFILER_MEMWRITE);
-
-	byteaddress &= space->bytemask;
-	entry = space->writelookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->writelookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->write.handlers[entry];
-
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-		(*handler->bankbaseptr)[byteoffset] = data;
-	else
-		(*handler->handler.write.shandler8)((const address_space *)handler->object, byteoffset, data);
+private:
+	// internal handlers
+	template<typename _UintType>
+	void unmap_w(address_space &space, offs_t offset, _UintType data, _UintType mask)
+	{
+		if (m_space.log_unmap() && !m_space.debugger_access())
+			logerror("%s: unmapped %s memory write to %s = %s & %s\n",
+					cpuexec_describe_context(&m_space.m_machine), m_space.name(),
+					core_i64_hex_format(m_space.byte_to_address(offset * sizeof(_UintType)), m_space.addrchars()),
+					core_i64_hex_format(data, 2 * sizeof(_UintType)),
+					core_i64_hex_format(mask, 2 * sizeof(_UintType)));
+	}
 
-	profiler_mark_end();
-}
+	template<typename _UintType>
+	void nop_w(address_space &space, offs_t offset, _UintType data, _UintType mask)
+	{
+	}
 
+	template<typename _UintType>
+	void watchpoint_w(address_space &space, offs_t offset, _UintType data, _UintType mask)
+	{
+		m_space.device().debug()->memory_write_hook(m_space, offset * sizeof(_UintType), data, mask);
 
-/*-------------------------------------------------
-    read_word_generic - read a word from an
-    arbitrary address space
--------------------------------------------------*/
+		UINT8 *oldtable = m_live_lookup;
+		m_live_lookup = m_table;
+		if (sizeof(_UintType) == 1) m_space.write_byte(offset, data);
+		if (sizeof(_UintType) == 2) m_space.write_word(offset << 1, data, mask);
+		if (sizeof(_UintType) == 4) m_space.write_dword(offset << 2, data, mask);
+		if (sizeof(_UintType) == 8) m_space.write_qword(offset << 3, data, mask);
+		m_live_lookup = oldtable;
+	}
 
-INLINE UINT16 read_word_generic(const address_space *space, offs_t byteaddress, UINT16 mem_mask)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-	UINT16 result;
+	// internal state
+	handler_entry_write *		m_handlers[256];		// array of user-installed handlers
+};
 
-	profiler_mark_start(PROFILER_MEMREAD);
 
-	byteaddress &= space->bytemask;
-	entry = space->readlookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->readlookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->read.handlers[entry];
+// ======================> address_space_specific
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-		result = *(UINT16 *)&(*handler->bankbaseptr)[byteoffset & ~1];
-	else
-		result = (*handler->handler.read.shandler16)((const address_space *)handler->object, byteoffset >> 1, mem_mask);
+// this is a derived class of address_space with specific width, endianness, and table size
+template<typename _NativeType, endianness_t _Endian, bool _Large>
+class address_space_specific : public address_space
+{
+	typedef address_space_specific<_NativeType, _Endian, _Large> this_type;
+
+	// constants describing the native size
+	static const UINT32 NATIVE_BYTES = sizeof(_NativeType);
+	static const UINT32 NATIVE_MASK = NATIVE_BYTES - 1;
+	static const UINT32 NATIVE_BITS = 8 * NATIVE_BYTES;
+
+	// helpers to simplify core code
+	UINT32 read_lookup(offs_t byteaddress) const { return _Large ? m_read.lookup_live_large(byteaddress) : m_read.lookup_live_small(byteaddress); }
+	UINT32 write_lookup(offs_t byteaddress) const { return _Large ? m_write.lookup_live_large(byteaddress) : m_write.lookup_live_small(byteaddress); }
+
+public:
+	// construction/destruction
+	address_space_specific(device_memory_interface &memory, int spacenum)
+		: address_space(memory, spacenum, _Large),
+		  m_read(*this, _Large),
+		  m_write(*this, _Large)
+	{
+#if (TEST_HANDLER)
+		// test code to verify the read/write handlers are touching the correct bits
+		// and returning the correct results
+
+		// install some dummy RAM for the first 16 bytes with well-known values
+		UINT8 buffer[16];
+		for (int index = 0; index < 16; index++)
+			buffer[index ^ ((_Endian == ENDIANNESS_NATIVE) ? 0 : (data_width()/8 - 1))] = index * 0x11;
+		install_ram(0x00, 0x0f, 0x0f, 0, ROW_READWRITE, buffer);
+		printf("\n\naddress_space(%d, %s, %s)\n", NATIVE_BITS, (_Endian == ENDIANNESS_LITTLE) ? "little" : "big", _Large ? "large" : "small");
 
-	profiler_mark_end();
-	return result;
-}
+		// walk through the first 8 addresses
+		for (int address = 0; address < 8; address++)
+		{
+			// determine expected values
+			UINT64 expected64 = ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 7 : 0)) * 0x11) << 56) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 6 : 1)) * 0x11) << 48) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 5 : 2)) * 0x11) << 40) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 4 : 3)) * 0x11) << 32) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 3 : 4)) * 0x11) << 24) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 2 : 5)) * 0x11) << 16) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 1 : 6)) * 0x11) <<  8) |
+							    ((UINT64)((address + ((_Endian == ENDIANNESS_LITTLE) ? 0 : 7)) * 0x11) <<  0);
+			UINT32 expected32 = (_Endian == ENDIANNESS_LITTLE) ? expected64 : (expected64 >> 32);
+			UINT16 expected16 = (_Endian == ENDIANNESS_LITTLE) ? expected32 : (expected32 >> 16);
+			UINT8 expected8 = (_Endian == ENDIANNESS_LITTLE) ? expected16 : (expected16 >> 8);
+
+			UINT64 result64;
+			UINT32 result32;
+			UINT16 result16;
+			UINT8 result8;
+
+			// validate byte accesses
+			printf("\nAddress %d\n", address);
+			printf("   read_byte = "); printf("%02X\n", result8 = read_byte(address)); assert(result8 == expected8);
+
+			// validate word accesses (if aligned)
+			if (address % 2 == 0) { printf("   read_word = "); printf("%04X\n", result16 = read_word(address)); assert(result16 == expected16); }
+			if (address % 2 == 0) { printf("   read_word (0xff00) = "); printf("%04X\n", result16 = read_word(address, 0xff00)); assert((result16 & 0xff00) == (expected16 & 0xff00)); }
+			if (address % 2 == 0) { printf("             (0x00ff) = "); printf("%04X\n", result16 = read_word(address, 0x00ff)); assert((result16 & 0x00ff) == (expected16 & 0x00ff)); }
+
+			// validate unaligned word accesses
+			printf("   read_word_unaligned = "); printf("%04X\n", result16 = read_word_unaligned(address)); assert(result16 == expected16);
+			printf("   read_word_unaligned (0xff00) = "); printf("%04X\n", result16 = read_word_unaligned(address, 0xff00)); assert((result16 & 0xff00) == (expected16 & 0xff00));
+			printf("                       (0x00ff) = "); printf("%04X\n", result16 = read_word_unaligned(address, 0x00ff)); assert((result16 & 0x00ff) == (expected16 & 0x00ff));
+
+			// validate dword acceses (if aligned)
+			if (address % 4 == 0) { printf("   read_dword = "); printf("%08X\n", result32 = read_dword(address)); assert(result32 == expected32); }
+			if (address % 4 == 0) { printf("   read_dword (0xff000000) = "); printf("%08X\n", result32 = read_dword(address, 0xff000000)); assert((result32 & 0xff000000) == (expected32 & 0xff000000)); }
+			if (address % 4 == 0) { printf("              (0x00ff0000) = "); printf("%08X\n", result32 = read_dword(address, 0x00ff0000)); assert((result32 & 0x00ff0000) == (expected32 & 0x00ff0000)); }
+			if (address % 4 == 0) { printf("              (0x0000ff00) = "); printf("%08X\n", result32 = read_dword(address, 0x0000ff00)); assert((result32 & 0x0000ff00) == (expected32 & 0x0000ff00)); }
+			if (address % 4 == 0) { printf("              (0x000000ff) = "); printf("%08X\n", result32 = read_dword(address, 0x000000ff)); assert((result32 & 0x000000ff) == (expected32 & 0x000000ff)); }
+			if (address % 4 == 0) { printf("              (0xffff0000) = "); printf("%08X\n", result32 = read_dword(address, 0xffff0000)); assert((result32 & 0xffff0000) == (expected32 & 0xffff0000)); }
+			if (address % 4 == 0) { printf("              (0x0000ffff) = "); printf("%08X\n", result32 = read_dword(address, 0x0000ffff)); assert((result32 & 0x0000ffff) == (expected32 & 0x0000ffff)); }
+			if (address % 4 == 0) { printf("              (0xffffff00) = "); printf("%08X\n", result32 = read_dword(address, 0xffffff00)); assert((result32 & 0xffffff00) == (expected32 & 0xffffff00)); }
+			if (address % 4 == 0) { printf("              (0x00ffffff) = "); printf("%08X\n", result32 = read_dword(address, 0x00ffffff)); assert((result32 & 0x00ffffff) == (expected32 & 0x00ffffff)); }
+
+			// validate unaligned dword accesses
+			printf("   read_dword_unaligned = "); printf("%08X\n", result32 = read_dword_unaligned(address)); assert(result32 == expected32);
+			printf("   read_dword_unaligned (0xff000000) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0xff000000)); assert((result32 & 0xff000000) == (expected32 & 0xff000000));
+			printf("                        (0x00ff0000) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0x00ff0000)); assert((result32 & 0x00ff0000) == (expected32 & 0x00ff0000));
+			printf("                        (0x0000ff00) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0x0000ff00)); assert((result32 & 0x0000ff00) == (expected32 & 0x0000ff00));
+			printf("                        (0x000000ff) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0x000000ff)); assert((result32 & 0x000000ff) == (expected32 & 0x000000ff));
+			printf("                        (0xffff0000) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0xffff0000)); assert((result32 & 0xffff0000) == (expected32 & 0xffff0000));
+			printf("                        (0x0000ffff) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0x0000ffff)); assert((result32 & 0x0000ffff) == (expected32 & 0x0000ffff));
+			printf("                        (0xffffff00) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0xffffff00)); assert((result32 & 0xffffff00) == (expected32 & 0xffffff00));
+			printf("                        (0x00ffffff) = "); printf("%08X\n", result32 = read_dword_unaligned(address, 0x00ffffff)); assert((result32 & 0x00ffffff) == (expected32 & 0x00ffffff));
+
+			// validate qword acceses (if aligned)
+			if (address % 8 == 0) { printf("   read_qword = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address), 16)); assert(result64 == expected64); }
+			if (address % 8 == 0) { printf("   read_qword (0xff00000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xff00000000000000)), 16)); assert((result64 & U64(0xff00000000000000)) == (expected64 & U64(0xff00000000000000))); }
+			if (address % 8 == 0) { printf("              (0x00ff000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00ff000000000000)), 16)); assert((result64 & U64(0x00ff000000000000)) == (expected64 & U64(0x00ff000000000000))); }
+			if (address % 8 == 0) { printf("              (0x0000ff0000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ff0000000000)), 16)); assert((result64 & U64(0x0000ff0000000000)) == (expected64 & U64(0x0000ff0000000000))); }
+			if (address % 8 == 0) { printf("              (0x000000ff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000ff00000000)), 16)); assert((result64 & U64(0x000000ff00000000)) == (expected64 & U64(0x000000ff00000000))); }
+			if (address % 8 == 0) { printf("              (0x00000000ff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00000000ff000000)), 16)); assert((result64 & U64(0x00000000ff000000)) == (expected64 & U64(0x00000000ff000000))); }
+			if (address % 8 == 0) { printf("              (0x0000000000ff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000000000ff0000)), 16)); assert((result64 & U64(0x0000000000ff0000)) == (expected64 & U64(0x0000000000ff0000))); }
+			if (address % 8 == 0) { printf("              (0x000000000000ff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000000000ff00)), 16)); assert((result64 & U64(0x000000000000ff00)) == (expected64 & U64(0x000000000000ff00))); }
+			if (address % 8 == 0) { printf("              (0x00000000000000ff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00000000000000ff)), 16)); assert((result64 & U64(0x00000000000000ff)) == (expected64 & U64(0x00000000000000ff))); }
+			if (address % 8 == 0) { printf("              (0xffff000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffff000000000000)), 16)); assert((result64 & U64(0xffff000000000000)) == (expected64 & U64(0xffff000000000000))); }
+			if (address % 8 == 0) { printf("              (0x0000ffff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ffff00000000)), 16)); assert((result64 & U64(0x0000ffff00000000)) == (expected64 & U64(0x0000ffff00000000))); }
+			if (address % 8 == 0) { printf("              (0x00000000ffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00000000ffff0000)), 16)); assert((result64 & U64(0x00000000ffff0000)) == (expected64 & U64(0x00000000ffff0000))); }
+			if (address % 8 == 0) { printf("              (0x000000000000ffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000000000ffff)), 16)); assert((result64 & U64(0x000000000000ffff)) == (expected64 & U64(0x000000000000ffff))); }
+			if (address % 8 == 0) { printf("              (0xffffff0000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffffff0000000000)), 16)); assert((result64 & U64(0xffffff0000000000)) == (expected64 & U64(0xffffff0000000000))); }
+			if (address % 8 == 0) { printf("              (0x0000ffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ffffff000000)), 16)); assert((result64 & U64(0x0000ffffff000000)) == (expected64 & U64(0x0000ffffff000000))); }
+			if (address % 8 == 0) { printf("              (0x000000ffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000ffffff0000)), 16)); assert((result64 & U64(0x000000ffffff0000)) == (expected64 & U64(0x000000ffffff0000))); }
+			if (address % 8 == 0) { printf("              (0x0000000000ffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000000000ffffff)), 16)); assert((result64 & U64(0x0000000000ffffff)) == (expected64 & U64(0x0000000000ffffff))); }
+			if (address % 8 == 0) { printf("              (0xffffffff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffffffff00000000)), 16)); assert((result64 & U64(0xffffffff00000000)) == (expected64 & U64(0xffffffff00000000))); }
+			if (address % 8 == 0) { printf("              (0x00ffffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00ffffffff000000)), 16)); assert((result64 & U64(0x00ffffffff000000)) == (expected64 & U64(0x00ffffffff000000))); }
+			if (address % 8 == 0) { printf("              (0x0000ffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ffffffff0000)), 16)); assert((result64 & U64(0x0000ffffffff0000)) == (expected64 & U64(0x0000ffffffff0000))); }
+			if (address % 8 == 0) { printf("              (0x000000ffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000ffffffff00)), 16)); assert((result64 & U64(0x000000ffffffff00)) == (expected64 & U64(0x000000ffffffff00))); }
+			if (address % 8 == 0) { printf("              (0x00000000ffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00000000ffffffff)), 16)); assert((result64 & U64(0x00000000ffffffff)) == (expected64 & U64(0x00000000ffffffff))); }
+			if (address % 8 == 0) { printf("              (0xffffffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffffffffff000000)), 16)); assert((result64 & U64(0xffffffffff000000)) == (expected64 & U64(0xffffffffff000000))); }
+			if (address % 8 == 0) { printf("              (0x00ffffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00ffffffffff0000)), 16)); assert((result64 & U64(0x00ffffffffff0000)) == (expected64 & U64(0x00ffffffffff0000))); }
+			if (address % 8 == 0) { printf("              (0x0000ffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ffffffffff00)), 16)); assert((result64 & U64(0x0000ffffffffff00)) == (expected64 & U64(0x0000ffffffffff00))); }
+			if (address % 8 == 0) { printf("              (0x000000ffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x000000ffffffffff)), 16)); assert((result64 & U64(0x000000ffffffffff)) == (expected64 & U64(0x000000ffffffffff))); }
+			if (address % 8 == 0) { printf("              (0xffffffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffffffffffff0000)), 16)); assert((result64 & U64(0xffffffffffff0000)) == (expected64 & U64(0xffffffffffff0000))); }
+			if (address % 8 == 0) { printf("              (0x00ffffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00ffffffffffff00)), 16)); assert((result64 & U64(0x00ffffffffffff00)) == (expected64 & U64(0x00ffffffffffff00))); }
+			if (address % 8 == 0) { printf("              (0x0000ffffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x0000ffffffffffff)), 16)); assert((result64 & U64(0x0000ffffffffffff)) == (expected64 & U64(0x0000ffffffffffff))); }
+			if (address % 8 == 0) { printf("              (0xffffffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0xffffffffffffff00)), 16)); assert((result64 & U64(0xffffffffffffff00)) == (expected64 & U64(0xffffffffffffff00))); }
+			if (address % 8 == 0) { printf("              (0x00ffffffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword(address, U64(0x00ffffffffffffff)), 16)); assert((result64 & U64(0x00ffffffffffffff)) == (expected64 & U64(0x00ffffffffffffff))); }
+
+			// validate unaligned qword accesses
+			printf("   read_qword_unaligned = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address), 16)); assert(result64 == expected64);
+			printf("   read_qword_unaligned (0xff00000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xff00000000000000)), 16)); assert((result64 & U64(0xff00000000000000)) == (expected64 & U64(0xff00000000000000)));
+			printf("                        (0x00ff000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00ff000000000000)), 16)); assert((result64 & U64(0x00ff000000000000)) == (expected64 & U64(0x00ff000000000000)));
+			printf("                        (0x0000ff0000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ff0000000000)), 16)); assert((result64 & U64(0x0000ff0000000000)) == (expected64 & U64(0x0000ff0000000000)));
+			printf("                        (0x000000ff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000ff00000000)), 16)); assert((result64 & U64(0x000000ff00000000)) == (expected64 & U64(0x000000ff00000000)));
+			printf("                        (0x00000000ff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00000000ff000000)), 16)); assert((result64 & U64(0x00000000ff000000)) == (expected64 & U64(0x00000000ff000000)));
+			printf("                        (0x0000000000ff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000000000ff0000)), 16)); assert((result64 & U64(0x0000000000ff0000)) == (expected64 & U64(0x0000000000ff0000)));
+			printf("                        (0x000000000000ff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000000000ff00)), 16)); assert((result64 & U64(0x000000000000ff00)) == (expected64 & U64(0x000000000000ff00)));
+			printf("                        (0x00000000000000ff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00000000000000ff)), 16)); assert((result64 & U64(0x00000000000000ff)) == (expected64 & U64(0x00000000000000ff)));
+			printf("                        (0xffff000000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffff000000000000)), 16)); assert((result64 & U64(0xffff000000000000)) == (expected64 & U64(0xffff000000000000)));
+			printf("                        (0x0000ffff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ffff00000000)), 16)); assert((result64 & U64(0x0000ffff00000000)) == (expected64 & U64(0x0000ffff00000000)));
+			printf("                        (0x00000000ffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00000000ffff0000)), 16)); assert((result64 & U64(0x00000000ffff0000)) == (expected64 & U64(0x00000000ffff0000)));
+			printf("                        (0x000000000000ffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000000000ffff)), 16)); assert((result64 & U64(0x000000000000ffff)) == (expected64 & U64(0x000000000000ffff)));
+			printf("                        (0xffffff0000000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffffff0000000000)), 16)); assert((result64 & U64(0xffffff0000000000)) == (expected64 & U64(0xffffff0000000000)));
+			printf("                        (0x0000ffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ffffff000000)), 16)); assert((result64 & U64(0x0000ffffff000000)) == (expected64 & U64(0x0000ffffff000000)));
+			printf("                        (0x000000ffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000ffffff0000)), 16)); assert((result64 & U64(0x000000ffffff0000)) == (expected64 & U64(0x000000ffffff0000)));
+			printf("                        (0x0000000000ffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000000000ffffff)), 16)); assert((result64 & U64(0x0000000000ffffff)) == (expected64 & U64(0x0000000000ffffff)));
+			printf("                        (0xffffffff00000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffffffff00000000)), 16)); assert((result64 & U64(0xffffffff00000000)) == (expected64 & U64(0xffffffff00000000)));
+			printf("                        (0x00ffffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00ffffffff000000)), 16)); assert((result64 & U64(0x00ffffffff000000)) == (expected64 & U64(0x00ffffffff000000)));
+			printf("                        (0x0000ffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ffffffff0000)), 16)); assert((result64 & U64(0x0000ffffffff0000)) == (expected64 & U64(0x0000ffffffff0000)));
+			printf("                        (0x000000ffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000ffffffff00)), 16)); assert((result64 & U64(0x000000ffffffff00)) == (expected64 & U64(0x000000ffffffff00)));
+			printf("                        (0x00000000ffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00000000ffffffff)), 16)); assert((result64 & U64(0x00000000ffffffff)) == (expected64 & U64(0x00000000ffffffff)));
+			printf("                        (0xffffffffff000000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffffffffff000000)), 16)); assert((result64 & U64(0xffffffffff000000)) == (expected64 & U64(0xffffffffff000000)));
+			printf("                        (0x00ffffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00ffffffffff0000)), 16)); assert((result64 & U64(0x00ffffffffff0000)) == (expected64 & U64(0x00ffffffffff0000)));
+			printf("                        (0x0000ffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ffffffffff00)), 16)); assert((result64 & U64(0x0000ffffffffff00)) == (expected64 & U64(0x0000ffffffffff00)));
+			printf("                        (0x000000ffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x000000ffffffffff)), 16)); assert((result64 & U64(0x000000ffffffffff)) == (expected64 & U64(0x000000ffffffffff)));
+			printf("                        (0xffffffffffff0000) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffffffffffff0000)), 16)); assert((result64 & U64(0xffffffffffff0000)) == (expected64 & U64(0xffffffffffff0000)));
+			printf("                        (0x00ffffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00ffffffffffff00)), 16)); assert((result64 & U64(0x00ffffffffffff00)) == (expected64 & U64(0x00ffffffffffff00)));
+			printf("                        (0x0000ffffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x0000ffffffffffff)), 16)); assert((result64 & U64(0x0000ffffffffffff)) == (expected64 & U64(0x0000ffffffffffff)));
+			printf("                        (0xffffffffffffff00) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0xffffffffffffff00)), 16)); assert((result64 & U64(0xffffffffffffff00)) == (expected64 & U64(0xffffffffffffff00)));
+			printf("                        (0x00ffffffffffffff) = "); printf("%s\n", core_i64_hex_format(result64 = read_qword_unaligned(address, U64(0x00ffffffffffffff)), 16)); assert((result64 & U64(0x00ffffffffffffff)) == (expected64 & U64(0x00ffffffffffffff)));
+		}
+#endif
+	}
 
+	// accessors
+	virtual address_table_read &read() { return m_read; }
+	virtual address_table_write &write() { return m_write; }
 
-/*-------------------------------------------------
-    write_word_generic - write a word to an
-    arbitrary address space
--------------------------------------------------*/
-
-INLINE void write_word_generic(const address_space *space, offs_t byteaddress, UINT16 data, UINT16 mem_mask)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-
-	profiler_mark_start(PROFILER_MEMWRITE);
-
-	byteaddress &= space->bytemask;
-	entry = space->writelookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->writelookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->write.handlers[entry];
+	// watchpoint control
+	virtual void enable_read_watchpoints(bool enable = true) { m_read.enable_watchpoints(enable); }
+	virtual void enable_write_watchpoints(bool enable = true) { m_write.enable_watchpoints(enable); }
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
+	// generate accessor table
+	virtual void accessors(data_accessors &accessors) const
 	{
-		UINT16 *dest = (UINT16 *)&(*handler->bankbaseptr)[byteoffset & ~1];
-		*dest = (*dest & ~mem_mask) | (data & mem_mask);
+		accessors.read_byte = reinterpret_cast<UINT8 (*)(address_space *, offs_t)>(&read_byte_static);
+		accessors.read_word = reinterpret_cast<UINT16 (*)(address_space *, offs_t)>(&read_word_static);
+		accessors.read_word_masked = reinterpret_cast<UINT16 (*)(address_space *, offs_t, UINT16)>(&read_word_masked_static);
+		accessors.read_dword = reinterpret_cast<UINT32 (*)(address_space *, offs_t)>(&read_dword_static);
+		accessors.read_dword_masked = reinterpret_cast<UINT32 (*)(address_space *, offs_t, UINT32)>(&read_dword_masked_static);
+		accessors.read_qword = reinterpret_cast<UINT64 (*)(address_space *, offs_t)>(&read_qword_static);
+		accessors.read_qword_masked = reinterpret_cast<UINT64 (*)(address_space *, offs_t, UINT64)>(&read_qword_masked_static);
+		accessors.write_byte = reinterpret_cast<void (*)(address_space *, offs_t, UINT8)>(&write_byte_static);
+		accessors.write_word = reinterpret_cast<void (*)(address_space *, offs_t, UINT16)>(&write_word_static);
+		accessors.write_word_masked = reinterpret_cast<void (*)(address_space *, offs_t, UINT16, UINT16)>(&write_word_masked_static);
+		accessors.write_dword = reinterpret_cast<void (*)(address_space *, offs_t, UINT32)>(&write_dword_static);
+		accessors.write_dword_masked = reinterpret_cast<void (*)(address_space *, offs_t, UINT32, UINT32)>(&write_dword_masked_static);
+		accessors.write_qword = reinterpret_cast<void (*)(address_space *, offs_t, UINT64)>(&write_qword_static);
+		accessors.write_qword_masked = reinterpret_cast<void (*)(address_space *, offs_t, UINT64, UINT64)>(&write_qword_masked_static);
 	}
-	else
-		(*handler->handler.write.shandler16)((const address_space *)handler->object, byteoffset >> 1, data, mem_mask);
-
-	profiler_mark_end();
-}
 
+	// return a pointer to the read bank, or NULL if none
+	virtual void *get_read_ptr(offs_t byteaddress)
+	{
+		// perform the lookup
+		byteaddress &= m_bytemask;
+		UINT32 entry = read_lookup(byteaddress);
+		const handler_entry_read &handler = m_read.handler_read(entry);
 
-/*-------------------------------------------------
-    read_dword_generic - read a dword from an
-    arbitrary address space
--------------------------------------------------*/
+		// 8-bit case: RAM/ROM
+		if (entry >= STATIC_RAM)
+			return NULL;
+		return handler.ramptr(handler.byteoffset(byteaddress));
+	}
 
-INLINE UINT32 read_dword_generic(const address_space *space, offs_t byteaddress, UINT32 mem_mask)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-	UINT32 result;
+	// return a pointer to the write bank, or NULL if none
+	virtual void *get_write_ptr(offs_t byteaddress)
+	{
+		// perform the lookup
+		byteaddress &= m_bytemask;
+		UINT32 entry = read_lookup(byteaddress);
+		const handler_entry_write &handler = m_write.handler_write(entry);
 
-	profiler_mark_start(PROFILER_MEMREAD);
+		// 8-bit case: RAM/ROM
+		if (entry >= STATIC_RAM)
+			return NULL;
+		return handler.ramptr(handler.byteoffset(byteaddress));
+	}
 
-	byteaddress &= space->bytemask;
-	entry = space->readlookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->readlookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->read.handlers[entry];
+	// native read
+	_NativeType read_native(offs_t offset, _NativeType mask)
+	{
+		g_profiler.start(PROFILER_MEMREAD);
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-		result = *(UINT32 *)&(*handler->bankbaseptr)[byteoffset & ~3];
-	else
-		result = (*handler->handler.read.shandler32)((const address_space *)handler->object, byteoffset >> 2, mem_mask);
+		if (TEST_HANDLER) printf("[r%X,%s]", offset, core_i64_hex_format(mask, sizeof(_NativeType) * 2));
 
-	profiler_mark_end();
-	return result;
-}
+		// look up the handler
+		offs_t byteaddress = offset & m_bytemask;
+		UINT32 entry = read_lookup(byteaddress);
+		const handler_entry_read &handler = m_read.handler_read(entry);
 
+		// either read directly from RAM, or call the delegate
+		offset = handler.byteoffset(byteaddress);
+		_NativeType result;
+		if (entry < STATIC_RAM) result = *reinterpret_cast<_NativeType *>(handler.ramptr(offset));
+		else if (sizeof(_NativeType) == 1) result = handler.read8(*this, offset, mask);
+		else if (sizeof(_NativeType) == 2) result = handler.read16(*this, offset >> 1, mask);
+		else if (sizeof(_NativeType) == 4) result = handler.read32(*this, offset >> 2, mask);
+		else if (sizeof(_NativeType) == 8) result = handler.read64(*this, offset >> 3, mask);
 
-/*-------------------------------------------------
-    write_dword_generic - write a dword to an
-    arbitrary address space
--------------------------------------------------*/
-
-INLINE void write_dword_generic(const address_space *space, offs_t byteaddress, UINT32 data, UINT32 mem_mask)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-
-	profiler_mark_start(PROFILER_MEMWRITE);
-
-	byteaddress &= space->bytemask;
-	entry = space->writelookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->writelookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->write.handlers[entry];
+		g_profiler.stop();
+		return result;
+	}
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
+	// mask-less native read
+	_NativeType read_native(offs_t offset)
 	{
-		UINT32 *dest = (UINT32 *)&(*handler->bankbaseptr)[byteoffset & ~3];
-		*dest = (*dest & ~mem_mask) | (data & mem_mask);
-	}
-	else
-		(*handler->handler.write.shandler32)((const address_space *)handler->object, byteoffset >> 2, data, mem_mask);
+		g_profiler.start(PROFILER_MEMREAD);
 
-	profiler_mark_end();
-}
+		if (TEST_HANDLER) printf("[r%X]", offset);
 
+		// look up the handler
+		offs_t byteaddress = offset & m_bytemask;
+		UINT32 entry = read_lookup(byteaddress);
+		const handler_entry_read &handler = m_read.handler_read(entry);
 
-/*-------------------------------------------------
-    read_qword_generic - read a qword from an
-    arbitrary address space
--------------------------------------------------*/
+		// either read directly from RAM, or call the delegate
+		offset = handler.byteoffset(byteaddress);
+		_NativeType result;
+		if (entry < STATIC_RAM) result = *reinterpret_cast<_NativeType *>(handler.ramptr(offset));
+		else if (sizeof(_NativeType) == 1) result = handler.read8(*this, offset, 0xff);
+		else if (sizeof(_NativeType) == 2) result = handler.read16(*this, offset >> 1, 0xffff);
+		else if (sizeof(_NativeType) == 4) result = handler.read32(*this, offset >> 2, 0xffffffff);
+		else if (sizeof(_NativeType) == 8) result = handler.read64(*this, offset >> 3, U64(0xffffffffffffffff));
 
-INLINE UINT64 read_qword_generic(const address_space *space, offs_t byteaddress, UINT64 mem_mask)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT32 entry;
-	UINT64 result;
+		g_profiler.stop();
+		return result;
+	}
+
+	// native write
+	void write_native(offs_t offset, _NativeType data, _NativeType mask)
+	{
+		g_profiler.start(PROFILER_MEMWRITE);
 
-	profiler_mark_start(PROFILER_MEMREAD);
+		// look up the handler
+		offs_t byteaddress = offset & m_bytemask;
+		UINT32 entry = write_lookup(byteaddress);
+		const handler_entry_write &handler = m_write.handler_write(entry);
 
-	byteaddress &= space->bytemask;
-	entry = space->readlookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->readlookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->read.handlers[entry];
+		// either write directly to RAM, or call the delegate
+		offset = handler.byteoffset(byteaddress);
+		if (entry < STATIC_RAM)
+		{
+			_NativeType *dest = reinterpret_cast<_NativeType *>(handler.ramptr(offset));
+			*dest = (*dest & ~mask) | (data & mask);
+		}
+		else if (sizeof(_NativeType) == 1) handler.write8(*this, offset, data, mask);
+		else if (sizeof(_NativeType) == 2) handler.write16(*this, offset >> 1, data, mask);
+		else if (sizeof(_NativeType) == 4) handler.write32(*this, offset >> 2, data, mask);
+		else if (sizeof(_NativeType) == 8) handler.write64(*this, offset >> 3, data, mask);
 
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-		result = *(UINT64 *)&(*handler->bankbaseptr)[byteoffset & ~7];
-	else
-		result = (*handler->handler.read.shandler64)((const address_space *)handler->object, byteoffset >> 3, mem_mask);
+		g_profiler.stop();
+	}
 
-	profiler_mark_end();
-	return result;
-}
+	// mask-less native write
+	void write_native(offs_t offset, _NativeType data)
+	{
+		g_profiler.start(PROFILER_MEMWRITE);
 
+		// look up the handler
+		offs_t byteaddress = offset & m_bytemask;
+		UINT32 entry = write_lookup(byteaddress);
+		const handler_entry_write &handler = m_write.handler_write(entry);
 
-/*-------------------------------------------------
-    write_qword_generic - write a qword to an
-    arbitrary address space
--------------------------------------------------*/
-
-INLINE void write_qword_generic(const address_space *space, offs_t byteaddress, UINT64 data, UINT64 mem_mask)
-{
-	const handler_data *handler;
-	offs_t offset;
-	UINT32 entry;
-
-	profiler_mark_start(PROFILER_MEMWRITE);
-
-	byteaddress &= space->bytemask;
-	entry = space->writelookup[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->writelookup[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->write.handlers[entry];
+		// either write directly to RAM, or call the delegate
+		offset = handler.byteoffset(byteaddress);
+		if (entry < STATIC_RAM) *reinterpret_cast<_NativeType *>(handler.ramptr(offset)) = data;
+		else if (sizeof(_NativeType) == 1) handler.write8(*this, offset, data, 0xff);
+		else if (sizeof(_NativeType) == 2) handler.write16(*this, offset >> 1, data, 0xffff);
+		else if (sizeof(_NativeType) == 4) handler.write32(*this, offset >> 2, data, 0xffffffff);
+		else if (sizeof(_NativeType) == 8) handler.write64(*this, offset >> 3, data, U64(0xffffffffffffffff));
 
-	offset = (byteaddress - handler->bytestart) & handler->bytemask;
-	if (entry < STATIC_RAM)
-	{
-		UINT64 *dest = (UINT64 *)&(*handler->bankbaseptr)[offset & ~7];
-		*dest = (*dest & ~mem_mask) | (data & mem_mask);
+		g_profiler.stop();
 	}
-	else
-		(*handler->handler.write.shandler64)((const address_space *)handler->object, offset >> 3, data, mem_mask);
-
-	profiler_mark_end();
-}
 
+	// generic direct read
+	template<typename _TargetType, bool _Aligned>
+	_TargetType read_direct(offs_t address, _TargetType mask)
+	{
+		const UINT32 TARGET_BYTES = sizeof(_TargetType);
+		const UINT32 TARGET_BITS = 8 * TARGET_BYTES;
 
+		// equal to native size and aligned; simple pass-through to the native reader
+		if (NATIVE_BYTES == TARGET_BYTES && (_Aligned || (address & NATIVE_MASK) == 0))
+			return read_native(address & ~NATIVE_MASK, mask);
 
-/***************************************************************************
-    CORE SYSTEM OPERATIONS
-***************************************************************************/
+		// if native size is larger, see if we can do a single masked read (guaranteed if we're aligned)
+		if (NATIVE_BYTES > TARGET_BYTES)
+		{
+			UINT32 offsbits = 8 * (address & (NATIVE_BYTES - (_Aligned ? TARGET_BYTES : 1)));
+			if (_Aligned || (offsbits + TARGET_BITS <= NATIVE_BITS))
+			{
+				if (_Endian != ENDIANNESS_LITTLE) offsbits = NATIVE_BITS - TARGET_BITS - offsbits;
+				return read_native(address & ~NATIVE_MASK, (_NativeType)mask << offsbits) >> offsbits;
+			}
+		}
 
-/*-------------------------------------------------
-    memory_init - initialize the memory system
--------------------------------------------------*/
+		// determine our alignment against the native boundaries, and mask the address
+		UINT32 offsbits = 8 * (address & (NATIVE_BYTES - 1));
+		address &= ~NATIVE_MASK;
 
-void memory_init(running_machine *machine)
-{
-	memory_private *memdata;
+		// if we're here, and native size is larger or equal to the target, we need exactly 2 reads
+		if (NATIVE_BYTES >= TARGET_BYTES)
+		{
+			// little-endian case
+			if (_Endian == ENDIANNESS_LITTLE)
+			{
+				// read lower bits from lower address
+				_TargetType result = 0;
+				_NativeType curmask = (_NativeType)mask << offsbits;
+				if (curmask != 0) result = read_native(address, curmask) >> offsbits;
+
+				// read upper bits from upper address
+				offsbits = NATIVE_BITS - offsbits;
+				curmask = mask >> offsbits;
+				if (curmask != 0) result |= read_native(address + NATIVE_BYTES, curmask) << offsbits;
+				return result;
+			}
 
-	machine->add_notifier(MACHINE_NOTIFY_EXIT, memory_exit);
+			// big-endian case
+			else
+			{
+				// left-justify the mask to the target type
+				const UINT32 LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT = ((NATIVE_BITS >= TARGET_BITS) ? (NATIVE_BITS - TARGET_BITS) : 0);
+				_NativeType result = 0;
+				_NativeType ljmask = (_NativeType)mask << LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT;
+				_NativeType curmask = ljmask >> offsbits;
+
+				// read upper bits from lower address
+				if (curmask != 0) result = read_native(address, curmask) << offsbits;
+				offsbits = NATIVE_BITS - offsbits;
+
+				// read lower bits from upper address
+				curmask = ljmask << offsbits;
+				if (curmask != 0) result |= read_native(address + NATIVE_BYTES, curmask) >> offsbits;
 
-	/* allocate our private data */
-	memdata = machine->memory_data = auto_alloc_clear(machine, memory_private);
+				// return the un-justified result
+				return result >> LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT;
+			}
+		}
 
-	/* build up the list of address spaces */
-	memory_init_spaces(machine);
+		// if we're here, then we have 2 or more reads needed to get our final result
+		else
+		{
+			// compute the maximum number of loops; we do it this way so that there are
+			// a fixed number of loops for the compiler to unroll if it desires
+			const UINT32 MAX_SPLITS_MINUS_ONE = TARGET_BYTES / NATIVE_BYTES - 1;
+			_TargetType result = 0;
 
-	/* preflight the memory handlers and check banks */
-	memory_init_preflight(machine);
+			// little-endian case
+			if (_Endian == ENDIANNESS_LITTLE)
+			{
+				// read lowest bits from first address
+				_NativeType curmask = mask << offsbits;
+				if (curmask != 0) result = read_native(address, curmask) >> offsbits;
+
+				// read middle bits from subsequent addresses
+				offsbits = NATIVE_BITS - offsbits;
+				for (UINT32 index = 0; index < MAX_SPLITS_MINUS_ONE; index++)
+				{
+					address += NATIVE_BYTES;
+					curmask = mask >> offsbits;
+					if (curmask != 0) result |= (_TargetType)read_native(address, curmask) << offsbits;
+					offsbits += NATIVE_BITS;
+				}
 
-	/* then fill in the tables */
-	memory_init_populate(machine);
+				// if we're not aligned and we still have bits left, read uppermost bits from last address
+				if (!_Aligned && offsbits < TARGET_BITS)
+				{
+					curmask = mask >> offsbits;
+					if (curmask != 0) result |= (_TargetType)read_native(address + NATIVE_BYTES, curmask) << offsbits;
+				}
+			}
 
-	/* allocate any necessary memory */
-	memory_init_allocate(machine);
+			// big-endian case
+			else
+			{
+				// read highest bits from first address
+				offsbits = TARGET_BITS - (NATIVE_BITS - offsbits);
+				_NativeType curmask = mask >> offsbits;
+				if (curmask != 0) result = (_TargetType)read_native(address, curmask) << offsbits;
 
-	/* find all the allocated pointers */
-	memory_init_locate(machine);
+				// read middle bits from subsequent addresses
+				for (UINT32 index = 0; index < MAX_SPLITS_MINUS_ONE; index++)
+				{
+					offsbits -= NATIVE_BITS;
+					address += NATIVE_BYTES;
+					curmask = mask >> offsbits;
+					if (curmask != 0) result |= (_TargetType)read_native(address, curmask) << offsbits;
+				}
 
-	/* dump the final memory configuration */
-	mem_dump(machine);
+				// if we're not aligned and we still have bits left, read lowermost bits from the last address
+				if (!_Aligned && offsbits != 0)
+				{
+					offsbits = NATIVE_BITS - offsbits;
+					curmask = mask << offsbits;
+					if (curmask != 0) result |= read_native(address + NATIVE_BYTES, curmask) >> offsbits;
+				}
+			}
+			return result;
+		}
+	}
 
-	/* we are now initialized */
-	memdata->initialized = TRUE;
-}
+	// generic direct write
+	template<typename _TargetType, bool _Aligned>
+	void write_direct(offs_t address, _TargetType data, _TargetType mask)
+	{
+		const UINT32 TARGET_BYTES = sizeof(_TargetType);
+		const UINT32 TARGET_BITS = 8 * TARGET_BYTES;
+
+		// equal to native size and aligned; simple pass-through to the native writer
+		if (NATIVE_BYTES == TARGET_BYTES && (_Aligned || (address & NATIVE_MASK) == 0))
+			return write_native(address & ~NATIVE_MASK, data, mask);
 
+		// if native size is larger, see if we can do a single masked write (guaranteed if we're aligned)
+		if (NATIVE_BYTES > TARGET_BYTES)
+		{
+			UINT32 offsbits = 8 * (address & (NATIVE_BYTES - (_Aligned ? TARGET_BYTES : 1)));
+			if (_Aligned || (offsbits + TARGET_BITS <= NATIVE_BITS))
+			{
+				if (_Endian != ENDIANNESS_LITTLE) offsbits = NATIVE_BITS - TARGET_BITS - offsbits;
+				return write_native(address & ~NATIVE_MASK, (_NativeType)data << offsbits, (_NativeType)mask << offsbits);
+			}
+		}
 
+		// determine our alignment against the native boundaries, and mask the address
+		UINT32 offsbits = 8 * (address & (NATIVE_BYTES - 1));
+		address &= ~NATIVE_MASK;
 
-/***************************************************************************
-    DIRECT ACCESS CONTROL
-***************************************************************************/
+		// if we're here, and native size is larger or equal to the target, we need exactly 2 writes
+		if (NATIVE_BYTES >= TARGET_BYTES)
+		{
+			// little-endian case
+			if (_Endian == ENDIANNESS_LITTLE)
+			{
+				// write lower bits to lower address
+				_NativeType curmask = (_NativeType)mask << offsbits;
+				if (curmask != 0) write_native(address, (_NativeType)data << offsbits, curmask);
+
+				// write upper bits to upper address
+				offsbits = NATIVE_BITS - offsbits;
+				curmask = mask >> offsbits;
+				if (curmask != 0) write_native(address + NATIVE_BYTES, data >> offsbits, curmask);
+			}
 
-/*-------------------------------------------------
-    memory_set_decrypted_region - registers an
-    address range as having a decrypted data
-    pointer
--------------------------------------------------*/
-
-void memory_set_decrypted_region(const address_space *space, offs_t addrstart, offs_t addrend, void *base)
-{
-	offs_t bytestart = memory_address_to_byte(space, addrstart);
-	offs_t byteend = memory_address_to_byte_end(space, addrend);
-	int found = FALSE;
-	bank_info *bank;
+			// big-endian case
+			else
+			{
+				// left-justify the mask and data to the target type
+				const UINT32 LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT = ((NATIVE_BITS >= TARGET_BITS) ? (NATIVE_BITS - TARGET_BITS) : 0);
+				_NativeType ljdata = (_NativeType)data << LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT;
+				_NativeType ljmask = (_NativeType)mask << LEFT_JUSTIFY_TARGET_TO_NATIVE_SHIFT;
+
+				// write upper bits to lower address
+				_NativeType curmask = ljmask >> offsbits;
+				if (curmask != 0) write_native(address, ljdata >> offsbits, curmask);
+
+				// write lower bits to upper address
+				offsbits = NATIVE_BITS - offsbits;
+				curmask = ljmask << offsbits;
+				if (curmask != 0) write_native(address + NATIVE_BYTES, ljdata << offsbits, curmask);
+			}
+		}
 
-	/* loop over banks looking for a match */
-	for (bank = space->machine->memory_data->banklist; bank != NULL; bank = bank->next)
-	{
-		/* consider this bank if it is used for reading and matches the address space */
-		if (bank->read && bank_references_space(bank, space))
+		// if we're here, then we have 2 or more writes needed to get our final result
+		else
 		{
-			/* verify that the region fully covers the decrypted range */
-			if (bank->bytestart >= bytestart && bank->byteend <= byteend)
+			// compute the maximum number of loops; we do it this way so that there are
+			// a fixed number of loops for the compiler to unroll if it desires
+			const UINT32 MAX_SPLITS_MINUS_ONE = TARGET_BYTES / NATIVE_BYTES - 1;
+
+			// little-endian case
+			if (_Endian == ENDIANNESS_LITTLE)
 			{
-				/* set the decrypted pointer for the corresponding memory bank */
-				space->machine->memory_data->bankd_ptr[bank->index] = (UINT8 *)base + bank->bytestart - bytestart;
-				found = TRUE;
-
-				/* if we are executing from here, force an opcode base update */
-				if (space->direct.entry == bank->index)
-					force_opbase_update(space);
+				// write lowest bits to first address
+				_NativeType curmask = mask << offsbits;
+				if (curmask != 0) write_native(address, data << offsbits, curmask);
+
+				// write middle bits to subsequent addresses
+				offsbits = NATIVE_BITS - offsbits;
+				for (UINT32 index = 0; index < MAX_SPLITS_MINUS_ONE; index++)
+				{
+					address += NATIVE_BYTES;
+					curmask = mask >> offsbits;
+					if (curmask != 0) write_native(address, data >> offsbits, curmask);
+					offsbits += NATIVE_BITS;
+				}
+
+				// if we're not aligned and we still have bits left, write uppermost bits to last address
+				if (!_Aligned && offsbits < TARGET_BITS)
+				{
+					curmask = mask >> offsbits;
+					if (curmask != 0) write_native(address + NATIVE_BYTES, data >> offsbits, curmask);
+				}
 			}
 
-			/* fatal error if the decrypted region straddles the bank */
-			else if (bank->bytestart < byteend && bank->byteend > bytestart)
-				fatalerror("memory_set_decrypted_region found straddled region %08X-%08X for device '%s'", bytestart, byteend, space->cpu->tag());
+			// big-endian case
+			else
+			{
+				// write highest bits to first address
+				offsbits = TARGET_BITS - (NATIVE_BITS - offsbits);
+				_NativeType curmask = mask >> offsbits;
+				if (curmask != 0) write_native(address, data >> offsbits, curmask);
+
+				// write middle bits to subsequent addresses
+				for (UINT32 index = 0; index < MAX_SPLITS_MINUS_ONE; index++)
+				{
+					offsbits -= NATIVE_BITS;
+					address += NATIVE_BYTES;
+					curmask = mask >> offsbits;
+					if (curmask != 0) write_native(address, data >> offsbits, curmask);
+				}
+
+				// if we're not aligned and we still have bits left, write lowermost bits to the last address
+				if (!_Aligned && offsbits != 0)
+				{
+					offsbits = NATIVE_BITS - offsbits;
+					curmask = mask << offsbits;
+					if (curmask != 0) write_native(address + NATIVE_BYTES, data << offsbits, curmask);
+				}
+			}
 		}
 	}
 
-	/* fatal error as well if we didn't find any relevant memory banks */
-	if (!found)
-		fatalerror("memory_set_decrypted_region unable to find matching region %08X-%08X for device '%s'", bytestart, byteend, space->cpu->tag());
-}
+	// virtual access to these functions
+	UINT8 read_byte(offs_t address) { return (NATIVE_BITS == 8) ? read_native(address & ~NATIVE_MASK) : read_direct<UINT8, true>(address, 0xff); }
+	UINT16 read_word(offs_t address) { return (NATIVE_BITS == 16) ? read_native(address & ~NATIVE_MASK) : read_direct<UINT16, true>(address, 0xffff); }
+	UINT16 read_word(offs_t address, UINT16 mask) { return read_direct<UINT16, true>(address, mask); }
+	UINT16 read_word_unaligned(offs_t address) { return read_direct<UINT16, false>(address, 0xffff); }
+	UINT16 read_word_unaligned(offs_t address, UINT16 mask) { return read_direct<UINT16, false>(address, mask); }
+	UINT32 read_dword(offs_t address) { return (NATIVE_BITS == 32) ? read_native(address & ~NATIVE_MASK) : read_direct<UINT32, true>(address, 0xffffffff); }
+	UINT32 read_dword(offs_t address, UINT32 mask) { return read_direct<UINT32, true>(address, mask); }
+	UINT32 read_dword_unaligned(offs_t address) { return read_direct<UINT32, false>(address, 0xffffffff); }
+	UINT32 read_dword_unaligned(offs_t address, UINT32 mask) { return read_direct<UINT32, false>(address, mask); }
+	UINT64 read_qword(offs_t address) { return (NATIVE_BITS == 64) ? read_native(address & ~NATIVE_MASK) : read_direct<UINT64, true>(address, U64(0xffffffffffffffff)); }
+	UINT64 read_qword(offs_t address, UINT64 mask) { return read_direct<UINT64, true>(address, mask); }
+	UINT64 read_qword_unaligned(offs_t address) { return read_direct<UINT64, false>(address, U64(0xffffffffffffffff)); }
+	UINT64 read_qword_unaligned(offs_t address, UINT64 mask) { return read_direct<UINT64, false>(address, mask); }
+
+	void write_byte(offs_t address, UINT8 data) { if (NATIVE_BITS == 8) write_native(address & ~NATIVE_MASK, data); else write_direct<UINT8, true>(address, data, 0xff); }
+	void write_word(offs_t address, UINT16 data) { if (NATIVE_BITS == 16) write_native(address & ~NATIVE_MASK, data); else write_direct<UINT16, true>(address, data, 0xffff); }
+	void write_word(offs_t address, UINT16 data, UINT16 mask) { write_direct<UINT16, true>(address, data, mask); }
+	void write_word_unaligned(offs_t address, UINT16 data) { write_direct<UINT16, false>(address, data, 0xffff); }
+	void write_word_unaligned(offs_t address, UINT16 data, UINT16 mask) { write_direct<UINT16, false>(address, data, mask); }
+	void write_dword(offs_t address, UINT32 data) { if (NATIVE_BITS == 32) write_native(address & ~NATIVE_MASK, data); else write_direct<UINT32, true>(address, data, 0xffffffff); }
+	void write_dword(offs_t address, UINT32 data, UINT32 mask) { write_direct<UINT32, true>(address, data, mask); }
+	void write_dword_unaligned(offs_t address, UINT32 data) { write_direct<UINT32, false>(address, data, 0xffffffff); }
+	void write_dword_unaligned(offs_t address, UINT32 data, UINT32 mask) { write_direct<UINT32, false>(address, data, mask); }
+	void write_qword(offs_t address, UINT64 data) { if (NATIVE_BITS == 64) write_native(address & ~NATIVE_MASK, data); else write_direct<UINT64, true>(address, data, U64(0xffffffffffffffff)); }
+	void write_qword(offs_t address, UINT64 data, UINT64 mask) { write_direct<UINT64, true>(address, data, mask); }
+	void write_qword_unaligned(offs_t address, UINT64 data) { write_direct<UINT64, false>(address, data, U64(0xffffffffffffffff)); }
+	void write_qword_unaligned(offs_t address, UINT64 data, UINT64 mask) { write_direct<UINT64, false>(address, data, mask); }
+
+	// static access to these functions
+	static UINT8 read_byte_static(this_type *space, offs_t address) { return (NATIVE_BITS == 8) ? space->read_native(address & ~NATIVE_MASK) : space->read_direct<UINT8, true>(address, 0xff); }
+	static UINT16 read_word_static(this_type *space, offs_t address) { return (NATIVE_BITS == 16) ? space->read_native(address & ~NATIVE_MASK) : space->read_direct<UINT16, true>(address, 0xffff); }
+	static UINT16 read_word_masked_static(this_type *space, offs_t address, UINT16 mask) { return space->read_direct<UINT16, true>(address, mask); }
+	static UINT32 read_dword_static(this_type *space, offs_t address) { return (NATIVE_BITS == 32) ? space->read_native(address & ~NATIVE_MASK) : space->read_direct<UINT32, true>(address, 0xffffffff); }
+	static UINT32 read_dword_masked_static(this_type *space, offs_t address, UINT32 mask) { return space->read_direct<UINT32, true>(address, mask); }
+	static UINT64 read_qword_static(this_type *space, offs_t address) { return (NATIVE_BITS == 64) ? space->read_native(address & ~NATIVE_MASK) : space->read_direct<UINT64, true>(address, U64(0xffffffffffffffff)); }
+	static UINT64 read_qword_masked_static(this_type *space, offs_t address, UINT64 mask) { return space->read_direct<UINT64, true>(address, mask); }
+	static void write_byte_static(this_type *space, offs_t address, UINT8 data) { if (NATIVE_BITS == 8) space->write_native(address & ~NATIVE_MASK, data); else space->write_direct<UINT8, true>(address, data, 0xff); }
+	static void write_word_static(this_type *space, offs_t address, UINT16 data) { if (NATIVE_BITS == 16) space->write_native(address & ~NATIVE_MASK, data); else space->write_direct<UINT16, true>(address, data, 0xffff); }
+	static void write_word_masked_static(this_type *space, offs_t address, UINT16 data, UINT16 mask) { space->write_direct<UINT16, true>(address, data, mask); }
+	static void write_dword_static(this_type *space, offs_t address, UINT32 data) { if (NATIVE_BITS == 32) space->write_native(address & ~NATIVE_MASK, data); else space->write_direct<UINT32, true>(address, data, 0xffffffff); }
+	static void write_dword_masked_static(this_type *space, offs_t address, UINT32 data, UINT32 mask) { space->write_direct<UINT32, true>(address, data, mask); }
+	static void write_qword_static(this_type *space, offs_t address, UINT64 data) { if (NATIVE_BITS == 64) space->write_native(address & ~NATIVE_MASK, data); else space->write_direct<UINT64, true>(address, data, U64(0xffffffffffffffff)); }
+	static void write_qword_masked_static(this_type *space, offs_t address, UINT64 data, UINT64 mask) { space->write_direct<UINT64, true>(address, data, mask); }
 
+	address_table_read		m_read;				// memory read lookup table
+	address_table_write		m_write;			// memory write lookup table
+};
+
+typedef address_space_specific<UINT8,  ENDIANNESS_LITTLE, false> address_space_8le_small;
+typedef address_space_specific<UINT8,  ENDIANNESS_BIG,    false> address_space_8be_small;
+typedef address_space_specific<UINT16, ENDIANNESS_LITTLE, false> address_space_16le_small;
+typedef address_space_specific<UINT16, ENDIANNESS_BIG,    false> address_space_16be_small;
+typedef address_space_specific<UINT32, ENDIANNESS_LITTLE, false> address_space_32le_small;
+typedef address_space_specific<UINT32, ENDIANNESS_BIG,    false> address_space_32be_small;
+typedef address_space_specific<UINT64, ENDIANNESS_LITTLE, false> address_space_64le_small;
+typedef address_space_specific<UINT64, ENDIANNESS_BIG,    false> address_space_64be_small;
+
+typedef address_space_specific<UINT8,  ENDIANNESS_LITTLE, true> address_space_8le_large;
+typedef address_space_specific<UINT8,  ENDIANNESS_BIG,    true> address_space_8be_large;
+typedef address_space_specific<UINT16, ENDIANNESS_LITTLE, true> address_space_16le_large;
+typedef address_space_specific<UINT16, ENDIANNESS_BIG,    true> address_space_16be_large;
+typedef address_space_specific<UINT32, ENDIANNESS_LITTLE, true> address_space_32le_large;
+typedef address_space_specific<UINT32, ENDIANNESS_BIG,    true> address_space_32be_large;
+typedef address_space_specific<UINT64, ENDIANNESS_LITTLE, true> address_space_64le_large;
+typedef address_space_specific<UINT64, ENDIANNESS_BIG,    true> address_space_64be_large;
 
-/*-------------------------------------------------
-    memory_set_direct_update_handler - register a
-    handler for opcode base changes on a given
-    device
--------------------------------------------------*/
 
-direct_update_func memory_set_direct_update_handler(const address_space *space, direct_update_func function)
+// ======================> _memory_private
+
+// holds internal state for the memory system
+struct _memory_private
 {
-	address_space *spacerw = (address_space *)space;
-	direct_update_func old = spacerw->directupdate;
-	spacerw->directupdate = function;
-	return old;
-}
+	bool					initialized;					// have we completed initialization?
 
+	UINT8 *					bank_ptr[STATIC_COUNT];			// array of bank pointers
+	UINT8 *					bankd_ptr[STATIC_COUNT];		// array of decrypted bank pointers
 
-/*-------------------------------------------------
-    memory_set_direct_region - called by device
-    cores to update the opcode base for the given
-    address
--------------------------------------------------*/
-
-int memory_set_direct_region(const address_space *space, offs_t *byteaddress)
-{
-	memory_private *memdata = space->machine->memory_data;
-	address_space *spacerw = (address_space *)space;
-	UINT8 *base = NULL, *based = NULL;
-	const handler_data *handlers;
-	direct_range *range;
-	offs_t maskedbits;
-	offs_t overrideaddress = *byteaddress;
-	UINT8 entry;
+	simple_list<address_space> spacelist;					// list of address spaces
+	simple_list<memory_block> blocklist;					// head of the list of memory blocks
 
-	/* allow overrides */
-	if (spacerw->directupdate != NULL)
-	{
-		overrideaddress = (*spacerw->directupdate)(spacerw, overrideaddress, &spacerw->direct);
-		if (overrideaddress == ~0)
-			return TRUE;
+	simple_list<memory_bank> banklist;						// data gathered for each bank
+	tagmap_t<memory_bank *>	bankmap;						// map for fast bank lookups
+	UINT8					banknext;						// next bank to allocate
 
-		*byteaddress = overrideaddress;
-	}
+	tagmap_t<void *>		sharemap;						// map for share lookups
+};
 
-	/* remove the masked bits (we'll put them back later) */
-	maskedbits = overrideaddress & ~spacerw->bytemask;
 
-	/* find or allocate a matching range */
-	range = direct_range_find(spacerw, overrideaddress, &entry);
 
-	/* keep track of current entry */
-	spacerw->direct.entry = entry;
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-	/* if we don't map to a bank, return FALSE */
-	if (entry < STATIC_BANK1 || entry >= STATIC_RAM)
-	{
-		/* ensure future updates to land here as well until we get back into a bank */
-		spacerw->direct.byteend = 0;
-		spacerw->direct.bytestart = 1;
-		return FALSE;
-	}
+// global watchpoint table
+UINT8 address_table::s_watchpoint_table[1 << LEVEL1_BITS];
 
-	/* if no decrypted opcodes, point to the same base */
-	base = memdata->bank_ptr[entry];
-	based = memdata->bankd_ptr[entry];
-	if (based == NULL)
-		based = base;
 
-	/* compute the adjusted base */
-	handlers = spacerw->read.handlers[entry];
-	spacerw->direct.bytemask = handlers->bytemask;
-	spacerw->direct.raw = base - (handlers->bytestart & spacerw->direct.bytemask);
-	spacerw->direct.decrypted = based - (handlers->bytestart & spacerw->direct.bytemask);
-	spacerw->direct.bytestart = maskedbits | range->bytestart;
-	spacerw->direct.byteend = maskedbits | range->byteend;
-	return TRUE;
-}
 
+//**************************************************************************
+//  FUNCTION PROTOTYPES
+//**************************************************************************
+
+// banking helpers
+static STATE_POSTLOAD( bank_reattach );
+
+// debugging
+static void generate_memdump(running_machine *machine);
 
-/*-------------------------------------------------
-    memory_get_read_ptr - return a pointer the
-    memory byte provided in the given address
-    space, or NULL if it is not mapped to a bank
--------------------------------------------------*/
-
-void *memory_get_read_ptr(const address_space *space, offs_t byteaddress)
-{
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT8 entry;
-
-	/* perform the lookup */
-	byteaddress &= space->bytemask;
-	entry = space->read.table[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->read.table[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->read.handlers[entry];
 
-	/* 8-bit case: RAM/ROM */
-	if (entry >= STATIC_RAM)
-		return NULL;
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	return &(*handler->bankbaseptr)[byteoffset];
-}
 
+//**************************************************************************
+//  CORE SYSTEM OPERATIONS
+//**************************************************************************
 
-/*-------------------------------------------------
-    memory_get_write_ptr - return a pointer the
-    memory byte provided in the given address
-    space, or NULL if it is not mapped to a
-    writeable bank
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_init - initialize the memory system
+//-------------------------------------------------
 
-void *memory_get_write_ptr(const address_space *space, offs_t byteaddress)
+void memory_init(running_machine *machine)
 {
-	const handler_data *handler;
-	offs_t byteoffset;
-	UINT8 entry;
+	// allocate our private data
+	memory_private *memdata = machine->memory_data = auto_alloc_clear(machine, memory_private);
+	memdata->banknext = STATIC_BANK1;
+
+	// loop over devices and spaces within each device
+	device_memory_interface *memory = NULL;
+	for (bool gotone = machine->m_devicelist.first(memory); gotone; gotone = memory->next(memory))
+		for (int spacenum = 0; spacenum < ADDRESS_SPACES; spacenum++)
+		{
+			// if there is a configuration for this space, we need an address space
+			const address_space_config *spaceconfig = memory->space_config(spacenum);
+			if (spaceconfig != NULL)
+				memdata->spacelist.append(address_space::allocate(*machine, *spaceconfig, *memory, spacenum));
+		}
 
-	/* perform the lookup */
-	byteaddress &= space->bytemask;
-	entry = space->write.table[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = space->write.table[LEVEL2_INDEX(entry, byteaddress)];
-	handler = space->write.handlers[entry];
+	// construct and preprocess the address_map for each space
+	for (address_space *space = memdata->spacelist.first(); space != NULL; space = space->next())
+		space->prepare_map();
+
+	// create the handlers from the resulting address maps
+	for (address_space *space = memdata->spacelist.first(); space != NULL; space = space->next())
+		space->populate_from_map();
+
+	// allocate memory needed to back each address space
+	for (address_space *space = memdata->spacelist.first(); space != NULL; space = space->next())
+		space->allocate_memory();
+
+	// find all the allocated pointers
+	for (address_space *space = memdata->spacelist.first(); space != NULL; space = space->next())
+		space->locate_memory();
 
-	/* 8-bit case: RAM/ROM */
-	if (entry >= STATIC_RAM)
-		return NULL;
-	byteoffset = (byteaddress - handler->bytestart) & handler->bytemask;
-	return &(*handler->bankbaseptr)[byteoffset];
+	// register a callback to reset banks when reloading state
+	state_save_register_postload(machine, bank_reattach, NULL);
+
+	// dump the final memory configuration
+	generate_memdump(machine);
+
+	// borrow the first address space to be used as a dummy space
+	machine->m_nonspecific_space = memdata->spacelist.first();
+
+	// we are now initialized
+	memdata->initialized = true;
 }
 
 
 
-/***************************************************************************
-    MEMORY BANKING
-***************************************************************************/
+//**************************************************************************
+//  MEMORY BANKING
+//**************************************************************************
 
-/*-------------------------------------------------
-    memory_configure_bank - configure the
-    addresses for a bank
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_configure_bank - configure the
+//  addresses for a bank
+//-------------------------------------------------
 
 void memory_configure_bank(running_machine *machine, const char *tag, int startentry, int numentries, void *base, offs_t stride)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank = memdata->bankmap.find_hash_only(tag);
-	int entrynum;
-
-	/* validation checks */
+	// validation checks
+	memory_bank *bank = machine->memory_data->bankmap.find_hash_only(tag);
 	if (bank == NULL)
 		fatalerror("memory_configure_bank called for unknown bank '%s'", tag);
-	if (startentry < 0 || startentry + numentries > MAX_BANK_ENTRIES)
-		fatalerror("memory_configure_bank called with out-of-range entries %d-%d", startentry, startentry + numentries - 1);
-	if (!base)
+	if (base == NULL)
 		fatalerror("memory_configure_bank called NULL base");
 
-	/* fill in the requested bank entries */
-	for (entrynum = startentry; entrynum < startentry + numentries; entrynum++)
-		bank->entry[entrynum] = (UINT8 *)base + (entrynum - startentry) * stride;
-
-	/* if we have no bankptr yet, set it to the first entry */
-	if (memdata->bank_ptr[bank->index] == NULL)
-		memdata->bank_ptr[bank->index] = (UINT8 *)bank->entry[0];
+	// fill in the requested bank entries (backwards to improve allocation)
+	for (int entrynum = startentry + numentries - 1; entrynum >= startentry; entrynum--)
+		bank->configure(entrynum, reinterpret_cast<UINT8 *>(base) + (entrynum - startentry) * stride);
 }
 
 
-/*-------------------------------------------------
-    memory_configure_bank_decrypted - configure
-    the decrypted addresses for a bank
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_configure_bank_decrypted - configure
+//  the decrypted addresses for a bank
+//-------------------------------------------------
 
 void memory_configure_bank_decrypted(running_machine *machine, const char *tag, int startentry, int numentries, void *base, offs_t stride)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank = memdata->bankmap.find_hash_only(tag);
-	int entrynum;
-
-	/* validation checks */
+	// validation checks
+	memory_bank *bank = machine->memory_data->bankmap.find_hash_only(tag);
 	if (bank == NULL)
 		fatalerror("memory_configure_bank_decrypted called for unknown bank '%s'", tag);
-	if (startentry < 0 || startentry + numentries > MAX_BANK_ENTRIES)
-		fatalerror("memory_configure_bank_decrypted called with out-of-range entries %d-%d", startentry, startentry + numentries - 1);
-	if (!base)
+	if (base == NULL)
 		fatalerror("memory_configure_bank_decrypted called NULL base");
 
-	/* fill in the requested bank entries */
-	for (entrynum = startentry; entrynum < startentry + numentries; entrynum++)
-		bank->entryd[entrynum] = (UINT8 *)base + (entrynum - startentry) * stride;
-
-	/* if we have no bankptr yet, set it to the first entry */
-	if (memdata->bankd_ptr[bank->index] == NULL)
-		memdata->bankd_ptr[bank->index] = (UINT8 *)bank->entryd[0];
+	// fill in the requested bank entries (backwards to improve allocation)
+	for (int entrynum = startentry + numentries - 1; entrynum >= startentry; entrynum--)
+		bank->configure_decrypted(entrynum, reinterpret_cast<UINT8 *>(base) + (entrynum - startentry) * stride);
 }
 
 
-/*-------------------------------------------------
-    memory_set_bank - select one pre-configured
-    entry to be the new bank base
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_set_bank - select one pre-configured
+//  entry to be the new bank base
+//-------------------------------------------------
 
 void memory_set_bank(running_machine *machine, const char *tag, int entrynum)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank = memdata->bankmap.find_hash_only(tag);
-	bank_reference *ref;
-
-	/* validation checks */
+	// validation checks
+	memory_bank *bank = machine->memory_data->bankmap.find_hash_only(tag);
 	if (bank == NULL)
 		fatalerror("memory_set_bank called for unknown bank '%s'", tag);
-	if (entrynum < 0 || entrynum > MAX_BANK_ENTRIES)
-		fatalerror("memory_set_bank called with out-of-range entry %d", entrynum);
-	if (!bank->entry[entrynum])
-		fatalerror("memory_set_bank called for bank '%s' with invalid bank entry %d", tag, entrynum);
-
-	/* set the base */
-	bank->curentry = entrynum;
-	memdata->bank_ptr[bank->index] = (UINT8 *)bank->entry[entrynum];
-	memdata->bankd_ptr[bank->index] = (UINT8 *)bank->entryd[entrynum];
-
-	/* invalidate all the direct references to any referenced address spaces */
-	for (ref = bank->reflist; ref != NULL; ref = ref->next)
-		force_opbase_update(ref->space);
+
+	// set the base
+	bank->set_entry(entrynum);
 }
 
 
-/*-------------------------------------------------
-    memory_get_bank - return the currently
-    selected bank
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_get_bank - return the currently
+//  selected bank
+//-------------------------------------------------
 
 int memory_get_bank(running_machine *machine, const char *tag)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank = memdata->bankmap.find_hash_only(tag);
-
-	/* validation checks */
+	// validation checks
+	memory_bank *bank = machine->memory_data->bankmap.find_hash_only(tag);
 	if (bank == NULL)
 		fatalerror("memory_get_bank called for unknown bank '%s'", tag);
-	return bank->curentry;
+
+	// return the current entry
+	return bank->entry();
 }
 
 
-/*-------------------------------------------------
-    memory_set_bankptr - set the base of a bank
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_set_bankptr - set the base of a bank
+//-------------------------------------------------
 
 void memory_set_bankptr(running_machine *machine, const char *tag, void *base)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank = memdata->bankmap.find_hash_only(tag);
-	bank_reference *ref;
-
-	/* validation checks */
+	// validation checks
+	memory_bank *bank = machine->memory_data->bankmap.find_hash_only(tag);
 	if (bank == NULL)
-		fatalerror("memory_set_bankptr called for unknown bank '%s'", tag);
-	if (base == NULL)
-		fatalerror("memory_set_bankptr called NULL base");
-//  if (ALLOW_ONLY_AUTO_MALLOC_BANKS)
-//      validate_auto_malloc_memory(base, bank->byteend - bank->bytestart + 1);
-
-	/* set the base */
-	memdata->bank_ptr[bank->index] = (UINT8 *)base;
+		throw emu_fatalerror("memory_set_bankptr called for unknown bank '%s'", tag);
 
-	/* invalidate all the direct references to any referenced address spaces */
-	for (ref = bank->reflist; ref != NULL; ref = ref->next)
-		force_opbase_update(ref->space);
+	// set the base
+	bank->set_base(base);
 }
 
 
+//-------------------------------------------------
+//  memory_dump - dump the internal memory tables
+//  to the given file
+//-------------------------------------------------
 
-/***************************************************************************
-    DYNAMIC ADDRESS SPACE MAPPING
-***************************************************************************/
+void memory_dump(running_machine *machine, FILE *file)
+{
+	// skip if we can't open the file
+	if (file == NULL)
+		return;
 
-/*-------------------------------------------------
-    _memory_install_handler - install a new memory
-    handler into the given address space,
-    returning a pointer to the memory backing it,
-    if present
--------------------------------------------------*/
-
-#ifdef UNUSED_CODE
-void *_memory_install_handler(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, FPTR rhandler, FPTR whandler)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler >= STATIC_COUNT)
-		fatalerror("Attempted to install non-static read handler via memory_install_handler() in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler >= STATIC_COUNT)
-		fatalerror("Attempted to install non-static write handler via memory_install_handler() in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != 0)
-		space_map_range(spacerw, ROW_READ, spacerw->dbits, 0, addrstart, addrend, addrmask, addrmirror, (genf *)(FPTR)rhandler, spacerw, NULL);
-	if (whandler != 0)
-		space_map_range(spacerw, ROW_WRITE, spacerw->dbits, 0, addrstart, addrend, addrmask, addrmirror, (genf *)(FPTR)whandler, spacerw, NULL);
-	mem_dump(space->machine);
-	return space_find_backing_memory(spacerw, addrstart, addrend);
+	// loop over address spaces
+	for (address_space *space = machine->memory_data->spacelist.first(); space != NULL; space = space->next())
+	{
+		fprintf(file, "\n\n"
+		              "====================================================\n"
+		              "Device '%s' %s address space read handler dump\n"
+		              "====================================================\n", space->device().tag(), space->name());
+		space->dump_map(file, ROW_READ);
+
+		fprintf(file, "\n\n"
+		              "====================================================\n"
+		              "Device '%s' %s address space write handler dump\n"
+		              "====================================================\n", space->device().tag(), space->name());
+		space->dump_map(file, ROW_WRITE);
+	}
 }
-#endif
 
 
-/*-------------------------------------------------
-    _memory_install_handler8 - same as above but
-    explicitly for 8-bit handlers
--------------------------------------------------*/
-
-UINT8 *_memory_install_handler8(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rhandler_name, write8_space_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 8, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, spacerw, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 8, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, spacerw, whandler_name);
-	mem_dump(space->machine);
-	return (UINT8 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_handler16 - same as above but
-    explicitly for 16-bit handlers
--------------------------------------------------*/
-
-UINT16 *_memory_install_handler16(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rhandler_name, write16_space_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 16, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, spacerw, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 16, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, spacerw, whandler_name);
-	mem_dump(space->machine);
-	return (UINT16 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_handler32 - same as above but
-    explicitly for 32-bit handlers
--------------------------------------------------*/
-
-UINT32 *_memory_install_handler32(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rhandler_name, write32_space_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 32, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, spacerw, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 32, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, spacerw, whandler_name);
-	mem_dump(space->machine);
-	return (UINT32 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_handler64 - same as above but
-    explicitly for 64-bit handlers
--------------------------------------------------*/
-
-UINT64 *_memory_install_handler64(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rhandler_name, write64_space_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler in space %s of device '%s'\n", space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 64, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, spacerw, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 64, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, spacerw, whandler_name);
-	mem_dump(space->machine);
-	return (UINT64 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_device_handler8 - same as above
-    but explicitly for 8-bit handlers
--------------------------------------------------*/
-
-UINT8 *_memory_install_device_handler8(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rhandler_name, write8_device_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 8, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, (void *)device, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 8, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, (void *)device, whandler_name);
-	mem_dump(space->machine);
-	return (UINT8 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_device_handler16 - same as
-    above but explicitly for 16-bit handlers
--------------------------------------------------*/
-
-UINT16 *_memory_install_device_handler16(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rhandler_name, write16_device_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 16, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, (void *)device, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 16, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, (void *)device, whandler_name);
-	mem_dump(space->machine);
-	return (UINT16 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_device_handler32 - same as
-    above but explicitly for 32-bit handlers
--------------------------------------------------*/
-
-UINT32 *_memory_install_device_handler32(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rhandler_name, write32_device_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 32, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, (void *)device, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 32, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, (void *)device, whandler_name);
-	mem_dump(space->machine);
-	return (UINT32 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_device_handler64 - same as
-    above but explicitly for 64-bit handlers
--------------------------------------------------*/
-
-UINT64 *_memory_install_device_handler64(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rhandler_name, write64_device_func whandler, const char *whandler_name, int handlerunitmask)
-{
-	address_space *spacerw = (address_space *)space;
-	if (rhandler != NULL && (FPTR)rhandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid read handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (whandler != NULL && (FPTR)whandler < STATIC_COUNT)
-		fatalerror("Attempted to install invalid write handler for device '%s' in space %s of device '%s'\n", device->tag(), space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-	if (rhandler != NULL)
-		space_map_range(spacerw, ROW_READ, 64, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)rhandler, (void *)device, rhandler_name);
-	if (whandler != NULL)
-		space_map_range(spacerw, ROW_WRITE, 64, handlerunitmask, addrstart, addrend, addrmask, addrmirror, (genf *)whandler, (void *)device, whandler_name);
-	mem_dump(space->machine);
-	return (UINT64 *)space_find_backing_memory(spacerw, addrstart, addrend);
-}
-
-
-/*-------------------------------------------------
-    _memory_install_port - install a
-    new port handler into the given address space
--------------------------------------------------*/
-
-void _memory_install_port(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag)
-{
-	address_space *spacerw = (address_space *)space;
-	genf *rhandler = NULL;
-	genf *whandler = NULL;
-
-	/* pick the appropriate read/write handlers */
-	switch (space->dbits)
-	{
-		case 8:		rhandler = (genf *)input_port_read8;	whandler = (genf *)input_port_write8;	break;
-		case 16:	rhandler = (genf *)input_port_read16;	whandler = (genf *)input_port_write16;	break;
-		case 32:	rhandler = (genf *)input_port_read32;	whandler = (genf *)input_port_write32;	break;
-		case 64:	rhandler = (genf *)input_port_read64;	whandler = (genf *)input_port_write64;	break;
-	}
+//-------------------------------------------------
+//  generate_memdump - internal memory dump
+//-------------------------------------------------
 
-	/* assign the read handler */
-	if (rtag != NULL)
+static void generate_memdump(running_machine *machine)
+{
+	if (MEM_DUMP)
 	{
-		const input_port_config *port = space->machine->port(rtag);
-		if (port == NULL)
-			fatalerror("Attempted to map non-existent port '%s' for read in space %s of device '%s'\n", rtag, space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-		space_map_range(spacerw, ROW_READ, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, rhandler, (void *)port, rtag);
-	}
-
-	/* assign the write handler */
-	if (wtag != NULL)
-	{
-		const input_port_config *port = space->machine->port(wtag);
-		if (port == NULL)
-			fatalerror("Attempted to map non-existent port '%s' for write in space %s of device '%s'\n", wtag, space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-		space_map_range(spacerw, ROW_WRITE, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, whandler, (void *)port, wtag);
+		FILE *file = fopen("memdump.log", "w");
+		if (file)
+		{
+			memory_dump(machine, file);
+			fclose(file);
+		}
 	}
+}
+
+
+//-------------------------------------------------
+//  bank_reattach - reconnect banks after a load
+//-------------------------------------------------
 
-	/* update the memory dump */
-	mem_dump(space->machine);
+static STATE_POSTLOAD( bank_reattach )
+{
+	// for each non-anonymous bank, explicitly reset its entry
+	for (memory_bank *bank = machine->memory_data->banklist.first(); bank != NULL; bank = bank->next())
+		if (!bank->anonymous() && bank->entry() != BANK_ENTRY_UNSPECIFIED)
+			bank->set_entry(bank->entry());
 }
 
 
-/*-------------------------------------------------
-    _memory_install_bank - install a
-    new port handler into the given address space
--------------------------------------------------*/
 
-void _memory_install_bank(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag)
+//**************************************************************************
+//  ADDRESS SPACE
+//**************************************************************************
+
+//-------------------------------------------------
+//  address_space - constructor
+//-------------------------------------------------
+
+address_space::address_space(device_memory_interface &memory, int spacenum, bool large)
+	: machine(memory.device().machine),
+	  cpu(&memory.device()),
+	  m_machine(*memory.device().machine),
+	  m_next(NULL),
+	  m_config(*memory.space_config(spacenum)),
+	  m_device(memory.device()),
+	  m_map(NULL),
+	  m_addrmask(0xffffffffUL >> (32 - m_config.m_addrbus_width)),
+	  m_bytemask(address_to_byte_end(m_addrmask)),
+	  m_logaddrmask(0xffffffffUL >> (32 - m_config.m_logaddr_width)),
+	  m_logbytemask(address_to_byte_end(m_logaddrmask)),
+	  m_unmap(0),
+	  m_spacenum(spacenum),
+	  m_debugger_access(false),
+	  m_log_unmap(true),
+	  m_direct(*auto_alloc(memory.device().machine, direct_read_data(*this))),
+	  m_name(memory.space_config(spacenum)->name()),
+	  m_addrchars((m_config.m_databus_width + 3) / 4),
+	  m_logaddrchars((m_config.m_logaddr_width + 3) / 4)
 {
-	address_space *spacerw = (address_space *)space;
+	// notify the device
+	memory.set_address_space(spacenum, *this);
+}
 
-	/* map the read bank */
-	if (rtag != NULL)
-	{
-		genf *handler = bank_find_or_allocate(space, rtag, addrstart, addrend, addrmask, addrmirror, ROW_READ);
-		space_map_range(spacerw, ROW_READ, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, handler, spacerw, rtag);
-	}
 
-	/* map the write bank */
-	if (wtag != NULL)
-	{
-		genf *handler = bank_find_or_allocate(space, wtag, addrstart, addrend, addrmask, addrmirror, ROW_WRITE);
-		space_map_range(spacerw, ROW_WRITE, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, handler, spacerw, wtag);
-	}
+//-------------------------------------------------
+//  ~address_space - destructor
+//-------------------------------------------------
 
-	/* update the memory dump */
-	mem_dump(space->machine);
+address_space::~address_space()
+{
+	global_free(&m_direct);
+	global_free(m_map);
 }
 
 
-/*-------------------------------------------------
-    _memory_install_ram - install a simple fixed
-    RAM region into the given address space
--------------------------------------------------*/
+//-------------------------------------------------
+//  allocate - static smart allocator of subtypes
+//-------------------------------------------------
 
-void *_memory_install_ram(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, UINT8 install_read, UINT8 install_write, void *baseptr)
+address_space &address_space::allocate(running_machine &machine, const address_space_config &config, device_memory_interface &memory, int spacenum)
 {
-	memory_private *memdata = space->machine->memory_data;
-	address_space *spacerw = (address_space *)space;
-	FPTR bankindex;
-	genf *handler;
+	// allocate one of the appropriate type
+	bool large = (config.addr2byte_end(0xffffffffUL >> (32 - config.m_addrbus_width)) >= (1 << 18));
 
-	/* map for read */
-	if (install_read)
+	switch (config.data_width())
 	{
-		handler = bank_find_or_allocate(space, NULL, addrstart, addrend, addrmask, addrmirror, ROW_READ);
-		space_map_range(spacerw, ROW_READ, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, handler, spacerw, "ram");
+		case 8:
+			if (config.endianness() == ENDIANNESS_LITTLE)
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_8le_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_8le_small(memory, spacenum));
+			}
+			else
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_8be_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_8be_small(memory, spacenum));
+			}
 
-		/* if we are provided a pointer, set it */
-		bankindex = (FPTR)handler;
-		if (baseptr != NULL)
-			memdata->bank_ptr[bankindex] = (UINT8 *)baseptr;
+		case 16:
+			if (config.endianness() == ENDIANNESS_LITTLE)
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_16le_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_16le_small(memory, spacenum));
+			}
+			else
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_16be_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_16be_small(memory, spacenum));
+			}
 
-		/* if we don't have a bank pointer yet, try to find one */
-		if (memdata->bank_ptr[bankindex] == NULL)
-			memdata->bank_ptr[bankindex] = (UINT8 *)space_find_backing_memory(space, addrstart, addrend);
+		case 32:
+			if (config.endianness() == ENDIANNESS_LITTLE)
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_32le_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_32le_small(memory, spacenum));
+			}
+			else
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_32be_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_32be_small(memory, spacenum));
+			}
 
-		/* if we still don't have a pointer, and we're past the initialization phase, allocate a new block */
-		if (memdata->bank_ptr[bankindex] == NULL && memdata->initialized)
-		{
-			if (space->machine->phase() >= MACHINE_PHASE_RESET)
-				fatalerror("Attempted to call memory_install_ram() after initialization time without a baseptr!");
-			memdata->bank_ptr[bankindex] = (UINT8 *)block_allocate(space, memory_address_to_byte(space, addrstart), memory_address_to_byte_end(space, addrend), NULL);
-		}
+		case 64:
+			if (config.endianness() == ENDIANNESS_LITTLE)
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_64le_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_64le_small(memory, spacenum));
+			}
+			else
+			{
+				if (large)
+					return *auto_alloc(&machine, address_space_64be_large(memory, spacenum));
+				else
+					return *auto_alloc(&machine, address_space_64be_small(memory, spacenum));
+			}
 	}
+	throw emu_fatalerror("Invalid width %d specified for address_space::allocate", config.data_width());
+}
+
+
+//-------------------------------------------------
+//  adjust_addresses - adjust addresses for a
+//  given address space in a standard fashion
+//-------------------------------------------------
+
+inline void address_space::adjust_addresses(offs_t &start, offs_t &end, offs_t &mask, offs_t &mirror)
+{
+	// adjust start/end/mask values
+	if (mask == 0)
+		mask = m_addrmask & ~mirror;
+	else
+		mask &= m_addrmask;
+	start &= ~mirror & m_addrmask;
+	end &= ~mirror & m_addrmask;
+
+	// adjust to byte values
+	start = address_to_byte(start);
+	end = address_to_byte_end(end);
+	mask = address_to_byte_end(mask);
+	mirror = address_to_byte(mirror);
+}
 
-	/* map for write */
-	if (install_write)
+
+//-------------------------------------------------
+//  prepare_map - allocate the address map and
+//  walk through it to find implcit memory regions
+//  and identify shared regions
+//-------------------------------------------------
+
+void address_space::prepare_map()
+{
+	const region_info *devregion = (m_spacenum == ADDRESS_SPACE_0) ? m_machine.region(m_device.tag()) : NULL;
+	UINT32 devregionsize = (devregion != NULL) ? devregion->bytes() : 0;
+
+	// allocate the address map
+	m_map = global_alloc(address_map(m_device.baseconfig(), m_spacenum));
+
+	// extract global parameters specified by the map
+	m_unmap = (m_map->m_unmapval == 0) ? 0 : ~0;
+	if (m_map->m_globalmask != 0)
 	{
-		handler = bank_find_or_allocate(space, NULL, addrstart, addrend, addrmask, addrmirror, ROW_WRITE);
-		space_map_range(spacerw, ROW_WRITE, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, handler, spacerw, "ram");
+		m_addrmask = m_map->m_globalmask;
+		m_bytemask = address_to_byte_end(m_addrmask);
+	}
 
-		/* if we are provided a pointer, set it */
-		bankindex = (FPTR)handler;
-		if (baseptr != NULL)
-			memdata->bank_ptr[bankindex] = (UINT8 *)baseptr;
+	// make a pass over the address map, adjusting for the device and getting memory pointers
+	for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+	{
+		// if we have a share entry, add it to our map
+		if (entry->m_share != NULL)
+			m_machine.memory_data->sharemap.add(entry->m_share, UNMAPPED_SHARE_PTR, false);
 
-		/* if we don't have a bank pointer yet, try to find one */
-		if (memdata->bank_ptr[bankindex] == NULL)
-			memdata->bank_ptr[bankindex] = (UINT8 *)space_find_backing_memory(space, addrstart, addrend);
+		// computed adjusted addresses first
+		entry->m_bytestart = entry->m_addrstart;
+		entry->m_byteend = entry->m_addrend;
+		entry->m_bytemirror = entry->m_addrmirror;
+		entry->m_bytemask = entry->m_addrmask;
+		adjust_addresses(entry->m_bytestart, entry->m_byteend, entry->m_bytemask, entry->m_bytemirror);
 
-		/* if we still don't have a pointer, and we're past the initialization phase, allocate a new block */
-		if (memdata->bank_ptr[bankindex] == NULL && memdata->initialized)
+		// if this is a ROM handler without a specified region, attach it to the implicit region
+		if (m_spacenum == ADDRESS_SPACE_0 && entry->m_read.m_type == AMH_ROM && entry->m_region == NULL)
 		{
-			if (space->machine->phase() >= MACHINE_PHASE_RESET)
-				fatalerror("Attempted to call memory_install_ram() after initialization time without a baseptr!");
-			memdata->bank_ptr[bankindex] = (UINT8 *)block_allocate(space, memory_address_to_byte(space, addrstart), memory_address_to_byte_end(space, addrend), NULL);
+			// make sure it fits within the memory region before doing so, however
+			if (entry->m_byteend < devregionsize)
+			{
+				entry->m_region = m_device.tag();
+				entry->m_rgnoffs = entry->m_bytestart;
+			}
+		}
+
+		// validate adjusted addresses against implicit regions
+		if (entry->m_region != NULL && entry->m_share == NULL && entry->m_baseptr == NULL)
+		{
+			const region_info *region = m_machine.region(entry->m_region);
+			if (region == NULL)
+				fatalerror("Error: device '%s' %s space memory map entry %X-%X references non-existant region \"%s\"", m_device.tag(), m_name, entry->m_addrstart, entry->m_addrend, entry->m_region);
+
+			// validate the region
+			if (entry->m_rgnoffs + (entry->m_byteend - entry->m_bytestart + 1) > region->bytes())
+				fatalerror("Error: device '%s' %s space memory map entry %X-%X extends beyond region \"%s\" size (%X)", m_device.tag(), m_name, entry->m_addrstart, entry->m_addrend, entry->m_region, region->bytes());
 		}
+
+		// convert any region-relative entries to their memory pointers
+		if (entry->m_region != NULL)
+			entry->m_memory = m_machine.region(entry->m_region)->base() + entry->m_rgnoffs;
 	}
 
-	return (void *)space_find_backing_memory(spacerw, addrstart, addrend);
+	// now loop over all the handlers and enforce the address mask
+	read().mask_all_handlers(m_bytemask);
+	write().mask_all_handlers(m_bytemask);
 }
 
 
-/*-------------------------------------------------
-    _memory_unmap - unmap a section of address
-    space
--------------------------------------------------*/
+//-------------------------------------------------
+//  populate_from_map - walk the map in reverse
+//  order and install the appropriate handler for
+//  each case
+//-------------------------------------------------
 
-void _memory_unmap(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, UINT8 unmap_read, UINT8 unmap_write, UINT8 quiet)
+void address_space::populate_from_map()
 {
-	address_space *spacerw = (address_space *)space;
+	// no map, nothing to do
+	if (m_map == NULL)
+		return;
+
+	// install the handlers, using the original, unadjusted memory map
+	const address_map_entry *last_entry = NULL;
+	while (last_entry != m_map->m_entrylist.first())
+	{
+		// find the entry before the last one we processed
+		const address_map_entry *entry;
+		for (entry = m_map->m_entrylist.first(); entry->next() != last_entry; entry = entry->next()) ;
+		last_entry = entry;
 
-	if (unmap_read)
-		space_map_range(spacerw, ROW_READ, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, (genf *)(FPTR)(quiet ? STATIC_NOP : STATIC_UNMAP), spacerw, "unmapped");
-	if (unmap_write)
-		space_map_range(spacerw, ROW_WRITE, space->dbits, 0, addrstart, addrend, addrmask, addrmirror, (genf *)(FPTR)(quiet ? STATIC_NOP : STATIC_UNMAP), spacerw, "unmapped");
+		// map both read and write halves
+		populate_map_entry(*entry, ROW_READ);
+		populate_map_entry(*entry, ROW_WRITE);
+	}
 }
 
 
+//-------------------------------------------------
+//  populate_map_entry - map a single read or
+//  write entry based on information from an
+//  address map entry
+//-------------------------------------------------
 
-/***************************************************************************
-    DEBUGGER HELPERS
-***************************************************************************/
+void address_space::populate_map_entry(const address_map_entry &entry, read_or_write readorwrite)
+{
+	const map_handler_data &data = (readorwrite == ROW_READ) ? entry.m_read : entry.m_write;
+	bindable_object *object;
+	device_t *device;
 
-/*-------------------------------------------------
-    memory_get_handler_string - return a string
-    describing the handler at a particular offset
--------------------------------------------------*/
+	// based on the handler type, alter the bits, name, funcptr, and object
+	switch (data.m_type)
+	{
+		case AMH_NONE:
+			return;
 
-const char *memory_get_handler_string(const address_space *space, int read0_or_write1, offs_t byteaddress)
-{
-	const address_table *table = read0_or_write1 ? &space->write : &space->read;
-	UINT8 entry;
+		case AMH_ROM:
+			// writes to ROM are no-ops
+			if (readorwrite == ROW_WRITE)
+				return;
+			// fall through to the RAM case otherwise
+
+		case AMH_RAM:
+			install_ram(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, readorwrite);
+			break;
+
+		case AMH_NOP:
+			unmap(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, readorwrite, true);
+			break;
+
+		case AMH_UNMAP:
+			unmap(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, readorwrite, false);
+			break;
+
+		case AMH_DRIVER_DELEGATE:
+		case AMH_DEVICE_DELEGATE:
+			if (data.m_type == AMH_DRIVER_DELEGATE)
+			{
+				object = m_machine.driver_data<driver_data_t>();
+				if (object == NULL)
+					throw emu_fatalerror("Attempted to map a driver delegate in space %s of device '%s' when there is no driver data\n", m_name, m_device.tag());
+			}
+			else
+			{
+				object = m_machine.device(data.m_tag);
+				if (object == NULL)
+					throw emu_fatalerror("Attempted to map a non-existent device '%s' in space %s of device '%s'\n", data.m_tag, m_name, m_device.tag());
+			}
+
+			if (readorwrite == ROW_READ)
+				switch (data.m_bits)
+				{
+					case 8:		install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, read8_delegate(entry.m_rproto8, *object), data.m_mask);		break;
+					case 16:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, read16_delegate(entry.m_rproto16, *object), data.m_mask);		break;
+					case 32:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, read32_delegate(entry.m_rproto32, *object), data.m_mask);		break;
+					case 64:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, read64_delegate(entry.m_rproto64, *object), data.m_mask);		break;
+				}
+			else
+				switch (data.m_bits)
+				{
+					case 8:		install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, write8_delegate(entry.m_wproto8, *object), data.m_mask);		break;
+					case 16:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, write16_delegate(entry.m_wproto16, *object), data.m_mask);	break;
+					case 32:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, write32_delegate(entry.m_wproto32, *object), data.m_mask);	break;
+					case 64:	install_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, write64_delegate(entry.m_wproto64, *object), data.m_mask);	break;
+				}
+			break;
+
+		case AMH_LEGACY_SPACE_HANDLER:
+			if (readorwrite == ROW_READ)
+				switch (data.m_bits)
+				{
+					case 8:		install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rspace8, data.m_name, data.m_mask);	break;
+					case 16:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rspace16, data.m_name, data.m_mask);	break;
+					case 32:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rspace32, data.m_name, data.m_mask);	break;
+					case 64:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rspace64, data.m_name, data.m_mask);	break;
+				}
+			else
+				switch (data.m_bits)
+				{
+					case 8:		install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wspace8, data.m_name, data.m_mask);	break;
+					case 16:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wspace16, data.m_name, data.m_mask);	break;
+					case 32:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wspace32, data.m_name, data.m_mask);	break;
+					case 64:	install_legacy_handler(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wspace64, data.m_name, data.m_mask);	break;
+				}
+			break;
 
-	/* perform the lookup */
-	byteaddress &= space->bytemask;
-	entry = table->table[LEVEL1_INDEX(byteaddress)];
-	if (entry >= SUBTABLE_BASE)
-		entry = table->table[LEVEL2_INDEX(entry, byteaddress)];
+		case AMH_LEGACY_DEVICE_HANDLER:
+			device = m_machine.device(data.m_tag);
+			if (device == NULL)
+				fatalerror("Attempted to map a non-existent device '%s' in space %s of device '%s'\n", data.m_tag, m_name, m_device.tag());
 
-	/* 8-bit case: RAM/ROM */
-	return handler_to_string(space, table, entry);
+			if (readorwrite == ROW_READ)
+				switch (data.m_bits)
+				{
+					case 8:		install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rdevice8, data.m_name, data.m_mask);	break;
+					case 16:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rdevice16, data.m_name, data.m_mask);	break;
+					case 32:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rdevice32, data.m_name, data.m_mask);	break;
+					case 64:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_rdevice64, data.m_name, data.m_mask);	break;
+				}
+			else
+				switch (data.m_bits)
+				{
+					case 8:		install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wdevice8, data.m_name, data.m_mask);	break;
+					case 16:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wdevice16, data.m_name, data.m_mask);	break;
+					case 32:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wdevice32, data.m_name, data.m_mask);	break;
+					case 64:	install_legacy_handler(*device, entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror, entry.m_wdevice64, data.m_name, data.m_mask);	break;
+				}
+			break;
+
+		case AMH_PORT:
+			install_port(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror,
+							(readorwrite == ROW_READ) ? data.m_tag : NULL,
+							(readorwrite == ROW_WRITE) ? data.m_tag : NULL);
+			break;
+
+		case AMH_BANK:
+			install_bank(entry.m_addrstart, entry.m_addrend, entry.m_addrmask, entry.m_addrmirror,
+							(readorwrite == ROW_READ) ? data.m_tag : NULL,
+							(readorwrite == ROW_WRITE) ? data.m_tag : NULL);
+			break;
+	}
 }
 
 
-/*-------------------------------------------------
-    memory_enable_read_watchpoints - enable/disable
-    read watchpoint tracking for a given address
-    space
--------------------------------------------------*/
+//-------------------------------------------------
+//  allocate_memory - determine all neighboring
+//  address ranges and allocate memory to back
+//  them
+//-------------------------------------------------
+
+void address_space::allocate_memory()
+{
+	simple_list<memory_block> &blocklist = m_machine.memory_data->blocklist;
+
+	// make a first pass over the memory map and track blocks with hardcoded pointers
+	// we do this to make sure they are found by space_find_backing_memory first
+	memory_block *prev_memblock_tail = blocklist.last();
+	for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+		if (entry->m_memory != NULL)
+			blocklist.append(*auto_alloc(&m_machine, memory_block(*this, entry->m_bytestart, entry->m_byteend, entry->m_memory)));
+
+	// loop over all blocks just allocated and assign pointers from them
+	address_map_entry *unassigned = NULL;
+	memory_block *first_new_block = (prev_memblock_tail != NULL) ? prev_memblock_tail->next() : blocklist.first();
+	for (memory_block *memblock = first_new_block; memblock != NULL; memblock = memblock->next())
+		unassigned = block_assign_intersecting(memblock->bytestart(), memblock->byteend(), memblock->data());
+
+	// if we don't have an unassigned pointer yet, try to find one
+	if (unassigned == NULL)
+		unassigned = block_assign_intersecting(~0, 0, NULL);
+
+	// loop until we've assigned all memory in this space
+	while (unassigned != NULL)
+	{
+		// work in MEMORY_BLOCK_CHUNK-sized chunks
+		offs_t curblockstart = unassigned->m_bytestart / MEMORY_BLOCK_CHUNK;
+		offs_t curblockend = unassigned->m_byteend / MEMORY_BLOCK_CHUNK;
+
+		// loop while we keep finding unassigned blocks in neighboring MEMORY_BLOCK_CHUNK chunks
+		bool changed;
+		do
+		{
+			changed = false;
 
-void memory_enable_read_watchpoints(const address_space *space, int enable)
-{
-	address_space *spacerw = (address_space *)space;
-	if (enable)
-		spacerw->readlookup = space->machine->memory_data->wptable;
-	else
-		spacerw->readlookup = spacerw->read.table;
+			// scan for unmapped blocks in the adjusted map
+			for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+				if (entry->m_memory == NULL && entry != unassigned && needs_backing_store(entry))
+				{
+					// get block start/end blocks for this block
+					offs_t blockstart = entry->m_bytestart / MEMORY_BLOCK_CHUNK;
+					offs_t blockend = entry->m_byteend / MEMORY_BLOCK_CHUNK;
+
+					// if we intersect or are adjacent, adjust the start/end
+					if (blockstart <= curblockend + 1 && blockend >= curblockstart - 1)
+					{
+						if (blockstart < curblockstart)
+							curblockstart = blockstart, changed = true;
+						if (blockend > curblockend)
+							curblockend = blockend, changed = true;
+					}
+				}
+		} while (changed);
+
+		// we now have a block to allocate; do it
+		offs_t curbytestart = curblockstart * MEMORY_BLOCK_CHUNK;
+		offs_t curbyteend = curblockend * MEMORY_BLOCK_CHUNK + (MEMORY_BLOCK_CHUNK - 1);
+		memory_block &block = blocklist.append(*auto_alloc(&m_machine, memory_block(*this, curbytestart, curbyteend)));
+
+		// assign memory that intersected the new block
+		unassigned = block_assign_intersecting(curbytestart, curbyteend, block.data());
+	}
 }
 
 
-/*-------------------------------------------------
-    memory_enable_write_watchpoints - enable/disable
-    write watchpoint tracking for a given address
-    space
--------------------------------------------------*/
+//-------------------------------------------------
+//  locate_memory - find all the requested
+//  pointers into the final allocated memory
+//-------------------------------------------------
 
-void memory_enable_write_watchpoints(const address_space *space, int enable)
+void address_space::locate_memory()
 {
-	address_space *spacerw = (address_space *)space;
-	if (enable)
-		spacerw->writelookup = space->machine->memory_data->wptable;
-	else
-		spacerw->writelookup = spacerw->write.table;
+	// fill in base/size entries
+	for (const address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+	{
+		if (entry->m_baseptr != NULL)
+			*entry->m_baseptr = entry->m_memory;
+		if (entry->m_baseptroffs_plus1 != 0)
+			*(void **)(reinterpret_cast<UINT8 *>(m_machine.driver_data<void>()) + entry->m_baseptroffs_plus1 - 1) = entry->m_memory;
+		if (entry->m_genbaseptroffs_plus1 != 0)
+			*(void **)((UINT8 *)&m_machine.generic + entry->m_genbaseptroffs_plus1 - 1) = entry->m_memory;
+		if (entry->m_sizeptr != NULL)
+			*entry->m_sizeptr = entry->m_byteend - entry->m_bytestart + 1;
+		if (entry->m_sizeptroffs_plus1 != 0)
+			*(size_t *)(reinterpret_cast<UINT8 *>(m_machine.driver_data<void>()) + entry->m_sizeptroffs_plus1 - 1) = entry->m_byteend - entry->m_bytestart + 1;
+		if (entry->m_gensizeptroffs_plus1 != 0)
+			*(size_t *)((UINT8 *)&m_machine.generic + entry->m_gensizeptroffs_plus1 - 1) = entry->m_byteend - entry->m_bytestart + 1;
+	}
+
+	// once this is done, find the starting bases for the banks
+	for (memory_bank *bank = m_machine.memory_data->banklist.first(); bank != NULL; bank = bank->next())
+		if (bank->base() == NULL && bank->references_space(*this, ROW_READWRITE))
+		{
+			// set the initial bank pointer
+			for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+				if (entry->m_bytestart == bank->bytestart() && entry->m_memory != NULL)
+				{
+					bank->set_base(entry->m_memory);
+					VPRINTF(("assigned bank '%s' pointer to memory from range %08X-%08X [%p]\n", bank->tag(), entry->m_addrstart, entry->m_addrend, entry->m_memory));
+					break;
+				}
+
+			// if the entry was set ahead of time, override the automatically found pointer
+			if (!bank->anonymous() && bank->entry() != BANK_ENTRY_UNSPECIFIED)
+				bank->set_entry(bank->entry());
+		}
+}
+
+
+//-------------------------------------------------
+//  set_decrypted_region - registers an address
+//  range as having a decrypted data pointer
+//-------------------------------------------------
+
+void address_space::set_decrypted_region(offs_t addrstart, offs_t addrend, void *base)
+{
+	offs_t bytestart = address_to_byte(addrstart);
+	offs_t byteend = address_to_byte_end(addrend);
+	bool found = false;
+
+	// loop over banks looking for a match
+	for (memory_bank *bank = m_machine.memory_data->banklist.first(); bank != NULL; bank = bank->next())
+	{
+		// consider this bank if it is used for reading and matches the address space
+		if (bank->references_space(*this, ROW_READ))
+		{
+			// verify that the provided range fully covers this bank
+			if (bank->is_covered_by(bytestart, byteend))
+			{
+				// set the decrypted pointer for the corresponding memory bank
+				bank->set_base_decrypted(reinterpret_cast<UINT8 *>(base) + bank->bytestart() - bytestart);
+				found = true;
+			}
+
+			// fatal error if the decrypted region straddles the bank
+			else if (bank->straddles(bytestart, byteend))
+				throw emu_fatalerror("memory_set_decrypted_region found straddled region %08X-%08X for device '%s'", bytestart, byteend, m_device.tag());
+		}
+	}
+
+	// fatal error as well if we didn't find any relevant memory banks
+	if (!found)
+		throw emu_fatalerror("memory_set_decrypted_region unable to find matching region %08X-%08X for device '%s'", bytestart, byteend, m_device.tag());
 }
 
 
-/*-------------------------------------------------
-    memory_set_debugger_access - control whether
-    subsequent accesses are treated as coming from
-    the debugger
--------------------------------------------------*/
+//-------------------------------------------------
+//  block_assign_intersecting - find all
+//  intersecting blocks and assign their pointers
+//-------------------------------------------------
 
-void memory_set_debugger_access(const address_space *space, int debugger)
+address_map_entry *address_space::block_assign_intersecting(offs_t bytestart, offs_t byteend, UINT8 *base)
 {
-	address_space *spacerw = (address_space *)space;
-	spacerw->debugger_access = debugger;
+	memory_private *memdata = m_machine.memory_data;
+	address_map_entry *unassigned = NULL;
+
+	// loop over the adjusted map and assign memory to any blocks we can
+	for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
+	{
+		// if we haven't assigned this block yet, see if we have a mapped shared pointer for it
+		if (entry->m_memory == NULL && entry->m_share != NULL)
+		{
+			void *shareptr = memdata->sharemap.find(entry->m_share);
+			if (shareptr != UNMAPPED_SHARE_PTR)
+			{
+				entry->m_memory = shareptr;
+				VPRINTF(("memory range %08X-%08X -> shared_ptr '%s' [%p]\n", entry->m_addrstart, entry->m_addrend, entry->m_share, entry->m_memory));
+			}
+		}
+
+		// otherwise, look for a match in this block
+		if (entry->m_memory == NULL && entry->m_bytestart >= bytestart && entry->m_byteend <= byteend)
+		{
+			entry->m_memory = base + (entry->m_bytestart - bytestart);
+			VPRINTF(("memory range %08X-%08X -> found in block from %08X-%08X [%p]\n", entry->m_addrstart, entry->m_addrend, bytestart, byteend, entry->m_memory));
+		}
+
+		// if we're the first match on a shared pointer, assign it now
+		if (entry->m_memory != NULL && entry->m_share != NULL)
+		{
+			void *shareptr = memdata->sharemap.find(entry->m_share);
+			if (shareptr == UNMAPPED_SHARE_PTR)
+				memdata->sharemap.add(entry->m_share, entry->m_memory, TRUE);
+		}
+
+		// keep track of the first unassigned entry
+		if (entry->m_memory == NULL && unassigned == NULL && needs_backing_store(entry))
+			unassigned = entry;
+	}
+
+	return unassigned;
 }
 
 
-/*-------------------------------------------------
-    memory_set_log_unmap - sets whether unmapped
-    memory accesses should be logged or not
--------------------------------------------------*/
+//-------------------------------------------------
+//  get_handler_string - return a string
+//  describing the handler at a particular offset
+//-------------------------------------------------
 
-void memory_set_log_unmap(const address_space *space, int log)
+const char *address_space::get_handler_string(read_or_write readorwrite, offs_t byteaddress)
 {
-	address_space *spacerw = (address_space *)space;
-	spacerw->log_unmap = log;
+	if (readorwrite == ROW_READ)
+		return read().handler_name(read().lookup(byteaddress));
+	else
+		return write().handler_name(write().lookup(byteaddress));
 }
 
 
-/*-------------------------------------------------
-    memory_get_log_unmap - gets whether unmapped
-    memory accesses should be logged or not
--------------------------------------------------*/
+//-------------------------------------------------
+//  dump_map - dump the contents of a single
+//  address space
+//-------------------------------------------------
 
-int memory_get_log_unmap(const address_space *space)
+void address_space::dump_map(FILE *file, read_or_write readorwrite)
 {
-	return space->log_unmap;
+	const address_table &table = (readorwrite == ROW_READ) ? static_cast<address_table &>(read()) : static_cast<address_table &>(write());
+
+	// dump generic information
+	fprintf(file, "  Address bits = %d\n", m_config.m_addrbus_width);
+	fprintf(file, "     Data bits = %d\n", m_config.m_databus_width);
+	fprintf(file, "  Address mask = %X\n", m_bytemask);
+	fprintf(file, "\n");
+
+	// iterate over addresses
+	offs_t bytestart, byteend;
+	for (offs_t byteaddress = 0; byteaddress <= m_bytemask; byteaddress = byteend)
+	{
+		UINT8 entry = table.derive_range(byteaddress, bytestart, byteend);
+		fprintf(file, "%08X-%08X    = %02X: %s [offset=%08X]\n",
+						bytestart, byteend, entry, table.handler_name(entry), table.handler(entry).bytestart());
+		if (++byteend == 0)
+			break;
+	}
 }
 
 
-/*-------------------------------------------------
-    memory_dump - dump the internal memory tables
-    to the given file
--------------------------------------------------*/
+//**************************************************************************
+//  DYNAMIC ADDRESS SPACE MAPPING
+//**************************************************************************
 
-void memory_dump(running_machine *machine, FILE *file)
+//-------------------------------------------------
+//  unmap - unmap a section of address space
+//-------------------------------------------------
+
+void address_space::unmap(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite, bool quiet)
 {
-	memory_private *memdata = machine->memory_data;
-	const address_space *space;
+	VPRINTF(("address_space::unmap(%s-%s mask=%s mirror=%s, %s, %s)\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 (readorwrite == ROW_READ) ? "read" : (readorwrite == ROW_WRITE) ? "write" : (readorwrite == ROW_READWRITE) ? "read/write" : "??",
+			 quiet ? "quiet" : "normal"));
 
-	/* skip if we can't open the file */
-	if (!file)
-		return;
+	// read space
+	if (readorwrite == ROW_READ || readorwrite == ROW_READWRITE)
+		read().map_range(addrstart, addrend, addrmask, addrmirror, quiet ? STATIC_NOP : STATIC_UNMAP);
+
+	// write space
+	if (readorwrite == ROW_WRITE || readorwrite == ROW_READWRITE)
+		write().map_range(addrstart, addrend, addrmask, addrmirror, quiet ? STATIC_NOP : STATIC_UNMAP);
+}
+
+
+//-------------------------------------------------
+//  install_port - install a new I/O port handler
+//  into this address space
+//-------------------------------------------------
+
+void address_space::install_port(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag)
+{
+	VPRINTF(("address_space::install_port(%s-%s mask=%s mirror=%s, read=\"%s\" / write=\"%s\")\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 (rtag != NULL) ? rtag : "(none)", (wtag != NULL) ? wtag : "(none)"));
 
-	/* loop over valid address spaces */
-	for (space = memdata->spacelist; space != NULL; space = space->next)
+	// read handler
+	if (rtag != NULL)
 	{
-		fprintf(file, "\n\n"
-		              "====================================================\n"
-		              "Device '%s' %s address space read handler dump\n"
-		              "====================================================\n", space->cpu->tag(), space->name);
-		dump_map(file, space, &space->read);
+		// find the port
+		const input_port_config *port = m_machine.port(rtag);
+		if (port == NULL)
+			throw emu_fatalerror("Attempted to map non-existent port '%s' for read in space %s of device '%s'\n", rtag, m_name, m_device.tag());
 
-		fprintf(file, "\n\n"
-		              "====================================================\n"
-		              "Device '%s' %s address space write handler dump\n"
-		              "====================================================\n", space->cpu->tag(), space->name);
-		dump_map(file, space, &space->write);
+		// map the range and set the ioport
+		UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+		read().handler_read(entry).set_ioport(*port);
 	}
-}
 
+	if (wtag != NULL)
+	{
+		// find the port
+		const input_port_config *port = m_machine.port(wtag);
+		if (port == NULL)
+			fatalerror("Attempted to map non-existent port '%s' for write in space %s of device '%s'\n", wtag, m_name, m_device.tag());
 
+		// map the range and set the ioport
+		UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+		write().handler_write(entry).set_ioport(*port);
+	}
 
-/***************************************************************************
-    INTERNAL INITIALIZATION
-***************************************************************************/
+	// update the memory dump
+	generate_memdump(&m_machine);
+}
 
-/*-------------------------------------------------
-    memory_init_spaces - create the address
-    spaces
--------------------------------------------------*/
-
-static void memory_init_spaces(running_machine *machine)
-{
-	memory_private *memdata = machine->memory_data;
-	address_space **nextptr = (address_space **)&memdata->spacelist;
-	int spacenum;
-
-	/* create a global watchpoint-filled table */
-	memdata->wptable = auto_alloc_array(machine, UINT8, 1 << LEVEL1_BITS);
-	memset(memdata->wptable, STATIC_WATCHPOINT, 1 << LEVEL1_BITS);
 
-	/* loop over devices */
-	device_memory_interface *memory = NULL;
-	for (bool gotone = machine->m_devicelist.first(memory); gotone; gotone = memory->next(memory))
-		for (spacenum = 0; spacenum < ADDRESS_SPACES; spacenum++)
-		{
-			const address_space_config *spaceconfig = memory->space_config(spacenum);
-			if (spaceconfig != NULL)
-			{
-				address_space *space = auto_alloc_clear(machine, address_space);
-				int ashift = spaceconfig->m_addrbus_shift;
-				int abits = spaceconfig->m_addrbus_width;
-				int dbits = spaceconfig->m_databus_width;
-				int logbits = spaceconfig->m_logaddr_width;
-				endianness_t endianness = spaceconfig->m_endianness;
-				int accessorindex = (dbits == 8) ? 0 : (dbits == 16) ? 1 : (dbits == 32) ? 2 : 3;
-				int entrynum;
-
-				/* if logbits is 0, revert to abits */
-				if (logbits == 0)
-					logbits = abits;
-
-				/* determine the address and data bits */
-				space->machine = machine;
-				space->cpu = &memory->device();
-				space->name = spaceconfig->m_name;
-				space->accessors = memory_accessors[accessorindex][(endianness == ENDIANNESS_LITTLE) ? 0 : 1];
-				space->addrmask = 0xffffffffUL >> (32 - abits);
-				space->bytemask = (ashift < 0) ? ((space->addrmask << -ashift) | ((1 << -ashift) - 1)) : (space->addrmask >> ashift);
-				space->logaddrmask = 0xffffffffUL >> (32 - logbits);
-				space->logbytemask = (ashift < 0) ? ((space->logaddrmask << -ashift) | ((1 << -ashift) - 1)) : (space->logaddrmask >> ashift);
-				space->spacenum = spacenum;
-				space->endianness = endianness;
-				space->ashift = ashift;
-				space->abits = abits;
-				space->dbits = dbits;
-				space->addrchars = (abits + 3) / 4;
-				space->logaddrchars = (logbits + 3) / 4;
-				space->log_unmap = TRUE;
-
-				/* allocate subtable information; we malloc this manually because it will be realloc'ed */
-				space->read.subtable = auto_alloc_array_clear(machine, subtable_data, SUBTABLE_COUNT);
-				space->write.subtable = auto_alloc_array_clear(machine, subtable_data, SUBTABLE_COUNT);
-
-				/* allocate the handler table */
-				space->read.handlers[0] = auto_alloc_array_clear(machine, handler_data, ARRAY_LENGTH(space->read.handlers));
-				space->write.handlers[0] = auto_alloc_array_clear(machine, handler_data, ARRAY_LENGTH(space->write.handlers));
-				for (entrynum = 1; entrynum < ARRAY_LENGTH(space->read.handlers); entrynum++)
-				{
-					space->read.handlers[entrynum] = space->read.handlers[0] + entrynum;
-					space->write.handlers[entrynum] = space->write.handlers[0] + entrynum;
-				}
+//-------------------------------------------------
+//  install_bank - install a range as mapping to
+//  a particular bank
+//-------------------------------------------------
 
-				/* init the static handlers */
-				for (entrynum = 0; entrynum < ENTRY_COUNT; entrynum++)
-				{
-					space->read.handlers[entrynum]->handler.generic = get_static_handler(space->dbits, 0, entrynum);
-					space->read.handlers[entrynum]->object = space;
-					space->write.handlers[entrynum]->handler.generic = get_static_handler(space->dbits, 1, entrynum);
-					space->write.handlers[entrynum]->object = space;
-				}
+void address_space::install_bank(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag)
+{
+	VPRINTF(("address_space::install_bank(%s-%s mask=%s mirror=%s, read=\"%s\" / write=\"%s\")\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 (rtag != NULL) ? rtag : "(none)", (wtag != NULL) ? wtag : "(none)"));
+
+	// map the read bank
+	if (rtag != NULL)
+	{
+		memory_bank &bank = bank_find_or_allocate(rtag, addrstart, addrend, addrmask, addrmirror, ROW_READ);
+		read().map_range(addrstart, addrend, addrmask, addrmirror, bank.index());
+	}
 
-				/* make sure we fix up the mask for the unmap and watchpoint handlers */
-				space->read.handlers[STATIC_UNMAP]->bytemask = ~0;
-				space->write.handlers[STATIC_UNMAP]->bytemask = ~0;
-				space->read.handlers[STATIC_WATCHPOINT]->bytemask = ~0;
-				space->write.handlers[STATIC_WATCHPOINT]->bytemask = ~0;
-
-				/* allocate memory */
-				space->read.machine = machine;
-				space->read.table = auto_alloc_array(machine, UINT8, 1 << LEVEL1_BITS);
-				space->write.machine = machine;
-				space->write.table = auto_alloc_array(machine, UINT8, 1 << LEVEL1_BITS);
-
-				/* initialize everything to unmapped */
-				memset(space->read.table, STATIC_UNMAP, 1 << LEVEL1_BITS);
-				memset(space->write.table, STATIC_UNMAP, 1 << LEVEL1_BITS);
-
-				/* initialize the lookups */
-				space->readlookup = space->read.table;
-				space->writelookup = space->write.table;
-
-				/* set the direct access information base */
-				space->direct.raw = space->direct.decrypted = NULL;
-				space->direct.bytemask = space->bytemask;
-				space->direct.bytestart = 1;
-				space->direct.byteend = 0;
-				space->direct.entry = STATIC_UNMAP;
-				space->directupdate = NULL;
-
-				/* link us in */
-				*nextptr = space;
-				nextptr = (address_space **)&space->next;
+	// map the write bank
+	if (wtag != NULL)
+	{
+		memory_bank &bank = bank_find_or_allocate(wtag, addrstart, addrend, addrmask, addrmirror, ROW_WRITE);
+		write().map_range(addrstart, addrend, addrmask, addrmirror, bank.index());
+	}
 
-				/* notify the device */
-				memory->set_address_space(spacenum, space);
-			}
-		}
+	// update the memory dump
+	generate_memdump(&m_machine);
 }
 
 
-/*-------------------------------------------------
-    memory_init_preflight - verify the memory structs
-    and track which banks are referenced
--------------------------------------------------*/
+//-------------------------------------------------
+//  install_ram - install a simple fixed RAM
+//  region into the given address space
+//-------------------------------------------------
 
-static void memory_init_preflight(running_machine *machine)
+void *address_space::install_ram(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite, void *baseptr)
 {
-	memory_private *memdata = machine->memory_data;
-	address_space *space;
+	memory_private *memdata = m_machine.memory_data;
 
-	/* reset the banking state */
-	memdata->banknext = STATIC_BANK1;
+	VPRINTF(("address_space::install_ram(%s-%s mask=%s mirror=%s, %s, %p)\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 (readorwrite == ROW_READ) ? "read" : (readorwrite == ROW_WRITE) ? "write" : (readorwrite == ROW_READWRITE) ? "read/write" : "??",
+			 baseptr));
 
-	/* loop over valid address spaces */
-	for (space = (address_space *)memdata->spacelist; space != NULL; space = (address_space *)space->next)
+	// map for read
+	if (readorwrite == ROW_READ || readorwrite == ROW_READWRITE)
 	{
-		const region_info *devregion = (space->spacenum == ADDRESS_SPACE_0) ? space->machine->region(space->cpu->tag()) : NULL;
-		int devregionsize = (devregion != NULL) ? devregion->bytes() : 0;
-		address_map_entry *entry;
-		int entrynum;
-
-		/* allocate the address map */
-		space->map = global_alloc(address_map(space->cpu->baseconfig(), space->spacenum));
-
-		/* extract global parameters specified by the map */
-		space->unmap = (space->map->m_unmapval == 0) ? 0 : ~0;
-		if (space->map->m_globalmask != 0)
+		// find a bank and map it
+		memory_bank &bank = bank_find_or_allocate(NULL, addrstart, addrend, addrmask, addrmirror, ROW_READ);
+		read().map_range(addrstart, addrend, addrmask, addrmirror, bank.index());
+
+		// if we are provided a pointer, set it
+		if (baseptr != NULL)
+			bank.set_base(baseptr);
+
+		// if we don't have a bank pointer yet, try to find one
+		if (bank.base() == NULL)
 		{
-			space->addrmask = space->map->m_globalmask;
-			space->bytemask = memory_address_to_byte_end(space, space->addrmask);
+			void *backing = find_backing_memory(addrstart, addrend);
+			if (backing != NULL)
+				bank.set_base(backing);
 		}
 
-		/* make a pass over the address map, adjusting for the device and getting memory pointers */
-		for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
+		// if we still don't have a pointer, and we're past the initialization phase, allocate a new block
+		if (bank.base() == NULL && memdata->initialized)
 		{
-			/* if we have a share entry, add it to our map */
-			if (entry->m_share != NULL)
-				memdata->sharemap.add(entry->m_share, UNMAPPED_SHARE_PTR, FALSE);
-
-			/* computed adjusted addresses first */
-			entry->m_bytestart = entry->m_addrstart;
-			entry->m_byteend = entry->m_addrend;
-			entry->m_bytemirror = entry->m_addrmirror;
-			entry->m_bytemask = entry->m_addrmask;
-			adjust_addresses(space, &entry->m_bytestart, &entry->m_byteend, &entry->m_bytemask, &entry->m_bytemirror);
+			if (m_machine.phase() >= MACHINE_PHASE_RESET)
+				fatalerror("Attempted to call memory_install_ram() after initialization time without a baseptr!");
+			memory_block &block = memdata->blocklist.append(*auto_alloc(&m_machine, memory_block(*this, address_to_byte(addrstart), address_to_byte_end(addrend))));
+			bank.set_base(block.data());
+		}
+	}
 
-			/* if this is a ROM handler without a specified region, attach it to the implicit region */
-			if (space->spacenum == ADDRESS_SPACE_0 && entry->m_read.type == AMH_ROM && entry->m_region == NULL)
-			{
-				/* make sure it fits within the memory region before doing so, however */
-				if (entry->m_byteend < devregionsize)
-				{
-					entry->m_region = space->cpu->tag();
-					entry->m_rgnoffs = entry->m_bytestart;
-				}
-			}
+	// map for write
+	if (readorwrite == ROW_WRITE || readorwrite == ROW_READWRITE)
+	{
+		// find a bank and map it
+		memory_bank &bank = bank_find_or_allocate(NULL, addrstart, addrend, addrmask, addrmirror, ROW_WRITE);
+		write().map_range(addrstart, addrend, addrmask, addrmirror, bank.index());
 
-			/* validate adjusted addresses against implicit regions */
-			if (entry->m_region != NULL && entry->m_share == NULL && entry->m_baseptr == NULL)
-			{
-				const region_info *region = machine->region(entry->m_region);
-				if (region == NULL)
-					fatalerror("Error: device '%s' %s space memory map entry %X-%X references non-existant region \"%s\"", space->cpu->tag(), space->name, entry->m_addrstart, entry->m_addrend, entry->m_region);
-
-				/* validate the region */
-				if (entry->m_rgnoffs + (entry->m_byteend - entry->m_bytestart + 1) > region->bytes())
-					fatalerror("Error: device '%s' %s space memory map entry %X-%X extends beyond region \"%s\" size (%X)", space->cpu->tag(), space->name, entry->m_addrstart, entry->m_addrend, entry->m_region, region->bytes());
-			}
+		// if we are provided a pointer, set it
+		if (baseptr != NULL)
+			bank.set_base(baseptr);
 
-			/* convert any region-relative entries to their memory pointers */
-			if (entry->m_region != NULL)
-				entry->m_memory = machine->region(entry->m_region)->base() + entry->m_rgnoffs;
+		// if we don't have a bank pointer yet, try to find one
+		if (bank.base() == NULL)
+		{
+			void *backing = find_backing_memory(addrstart, addrend);
+			if (backing != NULL)
+				bank.set_base(backing);
 		}
 
-		/* now loop over all the handlers and enforce the address mask */
-		/* we don't loop over map entries because the mask applies to static handlers as well */
-		for (entrynum = 0; entrynum < ENTRY_COUNT; entrynum++)
+		// if we still don't have a pointer, and we're past the initialization phase, allocate a new block
+		if (bank.base() == NULL && memdata->initialized)
 		{
-			space->read.handlers[entrynum]->bytemask &= space->bytemask;
-			space->write.handlers[entrynum]->bytemask &= space->bytemask;
+			if (m_machine.phase() >= MACHINE_PHASE_RESET)
+				fatalerror("Attempted to call memory_install_ram() after initialization time without a baseptr!");
+			memory_block &block = memdata->blocklist.append(*auto_alloc(&m_machine, memory_block(*this, address_to_byte(addrstart), address_to_byte_end(addrend))));
+			bank.set_base(block.data());
 		}
 	}
+
+	return (void *)find_backing_memory(addrstart, addrend);
 }
 
 
-/*-------------------------------------------------
-    memory_init_populate - populate the memory
-    mapping tables with entries
--------------------------------------------------*/
-
-static void memory_init_populate(running_machine *machine)
-{
-	memory_private *memdata = machine->memory_data;
-	address_space *space;
-
-	/* loop over valid address spaces */
-	for (space = (address_space *)memdata->spacelist; space != NULL; space = (address_space *)space->next)
-		if (space->map != NULL)
-		{
-			const address_map_entry *last_entry = NULL;
+//-------------------------------------------------
+//  install_handler - install 8-bit read/write
+//  delegate handlers for the space
+//-------------------------------------------------
 
-			/* install the handlers, using the original, unadjusted memory map */
-			while (last_entry != space->map->m_entrylist)
-			{
-				const address_map_entry *entry;
+UINT8 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_delegate handler, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_handler(%s-%s mask=%s mirror=%s, %s, %s)\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 handler.name(), core_i64_hex_format(unitmask, data_width() / 4)));
 
-				/* find the entry before the last one we processed */
-				for (entry = space->map->m_entrylist; entry->m_next != last_entry; entry = entry->m_next) ;
-				last_entry = entry;
-
-				/* map both read and write halves */
-				memory_init_map_entry(space, entry, ROW_READ);
-				memory_init_map_entry(space, entry, ROW_WRITE);
-			}
-		}
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
 }
 
+UINT8 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_delegate handler, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_handler(%s-%s mask=%s mirror=%s, %s, %s)\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 handler.name(), core_i64_hex_format(unitmask, data_width() / 4)));
 
-/*-------------------------------------------------
-    memory_init_map_entry - map a single read or
-    write entry based on information from an
-    address map entry
--------------------------------------------------*/
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
+}
 
-static void memory_init_map_entry(address_space *space, const address_map_entry *entry, read_or_write readorwrite)
+UINT8 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_delegate rhandler, write8_delegate whandler, UINT64 unitmask)
 {
-	const map_handler_data *handler = (readorwrite == ROW_READ) ? &entry->m_read : &entry->m_write;
-	device_t *device;
+	install_handler(addrstart, addrend, addrmask, addrmirror, rhandler, unitmask);
+	return install_handler(addrstart, addrend, addrmask, addrmirror, whandler, unitmask);
+}
 
-	/* based on the handler type, alter the bits, name, funcptr, and object */
-	switch (handler->type)
-	{
-		case AMH_NONE:
-			return;
 
-		case AMH_ROM:
-			if (readorwrite == ROW_WRITE)
-				return;
-			/* fall through to the RAM case otherwise */
+//-------------------------------------------------
+//  install_legacy_handler - install 8-bit read/
+//  write legacy address space handlers for the
+//  space
+//-------------------------------------------------
 
-		case AMH_RAM:
-			_memory_install_ram(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-								readorwrite == ROW_READ, readorwrite == ROW_WRITE, NULL);
-			break;
+UINT8 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rname, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_legacy_handler(%s-%s mask=%s mirror=%s, %s, %s) [read8]\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 rname, core_i64_hex_format(unitmask, data_width() / 4)));
 
-		case AMH_NOP:
-			_memory_unmap(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-							readorwrite == ROW_READ, readorwrite == ROW_WRITE, TRUE);
-			break;
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(*this, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
+}
 
-		case AMH_UNMAP:
-			_memory_unmap(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-							readorwrite == ROW_READ, readorwrite == ROW_WRITE, FALSE);
-			break;
+UINT8 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_legacy_handler(%s-%s mask=%s mirror=%s, %s, %s) [write8]\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 wname, core_i64_hex_format(unitmask, data_width() / 4)));
 
-		case AMH_HANDLER:
-			switch ((handler->bits != 0) ? handler->bits : space->dbits)
-			{
-				case 8:
-					_memory_install_handler8(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-												(readorwrite == ROW_READ) ? handler->handler.read.shandler8 : NULL, handler->name,
-												(readorwrite == ROW_WRITE) ? handler->handler.write.shandler8 : NULL, handler->name,
-												handler->mask);
-					break;
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(*this, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
+}
 
-				case 16:
-					_memory_install_handler16(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-												(readorwrite == ROW_READ) ? handler->handler.read.shandler16 : NULL, handler->name,
-												(readorwrite == ROW_WRITE) ? handler->handler.write.shandler16 : NULL, handler->name,
-												handler->mask);
-					break;
+UINT8 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rname, write8_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
 
-				case 32:
-					_memory_install_handler32(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-												(readorwrite == ROW_READ) ? handler->handler.read.shandler32 : NULL, handler->name,
-												(readorwrite == ROW_WRITE) ? handler->handler.write.shandler32 : NULL, handler->name,
-												handler->mask);
-					break;
 
-				case 64:
-					_memory_install_handler64(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-												(readorwrite == ROW_READ) ? handler->handler.read.shandler64 : NULL, handler->name,
-												(readorwrite == ROW_WRITE) ? handler->handler.write.shandler64 : NULL, handler->name,
-												handler->mask);
-					break;
-			}
-			break;
+//-------------------------------------------------
+//  install_legacy_handler - install 8-bit read/
+//  write legacy device handlers for the space
+//-------------------------------------------------
 
-		case AMH_DEVICE_HANDLER:
-			device = space->machine->device(handler->tag);
-			if (device == NULL)
-				fatalerror("Attempted to map a non-existent device '%s' in space %s of device '%s'\n", handler->tag, space->name, (space->cpu != NULL) ? space->cpu->tag() : "??");
-			switch ((handler->bits != 0) ? handler->bits : space->dbits)
-			{
-				case 8:
-					_memory_install_device_handler8(space, device, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-													(readorwrite == ROW_READ) ? handler->handler.read.dhandler8 : NULL, handler->name,
-													(readorwrite == ROW_WRITE) ? handler->handler.write.dhandler8 : NULL, handler->name,
-													handler->mask);
-					break;
+UINT8 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rname, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_legacy_handler(%s-%s mask=%s mirror=%s, %s, %s, \"%s\") [read8]\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 rname, core_i64_hex_format(unitmask, data_width() / 4), device.tag()));
 
-				case 16:
-					_memory_install_device_handler16(space, device, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-													(readorwrite == ROW_READ) ? handler->handler.read.dhandler16 : NULL, handler->name,
-													(readorwrite == ROW_WRITE) ? handler->handler.write.dhandler16 : NULL, handler->name,
-													handler->mask);
-					break;
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(device, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
+}
 
-				case 32:
-					_memory_install_device_handler32(space, device, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-													(readorwrite == ROW_READ) ? handler->handler.read.dhandler32 : NULL, handler->name,
-													(readorwrite == ROW_WRITE) ? handler->handler.write.dhandler32 : NULL, handler->name,
-													handler->mask);
-					break;
+UINT8 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	VPRINTF(("address_space::install_legacy_handler(%s-%s mask=%s mirror=%s, %s, %s, \"%s\") [write8]\n",
+			 core_i64_hex_format(addrstart, m_addrchars), core_i64_hex_format(addrend, m_addrchars),
+			 core_i64_hex_format(addrmask, m_addrchars), core_i64_hex_format(addrmirror, m_addrchars),
+			 wname, core_i64_hex_format(unitmask, data_width() / 4), device.tag()));
 
-				case 64:
-					_memory_install_device_handler64(space, device, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-													(readorwrite == ROW_READ) ? handler->handler.read.dhandler64 : NULL, handler->name,
-													(readorwrite == ROW_WRITE) ? handler->handler.write.dhandler64 : NULL, handler->name,
-													handler->mask);
-					break;
-			}
-			break;
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(device, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT8 *>(find_backing_memory(addrstart, addrend));
+}
 
-		case AMH_PORT:
-			_memory_install_port(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-									(readorwrite == ROW_READ) ? handler->tag : NULL,
-									(readorwrite == ROW_WRITE) ? handler->tag : NULL);
-			break;
+UINT8 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rname, write8_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_handler - install 16-bit read/write
+//  delegate handlers for the space
+//-------------------------------------------------
+
+UINT16 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_delegate rhandler, write16_delegate whandler, UINT64 unitmask)
+{
+	install_handler(addrstart, addrend, addrmask, addrmirror, rhandler, unitmask);
+	return install_handler(addrstart, addrend, addrmask, addrmirror, whandler, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_legacy_handler - install 16-bit read/
+//  write legacy address space handlers for the
+//  space
+//-------------------------------------------------
+
+UINT16 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(*this, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(*this, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rname, write16_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_legacy_handler - install 16-bit read/
+//  write legacy device handlers for the space
+//-------------------------------------------------
+
+UINT16 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(device, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(device, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT16 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT16 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rname, write16_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_handler - install 32-bit read/write
+//  delegate handlers for the space
+//-------------------------------------------------
+
+UINT32 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT32 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT32 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_delegate rhandler, write32_delegate whandler, UINT64 unitmask)
+{
+	install_handler(addrstart, addrend, addrmask, addrmirror, rhandler, unitmask);
+	return install_handler(addrstart, addrend, addrmask, addrmirror, whandler, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_legacy_handler - install 32-bit read/
+//  write legacy address space handlers for the
+//  space
+//-------------------------------------------------
+
+UINT32 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(*this, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT32 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(*this, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
+}
+
+UINT32 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rname, write32_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
+
+
+//-------------------------------------------------
+//  install_legacy_handler - install 32-bit read/
+//  write legacy device handlers for the space
+//-------------------------------------------------
+
+UINT32 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(device, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
+}
 
-		case AMH_BANK:
-			_memory_install_bank(space, entry->m_addrstart, entry->m_addrend, entry->m_addrmask, entry->m_addrmirror,
-									(readorwrite == ROW_READ) ? handler->tag : NULL,
-									(readorwrite == ROW_WRITE) ? handler->tag : NULL);
-			break;
-	}
+UINT32 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(device, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT32 *>(find_backing_memory(addrstart, addrend));
 }
 
+UINT32 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rname, write32_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
 
-/*-------------------------------------------------
-    memory_init_allocate - allocate memory for
-    device address spaces
--------------------------------------------------*/
-
-static void memory_init_allocate(running_machine *machine)
-{
-	memory_private *memdata = machine->memory_data;
-	address_space *space;
-
-	/* loop over valid address spaces */
-	for (space = (address_space *)memdata->spacelist; space != NULL; space = (address_space *)space->next)
-	{
-		address_map_entry *unassigned = NULL;
-		address_map_entry *entry;
-		memory_block *prev_memblock_head = memdata->memory_block_list;
-		memory_block *memblock;
-
-		/* make a first pass over the memory map and track blocks with hardcoded pointers */
-		/* we do this to make sure they are found by space_find_backing_memory first */
-		for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
-			if (entry->m_memory != NULL)
-				block_allocate(space, entry->m_bytestart, entry->m_byteend, entry->m_memory);
-
-		/* loop over all blocks just allocated and assign pointers from them */
-		for (memblock = memdata->memory_block_list; memblock != prev_memblock_head; memblock = memblock->next)
-			unassigned = block_assign_intersecting(space, memblock->bytestart, memblock->byteend, memblock->data);
-
-		/* if we don't have an unassigned pointer yet, try to find one */
-		if (unassigned == NULL)
-			unassigned = block_assign_intersecting(space, ~0, 0, NULL);
 
-		/* loop until we've assigned all memory in this space */
-		while (unassigned != NULL)
-		{
-			offs_t curbytestart, curbyteend;
-			int changed;
-			void *block;
-
-			/* work in MEMORY_BLOCK_CHUNK-sized chunks */
-			offs_t curblockstart = unassigned->m_bytestart / MEMORY_BLOCK_CHUNK;
-			offs_t curblockend = unassigned->m_byteend / MEMORY_BLOCK_CHUNK;
+//-------------------------------------------------
+//  install_handler64 - install 64-bit read/write
+//  delegate handlers for the space
+//-------------------------------------------------
 
-			/* loop while we keep finding unassigned blocks in neighboring MEMORY_BLOCK_CHUNK chunks */
-			do
-			{
-				changed = FALSE;
+UINT64 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
+}
 
-				/* scan for unmapped blocks in the adjusted map */
-				for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
-					if (entry->m_memory == NULL && entry != unassigned && space_needs_backing_store(space, entry))
-					{
-						offs_t blockstart, blockend;
+UINT64 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_delegate handler, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_delegate(handler, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
+}
 
-						/* get block start/end blocks for this block */
-						blockstart = entry->m_bytestart / MEMORY_BLOCK_CHUNK;
-						blockend = entry->m_byteend / MEMORY_BLOCK_CHUNK;
+UINT64 *address_space::install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_delegate rhandler, write64_delegate whandler, UINT64 unitmask)
+{
+	install_handler(addrstart, addrend, addrmask, addrmirror, rhandler, unitmask);
+	return install_handler(addrstart, addrend, addrmask, addrmirror, whandler, unitmask);
+}
 
-						/* if we intersect or are adjacent, adjust the start/end */
-						if (blockstart <= curblockend + 1 && blockend >= curblockstart - 1)
-						{
-							if (blockstart < curblockstart)
-								curblockstart = blockstart, changed = TRUE;
-							if (blockend > curblockend)
-								curblockend = blockend, changed = TRUE;
-						}
-					}
-			} while (changed);
 
-			/* we now have a block to allocate; do it */
-			curbytestart = curblockstart * MEMORY_BLOCK_CHUNK;
-			curbyteend = curblockend * MEMORY_BLOCK_CHUNK + (MEMORY_BLOCK_CHUNK - 1);
-			block = block_allocate(space, curbytestart, curbyteend, NULL);
+//-------------------------------------------------
+//  install_legacy_handler - install 64-bit read/
+//  write legacy address space handlers for the
+//  space
+//-------------------------------------------------
 
-			/* assign memory that intersected the new block */
-			unassigned = block_assign_intersecting(space, curbytestart, curbyteend, (UINT8 *)block);
-		}
-	}
+UINT64 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(*this, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
 }
 
+UINT64 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(*this, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
+}
 
-/*-------------------------------------------------
-    memory_init_locate - find all the requested
-    pointers into the final allocated memory
--------------------------------------------------*/
-
-static void memory_init_locate(running_machine *machine)
-{
-	memory_private *memdata = machine->memory_data;
-	address_space *space;
-	bank_info *bank;
+UINT64 *address_space::install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rname, write64_space_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
+}
 
-	/* loop over valid address spaces */
-	for (space = (address_space *)memdata->spacelist; space != NULL; space = (address_space *)space->next)
-	{
-		const address_map_entry *entry;
 
-		/* fill in base/size entries */
-		for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
-		{
-			if (entry->m_baseptr != NULL)
-				*entry->m_baseptr = entry->m_memory;
-			if (entry->m_baseptroffs_plus1 != 0)
-				*(void **)(reinterpret_cast<UINT8 *>(machine->driver_data<void>()) + entry->m_baseptroffs_plus1 - 1) = entry->m_memory;
-			if (entry->m_genbaseptroffs_plus1 != 0)
-				*(void **)((UINT8 *)&machine->generic + entry->m_genbaseptroffs_plus1 - 1) = entry->m_memory;
-			if (entry->m_sizeptr != NULL)
-				*entry->m_sizeptr = entry->m_byteend - entry->m_bytestart + 1;
-			if (entry->m_sizeptroffs_plus1 != 0)
-				*(size_t *)(reinterpret_cast<UINT8 *>(machine->driver_data<void>()) + entry->m_sizeptroffs_plus1 - 1) = entry->m_byteend - entry->m_bytestart + 1;
-			if (entry->m_gensizeptroffs_plus1 != 0)
-				*(size_t *)((UINT8 *)&machine->generic + entry->m_gensizeptroffs_plus1 - 1) = entry->m_byteend - entry->m_bytestart + 1;
-		}
-	}
+//-------------------------------------------------
+//  install_legacy_handler - install 64-bit read/
+//  write legacy device handlers for the space
+//-------------------------------------------------
 
-	/* once this is done, find the starting bases for the banks */
-	for (bank = memdata->banklist; bank != NULL; bank = bank->next)
-	{
-		address_map_entry *entry;
-		bank_reference *ref;
-		int foundit = FALSE;
-
-		/* set the initial bank pointer */
-		for (ref = bank->reflist; !foundit && ref != NULL; ref = ref->next)
-			for (entry = ref->space->map->m_entrylist; entry != NULL; entry = entry->m_next)
-				if (entry->m_bytestart == bank->bytestart && entry->m_memory != NULL)
-				{
-					memdata->bank_ptr[bank->index] = (UINT8 *)entry->m_memory;
-					foundit = TRUE;
-					VPRINTF(("assigned bank '%s' pointer to memory from range %08X-%08X [%p]\n", bank->tag, entry->m_addrstart, entry->m_addrend, entry->m_memory));
-					break;
-				}
+UINT64 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rname, UINT64 unitmask)
+{
+	UINT32 entry = read().map_range(addrstart, addrend, addrmask, addrmirror);
+	read().handler_read(entry).set_legacy_func(device, rhandler, rname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
+}
 
-		/* if the entry was set ahead of time, override the automatically found pointer */
-		if (bank->tag[0] != '~' && bank->curentry != MAX_BANK_ENTRIES)
-			memdata->bank_ptr[bank->index] = (UINT8 *)bank->entry[bank->curentry];
-	}
+UINT64 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	UINT32 entry = write().map_range(addrstart, addrend, addrmask, addrmirror);
+	write().handler_write(entry).set_legacy_func(device, whandler, wname, unitmask);
+	generate_memdump(machine);
+	return reinterpret_cast<UINT64 *>(find_backing_memory(addrstart, addrend));
+}
 
-	/* request a callback to fix up the banks when done */
-	state_save_register_postload(machine, bank_reattach, NULL);
+UINT64 *address_space::install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rname, write64_device_func whandler, const char *wname, UINT64 unitmask)
+{
+	install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, rhandler, rname, unitmask);
+	return install_legacy_handler(device, addrstart, addrend, addrmask, addrmirror, whandler, wname, unitmask);
 }
 
 
-/*-------------------------------------------------
-    memory_exit - free memory
--------------------------------------------------*/
 
-static void memory_exit(running_machine &machine)
-{
-	memory_private *memdata = machine.memory_data;
-	address_space *space;
+//**************************************************************************
+//  INTERNAL INITIALIZATION
+//**************************************************************************
 
-	/* free all the address spaces and tables */
-	for (space = (address_space *)memdata->spacelist; space != NULL; space = space->next)
-	{
-		/* free the address map and tables */
-		global_free(space->map);
-	}
-}
 
+//**************************************************************************
+//  MEMORY MAPPING HELPERS
+//**************************************************************************
 
+//-------------------------------------------------
+//  find_backing_memory - return a pointer to
+//  the base of RAM associated with the given
+//  device and offset
+//-------------------------------------------------
 
-/***************************************************************************
-    MEMORY MAPPING HELPERS
-***************************************************************************/
+void *address_space::find_backing_memory(offs_t addrstart, offs_t addrend)
+{
+	offs_t bytestart = address_to_byte(addrstart);
+	offs_t byteend = address_to_byte_end(addrend);
 
-/*-------------------------------------------------
-    space_map_range - maps a range of addresses
-    to the specified handler within an address
-    space
--------------------------------------------------*/
-
-static void space_map_range(address_space *space, read_or_write readorwrite, int handlerbits, int handlerunitmask, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, genf *handler, void *object, const char *handler_name)
-{
-	address_table *tabledata = (readorwrite == ROW_WRITE) ? &space->write : &space->read;
-	int reset_write = (space->writelookup == space->write.table);
-	int reset_read = (space->readlookup == space->read.table);
-	offs_t bytestart, byteend, bytemask, bytemirror;
-	UINT8 entry;
-
-	/* sanity checks */
-	assert(space != NULL);
-	assert(handlerbits == 8 || handlerbits == 16 || handlerbits == 32 || handlerbits == 64);
-
-	/* adjust the incoming addresses */
-	bytestart = addrstart;
-	byteend = addrend;
-	bytemirror = addrmirror;
-	bytemask = addrmask;
-	adjust_addresses(space, &bytestart, &byteend, &bytemask, &bytemirror);
-
-	/* validity checks */
-	assert_always(!HANDLER_IS_ROM(handler), "space_map_range called with ROM after initialization");
-	assert_always(!HANDLER_IS_RAM(handler), "space_map_range called with RAM after initialization");
-	assert_always(addrstart <= addrend, "space_map_range called with start greater than end");
-	assert_always(handlerbits <= space->dbits, "space_map_range called with handlers larger than the address space");
-	assert_always((bytestart & (space->dbits / 8 - 1)) == 0, "space_map_range called with misaligned start address");
-	assert_always((byteend & (space->dbits / 8 - 1)) == (space->dbits / 8 - 1), "space_map_range called with misaligned end address");
-
-	/* get the final handler index */
-	entry = table_assign_handler(space, tabledata->handlers, object, handler, handler_name, bytestart, byteend, bytemask);
-
-	/* fix up the handler if a stub is required */
-	if (handlerbits != space->dbits)
-		table_compute_subhandler(tabledata->handlers, entry, readorwrite, space->dbits, space->endianness, handlerbits, handlerunitmask);
-
-	/* populate it */
-	table_populate_range_mirrored(space, tabledata, bytestart, byteend, bytemirror, entry);
-
-	/* reset read/write pointers if necessary (could have moved due to realloc) */
-	if (reset_write)
-		space->writelookup = space->write.table;
-	if (reset_read)
-		space->readlookup = space->read.table;
-
-	/* recompute any direct access on this space if it is a read modification */
-	if (readorwrite == ROW_READ && entry == space->direct.entry)
-	{
-		space->direct.entry = STATIC_UNMAP;
-		space->direct.bytestart = 1;
-		space->direct.byteend = 0;
-	}
-}
-
-
-/*-------------------------------------------------
-    space_find_backing_memory - return a pointer to
-    the base of RAM associated with the given
-    device and offset
--------------------------------------------------*/
-
-static void *space_find_backing_memory(const address_space *space, offs_t addrstart, offs_t addrend)
-{
-	offs_t bytestart = memory_address_to_byte(space, addrstart);
-	offs_t byteend = memory_address_to_byte_end(space, addrend);
-	memory_private *memdata = space->machine->memory_data;
-	address_map_entry *entry;
-	memory_block *block;
+	VPRINTF(("address_space::find_backing_memory('%s',%s,%08X-%08X) -> ", m_device.tag(), m_name, bytestart, byteend));
 
-	VPRINTF(("space_find_backing_memory('%s',%s,%08X-%08X) -> ", space->cpu->tag(), space->name, bytestart, byteend));
+	if (m_map == NULL)
+		return NULL;
 
-	/* look in the address map first */
-	for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
+	// look in the address map first
+	for (address_map_entry *entry = m_map->m_entrylist.first(); entry != NULL; entry = entry->next())
 	{
 		offs_t maskstart = bytestart & entry->m_bytemask;
 		offs_t maskend = byteend & entry->m_bytemask;
@@ -2222,12 +2932,12 @@
 		}
 	}
 
-	/* if not found there, look in the allocated blocks */
-	for (block = memdata->memory_block_list; block != NULL; block = block->next)
-		if (block->space == space && block->bytestart <= bytestart && block->byteend >= byteend)
+	// if not found there, look in the allocated blocks
+	for (memory_block *block = m_machine.memory_data->blocklist.first(); block != NULL; block = block->next())
+		if (block->contains(*this, bytestart, byteend))
 		{
-			VPRINTF(("found in allocated memory block %08X-%08X [%p]\n", block->bytestart, block->byteend, block->data + (bytestart - block->bytestart)));
-			return block->data + bytestart - block->bytestart;
+			VPRINTF(("found in allocated memory block %08X-%08X [%p]\n", block->bytestart(), block->byteend(), block->data() + (bytestart - block->bytestart())));
+			return block->data() + bytestart - block->bytestart();
 		}
 
 	VPRINTF(("did not find\n"));
@@ -2235,1121 +2945,674 @@
 }
 
 
-/*-------------------------------------------------
-    space_needs_backing_store - return whether a
-    given memory map entry implies the need of
-    allocating and registering memory
--------------------------------------------------*/
+//-------------------------------------------------
+//  space_needs_backing_store - return whether a
+//  given memory map entry implies the need of
+//  allocating and registering memory
+//-------------------------------------------------
 
-static int space_needs_backing_store(const address_space *space, const address_map_entry *entry)
+bool address_space::needs_backing_store(const address_map_entry *entry)
 {
-	/* if we are asked to provide a base pointer, then yes, we do need backing */
+	// if we are asked to provide a base pointer, then yes, we do need backing
 	if (entry->m_baseptr != NULL || entry->m_baseptroffs_plus1 != 0 || entry->m_genbaseptroffs_plus1 != 0)
-		return TRUE;
+		return true;
 
-	/* if we're writing to any sort of bank or RAM, then yes, we do need backing */
-	if (entry->m_write.type == AMH_BANK || entry->m_write.type == AMH_RAM)
-		return TRUE;
+	// if we're writing to any sort of bank or RAM, then yes, we do need backing
+	if (entry->m_write.m_type == AMH_BANK || entry->m_write.m_type == AMH_RAM)
+		return true;
 
-	/* if we're reading from RAM or from ROM outside of address space 0 or its region, then yes, we do need backing */
-	const region_info *region = space->machine->region(space->cpu->tag());
-	if (entry->m_read.type == AMH_RAM ||
-		(entry->m_read.type == AMH_ROM && (space->spacenum != ADDRESS_SPACE_0 || region == NULL || entry->m_addrstart >= region->bytes())))
-		return TRUE;
+	// if we're reading from RAM or from ROM outside of address space 0 or its region, then yes, we do need backing
+	const region_info *region = m_machine.region(m_device.tag());
+	if (entry->m_read.m_type == AMH_RAM ||
+		(entry->m_read.m_type == AMH_ROM && (m_spacenum != ADDRESS_SPACE_0 || region == NULL || entry->m_addrstart >= region->bytes())))
+		return true;
 
-	/* all other cases don't need backing */
-	return FALSE;
+	// all other cases don't need backing
+	return false;
 }
 
 
 
-/***************************************************************************
-    BANKING HELPERS
-***************************************************************************/
+//**************************************************************************
+//  BANKING HELPERS
+//**************************************************************************
 
-/*-------------------------------------------------
-    bank_find_or_allocate - allocate a new
-    bank, or find an existing one, and return the
-    read/write handler
--------------------------------------------------*/
+//-------------------------------------------------
+//  bank_find_or_allocate - allocate a new
+//  bank, or find an existing one, and return the
+//  read/write handler
+//-------------------------------------------------
 
-static genf *bank_find_or_allocate(const address_space *space, const char *tag, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite)
+memory_bank &address_space::bank_find_or_allocate(const char *tag, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite)
 {
-	memory_private *memdata = space->machine->memory_data;
+	memory_private *memdata = m_machine.memory_data;
+
+	// adjust the addresses, handling mirrors and such
 	offs_t bytemirror = addrmirror;
 	offs_t bytestart = addrstart;
 	offs_t bytemask = addrmask;
 	offs_t byteend = addrend;
-	bank_info *bank = NULL;
-	char temptag[10];
-	char name[30];
-
-	/* adjust the addresses, handling mirrors and such */
-	adjust_addresses(space, &bytestart, &byteend, &bytemask, &bytemirror);
+	adjust_addresses(bytestart, byteend, bytemask, bytemirror);
 
-	/* if this bank is named, look it up */
+	// if this bank is named, look it up
+	memory_bank *bank = NULL;
 	if (tag != NULL)
 		bank = memdata->bankmap.find_hash_only(tag);
 
-	/* else try to find an exact match */
+	// else try to find an exact match
 	else
-	{
-		for (bank = memdata->banklist; bank != NULL; bank = bank->next)
-			if (bank->tag[0] == '~' && bank->bytestart == bytestart && bank->byteend == byteend && bank->reflist != NULL && bank->reflist->space == space)
+		for (bank = memdata->banklist.first(); bank != NULL; bank = bank->next())
+			if (bank->anonymous() && bank->references_space(*this, ROW_READWRITE) && bank->matches_exactly(bytestart, byteend))
 				break;
-	}
 
-	/* if we don't have a bank yet, find a free one */
+	// if we don't have a bank yet, find a free one
 	if (bank == NULL)
 	{
+		// handle failure
 		int banknum = memdata->banknext++;
-
-		/* handle failure */
 		if (banknum > STATIC_BANKMAX)
 		{
 			if (tag != NULL)
-				fatalerror("Unable to allocate new bank '%s'", tag);
+				throw emu_fatalerror("Unable to allocate new bank '%s'", tag);
 			else
-				fatalerror("Unable to allocate bank for RAM/ROM area %X-%X\n", bytestart, byteend);
-		}
-
-		/* generate an internal tag if we don't have one */
-		if (tag == NULL)
-		{
-			sprintf(temptag, "~%d~", banknum);
-			tag = temptag;
-			sprintf(name, "Internal bank #%d", banknum);
+				throw emu_fatalerror("Unable to allocate bank for RAM/ROM area %X-%X\n", bytestart, byteend);
 		}
-		else
-			sprintf(name, "Bank '%s'", tag);
-
-		/* allocate the bank */
-		bank = (bank_info *)auto_alloc_array_clear(space->machine, UINT8, sizeof(bank_info) + strlen(tag) + 1 + strlen(name));
 
-		/* populate it */
-		bank->index = banknum;
-		bank->handler = (void *)(FPTR)(STATIC_BANK1 + banknum - 1);
-		bank->bytestart = bytestart;
-		bank->byteend = byteend;
-		bank->curentry = MAX_BANK_ENTRIES;
-		strcpy(bank->tag, tag);
-		bank->name = bank->tag + strlen(tag) + 1;
-		strcpy(bank->name, name);
-
-		/* add us to the list */
-		bank->next = memdata->banklist;
-		memdata->banklist = bank;
+		// allocate the bank
+		bank = auto_alloc(&m_machine, memory_bank(*this, banknum, bytestart, byteend, tag));
+		memdata->banklist.append(*bank);
 
-		/* for named banks, add to the map and register for save states */
-		if (tag[0] != '~')
-		{
-			memdata->bankmap.add_unique_hash(tag, bank, FALSE);
-			if (state_save_registration_allowed(space->machine))
-				state_save_register_item(space->machine, "memory", bank->tag, 0, bank->curentry);
-		}
+		// for named banks, add to the map and register for save states
+		if (tag != NULL)
+			memdata->bankmap.add_unique_hash(tag, bank, false);
 	}
 
-	/* update the read/write state for this bank */
-	if (readorwrite == ROW_READ)
-		bank->read = TRUE;
-	if (readorwrite == ROW_WRITE)
-		bank->write = TRUE;
-
-	/* add a reference for this space */
-	add_bank_reference(bank, space);
-	return (genf *)bank->handler;
+	// add a reference for this space
+	bank->add_reference(*this, readorwrite);
+	return *bank;
 }
 
 
-/*-------------------------------------------------
-    bank_reattach - reconnect banks after a load
--------------------------------------------------*/
 
-static STATE_POSTLOAD( bank_reattach )
+//**************************************************************************
+//  TABLE MANAGEMENT
+//**************************************************************************
+
+//-------------------------------------------------
+//  address_table - constructor
+//-------------------------------------------------
+
+address_table::address_table(address_space &space, bool large)
+	: m_table(auto_alloc_array(&space.m_machine, UINT8, 1 << LEVEL1_BITS)),
+	  m_live_lookup(m_table),
+	  m_space(space),
+	  m_large(large),
+	  m_subtable(auto_alloc_array(&space.m_machine, subtable_data, SUBTABLE_COUNT)),
+	  m_subtable_alloc(0)
 {
-	memory_private *memdata = machine->memory_data;
-	bank_info *bank;
+	// make our static table all watchpoints
+	if (s_watchpoint_table[0] != STATIC_WATCHPOINT)
+		memset(s_watchpoint_table, STATIC_WATCHPOINT, sizeof(s_watchpoint_table));
 
-	/* once this is done, find the starting bases for the banks */
-	for (bank = memdata->banklist; bank != NULL; bank = bank->next)
-		if (bank->tag[0] != '~')
-		{
-			/* if this entry has a changed entry, set the appropriate pointer */
-			if (bank->curentry != MAX_BANK_ENTRIES)
-				memdata->bank_ptr[bank->index] = (UINT8 *)bank->entry[bank->curentry];
-		}
+	// initialize everything to unmapped
+	memset(m_table, STATIC_UNMAP, 1 << LEVEL1_BITS);
 }
 
 
+//-------------------------------------------------
+//  ~address_table - destructor
+//-------------------------------------------------
 
-/***************************************************************************
-    TABLE MANAGEMENT
-***************************************************************************/
+address_table::~address_table()
+{
+	auto_free(&m_space.m_machine, m_table);
+	auto_free(&m_space.m_machine, m_subtable);
+}
 
-/*-------------------------------------------------
-    table_assign_handler - finds the index of a
-    handler, or allocates a new one as necessary
--------------------------------------------------*/
 
-static UINT8 table_assign_handler(const address_space *space, handler_data **table, void *object, genf *handler, const char *handler_name, offs_t bytestart, offs_t byteend, offs_t bytemask)
+//-------------------------------------------------
+//  map_range - finds an approprite handler entry
+//  and requests to populate the address map with
+//  it
+//-------------------------------------------------
+
+UINT8 address_table::map_range(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, UINT8 staticentry)
 {
-	int entry;
+	// convert addresses to bytes
+	offs_t bytestart = addrstart;
+	offs_t byteend = addrend;
+	offs_t bytemask = addrmask;
+	offs_t bytemirror = addrmirror;
+	m_space.adjust_addresses(bytestart, byteend, bytemask, bytemirror);
 
-	/* all static handlers are hardcoded */
-	if (HANDLER_IS_STATIC(handler))
+	// validity checks
+	assert_always(addrstart <= addrend, "address_table::map_range called with start greater than end");
+	assert_always((bytestart & (m_space.data_width() / 8 - 1)) == 0, "address_table::map_range called with misaligned start address");
+	assert_always((byteend & (m_space.data_width() / 8 - 1)) == (m_space.data_width() / 8 - 1), "address_table::map_range called with misaligned end address");
+
+	// if we weren't given an explicit entry, find a free one
+	UINT8 entry = staticentry;
+	if (entry == STATIC_INVALID)
 	{
-		entry = (FPTR)handler;
-
-		/* if it is a bank, copy in the relevant information */
-		if (HANDLER_IS_BANK(handler))
+		// two attempts to find an empty
+		for (int attempt = 0; attempt < 2; attempt++)
 		{
-			handler_data *hdata = table[entry];
-			hdata->bytestart = bytestart;
-			hdata->byteend = byteend;
-			hdata->bytemask = bytemask;
-			hdata->bankbaseptr = &space->machine->memory_data->bank_ptr[entry];
-			hdata->name = handler_name;
-		}
-		return entry;
-	}
+			// scan all possible assigned entries for something unpopulated, or for an exact match
+			for (UINT8 scanentry = STATIC_COUNT; scanentry < SUBTABLE_BASE; scanentry++)
+			{
+				handler_entry &curentry = handler(scanentry);
 
-	/* otherwise, we have to search */
-	for (entry = STATIC_COUNT; entry < SUBTABLE_BASE; entry++)
-	{
-		handler_data *hdata = table[entry];
+				// exact match takes precedence
+				if (curentry.matches_exactly(bytestart, byteend, bytemask))
+				{
+					entry = scanentry;
+					break;
+				}
 
-		/* if we hit a NULL hdata, then we need to allocate this one as a new one */
-		if (hdata->handler.generic == NULL)
-		{
-			hdata->handler.generic = handler;
-			hdata->bytestart = bytestart;
-			hdata->byteend = byteend;
-			hdata->bytemask = bytemask;
-			hdata->name = handler_name;
-			hdata->object = object;
-			return entry;
+				// unpopulated is our second choice
+				if (entry == STATIC_INVALID && !curentry.populated())
+					entry = scanentry;
+			}
+
+			// if we didn't find anything, find something to depopulate
+			if (entry != STATIC_INVALID)
+				break;
+			depopulate_unused();
 		}
 
-		/* if we find a perfect match, return a duplicate entry */
-		if (hdata->handler.generic == handler && hdata->bytestart == bytestart && hdata->bytemask == bytemask && hdata->object == object)
-			return entry;
+		// if we utterly failed, it's fatal
+		if (entry == STATIC_INVALID)
+			throw emu_fatalerror("Out of handler entries in address table");
 	}
-	return 0;
-}
-
-
-/*-------------------------------------------------
-    table_compute_subhandler - compute data for
-    a subhandler
--------------------------------------------------*/
-
-static void table_compute_subhandler(handler_data **table, UINT8 entry, read_or_write readorwrite, int spacebits, int spaceendian, int handlerbits, int handlerunitmask)
-{
-	int maxunits = spacebits / handlerbits;
-	handler_data *hdata = table[entry];
-	int unitnum;
-
-	assert_always(!HANDLER_IS_STATIC(entry), "table_compute_subhandler called with static handlers and mismatched data bus widths");
 
-	/* copy raw data to the subhandler data */
-	hdata->subobject = hdata->object;
-	hdata->subhandler = hdata->handler;
+	// configure the entry to our parameters
+	handler_entry &curentry = handler(entry);
+	curentry.configure(bytestart, byteend, bytemask);
 
-	/* fill in a stub as the real handler */
-	hdata->object = hdata;
-	hdata->handler = get_stub_handler(readorwrite, spacebits, handlerbits);
+	// populate it
+	populate_range_mirrored(bytestart, byteend, bytemirror, entry);
 
-	/* compute the number of subunits */
-	hdata->subunits = 0;
-	for (unitnum = 0; unitnum < maxunits; unitnum++)
-		if (handlerunitmask & (1 << unitnum))
-			hdata->subunits++;
-	assert_always(hdata->subunits > 0, "table_compute_subhandler called with no bytes specified in mask");
-
-	/* then fill in the shifts based on the endianness */
-	if (spaceendian == ENDIANNESS_LITTLE)
-	{
-		UINT8 *unitshift = &hdata->subshift[0];
-		for (unitnum = 0; unitnum < maxunits; unitnum++)
-			if (handlerunitmask & (1 << unitnum))
-				*unitshift++ = unitnum * handlerbits;
-	}
-	else
-	{
-		UINT8 *unitshift = &hdata->subshift[hdata->subunits];
-		for (unitnum = 0; unitnum < maxunits; unitnum++)
-			if (handlerunitmask & (1 << unitnum))
-				*--unitshift = unitnum * handlerbits;
-	}
+	// recompute any direct access on this space if it is a read modification
+	m_space.m_direct.force_update(entry);
+	return entry;
 }
 
 
-/*-------------------------------------------------
-    table_populate_range - assign a memory handler
-    to a range of addresses
--------------------------------------------------*/
+//-------------------------------------------------
+//  populate_range - assign a memory handler to a
+//  range of addresses
+//-------------------------------------------------
 
-static void table_populate_range(address_table *tabledata, offs_t bytestart, offs_t byteend, UINT8 handler)
+void address_table::populate_range(offs_t bytestart, offs_t byteend, UINT8 handlerindex)
 {
-	offs_t l2mask = (1 << LEVEL2_BITS) - 1;
-	offs_t l1start = bytestart >> LEVEL2_BITS;
+	offs_t l2mask = (1 << level2_bits()) - 1;
+	offs_t l1start = bytestart >> level2_bits();
 	offs_t l2start = bytestart & l2mask;
-	offs_t l1stop = byteend >> LEVEL2_BITS;
+	offs_t l1stop = byteend >> level2_bits();
 	offs_t l2stop = byteend & l2mask;
-	offs_t l1index;
 
-	/* sanity check */
+	// sanity check
 	if (bytestart > byteend)
 		return;
 
-	/* handle the starting edge if it's not on a block boundary */
+	// handle the starting edge if it's not on a block boundary
 	if (l2start != 0)
 	{
-		UINT8 *subtable = subtable_open(tabledata, l1start);
+		UINT8 *subtable = subtable_open(l1start);
 
-		/* if the start and stop end within the same block, handle that */
+		// if the start and stop end within the same block, handle that
 		if (l1start == l1stop)
 		{
-			memset(&subtable[l2start], handler, l2stop - l2start + 1);
-			subtable_close(tabledata, l1start);
+			memset(&subtable[l2start], handlerindex, l2stop - l2start + 1);
+			subtable_close(l1start);
 			return;
 		}
 
-		/* otherwise, fill until the end */
-		memset(&subtable[l2start], handler, (1 << LEVEL2_BITS) - l2start);
-		subtable_close(tabledata, l1start);
-		if (l1start != (offs_t)~0) l1start++;
+		// otherwise, fill until the end
+		memset(&subtable[l2start], handlerindex, (1 << level2_bits()) - l2start);
+		subtable_close(l1start);
+		if (l1start != (offs_t)~0)
+			l1start++;
 	}
 
-	/* handle the trailing edge if it's not on a block boundary */
+	// handle the trailing edge if it's not on a block boundary
 	if (l2stop != l2mask)
 	{
-		UINT8 *subtable = subtable_open(tabledata, l1stop);
+		UINT8 *subtable = subtable_open(l1stop);
 
-		/* fill from the beginning */
-		memset(&subtable[0], handler, l2stop + 1);
-		subtable_close(tabledata, l1stop);
+		// fill from the beginning
+		memset(&subtable[0], handlerindex, l2stop + 1);
+		subtable_close(l1stop);
 
-		/* if the start and stop end within the same block, handle that */
+		// if the start and stop end within the same block, handle that
 		if (l1start == l1stop)
 			return;
-		if (l1stop != 0) l1stop--;
+		if (l1stop != 0)
+			l1stop--;
 	}
 
-	/* now fill in the middle tables */
-	for (l1index = l1start; l1index <= l1stop; l1index++)
+	// now fill in the middle tables
+	for (offs_t l1index = l1start; l1index <= l1stop; l1index++)
 	{
-		/* if we have a subtable here, release it */
-		if (tabledata->table[l1index] >= SUBTABLE_BASE)
-			subtable_release(tabledata, tabledata->table[l1index]);
-		tabledata->table[l1index] = handler;
+		// if we have a subtable here, release it
+		if (m_table[l1index] >= SUBTABLE_BASE)
+			subtable_release(m_table[l1index]);
+		m_table[l1index] = handlerindex;
 	}
 }
 
 
-/*-------------------------------------------------
-    table_populate_range_mirrored - assign a
-    memory handler to a range of addresses
-    including mirrors
--------------------------------------------------*/
+//-------------------------------------------------
+//  populate_range_mirrored - assign a memory
+//  handler to a range of addresses including
+//  mirrors
+//-------------------------------------------------
 
-static void table_populate_range_mirrored(address_space *space, address_table *tabledata, offs_t bytestart, offs_t byteend, offs_t bytemirror, UINT8 handler)
+void address_table::populate_range_mirrored(offs_t bytestart, offs_t byteend, offs_t bytemirror, UINT8 handlerindex)
 {
-	offs_t lmirrorbit[LEVEL2_BITS], lmirrorbits, hmirrorbit[32 - LEVEL2_BITS], hmirrorbits, lmirrorcount, hmirrorcount;
-	UINT8 prev_entry = STATIC_INVALID;
-	int cur_index, prev_index = 0;
-	int i;
+	// determine the mirror bits
+	offs_t lmirrorbits = 0;
+	offs_t lmirrorbit[32];
+	for (int bit = 0; bit < level2_bits(); bit++)
+		if (bytemirror & (1 << bit))
+			lmirrorbit[lmirrorbits++] = 1 << bit;
 
-	/* determine the mirror bits */
-	hmirrorbits = lmirrorbits = 0;
-	for (i = 0; i < LEVEL2_BITS; i++)
-		if (bytemirror & (1 << i))
-			lmirrorbit[lmirrorbits++] = 1 << i;
-	for (i = LEVEL2_BITS; i < 32; i++)
-		if (bytemirror & (1 << i))
-			hmirrorbit[hmirrorbits++] = 1 << i;
+	offs_t hmirrorbits = 0;
+	offs_t hmirrorbit[32];
+	for (int bit = level2_bits(); bit < 32; bit++)
+		if (bytemirror & (1 << bit))
+			hmirrorbit[hmirrorbits++] = 1 << bit;
 
-	/* loop over mirrors in the level 2 table */
-	for (hmirrorcount = 0; hmirrorcount < (1 << hmirrorbits); hmirrorcount++)
+	// loop over mirrors in the level 2 table
+	UINT8 prev_entry = STATIC_INVALID;
+	int prev_index = 0;
+	for (offs_t hmirrorcount = 0; hmirrorcount < (1 << hmirrorbits); hmirrorcount++)
 	{
-		/* compute the base of this mirror */
+		// compute the base of this mirror
 		offs_t hmirrorbase = 0;
-		for (i = 0; i < hmirrorbits; i++)
-			if (hmirrorcount & (1 << i))
-				hmirrorbase |= hmirrorbit[i];
+		for (int bit = 0; bit < hmirrorbits; bit++)
+			if (hmirrorcount & (1 << bit))
+				hmirrorbase |= hmirrorbit[bit];
 
-		/* invalidate any intersecting cached ranges */
-		for (lmirrorcount = 0; lmirrorcount < (1 << lmirrorbits); lmirrorcount++)
+		// invalidate any intersecting cached ranges
+		for (offs_t lmirrorcount = 0; lmirrorcount < (1 << lmirrorbits); lmirrorcount++)
 		{
-			/* compute the base of this mirror */
+			// compute the base of this mirror
 			offs_t lmirrorbase = hmirrorbase;
-			for (i = 0; i < lmirrorbits; i++)
-				if (lmirrorcount & (1 << i))
-					lmirrorbase |= lmirrorbit[i];
-			direct_range_remove_intersecting(space, bytestart + lmirrorbase, byteend + lmirrorbase);
+			for (int bit = 0; bit < lmirrorbits; bit++)
+				if (lmirrorcount & (1 << bit))
+					lmirrorbase |= lmirrorbit[bit];
+			m_space.m_direct.remove_intersecting_ranges(bytestart + lmirrorbase, byteend + lmirrorbase);
 		}
 
-		/* if this is not our first time through, and the level 2 entry matches the previous
-           level 2 entry, just do a quick map and get out; note that this only works for entries
-           which don't span multiple level 1 table entries */
-		cur_index = LEVEL1_INDEX(bytestart + hmirrorbase);
-		if (cur_index == LEVEL1_INDEX(byteend + hmirrorbase))
+		// if this is not our first time through, and the level 2 entry matches the previous
+		// level 2 entry, just do a quick map and get out; note that this only works for entries
+		// which don't span multiple level 1 table entries
+		int cur_index = level1_index(bytestart + hmirrorbase);
+		if (cur_index == level1_index(byteend + hmirrorbase))
 		{
-			if (hmirrorcount != 0 && prev_entry == tabledata->table[cur_index])
+			if (hmirrorcount != 0 && prev_entry == m_table[cur_index])
 			{
-				VPRINTF(("Quick mapping subtable at %08X to match subtable at %08X\n", cur_index << LEVEL2_BITS, prev_index << LEVEL2_BITS));
+				VPRINTF(("Quick mapping subtable at %08X to match subtable at %08X\n", cur_index << level2_bits(), prev_index << level2_bits()));
 
-				/* release the subtable if the old value was a subtable */
-				if (tabledata->table[cur_index] >= SUBTABLE_BASE)
-					subtable_release(tabledata, tabledata->table[cur_index]);
-
-				/* reallocate the subtable if the new value is a subtable */
-				if (tabledata->table[prev_index] >= SUBTABLE_BASE)
-					subtable_realloc(tabledata, tabledata->table[prev_index]);
+				// release the subtable if the old value was a subtable
+				if (m_table[cur_index] >= SUBTABLE_BASE)
+					subtable_release(m_table[cur_index]);
+
+				// reallocate the subtable if the new value is a subtable
+				if (m_table[prev_index] >= SUBTABLE_BASE)
+					subtable_realloc(m_table[prev_index]);
 
-				/* set the new value and short-circuit the mapping step */
-				tabledata->table[cur_index] = tabledata->table[prev_index];
+				// set the new value and short-circuit the mapping step
+				m_table[cur_index] = m_table[prev_index];
 				continue;
 			}
 			prev_index = cur_index;
-			prev_entry = tabledata->table[cur_index];
+			prev_entry = m_table[cur_index];
 		}
 
-		/* loop over mirrors in the level 1 table */
-		for (lmirrorcount = 0; lmirrorcount < (1 << lmirrorbits); lmirrorcount++)
+		// loop over mirrors in the level 1 table
+		for (offs_t lmirrorcount = 0; lmirrorcount < (1 << lmirrorbits); lmirrorcount++)
 		{
-			/* compute the base of this mirror */
+			// compute the base of this mirror
 			offs_t lmirrorbase = hmirrorbase;
-			for (i = 0; i < lmirrorbits; i++)
-				if (lmirrorcount & (1 << i))
-					lmirrorbase |= lmirrorbit[i];
+			for (int bit = 0; bit < lmirrorbits; bit++)
+				if (lmirrorcount & (1 << bit))
+					lmirrorbase |= lmirrorbit[bit];
 
-			/* populate the tables */
-			table_populate_range(tabledata, bytestart + lmirrorbase, byteend + lmirrorbase, handler);
+			// populate the tables
+			populate_range(bytestart + lmirrorbase, byteend + lmirrorbase, handlerindex);
 		}
 	}
 }
 
 
-/*-------------------------------------------------
-    table_derive_range - look up the entry for
-    a memory range, and then compute the extent
-    of that range based on the lookup tables
--------------------------------------------------*/
+//-------------------------------------------------
+//  depopulate_unused - scan the table and
+//  eliminate entries that are no longer used
+//-------------------------------------------------
 
-static UINT8 table_derive_range(const address_table *table, offs_t byteaddress, offs_t *bytestart, offs_t *byteend)
+void address_table::depopulate_unused()
 {
-	UINT32 curentry, entry, curl1entry, l1entry;
-	const handler_data *handler;
-	offs_t minscan, maxscan;
+	assert(false);
+}
+
 
-	/* look up the initial address to get the entry we care about */
-	entry = l1entry = table->table[LEVEL1_INDEX(byteaddress)];
+//-------------------------------------------------
+//  derive_range - look up the entry for a memory
+//  range, and then compute the extent of that
+//  range based on the lookup tables
+//-------------------------------------------------
+
+UINT8 address_table::derive_range(offs_t byteaddress, offs_t &bytestart, offs_t &byteend) const
+{
+	// look up the initial address to get the entry we care about
+	UINT8 l1entry;
+	UINT8 entry = l1entry = m_table[level1_index(byteaddress)];
 	if (l1entry >= SUBTABLE_BASE)
-		entry = table->table[LEVEL2_INDEX(l1entry, byteaddress)];
-	handler = table->handlers[entry];
+		entry = m_table[level2_index(l1entry, byteaddress)];
 
-	/* use the bytemask of the entry to set minimum and maximum bounds */
-	minscan = handler->bytestart | ((byteaddress - handler->bytestart) & ~handler->bytemask);
-	maxscan = handler->byteend | ((byteaddress - handler->bytestart) & ~handler->bytemask);
+	// use the bytemask of the entry to set minimum and maximum bounds
+	offs_t minscan, maxscan;
+	handler(entry).mirrored_start_end(byteaddress, minscan, maxscan);
 
-	/* first scan backwards to find the start address */
-	curl1entry = l1entry;
-	curentry = entry;
-	*bytestart = byteaddress;
+	// first scan backwards to find the start address
+	UINT8 curl1entry = l1entry;
+	UINT8 curentry = entry;
+	bytestart = byteaddress;
 	while (1)
 	{
-		/* if we need to scan the subtable, do it */
+		// if we need to scan the subtable, do it
 		if (curentry != curl1entry)
 		{
-			UINT32 minindex = LEVEL2_INDEX(curl1entry, 0);
+			UINT32 minindex = level2_index(curl1entry, 0);
 			UINT32 index;
 
-			/* scan backwards from the current address, until the previous entry doesn't match */
-			for (index = LEVEL2_INDEX(curl1entry, *bytestart); index > minindex; index--, *bytestart -= 1)
-				if (table->table[index - 1] != entry)
+			// scan backwards from the current address, until the previous entry doesn't match
+			for (index = level2_index(curl1entry, bytestart); index > minindex; index--, bytestart -= 1)
+				if (m_table[index - 1] != entry)
 					break;
 
-			/* if we didn't hit the beginning, then we're finished scanning */
+			// if we didn't hit the beginning, then we're finished scanning
 			if (index != minindex)
 				break;
 		}
 
-		/* move to the beginning of this L1 entry; stop at the minimum address */
-		*bytestart &= ~((1 << LEVEL2_BITS) - 1);
-		if (*bytestart <= minscan)
+		// move to the beginning of this L1 entry; stop at the minimum address
+		bytestart &= ~((1 << level2_bits()) - 1);
+		if (bytestart <= minscan)
 			break;
 
-		/* look up the entry of the byte at the end of the previous L1 entry; if it doesn't match, stop */
-		curentry = curl1entry = table->table[LEVEL1_INDEX(*bytestart - 1)];
+		// look up the entry of the byte at the end of the previous L1 entry; if it doesn't match, stop
+		curentry = curl1entry = m_table[level1_index(bytestart - 1)];
 		if (curl1entry >= SUBTABLE_BASE)
-			curentry = table->table[LEVEL2_INDEX(curl1entry, *bytestart - 1)];
+			curentry = m_table[level2_index(curl1entry, bytestart - 1)];
 		if (curentry != entry)
 			break;
 
-		/* move into the previous entry and resume searching */
-		*bytestart -= 1;
+		// move into the previous entry and resume searching
+		bytestart -= 1;
 	}
 
-	/* then scan forwards to find the end address */
+	// then scan forwards to find the end address
 	curl1entry = l1entry;
 	curentry = entry;
-	*byteend = byteaddress;
+	byteend = byteaddress;
 	while (1)
 	{
-		/* if we need to scan the subtable, do it */
+		// if we need to scan the subtable, do it
 		if (curentry != curl1entry)
 		{
-			UINT32 maxindex = LEVEL2_INDEX(curl1entry, ~0);
+			UINT32 maxindex = level2_index(curl1entry, ~0);
 			UINT32 index;
 
-			/* scan forwards from the current address, until the next entry doesn't match */
-			for (index = LEVEL2_INDEX(curl1entry, *byteend); index < maxindex; index++, *byteend += 1)
-				if (table->table[index + 1] != entry)
+			// scan forwards from the current address, until the next entry doesn't match
+			for (index = level2_index(curl1entry, byteend); index < maxindex; index++, byteend += 1)
+				if (m_table[index + 1] != entry)
 					break;
 
-			/* if we didn't hit the end, then we're finished scanning */
+			// if we didn't hit the end, then we're finished scanning
 			if (index != maxindex)
 				break;
 		}
 
-		/* move to the end of this L1 entry; stop at the maximum address */
-		*byteend |= (1 << LEVEL2_BITS) - 1;
-		if (*byteend >= maxscan)
-			break;
-
-		/* look up the entry of the byte at the start of the next L1 entry; if it doesn't match, stop */
-		curentry = curl1entry = table->table[LEVEL1_INDEX(*byteend + 1)];
-		if (curl1entry >= SUBTABLE_BASE)
-			curentry = table->table[LEVEL2_INDEX(curl1entry, *byteend + 1)];
-		if (curentry != entry)
-			break;
-
-		/* move into the next entry and resume searching */
-		*byteend += 1;
-	}
-
-	return entry;
-}
-
-
-
-/***************************************************************************
-    SUBTABLE MANAGEMENT
-***************************************************************************/
-
-/*-------------------------------------------------
-    subtable_alloc - allocate a fresh subtable
-    and set its usecount to 1
--------------------------------------------------*/
-
-static UINT8 subtable_alloc(address_table *tabledata)
-{
-	/* loop */
-	while (1)
-	{
-		UINT8 subindex;
-
-		/* find a subtable with a usecount of 0 */
-		for (subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
-			if (tabledata->subtable[subindex].usecount == 0)
-			{
-				/* if this is past our allocation budget, allocate some more */
-				if (subindex >= tabledata->subtable_alloc)
-				{
-					UINT32 oldsize = (1 << LEVEL1_BITS) + (tabledata->subtable_alloc << LEVEL2_BITS);
-					tabledata->subtable_alloc += SUBTABLE_ALLOC;
-					UINT32 newsize = (1 << LEVEL1_BITS) + (tabledata->subtable_alloc << LEVEL2_BITS);
-
-					UINT8 *newtable = auto_alloc_array(tabledata->machine, UINT8, newsize);
-					memcpy(newtable, tabledata->table, oldsize);
-					auto_free(tabledata->machine, tabledata->table);
-					tabledata->table = newtable;
-				}
-
-				/* bump the usecount and return */
-				tabledata->subtable[subindex].usecount++;
-				return subindex + SUBTABLE_BASE;
-			}
-
-		/* merge any subtables we can */
-		if (!subtable_merge(tabledata))
-			fatalerror("Ran out of subtables!");
-	}
-}
-
-
-/*-------------------------------------------------
-    subtable_realloc - increment the usecount on
-    a subtable
--------------------------------------------------*/
-
-static void subtable_realloc(address_table *tabledata, UINT8 subentry)
-{
-	UINT8 subindex = subentry - SUBTABLE_BASE;
-
-	/* sanity check */
-	if (tabledata->subtable[subindex].usecount <= 0)
-		fatalerror("Called subtable_realloc on a table with a usecount of 0");
-
-	/* increment the usecount */
-	tabledata->subtable[subindex].usecount++;
-}
-
-
-/*-------------------------------------------------
-    subtable_merge - merge any duplicate
-    subtables
--------------------------------------------------*/
-
-static int subtable_merge(address_table *tabledata)
-{
-	int merged = 0;
-	UINT8 subindex;
-
-	VPRINTF(("Merging subtables....\n"));
-
-	/* okay, we failed; update all the checksums and merge tables */
-	for (subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
-		if (!tabledata->subtable[subindex].checksum_valid && tabledata->subtable[subindex].usecount != 0)
-		{
-			UINT32 *subtable = (UINT32 *)SUBTABLE_PTR(tabledata, subindex + SUBTABLE_BASE);
-			UINT32 checksum = 0;
-			int l2index;
-
-			/* update the checksum */
-			for (l2index = 0; l2index < (1 << LEVEL2_BITS)/4; l2index++)
-				checksum += subtable[l2index];
-			tabledata->subtable[subindex].checksum = checksum;
-			tabledata->subtable[subindex].checksum_valid = 1;
-		}
-
-	/* see if there's a matching checksum */
-	for (subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
-		if (tabledata->subtable[subindex].usecount != 0)
-		{
-			UINT8 *subtable = SUBTABLE_PTR(tabledata, subindex + SUBTABLE_BASE);
-			UINT32 checksum = tabledata->subtable[subindex].checksum;
-			UINT8 sumindex;
-
-			for (sumindex = subindex + 1; sumindex < SUBTABLE_COUNT; sumindex++)
-				if (tabledata->subtable[sumindex].usecount != 0 &&
-					tabledata->subtable[sumindex].checksum == checksum &&
-					!memcmp(subtable, SUBTABLE_PTR(tabledata, sumindex + SUBTABLE_BASE), 1 << LEVEL2_BITS))
-				{
-					int l1index;
-
-					VPRINTF(("Merging subtable %d and %d....\n", subindex, sumindex));
-
-					/* find all the entries in the L1 tables that pointed to the old one, and point them to the merged table */
-					for (l1index = 0; l1index <= (0xffffffffUL >> LEVEL2_BITS); l1index++)
-						if (tabledata->table[l1index] == sumindex + SUBTABLE_BASE)
-						{
-							subtable_release(tabledata, sumindex + SUBTABLE_BASE);
-							subtable_realloc(tabledata, subindex + SUBTABLE_BASE);
-							tabledata->table[l1index] = subindex + SUBTABLE_BASE;
-							merged++;
-						}
-				}
-		}
-
-	return merged;
-}
-
-
-/*-------------------------------------------------
-    subtable_release - decrement the usecount on
-    a subtable and free it if we're done
--------------------------------------------------*/
-
-static void subtable_release(address_table *tabledata, UINT8 subentry)
-{
-	UINT8 subindex = subentry - SUBTABLE_BASE;
-
-	/* sanity check */
-	if (tabledata->subtable[subindex].usecount <= 0)
-		fatalerror("Called subtable_release on a table with a usecount of 0");
-
-	/* decrement the usecount and clear the checksum if we're at 0 */
-	tabledata->subtable[subindex].usecount--;
-	if (tabledata->subtable[subindex].usecount == 0)
-		tabledata->subtable[subindex].checksum = 0;
-}
-
-
-/*-------------------------------------------------
-    subtable_open - gain access to a subtable for
-    modification
--------------------------------------------------*/
-
-static UINT8 *subtable_open(address_table *tabledata, offs_t l1index)
-{
-	UINT8 subentry = tabledata->table[l1index];
-
-	/* if we don't have a subtable yet, allocate a new one */
-	if (subentry < SUBTABLE_BASE)
-	{
-		UINT8 newentry = subtable_alloc(tabledata);
-		memset(SUBTABLE_PTR(tabledata, newentry), subentry, 1 << LEVEL2_BITS);
-		tabledata->table[l1index] = newentry;
-		tabledata->subtable[newentry - SUBTABLE_BASE].checksum = (subentry + (subentry << 8) + (subentry << 16) + (subentry << 24)) * ((1 << LEVEL2_BITS)/4);
-		subentry = newentry;
-	}
-
-	/* if we're sharing this subtable, we also need to allocate a fresh copy */
-	else if (tabledata->subtable[subentry - SUBTABLE_BASE].usecount > 1)
-	{
-		UINT8 newentry = subtable_alloc(tabledata);
-
-		/* allocate may cause some additional merging -- look up the subentry again */
-		/* when we're done; it should still require a split */
-		subentry = tabledata->table[l1index];
-		assert(subentry >= SUBTABLE_BASE);
-		assert(tabledata->subtable[subentry - SUBTABLE_BASE].usecount > 1);
-
-		memcpy(SUBTABLE_PTR(tabledata, newentry), SUBTABLE_PTR(tabledata, subentry), 1 << LEVEL2_BITS);
-		subtable_release(tabledata, subentry);
-		tabledata->table[l1index] = newentry;
-		tabledata->subtable[newentry - SUBTABLE_BASE].checksum = tabledata->subtable[subentry - SUBTABLE_BASE].checksum;
-		subentry = newentry;
-	}
-
-	/* mark the table dirty */
-	tabledata->subtable[subentry - SUBTABLE_BASE].checksum_valid = 0;
-
-	/* return the pointer to the subtable */
-	return SUBTABLE_PTR(tabledata, subentry);
-}
-
-
-/*-------------------------------------------------
-    subtable_close - stop access to a subtable
--------------------------------------------------*/
-
-static void subtable_close(address_table *tabledata, offs_t l1index)
-{
-	/* defer any merging until we run out of tables */
-}
-
-
-
-/***************************************************************************
-    DIRECT MEMORY RANGES
-***************************************************************************/
-
-/*-------------------------------------------------
-    direct_range_find - find a byte address in
-    a range
--------------------------------------------------*/
-
-static direct_range *direct_range_find(address_space *space, offs_t byteaddress, UINT8 *entry)
-{
-	direct_range **rangelistptr;
-	direct_range **rangeptr;
-	direct_range *range;
-
-	/* determine which entry */
-	byteaddress &= space->bytemask;
-	*entry = space->read.table[LEVEL1_INDEX(byteaddress)];
-	if (*entry >= SUBTABLE_BASE)
-		*entry = space->read.table[LEVEL2_INDEX(*entry, byteaddress)];
-	rangelistptr = &space->direct.rangelist[*entry];
-
-	/* scan our table */
-	for (rangeptr = rangelistptr; *rangeptr != NULL; rangeptr = &(*rangeptr)->next)
-		if (byteaddress >= (*rangeptr)->bytestart && byteaddress <= (*rangeptr)->byteend)
-		{
-			/* found a match; move us to the head of the list if we're not already there */
-			range = *rangeptr;
-			if (range != *rangelistptr)
-			{
-				*rangeptr = range->next;
-				range->next = *rangelistptr;
-				*rangelistptr = range;
-			}
-			return range;
-		}
-
-	/* didn't find out; allocate a new one */
-	range = space->direct.freerangelist;
-	if (range != NULL)
-		space->direct.freerangelist = range->next;
-	else
-		range = auto_alloc(space->machine, direct_range);
-
-	/* fill in the range */
-	table_derive_range(&space->read, byteaddress, &range->bytestart, &range->byteend);
-	range->next = *rangelistptr;
-	*rangelistptr = range;
-
-	return range;
-}
-
-
-/*-------------------------------------------------
-    direct_range_remove_intersecting - remove
-    all cached ranges that intersect the given
-    address range
--------------------------------------------------*/
-
-static void direct_range_remove_intersecting(address_space *space, offs_t bytestart, offs_t byteend)
-{
-    int entry;
-
-    /* loop over all entries */
-    for (entry = 0; entry < ARRAY_LENGTH(space->read.handlers); entry++)
-    {
-        direct_range **rangeptr, **nextrangeptr;
-
-        /* loop over all ranges in this entry's list */
-        for (nextrangeptr = rangeptr = &space->direct.rangelist[entry]; *rangeptr != NULL; rangeptr = nextrangeptr)
-        {
-        	/* if we intersect, remove and add to the free range list */
-            if (bytestart <= (*rangeptr)->byteend && byteend >= (*rangeptr)->bytestart)
-            {
-                direct_range *range = *rangeptr;
-                *rangeptr = range->next;
-                range->next = space->direct.freerangelist;
-                space->direct.freerangelist = range;
-            }
-
-            /* otherwise advance to the next in the list */
-            else
-                nextrangeptr = &(*rangeptr)->next;
-        }
-    }
-}
-
-
-
-/***************************************************************************
-    MEMORY BLOCK ALLOCATION
-***************************************************************************/
-
-/*-------------------------------------------------
-    block_allocate - allocate a single
-    memory block of data
--------------------------------------------------*/
-
-static void *block_allocate(const address_space *space, offs_t bytestart, offs_t byteend, void *memory)
-{
-	memory_private *memdata = space->machine->memory_data;
-	int allocatemem = (memory == NULL);
-	memory_block *block;
-	size_t bytestoalloc;
-	const region_info *region;
-
-	VPRINTF(("block_allocate('%s',%s,%08X,%08X,%p)\n", space->cpu->tag(), space->name, bytestart, byteend, memory));
-
-	/* determine how much memory to allocate for this */
-	bytestoalloc = sizeof(*block);
-	if (allocatemem)
-		bytestoalloc += byteend - bytestart + 1;
-
-	/* allocate and clear the memory */
-	block = (memory_block *)auto_alloc_array_clear(space->machine, UINT8, bytestoalloc);
-	if (allocatemem)
-		memory = block + 1;
-
-	/* register for saving, but only if we're not part of a memory region */
-	for (region = space->machine->m_regionlist.first(); region != NULL; region = region->next())
-	{
-		if ((UINT8 *)memory >= region->base() && ((UINT8 *)memory + (byteend - bytestart + 1)) < region->end())
-		{
-			VPRINTF(("skipping save of this memory block as it is covered by a memory region\n"));
-			break;
-		}
-	}
+		// move to the end of this L1 entry; stop at the maximum address
+		byteend |= (1 << level2_bits()) - 1;
+		if (byteend >= maxscan)
+			break;
 
-	/* if we didn't find a match, register */
-	if (region == NULL)
-	{
-		int bytes_per_element = space->dbits/8;
-		char name[256];
+		// look up the entry of the byte at the start of the next L1 entry; if it doesn't match, stop
+		curentry = curl1entry = m_table[level1_index(byteend + 1)];
+		if (curl1entry >= SUBTABLE_BASE)
+			curentry = m_table[level2_index(curl1entry, byteend + 1)];
+		if (curentry != entry)
+			break;
 
-		sprintf(name, "%08x-%08x", bytestart, byteend);
-		state_save_register_memory(space->machine, "memory", space->cpu->tag(), space->spacenum, name, memory, bytes_per_element, (UINT32)(byteend - bytestart + 1) / bytes_per_element, __FILE__, __LINE__);
+		// move into the next entry and resume searching
+		byteend += 1;
 	}
 
-	/* fill in the tracking block */
-	block->space = space;
-	block->isallocated = allocatemem;
-	block->bytestart = bytestart;
-	block->byteend = byteend;
-	block->data = (UINT8 *)memory;
+	return entry;
+}
+
 
-	/* attach us to the head of the list */
-	block->next = memdata->memory_block_list;
-	memdata->memory_block_list = block;
+//-------------------------------------------------
+//  mask_all_handlers - apply a mask to all
+//  address handlers
+//-------------------------------------------------
 
-	return memory;
+void address_table::mask_all_handlers(offs_t mask)
+{
+	// we don't loop over map entries because the mask applies to static handlers as well
+	for (int entrynum = 0; entrynum < ENTRY_COUNT; entrynum++)
+		handler(entrynum).apply_mask(mask);
 }
 
 
-/*-------------------------------------------------
-    block_assign_intersecting - find all
-    intersecting blocks and assign their pointers
--------------------------------------------------*/
 
-static address_map_entry *block_assign_intersecting(address_space *space, offs_t bytestart, offs_t byteend, UINT8 *base)
-{
-	memory_private *memdata = space->machine->memory_data;
-	address_map_entry *entry, *unassigned = NULL;
+//**************************************************************************
+//  SUBTABLE MANAGEMENT
+//**************************************************************************
+
+//-------------------------------------------------
+//  subtable_alloc - allocate a fresh subtable
+//  and set its usecount to 1
+//-------------------------------------------------
 
-	/* loop over the adjusted map and assign memory to any blocks we can */
-	for (entry = space->map->m_entrylist; entry != NULL; entry = entry->m_next)
+UINT8 address_table::subtable_alloc()
+{
+	// loop
+	while (1)
 	{
-		/* if we haven't assigned this block yet, see if we have a mapped shared pointer for it */
-		if (entry->m_memory == NULL && entry->m_share != NULL)
-		{
-			void *shareptr = memdata->sharemap.find(entry->m_share);
-			if (shareptr != UNMAPPED_SHARE_PTR)
+		// find a subtable with a usecount of 0
+		for (UINT8 subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
+			if (m_subtable[subindex].m_usecount == 0)
 			{
-				entry->m_memory = shareptr;
-				VPRINTF(("memory range %08X-%08X -> shared_ptr '%s' [%p]\n", entry->m_addrstart, entry->m_addrend, entry->m_share, entry->m_memory));
-			}
-		}
-
-		/* otherwise, look for a match in this block */
-		if (entry->m_memory == NULL && entry->m_bytestart >= bytestart && entry->m_byteend <= byteend)
-		{
-			entry->m_memory = base + (entry->m_bytestart - bytestart);
-			VPRINTF(("memory range %08X-%08X -> found in block from %08X-%08X [%p]\n", entry->m_addrstart, entry->m_addrend, bytestart, byteend, entry->m_memory));
-		}
+				// if this is past our allocation budget, allocate some more
+				if (subindex >= m_subtable_alloc)
+				{
+					UINT32 oldsize = (1 << LEVEL1_BITS) + (m_subtable_alloc << level2_bits());
+					m_subtable_alloc += SUBTABLE_ALLOC;
+					UINT32 newsize = (1 << LEVEL1_BITS) + (m_subtable_alloc << level2_bits());
+
+					UINT8 *newtable = auto_alloc_array_clear(&m_space.m_machine, UINT8, newsize);
+					memcpy(newtable, m_table, oldsize);
+					if (m_live_lookup == m_table)
+						m_live_lookup = newtable;
+					auto_free(&m_space.m_machine, m_table);
+					m_table = newtable;
+				}
 
-		/* if we're the first match on a shared pointer, assign it now */
-		if (entry->m_memory != NULL && entry->m_share != NULL)
-		{
-			void *shareptr = memdata->sharemap.find(entry->m_share);
-			if (shareptr == UNMAPPED_SHARE_PTR)
-				memdata->sharemap.add(entry->m_share, entry->m_memory, TRUE);
-		}
+				// bump the usecount and return
+				m_subtable[subindex].m_usecount++;
+				return subindex + SUBTABLE_BASE;
+			}
 
-		/* keep track of the first unassigned entry */
-		if (entry->m_memory == NULL && unassigned == NULL && space_needs_backing_store(space, entry))
-			unassigned = entry;
+		// merge any subtables we can
+		if (!subtable_merge())
+			fatalerror("Ran out of subtables!");
 	}
-
-	return unassigned;
 }
 
 
+//-------------------------------------------------
+//  subtable_realloc - increment the usecount on
+//  a subtable
+//-------------------------------------------------
 
-/***************************************************************************
-    INTERNAL HANDLERS
-***************************************************************************/
-
-/*-------------------------------------------------
-    unmapped memory handlers
--------------------------------------------------*/
-
-static READ8_HANDLER( unmap_read8 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory byte read from %s\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset), space->addrchars));
-	return space->unmap;
-}
-static READ16_HANDLER( unmap_read16 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory word read from %s & %04X\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*2), space->addrchars), mem_mask);
-	return space->unmap;
-}
-static READ32_HANDLER( unmap_read32 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory dword read from %s & %08X\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*4), space->addrchars), mem_mask);
-	return space->unmap;
-}
-static READ64_HANDLER( unmap_read64 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory qword read from %s & %s\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*8), space->addrchars), core_i64_hex_format(mem_mask, 16));
-	return space->unmap;
-}
-
-static WRITE8_HANDLER( unmap_write8 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory byte write to %s = %02X\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset), space->addrchars), data);
-}
-static WRITE16_HANDLER( unmap_write16 )
+void address_table::subtable_realloc(UINT8 subentry)
 {
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory word write to %s = %04X & %04X\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*2), space->addrchars), data, mem_mask);
-}
-static WRITE32_HANDLER( unmap_write32 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory dword write to %s = %08X & %08X\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*4), space->addrchars), data, mem_mask);
-}
-static WRITE64_HANDLER( unmap_write64 )
-{
-	if (space->log_unmap && !space->debugger_access) logerror("%s: unmapped %s memory qword write to %s = %s & %s\n", cpuexec_describe_context(space->machine), space->name, core_i64_hex_format(memory_byte_to_address(space, offset*8), space->addrchars), core_i64_hex_format(data, 16), core_i64_hex_format(mem_mask, 16));
-}
-
-
-/*-------------------------------------------------
-    no-op memory handlers
--------------------------------------------------*/
+	UINT8 subindex = subentry - SUBTABLE_BASE;
 
-static READ8_HANDLER( nop_read8 )      { return space->unmap; }
-static READ16_HANDLER( nop_read16 )    { return space->unmap; }
-static READ32_HANDLER( nop_read32 )    { return space->unmap; }
-static READ64_HANDLER( nop_read64 )    { return space->unmap; }
+	// sanity check
+	if (m_subtable[subindex].m_usecount <= 0)
+		fatalerror("Called subtable_realloc on a table with a usecount of 0");
 
-static WRITE8_HANDLER( nop_write8 )    {  }
-static WRITE16_HANDLER( nop_write16 )  {  }
-static WRITE32_HANDLER( nop_write32 )  {  }
-static WRITE64_HANDLER( nop_write64 )  {  }
+	// increment the usecount
+	m_subtable[subindex].m_usecount++;
+}
 
 
-/*-------------------------------------------------
-    watchpoint memory handlers
--------------------------------------------------*/
+//-------------------------------------------------
+//  subtable_merge - merge any duplicate
+//  subtables
+//-------------------------------------------------
 
-static READ8_HANDLER( watchpoint_read8 )
+int address_table::subtable_merge()
 {
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->readlookup;
-	UINT8 result;
+	int merged = 0;
+	UINT8 subindex;
 
-	spacerw->cpu->debug()->memory_read_hook(*spacerw, offset, 0xff);
-	spacerw->readlookup = space->read.table;
-	result = read_byte_generic(spacerw, offset);
-	spacerw->readlookup = oldtable;
-	return result;
-}
+	VPRINTF(("Merging subtables....\n"));
 
-static READ16_HANDLER( watchpoint_read16 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->readlookup;
-	UINT16 result;
-
-	spacerw->cpu->debug()->memory_read_hook(*spacerw, offset << 1, mem_mask);
-	spacerw->readlookup = spacerw->read.table;
-	result = read_word_generic(spacerw, offset << 1, mem_mask);
-	spacerw->readlookup = oldtable;
-	return result;
-}
+	// okay, we failed; update all the checksums and merge tables
+	for (subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
+		if (!m_subtable[subindex].m_checksum_valid && m_subtable[subindex].m_usecount != 0)
+		{
+			UINT32 *subtable = reinterpret_cast<UINT32 *>(subtable_ptr(subindex + SUBTABLE_BASE));
+			UINT32 checksum = 0;
 
-static READ32_HANDLER( watchpoint_read32 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->readlookup;
-	UINT32 result;
-
-	spacerw->cpu->debug()->memory_read_hook(*spacerw, offset << 2, mem_mask);
-	spacerw->readlookup = spacerw->read.table;
-	result = read_dword_generic(spacerw, offset << 2, mem_mask);
-	spacerw->readlookup = oldtable;
-	return result;
-}
+			// update the checksum
+			for (int l2index = 0; l2index < (1 << level2_bits())/4; l2index++)
+				checksum += subtable[l2index];
+			m_subtable[subindex].m_checksum = checksum;
+			m_subtable[subindex].m_checksum_valid = true;
+		}
 
-static READ64_HANDLER( watchpoint_read64 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->readlookup;
-	UINT64 result;
-
-	spacerw->cpu->debug()->memory_read_hook(*spacerw, offset << 3, mem_mask);
-	spacerw->readlookup = spacerw->read.table;
-	result = read_qword_generic(spacerw, offset << 3, mem_mask);
-	spacerw->readlookup = oldtable;
-	return result;
-}
+	// see if there's a matching checksum
+	for (subindex = 0; subindex < SUBTABLE_COUNT; subindex++)
+		if (m_subtable[subindex].m_usecount != 0)
+		{
+			UINT8 *subtable = subtable_ptr(subindex + SUBTABLE_BASE);
+			UINT32 checksum = m_subtable[subindex].m_checksum;
+			UINT8 sumindex;
 
-static WRITE8_HANDLER( watchpoint_write8 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->writelookup;
+			for (sumindex = subindex + 1; sumindex < SUBTABLE_COUNT; sumindex++)
+				if (m_subtable[sumindex].m_usecount != 0 &&
+					m_subtable[sumindex].m_checksum == checksum &&
+					!memcmp(subtable, subtable_ptr(sumindex + SUBTABLE_BASE), 1 << level2_bits()))
+				{
+					int l1index;
 
-	spacerw->cpu->debug()->memory_write_hook(*spacerw, offset, data, 0xff);
-	spacerw->writelookup = spacerw->write.table;
-	write_byte_generic(spacerw, offset, data);
-	spacerw->writelookup = oldtable;
-}
+					VPRINTF(("Merging subtable %d and %d....\n", subindex, sumindex));
 
-static WRITE16_HANDLER( watchpoint_write16 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->writelookup;
+					// find all the entries in the L1 tables that pointed to the old one, and point them to the merged table
+					for (l1index = 0; l1index <= (0xffffffffUL >> level2_bits()); l1index++)
+						if (m_table[l1index] == sumindex + SUBTABLE_BASE)
+						{
+							subtable_release(sumindex + SUBTABLE_BASE);
+							subtable_realloc(subindex + SUBTABLE_BASE);
+							m_table[l1index] = subindex + SUBTABLE_BASE;
+							merged++;
+						}
+				}
+		}
 
-	spacerw->cpu->debug()->memory_write_hook(*spacerw, offset << 1, data, mem_mask);
-	spacerw->writelookup = spacerw->write.table;
-	write_word_generic(spacerw, offset << 1, data, mem_mask);
-	spacerw->writelookup = oldtable;
+	return merged;
 }
 
-static WRITE32_HANDLER( watchpoint_write32 )
-{
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->writelookup;
 
-	spacerw->cpu->debug()->memory_write_hook(*spacerw, offset << 2, data, mem_mask);
-	spacerw->writelookup = spacerw->write.table;
-	write_dword_generic(spacerw, offset << 2, data, mem_mask);
-	spacerw->writelookup = oldtable;
-}
+//-------------------------------------------------
+//  subtable_release - decrement the usecount on
+//  a subtable and free it if we're done
+//-------------------------------------------------
 
-static WRITE64_HANDLER( watchpoint_write64 )
+void address_table::subtable_release(UINT8 subentry)
 {
-	address_space *spacerw = (address_space *)space;
-	UINT8 *oldtable = spacerw->writelookup;
+	UINT8 subindex = subentry - SUBTABLE_BASE;
 
-	spacerw->cpu->debug()->memory_write_hook(*spacerw, offset << 3, data, mem_mask);
-	spacerw->writelookup = spacerw->write.table;
-	write_qword_generic(spacerw, offset << 3, data, mem_mask);
-	spacerw->writelookup = oldtable;
+	// sanity check
+	if (m_subtable[subindex].m_usecount <= 0)
+		fatalerror("Called subtable_release on a table with a usecount of 0");
+
+	// decrement the usecount and clear the checksum if we're at 0
+	m_subtable[subindex].m_usecount--;
+	if (m_subtable[subindex].m_usecount == 0)
+		m_subtable[subindex].m_checksum = 0;
 }
 
 
-/*-------------------------------------------------
-    get_static_handler - returns points to static
-    memory handlers
--------------------------------------------------*/
+//-------------------------------------------------
+//  subtable_open - gain access to a subtable for
+//  modification
+//-------------------------------------------------
 
-static genf *get_static_handler(int handlerbits, int readorwrite, int which)
+UINT8 *address_table::subtable_open(offs_t l1index)
 {
-	static const struct
-	{
-		UINT8		handlerbits;
-		UINT8		handlernum;
-		genf *		read;
-		genf *		write;
-	} static_handler_list[] =
+	UINT8 subentry = m_table[l1index];
+
+	// if we don't have a subtable yet, allocate a new one
+	if (subentry < SUBTABLE_BASE)
 	{
-		{  8, STATIC_UNMAP,      (genf *)unmap_read8,       (genf *)unmap_write8 },
-		{  8, STATIC_NOP,        (genf *)nop_read8,         (genf *)nop_write8 },
-		{  8, STATIC_WATCHPOINT, (genf *)watchpoint_read8,  (genf *)watchpoint_write8 },
+		UINT8 newentry = subtable_alloc();
+		memset(subtable_ptr(newentry), subentry, 1 << level2_bits());
+		m_table[l1index] = newentry;
+		m_subtable[newentry - SUBTABLE_BASE].m_checksum = (subentry + (subentry << 8) + (subentry << 16) + (subentry << 24)) * ((1 << level2_bits())/4);
+		subentry = newentry;
+	}
 
-		{ 16, STATIC_UNMAP,      (genf *)unmap_read16,      (genf *)unmap_write16 },
-		{ 16, STATIC_NOP,        (genf *)nop_read16,        (genf *)nop_write16 },
-		{ 16, STATIC_WATCHPOINT, (genf *)watchpoint_read16, (genf *)watchpoint_write16 },
+	// if we're sharing this subtable, we also need to allocate a fresh copy
+	else if (m_subtable[subentry - SUBTABLE_BASE].m_usecount > 1)
+	{
+		UINT8 newentry = subtable_alloc();
 
-		{ 32, STATIC_UNMAP,      (genf *)unmap_read32,      (genf *)unmap_write32 },
-		{ 32, STATIC_NOP,        (genf *)nop_read32,        (genf *)nop_write32 },
-		{ 32, STATIC_WATCHPOINT, (genf *)watchpoint_read32, (genf *)watchpoint_write32 },
+		// allocate may cause some additional merging -- look up the subentry again
+		// when we're done; it should still require a split
+		subentry = m_table[l1index];
+		assert(subentry >= SUBTABLE_BASE);
+		assert(m_subtable[subentry - SUBTABLE_BASE].m_usecount > 1);
 
-		{ 64, STATIC_UNMAP,      (genf *)unmap_read64,      (genf *)unmap_write64 },
-		{ 64, STATIC_NOP,        (genf *)nop_read64,        (genf *)nop_write64 },
-		{ 64, STATIC_WATCHPOINT, (genf *)watchpoint_read64, (genf *)watchpoint_write64 },
-	};
-	int tablenum;
+		memcpy(subtable_ptr(newentry), subtable_ptr(subentry), 1 << level2_bits());
+		subtable_release(subentry);
+		m_table[l1index] = newentry;
+		m_subtable[newentry - SUBTABLE_BASE].m_checksum = m_subtable[subentry - SUBTABLE_BASE].m_checksum;
+		subentry = newentry;
+	}
 
-	for (tablenum = 0; tablenum < sizeof(static_handler_list) / sizeof(static_handler_list[0]); tablenum++)
-		if (static_handler_list[tablenum].handlerbits == handlerbits && static_handler_list[tablenum].handlernum == which)
-			return readorwrite ? static_handler_list[tablenum].write : static_handler_list[tablenum].read;
+	// mark the table dirty
+	m_subtable[subentry - SUBTABLE_BASE].m_checksum_valid = false;
 
-	return NULL;
+	// return the pointer to the subtable
+	return subtable_ptr(subentry);
 }
 
 
+//-------------------------------------------------
+//  subtable_close - stop access to a subtable
+//-------------------------------------------------
 
-/***************************************************************************
-    DEBUGGING
-***************************************************************************/
+void address_table::subtable_close(offs_t l1index)
+{
+	// defer any merging until we run out of tables
+}
 
-/*-------------------------------------------------
-    handler_to_string - return friendly string
-    description of a handler
--------------------------------------------------*/
 
-static const char *handler_to_string(const address_space *space, const address_table *table, UINT8 entry)
+//-------------------------------------------------
+//  handler_name - return friendly string
+//  description of a handler
+//-------------------------------------------------
+
+const char *address_table::handler_name(UINT8 entry) const
 {
 	static const char *const strings[] =
 	{
@@ -3387,1204 +3650,1342 @@
 		"rom",			"nop",			"unmapped",     "watchpoint"
 	};
 
-	/* banks have names */
+	// banks have names
 	if (entry >= STATIC_BANK1 && entry <= STATIC_BANKMAX)
-	{
-		bank_info *info;
-		for (info = space->machine->memory_data->banklist; info != NULL; info = info->next)
-			if (info->index == entry)
-				return info->name;
-	}
+		for (memory_bank *info = m_space.m_machine.memory_data->banklist.first(); info != NULL; info = info->next())
+			if (info->index() == entry)
+				return info->name();
 
-	/* constant strings for lower entries */
-	if (entry < STATIC_COUNT)
+	// constant strings for lower entries
+	if (entry < ARRAY_LENGTH(strings))
 		return strings[entry];
+	else if (handler(entry).name() != NULL)
+		return handler(entry).name();
 	else
-		return (table->handlers[entry]->name != NULL) ? table->handlers[entry]->name : "???";
+		return "???";
 }
 
 
-/*-------------------------------------------------
-    dump_map - dump the contents of a single
-    address space
--------------------------------------------------*/
+//-------------------------------------------------
+//  address_table_read - constructor
+//-------------------------------------------------
 
-static void dump_map(FILE *file, const address_space *space, const address_table *table)
+address_table_read::address_table_read(address_space &space, bool large)
+	: address_table(space, large)
 {
-	offs_t byteaddress, bytestart, byteend;
-
-	/* dump generic information */
-	fprintf(file, "  Address bits = %d\n", space->abits);
-	fprintf(file, "     Data bits = %d\n", space->dbits);
-	fprintf(file, "       L1 bits = %d\n", LEVEL1_BITS);
-	fprintf(file, "       L2 bits = %d\n", LEVEL2_BITS);
-	fprintf(file, "  Address mask = %X\n", space->bytemask);
-	fprintf(file, "\n");
-
-	/* iterate over addresses */
-	for (byteaddress = 0; byteaddress <= space->bytemask; byteaddress = byteend + 1)
+	// allocate handlers for each entry, prepopulating the bankptrs for banks
+	for (int entrynum = 0; entrynum < ARRAY_LENGTH(m_handlers); entrynum++)
 	{
-		UINT8 entry = table_derive_range(table, byteaddress, &bytestart, &byteend);
-		fprintf(file, "%08X-%08X    = %02X: %s [offset=%08X]\n",
-						bytestart, byteend, entry, handler_to_string(space, table, entry), table->handlers[entry]->bytestart);
+		UINT8 **bankptr = (entrynum >= STATIC_BANK1 && entrynum <= STATIC_BANKMAX) ? &space.m_machine.memory_data->bank_ptr[entrynum] : NULL;
+		m_handlers[entrynum] = auto_alloc(&space.m_machine, handler_entry_read(space.data_width(), space.endianness(), bankptr));
 	}
-}
 
-
-/*-------------------------------------------------
-    mem_dump - internal memory dump
--------------------------------------------------*/
-
-static void mem_dump(running_machine *machine)
-{
-	FILE *file;
-
-	if (MEM_DUMP)
+	// we have to allocate different object types based on the data bus width
+	switch (space.data_width())
 	{
-		file = fopen("memdump.log", "w");
-		if (file)
-		{
-			memory_dump(machine, file);
-			fclose(file);
-		}
-	}
-}
-
+		// 8-bit case
+		case 8:
+			m_handlers[STATIC_UNMAP]->set_delegate(read8_delegate_create(address_table_read, unmap_r<UINT8>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(read8_delegate_create(address_table_read, nop_r<UINT8>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(read8_delegate_create(address_table_read, watchpoint_r<UINT8>, *this));
+			break;
 
+		// 16-bit case
+		case 16:
+			m_handlers[STATIC_UNMAP]->set_delegate(read16_delegate_create(address_table_read, unmap_r<UINT16>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(read16_delegate_create(address_table_read, nop_r<UINT16>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(read16_delegate_create(address_table_read, watchpoint_r<UINT16>, *this));
+			break;
 
-/***************************************************************************
-    INPUT PORT READ HANDLERS
-***************************************************************************/
+		// 32-bit case
+		case 32:
+			m_handlers[STATIC_UNMAP]->set_delegate(read32_delegate_create(address_table_read, unmap_r<UINT32>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(read32_delegate_create(address_table_read, nop_r<UINT32>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(read32_delegate_create(address_table_read, watchpoint_r<UINT32>, *this));
+			break;
 
-/*-------------------------------------------------
-    input port handlers
--------------------------------------------------*/
+		// 64-bit case
+		case 64:
+			m_handlers[STATIC_UNMAP]->set_delegate(read64_delegate_create(address_table_read, unmap_r<UINT64>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(read64_delegate_create(address_table_read, nop_r<UINT64>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(read64_delegate_create(address_table_read, watchpoint_r<UINT64>, *this));
+			break;
+	}
 
-static UINT8 input_port_read8(const input_port_config *port, offs_t offset)
-{
-	return input_port_read_direct(port);
+	// reset the byte masks on the special handlers to open up the full address space for proper reporting
+	m_handlers[STATIC_UNMAP]->configure(0, space.bytemask(), ~0);
+	m_handlers[STATIC_NOP]->configure(0, space.bytemask(), ~0);
+	m_handlers[STATIC_WATCHPOINT]->configure(0, space.bytemask(), ~0);
 }
 
-static UINT16 input_port_read16(const input_port_config *port, offs_t offset, UINT16 mem_mask)
-{
-	return input_port_read_direct(port);
-}
 
-static UINT32 input_port_read32(const input_port_config *port, offs_t offset, UINT32 mem_mask)
-{
-	return input_port_read_direct(port);
-}
+//-------------------------------------------------
+//  address_table_read - destructor
+//-------------------------------------------------
 
-static UINT64 input_port_read64(const input_port_config *port, offs_t offset, UINT64 mem_mask)
+address_table_read::~address_table_read()
 {
-	return input_port_read_direct(port);
+	for (int handnum = 0; handnum < ARRAY_LENGTH(m_handlers); handnum++)
+		auto_free(&m_space.m_machine, m_handlers[handnum]);
 }
 
 
+//-------------------------------------------------
+//  handler - return the generic handler entry for
+//  this index
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    output port handlers
--------------------------------------------------*/
-
-static void input_port_write8(const input_port_config *port, offs_t offset, UINT8 data)
+handler_entry &address_table_read::handler(UINT32 index) const
 {
-	input_port_write_direct(port, data, 0xff);
+	assert(index < ARRAY_LENGTH(m_handlers));
+	return *m_handlers[index];
 }
 
-static void input_port_write16(const input_port_config *port, offs_t offset, UINT16 data, UINT16 mem_mask)
-{
-	input_port_write_direct(port, data, mem_mask);
-}
 
-static void input_port_write32(const input_port_config *port, offs_t offset, UINT32 data, UINT32 mem_mask)
-{
-	input_port_write_direct(port, data, mem_mask);
-}
+//-------------------------------------------------
+//  address_table_write - constructor
+//-------------------------------------------------
 
-static void input_port_write64(const input_port_config *port, offs_t offset, UINT64 data, UINT64 mem_mask)
+address_table_write::address_table_write(address_space &space, bool large)
+	: address_table(space, large)
 {
-	input_port_write_direct(port, data, mem_mask);
-}
-
+	// allocate handlers for each entry, prepopulating the bankptrs for banks
+	for (int entrynum = 0; entrynum < ARRAY_LENGTH(m_handlers); entrynum++)
+	{
+		UINT8 **bankptr = (entrynum >= STATIC_BANK1 && entrynum <= STATIC_BANKMAX) ? &space.m_machine.memory_data->bank_ptr[entrynum] : NULL;
+		m_handlers[entrynum] = auto_alloc(&space.m_machine, handler_entry_write(space.data_width(), space.endianness(), bankptr));
+	}
 
+	// we have to allocate different object types based on the data bus width
+	switch (space.data_width())
+	{
+		// 8-bit case
+		case 8:
+			m_handlers[STATIC_UNMAP]->set_delegate(write8_delegate_create(address_table_write, unmap_w<UINT8>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(write8_delegate_create(address_table_write, nop_w<UINT8>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(write8_delegate_create(address_table_write, watchpoint_w<UINT8>, *this));
+			break;
 
-/***************************************************************************
-    STUB HANDLERS THAT MAP TO BYTE READS
-***************************************************************************/
+		// 16-bit case
+		case 16:
+			m_handlers[STATIC_UNMAP]->set_delegate(write16_delegate_create(address_table_write, unmap_w<UINT16>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(write16_delegate_create(address_table_write, nop_w<UINT16>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(write16_delegate_create(address_table_write, watchpoint_w<UINT16>, *this));
+			break;
 
-/*-------------------------------------------------
-    stub_read8_from_16 - return a 16-bit
-    value combined from one or more byte accesses
--------------------------------------------------*/
-
-static READ16_HANDLER( stub_read8_from_16 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT16 result = 0;
+		// 32-bit case
+		case 32:
+			m_handlers[STATIC_UNMAP]->set_delegate(write32_delegate_create(address_table_write, unmap_w<UINT32>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(write32_delegate_create(address_table_write, nop_w<UINT32>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(write32_delegate_create(address_table_write, watchpoint_w<UINT32>, *this));
+			break;
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			result |= (*handler->subhandler.read.shandler8)((const address_space *)handler->subobject, offset) << shift;
-		offset++;
+		// 64-bit case
+		case 64:
+			m_handlers[STATIC_UNMAP]->set_delegate(write64_delegate_create(address_table_write, unmap_w<UINT64>, *this));
+			m_handlers[STATIC_NOP]->set_delegate(write64_delegate_create(address_table_write, nop_w<UINT64>, *this));
+			m_handlers[STATIC_WATCHPOINT]->set_delegate(write64_delegate_create(address_table_write, watchpoint_w<UINT64>, *this));
+			break;
 	}
-	return result;
+
+	// reset the byte masks on the special handlers to open up the full address space for proper reporting
+	m_handlers[STATIC_UNMAP]->configure(0, space.bytemask(), ~0);
+	m_handlers[STATIC_NOP]->configure(0, space.bytemask(), ~0);
+	m_handlers[STATIC_WATCHPOINT]->configure(0, space.bytemask(), ~0);
 }
 
 
-/*-------------------------------------------------
-    stub_read8_from_32 - return a 32-bit
-    value combined from one or more byte accesses
--------------------------------------------------*/
-
-static READ32_HANDLER( stub_read8_from_32 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT32 result = 0;
+//-------------------------------------------------
+//  address_table_write - destructor
+//-------------------------------------------------
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			result |= (*handler->subhandler.read.shandler8)((const address_space *)handler->subobject, offset) << shift;
-		offset++;
-	}
-	return result;
+address_table_write::~address_table_write()
+{
+	for (int handnum = 0; handnum < ARRAY_LENGTH(m_handlers); handnum++)
+		auto_free(&m_space.m_machine, m_handlers[handnum]);
 }
 
 
-/*-------------------------------------------------
-    stub_read8_from_64 - return a 64-bit
-    value combined from one or more byte accesses
--------------------------------------------------*/
-
-static READ64_HANDLER( stub_read8_from_64 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT64 result = 0;
+//-------------------------------------------------
+//  handler - return the generic handler entry for
+//  this index
+//-------------------------------------------------
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			result |= (UINT64)(*handler->subhandler.read.shandler8)((const address_space *)handler->subobject, offset) << shift;
-		offset++;
-	}
-	return result;
+handler_entry &address_table_write::handler(UINT32 index) const
+{
+	assert(index < ARRAY_LENGTH(m_handlers));
+	return *m_handlers[index];
 }
 
 
-/*-------------------------------------------------
-    stub_read16_from_32 - return a 32-bit
-    value combined from one or more word accesses
--------------------------------------------------*/
-
-static READ32_HANDLER( stub_read16_from_32 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT32 result = 0;
-
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT16)(mem_mask >> shift) != 0)
-			result |= (*handler->subhandler.read.shandler16)((const address_space *)handler->subobject, offset, mem_mask >> shift) << shift;
-		offset++;
-	}
-	return result;
-}
 
+//**************************************************************************
+//  DIRECT MEMORY RANGES
+//**************************************************************************
 
-/*-------------------------------------------------
-    stub_read16_from_64 - return a 64-bit
-    value combined from one or more word accesses
--------------------------------------------------*/
-
-static READ64_HANDLER( stub_read16_from_64 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT64 result = 0;
+//-------------------------------------------------
+//  direct_read_data - constructor
+//-------------------------------------------------
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT16)(mem_mask >> shift) != 0)
-			result |= (UINT64)(*handler->subhandler.read.shandler16)((const address_space *)handler->subobject, offset, mem_mask >> shift) << shift;
-		offset++;
-	}
-	return result;
+direct_read_data::direct_read_data(address_space &space)
+	: m_space(space),
+	  m_raw(NULL),
+	  m_decrypted(NULL),
+	  m_bytemask(space.bytemask()),
+	  m_bytestart(1),
+	  m_byteend(0),
+	  m_entry(STATIC_UNMAP)
+{
 }
 
 
-/*-------------------------------------------------
-    stub_read32_from_64 - return a 64-bit
-    value combined from one or more dword accesses
--------------------------------------------------*/
-
-static READ64_HANDLER( stub_read32_from_64 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-	UINT64 result = 0;
+//-------------------------------------------------
+//  ~direct_read_data - destructor
+//-------------------------------------------------
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT32)(mem_mask >> shift) != 0)
-			result |= (UINT64)(*handler->subhandler.read.shandler32)((const address_space *)handler->subobject, offset, mem_mask >> shift) << shift;
-		offset++;
-	}
-	return result;
+direct_read_data::~direct_read_data()
+{
 }
 
 
+//-------------------------------------------------
+//  set_direct_region - called by device cores to
+//  update the opcode base for the given address
+//-------------------------------------------------
 
-/***************************************************************************
-    STUB HANDLERS THAT MAP TO BYTE WRITES
-***************************************************************************/
-
-/*-------------------------------------------------
-    stub_write8_from_16 - convert a 16-bit
-    write to one or more byte accesses
--------------------------------------------------*/
-
-static WRITE16_HANDLER( stub_write8_from_16 )
+bool direct_read_data::set_direct_region(offs_t &byteaddress)
 {
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-
-	offset *= subunits;
-	while (subunits-- != 0)
+	// allow overrides
+	offs_t overrideaddress = byteaddress;
+	if (!m_directupdate.isnull())
 	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler8)((const address_space *)handler->subobject, offset, data >> shift);
-		offset++;
-	}
-}
+		overrideaddress = m_directupdate(*this, overrideaddress);
+		if (overrideaddress == ~0)
+			return true;
 
+		byteaddress = overrideaddress;
+	}
 
-/*-------------------------------------------------
-    stub_write8_from_32 - convert a 32-bit
-    write to one or more byte accesses
--------------------------------------------------*/
+	// remove the masked bits (we'll put them back later)
+	offs_t maskedbits = overrideaddress & ~m_bytemask;
 
-static WRITE32_HANDLER( stub_write8_from_32 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
+	// find or allocate a matching range
+	direct_range *range = find_range(overrideaddress, m_entry);
 
-	offset *= subunits;
-	while (subunits-- != 0)
+	// if we don't map to a bank, return FALSE
+	if (m_entry < STATIC_BANK1 || m_entry >= STATIC_RAM)
 	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler8)((const address_space *)handler->subobject, offset, data >> shift);
-		offset++;
+		// ensure future updates to land here as well until we get back into a bank
+		m_byteend = 0;
+		m_bytestart = 1;
+		return false;
 	}
+
+	// if no decrypted opcodes, point to the same base
+	UINT8 *base = m_space.m_machine.memory_data->bank_ptr[m_entry];
+	UINT8 *based = m_space.m_machine.memory_data->bankd_ptr[m_entry];
+	if (based == NULL)
+		based = base;
+
+	// compute the adjusted base
+	const handler_entry_read &handler = m_space.read().handler_read(m_entry);
+	m_bytemask = handler.bytemask();
+	m_raw = base - (handler.bytestart() & m_bytemask);
+	m_decrypted = based - (handler.bytestart() & m_bytemask);
+	m_bytestart = maskedbits | range->m_bytestart;
+	m_byteend = maskedbits | range->m_byteend;
+	return true;
 }
 
 
-/*-------------------------------------------------
-    stub_write8_from_64 - convert a 64-bit
-    write to one or more byte accesses
--------------------------------------------------*/
+//-------------------------------------------------
+//  find_range - find a byte address in a range
+//-------------------------------------------------
+
+direct_read_data::direct_range *direct_read_data::find_range(offs_t byteaddress, UINT8 &entry)
+{
+	// determine which entry
+	byteaddress &= m_space.m_bytemask;
+	entry = m_space.read().lookup_live(byteaddress);
+
+	// scan our table
+	for (direct_range *range = m_rangelist[entry].first(); range != NULL; range = range->next())
+		if (byteaddress >= range->m_bytestart && byteaddress <= range->m_byteend)
+			return range;
 
-static WRITE64_HANDLER( stub_write8_from_64 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
+	// didn't find out; allocate a new one
+	direct_range *range = m_freerangelist.first();
+	if (range != NULL)
+		m_freerangelist.detach(*range);
+	else
+		range = auto_alloc(&m_space.m_machine, direct_range);
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT8)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler8)((const address_space *)handler->subobject, offset, data >> shift);
-		offset++;
-	}
-}
+	// fill in the range
+	m_space.read().derive_range(byteaddress, range->m_bytestart, range->m_byteend);
+	m_rangelist[entry].prepend(*range);
 
+	return range;
+}
 
-/*-------------------------------------------------
-    stub_write16_from_32 - convert a 32-bit
-    write to one or more word accesses
--------------------------------------------------*/
 
-static WRITE32_HANDLER( stub_write16_from_32 )
-{
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
+//-------------------------------------------------
+//  remove_intersecting_ranges - remove all cached
+//  ranges that intersect the given address range
+//-------------------------------------------------
+
+void direct_read_data::remove_intersecting_ranges(offs_t bytestart, offs_t byteend)
+{
+	// loop over all entries
+	for (int entry = 0; entry < ARRAY_LENGTH(m_rangelist); entry++)
+	{
+		// loop over all ranges in this entry's list
+		direct_range *nextrange;
+		for (direct_range *range = m_rangelist[entry].first(); range != NULL; range = nextrange)
+		{
+			nextrange = range->next();
 
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT16)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler16)((const address_space *)handler->subobject, offset, data >> shift, mem_mask >> shift);
-		offset++;
+			// if we intersect, remove and add to the free range list
+			if (bytestart <= range->m_byteend && byteend >= range->m_bytestart)
+			{
+				m_rangelist[entry].detach(*range);
+				m_freerangelist.prepend(*range);
+			}
+		}
 	}
 }
 
 
-/*-------------------------------------------------
-    stub_write16_from_64 - convert a 64-bit
-    write to one or more word accesses
--------------------------------------------------*/
+//-------------------------------------------------
+//  set_direct_update - set a custom direct range
+//  update callback
+//-------------------------------------------------
 
-static WRITE64_HANDLER( stub_write16_from_64 )
+direct_update_delegate direct_read_data::set_direct_update(direct_update_delegate function)
 {
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT16)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler16)((const address_space *)handler->subobject, offset, data >> shift, mem_mask >> shift);
-		offset++;
-	}
+	direct_update_delegate old = m_directupdate;
+	m_directupdate = function;
+	return old;
 }
 
 
-/*-------------------------------------------------
-    stub_write32_from_64 - convert a 64-bit
-    write to one or more word accesses
--------------------------------------------------*/
+//-------------------------------------------------
+//  explicit_configure - explicitly configure
+//  the start/end/mask and the pointers from
+//  within a custom callback
+//-------------------------------------------------
 
-static WRITE64_HANDLER( stub_write32_from_64 )
+void direct_read_data::explicit_configure(offs_t bytestart, offs_t byteend, offs_t bytemask, void *raw, void *decrypted)
 {
-	const handler_data *handler = (const handler_data *)space;
-	const UINT8 *subshift = handler->subshift;
-	int subunits = handler->subunits;
-
-	offset *= subunits;
-	while (subunits-- != 0)
-	{
-		int shift = *subshift++;
-		if ((UINT32)(mem_mask >> shift) != 0)
-			(*handler->subhandler.write.shandler32)((const address_space *)handler->subobject, offset, data >> shift, mem_mask >> shift);
-		offset++;
-	}
+	m_bytestart = bytestart;
+	m_byteend = byteend;
+	m_bytemask = bytemask;
+	m_raw = reinterpret_cast<UINT8 *>(raw);
+	m_decrypted = reinterpret_cast<UINT8 *>((decrypted == NULL) ? raw : decrypted);
+	m_raw -= bytestart & bytemask;
+	m_decrypted -= bytestart & bytemask;
 }
 
 
 
-/***************************************************************************
-    STUB ACCESSORS
-***************************************************************************/
+//**************************************************************************
+//  MEMORY BLOCK
+//**************************************************************************
 
-/*-------------------------------------------------
-    get_stub_handler - return the appropriate
-    stub handler
--------------------------------------------------*/
+//-------------------------------------------------
+//  memory_block - constructor
+//-------------------------------------------------
 
-static memory_handler get_stub_handler(read_or_write readorwrite, int spacedbits, int handlerdbits)
+memory_block::memory_block(address_space &space, offs_t bytestart, offs_t byteend, void *memory)
+	: m_next(NULL),
+	  m_machine(space.m_machine),
+	  m_space(space),
+	  m_isallocated(memory == NULL),
+	  m_bytestart(bytestart),
+	  m_byteend(byteend),
+	  m_data((memory != NULL) ? reinterpret_cast<UINT8 *>(memory) : auto_alloc_array_clear(&space.m_machine, UINT8, byteend + 1 - bytestart))
 {
-	memory_handler result = { 0 };
-
-	/* read stubs */
-	if (readorwrite == ROW_READ)
-	{
-		/* 16-bit read stubs */
-		if (spacedbits == 16)
-		{
-			if (handlerdbits == 8)
-				result.read.shandler16 = stub_read8_from_16;
-		}
-
-		/* 32-bit read stubs */
-		else if (spacedbits == 32)
-		{
-			if (handlerdbits == 8)
-				result.read.shandler32 = stub_read8_from_32;
-			else if (handlerdbits == 16)
-				result.read.shandler32 = stub_read16_from_32;
-		}
+	VPRINTF(("block_allocate('%s',%s,%08X,%08X,%p)\n", space.device().tag(), space.name(), bytestart, byteend, memory));
 
-		/* 64-bit read stubs */
-		else if (spacedbits == 64)
+	// register for saving, but only if we're not part of a memory region
+	const region_info *region;
+	for (region = space.m_machine.m_regionlist.first(); region != NULL; region = region->next())
+		if (m_data >= region->base() && (m_data + (byteend - bytestart + 1)) < region->end())
 		{
-			if (handlerdbits == 8)
-				result.read.shandler64 = stub_read8_from_64;
-			else if (handlerdbits == 16)
-				result.read.shandler64 = stub_read16_from_64;
-			else if (handlerdbits == 32)
-				result.read.shandler64 = stub_read32_from_64;
+			VPRINTF(("skipping save of this memory block as it is covered by a memory region\n"));
+			break;
 		}
-	}
 
-	/* write stubs */
-	else if (readorwrite == ROW_WRITE)
+	// if we didn't find a match, register
+	if (region == NULL)
 	{
-		/* 16-bit write stubs */
-		if (spacedbits == 16)
-		{
-			if (handlerdbits == 8)
-				result.write.shandler16 = stub_write8_from_16;
-		}
-
-		/* 32-bit write stubs */
-		else if (spacedbits == 32)
-		{
-			if (handlerdbits == 8)
-				result.write.shandler32 = stub_write8_from_32;
-			else if (handlerdbits == 16)
-				result.write.shandler32 = stub_write16_from_32;
-		}
-
-		/* 64-bit write stubs */
-		else if (spacedbits == 64)
-		{
-			if (handlerdbits == 8)
-				result.write.shandler64 = stub_write8_from_64;
-			else if (handlerdbits == 16)
-				result.write.shandler64 = stub_write16_from_64;
-			else if (handlerdbits == 32)
-				result.write.shandler64 = stub_write32_from_64;
-		}
+		int bytes_per_element = space.data_width() / 8;
+		astring name;
+		name.printf("%08x-%08x", bytestart, byteend);
+		state_save_register_memory(&space.m_machine, "memory", space.device().tag(), space.spacenum(), name, m_data, bytes_per_element, (UINT32)(byteend + 1 - bytestart) / bytes_per_element, __FILE__, __LINE__);
 	}
-
-	assert(result.read.generic != NULL);
-	return result;
 }
 
 
+//-------------------------------------------------
+//  memory_block - destructor
+//-------------------------------------------------
 
-/***************************************************************************
-    8-BIT READ HANDLERS
-***************************************************************************/
-
-UINT8 memory_read_byte_8le(const address_space *space, offs_t address)
+memory_block::~memory_block()
 {
-	return read_byte_generic(space, address);
+	if (m_isallocated)
+		auto_free(&m_machine, m_data);
 }
 
-UINT8 memory_read_byte_8be(const address_space *space, offs_t address)
-{
-	return read_byte_generic(space, address);
-}
 
-UINT16 memory_read_word_8le(const address_space *space, offs_t address)
-{
-	UINT16 result = memory_read_byte_8le(space, address + 0) << 0;
-	return result | (memory_read_byte_8le(space, address + 1) << 8);
-}
 
-UINT16 memory_read_word_masked_8le(const address_space *space, offs_t address, UINT16 mask)
-{
-	UINT16 result = 0;
-	if (mask & 0x00ff) result |= memory_read_byte_8le(space, address + 0) << 0;
-	if (mask & 0xff00) result |= memory_read_byte_8le(space, address + 1) << 8;
-	return result;
-}
+//**************************************************************************
+//  MEMORY BANK
+//**************************************************************************
 
-UINT16 memory_read_word_8be(const address_space *space, offs_t address)
-{
-	UINT16 result = memory_read_byte_8be(space, address + 0) << 8;
-	return result | (memory_read_byte_8be(space, address + 1) << 0);
-}
+//-------------------------------------------------
+//  memory_bank - constructor
+//-------------------------------------------------
 
-UINT16 memory_read_word_masked_8be(const address_space *space, offs_t address, UINT16 mask)
+memory_bank::memory_bank(address_space &space, int index, offs_t bytestart, offs_t byteend, const char *tag)
+	: m_next(NULL),
+	  m_machine(space.m_machine),
+	  m_baseptr(&space.m_machine.memory_data->bank_ptr[index]),
+	  m_basedptr(&space.m_machine.memory_data->bankd_ptr[index]),
+	  m_index(index),
+	  m_anonymous(tag == NULL),
+	  m_bytestart(bytestart),
+	  m_byteend(byteend),
+	  m_curentry(BANK_ENTRY_UNSPECIFIED),
+	  m_entry(NULL),
+	  m_entry_count(0)
 {
-	UINT16 result = 0;
-	if (mask & 0xff00) result |= memory_read_byte_8be(space, address + 0) << 8;
-	if (mask & 0x00ff) result |= memory_read_byte_8be(space, address + 1) << 0;
-	return result;
-}
+	// generate an internal tag if we don't have one
+	if (tag == NULL)
+	{
+		m_tag.printf("~%d~", index);
+		m_name.printf("Internal bank #%d", index);
+	}
+	else
+	{
+		m_tag.cpy(tag);
+		m_name.printf("Bank '%s'", tag);
+	}
 
-UINT32 memory_read_dword_8le(const address_space *space, offs_t address)
-{
-	UINT32 result = memory_read_word_8le(space, address + 0) << 0;
-	return result | (memory_read_word_8le(space, address + 2) << 16);
+	if (!m_anonymous && state_save_registration_allowed(&space.m_machine))
+		state_save_register_item(&space.m_machine, "memory", m_tag, 0, m_curentry);
 }
 
-UINT32 memory_read_dword_masked_8le(const address_space *space, offs_t address, UINT32 mask)
-{
-	UINT32 result = 0;
-	if (mask & 0x0000ffff) result |= memory_read_word_masked_8le(space, address + 0, mask >> 0) << 0;
-	if (mask & 0xffff0000) result |= memory_read_word_masked_8le(space, address + 2, mask >> 16) << 16;
-	return result;
-}
 
-UINT32 memory_read_dword_8be(const address_space *space, offs_t address)
-{
-	UINT32 result = memory_read_word_8be(space, address + 0) << 16;
-	return result | (memory_read_word_8be(space, address + 2) << 0);
-}
+//-------------------------------------------------
+//  memory_bank - destructor
+//-------------------------------------------------
 
-UINT32 memory_read_dword_masked_8be(const address_space *space, offs_t address, UINT32 mask)
+memory_bank::~memory_bank()
 {
-	UINT32 result = 0;
-	if (mask & 0xffff0000) result |= memory_read_word_masked_8be(space, address + 0, mask >> 16) << 16;
-	if (mask & 0x0000ffff) result |= memory_read_word_masked_8be(space, address + 2, mask >> 0) << 0;
-	return result;
+	auto_free(&m_machine, m_entry);
 }
 
-UINT64 memory_read_qword_8le(const address_space *space, offs_t address)
-{
-	UINT64 result = (UINT64)memory_read_dword_8le(space, address + 0) << 0;
-	return result | ((UINT64)memory_read_dword_8le(space, address + 4) << 32);
-}
 
-UINT64 memory_read_qword_masked_8le(const address_space *space, offs_t address, UINT64 mask)
-{
-	UINT64 result = 0;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_8le(space, address + 0, mask >> 0) << 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_8le(space, address + 4, mask >> 32) << 32;
-	return result;
-}
+//-------------------------------------------------
+//  references_space - walk the list of references
+//  to find a match against the provided space
+//  and read/write
+//-------------------------------------------------
 
-UINT64 memory_read_qword_8be(const address_space *space, offs_t address)
+bool memory_bank::references_space(address_space &space, read_or_write readorwrite) const
 {
-	UINT64 result = (UINT64)memory_read_dword_8be(space, address + 0) << 32;
-	return result | ((UINT64)memory_read_dword_8be(space, address + 4) << 0);
+	for (bank_reference *ref = m_reflist.first(); ref != NULL; ref = ref->next())
+		if (ref->matches(space, readorwrite))
+			return true;
+	return false;
 }
 
-UINT64 memory_read_qword_masked_8be(const address_space *space, offs_t address, UINT64 mask)
+
+//-------------------------------------------------
+//  add_reference - add a new reference to the
+//  given space
+//-------------------------------------------------
+
+void memory_bank::add_reference(address_space &space, read_or_write readorwrite)
 {
-	UINT64 result = 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_8be(space, address + 0, mask >> 32) << 32;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_8be(space, address + 4, mask >> 0) << 0;
-	return result;
+	// if we already have a reference, skip it
+	if (references_space(space, readorwrite))
+		return;
+	m_reflist.append(*auto_alloc(&space.m_machine, bank_reference(space, readorwrite)));
 }
 
 
+//-------------------------------------------------
+//  invalidate_references - force updates on all
+//  referencing address spaces
+//-------------------------------------------------
 
-/***************************************************************************
-    8-BIT WRITE HANDLERS
-***************************************************************************/
-
-void memory_write_byte_8le(const address_space *space, offs_t address, UINT8 data)
+void memory_bank::invalidate_references()
 {
-	write_byte_generic(space, address, data);
+	// invalidate all the direct references to any referenced address spaces
+	for (bank_reference *ref = m_reflist.first(); ref != NULL; ref = ref->next())
+		ref->space().direct().force_update();
 }
 
-void memory_write_byte_8be(const address_space *space, offs_t address, UINT8 data)
-{
-	write_byte_generic(space, address, data);
-}
 
-void memory_write_word_8le(const address_space *space, offs_t address, UINT16 data)
-{
-	memory_write_byte_8le(space, address + 0, data >> 0);
-	memory_write_byte_8le(space, address + 1, data >> 8);
-}
+//-------------------------------------------------
+//  set_base - set the bank base explicitly
+//-------------------------------------------------
 
-void memory_write_word_masked_8le(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
+void memory_bank::set_base(void *base)
 {
-	if (mask & 0x00ff) memory_write_byte_8le(space, address + 0, data >> 0);
-	if (mask & 0xff00) memory_write_byte_8le(space, address + 1, data >> 8);
-}
+	// NULL is not an option
+	if (base == NULL)
+		throw emu_fatalerror("memory_bank::set_base called NULL base");
 
-void memory_write_word_8be(const address_space *space, offs_t address, UINT16 data)
-{
-	memory_write_byte_8be(space, address + 0, data >> 8);
-	memory_write_byte_8be(space, address + 1, data >> 0);
+	// set the base and invalidate any referencing spaces
+	*m_baseptr = reinterpret_cast<UINT8 *>(base);
+	invalidate_references();
 }
 
-void memory_write_word_masked_8be(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
-{
-	if (mask & 0xff00) memory_write_byte_8be(space, address + 0, data >> 8);
-	if (mask & 0x00ff) memory_write_byte_8be(space, address + 1, data >> 0);
-}
 
-void memory_write_dword_8le(const address_space *space, offs_t address, UINT32 data)
-{
-	memory_write_word_8le(space, address + 0, data >> 0);
-	memory_write_word_8le(space, address + 2, data >> 16);
-}
+//-------------------------------------------------
+//  set_base_decrypted - set the decrypted base
+//  explicitly
+//-------------------------------------------------
 
-void memory_write_dword_masked_8le(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
+void memory_bank::set_base_decrypted(void *base)
 {
-	if (mask & 0x0000ffff) memory_write_word_masked_8le(space, address + 0, data >> 0, mask >> 0);
-	if (mask & 0xffff0000) memory_write_word_masked_8le(space, address + 2, data >> 16, mask >> 16);
-}
+	// NULL is not an option
+	if (base == NULL)
+		throw emu_fatalerror("memory_bank::set_base called NULL base");
 
-void memory_write_dword_8be(const address_space *space, offs_t address, UINT32 data)
-{
-	memory_write_word_8be(space, address + 0, data >> 16);
-	memory_write_word_8be(space, address + 2, data >> 0);
+	// set the base and invalidate any referencing spaces
+	*m_basedptr = reinterpret_cast<UINT8 *>(base);
+	invalidate_references();
 }
 
-void memory_write_dword_masked_8be(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
-{
-	if (mask & 0xffff0000) memory_write_word_masked_8be(space, address + 0, data >> 16, mask >> 16);
-	if (mask & 0x0000ffff) memory_write_word_masked_8be(space, address + 2, data >> 0, mask >> 0);
-}
 
-void memory_write_qword_8le(const address_space *space, offs_t address, UINT64 data)
-{
-	memory_write_dword_8le(space, address + 0, data >> 0);
-	memory_write_dword_8le(space, address + 4, data >> 32);
-}
+//-------------------------------------------------
+//  set_entry - set the base to a pre-configured
+//  entry
+//-------------------------------------------------
 
-void memory_write_qword_masked_8le(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
+void memory_bank::set_entry(int entrynum)
 {
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_8le(space, address + 0, data >> 0, mask >> 0);
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_8le(space, address + 4, data >> 32, mask >> 32);
-}
+	// validate
+	if (m_anonymous)
+		throw emu_fatalerror("memory_bank::set_entry called for anonymous bank");
+	if (entrynum < 0 || entrynum >= m_entry_count)
+		throw emu_fatalerror("memory_bank::set_entry called with out-of-range entry %d", entrynum);
+	if (m_entry[entrynum].m_raw == NULL)
+		throw emu_fatalerror("memory_bank::set_entry called for bank '%s' with invalid bank entry %d", m_tag.cstr(), entrynum);
 
-void memory_write_qword_8be(const address_space *space, offs_t address, UINT64 data)
-{
-	memory_write_dword_8be(space, address + 0, data >> 32);
-	memory_write_dword_8be(space, address + 4, data >> 0);
-}
+	// set both raw and decrypted values
+	m_curentry = entrynum;
+	*m_baseptr = m_entry[entrynum].m_raw;
+	*m_basedptr = m_entry[entrynum].m_decrypted;
 
-void memory_write_qword_masked_8be(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
-{
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_8be(space, address + 0, data >> 32, mask >> 32);
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_8be(space, address + 4, data >> 0, mask >> 0);
+	// invalidate referencing spaces
+	invalidate_references();
 }
 
 
+//-------------------------------------------------
+//  expand_entries - expand the allocated array
+//  of entries
+//-------------------------------------------------
 
-/***************************************************************************
-    16-BIT READ HANDLERS
-***************************************************************************/
-
-UINT8 memory_read_byte_16le(const address_space *space, offs_t address)
+void memory_bank::expand_entries(int entrynum)
 {
-	UINT32 shift = (address & 1) * 8;
-	return read_word_generic(space, address, 0xff << shift) >> shift;
-}
+	int newcount = entrynum + 1;
 
-UINT8 memory_read_byte_16be(const address_space *space, offs_t address)
-{
-	UINT32 shift = (~address & 1) * 8;
-	return read_word_generic(space, address, 0xff << shift) >> shift;
-}
+	// allocate a new array and copy from the old one; zero out the new entries
+	bank_entry *newentry = auto_alloc_array(&m_machine, bank_entry, newcount);
+	memcpy(newentry, m_entry, sizeof(m_entry[0]) * m_entry_count);
+	memset(&newentry[m_entry_count], 0, (newcount - m_entry_count) * sizeof(m_entry[0]));
 
-UINT16 memory_read_word_16le(const address_space *space, offs_t address)
-{
-	return read_word_generic(space, address, 0xffff);
+	// free the old array and set the updated values
+	auto_free(&m_machine, m_entry);
+	m_entry = newentry;
+	m_entry_count = newcount;
 }
 
-UINT16 memory_read_word_masked_16le(const address_space *space, offs_t address, UINT16 mask)
-{
-	return read_word_generic(space, address, mask);
-}
 
-UINT16 memory_read_word_16be(const address_space *space, offs_t address)
-{
-	return read_word_generic(space, address, 0xffff);
-}
+//-------------------------------------------------
+//  configure - configure an entry
+//-------------------------------------------------
 
-UINT16 memory_read_word_masked_16be(const address_space *space, offs_t address, UINT16 mask)
+void memory_bank::configure(int entrynum, void *base)
 {
-	return read_word_generic(space, address, mask);
-}
+	// must be positive
+	if (entrynum < 0)
+		throw emu_fatalerror("memory_bank::configure called with out-of-range entry %d", entrynum);
 
-UINT32 memory_read_dword_16le(const address_space *space, offs_t address)
-{
-	UINT32 result = memory_read_word_16le(space, address + 0) << 0;
-	return result | (memory_read_word_16le(space, address + 2) << 16);
-}
+	// if we haven't allocated this many entries yet, expand our array
+	if (entrynum >= m_entry_count)
+		expand_entries(entrynum);
 
-UINT32 memory_read_dword_masked_16le(const address_space *space, offs_t address, UINT32 mask)
-{
-	UINT32 result = 0;
-	if (mask & 0x0000ffff) result |= memory_read_word_masked_16le(space, address + 0, mask >> 0) << 0;
-	if (mask & 0xffff0000) result |= memory_read_word_masked_16le(space, address + 2, mask >> 16) << 16;
-	return result;
-}
+	// set the entry
+	m_entry[entrynum].m_raw = reinterpret_cast<UINT8 *>(base);
 
-UINT32 memory_read_dword_16be(const address_space *space, offs_t address)
-{
-	UINT32 result = memory_read_word_16be(space, address + 0) << 16;
-	return result | (memory_read_word_16be(space, address + 2) << 0);
+	// if the bank base is not configured, and we're the first entry, set us up
+	if (*m_baseptr == NULL && entrynum == 0)
+		*m_baseptr = m_entry[entrynum].m_raw;
 }
 
-UINT32 memory_read_dword_masked_16be(const address_space *space, offs_t address, UINT32 mask)
-{
-	UINT32 result = 0;
-	if (mask & 0xffff0000) result |= memory_read_word_masked_16be(space, address + 0, mask >> 16) << 16;
-	if (mask & 0x0000ffff) result |= memory_read_word_masked_16be(space, address + 2, mask >> 0) << 0;
-	return result;
-}
 
-UINT64 memory_read_qword_16le(const address_space *space, offs_t address)
-{
-	UINT64 result = (UINT64)memory_read_dword_16le(space, address + 0) << 0;
-	return result | ((UINT64)memory_read_dword_16le(space, address + 4) << 32);
-}
+//-------------------------------------------------
+//  configure_decrypted - configure a decrypted
+//  entry
+//-------------------------------------------------
 
-UINT64 memory_read_qword_masked_16le(const address_space *space, offs_t address, UINT64 mask)
+void memory_bank::configure_decrypted(int entrynum, void *base)
 {
-	UINT64 result = 0;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_16le(space, address + 0, mask >> 0) << 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_16le(space, address + 4, mask >> 32) << 32;
-	return result;
-}
+	// must be positive
+	if (entrynum < 0)
+		throw emu_fatalerror("memory_bank::configure called with out-of-range entry %d", entrynum);
 
-UINT64 memory_read_qword_16be(const address_space *space, offs_t address)
-{
-	UINT64 result = (UINT64)memory_read_dword_16be(space, address + 0) << 32;
-	return result | ((UINT64)memory_read_dword_16be(space, address + 4) << 0);
-}
+	// if we haven't allocated this many entries yet, expand our array
+	if (entrynum >= m_entry_count)
+		expand_entries(entrynum);
 
-UINT64 memory_read_qword_masked_16be(const address_space *space, offs_t address, UINT64 mask)
-{
-	UINT64 result = 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_16be(space, address + 0, mask >> 32) << 32;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_16be(space, address + 4, mask >> 0) << 0;
-	return result;
+	// set the entry
+	m_entry[entrynum].m_decrypted = reinterpret_cast<UINT8 *>(base);
+
+	// if the bank base is not configured, and we're the first entry, set us up
+	if (*m_basedptr == NULL && entrynum == 0)
+		*m_basedptr = m_entry[entrynum].m_decrypted;
 }
 
 
 
-/***************************************************************************
-    16-BIT WRITE HANDLERS
-***************************************************************************/
+//**************************************************************************
+//  HANDLER ENTRY
+//**************************************************************************
 
-void memory_write_byte_16le(const address_space *space, offs_t address, UINT8 data)
-{
-	UINT32 shift = (address & 1) * 8;
-	write_word_generic(space, address, data << shift, 0xff << shift);
-}
+//-------------------------------------------------
+//  handler_entry - constructor
+//-------------------------------------------------
 
-void memory_write_byte_16be(const address_space *space, offs_t address, UINT8 data)
+handler_entry::handler_entry(UINT8 width, endianness_t endianness, UINT8 **rambaseptr)
+	: m_populated(false),
+	  m_datawidth(width),
+	  m_endianness(endianness),
+	  m_bytestart(0),
+	  m_byteend(0),
+	  m_bytemask(~0),
+	  m_rambaseptr(rambaseptr),
+	  m_subunits(0)
 {
-	UINT32 shift = (~address & 1) * 8;
-	write_word_generic(space, address, data << shift, 0xff << shift);
 }
 
-void memory_write_word_16le(const address_space *space, offs_t address, UINT16 data)
-{
-	write_word_generic(space, address, data, 0xffff);
-}
 
-void memory_write_word_masked_16le(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
-{
-	write_word_generic(space, address, data, mask);
-}
+//-------------------------------------------------
+//  ~handler_entry - destructor
+//-------------------------------------------------
 
-void memory_write_word_16be(const address_space *space, offs_t address, UINT16 data)
+handler_entry::~handler_entry()
 {
-	write_word_generic(space, address, data, 0xffff);
 }
 
-void memory_write_word_masked_16be(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
-{
-	write_word_generic(space, address, data, mask);
-}
 
-void memory_write_dword_16le(const address_space *space, offs_t address, UINT32 data)
-{
-	memory_write_word_16le(space, address + 0, data >> 0);
-	memory_write_word_16le(space, address + 2, data >> 16);
-}
+//-------------------------------------------------
+//  configure_subunits - configure the subunits
+//  and subshift array to represent the provided
+//  mask
+//-------------------------------------------------
 
-void memory_write_dword_masked_16le(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
+void handler_entry::configure_subunits(UINT64 handlermask, int handlerbits)
 {
-	if (mask & 0x0000ffff) memory_write_word_masked_16le(space, address + 0, data >> 0, mask >> 0);
-	if (mask & 0xffff0000) memory_write_word_masked_16le(space, address + 2, data >> 16, mask >> 16);
-}
+	UINT64 unitmask = ((UINT64)1 << handlerbits) - 1;
+	assert(handlermask != 0);
 
-void memory_write_dword_16be(const address_space *space, offs_t address, UINT32 data)
-{
-	memory_write_word_16be(space, address + 0, data >> 16);
-	memory_write_word_16be(space, address + 2, data >> 0);
-}
+	// compute the maximum possible subunits
+	int maxunits = m_datawidth / handlerbits;
+	assert(maxunits > 1);
+	assert(maxunits < ARRAY_LENGTH(m_subshift));
 
-void memory_write_dword_masked_16be(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
-{
-	if (mask & 0xffff0000) memory_write_word_masked_16be(space, address + 0, data >> 16, mask >> 16);
-	if (mask & 0x0000ffff) memory_write_word_masked_16be(space, address + 2, data >> 0, mask >> 0);
-}
+	// walk the handlermask to find out how many we have
+	m_subunits = 0;
+	for (int unitnum = 0; unitnum < maxunits; unitnum++)
+	{
+		UINT64 scanmask = unitmask << (unitnum * handlerbits);
+		assert((handlermask & scanmask) == 0 || (handlermask & scanmask) == scanmask);
+		if ((handlermask & scanmask) != 0)
+			m_subunits++;
+	}
 
-void memory_write_qword_16le(const address_space *space, offs_t address, UINT64 data)
-{
-	memory_write_dword_16le(space, address + 0, data >> 0);
-	memory_write_dword_16le(space, address + 4, data >> 32);
+	// then fill in the shifts based on the endianness
+	if (m_endianness == ENDIANNESS_LITTLE)
+	{
+		UINT8 *unitshift = &m_subshift[0];
+		for (int unitnum = 0; unitnum < maxunits; unitnum++)
+			if ((handlermask & (unitmask << (unitnum * handlerbits))) != 0)
+				*unitshift++ = unitnum * handlerbits;
+	}
+	else
+	{
+		UINT8 *unitshift = &m_subshift[m_subunits];
+		for (int unitnum = 0; unitnum < maxunits; unitnum++)
+			if ((handlermask & (unitmask << (unitnum * handlerbits))) != 0)
+				*--unitshift = unitnum * handlerbits;
+	}
 }
 
-void memory_write_qword_masked_16le(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
-{
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_16le(space, address + 0, data >> 0, mask >> 0);
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_16le(space, address + 4, data >> 32, mask >> 32);
+
+
+//**************************************************************************
+//  HANDLER ENTRY READ
+//**************************************************************************
+
+//-------------------------------------------------
+//  name - return the handler name, from the
+//  appropriately-sized delegate
+//-------------------------------------------------
+
+const char *handler_entry_read::name() const
+{
+	switch (m_datawidth)
+	{
+		case 8:		return m_read8.name();
+		case 16:	return m_read16.name();
+		case 32:	return m_read32.name();
+		case 64:	return m_read64.name();
+	}
+	return NULL;
 }
 
-void memory_write_qword_16be(const address_space *space, offs_t address, UINT64 data)
+
+//-------------------------------------------------
+//  set_delegate - set an 8-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
+
+void handler_entry_read::set_delegate(read8_delegate delegate, UINT64 mask)
 {
-	memory_write_dword_16be(space, address + 0, data >> 32);
-	memory_write_dword_16be(space, address + 4, data >> 0);
+	// error if no object
+	if (!delegate.has_object())
+		throw emu_fatalerror("Attempted to install delegate '%s' without a bound object", delegate.name());
+
+	// make sure this is a valid size
+	assert(m_datawidth >= 8);
+	m_read8 = delegate;
+
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 8)
+	{
+		configure_subunits(mask, 8);
+		if (m_datawidth == 16)
+			set_delegate(read16_delegate(read16_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_16_from_8>(delegate.name()), *this));
+		else if (m_datawidth == 32)
+			set_delegate(read32_delegate(read32_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_32_from_8>(delegate.name()), *this));
+		else if (m_datawidth == 64)
+			set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_64_from_8>(delegate.name()), *this));
+	}
 }
 
-void memory_write_qword_masked_16be(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
+
+//-------------------------------------------------
+//  set_delegate - set a 16-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
+
+void handler_entry_read::set_delegate(read16_delegate delegate, UINT64 mask)
 {
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_16be(space, address + 0, data >> 32, mask >> 32);
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_16be(space, address + 4, data >> 0, mask >> 0);
-}
+	// error if no object
+	if (!delegate.has_object())
+		throw emu_fatalerror("Attempted to install delegate '%s' without a bound object", delegate.name());
+
+	// make sure this is a valid size
+	assert(m_datawidth >= 16);
+	m_read16 = delegate;
 
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 16)
+	{
+		configure_subunits(mask, 16);
+		if (m_datawidth == 32)
+			set_delegate(read32_delegate(read32_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_32_from_16>(delegate.name()), *this));
+		else if (m_datawidth == 64)
+			set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_64_from_16>(delegate.name()), *this));
+	}
+}
 
 
-/***************************************************************************
-    32-BIT READ HANDLERS
-***************************************************************************/
+//-------------------------------------------------
+//  set_delegate - set a 32-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
 
-UINT8 memory_read_byte_32le(const address_space *space, offs_t address)
+void handler_entry_read::set_delegate(read32_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (address & 3) * 8;
-	return read_dword_generic(space, address, 0xff << shift) >> shift;
+	// error if no object
+	if (!delegate.has_object())
+		throw emu_fatalerror("Attempted to install delegate '%s' without a bound object", delegate.name());
+
+	// make sure this is a valid size
+	assert(m_datawidth >= 32);
+	m_read32 = delegate;
+
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 32)
+	{
+		configure_subunits(mask, 16);
+		if (m_datawidth == 64)
+			set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_64_from_32>(delegate.name()), *this));
+	}
 }
 
-UINT8 memory_read_byte_32be(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_delegate - set a 64-bit delegate
+//-------------------------------------------------
+
+void handler_entry_read::set_delegate(read64_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (~address & 3) * 8;
-	return read_dword_generic(space, address, 0xff << shift) >> shift;
+	// error if no object
+	if (!delegate.has_object())
+		throw emu_fatalerror("Attempted to install delegate '%s' without a bound object", delegate.name());
+
+	// make sure this is a valid size
+	assert(m_datawidth >= 64);
+	m_read64 = delegate;
 }
 
-UINT16 memory_read_word_32le(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_legacy_func - configure a legacy address
+//  space stub of the appropriate size
+//-------------------------------------------------
+
+void handler_entry_read::set_legacy_func(address_space &space, read8_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (address & 2) * 8;
-	return read_dword_generic(space, address, 0xffff << shift) >> shift;
+	m_legacy_handler.space8 = func;
+	m_legacy_object.space = &space;
+	set_delegate(read8_delegate(read8_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT16 memory_read_word_masked_32le(const address_space *space, offs_t address, UINT16 mask)
+void handler_entry_read::set_legacy_func(address_space &space, read16_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (address & 2) * 8;
-	return read_dword_generic(space, address, mask << shift) >> shift;
+	m_legacy_handler.space16 = func;
+	m_legacy_object.space = &space;
+	set_delegate(read16_delegate(read16_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT16 memory_read_word_32be(const address_space *space, offs_t address)
+void handler_entry_read::set_legacy_func(address_space &space, read32_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (~address & 2) * 8;
-	return read_dword_generic(space, address, 0xffff << shift) >> shift;
+	m_legacy_handler.space32 = func;
+	m_legacy_object.space = &space;
+	set_delegate(read32_delegate(read32_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT16 memory_read_word_masked_32be(const address_space *space, offs_t address, UINT16 mask)
+void handler_entry_read::set_legacy_func(address_space &space, read64_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (~address & 2) * 8;
-	return read_dword_generic(space, address, mask << shift) >> shift;
+	m_legacy_handler.space64 = func;
+	m_legacy_object.space = &space;
+	set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_32le(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_legacy_func - configure a legacy device
+//  stub of the appropriate size
+//-------------------------------------------------
+
+void handler_entry_read::set_legacy_func(device_t &device, read8_device_func func, const char *name, UINT64 mask)
 {
-	return read_dword_generic(space, address, 0xffffffff);
+	m_legacy_handler.device8 = func;
+	m_legacy_object.device = &device;
+	set_delegate(read8_delegate(read8_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_masked_32le(const address_space *space, offs_t address, UINT32 mask)
+void handler_entry_read::set_legacy_func(device_t &device, read16_device_func func, const char *name, UINT64 mask)
 {
-	return read_dword_generic(space, address, mask);
+	m_legacy_handler.device16 = func;
+	m_legacy_object.device = &device;
+	set_delegate(read16_delegate(read16_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_32be(const address_space *space, offs_t address)
+void handler_entry_read::set_legacy_func(device_t &device, read32_device_func func, const char *name, UINT64 mask)
 {
-	return read_dword_generic(space, address, 0xffffffff);
+	m_legacy_handler.device32 = func;
+	m_legacy_object.device = &device;
+	set_delegate(read32_delegate(read32_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_masked_32be(const address_space *space, offs_t address, UINT32 mask)
+void handler_entry_read::set_legacy_func(device_t &device, read64_device_func func, const char *name, UINT64 mask)
 {
-	return read_dword_generic(space, address, mask);
+	m_legacy_handler.device64 = func;
+	m_legacy_object.device = &device;
+	set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_legacy>(name), *this), mask);
 }
 
-UINT64 memory_read_qword_32le(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_ioport - configure an I/O port read stub
+//  of the appropriate size
+//-------------------------------------------------
+
+void handler_entry_read::set_ioport(const input_port_config &ioport)
 {
-	UINT64 result = (UINT64)memory_read_dword_32le(space, address + 0) << 0;
-	return result | ((UINT64)memory_read_dword_32le(space, address + 4) << 32);
+	m_ioport = &ioport;
+	if (m_datawidth == 8)
+		set_delegate(read8_delegate(read8_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_ioport<UINT8> >(ioport.tag), *this));
+	else if (m_datawidth == 16)
+		set_delegate(read16_delegate(read16_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_ioport<UINT16> >(ioport.tag), *this));
+	else if (m_datawidth == 32)
+		set_delegate(read32_delegate(read32_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_ioport<UINT32> >(ioport.tag), *this));
+	else if (m_datawidth == 64)
+		set_delegate(read64_delegate(read64_proto_delegate::_create_member<handler_entry_read, &handler_entry_read::read_stub_ioport<UINT64> >(ioport.tag), *this));
 }
 
-UINT64 memory_read_qword_masked_32le(const address_space *space, offs_t address, UINT64 mask)
+
+//-------------------------------------------------
+//  read_stub_16_from_8 - construct a 16-bit read
+//  from 8-bit sources
+//-------------------------------------------------
+
+UINT16 handler_entry_read::read_stub_16_from_8(address_space &space, offs_t offset, UINT16 mask)
 {
-	UINT64 result = 0;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_32le(space, address + 0, mask >> 0) << 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_32le(space, address + 4, mask >> 32) << 32;
+	UINT16 result = 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			result |= m_read8(space, offset * m_subunits + index, mask8) << shift;
+	}
 	return result;
 }
 
-UINT64 memory_read_qword_32be(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  read_stub_32_from_8 - construct a 32-bit read
+//  from 8-bit sources
+//-------------------------------------------------
+
+UINT32 handler_entry_read::read_stub_32_from_8(address_space &space, offs_t offset, UINT32 mask)
 {
-	UINT64 result = (UINT64)memory_read_dword_32be(space, address + 0) << 32;
-	return result | ((UINT64)memory_read_dword_32be(space, address + 4) << 0);
+	UINT32 result = 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			result |= m_read8(space, offset * m_subunits + index, mask8) << shift;
+	}
+	return result;
 }
 
-UINT64 memory_read_qword_masked_32be(const address_space *space, offs_t address, UINT64 mask)
+
+//-------------------------------------------------
+//  read_stub_64_from_8 - construct a 64-bit read
+//  from 8-bit sources
+//-------------------------------------------------
+
+UINT64 handler_entry_read::read_stub_64_from_8(address_space &space, offs_t offset, UINT64 mask)
 {
 	UINT64 result = 0;
-	if (mask & U64(0xffffffff00000000)) result |= (UINT64)memory_read_dword_masked_32be(space, address + 0, mask >> 32) << 32;
-	if (mask & U64(0x00000000ffffffff)) result |= (UINT64)memory_read_dword_masked_32be(space, address + 4, mask >> 0) << 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			result |= (UINT64)m_read8(space, offset * m_subunits + index, mask8) << shift;
+	}
 	return result;
 }
 
 
+//-------------------------------------------------
+//  read_stub_32_from_16 - construct a 32-bit read
+//  from 16-bit sources
+//-------------------------------------------------
 
-/***************************************************************************
-    32-BIT WRITE HANDLERS
-***************************************************************************/
-
-void memory_write_byte_32le(const address_space *space, offs_t address, UINT8 data)
+UINT32 handler_entry_read::read_stub_32_from_16(address_space &space, offs_t offset, UINT32 mask)
 {
-	UINT32 shift = (address & 3) * 8;
-	write_dword_generic(space, address, data << shift, 0xff << shift);
+	UINT32 result = 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT16 mask16 = mask >> shift;
+		if (mask16 != 0)
+			result |= m_read16(space, offset * m_subunits + index, mask16) << shift;
+	}
+	return result;
 }
 
-void memory_write_byte_32be(const address_space *space, offs_t address, UINT8 data)
-{
-	UINT32 shift = (~address & 3) * 8;
-	write_dword_generic(space, address, data << shift, 0xff << shift);
-}
 
-void memory_write_word_32le(const address_space *space, offs_t address, UINT16 data)
-{
-	UINT32 shift = (address & 2) * 8;
-	write_dword_generic(space, address, data << shift, 0xffff << shift);
-}
+//-------------------------------------------------
+//  read_stub_64_from_16 - construct a 64-bit read
+//  from 16-bit sources
+//-------------------------------------------------
 
-void memory_write_word_masked_32le(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
+UINT64 handler_entry_read::read_stub_64_from_16(address_space &space, offs_t offset, UINT64 mask)
 {
-	UINT32 shift = (address & 2) * 8;
-	write_dword_generic(space, address, data << shift, mask << shift);
+	UINT64 result = 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT16 mask16 = mask >> shift;
+		if (mask16 != 0)
+			result |= (UINT64)m_read16(space, offset * m_subunits + index, mask16) << shift;
+	}
+	return result;
 }
 
-void memory_write_word_32be(const address_space *space, offs_t address, UINT16 data)
-{
-	UINT32 shift = (~address & 2) * 8;
-	write_dword_generic(space, address, data << shift, 0xffff << shift);
-}
 
-void memory_write_word_masked_32be(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
-{
-	UINT32 shift = (~address & 2) * 8;
-	write_dword_generic(space, address, data << shift, mask << shift);
-}
+//-------------------------------------------------
+//  read_stub_64_from_32 - construct a 64-bit read
+//  from 32-bit sources
+//-------------------------------------------------
 
-void memory_write_dword_32le(const address_space *space, offs_t address, UINT32 data)
+UINT64 handler_entry_read::read_stub_64_from_32(address_space &space, offs_t offset, UINT64 mask)
 {
-	write_dword_generic(space, address, data, 0xffffffff);
+	UINT64 result = 0;
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT32 mask32 = mask >> shift;
+		if (mask32 != 0)
+			result |= (UINT64)m_read32(space, offset * m_subunits + index, mask32) << shift;
+	}
+	return result;
 }
 
-void memory_write_dword_masked_32le(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
-{
-	write_dword_generic(space, address, data, mask);
-}
 
-void memory_write_dword_32be(const address_space *space, offs_t address, UINT32 data)
-{
-	write_dword_generic(space, address, data, 0xffffffff);
-}
+//-------------------------------------------------
+//  read_stub_legacy - perform a read using legacy
+//  handler callbacks
+//-------------------------------------------------
 
-void memory_write_dword_masked_32be(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
+UINT8 handler_entry_read::read_stub_legacy(address_space &space, offs_t offset, UINT8 mask)
 {
-	write_dword_generic(space, address, data, mask);
+	return m_legacy_handler.space8(m_legacy_object.space, offset);
 }
 
-void memory_write_qword_32le(const address_space *space, offs_t address, UINT64 data)
+UINT16 handler_entry_read::read_stub_legacy(address_space &space, offs_t offset, UINT16 mask)
 {
-	memory_write_dword_32le(space, address + 0, data >> 0);
-	memory_write_dword_32le(space, address + 4, data >> 32);
+	return m_legacy_handler.space16(m_legacy_object.space, offset, mask);
 }
 
-void memory_write_qword_masked_32le(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
+UINT32 handler_entry_read::read_stub_legacy(address_space &space, offs_t offset, UINT32 mask)
 {
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_32le(space, address + 0, data >> 0, mask >> 0);
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_32le(space, address + 4, data >> 32, mask >> 32);
+	return m_legacy_handler.space32(m_legacy_object.space, offset, mask);
 }
 
-void memory_write_qword_32be(const address_space *space, offs_t address, UINT64 data)
+UINT64 handler_entry_read::read_stub_legacy(address_space &space, offs_t offset, UINT64 mask)
 {
-	memory_write_dword_32be(space, address + 0, data >> 32);
-	memory_write_dword_32be(space, address + 4, data >> 0);
+	return m_legacy_handler.space64(m_legacy_object.space, offset, mask);
 }
 
-void memory_write_qword_masked_32be(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
-{
-	if (mask & U64(0xffffffff00000000)) memory_write_dword_masked_32be(space, address + 0, data >> 32, mask >> 32);
-	if (mask & U64(0x00000000ffffffff)) memory_write_dword_masked_32be(space, address + 4, data >> 0, mask >> 0);
-}
 
 
+//**************************************************************************
+//  HANDLER ENTRY WRITE
+//**************************************************************************
 
-/***************************************************************************
-    64-BIT READ HANDLERS
-***************************************************************************/
+//-------------------------------------------------
+//  name - return the handler name, from the
+//  appropriately-sized delegate
+//-------------------------------------------------
 
-UINT8 memory_read_byte_64le(const address_space *space, offs_t address)
+const char *handler_entry_write::name() const
 {
-	UINT32 shift = (address & 7) * 8;
-	return read_qword_generic(space, address, (UINT64)0xff << shift) >> shift;
+	switch (m_datawidth)
+	{
+		case 8:		return m_write8.name();
+		case 16:	return m_write16.name();
+		case 32:	return m_write32.name();
+		case 64:	return m_write64.name();
+	}
+	return NULL;
 }
 
-UINT8 memory_read_byte_64be(const address_space *space, offs_t address)
-{
-	UINT32 shift = (~address & 7) * 8;
-	return read_qword_generic(space, address, (UINT64)0xff << shift) >> shift;
-}
 
-UINT16 memory_read_word_64le(const address_space *space, offs_t address)
+//-------------------------------------------------
+//  set_delegate - set an 8-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
+
+void handler_entry_write::set_delegate(write8_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (address & 6) * 8;
-	return read_qword_generic(space, address, (UINT64)0xffff << shift) >> shift;
+	assert(m_datawidth >= 8);
+	m_write8 = delegate;
+
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 8)
+	{
+		configure_subunits(mask, 8);
+		if (m_datawidth == 16)
+			set_delegate(write16_delegate(write16_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_16_from_8>(delegate.name()), *this));
+		else if (m_datawidth == 32)
+			set_delegate(write32_delegate(write32_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_32_from_8>(delegate.name()), *this));
+		else if (m_datawidth == 64)
+			set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_64_from_8>(delegate.name()), *this));
+	}
 }
 
-UINT16 memory_read_word_masked_64le(const address_space *space, offs_t address, UINT16 mask)
+
+//-------------------------------------------------
+//  set_delegate - set a 16-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
+
+void handler_entry_write::set_delegate(write16_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (address & 6) * 8;
-	return read_qword_generic(space, address, (UINT64)mask << shift) >> shift;
+	assert(m_datawidth >= 16);
+	m_write16 = delegate;
+
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 16)
+	{
+		configure_subunits(mask, 16);
+		if (m_datawidth == 32)
+			set_delegate(write32_delegate(write32_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_32_from_16>(delegate.name()), *this));
+		else if (m_datawidth == 64)
+			set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_64_from_16>(delegate.name()), *this));
+	}
 }
 
-UINT16 memory_read_word_64be(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_delegate - set a 32-bit delegate, and
+//  configure a stub if necessary
+//-------------------------------------------------
+
+void handler_entry_write::set_delegate(write32_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (~address & 6) * 8;
-	return read_qword_generic(space, address, (UINT64)0xffff << shift) >> shift;
+	assert(m_datawidth >= 32);
+	m_write32 = delegate;
+
+	// if mismatched bus width, configure a stub
+	if (m_datawidth != 32)
+	{
+		configure_subunits(mask, 16);
+		if (m_datawidth == 64)
+			set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_64_from_32>(delegate.name()), *this));
+	}
 }
 
-UINT16 memory_read_word_masked_64be(const address_space *space, offs_t address, UINT16 mask)
+
+//-------------------------------------------------
+//  set_delegate - set a 64-bit delegate
+//-------------------------------------------------
+
+void handler_entry_write::set_delegate(write64_delegate delegate, UINT64 mask)
 {
-	UINT32 shift = (~address & 6) * 8;
-	return read_qword_generic(space, address, (UINT64)mask << shift) >> shift;
+	assert(m_datawidth >= 64);
+	m_write64 = delegate;
 }
 
-UINT32 memory_read_dword_64le(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_legacy_func - configure a legacy address
+//  space stub of the appropriate size
+//-------------------------------------------------
+
+void handler_entry_write::set_legacy_func(address_space &space, write8_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (address & 4) * 8;
-	return read_qword_generic(space, address, (UINT64)0xffffffff << shift) >> shift;
+	m_legacy_handler.space8 = func;
+	m_legacy_object.space = &space;
+	set_delegate(write8_delegate(write8_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_masked_64le(const address_space *space, offs_t address, UINT32 mask)
+void handler_entry_write::set_legacy_func(address_space &space, write16_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (address & 4) * 8;
-	return read_qword_generic(space, address, (UINT64)mask << shift) >> shift;
+	m_legacy_handler.space16 = func;
+	m_legacy_object.space = &space;
+	set_delegate(write16_delegate(write16_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_64be(const address_space *space, offs_t address)
+void handler_entry_write::set_legacy_func(address_space &space, write32_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (~address & 4) * 8;
-	return read_qword_generic(space, address, (UINT64)0xffffffff << shift) >> shift;
+	m_legacy_handler.space32 = func;
+	m_legacy_object.space = &space;
+	set_delegate(write32_delegate(write32_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT32 memory_read_dword_masked_64be(const address_space *space, offs_t address, UINT32 mask)
+void handler_entry_write::set_legacy_func(address_space &space, write64_space_func func, const char *name, UINT64 mask)
 {
-	UINT32 shift = (~address & 4) * 8;
-	return read_qword_generic(space, address, (UINT64)mask << shift) >> shift;
+	m_legacy_handler.space64 = func;
+	m_legacy_object.space = &space;
+	set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT64 memory_read_qword_64le(const address_space *space, offs_t address)
+
+//-------------------------------------------------
+//  set_legacy_func - configure a legacy device
+//  stub of the appropriate size
+//-------------------------------------------------
+
+void handler_entry_write::set_legacy_func(device_t &device, write8_device_func func, const char *name, UINT64 mask)
 {
-	return read_qword_generic(space, address, U64(0xffffffffffffffff));
+	m_legacy_handler.device8 = func;
+	m_legacy_object.device = &device;
+	set_delegate(write8_delegate(write8_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT64 memory_read_qword_masked_64le(const address_space *space, offs_t address, UINT64 mask)
+void handler_entry_write::set_legacy_func(device_t &device, write16_device_func func, const char *name, UINT64 mask)
 {
-	return read_qword_generic(space, address, mask);
+	m_legacy_handler.device16 = func;
+	m_legacy_object.device = &device;
+	set_delegate(write16_delegate(write16_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT64 memory_read_qword_64be(const address_space *space, offs_t address)
+void handler_entry_write::set_legacy_func(device_t &device, write32_device_func func, const char *name, UINT64 mask)
 {
-	return read_qword_generic(space, address, U64(0xffffffffffffffff));
+	m_legacy_handler.device32 = func;
+	m_legacy_object.device = &device;
+	set_delegate(write32_delegate(write32_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
-UINT64 memory_read_qword_masked_64be(const address_space *space, offs_t address, UINT64 mask)
+void handler_entry_write::set_legacy_func(device_t &device, write64_device_func func, const char *name, UINT64 mask)
 {
-	return read_qword_generic(space, address, mask);
+	m_legacy_handler.device64 = func;
+	m_legacy_object.device = &device;
+	set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_legacy>(name), *this), mask);
 }
 
 
+//-------------------------------------------------
+//  set_ioport - configure an I/O port read stub
+//  of the appropriate size
+//-------------------------------------------------
 
-/***************************************************************************
-    64-BIT WRITE HANDLERS
-***************************************************************************/
-
-void memory_write_byte_64le(const address_space *space, offs_t address, UINT8 data)
+void handler_entry_write::set_ioport(const input_port_config &ioport)
 {
-	UINT32 shift = (address & 7) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xff << shift);
+	m_ioport = &ioport;
+	if (m_datawidth == 8)
+		set_delegate(write8_delegate(write8_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_ioport<UINT8> >(ioport.tag), *this));
+	else if (m_datawidth == 16)
+		set_delegate(write16_delegate(write16_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_ioport<UINT16> >(ioport.tag), *this));
+	else if (m_datawidth == 32)
+		set_delegate(write32_delegate(write32_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_ioport<UINT32> >(ioport.tag), *this));
+	else if (m_datawidth == 64)
+		set_delegate(write64_delegate(write64_proto_delegate::_create_member<handler_entry_write, &handler_entry_write::write_stub_ioport<UINT64> >(ioport.tag), *this));
 }
 
-void memory_write_byte_64be(const address_space *space, offs_t address, UINT8 data)
-{
-	UINT32 shift = (~address & 7) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xff << shift);
-}
 
-void memory_write_word_64le(const address_space *space, offs_t address, UINT16 data)
-{
-	UINT32 shift = (address & 6) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xffff << shift);
-}
+//-------------------------------------------------
+//  write_stub_16_from_8 - construct a 16-bit write
+//  from 8-bit sources
+//-------------------------------------------------
 
-void memory_write_word_masked_64le(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
+void handler_entry_write::write_stub_16_from_8(address_space &space, offs_t offset, UINT16 data, UINT16 mask)
 {
-	UINT32 shift = (address & 6) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)mask << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			m_write8(space, offset * m_subunits + index, data >> shift, mask8);
+	}
 }
 
-void memory_write_word_64be(const address_space *space, offs_t address, UINT16 data)
-{
-	UINT32 shift = (~address & 6) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xffff << shift);
-}
 
-void memory_write_word_masked_64be(const address_space *space, offs_t address, UINT16 data, UINT16 mask)
+//-------------------------------------------------
+//  write_stub_32_from_8 - construct a 32-bit write
+//  from 8-bit sources
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_32_from_8(address_space &space, offs_t offset, UINT32 data, UINT32 mask)
 {
-	UINT32 shift = (~address & 6) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)mask << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			m_write8(space, offset * m_subunits + index, data >> shift, mask8);
+	}
 }
 
-void memory_write_dword_64le(const address_space *space, offs_t address, UINT32 data)
+
+//-------------------------------------------------
+//  write_stub_64_from_8 - construct a 64-bit write
+//  from 8-bit sources
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_64_from_8(address_space &space, offs_t offset, UINT64 data, UINT64 mask)
 {
-	UINT32 shift = (address & 4) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xffffffff << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT8 mask8 = mask >> shift;
+		if (mask8 != 0)
+			m_write8(space, offset * m_subunits + index, data >> shift, mask8);
+	}
 }
 
-void memory_write_dword_masked_64le(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
+
+//-------------------------------------------------
+//  write_stub_32_from_16 - construct a 32-bit
+//  write from 16-bit sources
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_32_from_16(address_space &space, offs_t offset, UINT32 data, UINT32 mask)
 {
-	UINT32 shift = (address & 4) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)mask << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT16 mask16 = mask >> shift;
+		if (mask16 != 0)
+			m_write16(space, offset * m_subunits + index, data >> shift, mask16);
+	}
 }
 
-void memory_write_dword_64be(const address_space *space, offs_t address, UINT32 data)
+
+//-------------------------------------------------
+//  write_stub_64_from_16 - construct a 64-bit
+//  write from 16-bit sources
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_64_from_16(address_space &space, offs_t offset, UINT64 data, UINT64 mask)
 {
-	UINT32 shift = (~address & 4) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)0xffffffff << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT16 mask16 = mask >> shift;
+		if (mask16 != 0)
+			m_write16(space, offset * m_subunits + index, data >> shift, mask16);
+	}
 }
 
-void memory_write_dword_masked_64be(const address_space *space, offs_t address, UINT32 data, UINT32 mask)
+
+//-------------------------------------------------
+//  write_stub_64_from_32 - construct a 64-bit
+//  write from 32-bit sources
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_64_from_32(address_space &space, offs_t offset, UINT64 data, UINT64 mask)
 {
-	UINT32 shift = (~address & 4) * 8;
-	write_qword_generic(space, address, (UINT64)data << shift, (UINT64)mask << shift);
+	for (int index = 0; index < m_subunits; index++)
+	{
+		int shift = m_subshift[index];
+		UINT32 mask32 = mask >> shift;
+		if (mask32 != 0)
+			m_write32(space, offset * m_subunits + index, data >> shift, mask32);
+	}
 }
 
-void memory_write_qword_64le(const address_space *space, offs_t address, UINT64 data)
+
+//-------------------------------------------------
+//  write_stub_legacy - perform a write using
+//  legacy handler callbacks
+//-------------------------------------------------
+
+void handler_entry_write::write_stub_legacy(address_space &space, offs_t offset, UINT8 data, UINT8 mask)
 {
-	write_qword_generic(space, address, data, U64(0xffffffffffffffff));
+	m_legacy_handler.space8(m_legacy_object.space, offset, data);
 }
 
-void memory_write_qword_masked_64le(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
+void handler_entry_write::write_stub_legacy(address_space &space, offs_t offset, UINT16 data, UINT16 mask)
 {
-	write_qword_generic(space, address, data, mask);
+	m_legacy_handler.space16(m_legacy_object.space, offset, data, mask);
 }
 
-void memory_write_qword_64be(const address_space *space, offs_t address, UINT64 data)
+void handler_entry_write::write_stub_legacy(address_space &space, offs_t offset, UINT32 data, UINT32 mask)
 {
-	write_qword_generic(space, address, data, U64(0xffffffffffffffff));
+	m_legacy_handler.space32(m_legacy_object.space, offset, data, mask);
 }
 
-void memory_write_qword_masked_64be(const address_space *space, offs_t address, UINT64 data, UINT64 mask)
+void handler_entry_write::write_stub_legacy(address_space &space, offs_t offset, UINT64 data, UINT64 mask)
 {
-	write_qword_generic(space, address, data, mask);
+	m_legacy_handler.space64(m_legacy_object.space, offset, data, mask);
 }
diff -Nru src-old/emu/memory.h src/emu/memory.h
--- src-old/emu/memory.h	2010-08-01 14:04:03.000000000 -0700
+++ src/emu/memory.h	2010-08-30 08:20:58.000000000 -0700
@@ -4,8 +4,36 @@
 
     Functions which handle device memory accesses.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ***************************************************************************/
 
@@ -20,79 +48,69 @@
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-/* address spaces */
+// address spaces
 enum
 {
-	ADDRESS_SPACE_0,				/* first address space */
-	ADDRESS_SPACE_1,				/* second address space */
-	ADDRESS_SPACE_2,				/* third address space */
-	ADDRESS_SPACE_3,				/* fourth address space */
-	ADDRESS_SPACES					/* maximum number of address spaces */
+	ADDRESS_SPACE_0,				// first address space
+	ADDRESS_SPACE_1,				// second address space
+	ADDRESS_SPACE_2,				// third address space
+	ADDRESS_SPACE_3,				// fourth address space
+	ADDRESS_SPACES					// maximum number of address spaces
 };
 
+// read or write constants
+enum read_or_write
+{
+	ROW_READ = 1,
+	ROW_WRITE = 2,
+	ROW_READWRITE = 3
+};
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
 
-/* referenced types from other classes */
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
+
+// referenced types from other classes
+class device_memory_interface;
 class device_config;
 class device_t;
-class address_map;
 struct game_driver;
 
-
-/* handler_data and subtable_data are opaque types used to hold information about a particular handler */
-typedef struct _handler_data handler_data;
-typedef struct _subtable_data subtable_data;
-
-/* direct_range is an opaque type used to track ranges for direct access */
-typedef struct _direct_range direct_range;
-
-/* forward-declare the address_space structure */
-typedef struct _address_space address_space;
+// forward declarations of classes defined here
+class address_map;
+class address_map_entry;
+class memory_bank;
+class direct_read_data;
+class address_space;
+class address_table;
+class address_table_read;
+class address_table_write;
 
 
-/* offsets and addresses are 32-bit (for now...) */
+// offsets and addresses are 32-bit (for now...)
 typedef UINT32	offs_t;
 
+// address map constructors are functions that build up an address_map
+typedef void (*address_map_constructor)(address_map &map, const device_config &devconfig);
 
-/* direct_read_data contains state data for direct read access */
-typedef struct _direct_read_data direct_read_data;
-struct _direct_read_data
-{
-	UINT8 *					raw;				/* direct access data pointer (raw) */
-	UINT8 *					decrypted;			/* direct access data pointer (decrypted) */
-	offs_t					bytemask;			/* byte address mask */
-	offs_t					bytestart;			/* minimum valid byte address */
-	offs_t					byteend;			/* maximum valid byte address */
-	UINT8					entry;				/* live entry */
-	direct_range *			rangelist[256];		/* list of ranges for each entry */
-	direct_range *			freerangelist;		/* list of recycled range entries */
-};
-
-
-/* direct region update handler */
-typedef offs_t	(*direct_update_func) (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t address, ATTR_UNUSED direct_read_data *direct);
-
-
-/* space read/write handlers */
-typedef UINT8	(*read8_space_func)  (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset);
-typedef void	(*write8_space_func) (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data);
-typedef UINT16	(*read16_space_func) (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask);
-typedef void	(*write16_space_func)(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask);
-typedef UINT32	(*read32_space_func) (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask);
-typedef void	(*write32_space_func)(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask);
-typedef UINT64	(*read64_space_func) (ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask);
-typedef void	(*write64_space_func)(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask);
 
+// legacy space read/write handlers
+typedef UINT8	(*read8_space_func)  (ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset);
+typedef void	(*write8_space_func) (ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data);
+typedef UINT16	(*read16_space_func) (ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask);
+typedef void	(*write16_space_func)(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask);
+typedef UINT32	(*read32_space_func) (ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask);
+typedef void	(*write32_space_func)(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask);
+typedef UINT64	(*read64_space_func) (ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask);
+typedef void	(*write64_space_func)(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask);
 
-/* device read/write handlers */
+// legacy device read/write handlers
 typedef UINT8	(*read8_device_func)  (ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset);
 typedef void	(*write8_device_func) (ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data);
 typedef UINT16	(*read16_device_func) (ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask);
@@ -103,95 +121,425 @@
 typedef void	(*write64_device_func)(ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask);
 
 
-/* data_accessors is a struct with accessors of all flavors */
-typedef struct _data_accessors data_accessors;
-struct _data_accessors
-{
-	UINT8		(*read_byte)(const address_space *space, offs_t byteaddress);
-	UINT16		(*read_word)(const address_space *space, offs_t byteaddress);
-	UINT16		(*read_word_masked)(const address_space *space, offs_t byteaddress, UINT16 mask);
-	UINT32		(*read_dword)(const address_space *space, offs_t byteaddress);
-	UINT32		(*read_dword_masked)(const address_space *space, offs_t byteaddress, UINT32 mask);
-	UINT64		(*read_qword)(const address_space *space, offs_t byteaddress);
-	UINT64		(*read_qword_masked)(const address_space *space, offs_t byteaddress, UINT64 mask);
-
-	void		(*write_byte)(const address_space *space, offs_t byteaddress, UINT8 data);
-	void		(*write_word)(const address_space *space, offs_t byteaddress, UINT16 data);
-	void		(*write_word_masked)(const address_space *space, offs_t byteaddress, UINT16 data, UINT16 mask);
-	void		(*write_dword)(const address_space *space, offs_t byteaddress, UINT32 data);
-	void		(*write_dword_masked)(const address_space *space, offs_t byteaddress, UINT32 data, UINT32 mask);
-	void		(*write_qword)(const address_space *space, offs_t byteaddress, UINT64 data);
-	void		(*write_qword_masked)(const address_space *space, offs_t byteaddress, UINT64 data, UINT64 mask);
+// struct with function pointers for accessors; use is generally discouraged unless necessary
+struct data_accessors
+{
+	UINT8		(*read_byte)(address_space *space, offs_t byteaddress);
+	UINT16		(*read_word)(address_space *space, offs_t byteaddress);
+	UINT16		(*read_word_masked)(address_space *space, offs_t byteaddress, UINT16 mask);
+	UINT32		(*read_dword)(address_space *space, offs_t byteaddress);
+	UINT32		(*read_dword_masked)(address_space *space, offs_t byteaddress, UINT32 mask);
+	UINT64		(*read_qword)(address_space *space, offs_t byteaddress);
+	UINT64		(*read_qword_masked)(address_space *space, offs_t byteaddress, UINT64 mask);
+
+	void		(*write_byte)(address_space *space, offs_t byteaddress, UINT8 data);
+	void		(*write_word)(address_space *space, offs_t byteaddress, UINT16 data);
+	void		(*write_word_masked)(address_space *space, offs_t byteaddress, UINT16 data, UINT16 mask);
+	void		(*write_dword)(address_space *space, offs_t byteaddress, UINT32 data);
+	void		(*write_dword_masked)(address_space *space, offs_t byteaddress, UINT32 data, UINT32 mask);
+	void		(*write_qword)(address_space *space, offs_t byteaddress, UINT64 data);
+	void		(*write_qword_masked)(address_space *space, offs_t byteaddress, UINT64 data, UINT64 mask);
 };
 
 
-/* address_table contains information about read/write accesses within an address space */
-typedef struct _address_table address_table;
-struct _address_table
-{
-	UINT8 *					table;				/* pointer to base of table */
-	UINT8					subtable_alloc;		/* number of subtables allocated */
-	subtable_data *			subtable;			/* info about each subtable */
-	handler_data *			handlers[256];		/* array of user-installed handlers */
-	running_machine *		machine;			/* pointer back to the machine */
+// ======================> direct_update_delegate
+
+// direct region update handler
+typedef proto_delegate_2param<offs_t, direct_read_data &, offs_t> direct_update_proto_delegate;
+typedef delegate_2param<offs_t, direct_read_data &, offs_t> direct_update_delegate;
+
+#define direct_update_delegate_create(_Class, _Method, _Object) direct_update_delegate(direct_update_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method), _Object)
+#define direct_update_delegate_create_static(_Function, _Object) direct_update_delegate(direct_update_proto_delegate::_create_static<running_machine, &_Function>(#_Function), _Object)
+
+
+// ======================> read_delegate
+
+// declare proto-delegates for each width
+typedef proto_delegate_3param<UINT8, address_space &, offs_t, UINT8> read8_proto_delegate;
+typedef proto_delegate_3param<UINT16, address_space &, offs_t, UINT16> read16_proto_delegate;
+typedef proto_delegate_3param<UINT32, address_space &, offs_t, UINT32> read32_proto_delegate;
+typedef proto_delegate_3param<UINT64, address_space &, offs_t, UINT64> read64_proto_delegate;
+
+// declare delegates for each width
+typedef delegate_3param<UINT8, address_space &, offs_t, UINT8> read8_delegate;
+typedef delegate_3param<UINT16, address_space &, offs_t, UINT16> read16_delegate;
+typedef delegate_3param<UINT32, address_space &, offs_t, UINT32> read32_delegate;
+typedef delegate_3param<UINT64, address_space &, offs_t, UINT64> read64_delegate;
+
+// macros for creating read proto-delegates
+#define read8_proto_delegate_create(_Class, _Method) read8_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define read16_proto_delegate_create(_Class, _Method) read16_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define read32_proto_delegate_create(_Class, _Method) read32_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define read64_proto_delegate_create(_Class, _Method) read64_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+
+// macros for creating read delegates, bound to the provided object
+#define read8_delegate_create(_Class, _Method, _Object) read8_delegate(read8_proto_delegate_create(_Class, _Method), _Object)
+#define read16_delegate_create(_Class, _Method, _Object) read16_delegate(read16_proto_delegate_create(_Class, _Method), _Object)
+#define read32_delegate_create(_Class, _Method, _Object) read32_delegate(read32_proto_delegate_create(_Class, _Method), _Object)
+#define read64_delegate_create(_Class, _Method, _Object) read64_delegate(read64_proto_delegate_create(_Class, _Method), _Object)
+
+
+// ======================> write_delegate
+
+// declare proto-delegates for each width
+typedef proto_delegate_4param<void, address_space &, offs_t, UINT8, UINT8> write8_proto_delegate;
+typedef proto_delegate_4param<void, address_space &, offs_t, UINT16, UINT16> write16_proto_delegate;
+typedef proto_delegate_4param<void, address_space &, offs_t, UINT32, UINT32> write32_proto_delegate;
+typedef proto_delegate_4param<void, address_space &, offs_t, UINT64, UINT64> write64_proto_delegate;
+
+// declare delegates for each width
+typedef delegate_4param<void, address_space &, offs_t, UINT8, UINT8> write8_delegate;
+typedef delegate_4param<void, address_space &, offs_t, UINT16, UINT16> write16_delegate;
+typedef delegate_4param<void, address_space &, offs_t, UINT32, UINT32> write32_delegate;
+typedef delegate_4param<void, address_space &, offs_t, UINT64, UINT64> write64_delegate;
+
+// macros for creating write proto-delegates
+#define write8_proto_delegate_create(_Class, _Method) write8_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define write16_proto_delegate_create(_Class, _Method) write16_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define write32_proto_delegate_create(_Class, _Method) write32_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+#define write64_proto_delegate_create(_Class, _Method) write64_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method)
+
+// macros for creating write delegates, bound to the provided object
+#define write8_delegate_create(_Class, _Method, _Object) write8_delegate(write8_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method), _Object)
+#define write16_delegate_create(_Class, _Method, _Object) write16_delegate(write16_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method), _Object)
+#define write32_delegate_create(_Class, _Method, _Object) write32_delegate(write32_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method), _Object)
+#define write64_delegate_create(_Class, _Method, _Object) write64_delegate(write64_proto_delegate::_create_member<_Class, &_Class::_Method>(#_Class "::" #_Method), _Object)
+
+
+// ======================> direct_read_data
+
+// direct_read_data contains state data for direct read access
+class direct_read_data
+{
+	friend class address_table;
+
+public:
+	// direct_range is an internal class that is part of a list of start/end ranges
+	class direct_range
+	{
+	public:
+		// construction
+		direct_range()
+			: m_next(NULL),
+			  m_bytestart(0),
+			  m_byteend(~0) { }
+
+		// getters
+		direct_range *next() const { return m_next; }
+
+		// internal state
+		direct_range *			m_next;					// pointer to the next range in the list
+		offs_t					m_bytestart;			// starting byte offset of the range
+		offs_t					m_byteend;				// ending byte offset of the range
+	};
+
+	// construction/destruction
+	direct_read_data(address_space &space);
+	~direct_read_data();
+
+	// getters
+	address_space &space() const { return m_space; }
+	UINT8 *raw() const { return m_raw; }
+	UINT8 *decrypted() const { return m_decrypted; }
+
+	// see if an address is within bounds, or attempt to update it if not
+	bool address_is_valid(offs_t byteaddress) { return EXPECTED(byteaddress >= m_bytestart && byteaddress <= m_byteend) || set_direct_region(byteaddress); }
+
+	// force a recomputation on the next read
+	void force_update() { m_byteend = 0; m_bytestart = 1; }
+	void force_update(UINT8 if_match) { if (m_entry == if_match) force_update(); }
+
+	// custom update callbacks and configuration
+	direct_update_delegate set_direct_update(direct_update_delegate function);
+	void explicit_configure(offs_t bytestart, offs_t byteend, offs_t bytemask, void *raw, void *decrypted = NULL);
+
+	// accessor methods for reading raw data
+	void *read_raw_ptr(offs_t byteaddress);
+	UINT8 read_raw_byte(offs_t byteaddress);
+	UINT16 read_raw_word(offs_t byteaddress);
+	UINT32 read_raw_dword(offs_t byteaddress);
+	UINT64 read_raw_qword(offs_t byteaddress);
+
+	// accessor methods for reading decrypted data
+	void *read_decrypted_ptr(offs_t byteaddress);
+	UINT8 read_decrypted_byte(offs_t byteaddress);
+	UINT16 read_decrypted_word(offs_t byteaddress);
+	UINT32 read_decrypted_dword(offs_t byteaddress);
+	UINT64 read_decrypted_qword(offs_t byteaddress);
+
+private:
+	// internal helpers
+	bool set_direct_region(offs_t &byteaddress);
+	direct_range *find_range(offs_t byteaddress, UINT8 &entry);
+	void remove_intersecting_ranges(offs_t bytestart, offs_t byteend);
+
+	// internal state
+	address_space &				m_space;
+	UINT8 *						m_raw;					// direct access data pointer (raw)
+	UINT8 *						m_decrypted;			// direct access data pointer (decrypted)
+	offs_t						m_bytemask;				// byte address mask
+	offs_t						m_bytestart;			// minimum valid byte address
+	offs_t						m_byteend;				// maximum valid byte address
+	UINT8						m_entry;				// live entry
+	simple_list<direct_range>	m_rangelist[256];		// list of ranges for each entry
+	simple_list<direct_range>	m_freerangelist;		// list of recycled range entries
+	direct_update_delegate		m_directupdate;			// fast direct-access update callback
 };
 
 
-/* address_space holds live information about an address space */
-/* Declared above: typedef struct _address_space address_space; */
-struct _address_space
-{
-	address_space *			next;				/* next address space in the global list */
-	running_machine *		machine;			/* reference to the owning machine */
-	device_t *				cpu;				/* reference to the owning device */
-	const device_config *	devconfig;			/* pointer to the owning device's config */
-	address_map *			map;				/* original memory map */
-	const char *			name;				/* friendly name of the address space */
-	UINT8 *					readlookup;			/* live lookup table for reads */
-	UINT8 *					writelookup;		/* live lookup table for writes */
-	data_accessors			accessors;			/* data access handlers */
-	direct_read_data		direct;				/* fast direct-access read info */
-	direct_update_func		directupdate;		/* fast direct-access update callback */
-	UINT64					unmap;				/* unmapped value */
-	offs_t					addrmask;			/* physical address mask */
-	offs_t					bytemask;			/* byte-converted physical address mask */
-	offs_t					logaddrmask;		/* logical address mask */
-	offs_t					logbytemask;		/* byte-converted logical address mask */
-	UINT8					spacenum;			/* address space index */
-	endianness_t			endianness;			/* endianness of this space */
-	INT8					ashift;				/* address shift */
-	UINT8					abits;				/* address bits */
-	UINT8					dbits;				/* data bits */
-	UINT8					addrchars;			/* number of characters to use for physical addresses */
-	UINT8					logaddrchars;		/* number of characters to use for logical addresses */
-	UINT8					debugger_access;	/* treat accesses as coming from the debugger */
-	UINT8					log_unmap;			/* log unmapped accesses in this space? */
-	address_table			read;				/* memory read lookup table */
-	address_table			write;				/* memory write lookup table */
+// ======================> address_space_config
+
+// describes an address space and provides basic functions to map addresses to bytes
+class address_space_config
+{
+public:
+	// construction/destruction
+	address_space_config();
+	address_space_config(const char *name, endianness_t endian, UINT8 datawidth, UINT8 addrwidth, INT8 addrshift = 0, address_map_constructor internal = NULL, address_map_constructor defmap = NULL);
+	address_space_config(const char *name, endianness_t endian, UINT8 datawidth, UINT8 addrwidth, INT8 addrshift, UINT8 logwidth, UINT8 pageshift, address_map_constructor internal = NULL, address_map_constructor defmap = NULL);
+
+	// getters
+	const char *name() const { return m_name; }
+	endianness_t endianness() const { return m_endianness; }
+	int data_width() const { return m_databus_width; }
+	int addr_width() const { return m_addrbus_width; }
+
+	// address-to-byte conversion helpers
+	inline offs_t addr2byte(offs_t address) const { return (m_addrbus_shift < 0) ? (address << -m_addrbus_shift) : (address >> m_addrbus_shift); }
+	inline offs_t addr2byte_end(offs_t address) const { return (m_addrbus_shift < 0) ? ((address << -m_addrbus_shift) | ((1 << -m_addrbus_shift) - 1)) : (address >> m_addrbus_shift); }
+	inline offs_t byte2addr(offs_t address) const { return (m_addrbus_shift > 0) ? (address << m_addrbus_shift) : (address >> -m_addrbus_shift); }
+	inline offs_t byte2addr_end(offs_t address) const { return (m_addrbus_shift > 0) ? ((address << m_addrbus_shift) | ((1 << m_addrbus_shift) - 1)) : (address >> -m_addrbus_shift); }
+
+	// state
+	const char *		m_name;
+	endianness_t		m_endianness;
+	UINT8				m_databus_width;
+	UINT8				m_addrbus_width;
+	INT8				m_addrbus_shift;
+	UINT8				m_logaddr_width;
+	UINT8				m_page_shift;
+	address_map_constructor m_internal_map;
+	address_map_constructor m_default_map;
 };
 
 
+// ======================> address_space
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+// address_space holds live information about an address space
+class address_space : public bindable_object
+{
+	friend class address_table;
+	friend class address_table_read;
+	friend class address_table_write;
+	friend class direct_read_data;
+	friend class simple_list<address_space>;
+	friend resource_pool_object<address_space>::~resource_pool_object();
+
+protected:
+	// construction/destruction
+	address_space(device_memory_interface &memory, int spacenum, bool large);
+	~address_space();
+
+public:
+	// public allocator
+	static address_space &allocate(running_machine &machine, const address_space_config &config, device_memory_interface &memory, int spacenum);
+
+	// getters
+	address_space *next() const { return m_next; }
+	device_t &device() const { return m_device; }
+	const char *name() const { return m_name; }
+	int spacenum() const { return m_spacenum; }
+	address_map *map() const { return m_map; }
+
+	direct_read_data &direct() const { return const_cast<direct_read_data &>(m_direct); }
+
+	int data_width() const { return m_config.data_width(); }
+	int addr_width() const { return m_config.addr_width(); }
+	endianness_t endianness() const { return m_config.endianness(); }
+	UINT64 unmap() const { return m_unmap; }
+
+	offs_t addrmask() const { return m_addrmask; }
+	offs_t bytemask() const { return m_bytemask; }
+	UINT8 addrchars() const { return m_addrchars; }
+	offs_t logaddrmask() const { return m_logaddrmask; }
+	offs_t logbytemask() const { return m_logbytemask; }
+	UINT8 logaddrchars() const { return m_logaddrchars; }
+
+	// debug helpers
+	const char *get_handler_string(read_or_write readorwrite, offs_t byteaddress);
+	bool debugger_access() const { return m_debugger_access; }
+	void set_debugger_access(bool debugger) { m_debugger_access = debugger; }
+	bool log_unmap() const { return m_log_unmap; }
+	void set_log_unmap(bool log) { m_log_unmap = log; }
+	void dump_map(FILE *file, read_or_write readorwrite);
+
+	// watchpoint enablers
+	virtual void enable_read_watchpoints(bool enable = true) = 0;
+	virtual void enable_write_watchpoints(bool enable = true) = 0;
+
+	// general accessors
+	virtual void accessors(data_accessors &accessors) const = 0;
+	virtual void *get_read_ptr(offs_t byteaddress) = 0;
+	virtual void *get_write_ptr(offs_t byteaddress) = 0;
+
+	// read accessors
+	virtual UINT8 read_byte(offs_t byteaddress) = 0;
+	virtual UINT16 read_word(offs_t byteaddress) = 0;
+	virtual UINT16 read_word(offs_t byteaddress, UINT16 mask) = 0;
+	virtual UINT16 read_word_unaligned(offs_t byteaddress) = 0;
+	virtual UINT16 read_word_unaligned(offs_t byteaddress, UINT16 mask) = 0;
+	virtual UINT32 read_dword(offs_t byteaddress) = 0;
+	virtual UINT32 read_dword(offs_t byteaddress, UINT32 mask) = 0;
+	virtual UINT32 read_dword_unaligned(offs_t byteaddress) = 0;
+	virtual UINT32 read_dword_unaligned(offs_t byteaddress, UINT32 mask) = 0;
+	virtual UINT64 read_qword(offs_t byteaddress) = 0;
+	virtual UINT64 read_qword(offs_t byteaddress, UINT64 mask) = 0;
+	virtual UINT64 read_qword_unaligned(offs_t byteaddress) = 0;
+	virtual UINT64 read_qword_unaligned(offs_t byteaddress, UINT64 mask) = 0;
+
+	// write accessors
+	virtual void write_byte(offs_t byteaddress, UINT8 data) = 0;
+	virtual void write_word(offs_t byteaddress, UINT16 data) = 0;
+	virtual void write_word(offs_t byteaddress, UINT16 data, UINT16 mask) = 0;
+	virtual void write_word_unaligned(offs_t byteaddress, UINT16 data) = 0;
+	virtual void write_word_unaligned(offs_t byteaddress, UINT16 data, UINT16 mask) = 0;
+	virtual void write_dword(offs_t byteaddress, UINT32 data) = 0;
+	virtual void write_dword(offs_t byteaddress, UINT32 data, UINT32 mask) = 0;
+	virtual void write_dword_unaligned(offs_t byteaddress, UINT32 data) = 0;
+	virtual void write_dword_unaligned(offs_t byteaddress, UINT32 data, UINT32 mask) = 0;
+	virtual void write_qword(offs_t byteaddress, UINT64 data) = 0;
+	virtual void write_qword(offs_t byteaddress, UINT64 data, UINT64 mask) = 0;
+	virtual void write_qword_unaligned(offs_t byteaddress, UINT64 data) = 0;
+	virtual void write_qword_unaligned(offs_t byteaddress, UINT64 data, UINT64 mask) = 0;
+
+	// address-to-byte conversion helpers
+	offs_t address_to_byte(offs_t address) const { return m_config.addr2byte(address); }
+	offs_t address_to_byte_end(offs_t address) const { return m_config.addr2byte_end(address); }
+	offs_t byte_to_address(offs_t address) const { return m_config.byte2addr(address); }
+	offs_t byte_to_address_end(offs_t address) const { return m_config.byte2addr_end(address); }
+
+	// decryption
+	void set_decrypted_region(offs_t addrstart, offs_t addrend, void *base);
+
+	// direct access
+	direct_update_delegate set_direct_update_handler(direct_update_delegate function) { return m_direct.set_direct_update(function); }
+	bool set_direct_region(offs_t &byteaddress);
+
+	// static handler installation
+	void unmap(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite, bool quiet);
+	void install_port(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag);
+	void install_bank(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag);
+	void *install_ram(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite, void *baseptr = NULL);
+
+	// install new-style delegate handlers
+	UINT8 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_delegate rhandler, UINT64 unitmask = 0);
+	UINT8 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_delegate whandler, UINT64 unitmask = 0);
+	UINT8 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_delegate rhandler, write8_delegate whandler, UINT64 unitmask = 0);
+	UINT16 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_delegate rhandler, UINT64 unitmask = 0);
+	UINT16 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_delegate whandler, UINT64 unitmask = 0);
+	UINT16 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_delegate rhandler, write16_delegate whandler, UINT64 unitmask = 0);
+	UINT32 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_delegate rhandler, UINT64 unitmask = 0);
+	UINT32 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_delegate whandler, UINT64 unitmask = 0);
+	UINT32 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_delegate rhandler, write32_delegate whandler, UINT64 unitmask = 0);
+	UINT64 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_delegate rhandler, UINT64 unitmask = 0);
+	UINT64 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_delegate whandler, UINT64 unitmask = 0);
+	UINT64 *install_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_delegate rhandler, write64_delegate whandler, UINT64 unitmask = 0);
+
+	// install legacy address space handlers
+	UINT8 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT8 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT8 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rname, write8_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rname, write16_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rname, write32_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_space_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rname, write64_space_func whandler, const char *wname, UINT64 unitmask = 0);
+
+	// install legacy device handlers
+	UINT8 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT8 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write8_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT8 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rname, write8_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write16_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT16 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rname, write16_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write32_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT32 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rname, write32_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, write64_device_func whandler, const char *wname, UINT64 unitmask = 0);
+	UINT64 *install_legacy_handler(device_t &device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rname, write64_device_func whandler, const char *wname, UINT64 unitmask = 0);
+
+	// setup
+	void prepare_map();
+	void populate_from_map();
+	void allocate_memory();
+	void locate_memory();
+
+private:
+	// internal helpers
+	virtual address_table_read &read() = 0;
+	virtual address_table_write &write() = 0;
+	void populate_map_entry(const address_map_entry &entry, read_or_write readorwrite);
+	void bind_and_install_handler(const address_map_entry &entry, read_or_write readorwrite, device_t *device);
+	void adjust_addresses(offs_t &start, offs_t &end, offs_t &mask, offs_t &mirror);
+	void *find_backing_memory(offs_t addrstart, offs_t addrend);
+	bool needs_backing_store(const address_map_entry *entry);
+	memory_bank &bank_find_or_allocate(const char *tag, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read_or_write readorwrite);
+	address_map_entry *block_assign_intersecting(offs_t bytestart, offs_t byteend, UINT8 *base);
+
+public:
+	// public state (eventually will go away)
+	running_machine *		machine;			// kept for backwards compatibility
+	device_t *				cpu;				// kept for backwards compatibility
+	running_machine &		m_machine;			// reference to the owning machine
+
+protected:
+	// private state
+	address_space *			m_next;				// next address space in the global list
+	const address_space_config &m_config;		// configuration of this space
+	device_t &				m_device;			// reference to the owning device
+	address_map *			m_map;				// original memory map
+	offs_t					m_addrmask;			// physical address mask
+	offs_t					m_bytemask;			// byte-converted physical address mask
+	offs_t					m_logaddrmask;		// logical address mask
+	offs_t					m_logbytemask;		// byte-converted logical address mask
+	UINT64					m_unmap;			// unmapped value
+	UINT8					m_spacenum;			// address space index
+	bool					m_debugger_access;	// treat accesses as coming from the debugger
+	bool					m_log_unmap;		// log unmapped accesses in this space?
+	direct_read_data &		m_direct;			// fast direct-access read info
+	const char *			m_name;				// friendly name of the address space
+	UINT8					m_addrchars;		// number of characters to use for physical addresses
+	UINT8					m_logaddrchars;		// number of characters to use for logical addresses
+};
 
-/* opcode base adjustment handler function macro */
-#define DIRECT_UPDATE_HANDLER(name)		offs_t name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t address, direct_read_data *direct)
 
 
-/* space read/write handler function macros */
-#define READ8_HANDLER(name) 			UINT8  name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset)
-#define WRITE8_HANDLER(name)			void   name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data)
-#define READ16_HANDLER(name)			UINT16 name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask)
-#define WRITE16_HANDLER(name)			void   name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask)
-#define READ32_HANDLER(name)			UINT32 name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask)
-#define WRITE32_HANDLER(name)			void   name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask)
-#define READ64_HANDLER(name)			UINT64 name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask)
-#define WRITE64_HANDLER(name)			void   name(ATTR_UNUSED const address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask)
+//**************************************************************************
+//  MACROS
+//**************************************************************************
+
+// opcode base adjustment handler function macro
+#define DIRECT_UPDATE_MEMBER(name)		offs_t name(ATTR_UNUSED direct_read_data &direct, ATTR_UNUSED offs_t address)
+#define DIRECT_UPDATE_HANDLER(name)		offs_t name(ATTR_UNUSED running_machine *machine, ATTR_UNUSED direct_read_data &direct, ATTR_UNUSED offs_t address)
+
+
+// space read/write handler function macros
+#define READ8_HANDLER(name) 			UINT8  name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset)
+#define WRITE8_HANDLER(name)			void   name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data)
+#define READ16_HANDLER(name)			UINT16 name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask)
+#define WRITE16_HANDLER(name)			void   name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask)
+#define READ32_HANDLER(name)			UINT32 name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask)
+#define WRITE32_HANDLER(name)			void   name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask)
+#define READ64_HANDLER(name)			UINT64 name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask)
+#define WRITE64_HANDLER(name)			void   name(ATTR_UNUSED address_space *space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask)
 
 
-/* device read/write handler function macros */
+// device read/write handler function macros
 #define READ8_DEVICE_HANDLER(name)		UINT8  name(ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset)
 #define WRITE8_DEVICE_HANDLER(name) 	void   name(ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data)
 #define READ16_DEVICE_HANDLER(name)		UINT16 name(ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask)
@@ -202,7 +550,27 @@
 #define WRITE64_DEVICE_HANDLER(name)	void   name(ATTR_UNUSED device_t *device, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask)
 
 
-/* helper macro for merging data with the memory mask */
+// space read/write handler function macros
+#define READ8_MEMBER(name)				UINT8  name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 mem_mask)
+#define WRITE8_MEMBER(name)				void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data, ATTR_UNUSED UINT8 mem_mask)
+#define READ16_MEMBER(name)				UINT16 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask)
+#define WRITE16_MEMBER(name)			void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask)
+#define READ32_MEMBER(name)				UINT32 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask)
+#define WRITE32_MEMBER(name)			void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask)
+#define READ64_MEMBER(name)				UINT64 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask)
+#define WRITE64_MEMBER(name)			void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask)
+
+#define DECLARE_READ8_MEMBER(name)		UINT8  name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 mem_mask = 0xff)
+#define DECLARE_WRITE8_MEMBER(name)		void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT8 data, ATTR_UNUSED UINT8 mem_mask = 0xff)
+#define DECLARE_READ16_MEMBER(name)		UINT16 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 mem_mask = 0xffff)
+#define DECLARE_WRITE16_MEMBER(name)	void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT16 data, ATTR_UNUSED UINT16 mem_mask = 0xffff)
+#define DECLARE_READ32_MEMBER(name)		UINT32 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 mem_mask = 0xffffffff)
+#define DECLARE_WRITE32_MEMBER(name)	void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT32 data, ATTR_UNUSED UINT32 mem_mask = 0xffffffff)
+#define DECLARE_READ64_MEMBER(name)		UINT64 name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 mem_mask = U64(0xffffffffffffffff))
+#define DECLARE_WRITE64_MEMBER(name)	void   name(ATTR_UNUSED address_space &space, ATTR_UNUSED offs_t offset, ATTR_UNUSED UINT64 data, ATTR_UNUSED UINT64 mem_mask = U64(0xffffffffffffffff))
+
+
+// helper macro for merging data with the memory mask
 #define COMBINE_DATA(varptr)			(*(varptr) = (*(varptr) & ~mem_mask) | (data & mem_mask))
 
 #define ACCESSING_BITS_0_7				((mem_mask & 0x000000ff) != 0)
@@ -223,596 +591,263 @@
 #define ACCESSING_BITS_32_63			((mem_mask & U64(0xffffffff00000000)) != 0)
 
 
-/* opcode range safety check */
-#define memory_address_outside_direct_region(S,A)	((UNEXPECTED((A) < (S)->direct.bytestart) || UNEXPECTED((A) > (S)->direct.byteend)))
+// macros for accessing bytes and words within larger chunks
+
+// read/write a byte to a 16-bit space
+#define BYTE_XOR_BE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(1,0))
+#define BYTE_XOR_LE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,1))
+
+// read/write a byte to a 32-bit space
+#define BYTE4_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(3,0))
+#define BYTE4_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,3))
+
+// read/write a word to a 32-bit space
+#define WORD_XOR_BE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(2,0))
+#define WORD_XOR_LE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,2))
+
+// read/write a byte to a 64-bit space
+#define BYTE8_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(7,0))
+#define BYTE8_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,7))
+
+// read/write a word to a 64-bit space
+#define WORD2_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(6,0))
+#define WORD2_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,6))
+
+// read/write a dword to a 64-bit space
+#define DWORD_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(4,0))
+#define DWORD_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,4))
 
 
-/* wrappers for dynamic read handler installation */
+// wrappers for dynamic read handler installation
 #define memory_install_read8_handler(space, start, end, mask, mirror, rhandler) \
-	_memory_install_handler8(space, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read16_handler(space, start, end, mask, mirror, rhandler) \
-	_memory_install_handler16(space, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read32_handler(space, start, end, mask, mirror, rhandler) \
-	_memory_install_handler32(space, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read64_handler(space, start, end, mask, mirror, rhandler) \
-	_memory_install_handler64(space, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler)
 
 #define memory_install_read8_device_handler(space, device, start, end, mask, mirror, rhandler) \
-	_memory_install_device_handler8(space, device, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read16_device_handler(space, device, start, end, mask, mirror, rhandler) \
-	_memory_install_device_handler16(space, device, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read32_device_handler(space, device, start, end, mask, mirror, rhandler) \
-	_memory_install_device_handler32(space, device, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler)
 #define memory_install_read64_device_handler(space, device, start, end, mask, mirror, rhandler) \
-	_memory_install_device_handler64(space, device, start, end, mask, mirror, rhandler, #rhandler, NULL, NULL, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler)
 
 #define memory_install_read_port(space, start, end, mask, mirror, rtag) \
-	_memory_install_port(space, start, end, mask, mirror, rtag, NULL)
+	const_cast<address_space *>(space)->install_port(start, end, mask, mirror, rtag, NULL)
 #define memory_install_read_bank(space, start, end, mask, mirror, rtag) \
-	_memory_install_bank(space, start, end, mask, mirror, rtag, NULL)
+	const_cast<address_space *>(space)->install_bank(start, end, mask, mirror, rtag, NULL)
 #define memory_install_rom(space, start, end, mask, mirror, baseptr) \
-	_memory_install_ram(space, start, end, mask, mirror, TRUE, FALSE, baseptr)
+	const_cast<address_space *>(space)->install_ram(start, end, mask, mirror, ROW_READ, baseptr)
 #define memory_unmap_read(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, TRUE, FALSE, FALSE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_READ, false)
 #define memory_nop_read(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, TRUE, FALSE, TRUE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_READ, true)
 
-/* wrappers for dynamic write handler installation */
+// wrappers for dynamic write handler installation
 #define memory_install_write8_handler(space, start, end, mask, mirror, whandler) \
-	_memory_install_handler8(space, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write16_handler(space, start, end, mask, mirror, whandler) \
-	_memory_install_handler16(space, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write32_handler(space, start, end, mask, mirror, whandler) \
-	_memory_install_handler32(space, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write64_handler(space, start, end, mask, mirror, whandler) \
-	_memory_install_handler64(space, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, whandler, #whandler)
 
 #define memory_install_write8_device_handler(space, device, start, end, mask, mirror, whandler) \
-	_memory_install_device_handler8(space, device, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write16_device_handler(space, device, start, end, mask, mirror, whandler) \
-	_memory_install_device_handler16(space, device, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write32_device_handler(space, device, start, end, mask, mirror, whandler) \
-	_memory_install_device_handler32(space, device, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, whandler, #whandler)
 #define memory_install_write64_device_handler(space, device, start, end, mask, mirror, whandler) \
-	_memory_install_device_handler64(space, device, start, end, mask, mirror, NULL, NULL, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, whandler, #whandler)
 
 #define memory_install_write_port(space, start, end, mask, mirror, wtag) \
-	_memory_install_port(space, start, end, mask, mirror, NULL, wtag)
+	const_cast<address_space *>(space)->install_port(start, end, mask, mirror, NULL, wtag)
 #define memory_install_write_bank(space, start, end, mask, mirror, wtag) \
-	_memory_install_bank(space, start, end, mask, mirror, NULL, wtag)
+	const_cast<address_space *>(space)->install_bank(start, end, mask, mirror, NULL, wtag)
 #define memory_install_writeonly(space, start, end, mask, mirror, baseptr) \
-	_memory_install_ram(space, start, end, mask, mirror, FALSE, TRUE, baseptr)
+	const_cast<address_space *>(space)->install_ram(start, end, mask, mirror, ROW_WRITE, baseptr)
 #define memory_unmap_write(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, FALSE, TRUE, FALSE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_WRITE, false)
 #define memory_nop_write(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, FALSE, TRUE, TRUE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_WRITE, true)
 
-/* wrappers for dynamic read/write handler installation */
+// wrappers for dynamic read/write handler installation
 #define memory_install_readwrite8_handler(space, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_handler8(space, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite16_handler(space, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_handler16(space, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite32_handler(space, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_handler32(space, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite64_handler(space, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_handler64(space, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 
 #define memory_install_readwrite8_device_handler(space, device, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_device_handler8(space, device, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite16_device_handler(space, device, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_device_handler16(space, device, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite32_device_handler(space, device, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_device_handler32(space, device, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 #define memory_install_readwrite64_device_handler(space, device, start, end, mask, mirror, rhandler, whandler) \
-	_memory_install_device_handler64(space, device, start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler, 0)
+	const_cast<address_space *>(space)->install_legacy_handler(*(device), start, end, mask, mirror, rhandler, #rhandler, whandler, #whandler)
 
 #define memory_install_readwrite_port(space, start, end, mask, mirror, rtag, wtag) \
-	_memory_install_port(space, start, end, mask, mirror, rtag, wtag)
+	const_cast<address_space *>(space)->install_port(start, end, mask, mirror, rtag, wtag)
 #define memory_install_readwrite_bank(space, start, end, mask, mirror, tag) \
-	_memory_install_bank(space, start, end, mask, mirror, tag, tag)
+	const_cast<address_space *>(space)->install_bank(start, end, mask, mirror, tag, tag)
 #define memory_install_ram(space, start, end, mask, mirror, baseptr) \
-	_memory_install_ram(space, start, end, mask, mirror, TRUE, TRUE, baseptr)
+	const_cast<address_space *>(space)->install_ram(start, end, mask, mirror, ROW_READWRITE, baseptr)
 #define memory_unmap_readwrite(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, TRUE, TRUE, FALSE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_READWRITE, false)
 #define memory_nop_readwrite(space, start, end, mask, mirror) \
-	_memory_unmap(space, start, end, mask, mirror, TRUE, TRUE, TRUE)
+	const_cast<address_space *>(space)->unmap(start, end, mask, mirror, ROW_READWRITE, true)
 
 
-/* macros for accessing bytes and words within larger chunks */
 
-/* read/write a byte to a 16-bit space */
-#define BYTE_XOR_BE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(1,0))
-#define BYTE_XOR_LE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,1))
-
-/* read/write a byte to a 32-bit space */
-#define BYTE4_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(3,0))
-#define BYTE4_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,3))
-
-/* read/write a word to a 32-bit space */
-#define WORD_XOR_BE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(2,0))
-#define WORD_XOR_LE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,2))
-
-/* read/write a byte to a 64-bit space */
-#define BYTE8_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(7,0))
-#define BYTE8_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,7))
-
-/* read/write a word to a 64-bit space */
-#define WORD2_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(6,0))
-#define WORD2_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,6))
-
-/* read/write a dword to a 64-bit space */
-#define DWORD_XOR_BE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(4,0))
-#define DWORD_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,4))
-
-
-
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
 extern const char *const address_space_names[ADDRESS_SPACES];
 
 
 
-/***************************************************************************
-    FUNCTION PROTOTYPES FOR CORE MEMORY FUNCTIONS
-***************************************************************************/
+//**************************************************************************
+//  FUNCTION PROTOTYPES FOR CORE MEMORY FUNCTIONS
+//**************************************************************************
 
-
-/* ----- core system operations ----- */
-
-/* initialize the memory system */
+// initialize the memory system
 void memory_init(running_machine *machine);
 
-
-
-/* ----- direct access control ----- */
-
-/* registers an address range as having a decrypted data pointer */
-void memory_set_decrypted_region(const address_space *space, offs_t addrstart, offs_t addrend, void *base) ATTR_NONNULL(1, 4);
-
-/* register a handler for opcode base changes on a given device */
-direct_update_func memory_set_direct_update_handler(const address_space *space, direct_update_func function) ATTR_NONNULL(1);
-
-/* called by device cores to update the opcode base for the given address */
-int memory_set_direct_region(const address_space *space, offs_t *byteaddress) ATTR_NONNULL(1, 2);
-
-/* return a pointer the memory byte provided in the given address space, or NULL if it is not mapped to a bank */
-void *memory_get_read_ptr(const address_space *space, offs_t byteaddress) ATTR_NONNULL(1);
-
-/* return a pointer the memory byte provided in the given address space, or NULL if it is not mapped to a writeable bank */
-void *memory_get_write_ptr(const address_space *space, offs_t byteaddress) ATTR_NONNULL(1);
-
-
-
-/* ----- memory banking ----- */
-
-/* configure the addresses for a bank */
+// configure the addresses for a bank
 void memory_configure_bank(running_machine *machine, const char *tag, int startentry, int numentries, void *base, offs_t stride) ATTR_NONNULL(1, 5);
 
-/* configure the decrypted addresses for a bank */
+// configure the decrypted addresses for a bank
 void memory_configure_bank_decrypted(running_machine *machine, const char *tag, int startentry, int numentries, void *base, offs_t stride) ATTR_NONNULL(1, 5);
 
-/* select one pre-configured entry to be the new bank base */
+// select one pre-configured entry to be the new bank base
 void memory_set_bank(running_machine *machine, const char *tag, int entrynum) ATTR_NONNULL(1);
 
-/* return the currently selected bank */
+// return the currently selected bank
 int memory_get_bank(running_machine *machine, const char *tag) ATTR_NONNULL(1);
 
-/* set the absolute address of a bank base */
+// set the absolute address of a bank base
 void memory_set_bankptr(running_machine *machine, const char *tag, void *base) ATTR_NONNULL(1, 3);
 
-
-
-/* ----- dynamic address space mapping ----- */
-
-/* install a new 8-bit memory handler into the given address space, returning a pointer to the memory backing it, if present */
-UINT8 *_memory_install_handler8(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_space_func rhandler, const char *rhandler_name, write8_space_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1);
-
-/* same as above but explicitly for 16-bit handlers */
-UINT16 *_memory_install_handler16(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_space_func rhandler, const char *rhandler_name, write16_space_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1);
-
-/* same as above but explicitly for 32-bit handlers */
-UINT32 *_memory_install_handler32(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_space_func rhandler, const char *rhandler_name, write32_space_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1);
-
-/* same as above but explicitly for 64-bit handlers */
-UINT64 *_memory_install_handler64(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_space_func rhandler, const char *rhandler_name, write64_space_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1);
-
-/* install a new 8-bit device memory handler into the given address space, returning a pointer to the memory backing it, if present */
-UINT8 *_memory_install_device_handler8(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read8_device_func rhandler, const char *rhandler_name, write8_device_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1, 2);
-
-/* same as above but explicitly for 16-bit handlers */
-UINT16 *_memory_install_device_handler16(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read16_device_func rhandler, const char *rhandler_name, write16_device_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1, 2);
-
-/* same as above but explicitly for 32-bit handlers */
-UINT32 *_memory_install_device_handler32(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read32_device_func rhandler, const char *rhandler_name, write32_device_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1, 2);
-
-/* same as above but explicitly for 64-bit handlers */
-UINT64 *_memory_install_device_handler64(const address_space *space, device_t *device, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, read64_device_func rhandler, const char *rhandler_name, write64_device_func whandler, const char *whandler_name, int handlerunitmask) ATTR_NONNULL(1, 2);
-
-/* install a new port into the given address space */
-void _memory_install_port(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag) ATTR_NONNULL(1);
-
-/* install a new bank into the given address space */
-void _memory_install_bank(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, const char *rtag, const char *wtag) ATTR_NONNULL(1);
-
-/* install a simple fixed RAM region into the given address space */
-void *_memory_install_ram(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, UINT8 install_read, UINT8 install_write, void *baseptr) ATTR_NONNULL(1);
-
-/* unmap a section of address space */
-void _memory_unmap(const address_space *space, offs_t addrstart, offs_t addrend, offs_t addrmask, offs_t addrmirror, UINT8 unmap_read, UINT8 unmap_write, UINT8 quiet) ATTR_NONNULL(1);
-
-
-
-/* ----- debugger helpers ----- */
-
-/* return a string describing the handler at a particular offset */
-const char *memory_get_handler_string(const address_space *space, int read0_or_write1, offs_t byteaddress);
-
-/* enable/disable read watchpoint tracking for a given address space */
-void memory_enable_read_watchpoints(const address_space *space, int enable);
-
-/* enable/disable write watchpoint tracking for a given address space */
-void memory_enable_write_watchpoints(const address_space *space, int enable);
-
-/* control whether subsequent accesses are treated as coming from the debugger */
-void memory_set_debugger_access(const address_space *space, int debugger);
-
-/* sets whether unmapped memory accesses should be logged or not */
-void memory_set_log_unmap(const address_space *space, int log);
-
-/* gets whether unmapped memory accesses are being logged or not */
-int	memory_get_log_unmap(const address_space *space);
-
-/* dump the internal memory tables to the given file */
+// dump the internal memory tables to the given file
 void memory_dump(running_machine *machine, FILE *file);
 
 
 
-/***************************************************************************
-    INLINE FUNCTIONS
-***************************************************************************/
-
-/*-------------------------------------------------
-    memory_address_to_byte - convert an address in
-    the specified address space to a byte offset
--------------------------------------------------*/
-
-INLINE offs_t memory_address_to_byte(const address_space *space, offs_t address)
-{
-	return (space->ashift < 0) ? (address << -space->ashift) : (address >> space->ashift);
-}
-
-
-/*-------------------------------------------------
-    memory_address_to_byte_end - convert an address
-    in the specified address space to a byte
-    offset specifying the last byte covered by
-    the address
--------------------------------------------------*/
-
-INLINE offs_t memory_address_to_byte_end(const address_space *space, offs_t address)
-{
-	return (space->ashift < 0) ? ((address << -space->ashift) | ((1 << -space->ashift) - 1)) : (address >> space->ashift);
-}
-
-
-/*-------------------------------------------------
-    memory_byte_to_address - convert a byte offset
-    to an address in the specified address space
--------------------------------------------------*/
-
-INLINE offs_t memory_byte_to_address(const address_space *space, offs_t address)
-{
-	return (space->ashift < 0) ? (address >> -space->ashift) : (address << space->ashift);
-}
-
-
-/*-------------------------------------------------
-    memory_byte_to_address_end - convert a byte
-    offset to an address in the specified address
-    space specifying the last address covered by
-    the byte
--------------------------------------------------*/
-
-INLINE offs_t memory_byte_to_address_end(const address_space *space, offs_t address)
-{
-	return (space->ashift < 0) ? (address >> -space->ashift) : ((address << space->ashift) | ((1 << space->ashift) - 1));
-}
-
-
-/*-------------------------------------------------
-    memory_read_byte/word/dword/qword - read a
-    value from the specified address space
--------------------------------------------------*/
-
-INLINE UINT8 memory_read_byte(const address_space *space, offs_t byteaddress)
-{
-	return (*space->accessors.read_byte)(space, byteaddress);
-}
-
-INLINE UINT16 memory_read_word(const address_space *space, offs_t byteaddress)
-{
-	return (*space->accessors.read_word)(space, byteaddress);
-}
-
-INLINE UINT16 memory_read_word_masked(const address_space *space, offs_t byteaddress, UINT16 mask)
-{
-	return (*space->accessors.read_word_masked)(space, byteaddress, mask);
-}
-
-INLINE UINT32 memory_read_dword(const address_space *space, offs_t byteaddress)
-{
-	return (*space->accessors.read_dword)(space, byteaddress);
-}
-
-INLINE UINT32 memory_read_dword_masked(const address_space *space, offs_t byteaddress, UINT32 mask)
-{
-	return (*space->accessors.read_dword_masked)(space, byteaddress, mask);
-}
-
-INLINE UINT64 memory_read_qword(const address_space *space, offs_t byteaddress)
-{
-	return (*space->accessors.read_qword)(space, byteaddress);
-}
-
-INLINE UINT64 memory_read_qword_masked(const address_space *space, offs_t byteaddress, UINT64 mask)
-{
-	return (*space->accessors.read_qword_masked)(space, byteaddress, mask);
-}
-
+//**************************************************************************
+//  INLINE FUNCTIONS
+//**************************************************************************
+
+//-------------------------------------------------
+//  read_raw_ptr - return a pointer to valid RAM
+//  referenced by the address, or NULL if no RAM
+//  backing that address
+//-------------------------------------------------
 
-/*-------------------------------------------------
-    memory_write_byte/word/dword/qword - write a
-    value to the specified address space
--------------------------------------------------*/
-
-INLINE void memory_write_byte(const address_space *space, offs_t byteaddress, UINT8 data)
+inline void *direct_read_data::read_raw_ptr(offs_t byteaddress)
 {
-	(*space->accessors.write_byte)(space, byteaddress, data);
-}
-
-INLINE void memory_write_word(const address_space *space, offs_t byteaddress, UINT16 data)
-{
-	(*space->accessors.write_word)(space, byteaddress, data);
+	if (address_is_valid(byteaddress))
+		return &m_raw[byteaddress & m_bytemask];
+	return NULL;
 }
 
-INLINE void memory_write_word_masked(const address_space *space, offs_t byteaddress, UINT16 data, UINT16 mask)
+inline void *direct_read_data::read_decrypted_ptr(offs_t byteaddress)
 {
-	(*space->accessors.write_word_masked)(space, byteaddress, data, mask);
+	if (address_is_valid(byteaddress))
+		return &m_decrypted[byteaddress & m_bytemask];
+	return NULL;
 }
 
-INLINE void memory_write_dword(const address_space *space, offs_t byteaddress, UINT32 data)
-{
-	(*space->accessors.write_dword)(space, byteaddress, data);
-}
 
-INLINE void memory_write_dword_masked(const address_space *space, offs_t byteaddress, UINT32 data, UINT32 mask)
-{
-	(*space->accessors.write_dword_masked)(space, byteaddress, data, mask);
-}
+//-------------------------------------------------
+//  read_raw_byte - read a byte via the
+//  direct_read_data class
+//-------------------------------------------------
 
-INLINE void memory_write_qword(const address_space *space, offs_t byteaddress, UINT64 data)
+inline UINT8 direct_read_data::read_raw_byte(offs_t byteaddress)
 {
-	(*space->accessors.write_qword)(space, byteaddress, data);
+	if (address_is_valid(byteaddress))
+		return m_raw[byteaddress & m_bytemask];
+	return m_space.read_byte(byteaddress);
 }
 
-INLINE void memory_write_qword_masked(const address_space *space, offs_t byteaddress, UINT64 data, UINT64 mask)
+inline UINT8 direct_read_data::read_decrypted_byte(offs_t byteaddress)
 {
-	(*space->accessors.write_qword_masked)(space, byteaddress, data, mask);
+	if (address_is_valid(byteaddress))
+		return m_decrypted[byteaddress & m_bytemask];
+	return m_space.read_byte(byteaddress);
 }
 
 
-/*-------------------------------------------------
-    memory_decrypted_read_byte/word/dword/qword -
-    read a value from the specified address space
-    using the direct addressing mechanism and
-    the decrypted base pointer
--------------------------------------------------*/
+//-------------------------------------------------
+//  read_raw_word - read a word via the
+//  direct_read_data class
+//-------------------------------------------------
 
-INLINE void *memory_decrypted_read_ptr(const address_space *space, offs_t byteaddress)
+inline UINT16 direct_read_data::read_raw_word(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return &space->direct.decrypted[byteaddress & space->direct.bytemask];
-	return NULL;
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT16 *>(&m_raw[byteaddress & m_bytemask]);
+	return m_space.read_word(byteaddress);
 }
 
-INLINE UINT8 memory_decrypted_read_byte(const address_space *space, offs_t byteaddress)
+inline UINT16 direct_read_data::read_decrypted_word(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return space->direct.decrypted[byteaddress & space->direct.bytemask];
-	return memory_read_byte(space, byteaddress);
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT16 *>(&m_decrypted[byteaddress & m_bytemask]);
+	return m_space.read_word(byteaddress);
 }
 
-INLINE UINT16 memory_decrypted_read_word(const address_space *space, offs_t byteaddress)
-{
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT16 *)&space->direct.decrypted[byteaddress & space->direct.bytemask];
-	return memory_read_word(space, byteaddress);
-}
 
-INLINE UINT32 memory_decrypted_read_dword(const address_space *space, offs_t byteaddress)
-{
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT32 *)&space->direct.decrypted[byteaddress & space->direct.bytemask];
-	return memory_read_dword(space, byteaddress);
-}
+//-------------------------------------------------
+//  read_raw_dword - read a dword via the
+//  direct_read_data class
+//-------------------------------------------------
 
-INLINE UINT64 memory_decrypted_read_qword(const address_space *space, offs_t byteaddress)
+inline UINT32 direct_read_data::read_raw_dword(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT64 *)&space->direct.decrypted[byteaddress & space->direct.bytemask];
-	return memory_read_qword(space, byteaddress);
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT32 *>(&m_raw[byteaddress & m_bytemask]);
+	return m_space.read_dword(byteaddress);
 }
 
-
-/*-------------------------------------------------
-    memory_raw_read_byte/word/dword/qword -
-    read a value from the specified address space
-    using the direct addressing mechanism and
-    the raw base pointer
--------------------------------------------------*/
-
-INLINE void *memory_raw_read_ptr(const address_space *space, offs_t byteaddress)
+inline UINT32 direct_read_data::read_decrypted_dword(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return &space->direct.raw[byteaddress & space->direct.bytemask];
-	return NULL;
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT32 *>(&m_decrypted[byteaddress & m_bytemask]);
+	return m_space.read_dword(byteaddress);
 }
 
-INLINE UINT8 memory_raw_read_byte(const address_space *space, offs_t byteaddress)
-{
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return space->direct.raw[byteaddress & space->direct.bytemask];
-	return memory_read_byte(space, byteaddress);
-}
 
-INLINE UINT16 memory_raw_read_word(const address_space *space, offs_t byteaddress)
-{
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT16 *)&space->direct.raw[byteaddress & space->direct.bytemask];
-	return memory_read_word(space, byteaddress);
-}
+//-------------------------------------------------
+//  read_raw_qword - read a qword via the
+//  direct_read_data class
+//-------------------------------------------------
 
-INLINE UINT32 memory_raw_read_dword(const address_space *space, offs_t byteaddress)
+inline UINT64 direct_read_data::read_raw_qword(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT32 *)&space->direct.raw[byteaddress & space->direct.bytemask];
-	return memory_read_dword(space, byteaddress);
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT64 *>(&m_raw[byteaddress & m_bytemask]);
+	return m_space.read_qword(byteaddress);
 }
 
-INLINE UINT64 memory_raw_read_qword(const address_space *space, offs_t byteaddress)
+inline UINT64 direct_read_data::read_decrypted_qword(offs_t byteaddress)
 {
-	if (!memory_address_outside_direct_region(space, byteaddress) || memory_set_direct_region(space, &byteaddress))
-		return *(UINT64 *)&space->direct.raw[byteaddress & space->direct.bytemask];
-	return memory_read_qword(space, byteaddress);
+	if (address_is_valid(byteaddress))
+		return *reinterpret_cast<UINT64 *>(&m_decrypted[byteaddress & m_bytemask]);
+	return m_space.read_qword(byteaddress);
 }
 
 
-
-/***************************************************************************
-    FUNCTION PROTOTYPES FOR CORE READ/WRITE ROUTINES
-***************************************************************************/
-
-/* declare generic address space handlers */
-UINT8 memory_read_byte_8le(const address_space *space, offs_t address);
-UINT16 memory_read_word_8le(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_8le(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_8le(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_8le(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_8le(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_8le(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_8le(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_8le(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_8le(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_8le(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_8le(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_8le(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_8le(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_8be(const address_space *space, offs_t address);
-UINT16 memory_read_word_8be(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_8be(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_8be(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_8be(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_8be(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_8be(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_8be(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_8be(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_8be(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_8be(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_8be(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_8be(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_8be(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_16le(const address_space *space, offs_t address);
-UINT16 memory_read_word_16le(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_16le(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_16le(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_16le(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_16le(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_16le(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_16le(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_16le(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_16le(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_16le(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_16le(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_16le(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_16le(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_16be(const address_space *space, offs_t address);
-UINT16 memory_read_word_16be(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_16be(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_16be(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_16be(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_16be(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_16be(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_16be(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_16be(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_16be(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_16be(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_16be(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_16be(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_16be(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_32le(const address_space *space, offs_t address);
-UINT16 memory_read_word_32le(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_32le(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_32le(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_32le(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_32le(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_32le(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_32le(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_32le(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_32le(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_32le(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_32le(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_32le(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_32le(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_32be(const address_space *space, offs_t address);
-UINT16 memory_read_word_32be(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_32be(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_32be(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_32be(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_32be(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_32be(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_32be(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_32be(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_32be(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_32be(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_32be(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_32be(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_32be(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_64le(const address_space *space, offs_t address);
-UINT16 memory_read_word_64le(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_64le(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_64le(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_64le(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_64le(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_64le(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_64le(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_64le(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_64le(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_64le(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_64le(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_64le(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_64le(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
-UINT8 memory_read_byte_64be(const address_space *space, offs_t address);
-UINT16 memory_read_word_64be(const address_space *space, offs_t address);
-UINT16 memory_read_word_masked_64be(const address_space *space, offs_t address, UINT16 mask);
-UINT32 memory_read_dword_64be(const address_space *space, offs_t address);
-UINT32 memory_read_dword_masked_64be(const address_space *space, offs_t address, UINT32 mask);
-UINT64 memory_read_qword_64be(const address_space *space, offs_t address);
-UINT64 memory_read_qword_masked_64be(const address_space *space, offs_t address, UINT64 mask);
-void memory_write_byte_64be(const address_space *space, offs_t address, UINT8 data);
-void memory_write_word_64be(const address_space *space, offs_t address, UINT16 data);
-void memory_write_word_masked_64be(const address_space *space, offs_t address, UINT16 data, UINT16 mask);
-void memory_write_dword_64be(const address_space *space, offs_t address, UINT32 data);
-void memory_write_dword_masked_64be(const address_space *space, offs_t address, UINT32 data, UINT32 mask);
-void memory_write_qword_64be(const address_space *space, offs_t address, UINT64 data);
-void memory_write_qword_masked_64be(const address_space *space, offs_t address, UINT64 data, UINT64 mask);
-
 #endif	/* __MEMORY_H__ */
diff -Nru src-old/emu/profiler.c src/emu/profiler.c
--- src-old/emu/profiler.c	2010-06-27 23:40:44.000000000 -0700
+++ src/emu/profiler.c	2010-08-30 08:20:58.000000000 -0700
@@ -4,8 +4,49 @@
 
     Functions to manage profiling of MAME execution.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+****************************************************************************
+
+    Profiling is scope-based. To start profiling, put a profiler_scope
+    object on the stack. To end profiling, just end the scope:
+
+    {
+        profiler_scope scope(PROFILER_VIDEO);
+
+        your_work_here();
+    }
+
+    the profiler handles a FILO list so calls may be nested.
 
 ***************************************************************************/
 
@@ -14,12 +55,11 @@
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-typedef struct _profile_string profile_string;
-struct _profile_string
+struct profile_string
 {
 	int 		type;
 	const char *string;
@@ -27,94 +67,120 @@
 
 
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-profiler_state global_profiler;
+profiler_state g_profiler;
 
 
 
-/***************************************************************************
-    CORE FUNCTIONS
-***************************************************************************/
+//**************************************************************************
+//  DUMMY PROFILER STATE
+//**************************************************************************
+
+//-------------------------------------------------
+//  dummy_profiler_state - constructor
+//-------------------------------------------------
+
+dummy_profiler_state::dummy_profiler_state()
+{
+}
+
 
-/*-------------------------------------------------
-    _profiler_mark_start - mark the beginning of a
-    profiler entry
--------------------------------------------------*/
 
-void _profiler_mark_start(int type)
+//**************************************************************************
+//  REAL PROFILER STATE
+//**************************************************************************
+
+//-------------------------------------------------
+//  real_profiler_state - constructor
+//-------------------------------------------------
+
+real_profiler_state::real_profiler_state()
+	: m_enabled(false),
+	  m_dataready(false),
+	  m_filoindex(0),
+	  m_dataindex(0)
+{
+	memset(m_filo, 0, sizeof(m_filo));
+	memset(m_data, 0, sizeof(m_data));
+}
+
+
+//-------------------------------------------------
+//  real_start - mark the beginning of a
+//  profiler entry
+//-------------------------------------------------
+
+void real_profiler_state::real_start(profile_type type)
 {
-	profiler_data *data = &global_profiler.data[global_profiler.dataindex];
 	osd_ticks_t curticks = get_profile_ticks();
-	profiler_filo_entry *entry;
-	int index;
 
-	/* track context switches */
+	// track context switches
+	history_data &data = m_data[m_dataindex];
 	if (type >= PROFILER_DEVICE_FIRST && type <= PROFILER_DEVICE_MAX)
-		data->context_switches++;
+		data.context_switches++;
 
-	/* we're starting a new bucket, begin now */
-	index = global_profiler.filoindex++;
-	entry = &global_profiler.filo[index];
+	// we're starting a new bucket, begin now
+	int index = m_filoindex++;
+	filo_entry &entry = m_filo[index];
 
-	/* fail if we overflow */
-	if (index > ARRAY_LENGTH(global_profiler.filo))
-		fatalerror("Profiler FILO overflow (type = %d)\n", type);
+	// fail if we overflow
+	if (index > ARRAY_LENGTH(m_filo))
+		throw emu_fatalerror("Profiler FILO overflow (type = %d)\n", type);
 
-	/* if we're nested, stop the previous entry */
+	// if we're nested, stop the previous entry
 	if (index > 0)
 	{
-		profiler_filo_entry *preventry = entry - 1;
-		data->duration[preventry->type] += curticks - preventry->start;
+		filo_entry &preventry = m_filo[index - 1];
+		data.duration[preventry.type] += curticks - preventry.start;
 	}
 
-	/* fill in this entry */
-	entry->type = type;
-	entry->start = curticks;
+	// fill in this entry
+	entry.type = type;
+	entry.start = curticks;
 }
 
 
-/*-------------------------------------------------
-    _profiler_mark_end - mark the end of a
-    profiler entry
--------------------------------------------------*/
+//-------------------------------------------------
+//  real_stop - mark the end of a profiler entry
+//-------------------------------------------------
 
-void _profiler_mark_end(void)
+void real_profiler_state::real_stop()
 {
-	profiler_data *data = &global_profiler.data[global_profiler.dataindex];
 	osd_ticks_t curticks = get_profile_ticks();
 
-	/* we're ending an existing bucket, update the time */
-	if (global_profiler.filoindex > 0)
+	// we're ending an existing bucket, update the time
+	if (m_filoindex > 0)
 	{
-		int index = --global_profiler.filoindex;
-		profiler_filo_entry *entry = &global_profiler.filo[index];
+		int index = --m_filoindex;
+		filo_entry &entry = m_filo[index];
 
-		/* account for the time taken */
-		data->duration[entry->type] += curticks - entry->start;
+		// account for the time taken
+		history_data &data = m_data[m_dataindex];
+		data.duration[entry.type] += curticks - entry.start;
 
-		/* if we have a previous entry, restart his time now */
+		// if we have a previous entry, restart his time now
 		if (index != 0)
 		{
-			profiler_filo_entry *preventry = entry - 1;
-			preventry->start = curticks;
+			filo_entry &preventry = m_filo[index - 1];
+			preventry.start = curticks;
 		}
 	}
 }
 
 
-/*-------------------------------------------------
-    _profiler_get_text - return the current text
-    in an astring
--------------------------------------------------*/
+//-------------------------------------------------
+//  text - return the current text in an astring
+//-------------------------------------------------
 
-astring &_profiler_get_text(running_machine *machine, astring &string)
+const char *real_profiler_state::text(running_machine &machine, astring &string)
 {
 	static const profile_string names[] =
 	{
 		{ PROFILER_DRC_COMPILE,      "DRC Compilation" },
+		{ PROFILER_MEM_REMAP,        "Memory Remapping" },
 		{ PROFILER_MEMREAD,          "Memory Read" },
 		{ PROFILER_MEMWRITE,         "Memory Write" },
 		{ PROFILER_VIDEO,            "Video Update" },
@@ -141,84 +207,82 @@
 		{ PROFILER_PROFILER,         "Profiler" },
 		{ PROFILER_IDLE,             "Idle" }
 	};
-	UINT64 computed, normalize, total;
-	int curtype, curmem, switches;
 
-	profiler_mark_start(PROFILER_PROFILER);
+	g_profiler.start(PROFILER_PROFILER);
 
-	/* compute the total time for all bits, not including profiler or idle */
-	computed = 0;
-	for (curtype = 0; curtype < PROFILER_PROFILER; curtype++)
-		for (curmem = 0; curmem < ARRAY_LENGTH(global_profiler.data); curmem++)
-			computed += global_profiler.data[curmem].duration[curtype];
+	// compute the total time for all bits, not including profiler or idle
+	UINT64 computed = 0;
+	profile_type curtype;
+	for (curtype = PROFILER_DEVICE_FIRST; curtype < PROFILER_PROFILER; curtype++)
+		for (int curmem = 0; curmem < ARRAY_LENGTH(m_data); curmem++)
+			computed += m_data[curmem].duration[curtype];
 
-	/* save that result in normalize, and continue adding the rest */
-	normalize = computed;
+	// save that result in normalize, and continue adding the rest
+	UINT64 normalize = computed;
 	for ( ; curtype < PROFILER_TOTAL; curtype++)
-		for (curmem = 0; curmem < ARRAY_LENGTH(global_profiler.data); curmem++)
-			computed += global_profiler.data[curmem].duration[curtype];
+		for (int curmem = 0; curmem < ARRAY_LENGTH(m_data); curmem++)
+			computed += m_data[curmem].duration[curtype];
 
-	/* this becomes the total; if we end up with 0 for anything, we were just started, so return empty */
-	total = computed;
+	// this becomes the total; if we end up with 0 for anything, we were just started, so return empty
+	UINT64 total = computed;
 	string.reset();
 	if (total == 0 || normalize == 0)
-		goto out;
+	{
+		g_profiler.stop();
+		return string;
+	}
 
-	/* loop over all types and generate the string */
-	for (curtype = 0; curtype < PROFILER_TOTAL; curtype++)
+	// loop over all types and generate the string
+	for (curtype = PROFILER_DEVICE_FIRST; curtype < PROFILER_TOTAL; curtype++)
 	{
-		/* determine the accumulated time for this type */
+		// determine the accumulated time for this type
 		computed = 0;
-		for (curmem = 0; curmem < ARRAY_LENGTH(global_profiler.data); curmem++)
-			computed += global_profiler.data[curmem].duration[curtype];
+		for (int curmem = 0; curmem < ARRAY_LENGTH(m_data); curmem++)
+			computed += m_data[curmem].duration[curtype];
 
-		/* if we have non-zero data and we're ready to display, do it */
-		if (global_profiler.dataready && computed != 0)
+		// if we have non-zero data and we're ready to display, do it
+		if (m_dataready && computed != 0)
 		{
-			int nameindex;
-
-			/* start with the un-normalized percentage */
+			// start with the un-normalized percentage
 			string.catprintf("%02d%% ", (int)((computed * 100 + total/2) / total));
 
-			/* followed by the normalized percentage for everything but profiler and idle */
+			// followed by the normalized percentage for everything but profiler and idle
 			if (curtype < PROFILER_PROFILER)
 				string.catprintf("%02d%% ", (int)((computed * 100 + normalize/2) / normalize));
 
-			/* and then the text */
+			// and then the text
 			if (curtype >= PROFILER_DEVICE_FIRST && curtype <= PROFILER_DEVICE_MAX)
-				string.catprintf("'%s'", machine->m_devicelist.find(curtype - PROFILER_DEVICE_FIRST)->tag());
+				string.catprintf("'%s'", machine.m_devicelist.find(curtype - PROFILER_DEVICE_FIRST)->tag());
 			else
-				for (nameindex = 0; nameindex < ARRAY_LENGTH(names); nameindex++)
+				for (int nameindex = 0; nameindex < ARRAY_LENGTH(names); nameindex++)
 					if (names[nameindex].type == curtype)
 					{
 						string.cat(names[nameindex].string);
 						break;
 					}
 
-			/* followed by a carriage return */
+			// followed by a carriage return
 			string.cat("\n");
 		}
 	}
 
-	/* followed by context switches */
-	if (global_profiler.dataready)
+	// followed by context switches
+	if (m_dataready)
 	{
-		switches = 0;
-		for (curmem = 0; curmem < ARRAY_LENGTH(global_profiler.data); curmem++)
-			switches += global_profiler.data[curmem].context_switches;
-		string.catprintf("%d CPU switches\n", switches / (int) ARRAY_LENGTH(global_profiler.data));
+		int switches = 0;
+		for (int curmem = 0; curmem < ARRAY_LENGTH(m_data); curmem++)
+			switches += m_data[curmem].context_switches;
+		string.catprintf("%d CPU switches\n", switches / (int) ARRAY_LENGTH(m_data));
 	}
 
-	/* advance to the next dataset and reset it to 0 */
-	global_profiler.dataindex = (global_profiler.dataindex + 1) % ARRAY_LENGTH(global_profiler.data);
-	memset(&global_profiler.data[global_profiler.dataindex], 0, sizeof(global_profiler.data[global_profiler.dataindex]));
-
-	/* we are ready once we have wrapped around */
-	if (global_profiler.dataindex == 0)
-		global_profiler.dataready = TRUE;
-
-out:
-	profiler_mark_end();
+	// advance to the next dataset and reset it to 0
+	m_dataindex = (m_dataindex + 1) % ARRAY_LENGTH(m_data);
+	memset(&m_data[m_dataindex], 0, sizeof(m_data[m_dataindex]));
+
+	// we are ready once we have wrapped around
+	if (m_dataindex == 0)
+		m_dataready = true;
 
+	g_profiler.stop();
 	return string;
 }
diff -Nru src-old/emu/profiler.h src/emu/profiler.h
--- src-old/emu/profiler.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/profiler.h	2010-08-30 08:20:58.000000000 -0700
@@ -4,16 +4,47 @@
 
     Functions to manage profiling of MAME execution.
 
-    Copyright Nicola Salmoria and the MAME Team.
-    Visit http://mamedev.org for licensing and usage restrictions.
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
 
 ****************************************************************************
 
-    To start profiling a certain section, e.g. video:
-    profiler_mark_start(PROFILER_VIDEO);
+    Profiling is scope-based. To start profiling, put a profiler_scope
+    object on the stack. To end profiling, just end the scope:
+
+    {
+        profiler_scope scope(PROFILER_VIDEO);
 
-    to end profiling the current section:
-    profiler_mark_end();
+        your_work_here();
+    }
 
     the profiler handles a FILO list so calls may be nested.
 
@@ -26,16 +57,16 @@
 
 
 
-/***************************************************************************
-    CONSTANTS
-***************************************************************************/
+//**************************************************************************
+//  CONSTANTS
+//**************************************************************************
 
-/* profiling */
-enum
+enum profile_type
 {
 	PROFILER_DEVICE_FIRST = 0,
 	PROFILER_DEVICE_MAX = PROFILER_DEVICE_FIRST + 256,
 	PROFILER_DRC_COMPILE,
+	PROFILER_MEM_REMAP,
 	PROFILER_MEMREAD,
 	PROFILER_MEMWRITE,
 	PROFILER_VIDEO,
@@ -47,13 +78,13 @@
 	PROFILER_BLIT,
 	PROFILER_SOUND,
 	PROFILER_TIMER_CALLBACK,
-	PROFILER_INPUT,		/* input.c and inptport.c */
-	PROFILER_MOVIE_REC,	/* movie recording */
-	PROFILER_LOGERROR,	/* logerror */
-	PROFILER_EXTRA,		/* everything else */
+	PROFILER_INPUT,				// input.c and inptport.c
+	PROFILER_MOVIE_REC,			// movie recording
+	PROFILER_LOGERROR,			// logerror
+	PROFILER_EXTRA,				// everything else
 
-	/* the USER types are available to driver writers to profile */
-	/* custom sections of the code */
+	// the USER types are available to driver writers to profile
+	// custom sections of the code
 	PROFILER_USER1,
 	PROFILER_USER2,
 	PROFILER_USER3,
@@ -67,89 +98,111 @@
 	PROFILER_IDLE,
 	PROFILER_TOTAL
 };
+DECLARE_ENUM_OPERATORS(profile_type);
 
 
 
-/***************************************************************************
-    TYPE DEFINITIONS
-***************************************************************************/
+//**************************************************************************
+//  TYPE DEFINITIONS
+//**************************************************************************
 
-typedef struct _profiler_filo_entry profiler_filo_entry;
-struct _profiler_filo_entry
-{
-	int				type;				/* type of entry */
-	osd_ticks_t		start;				/* start time */
-};
 
+// ======================> real_profiler_state
 
-typedef struct _profiler_data profiler_data;
-struct _profiler_data
+class real_profiler_state
 {
-	UINT32			context_switches;	/* number of context switches seen */
-	osd_ticks_t		duration[PROFILER_TOTAL]; /* duration spent in each entry */
-};
-
+	friend class profile_scope;
 
-typedef struct _profiler_state profiler_state;
-struct _profiler_state
-{
-	UINT8			enabled;			/* are we enabled? */
-	UINT8			filoindex;			/* current FILO index */
-	UINT8			dataindex;			/* current data index */
-	UINT8			dataready;			/* are we to display the data yet? */
-	profiler_filo_entry filo[16];		/* array of FILO entries */
-	profiler_data	data[16];			/* array of data */
+public:
+	// construction/destruction
+	real_profiler_state();
+
+	// getters
+	bool enabled() const { return m_enabled; }
+	const char *text(running_machine &machine, astring &string);
+
+	// enable/disable
+	void enable(bool state = true)
+	{
+		if (state != m_enabled)
+		{
+			m_enabled = state;
+			if (m_enabled)
+			{
+				m_dataready = false;
+				m_filoindex = m_dataindex = 0;
+			}
+		}
+	}
+
+	// start/stop
+	void start(profile_type type) { if (m_enabled) real_start(type); }
+	void stop() { if (m_enabled) real_stop(); }
+
+private:
+	void real_start(profile_type type);
+	void real_stop();
+
+	// an entry in the FILO
+	struct filo_entry
+	{
+		int				type;						// type of entry
+		osd_ticks_t		start;						// start time
+	};
+
+	// item in the array of recent states
+	struct history_data
+	{
+		UINT32			context_switches;			// number of context switches seen
+		osd_ticks_t		duration[PROFILER_TOTAL];	// duration spent in each entry
+	};
+
+	// internal state
+	bool				m_enabled;					// are we enabled?
+	bool				m_dataready;				// are we to display the data yet?
+	UINT8				m_filoindex;				// current FILO index
+	UINT8				m_dataindex;				// current data index
+	filo_entry			m_filo[16];					// array of FILO entries
+	history_data		m_data[16];					// array of data
 };
 
 
+// ======================> dummy_profiler_state
 
-/***************************************************************************
-    GLOBAL VARIABLES
-***************************************************************************/
-
-extern profiler_state global_profiler;
-
+class dummy_profiler_state
+{
+public:
+	// construction/destruction
+	dummy_profiler_state();
+
+	// getters
+	bool enabled() const { return false; }
+	const char *text(running_machine &machine, astring &string) { return string.cpy(""); }
+
+	// enable/disable
+	void enable(bool state = true) { }
+
+	// start/stop
+	void start(profile_type type) { }
+	void stop() { }
+};
 
 
-/***************************************************************************
-    MACROS
-***************************************************************************/
+// ======================> profiler_state
 
 #ifdef MAME_PROFILER
-
-#define profiler_mark_start(x)	do { if (global_profiler.enabled) _profiler_mark_start(x); } while (0)
-#define profiler_mark_end()		do { if (global_profiler.enabled) _profiler_mark_end(); } while (0)
-#define profiler_start()		do { global_profiler.enabled = TRUE; global_profiler.filoindex = global_profiler.dataindex = global_profiler.dataready = 0; } while (0)
-#define profiler_stop()			do { global_profiler.enabled = FALSE; } while (0)
-#define profiler_get_text(x,s)	_profiler_get_text(x, s)
-
+typedef real_profiler_state profiler_state;
 #else
-
-#define profiler_mark_start(x)	do { } while (0)
-#define profiler_mark_end()		do { } while (0)
-#define profiler_start()		do { } while (0)
-#define profiler_stop()			do { } while (0)
-#define profiler_get_text(x,s)	(s).reset()
-
+typedef dummy_profiler_state profiler_state;
 #endif
 
 
 
-/***************************************************************************
-    FUNCTION PROTOTYPES
-***************************************************************************/
-
-
-/* ----- core functions (do not call directly; use macros) ----- */
-
-/* mark the beginning of a profiler entry */
-void _profiler_mark_start(int type);
-
-/* mark the end of a profiler entry */
-void _profiler_mark_end(void);
+//**************************************************************************
+//  GLOBAL VARIABLES
+//**************************************************************************
 
-/* return the current text in an astring */
-astring &_profiler_get_text(running_machine *machine, astring &string);
+extern profiler_state g_profiler;
 
 
 #endif	/* __PROFILER_H__ */
diff -Nru src-old/emu/schedule.c src/emu/schedule.c
--- src-old/emu/schedule.c	2010-06-27 23:40:44.000000000 -0700
+++ src/emu/schedule.c	2010-08-21 15:25:58.000000000 -0700
@@ -180,7 +180,7 @@
 					// if we're not suspended, actually execute
 					if (exec->m_suspend == 0)
 					{
-						profiler_mark_start(exec->m_profiler);
+						g_profiler.start(exec->m_profiler);
 
 						// note that this global variable cycles_stolen can be modified
 						// via the call to cpu_execute
@@ -202,7 +202,7 @@
 						ran -= *exec->m_icount;
 						assert(ran >= exec->m_cycles_stolen);
 						ran -= exec->m_cycles_stolen;
-						profiler_mark_end();
+						g_profiler.stop();
 					}
 else
 if (TEMPLOG) printf("Skipping %s for %d cycles\n", exec->device().tag(), ran);
diff -Nru src-old/emu/sound/bsmt2000.c src/emu/sound/bsmt2000.c
--- src-old/emu/sound/bsmt2000.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/bsmt2000.c	2010-08-30 08:20:58.000000000 -0700
@@ -66,6 +66,7 @@
 
 	bsmt2000_voice voice[MAX_VOICES];	/* the voices */
 	UINT16 *	regmap[128];			/* mapping of registers to voice params */
+	UINT8		mode;					/* current mode */
 
 	UINT32		clock;					/* original clock on the chip */
 	UINT8		stereo;					/* stereo output? */
@@ -109,6 +110,17 @@
 ***************************************************************************/
 
 /*-------------------------------------------------
+    bsmt2000_postload - save-state load callback
+-------------------------------------------------*/
+
+static STATE_POSTLOAD( bsmt2000_postload )
+{
+	bsmt2000_chip *chip = (bsmt2000_chip*)param;
+	set_mode(chip);
+}
+
+
+/*-------------------------------------------------
     DEVICE_START( bsmt2000 ) - initialization callback
 -------------------------------------------------*/
 
@@ -126,7 +138,9 @@
 	chip->total_banks = device->region()->bytes() / 0x10000;
 
 	/* register chip-wide data for save states */
+	state_save_register_postload(device->machine, bsmt2000_postload, chip);
 	state_save_register_device_item(device, 0, chip->last_register);
+	state_save_register_device_item(device, 0, chip->mode);
 	state_save_register_device_item(device, 0, chip->stereo);
 	state_save_register_device_item(device, 0, chip->voices);
 	state_save_register_device_item(device, 0, chip->adpcm);
@@ -168,7 +182,8 @@
 		voice->rightvol = 0x7fff;
 	}
 
-	/* recompute the mode */
+	/* recompute the mode - this comes from the address of the last register accessed */
+	chip->mode = chip->last_register;
 	set_mode(chip);
 }
 
@@ -360,8 +375,7 @@
 	/* force an update */
 	stream_update(chip->stream);
 
-	/* the mode comes from the address of the last register accessed */
-	switch (chip->last_register)
+	switch (chip->mode)
 	{
 		/* mode 0: 24kHz, 12 channel PCM, 1 channel ADPCM, mono */
 		default:
diff -Nru src-old/emu/sound/k053260.c src/emu/sound/k053260.c
--- src-old/emu/sound/k053260.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/k053260.c	2010-08-30 08:20:58.000000000 -0700
@@ -8,7 +8,7 @@
 #include "streams.h"
 #include "k053260.h"
 
-/* 2004-02-28: Fixed ppcm decoding. Games sound much better now.*/
+/* 2004-02-28: Fixed PPCM decoding. Games sound much better now.*/
 
 #define LOG 0
 
@@ -22,25 +22,26 @@
 	UINT32		start;
 	UINT32		bank;
 	UINT32		volume;
-	int					play;
+	int			play;
 	UINT32		pan;
 	UINT32		pos;
-	int					loop;
-	int					ppcm; /* packed PCM ( 4 bit signed ) */
-	int					ppcm_data;
+	int			loop;
+	int			ppcm; /* packed PCM ( 4 bit signed ) */
+	int			ppcm_data;
 };
 
 typedef struct _k053260_state k053260_state;
-struct _k053260_state {
-	sound_stream *					channel;
-	int								mode;
-	int								regs[0x30];
-	UINT8					*rom;
-	int								rom_size;
-	UINT32					*delta_table;
-	k053260_channel		channels[4];
-	const k053260_interface			*intf;
-	running_device *device;
+struct _k053260_state
+{
+	sound_stream *				channel;
+	int							mode;
+	int							regs[0x30];
+	UINT8						*rom;
+	int							rom_size;
+	UINT32						*delta_table;
+	k053260_channel				channels[4];
+	const k053260_interface		*intf;
+	running_device				*device;
 };
 
 INLINE k053260_state *get_safe_token(running_device *device)
@@ -51,7 +52,8 @@
 }
 
 
-static void InitDeltaTable( k053260_state *ic, int rate, int clock ) {
+static void InitDeltaTable( k053260_state *ic, int rate, int clock )
+{
 	int		i;
 	double	base = ( double )rate;
 	double	max = (double)(clock); /* Hz */
@@ -74,7 +76,8 @@
 	}
 }
 
-static DEVICE_RESET( k053260 ) {
+static DEVICE_RESET( k053260 )
+{
 	k053260_state *ic = get_safe_token(device);
 	int i;
 
@@ -93,7 +96,8 @@
 	}
 }
 
-INLINE int limit( int val, int max, int min ) {
+INLINE int limit( int val, int max, int min )
+{
 	if ( val > max )
 		val = max;
 	else if ( val < min )
@@ -105,7 +109,8 @@
 #define MAXOUT 0x7fff
 #define MINOUT -0x8000
 
-static STREAM_UPDATE( k053260_update ) {
+static STREAM_UPDATE( k053260_update )
+{
 	static const long dpcmcnv[] = { 0,1,2,4,8,16,32,64, -128, -64, -32, -16, -8, -4, -2, -1};
 
 	int i, j, lvol[4], rvol[4], play[4], loop[4], ppcm_data[4], ppcm[4];
@@ -233,18 +238,38 @@
 
 	InitDeltaTable( ic, rate, device->clock() );
 
+	/* register with the save state system */
+	state_save_register_device_item(device, 0, ic->mode);
+	state_save_register_device_item_array(device, 0, ic->regs);
+
+	for ( i = 0; i < 4; i++ )
+	{
+		state_save_register_device_item(device, i, ic->channels[i].rate);
+		state_save_register_device_item(device, i, ic->channels[i].size);
+		state_save_register_device_item(device, i, ic->channels[i].start);
+		state_save_register_device_item(device, i, ic->channels[i].bank);
+		state_save_register_device_item(device, i, ic->channels[i].volume);
+		state_save_register_device_item(device, i, ic->channels[i].play);
+		state_save_register_device_item(device, i, ic->channels[i].pan);
+		state_save_register_device_item(device, i, ic->channels[i].pos);
+		state_save_register_device_item(device, i, ic->channels[i].loop);
+		state_save_register_device_item(device, i, ic->channels[i].ppcm);
+		state_save_register_device_item(device, i, ic->channels[i].ppcm_data);
+	}
+
 	/* setup SH1 timer if necessary */
 	if ( ic->intf->irq )
 		timer_pulse( device->machine, attotime_mul(ATTOTIME_IN_HZ(device->clock()), 32), NULL, 0, ic->intf->irq );
 }
 
-INLINE void check_bounds( k053260_state *ic, int channel ) {
+INLINE void check_bounds( k053260_state *ic, int channel )
+{
 
 	int channel_start = ( ic->channels[channel].bank << 16 ) + ic->channels[channel].start;
 	int channel_end = channel_start + ic->channels[channel].size - 1;
 
 	if ( channel_start > ic->rom_size ) {
-		logerror("K53260: Attempting to start playing past the end of the rom ( start = %06x, end = %06x ).\n", channel_start, channel_end );
+		logerror("K53260: Attempting to start playing past the end of the ROM ( start = %06x, end = %06x ).\n", channel_start, channel_end );
 
 		ic->channels[channel].play = 0;
 
@@ -252,7 +277,7 @@
 	}
 
 	if ( channel_end > ic->rom_size ) {
-		logerror("K53260: Attempting to play past the end of the rom ( start = %06x, end = %06x ).\n", channel_start, channel_end );
+		logerror("K53260: Attempting to play past the end of the ROM ( start = %06x, end = %06x ).\n", channel_start, channel_end );
 
 		ic->channels[channel].size = ic->rom_size - channel_start;
 	}
@@ -392,7 +417,7 @@
 			}
 		break;
 
-		case 0x2e: /* read rom */
+		case 0x2e: /* read ROM */
 			if ( ic->mode & 1 )
 			{
 				UINT32 offs = ic->channels[0].start + ( ic->channels[0].pos >> BASE_SHIFT ) + ( ic->channels[0].bank << 16 );
@@ -400,7 +425,7 @@
 				ic->channels[0].pos += ( 1 << 16 );
 
 				if ( offs > ic->rom_size ) {
-					logerror("%s: K53260: Attempting to read past rom size in rom Read Mode (offs = %06x, size = %06x).\n", cpuexec_describe_context(device->machine),offs,ic->rom_size );
+					logerror("%s: K53260: Attempting to read past ROM size in ROM Read Mode (offs = %06x, size = %06x).\n", cpuexec_describe_context(device->machine),offs,ic->rom_size );
 
 					return 0;
 				}
@@ -427,14 +452,14 @@
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME( k053260 );		break;
 		case DEVINFO_FCT_STOP:							/* nothing */									break;
-		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME( k053260);		break;
+		case DEVINFO_FCT_RESET:							info->reset = DEVICE_RESET_NAME( k053260 );		break;
 
 		/* --- the following bits of info are returned as NULL-terminated strings --- */
 		case DEVINFO_STR_NAME:							strcpy(info->s, "K053260");						break;
-		case DEVINFO_STR_FAMILY:					strcpy(info->s, "Konami custom");				break;
-		case DEVINFO_STR_VERSION:					strcpy(info->s, "1.0");							break;
-		case DEVINFO_STR_SOURCE_FILE:						strcpy(info->s, __FILE__);						break;
-		case DEVINFO_STR_CREDITS:					strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
+		case DEVINFO_STR_FAMILY:						strcpy(info->s, "Konami custom");				break;
+		case DEVINFO_STR_VERSION:						strcpy(info->s, "1.0");							break;
+		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);						break;
+		case DEVINFO_STR_CREDITS:						strcpy(info->s, "Copyright Nicola Salmoria and the MAME Team"); break;
 	}
 }
 
diff -Nru src-old/emu/sound/msm5232.c src/emu/sound/msm5232.c
--- src-old/emu/sound/msm5232.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/msm5232.c	2010-08-15 13:53:48.000000000 -0700
@@ -33,7 +33,7 @@
 	double	dr_rate;
 	double	rr_rate;
 
-	int	pitch;			/* current pitch data */
+	int		pitch;			/* current pitch data */
 
 	int GF;
 } VOICE;
@@ -60,8 +60,8 @@
 	double	ar_tbl[8];
 	double	dr_tbl[16];
 
-	UINT8   control1;
-	UINT8   control2;
+	UINT8	control1;
+	UINT8	control2;
 
 	int		gate;		/* current state of the GATE output */
 
@@ -780,18 +780,62 @@
 
 
 /* MAME Interface */
+static STATE_POSTLOAD( msm5232_postload )
+{
+	MSM5232 *chip = (MSM5232 *)param;
+	msm5232_init_tables(chip);
+}
 
 static DEVICE_START( msm5232 )
 {
 	const msm5232_interface *intf = (const msm5232_interface *)device->baseconfig().static_config();
 	int rate = device->clock()/CLOCK_RATE_DIVIDER;
 	MSM5232 *chip = get_safe_token(device);
+	int voicenum;
 
 	chip->device = device;
 
 	msm5232_init(chip, intf, device->clock(), rate);
 
-	chip->stream = stream_create(device,0,11,rate,chip,MSM5232_update_one);
+	chip->stream = stream_create(device, 0, 11, rate, chip, MSM5232_update_one);
+
+	/* register with the save state system */
+	state_save_register_postload(device->machine, msm5232_postload, chip);
+	state_save_register_device_item_array(device, 0, chip->EN_out16);
+	state_save_register_device_item_array(device, 0, chip->EN_out8);
+	state_save_register_device_item_array(device, 0, chip->EN_out4);
+	state_save_register_device_item_array(device, 0, chip->EN_out2);
+	state_save_register_device_item(device, 0, chip->noise_cnt);
+	state_save_register_device_item(device, 0, chip->noise_rng);
+	state_save_register_device_item(device, 0, chip->noise_clocks);
+	state_save_register_device_item(device, 0, chip->control1);
+	state_save_register_device_item(device, 0, chip->control2);
+	state_save_register_device_item(device, 0, chip->gate);
+	state_save_register_device_item(device, 0, chip->clock);
+	state_save_register_device_item(device, 0, chip->rate);
+
+	/* register voice-specific data for save states */
+	for (voicenum = 0; voicenum < 8; voicenum++)
+	{
+		VOICE *voice = &chip->voi[voicenum];
+
+		state_save_register_device_item(device, voicenum, voice->mode);
+		state_save_register_device_item(device, voicenum, voice->TG_count_period);
+		state_save_register_device_item(device, voicenum, voice->TG_cnt);
+		state_save_register_device_item(device, voicenum, voice->TG_out16);
+		state_save_register_device_item(device, voicenum, voice->TG_out8);
+		state_save_register_device_item(device, voicenum, voice->TG_out4);
+		state_save_register_device_item(device, voicenum, voice->TG_out2);
+		state_save_register_device_item(device, voicenum, voice->egvol);
+		state_save_register_device_item(device, voicenum, voice->eg_sect);
+		state_save_register_device_item(device, voicenum, voice->counter);
+		state_save_register_device_item(device, voicenum, voice->eg);
+		state_save_register_device_item(device, voicenum, voice->eg_arm);
+		state_save_register_device_item(device, voicenum, voice->ar_rate);
+		state_save_register_device_item(device, voicenum, voice->dr_rate);
+		state_save_register_device_item(device, voicenum, voice->pitch);
+		state_save_register_device_item(device, voicenum, voice->GF);
+	}
 }
 
 void msm5232_set_clock(running_device *device, int clock)
diff -Nru src-old/emu/sound/namco.c src/emu/sound/namco.c
--- src-old/emu/sound/namco.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/sound/namco.c	2010-08-21 13:51:47.000000000 -0700
@@ -397,6 +397,11 @@
 	chip->sound_enable = 1;
 
 	/* register with the save state system */
+	state_save_register_device_item_pointer(device, 0, chip->soundregs, 0x400);
+
+	if (device->region() == NULL)
+		state_save_register_device_item_pointer(device, 0, chip->wavedata, 0x400);
+
 	state_save_register_device_item(device, 0, chip->num_voices);
 	state_save_register_device_item(device, 0, chip->sound_enable);
 	state_save_register_device_item_pointer(device, 0, chip->waveform[0],
diff -Nru src-old/emu/sound/nes_apu.c src/emu/sound/nes_apu.c
--- src-old/emu/sound/nes_apu.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/nes_apu.c	2010-08-19 01:27:05.000000000 -0700
@@ -384,7 +384,7 @@
 			bit_pos = 7 - (chan->bits_left & 7);
 			if (7 == bit_pos)
 			{
-				chan->cur_byte = memory_read_byte(info->APU.dpcm.memory, chan->address);
+				chan->cur_byte = info->APU.dpcm.memory->read_byte(chan->address);
 				chan->address++;
 				chan->length--;
 			}
diff -Nru src-old/emu/sound/nes_defs.h src/emu/sound/nes_defs.h
--- src-old/emu/sound/nes_defs.h	2009-08-06 03:58:38.000000000 -0700
+++ src/emu/sound/nes_defs.h	2010-08-19 00:26:14.000000000 -0700
@@ -137,7 +137,7 @@
 	uint8 cur_byte;
 	boolean enabled;
 	boolean irq_occurred;
-	const address_space *memory;
+	address_space *memory;
 	signed char vol;
 } dpcm_t;
 
diff -Nru src-old/emu/sound/okim6295.c src/emu/sound/okim6295.c
--- src-old/emu/sound/okim6295.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/sound/okim6295.c	2010-08-26 08:21:19.000000000 -0700
@@ -118,15 +118,14 @@
 
 
 //-------------------------------------------------
-//  device_config_complete - perform any
-//  operations now that the configuration is
-//  complete
+//  static_set_pin7 - configuration helper to set
+//  the pin 7 state
 //-------------------------------------------------
 
-void okim6295_device_config::device_config_complete()
+void okim6295_device_config::static_set_pin7(device_config *device, int pin7)
 {
-	// copy the pin7 state from inline data
-	m_pin7 = m_inline_data[INLINE_PIN7];
+	okim6295_device_config *okim6295 = downcast<okim6295_device_config *>(device);
+	okim6295->m_pin7 = pin7;
 }
 
 
@@ -159,7 +158,8 @@
 	  m_bank_installed(false),
 	  m_bank_offs(0),
 	  m_stream(NULL),
-	  m_pin7_state(m_config.m_pin7)
+	  m_pin7_state(m_config.m_pin7),
+	  m_direct(NULL)
 {
 }
 
@@ -170,6 +170,9 @@
 
 void okim6295_device::device_start()
 {
+	// find our direct access
+	m_direct = &space()->direct();
+
 	// create the stream
 	int divisor = m_config.m_pin7 ? 132 : 165;
 	m_stream = stream_create(this, 0, 1, clock() / divisor, this, static_stream_generate);
@@ -240,7 +243,7 @@
 
 	// iterate over voices and accumulate sample data
 	for (int voicenum = 0; voicenum < OKIM6295_VOICES; voicenum++)
-		m_voice[voicenum].generate_adpcm(space(), outputs[0], samples);
+		m_voice[voicenum].generate_adpcm(*m_direct, outputs[0], samples);
 }
 
 
@@ -289,10 +292,10 @@
 
 READ8_DEVICE_HANDLER( okim6295_r )
 {
-	return downcast<okim6295_device *>(device)->status_read();
+	return downcast<okim6295_device *>(device)->read(*device->machine->m_nonspecific_space, offset);
 }
 
-UINT8 okim6295_device::status_read()
+READ8_MEMBER( okim6295_device::read )
 {
 	UINT8 result = 0xf0;	// naname expects bits 4-7 to be 1
 
@@ -312,10 +315,10 @@
 
 WRITE8_DEVICE_HANDLER( okim6295_w )
 {
-	downcast<okim6295_device *>(device)->data_write(data);
+	downcast<okim6295_device *>(device)->write(*device->machine->m_nonspecific_space, offset, data);
 }
 
-void okim6295_device::data_write(UINT8 data)
+WRITE8_MEMBER( okim6295_device::write )
 {
 	// if a command is pending, process the second half
 	if (m_command != -1)
@@ -337,14 +340,14 @@
 				// determine the start/stop positions
 				offs_t base = m_command * 8;
 
-				offs_t start = memory_raw_read_byte(space(), base + 0) << 16;
-				start |= memory_raw_read_byte(space(), base + 1) << 8;
-				start |= memory_raw_read_byte(space(), base + 2) << 0;
+				offs_t start = m_direct->read_raw_byte(base + 0) << 16;
+				start |= m_direct->read_raw_byte(base + 1) << 8;
+				start |= m_direct->read_raw_byte(base + 2) << 0;
 				start &= 0x3ffff;
 
-				offs_t stop = memory_raw_read_byte(space(), base + 3) << 16;
-				stop |= memory_raw_read_byte(space(), base + 4) << 8;
-				stop |= memory_raw_read_byte(space(), base + 5) << 0;
+				offs_t stop = m_direct->read_raw_byte(base + 3) << 16;
+				stop |= m_direct->read_raw_byte(base + 4) << 8;
+				stop |= m_direct->read_raw_byte(base + 5) << 0;
 				stop &= 0x3ffff;
 
 				// set up the voice to play this sample
@@ -420,7 +423,7 @@
 //  add them to an output stream
 //-------------------------------------------------
 
-void okim6295_device::okim_voice::generate_adpcm(const address_space *space, stream_sample_t *buffer, int samples)
+void okim6295_device::okim_voice::generate_adpcm(direct_read_data &direct, stream_sample_t *buffer, int samples)
 {
 	// skip if not active
 	if (!m_playing)
@@ -430,7 +433,7 @@
 	while (samples-- != 0)
 	{
 		// fetch the next sample byte
-		int nibble = memory_raw_read_byte(space, m_base_offset + m_sample / 2) >> (((m_sample & 1) << 2) ^ 4);
+		int nibble = direct.read_raw_byte(m_base_offset + m_sample / 2) >> (((m_sample & 1) << 2) ^ 4);
 
 		// output to the buffer, scaling by the volume
 		// signal in range -2048..2047, volume in range 2..32 => signal * volume / 2 in range -32768..32767
diff -Nru src-old/emu/sound/okim6295.h src/emu/sound/okim6295.h
--- src-old/emu/sound/okim6295.h	2010-06-29 02:02:17.000000000 -0700
+++ src/emu/sound/okim6295.h	2010-08-26 08:21:19.000000000 -0700
@@ -40,7 +40,7 @@
 	MDRV_OKIM6295_PIN7(_pin7)
 
 #define MDRV_OKIM6295_PIN7(_pin7) \
-	MDRV_DEVICE_INLINE_DATA16(okim6295_device_config::INLINE_PIN7, _pin7)
+	okim6295_device_config::static_set_pin7(device, _pin7); \
 
 
 
@@ -89,19 +89,17 @@
 	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 	virtual device_t *alloc_device(running_machine &machine) const;
 
-	// inline configuration indexes
-	enum
-	{
-		INLINE_PIN7
-	};
+	// inline configuration helpers
+	static void static_set_pin7(device_config *device, int pin7);
 
 protected:
 	// device_config overrides
-	virtual void device_config_complete();
 	virtual const address_space_config *memory_space_config(int spacenum = 0) const;
 
 	// internal state
 	const address_space_config  m_space_config;
+
+	// inline data
 	UINT8						m_pin7;
 };
 
@@ -122,8 +120,8 @@
 	void set_bank_base(offs_t base);
 	void set_pin7(int pin7);
 
-	UINT8 status_read();
-	void data_write(UINT8 data);
+	DECLARE_READ8_MEMBER( read );
+	DECLARE_WRITE8_MEMBER( write );
 
 protected:
 	// device-level overrides
@@ -141,7 +139,7 @@
 	{
 	public:
 		okim_voice();
-		void generate_adpcm(const address_space *space, stream_sample_t *buffer, int samples);
+		void generate_adpcm(direct_read_data &direct, stream_sample_t *buffer, int samples);
 
 		adpcm_state m_adpcm;			// current ADPCM state
 		bool		m_playing;
@@ -156,12 +154,13 @@
 
 	const okim6295_device_config &m_config;
 
-	okim_voice		m_voice[OKIM6295_VOICES];
-	INT32			m_command;
-	bool			m_bank_installed;
-	offs_t			m_bank_offs;
-	sound_stream *	m_stream;
-	UINT8			m_pin7_state;
+	okim_voice			m_voice[OKIM6295_VOICES];
+	INT32				m_command;
+	bool				m_bank_installed;
+	offs_t				m_bank_offs;
+	sound_stream *		m_stream;
+	UINT8				m_pin7_state;
+	direct_read_data *	m_direct;
 
 	static const UINT8 s_volume_table[16];
 };
diff -Nru src-old/emu/sound/s2636.c src/emu/sound/s2636.c
--- src-old/emu/sound/s2636.c	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/sound/s2636.c	2010-08-12 12:45:01.000000000 -0700
@@ -0,0 +1,103 @@
+/***************************************************************************
+
+  PeT mess@utanet.at
+
+***************************************************************************/
+
+#include "emu.h"
+#include "streams.h"
+#include "sound/s2636.h"
+
+
+typedef struct _s2636_sound s2636_sound;
+struct _s2636_sound
+{
+    sound_stream *channel;
+    UINT8 reg[1];
+    int size, pos;
+    unsigned level;
+};
+
+
+static s2636_sound *get_token(running_device *device)
+{
+	assert(device != NULL);
+	assert(device->type() == SOUND_S2636);
+	return (s2636_sound *) downcast<legacy_device_base *>(device)->token();
+}
+
+
+void s2636_soundport_w (running_device *device, int offset, int data)
+{
+	s2636_sound *token = get_token(device);
+
+	stream_update(token->channel);
+	token->reg[offset] = data;
+	switch (offset)
+	{
+		case 0:
+			token->pos = 0;
+			token->level = TRUE;
+			// frequency 7874/(data+1)
+			token->size = device->machine->sample_rate * (data + 1) /7874;
+			break;
+	}
+}
+
+
+
+/************************************/
+/* Sound handler update             */
+/************************************/
+
+static STREAM_UPDATE( s2636_update )
+{
+	int i;
+	s2636_sound *token = get_token(device);
+	stream_sample_t *buffer = outputs[0];
+
+	for (i = 0; i < samples; i++, buffer++)
+	{
+		*buffer = 0;
+		if (token->reg[0] && token->pos <= token->size / 2)
+		{
+			*buffer = 0x7fff;
+		}
+		if (token->pos <= token->size)
+			token->pos++;
+		if (token->pos > token->size)
+			token->pos = 0;
+	}
+}
+
+
+
+/************************************/
+/* Sound handler start              */
+/************************************/
+
+static DEVICE_START(s2636_sound)
+{
+	s2636_sound *token = get_token(device);
+	memset(token, 0, sizeof(*token));
+    token->channel = stream_create(device, 0, 1, device->machine->sample_rate, 0, s2636_update);
+}
+
+
+DEVICE_GET_INFO( s2636_sound )
+{
+	switch (state)
+	{
+		/* --- the following bits of info are returned as 64-bit signed integers --- */
+		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(s2636_sound);			break;
+
+		/* --- the following bits of info are returned as pointers to data or functions --- */
+		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(s2636_sound);	break;
+
+		/* --- the following bits of info are returned as NULL-terminated strings --- */
+		case DEVINFO_STR_NAME:							strcpy(info->s, "S2636");				break;
+		case DEVINFO_STR_SOURCE_FILE:					strcpy(info->s, __FILE__);						break;
+	}
+}
+
+DEFINE_LEGACY_SOUND_DEVICE(S2636, s2636_sound);
diff -Nru src-old/emu/sound/s2636.h src/emu/sound/s2636.h
--- src-old/emu/sound/s2636.h	1969-12-31 16:00:00.000000000 -0800
+++ src/emu/sound/s2636.h	2010-08-12 12:45:01.000000000 -0700
@@ -0,0 +1,16 @@
+/*****************************************************************************
+ *
+ * sound/s2636.h
+ *
+ ****************************************************************************/
+
+#ifndef S2636_SOUND_H_
+#define S2636_SOUND_H_
+
+
+
+DECLARE_LEGACY_SOUND_DEVICE(S2636, s2636_sound);
+void s2636_soundport_w (running_device *device, int mode, int data);
+
+
+#endif /* VC4000_H_ */
diff -Nru src-old/emu/sound/scsp.c src/emu/sound/scsp.c
--- src-old/emu/sound/scsp.c	2010-07-02 17:12:44.000000000 -0700
+++ src/emu/sound/scsp.c	2010-08-19 01:27:05.000000000 -0700
@@ -227,7 +227,7 @@
 	running_device *device;
 };
 
-static void dma_scsp(const address_space *space, struct _SCSP *SCSP);		/*SCSP DMA transfer function*/
+static void dma_scsp(address_space *space, struct _SCSP *SCSP);		/*SCSP DMA transfer function*/
 #define	scsp_dgate		scsp_regs[0x16/2] & 0x4000
 #define	scsp_ddir		scsp_regs[0x16/2] & 0x2000
 #define scsp_dexe		scsp_regs[0x16/2] & 0x1000
@@ -698,7 +698,7 @@
 static void SCSP_UpdateReg(struct _SCSP *SCSP, int reg)
 {
 	/* temporary hack until this is converted to a device */
-	const address_space *space = device_get_space(SCSP->device->machine->firstcpu, AS_PROGRAM);
+	address_space *space = device_get_space(SCSP->device->machine->firstcpu, AS_PROGRAM);
 	switch(reg&0x3f)
 	{
 		case 0x2:
@@ -1168,7 +1168,7 @@
 	}
 }
 
-static void dma_scsp(const address_space *space, struct _SCSP *SCSP)
+static void dma_scsp(address_space *space, struct _SCSP *SCSP)
 {
 	static UINT16 tmp_dma[3], *scsp_regs;
 
@@ -1191,7 +1191,7 @@
 	{
 		for(;SCSP->scsp_dtlg > 0;SCSP->scsp_dtlg-=2)
 		{
-			memory_write_word(space,SCSP->scsp_dmea, memory_read_word(space,0x100000|SCSP->scsp_drga));
+			space->write_word(SCSP->scsp_dmea, space->read_word(0x100000|SCSP->scsp_drga));
 			SCSP->scsp_dmea+=2;
 			SCSP->scsp_drga+=2;
 		}
@@ -1200,7 +1200,7 @@
 	{
 		for(;SCSP->scsp_dtlg > 0;SCSP->scsp_dtlg-=2)
 		{
-			memory_write_word(space,0x100000|SCSP->scsp_drga,memory_read_word(space,SCSP->scsp_dmea));
+			space->write_word(0x100000|SCSP->scsp_drga,space->read_word(SCSP->scsp_dmea));
 			SCSP->scsp_dmea+=2;
 			SCSP->scsp_drga+=2;
 		}
diff -Nru src-old/emu/sound/sound.mak src/emu/sound/sound.mak
--- src-old/emu/sound/sound.mak	2010-07-15 04:15:35.000000000 -0700
+++ src/emu/sound/sound.mak	2010-08-12 12:45:01.000000000 -0700
@@ -392,6 +392,13 @@
 endif
 
 
+#-------------------------------------------------
+# S2636 wave generator
+#-------------------------------------------------
+
+ifneq ($(filter S2636,$(SOUNDS)),)
+SOUNDOBJS += $(SOUNDOBJ)/s2636.o
+endif
 
 #-------------------------------------------------
 # Sega custom sound chips
diff -Nru src-old/emu/sound/vlm5030.c src/emu/sound/vlm5030.c
--- src-old/emu/sound/vlm5030.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/vlm5030.c	2010-08-16 14:59:46.000000000 -0700
@@ -1,11 +1,45 @@
 /*
     vlm5030.c
 
-    VLM5030 emulator
+    Sanyo VLM5030 emulator
 
     Written by Tatsuyuki Satoh
     Based on TMS5220 simulator (tms5220.c)
 
+                 +-------,_,-------+
+        GND   -- |  1           40 | <-    RST
+  (gnd) TST1  -> |  2           39 | ??    TST4
+        OSC2  ck |  3     _     38 | ??    TST3
+        OSC1  ck |  4    (_)    37 | ??    TST2
+        D0    -> |  5           36 | ->    DAO
+        D1    -> |  6           35 | --    VREF (+5v thru 5.6k resistor)
+        D2    -> |  7           34 | ->    MTE
+        D3    -> |  8      V    33 | ->    /ME
+        D4    -> |  9      L    32 | <-    VCU
+        D5    -> | 10      M    31 | <-    START
+        D6    -> | 11      5    30 | ->    BSY
+        D7    -> | 12      0    29 | --    Vdd (+5v)
+        A0    <- | 13      3    28 | ->    A15
+        A1    <- | 14      0    27 | ->    A14
+        A2    <- | 15           26 | ->    A13
+        A3    <- | 16     _     25 | ->    A12
+        A4    <- | 17    (_)    24 | ->    A11
+        A5    <- | 18           23 | ->    A10
+        A6    <- | 19           22 | ->    A9
+        A7    <- | 20           21 | ->    A8
+                 +-----------------+
+
+TST1 is probably a test mode enable pin, must be grounded for normal operation.
+TST2-4 are some sort of test pins but can be left floating?
+VREF is probably the 0v ref for the output dac
+DAO is the output dac
+/ME is connected to the voice data rom /OE enable
+START strobes in a byte of data over the data bus from host cpu
+OSC1/2 are to both ends of a 3.579545MHz xtal with a 100pf cap from each end to gnd
+VCU makes the data bus select the upper 8 bits of the word register internally instead of the lower 8 bits. it is only useful if you need more than 256 phrases in rom? (recheck this)
+MTE is an output for roms which need to be clocked to latch address before use, or for a latch sitting in front of the voice rom address lines? (recheck this)
+RST not only resets the chip on its rising edge but grabs a byte of mode state data from the data bus on its falling edge? (recheck this)
+
   note:
     memory read cycle(==sampling rate) = 122.9u(440clock)
     interpolator (LC8109 = 2.5ms)      = 20 * samples(125us)
diff -Nru src-old/emu/sound/vrender0.c src/emu/sound/vrender0.c
--- src-old/emu/sound/vrender0.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/vrender0.c	2010-08-19 01:27:05.000000000 -0700
@@ -85,8 +85,8 @@
 #define ENVVOL(chan)	(VR0->SOUNDREGS[(0x20/4)*chan+0x04/4]&0xffffff)
 
 /*
-#define GETSOUNDREG16(Chan,Offs) memory_read_word_32le(space,VR0->Intf.reg_base+0x20*Chan+Offs)
-#define GETSOUNDREG32(Chan,Offs) memory_read_dword_32le(space,VR0->Intf.reg_base+0x20*Chan+Offs)
+#define GETSOUNDREG16(Chan,Offs) space->read_word(VR0->Intf.reg_base+0x20*Chan+Offs)
+#define GETSOUNDREG32(Chan,Offs) space->read_dword(VR0->Intf.reg_base+0x20*Chan+Offs)
 
 #define CURSADDR(chan)  GETSOUNDREG32(chan,0x00)
 #define DSADDR(chan)    GETSOUNDREG16(chan,0x08)
diff -Nru src-old/emu/sound/ymf278b.c src/emu/sound/ymf278b.c
--- src-old/emu/sound/ymf278b.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/sound/ymf278b.c	2010-08-18 15:00:49.000000000 -0700
@@ -676,6 +676,64 @@
 	mix = auto_alloc_array(device->machine, INT32, 44100*2);
 }
 
+static void ymf278b_register_save_state(running_device *device, YMF278BChip *chip)
+{
+	int i;
+
+	state_save_register_device_item(device, 0, chip->lsitest0);
+	state_save_register_device_item(device, 0, chip->lsitest1);
+	state_save_register_device_item(device, 0, chip->wavetblhdr);
+	state_save_register_device_item(device, 0, chip->memmode);
+	state_save_register_device_item(device, 0, chip->memadr);
+	state_save_register_device_item(device, 0, chip->fm_l);
+	state_save_register_device_item(device, 0, chip->fm_r);
+	state_save_register_device_item(device, 0, chip->pcm_l);
+	state_save_register_device_item(device, 0, chip->pcm_r);
+	state_save_register_device_item(device, 0, chip->timer_a_count);
+	state_save_register_device_item(device, 0, chip->timer_b_count);
+	state_save_register_device_item(device, 0, chip->enable);
+	state_save_register_device_item(device, 0, chip->current_irq);
+	state_save_register_device_item(device, 0, chip->irq_line);
+	state_save_register_device_item(device, 0, chip->port_A);
+	state_save_register_device_item(device, 0, chip->port_B);
+	state_save_register_device_item(device, 0, chip->port_C);
+
+	for (i = 0; i < 24; ++i)
+	{
+		state_save_register_device_item(device, i, chip->slots[i].wave);
+		state_save_register_device_item(device, i, chip->slots[i].FN);
+		state_save_register_device_item(device, i, chip->slots[i].OCT);
+		state_save_register_device_item(device, i, chip->slots[i].PRVB);
+		state_save_register_device_item(device, i, chip->slots[i].LD);
+		state_save_register_device_item(device, i, chip->slots[i].TL);
+		state_save_register_device_item(device, i, chip->slots[i].pan);
+		state_save_register_device_item(device, i, chip->slots[i].lfo);
+		state_save_register_device_item(device, i, chip->slots[i].vib);
+		state_save_register_device_item(device, i, chip->slots[i].AM);
+
+		state_save_register_device_item(device, i, chip->slots[i].AR);
+		state_save_register_device_item(device, i, chip->slots[i].D1R);
+		state_save_register_device_item(device, i, chip->slots[i].DL);
+		state_save_register_device_item(device, i, chip->slots[i].D2R);
+		state_save_register_device_item(device, i, chip->slots[i].RC);
+		state_save_register_device_item(device, i, chip->slots[i].RR);
+
+		state_save_register_device_item(device, i, chip->slots[i].step);
+		state_save_register_device_item(device, i, chip->slots[i].stepptr);
+
+		state_save_register_device_item(device, i, chip->slots[i].active);
+		state_save_register_device_item(device, i, chip->slots[i].bits);
+		state_save_register_device_item(device, i, chip->slots[i].startaddr);
+		state_save_register_device_item(device, i, chip->slots[i].loopaddr);
+		state_save_register_device_item(device, i, chip->slots[i].endaddr);
+
+		state_save_register_device_item(device, i, chip->slots[i].env_step);
+		state_save_register_device_item(device, i, chip->slots[i].env_vol);
+		state_save_register_device_item(device, i, chip->slots[i].env_vol_step);
+		state_save_register_device_item(device, i, chip->slots[i].env_vol_lim);
+	}
+}
+
 static DEVICE_START( ymf278b )
 {
 	static const ymf278b_interface defintrf = { 0 };
@@ -706,9 +764,10 @@
 	for(i=0; i<7; i++)
 		chip->mix_level[i] = chip->volume[8*i+8];
 	chip->mix_level[7] = 0;
-}
-
 
+	// Register state for saving
+	ymf278b_register_save_state(device, chip);
+}
 
 
 /**************************************************************************
diff -Nru src-old/emu/sound.c src/emu/sound.c
--- src-old/emu/sound.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/sound.c	2010-08-30 08:20:58.000000000 -0700
@@ -404,7 +404,7 @@
 
 	VPRINTF(("sound_update\n"));
 
-	profiler_mark_start(PROFILER_SOUND);
+	g_profiler.start(PROFILER_SOUND);
 
 	leftmix = global->leftmix;
 	rightmix = global->rightmix;
@@ -452,7 +452,7 @@
 	/* update the streamer */
 	streams_update(machine);
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -496,17 +496,16 @@
 
 
 //-------------------------------------------------
-//  device_config_complete - perform any
-//  operations now that the configuration is
-//  complete
+//  static_set_position - configuration helper to
+//  set the speaker position
 //-------------------------------------------------
 
-void speaker_device_config::device_config_complete()
+void speaker_device_config::static_set_position(device_config *device, double x, double y, double z)
 {
-	// move inline data into its final home
-	m_x = static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_X])) / (double)(1 << 24);
-	m_y = static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_Y])) / (double)(1 << 24);
-	m_z = static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_Z])) / (double)(1 << 24);
+	speaker_device_config *speaker = downcast<speaker_device_config *>(device);
+	speaker->m_x = x;
+	speaker->m_y = y;
+	speaker->m_z = z;
 }
 
 
diff -Nru src-old/emu/sound.h src/emu/sound.h
--- src-old/emu/sound.h	2010-07-05 05:18:11.000000000 -0700
+++ src/emu/sound.h	2010-08-26 08:21:19.000000000 -0700
@@ -49,19 +49,11 @@
 	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 	virtual device_t *alloc_device(running_machine &machine) const;
 
-	// indexes to inline data
-	enum
-	{
-		INLINE_X,
-		INLINE_Y,
-		INLINE_Z
-	};
+	// inline configuration helpers
+	static void static_set_position(device_config *device, double x, double y, double z);
 
 protected:
-	// device_config overrides
-	virtual void device_config_complete();
-
-	// internal state
+	// inline configuration state
 	double		m_x;
 	double		m_y;
 	double		m_z;
@@ -133,9 +125,7 @@
 /* add/remove speakers */
 #define MDRV_SPEAKER_ADD(_tag, _x, _y, _z) \
 	MDRV_DEVICE_ADD(_tag, SPEAKER, 0) \
-	MDRV_DEVICE_INLINE_DATA32(speaker_device_config::INLINE_X, (INT32)((_x) * (double)(1 << 24))) \
-	MDRV_DEVICE_INLINE_DATA32(speaker_device_config::INLINE_Y, (INT32)((_y) * (double)(1 << 24))) \
-	MDRV_DEVICE_INLINE_DATA32(speaker_device_config::INLINE_Z, (INT32)((_z) * (double)(1 << 24)))
+	speaker_device_config::static_set_position(device, _x, _y, _z); \
 
 #define MDRV_SPEAKER_STANDARD_MONO(_tag) \
 	MDRV_SPEAKER_ADD(_tag, 0.0, 0.0, 1.0)
diff -Nru src-old/emu/state.c src/emu/state.c
--- src-old/emu/state.c	2010-02-18 11:33:18.000000000 -0800
+++ src/emu/state.c	2010-08-23 11:22:05.000000000 -0700
@@ -169,18 +169,18 @@
 
 void state_init(running_machine *machine)
 {
-	bool test_bool;
-	INT8 test_INT8;
-	UINT8 test_UINT8;
-	INT16 test_INT16;
-	UINT16 test_UINT16;
-	INT32 test_INT32;
-	UINT32 test_UINT32;
-	INT64 test_INT64;
-	UINT64 test_UINT64;
-	float test_float;
-	double test_double;
-	test_enum_type test_enum;
+	bool test_bool = false;
+	INT8 test_INT8 = 0;
+	UINT8 test_UINT8 = 0;
+	INT16 test_INT16 = 0;
+	UINT16 test_UINT16 = 0;
+	INT32 test_INT32 = 0;
+	UINT32 test_UINT32 = 0;
+	INT64 test_INT64 = 0;
+	UINT64 test_UINT64 = 0;
+	float test_float = 0.0f;
+	double test_double = 0.0;
+	test_enum_type test_enum = test_val;
 #ifdef __GNUC__
 	test_class_type test_class;
 #endif
diff -Nru src-old/emu/streams.c src/emu/streams.c
--- src-old/emu/streams.c	2010-08-11 19:46:57.000000000 -0700
+++ src/emu/streams.c	2010-08-21 15:25:58.000000000 -0700
@@ -508,11 +508,11 @@
 	INT32 update_sampindex = time_to_sampindex(strdata, stream, timer_get_time(machine));
 
 	/* generate samples to get us up to the appropriate time */
-	profiler_mark_start(PROFILER_SOUND);
+	g_profiler.start(PROFILER_SOUND);
 	assert(stream->output_sampindex - stream->output_base_sampindex >= 0);
 	assert(update_sampindex - stream->output_base_sampindex <= stream->output_bufalloc);
 	generate_samples(stream, update_sampindex - stream->output_sampindex);
-	profiler_mark_end();
+	g_profiler.stop();
 
 	/* remember this info for next time */
 	stream->output_sampindex = update_sampindex;
diff -Nru src-old/emu/tilemap.c src/emu/tilemap.c
--- src-old/emu/tilemap.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/tilemap.c	2010-08-21 15:25:58.000000000 -0700
@@ -824,7 +824,7 @@
 	if (!tmap->enable)
 		return;
 
-profiler_mark_start(PROFILER_TILEMAP_DRAW);
+g_profiler.start(PROFILER_TILEMAP_DRAW);
 	/* configure the blit parameters based on the input parameters */
 	configure_blit_parameters(&blit, tmap, dest, cliprect, flags, priority, priority_mask);
 
@@ -927,7 +927,7 @@
 			}
 		}
 	}
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -962,7 +962,7 @@
 		return;
 	}
 
-profiler_mark_start(PROFILER_TILEMAP_DRAW_ROZ);
+g_profiler.start(PROFILER_TILEMAP_DRAW_ROZ);
 	/* configure the blit parameters */
 	configure_blit_parameters(&blit, tmap, dest, cliprect, flags, priority, priority_mask);
 
@@ -971,7 +971,7 @@
 
 	/* then do the roz copy */
 	tilemap_draw_roz_core(tmap, &blit, startx, starty, incxx, incxy, incyx, incyy, wraparound);
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -1274,7 +1274,7 @@
 	if (tmap->all_tiles_clean)
 		return;
 
-profiler_mark_start(PROFILER_TILEMAP_DRAW);
+g_profiler.start(PROFILER_TILEMAP_DRAW);
 
 	/* compute which columns and rows to update */
 	if (cliprect != NULL)
@@ -1314,7 +1314,7 @@
 	if (mincol == 0 && minrow == 0 && maxcol == tmap->cols - 1 && maxcol == tmap->rows - 1)
 		tmap->all_tiles_clean = TRUE;
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -1329,7 +1329,7 @@
 	tilemap_memory_index memindex;
 	UINT32 flags;
 
-profiler_mark_start(PROFILER_TILEMAP_UPDATE);
+g_profiler.start(PROFILER_TILEMAP_UPDATE);
 
 	/* call the get info callback for the associated memory index */
 	memindex = tmap->logical_to_memory[logindex];
@@ -1353,7 +1353,7 @@
 		tmap->gfx_dirtyseq[tmap->tileinfo.gfxnum] = tmap->machine->gfx[tmap->tileinfo.gfxnum]->dirtyseq;
 	}
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
diff -Nru src-old/emu/timer.c src/emu/timer.c
--- src-old/emu/timer.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/timer.c	2010-08-26 08:21:19.000000000 -0700
@@ -371,9 +371,9 @@
 		if (was_enabled && timer->callback != NULL)
 		{
 			LOG(("Timer %s:%d[%s] fired (expire=%s)\n", timer->file, timer->line, timer->func, attotime_string(timer->expire, 9)));
-			profiler_mark_start(PROFILER_TIMER_CALLBACK);
+			g_profiler.start(PROFILER_TIMER_CALLBACK);
 			(*timer->callback)(machine, timer->ptr, timer->param);
-			profiler_mark_end();
+			g_profiler.stop();
 		}
 
 		/* clear the callback timer global */
@@ -943,8 +943,8 @@
 	  m_type(TIMER_TYPE_GENERIC),
 	  m_callback(NULL),
 	  m_ptr(NULL),
-	  m_start_delay(0),
-	  m_period(0),
+	  m_start_delay(attotime_zero),
+	  m_period(attotime_zero),
 	  m_param(0),
 	  m_screen(NULL),
 	  m_first_vpos(0),
@@ -975,23 +975,93 @@
 
 
 //-------------------------------------------------
-//  device_config_complete - perform any
-//  operations now that the configuration is
-//  complete
-//-------------------------------------------------
-
-void timer_device_config::device_config_complete()
-{
-	// move inline data into its final home
-	m_type = static_cast<timer_type>(m_inline_data[INLINE_TYPE]);
-	m_callback = reinterpret_cast<timer_device_fired_func>(m_inline_data[INLINE_CALLBACK]);
-	m_ptr = reinterpret_cast<void *>(m_inline_data[INLINE_PTR]);
-	m_start_delay = static_cast<UINT64>(m_inline_data[INLINE_DELAY]);
-	m_period = static_cast<UINT64>(m_inline_data[INLINE_PERIOD]);
-	m_param = static_cast<UINT32>(m_inline_data[INLINE_PARAM]);
-	m_screen = reinterpret_cast<const char *>(m_inline_data[INLINE_SCREEN]);
-	m_first_vpos = static_cast<INT16>(m_inline_data[INLINE_FIRST_VPOS]);
-	m_increment = static_cast<INT16>(m_inline_data[INLINE_INCREMENT]);
+//  static_configure_generic - configuration
+//  helper to set up a generic timer
+//-------------------------------------------------
+
+void timer_device_config::static_configure_generic(device_config *device, timer_device_fired_func callback)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_type = TIMER_TYPE_GENERIC;
+	timer->m_callback = callback;
+}
+
+
+//-------------------------------------------------
+//  static_configure_periodic - configuration
+//  helper to set up a periodic timer
+//-------------------------------------------------
+
+void timer_device_config::static_configure_periodic(device_config *device, timer_device_fired_func callback, attotime period)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_type = TIMER_TYPE_PERIODIC;
+	timer->m_callback = callback;
+	timer->m_period = period;
+}
+
+
+//-------------------------------------------------
+//  static_configure_scanline - configuration
+//  helper to set up a scanline timer
+//-------------------------------------------------
+
+void timer_device_config::static_configure_scanline(device_config *device, timer_device_fired_func callback, const char *screen, int first_vpos, int increment)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_type = TIMER_TYPE_SCANLINE;
+	timer->m_callback = callback;
+	timer->m_screen = screen;
+	timer->m_first_vpos = first_vpos;
+	timer->m_increment = increment;
+}
+
+
+//-------------------------------------------------
+//  static_set_callback - configuration helper
+//  to set the callback
+//-------------------------------------------------
+
+void timer_device_config::static_set_callback(device_config *device, timer_device_fired_func callback)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_callback = callback;
+}
+
+
+//-------------------------------------------------
+//  static_set_start_delay - configuration helper
+//  to set the starting delay
+//-------------------------------------------------
+
+void timer_device_config::static_set_start_delay(device_config *device, attotime delay)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_start_delay = delay;
+}
+
+
+//-------------------------------------------------
+//  static_set_param - configuration helper to set
+//  the integer parameter
+//-------------------------------------------------
+
+void timer_device_config::static_set_param(device_config *device, int param)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_param = param;
+}
+
+
+//-------------------------------------------------
+//  static_set_ptr - configuration helper to set
+//  the pointer parameter
+//-------------------------------------------------
+
+void timer_device_config::static_set_ptr(device_config *device, void *ptr)
+{
+	timer_device_config *timer = downcast<timer_device_config *>(device);
+	timer->m_ptr = ptr;
 }
 
 
@@ -1008,16 +1078,16 @@
 	switch (m_type)
 	{
 		case TIMER_TYPE_GENERIC:
-			if (m_screen != NULL || m_first_vpos != 0 || m_start_delay != 0)
+			if (m_screen != NULL || m_first_vpos != 0 || attotime_compare(m_start_delay, attotime_zero) != 0)
 				mame_printf_warning("%s: %s generic timer '%s' specified parameters for a scanline timer\n", driver.source_file, driver.name, tag());
-			if (m_period != 0 || m_start_delay != 0)
+			if (attotime_compare(m_period, attotime_zero) != 0 || attotime_compare(m_start_delay, attotime_zero) != 0)
 				mame_printf_warning("%s: %s generic timer '%s' specified parameters for a periodic timer\n", driver.source_file, driver.name, tag());
 			break;
 
 		case TIMER_TYPE_PERIODIC:
 			if (m_screen != NULL || m_first_vpos != 0)
 				mame_printf_warning("%s: %s periodic timer '%s' specified parameters for a scanline timer\n", driver.source_file, driver.name, tag());
-			if (m_period <= 0)
+			if (attotime_compare(m_period, attotime_zero) <= 0)
 			{
 				mame_printf_error("%s: %s periodic timer '%s' specified invalid period\n", driver.source_file, driver.name, tag());
 				error = true;
@@ -1025,7 +1095,7 @@
 			break;
 
 		case TIMER_TYPE_SCANLINE:
-			if (m_period != 0 || m_start_delay != 0)
+			if (attotime_compare(m_period, attotime_zero) != 0 || attotime_compare(m_start_delay, attotime_zero) != 0)
 				mame_printf_warning("%s: %s scanline timer '%s' specified parameters for a periodic timer\n", driver.source_file, driver.name, tag());
 			if (m_param != 0)
 				mame_printf_warning("%s: %s scanline timer '%s' specified parameter which is ignored\n", driver.source_file, driver.name, tag());
@@ -1104,14 +1174,14 @@
 		{
 			// convert the period into attotime
 			attotime period = attotime_never;
-			if (m_config.m_period > 0)
+			if (attotime_compare(m_config.m_period, attotime_zero) > 0)
 			{
-				period = UINT64_ATTOTIME_TO_ATTOTIME(m_config.m_period);
+				period = m_config.m_period;
 
 				// convert the start_delay into attotime
 				attotime start_delay = attotime_zero;
-				if (m_config.m_start_delay > 0)
-					start_delay = UINT64_ATTOTIME_TO_ATTOTIME(m_config.m_start_delay);
+				if (attotime_compare(m_config.m_start_delay, attotime_zero) > 0)
+					start_delay = m_config.m_start_delay;
 
 				// allocate and start the backing timer
 				timer_adjust_periodic(m_timer, start_delay, m_config.m_param, period);
diff -Nru src-old/emu/timer.h src/emu/timer.h
--- src-old/emu/timer.h	2010-06-29 02:02:17.000000000 -0700
+++ src/emu/timer.h	2010-08-26 08:21:19.000000000 -0700
@@ -80,37 +80,30 @@
 
 #define MDRV_TIMER_ADD(_tag, _callback) \
 	MDRV_DEVICE_ADD(_tag, TIMER, 0) \
-	MDRV_DEVICE_INLINE_DATA16(timer_device_config::INLINE_TYPE, timer_device_config::TIMER_TYPE_GENERIC) \
-	MDRV_DEVICE_INLINE_DATAPTR(timer_device_config::INLINE_CALLBACK, _callback)
+	timer_device_config::static_configure_generic(device, _callback); \
 
 #define MDRV_TIMER_ADD_PERIODIC(_tag, _callback, _period) \
 	MDRV_DEVICE_ADD(_tag, TIMER, 0) \
-	MDRV_DEVICE_INLINE_DATA16(timer_device_config::INLINE_TYPE, timer_device_config::TIMER_TYPE_PERIODIC) \
-	MDRV_DEVICE_INLINE_DATAPTR(timer_device_config::INLINE_CALLBACK, _callback) \
-	MDRV_DEVICE_INLINE_DATA64(timer_device_config::INLINE_PERIOD, UINT64_ATTOTIME_IN_##_period)
+	timer_device_config::static_configure_periodic(device, _callback, ATTOTIME_IN_##_period); \
 
 #define MDRV_TIMER_ADD_SCANLINE(_tag, _callback, _screen, _first_vpos, _increment) \
 	MDRV_DEVICE_ADD(_tag, TIMER, 0) \
-	MDRV_DEVICE_INLINE_DATA16(timer_device_config::INLINE_TYPE, timer_device_config::TIMER_TYPE_SCANLINE) \
-	MDRV_DEVICE_INLINE_DATAPTR(timer_device_config::INLINE_CALLBACK, _callback) \
-	MDRV_DEVICE_INLINE_DATAPTR(timer_device_config::INLINE_SCREEN, _screen) \
-	MDRV_DEVICE_INLINE_DATA16(timer_device_config::INLINE_FIRST_VPOS, _first_vpos) \
-	MDRV_DEVICE_INLINE_DATA16(timer_device_config::INLINE_INCREMENT, _increment)
+	timer_device_config::static_configure_scanline(device, _callback, _screen, _first_vpos, _increment); \
 
 #define MDRV_TIMER_MODIFY(_tag) \
 	MDRV_DEVICE_MODIFY(_tag)
 
 #define MDRV_TIMER_CALLBACK(_callback) \
-	MDRV_DEVICE_INLINE_DATA32(timer_device_config::INLINE_CALLBACK, _callback)
+	timer_device_config::static_set_callback(device, _callback); \
 
 #define MDRV_TIMER_START_DELAY(_start_delay) \
-	MDRV_DEVICE_INLINE_DATA64(timer_device_config::INLINE_DELAY, UINT64_ATTOTIME_IN_##_start_delay)
+	timer_device_config::static_set_start_delay(device, ATTOTIME_IN_##_start_delay); \
 
 #define MDRV_TIMER_PARAM(_param) \
-	MDRV_DEVICE_INLINE_DATA32(timer_device_config::INLINE_PARAM, _param)
+	timer_device_config::static_set_param(device, _param); \
 
 #define MDRV_TIMER_PTR(_ptr) \
-	MDRV_DEVICE_INLINE_DATAPTR(timer_device_config::INLINE_PTR, _ptr)
+	timer_device_config::static_set_ptr(device, (void *)(_ptr)); \
 
 
 
@@ -233,19 +226,18 @@
 	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 	virtual device_t *alloc_device(running_machine &machine) const;
 
-	// indexes to inline data
-	enum
-	{
-		INLINE_TYPE,
-		INLINE_CALLBACK,
-		INLINE_PERIOD,
-		INLINE_SCREEN,
-		INLINE_FIRST_VPOS,
-		INLINE_INCREMENT,
-		INLINE_DELAY,
-		INLINE_PARAM,
-		INLINE_PTR
-	};
+	// inline configuration helpers
+	static void static_configure_generic(device_config *device, timer_device_fired_func callback);
+	static void static_configure_periodic(device_config *device, timer_device_fired_func callback, attotime period);
+	static void static_configure_scanline(device_config *device, timer_device_fired_func callback, const char *screen, int first_vpos, int increment);
+	static void static_set_callback(device_config *device, timer_device_fired_func callback);
+	static void static_set_start_delay(device_config *device, attotime delay);
+	static void static_set_param(device_config *device, int param);
+	static void static_set_ptr(device_config *device, void *ptr);
+
+private:
+	// device_config overrides
+	virtual bool device_validity_check(const game_driver &driver) const;
 
 	// timer types
 	enum timer_type
@@ -255,19 +247,14 @@
 		TIMER_TYPE_GENERIC
 	};
 
-private:
-	// device_config overrides
-	virtual void device_config_complete();
-	virtual bool device_validity_check(const game_driver &driver) const;
-
 	// configuration data
 	timer_type				m_type;				// type of timer
 	timer_device_fired_func	m_callback;			// the timer's callback function
 	void *					m_ptr;				// the pointer parameter passed to the timer callback
 
 	// periodic timers only
-	UINT64					m_start_delay;		// delay before the timer fires for the first time
-	UINT64					m_period;			// period of repeated timer firings
+	attotime				m_start_delay;		// delay before the timer fires for the first time
+	attotime				m_period;			// period of repeated timer firings
 	INT32					m_param;			// the integer parameter passed to the timer callback
 
 	// scanline timers only
diff -Nru src-old/emu/ui.c src/emu/ui.c
--- src-old/emu/ui.c	2010-07-07 21:48:25.000000000 -0700
+++ src/emu/ui.c	2010-08-21 15:25:58.000000000 -0700
@@ -822,16 +822,8 @@
 
 void ui_set_show_profiler(int show)
 {
-	if (show)
-	{
-		show_profiler = TRUE;
-		profiler_start();
-	}
-	else
-	{
-		show_profiler = FALSE;
-		profiler_stop();
-	}
+	show_profiler = show;
+	g_profiler.enable(show);
 }
 
 
@@ -1302,7 +1294,7 @@
 	if (show_profiler)
 	{
 		astring profilertext;
-		profiler_get_text(machine, profilertext);
+		g_profiler.text(*machine, profilertext);
 		ui_draw_text_full(container, profilertext, 0.0f, 0.0f, 1.0f, JUSTIFY_LEFT, WRAP_WORD, DRAW_OPAQUE, ARGB_WHITE, ARGB_BLACK, NULL, NULL);
 	}
 
diff -Nru src-old/emu/uiinput.c src/emu/uiinput.c
--- src-old/emu/uiinput.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/uiinput.c	2010-08-21 15:25:58.000000000 -0700
@@ -255,7 +255,7 @@
 	ui_input_private *uidata = machine->ui_input_data;
 	int pressed = FALSE;
 
-profiler_mark_start(PROFILER_INPUT);
+g_profiler.start(PROFILER_INPUT);
 
 	/* get the status of this key (assumed to be only in the defaults) */
 	assert(code >= IPT_UI_CONFIGURE && code <= IPT_OSD_16);
@@ -283,7 +283,7 @@
 	else
 		uidata->next_repeat[code] = 0;
 
-profiler_mark_end();
+g_profiler.stop();
 
 	return pressed;
 }
diff -Nru src-old/emu/uimenu.c src/emu/uimenu.c
--- src-old/emu/uimenu.c	2010-07-06 10:30:28.000000000 -0700
+++ src/emu/uimenu.c	2010-08-21 12:27:14.000000000 -0700
@@ -2577,7 +2577,7 @@
 				case IPT_UI_DISPLAY_COMMENT:
 				case IPT_UI_UP:
 				case IPT_UI_DOWN:
-					if (cheat_get_comment(event->itemref).len() != 0)
+					if (cheat_get_comment(event->itemref))
 						popmessage("Cheat Comment:\n%s", cheat_get_comment(event->itemref).cstr());
 					break;
 			}
diff -Nru src-old/emu/validity.c src/emu/validity.c
--- src-old/emu/validity.c	2010-08-11 21:24:53.000000000 -0700
+++ src/emu/validity.c	2010-08-30 08:20:58.000000000 -0700
@@ -492,23 +492,22 @@
 				else
 				{
 					astring fulltag;
-					int rgnnum;
 
 					/* iterate over all regions found so far */
 					rom_region_name(fulltag, driver, source, romp);
-					for (rgnnum = 0; rgnnum < ARRAY_LENGTH(rgninfo->entries); rgnnum++)
+					for (int rgnnum = 0; rgnnum < ARRAY_LENGTH(rgninfo->entries); rgnnum++)
 					{
 						/* stop when we hit an empty */
-						if (rgninfo->entries[rgnnum].tag.len() == 0)
+						if (!rgninfo->entries[rgnnum].tag)
 						{
 							currgn = &rgninfo->entries[rgnnum];
-							currgn->tag.cpy(fulltag);
+							currgn->tag = fulltag;
 							currgn->length = ROMREGION_GETLENGTH(romp);
 							break;
 						}
 
 						/* fail if we hit a duplicate */
-						if (fulltag.cmp(rgninfo->entries[rgnnum].tag) == 0)
+						if (fulltag == rgninfo->entries[rgnnum].tag)
 						{
 							mame_printf_error("%s: %s has duplicate ROM_REGION tag '%s'\n", driver->source_file, driver->name, fulltag.cstr());
 							error = true;
@@ -564,6 +563,10 @@
 				}
 			}
 
+			// count copies/fills as valid items
+			else if (ROMENTRY_ISCOPY(romp) || ROMENTRY_ISFILL(romp))
+				items_since_region++;
+
 			/* for any non-region ending entries, make sure they don't extend past the end */
 			if (!ROMENTRY_ISREGIONEND(romp) && currgn != NULL)
 			{
@@ -650,7 +653,7 @@
 			for (rgnnum = 0; rgnnum < ARRAY_LENGTH(rgninfo->entries); rgnnum++)
 			{
 				/* stop if we hit an empty */
-				if (rgninfo->entries[rgnnum].tag == NULL)
+				if (!rgninfo->entries[rgnnum].tag)
 				{
 					mame_printf_error("%s: %s has gfx[%d] referencing non-existent region '%s'\n", driver->source_file, driver->name, gfxnum, region);
 					error = true;
@@ -658,7 +661,7 @@
 				}
 
 				/* if we hit a match, check against the length */
-				if (rgninfo->entries[rgnnum].tag.cmp(region) == 0)
+				if (rgninfo->entries[rgnnum].tag == region)
 				{
 					/* if we have a valid region, and we're not using auto-sizing, check the decode against the region length */
 					if (!IS_FRAC(total))
diff -Nru src-old/emu/video/mc6845.c src/emu/video/mc6845.c
--- src-old/emu/video/mc6845.c	2010-06-16 23:55:54.000000000 -0700
+++ src/emu/video/mc6845.c	2010-08-13 01:54:21.000000000 -0700
@@ -138,7 +138,7 @@
 static void update_vsync_changed_timers(mc6845_t *mc6845);
 
 
-mc6845_interface mc6845_null_interface = { 0 };
+const mc6845_interface mc6845_null_interface = { 0 };
 
 
 /* makes sure that the passed in device is the right type */
diff -Nru src-old/emu/video/mc6845.h src/emu/video/mc6845.h
--- src-old/emu/video/mc6845.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/mc6845.h	2010-08-13 01:54:21.000000000 -0700
@@ -83,7 +83,7 @@
 	mc6845_on_update_addr_changed_func	on_update_addr_changed;
 };
 
-extern mc6845_interface mc6845_null_interface;
+extern const mc6845_interface mc6845_null_interface;
 
 
 /* select one of the registers for reading or writing */
diff -Nru src-old/emu/video/pc_vga.c src/emu/video/pc_vga.c
--- src-old/emu/video/pc_vga.c	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/pc_vga.c	2010-08-19 00:26:14.000000000 -0700
@@ -596,7 +596,7 @@
 
 static void vga_cpu_interface(running_machine *machine)
 {
-	const address_space *space = cpu_get_address_space(machine->firstcpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(machine->firstcpu, ADDRESS_SPACE_PROGRAM);
 	static int sequencer, gc;
 	read8_space_func read_handler;
 	write8_space_func write_handler;
@@ -1220,7 +1220,7 @@
 void pc_vga_init(running_machine *machine, const struct pc_vga_interface *vga_intf, const struct pc_svga_interface *svga_intf)
 {
 	int i, j, k, mask, buswidth;
-	const address_space *spacevga;
+	address_space *spacevga;
 
 	memset(&vga, 0, sizeof(vga));
 
diff -Nru src-old/emu/video/s2636.c src/emu/video/s2636.c
--- src-old/emu/video/s2636.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/video/s2636.c	2010-08-12 12:45:01.000000000 -0700
@@ -77,6 +77,7 @@
 
 #include "emu.h"
 #include "video/s2636.h"
+#include "sound/s2636.h"
 
 /*************************************
  *
@@ -318,6 +319,15 @@
 
 	assert(offset < s2636->work_ram_size);
 
+	if ( offset == 0xc7 )
+	{
+		const s2636_interface *intf = get_interface(device);
+		if ( intf->sound && *intf->sound )
+		{
+			s2636_soundport_w(device->machine->device(intf->sound), 0, data);
+		}
+	}
+
 	s2636->work_ram[offset] = data;
 }
 
diff -Nru src-old/emu/video/s2636.h src/emu/video/s2636.h
--- src-old/emu/video/s2636.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/s2636.h	2010-08-12 12:45:01.000000000 -0700
@@ -26,6 +26,7 @@
 	int        work_ram_size;
 	int        y_offset;
 	int        x_offset;
+	const char *sound;
 };
 
 /*************************************
diff -Nru src-old/emu/video/tlc34076.c src/emu/video/tlc34076.c
--- src-old/emu/video/tlc34076.c	2010-01-10 11:00:42.000000000 -0800
+++ src/emu/video/tlc34076.c	2010-08-15 17:41:11.000000000 -0700
@@ -10,14 +10,6 @@
 #include "emu.h"
 #include "tlc34076.h"
 
-static UINT8 local_paletteram[0x300];
-static UINT8 regs[0x10];
-static UINT8 palettedata[3];
-static UINT8 writeindex, readindex;
-static UINT8 dacbits;
-
-static rgb_t pens[0x100];
-
 #define PALETTE_WRITE_ADDR	0x00
 #define PALETTE_DATA		0x01
 #define PIXEL_READ_MASK		0x02
@@ -30,7 +22,33 @@
 #define TEST_REGISTER		0x0e
 #define RESET_STATE			0x0f
 
+typedef struct _tlc34076_state  tlc34076_state;
+struct _tlc34076_state
+{
+	UINT8 local_paletteram[0x300];
+	UINT8 regs[0x10];
+	UINT8 palettedata[3];
+	UINT8 writeindex;
+	UINT8 readindex;
+	UINT8 dacbits;
+
+	rgb_t pens[0x100];
+};
+
+
+/*************************************
+ *
+ *  Inline functions
+ *
+ *************************************/
+
+INLINE tlc34076_state *get_safe_token( running_device *device )
+{
+	assert(device != NULL);
+	assert(device->type() == TLC34076);
 
+	return (tlc34076_state *)downcast<legacy_device_base *>(device)->token();
+}
 
 /*************************************
  *
@@ -38,21 +56,22 @@
  *
  *************************************/
 
-const pen_t *tlc34076_get_pens(void)
+const pen_t *tlc34076_get_pens(running_device *device)
 {
+	tlc34076_state *state = get_safe_token(device);
 	offs_t i;
 
 	for (i = 0; i < 0x100; i++)
 	{
 		int r, g, b;
 
-		if ((i & regs[PIXEL_READ_MASK]) == i)
+		if ((i & state->regs[PIXEL_READ_MASK]) == i)
 		{
-			r = local_paletteram[3 * i + 0];
-			g = local_paletteram[3 * i + 1];
-			b = local_paletteram[3 * i + 2];
+			r = state->local_paletteram[3 * i + 0];
+			g = state->local_paletteram[3 * i + 1];
+			b = state->local_paletteram[3 * i + 2];
 
-			if (dacbits == 6)
+			if (state->dacbits == 6)
 			{
 				r = pal6bit(r);
 				g = pal6bit(g);
@@ -66,10 +85,10 @@
 			b = 0;
 		}
 
-		pens[i] = MAKE_RGB(r, g, b);
+		state->pens[i] = MAKE_RGB(r, g, b);
 	}
 
-	return pens;
+	return state->pens;
 }
 
 
@@ -80,40 +99,19 @@
  *
  *************************************/
 
-void tlc34076_reset(int dacwidth)
+static DEVICE_RESET( tlc34076 )
 {
-	assert_always((dacbits == 6) || (dacbits != 8), "tlc34076_reset: dacwidth must be 6 or 8!");
-
-	dacbits = dacwidth;
+	tlc34076_state *state = get_safe_token(device);
 
 	/* reset the registers */
-	regs[PIXEL_READ_MASK]		= 0xff;
-	regs[GENERAL_CONTROL]		= 0x03;
-	regs[INPUT_CLOCK_SEL]		= 0x00;
-	regs[OUTPUT_CLOCK_SEL]		= 0x3f;
-	regs[MUX_CONTROL]			= 0x2d;
-	regs[PALETTE_PAGE]			= 0x00;
-	regs[TEST_REGISTER]			= 0x00;
-	regs[RESET_STATE]			= 0x00;
-}
-
-
-
-/*************************************
- *
- *  Save State
- *
- *************************************/
-
-void tlc34076_state_save(running_machine *machine)
-{
-	state_save_register_global_array(machine, local_paletteram);
-	state_save_register_global_array(machine, regs);
-	state_save_register_global_array(machine, pens);
-
-	state_save_register_global(machine, writeindex);
-	state_save_register_global(machine, readindex);
-	state_save_register_global(machine, dacbits);
+	state->regs[PIXEL_READ_MASK]	= 0xff;
+	state->regs[GENERAL_CONTROL]	= 0x03;
+	state->regs[INPUT_CLOCK_SEL]	= 0x00;
+	state->regs[OUTPUT_CLOCK_SEL]	= 0x3f;
+	state->regs[MUX_CONTROL]		= 0x2d;
+	state->regs[PALETTE_PAGE]		= 0x00;
+	state->regs[TEST_REGISTER]		= 0x00;
+	state->regs[RESET_STATE]		= 0x00;
 }
 
 
@@ -123,29 +121,30 @@
  *
  *************************************/
 
-READ8_HANDLER( tlc34076_r )
+READ8_DEVICE_HANDLER( tlc34076_r )
 {
+	tlc34076_state *state = get_safe_token(device);
 	UINT8 result;
 
 	/* keep in range */
 	offset &= 0x0f;
-	result = regs[offset];
+	result = state->regs[offset];
 
 	/* switch off the offset */
 	switch (offset)
 	{
 		case PALETTE_DATA:
-			if (readindex == 0)
+			if (state->readindex == 0)
 			{
-				palettedata[0] = local_paletteram[3 * regs[PALETTE_READ_ADDR] + 0];
-				palettedata[1] = local_paletteram[3 * regs[PALETTE_READ_ADDR] + 1];
-				palettedata[2] = local_paletteram[3 * regs[PALETTE_READ_ADDR] + 2];
+				state->palettedata[0] = state->local_paletteram[3 * state->regs[PALETTE_READ_ADDR] + 0];
+				state->palettedata[1] = state->local_paletteram[3 * state->regs[PALETTE_READ_ADDR] + 1];
+				state->palettedata[2] = state->local_paletteram[3 * state->regs[PALETTE_READ_ADDR] + 2];
 			}
-			result = palettedata[readindex++];
-			if (readindex == 3)
+			result = state->palettedata[state->readindex++];
+			if (state->readindex == 3)
 			{
-				readindex = 0;
-				regs[PALETTE_READ_ADDR]++;
+				state->readindex = 0;
+				state->regs[PALETTE_READ_ADDR]++;
 			}
 			break;
 	}
@@ -161,36 +160,37 @@
  *
  *************************************/
 
-WRITE8_HANDLER( tlc34076_w )
+WRITE8_DEVICE_HANDLER( tlc34076_w )
 {
+	tlc34076_state *state = get_safe_token(device);
 	UINT8 oldval;
 
 	/* keep in range */
 	offset &= 0x0f;
-	oldval = regs[offset];
-	regs[offset] = data;
+	oldval = state->regs[offset];
+	state->regs[offset] = data;
 
 	/* switch off the offset */
 	switch (offset)
 	{
 		case PALETTE_WRITE_ADDR:
-			writeindex = 0;
+			state->writeindex = 0;
 			break;
 
 		case PALETTE_DATA:
-			palettedata[writeindex++] = data;
-			if (writeindex == 3)
+			state->palettedata[state->writeindex++] = data;
+			if (state->writeindex == 3)
 			{
-				local_paletteram[3 * regs[PALETTE_WRITE_ADDR] + 0] = palettedata[0];
-				local_paletteram[3 * regs[PALETTE_WRITE_ADDR] + 1] = palettedata[1];
-				local_paletteram[3 * regs[PALETTE_WRITE_ADDR] + 2] = palettedata[2];
-				writeindex = 0;
-				regs[PALETTE_WRITE_ADDR]++;
+				state->local_paletteram[3 * state->regs[PALETTE_WRITE_ADDR] + 0] = state->palettedata[0];
+				state->local_paletteram[3 * state->regs[PALETTE_WRITE_ADDR] + 1] = state->palettedata[1];
+				state->local_paletteram[3 * state->regs[PALETTE_WRITE_ADDR] + 2] = state->palettedata[2];
+				state->writeindex = 0;
+				state->regs[PALETTE_WRITE_ADDR]++;
 			}
 			break;
 
 		case PALETTE_READ_ADDR:
-			readindex = 0;
+			state->readindex = 0;
 			break;
 
 		case GENERAL_CONTROL:
@@ -247,7 +247,7 @@
 			break;
 
 		case RESET_STATE:
-			tlc34076_reset(dacbits);
+			DEVICE_RESET_CALL(tlc34076);
 			break;
 	}
 }
@@ -256,29 +256,33 @@
 
 /*************************************
  *
- *  16-bit accessors
+ *  Device interface
  *
  *************************************/
 
-READ16_HANDLER( tlc34076_lsb_r )
+static DEVICE_START( tlc34076 )
 {
-	return tlc34076_r(space, offset);
-}
+	tlc34076_config *config = (tlc34076_config *)downcast<const legacy_device_config_base &>(device->baseconfig()).inline_config();
+	tlc34076_state *state = get_safe_token(device);
 
-WRITE16_HANDLER( tlc34076_lsb_w )
-{
-	if (ACCESSING_BITS_0_7)
-		tlc34076_w(space, offset, data);
-}
+	state->dacbits = config->res_sel ? 8 : 6;
 
-READ16_HANDLER( tlc34076_msb_r )
-{
-	return tlc34076_r(space, offset) << 8;
+	state_save_register_global_array(device->machine, state->local_paletteram);
+	state_save_register_global_array(device->machine, state->regs);
+	state_save_register_global_array(device->machine, state->pens);
+
+	state_save_register_global(device->machine, state->writeindex);
+	state_save_register_global(device->machine, state->readindex);
+	state_save_register_global(device->machine, state->dacbits);
 }
 
-WRITE16_HANDLER( tlc34076_msb_w )
-{
-	if (ACCESSING_BITS_8_15)
-		tlc34076_w(space, offset, data >> 8);
-}
+static const char DEVTEMPLATE_SOURCE[] = __FILE__;
+
+#define DEVTEMPLATE_ID( p, s )	p##tlc34076##s
+#define DEVTEMPLATE_FEATURES	DT_HAS_START | DT_HAS_RESET | DT_HAS_INLINE_CONFIG
+#define DEVTEMPLATE_NAME		"TLC34076"
+#define DEVTEMPLATE_FAMILY		"RAMDAC"
+#include "devtempl.h"
+
 
+DEFINE_LEGACY_DEVICE(TLC34076, tlc34076);
diff -Nru src-old/emu/video/tlc34076.h src/emu/video/tlc34076.h
--- src-old/emu/video/tlc34076.h	2009-05-14 22:14:52.000000000 -0700
+++ src/emu/video/tlc34076.h	2010-08-15 17:41:11.000000000 -0700
@@ -7,16 +7,37 @@
 
 ***************************************************************************/
 
-void tlc34076_reset(int dacwidth);
-void tlc34076_state_save(running_machine *machine);
+#define TLC34076_6_BIT		0
+#define TLC34076_8_BIT		1
 
-const pen_t *tlc34076_get_pens(void);
+const pen_t *tlc34076_get_pens(running_device *device);
 
-READ8_HANDLER( tlc34076_r );
-WRITE8_HANDLER( tlc34076_w );
 
-READ16_HANDLER( tlc34076_lsb_r );
-WRITE16_HANDLER( tlc34076_lsb_w );
-READ16_HANDLER( tlc34076_msb_r );
-WRITE16_HANDLER( tlc34076_msb_w );
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+typedef struct _tlc34076_config tlc34076_config;
+struct _tlc34076_config
+{
+	int res_sel;
+};
+
+DECLARE_LEGACY_DEVICE(TLC34076, tlc34076);
+
+
+/***************************************************************************
+    DEVICE CONFIGURATION MACROS
+***************************************************************************/
+
+#define MDRV_TLC34076_ADD(_tag, _res_sel) \
+	MDRV_DEVICE_ADD(_tag, TLC34076, 0) \
+	MDRV_DEVICE_CONFIG_DATA32(tlc34076_config, res_sel, _res_sel)
+
+
+/***************************************************************************
+    DEVICE I/O FUNCTIONS
+***************************************************************************/
 
+WRITE8_DEVICE_HANDLER( tlc34076_w );
+READ8_DEVICE_HANDLER( tlc34076_r );
diff -Nru src-old/emu/video/tms34061.c src/emu/video/tms34061.c
--- src-old/emu/video/tms34061.c	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/tms34061.c	2010-08-19 00:26:14.000000000 -0700
@@ -164,7 +164,7 @@
  *
  *************************************/
 
-static void register_w(const address_space *space, offs_t offset, UINT8 data)
+static void register_w(address_space *space, offs_t offset, UINT8 data)
 {
 	int scanline;
 	int regnum = offset >> 2;
@@ -235,7 +235,7 @@
  *
  *************************************/
 
-static UINT8 register_r(const address_space *space, offs_t offset)
+static UINT8 register_r(address_space *space, offs_t offset)
 {
 	int regnum = offset >> 2;
 	UINT16 result;
@@ -357,7 +357,7 @@
 }
 
 
-static void xypixel_w(const address_space *space, int offset, UINT8 data)
+static void xypixel_w(address_space *space, int offset, UINT8 data)
 {
 	/* determine the offset, then adjust it */
 	offs_t pixeloffs = tms34061.regs[TMS34061_XYADDRESS];
@@ -377,7 +377,7 @@
 }
 
 
-static UINT8 xypixel_r(const address_space *space, int offset)
+static UINT8 xypixel_r(address_space *space, int offset)
 {
 	/* determine the offset, then adjust it */
 	offs_t pixeloffs = tms34061.regs[TMS34061_XYADDRESS];
@@ -402,7 +402,7 @@
  *
  *************************************/
 
-void tms34061_w(const address_space *space, int col, int row, int func, UINT8 data)
+void tms34061_w(address_space *space, int col, int row, int func, UINT8 data)
 {
 	offs_t offs;
 
@@ -464,7 +464,7 @@
 }
 
 
-UINT8 tms34061_r(const address_space *space, int col, int row, int func)
+UINT8 tms34061_r(address_space *space, int col, int row, int func)
 {
 	int result = 0;
 	offs_t offs;
diff -Nru src-old/emu/video/tms34061.h src/emu/video/tms34061.h
--- src-old/emu/video/tms34061.h	2008-12-14 01:15:01.000000000 -0800
+++ src/emu/video/tms34061.h	2010-08-19 00:26:14.000000000 -0700
@@ -59,8 +59,8 @@
 void tms34061_start(running_machine *machine, const struct tms34061_interface *interface);
 
 /* reads/writes to the 34061 */
-UINT8 tms34061_r(const address_space *space, int col, int row, int func);
-void tms34061_w(const address_space *space, int col, int row, int func, UINT8 data);
+UINT8 tms34061_r(address_space *space, int col, int row, int func);
+void tms34061_w(address_space *space, int col, int row, int func, UINT8 data);
 
 /* latch settings */
 READ8_HANDLER( tms34061_latch_r );
diff -Nru src-old/emu/video/tms9927.c src/emu/video/tms9927.c
--- src-old/emu/video/tms9927.c	2010-06-11 13:37:50.000000000 -0700
+++ src/emu/video/tms9927.c	2010-08-13 01:54:21.000000000 -0700
@@ -56,7 +56,7 @@
 static void recompute_parameters(tms9927_state *tms, int postload);
 
 
-tms9927_interface tms9927_null_interface = { 0 };
+const tms9927_interface tms9927_null_interface = { 0 };
 
 
 /* makes sure that the passed in device is the right type */
diff -Nru src-old/emu/video/tms9927.h src/emu/video/tms9927.h
--- src-old/emu/video/tms9927.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/tms9927.h	2010-08-13 01:54:21.000000000 -0700
@@ -39,7 +39,7 @@
 	const char *selfload_region;	/* name of the region with self-load data */
 };
 
-extern tms9927_interface tms9927_null_interface;
+extern const tms9927_interface tms9927_null_interface;
 
 
 /* basic read/write handlers */
diff -Nru src-old/emu/video/vector.c src/emu/video/vector.c
--- src-old/emu/video/vector.c	2010-06-29 20:46:21.000000000 -0700
+++ src/emu/video/vector.c	2010-08-13 01:54:21.000000000 -0700
@@ -139,9 +139,6 @@
 
 
 
-UINT8 *vectorram;
-size_t vectorram_size;
-
 static int flicker;                              /* beam flicker value     */
 static float flicker_correction = 0.0f;
 
diff -Nru src-old/emu/video/vector.h src/emu/video/vector.h
--- src-old/emu/video/vector.h	2008-12-19 12:40:22.000000000 -0800
+++ src/emu/video/vector.h	2010-08-13 01:54:21.000000000 -0700
@@ -10,9 +10,6 @@
 #define VECTOR_COLOR444(c) \
 	MAKE_RGB(pal4bit((c) >> 8), pal4bit((c) >> 4), pal4bit((c) >> 0))
 
-extern UINT8 *vectorram;
-extern size_t vectorram_size;
-
 VIDEO_START( vector );
 VIDEO_UPDATE( vector );
 
diff -Nru src-old/emu/video/vooddefs.h src/emu/video/vooddefs.h
--- src-old/emu/video/vooddefs.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/vooddefs.h	2010-08-21 15:52:01.000000000 -0700
@@ -1,10 +1,41 @@
-/*************************************************************************
+/***************************************************************************
 
-    3dfx Voodoo Graphics SST-1/2 emulator
+    vooddefs.h
 
-    emulator by Aaron Giles
+    3dfx Voodoo Graphics SST-1/2 emulator.
 
-**************************************************************************/
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
 
 
 /*************************************
diff -Nru src-old/emu/video/voodoo.c src/emu/video/voodoo.c
--- src-old/emu/video/voodoo.c	2010-06-27 23:40:44.000000000 -0700
+++ src/emu/video/voodoo.c	2010-08-21 15:52:01.000000000 -0700
@@ -1,6 +1,45 @@
+/***************************************************************************
+
+    voodoo.c
+
+    3dfx Voodoo Graphics SST-1/2 emulator.
+
+****************************************************************************
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+****************************************************************************
+
 //fix me -- blitz2k dies when starting a game with heavy fog (in DRC)
 
-/*************************************************************************
+****************************************************************************
 
     3dfx Voodoo Graphics SST-1/2 emulator
 
@@ -3417,7 +3456,7 @@
 	voodoo_state *v = get_safe_token(device);
 	int stall = FALSE;
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	/* should not be getting accesses while stalled */
 	if (v->pci.stall_state != NOT_STALLED)
@@ -3445,7 +3484,7 @@
 					if (offset & 0x40000/4)
 						data = FLIPENDIAN_INT32(data);
 					cmdfifo_w(v, &v->fbi.cmdfifo[0], offset & 0xffff, data);
-					profiler_mark_end();
+					g_profiler.stop();
 					return;
 				}
 
@@ -3458,7 +3497,7 @@
 						v->fbi.swaps_pending++;
 
 					logerror("Ignoring write to %s in CMDFIFO mode\n", v->regnames[offset & 0xff]);
-					profiler_mark_end();
+					g_profiler.stop();
 					return;
 				}
 			}
@@ -3475,7 +3514,7 @@
 		/* ignore if writes aren't allowed */
 		if (!(access & REGISTER_WRITE))
 		{
-			profiler_mark_end();
+			g_profiler.stop();
 			return;
 		}
 
@@ -3511,7 +3550,7 @@
 				timer_get_time(device->machine).seconds, (UINT32)(timer_get_time(device->machine).attoseconds >> 32), (UINT32)timer_get_time(device->machine).attoseconds,
 				v->pci.op_end_time.seconds, (UINT32)(v->pci.op_end_time.attoseconds >> 32), (UINT32)v->pci.op_end_time.attoseconds);
 		}
-		profiler_mark_end();
+		g_profiler.stop();
 		return;
 	}
 
@@ -3577,7 +3616,7 @@
 		stall_cpu(v, STALLED_UNTIL_FIFO_EMPTY, timer_get_time(device->machine));
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -4788,7 +4827,7 @@
 	int destbuf;
 	int pixels;
 
-	profiler_mark_start(PROFILER_USER2);
+	g_profiler.start(PROFILER_USER2);
 
 	/* determine the number of TMUs involved */
 	texcount = 0;
@@ -4859,7 +4898,7 @@
 	/* update stats */
 	v->stats.total_triangles++;
 
-	profiler_mark_end();
+	g_profiler.stop();
 
 	/* 1 pixel per clock, plus some setup time */
 	if (LOG_REGISTERS) logerror("cycles = %d\n", TRIANGLE_SETUP_CLOCKS + pixels);
diff -Nru src-old/emu/video/voodoo.h src/emu/video/voodoo.h
--- src-old/emu/video/voodoo.h	2010-06-07 23:09:57.000000000 -0700
+++ src/emu/video/voodoo.h	2010-08-21 15:52:01.000000000 -0700
@@ -1,10 +1,41 @@
-/*************************************************************************
+/***************************************************************************
+
+    voodoo.h
+
+    3dfx Voodoo Graphics SST-1/2 emulator.
 
-    3dfx Voodoo Graphics SST-1 emulator
+****************************************************************************
 
-    driver by Aaron Giles
+    Copyright Aaron Giles
+    All rights reserved.
 
-**************************************************************************/
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
 
 #ifndef __VOODOO_H__
 #define __VOODOO_H__
diff -Nru src-old/emu/video.c src/emu/video.c
--- src-old/emu/video.c	2010-07-26 04:55:21.000000000 -0700
+++ src/emu/video.c	2010-08-30 08:20:58.000000000 -0700
@@ -297,8 +297,7 @@
 		init_buffered_spriteram(machine);
 
 	/* call the PALETTE_INIT function */
-	if (machine->config->m_init_palette != NULL)
-		(*machine->config->m_init_palette)(machine, memory_region(machine, "proms"));
+	machine->driver_data<driver_data_t>()->palette_init(memory_region(machine, "proms"));
 
 	/* create a render target for snapshots */
 	viewname = options_get_string(machine->options(), OPTION_SNAPVIEW);
@@ -461,9 +460,9 @@
 		update_throttle(machine, current_time);
 
 	/* ask the OSD to update */
-	profiler_mark_start(PROFILER_BLIT);
+	g_profiler.start(PROFILER_BLIT);
 	osd_update(machine, !debug && skipped_it);
-	profiler_mark_end();
+	g_profiler.stop();
 
 	/* perform tasks for this frame */
 	if (!debug)
@@ -485,11 +484,11 @@
 			machine->primary_screen->scanline0_callback();
 
 		/* otherwise, call the video EOF callback */
-		else if (machine->config->m_video_eof != NULL)
+		else
 		{
-			profiler_mark_start(PROFILER_VIDEO);
-			(*machine->config->m_video_eof)(machine);
-			profiler_mark_end();
+			g_profiler.start(PROFILER_VIDEO);
+			machine->driver_data<driver_data_t>()->video_eof();
+			g_profiler.stop();
 		}
 	}
 }
@@ -882,7 +881,7 @@
     	allowed_to_sleep = TRUE;
 
 	/* loop until we reach our target */
-	profiler_mark_start(PROFILER_IDLE);
+	g_profiler.start(PROFILER_IDLE);
 	while (current_ticks < target_ticks)
 	{
 		osd_ticks_t delta;
@@ -920,7 +919,7 @@
 		}
 		current_ticks = new_ticks;
 	}
-	profiler_mark_end();
+	g_profiler.stop();
 
 	return current_ticks;
 }
@@ -1370,7 +1369,7 @@
 		png_info pnginfo = { 0 };
 		png_error error;
 
-		profiler_mark_start(PROFILER_MOVIE_REC);
+		g_profiler.start(PROFILER_MOVIE_REC);
 
 		/* create the bitmap */
 		create_snapshot_bitmap(NULL);
@@ -1406,7 +1405,7 @@
 			global.movie_frame++;
 		}
 
-		profiler_mark_end();
+		g_profiler.stop();
 	}
 }
 
@@ -1505,7 +1504,7 @@
 		attotime curtime = timer_get_time(machine);
 		avi_error avierr;
 
-		profiler_mark_start(PROFILER_MOVIE_REC);
+		g_profiler.start(PROFILER_MOVIE_REC);
 
 		/* create the bitmap */
 		create_snapshot_bitmap(NULL);
@@ -1526,7 +1525,7 @@
 			global.movie_frame++;
 		}
 
-		profiler_mark_end();
+		g_profiler.stop();
 	}
 }
 
@@ -1543,7 +1542,7 @@
 	{
 		avi_error avierr;
 
-		profiler_mark_start(PROFILER_MOVIE_REC);
+		g_profiler.start(PROFILER_MOVIE_REC);
 
 		/* write the next frame */
 		avierr = avi_append_sound_samples(global.avifile, 0, sound + 0, numsamples, 1);
@@ -1552,7 +1551,7 @@
 		if (avierr != AVIERR_NONE)
 			video_avi_end_recording(machine);
 
-		profiler_mark_end();
+		g_profiler.stop();
 	}
 }
 
@@ -1722,29 +1721,114 @@
 
 
 //-------------------------------------------------
-//  device_config_complete - perform any
-//  operations now that the configuration is
-//  complete
-//-------------------------------------------------
-
-void screen_device_config::device_config_complete()
-{
-	// move inline data into its final home
-	m_type = static_cast<screen_type_enum>(m_inline_data[INLINE_TYPE]);
-	m_width = static_cast<INT16>(m_inline_data[INLINE_WIDTH]);
-	m_height = static_cast<INT16>(m_inline_data[INLINE_HEIGHT]);
-	m_visarea.min_x = static_cast<INT16>(m_inline_data[INLINE_VIS_MINX]);
-	m_visarea.min_y = static_cast<INT16>(m_inline_data[INLINE_VIS_MINY]);
-	m_visarea.max_x = static_cast<INT16>(m_inline_data[INLINE_VIS_MAXX]);
-	m_visarea.max_y = static_cast<INT16>(m_inline_data[INLINE_VIS_MAXY]);
-	m_oldstyle_vblank_supplied = (m_inline_data[INLINE_OLDVBLANK] != 0);
-	m_refresh = m_inline_data[INLINE_REFRESH];
-	m_vblank = m_inline_data[INLINE_VBLANK];
-	m_format = static_cast<bitmap_format>(m_inline_data[INLINE_FORMAT]);
-	m_xoffset = static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_XOFFSET])) / (double)(1 << 24);
-	m_yoffset = static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_YOFFSET])) / (double)(1 << 24);
-	m_xscale = (m_inline_data[INLINE_XSCALE] == 0) ? 1.0 : (static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_XSCALE])) / (double)(1 << 24));
-	m_yscale = (m_inline_data[INLINE_YSCALE] == 0) ? 1.0 : (static_cast<double>(static_cast<INT32>(m_inline_data[INLINE_YSCALE])) / (double)(1 << 24));
+//  static_set_format - configuration helper
+//  to set the bitmap format
+//-------------------------------------------------
+
+void screen_device_config::static_set_format(device_config *device, bitmap_format format)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_format = format;
+}
+
+
+//-------------------------------------------------
+//  static_set_type - configuration helper
+//  to set the screen type
+//-------------------------------------------------
+
+void screen_device_config::static_set_type(device_config *device, screen_type_enum type)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_type = type;
+}
+
+
+//-------------------------------------------------
+//  static_set_raw - configuration helper
+//  to set the raw screen parameters
+//-------------------------------------------------
+
+void screen_device_config::static_set_raw(device_config *device, UINT32 pixclock, UINT16 htotal, UINT16 hbend, UINT16 hbstart, UINT16 vtotal, UINT16 vbend, UINT16 vbstart)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_refresh = HZ_TO_ATTOSECONDS(pixclock) * htotal * vtotal;
+	screen->m_vblank = screen->m_refresh / vtotal * (vtotal - (vbstart - vbend));
+	screen->m_width = htotal;
+	screen->m_height = vtotal;
+	screen->m_visarea.min_x = hbend;
+	screen->m_visarea.max_x = hbstart - 1;
+	screen->m_visarea.min_y = vbend;
+	screen->m_visarea.max_y = vbstart - 1;
+}
+
+
+//-------------------------------------------------
+//  static_set_refresh - configuration helper
+//  to set the refresh rate
+//-------------------------------------------------
+
+void screen_device_config::static_set_refresh(device_config *device, attoseconds_t rate)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_refresh = rate;
+}
+
+
+//-------------------------------------------------
+//  static_set_vblank_time - configuration helper
+//  to set the VBLANK duration
+//-------------------------------------------------
+
+void screen_device_config::static_set_vblank_time(device_config *device, attoseconds_t time)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_vblank = time;
+	screen->m_oldstyle_vblank_supplied = true;
+}
+
+
+//-------------------------------------------------
+//  static_set_size - configuration helper to set
+//  the width/height of the screen
+//-------------------------------------------------
+
+void screen_device_config::static_set_size(device_config *device, UINT16 width, UINT16 height)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_width = width;
+	screen->m_height = height;
+}
+
+
+//-------------------------------------------------
+//  static_set_visarea - configuration helper to
+//  set the visible area of the screen
+//-------------------------------------------------
+
+void screen_device_config::static_set_visarea(device_config *device, INT16 minx, INT16 maxx, INT16 miny, INT16 maxy)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_visarea.min_x = minx;
+	screen->m_visarea.max_x = maxx;
+	screen->m_visarea.min_y = miny;
+	screen->m_visarea.max_y = maxy;
+}
+
+
+//-------------------------------------------------
+//  static_set_default_position - configuration
+//  helper to set the default position and scale
+//  factors for the screen
+//-------------------------------------------------
+
+void screen_device_config::static_set_default_position(device_config *device, double xscale, double xoffs, double yscale, double yoffs)
+{
+	screen_device_config *screen = downcast<screen_device_config *>(device);
+	screen->m_xscale = xscale;
+	screen->m_xoffset = xoffs;
+	screen->m_yscale = yscale;
+	screen->m_yoffset = yoffs;
 }
 
 
@@ -2118,13 +2202,12 @@
 	{
 		UINT32 flags = UPDATE_HAS_NOT_CHANGED;
 
-		profiler_mark_start(PROFILER_VIDEO);
+		g_profiler.start(PROFILER_VIDEO);
 		LOG_PARTIAL_UPDATES(("updating %d-%d\n", clip.min_y, clip.max_y));
 
-		if (machine->config->m_video_update != NULL)
-			flags = (*machine->config->m_video_update)(this, m_bitmap[m_curbitmap], &clip);
+		flags = machine->driver_data<driver_data_t>()->video_update(*this, *m_bitmap[m_curbitmap], clip);
 		global.partial_updates_this_frame++;
-		profiler_mark_end();
+		g_profiler.stop();
 
 		// if we modified the bitmap, we have to commit
 		m_changed |= ~flags & UPDATE_HAS_NOT_CHANGED;
diff -Nru src-old/emu/video.h src/emu/video.h
--- src-old/emu/video.h	2010-07-05 05:18:11.000000000 -0700
+++ src/emu/video.h	2010-08-30 08:20:58.000000000 -0700
@@ -108,32 +108,21 @@
 	float xscale() const { return m_xscale; }
 	float yscale() const { return m_yscale; }
 
-	// indexes to inline data
-	enum
-	{
-		INLINE_TYPE,
-		INLINE_FORMAT,
-		INLINE_REFRESH,
-		INLINE_VBLANK,
-		INLINE_WIDTH,
-		INLINE_HEIGHT,
-		INLINE_VIS_MINX,
-		INLINE_VIS_MAXX,
-		INLINE_VIS_MINY,
-		INLINE_VIS_MAXY,
-		INLINE_XOFFSET,
-		INLINE_XSCALE,
-		INLINE_YOFFSET,
-		INLINE_YSCALE,
-		INLINE_OLDVBLANK
-	};
+	// inline configuration helpers
+	static void static_set_format(device_config *device, bitmap_format format);
+	static void static_set_type(device_config *device, screen_type_enum type);
+	static void static_set_raw(device_config *device, UINT32 pixclock, UINT16 htotal, UINT16 hbend, UINT16 hbstart, UINT16 vtotal, UINT16 vbend, UINT16 vbstart);
+	static void static_set_refresh(device_config *device, attoseconds_t rate);
+	static void static_set_vblank_time(device_config *device, attoseconds_t time);
+	static void static_set_size(device_config *device, UINT16 width, UINT16 height);
+	static void static_set_visarea(device_config *device, INT16 minx, INT16 maxx, INT16 miny, INT16 maxy);
+	static void static_set_default_position(device_config *device, double xscale, double xoffs, double yscale, double yoffs);
 
 private:
 	// device_config overrides
-	virtual void device_config_complete();
 	virtual bool device_validity_check(const game_driver &driver) const;
 
-	// configuration data
+	// inline configuration data
 	screen_type_enum	m_type;						// type of screen
 	int					m_width, m_height;			// default total width/height (HTOTAL, VTOTAL)
 	rectangle			m_visarea;					// default visible area (HBLANK end/start, VBLANK end/start)
@@ -279,49 +268,34 @@
 
 #define MDRV_SCREEN_ADD(_tag, _type) \
 	MDRV_DEVICE_ADD(_tag, SCREEN, 0) \
-	MDRV_SCREEN_TYPE(_type)
+	MDRV_SCREEN_TYPE(_type) \
 
 #define MDRV_SCREEN_MODIFY(_tag) \
 	MDRV_DEVICE_MODIFY(_tag)
 
 #define MDRV_SCREEN_FORMAT(_format) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_FORMAT, _format)
+	screen_device_config::static_set_format(device, _format); \
 
 #define MDRV_SCREEN_TYPE(_type) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_TYPE, SCREEN_TYPE_##_type)
+	screen_device_config::static_set_type(device, SCREEN_TYPE_##_type); \
 
 #define MDRV_SCREEN_RAW_PARAMS(_pixclock, _htotal, _hbend, _hbstart, _vtotal, _vbend, _vbstart) \
-	MDRV_DEVICE_INLINE_DATA64(screen_device_config::INLINE_REFRESH, HZ_TO_ATTOSECONDS(_pixclock) * (_htotal) * (_vtotal)) \
-	MDRV_DEVICE_INLINE_DATA64(screen_device_config::INLINE_VBLANK, ((HZ_TO_ATTOSECONDS(_pixclock) * (_htotal) * (_vtotal)) / (_vtotal)) * ((_vtotal) - ((_vbstart) - (_vbend)))) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_WIDTH, _htotal)	\
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_HEIGHT, _vtotal)	\
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MINX, _hbend) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MAXX, (_hbstart) - 1) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MINY, _vbend) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MAXY, (_vbstart) - 1)
+	screen_device_config::static_set_raw(device, _pixclock, _htotal, _hbend, _hbstart, _vtotal, _vbend, _vbstart);
 
 #define MDRV_SCREEN_REFRESH_RATE(_rate) \
-	MDRV_DEVICE_INLINE_DATA64(screen_device_config::INLINE_REFRESH, HZ_TO_ATTOSECONDS(_rate))
+	screen_device_config::static_set_refresh(device, HZ_TO_ATTOSECONDS(_rate)); \
 
 #define MDRV_SCREEN_VBLANK_TIME(_time) \
-	MDRV_DEVICE_INLINE_DATA64(screen_device_config::INLINE_VBLANK, _time) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_OLDVBLANK, true)
+	screen_device_config::static_set_vblank_time(device, _time); \
 
 #define MDRV_SCREEN_SIZE(_width, _height) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_WIDTH, _width) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_HEIGHT, _height)
+	screen_device_config::static_set_size(device, _width, _height); \
 
 #define MDRV_SCREEN_VISIBLE_AREA(_minx, _maxx, _miny, _maxy) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MINX, _minx) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MAXX, _maxx) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MINY, _miny) \
-	MDRV_DEVICE_INLINE_DATA16(screen_device_config::INLINE_VIS_MAXY, _maxy)
+	screen_device_config::static_set_visarea(device, _minx, _maxx, _miny, _maxy); \
 
 #define MDRV_SCREEN_DEFAULT_POSITION(_xscale, _xoffs, _yscale, _yoffs)	\
-	MDRV_DEVICE_INLINE_DATA32(screen_device_config::INLINE_XOFFSET, (INT32)((_xoffs) * (double)(1 << 24))) \
-	MDRV_DEVICE_INLINE_DATA32(screen_device_config::INLINE_XSCALE, (INT32)((_xscale) * (double)(1 << 24))) \
-	MDRV_DEVICE_INLINE_DATA32(screen_device_config::INLINE_YOFFSET, (INT32)((_yoffs) * (double)(1 << 24))) \
-	MDRV_DEVICE_INLINE_DATA32(screen_device_config::INLINE_YSCALE, (INT32)((_yscale) * (double)(1 << 24)))
+	screen_device_config::static_set_default_position(device, _xscale, _xoffs, _yscale, _yoffs); \
 
 
 
diff -Nru src-old/lib/util/astring.h src/lib/util/astring.h
--- src-old/lib/util/astring.h	2010-07-05 17:52:36.000000000 -0700
+++ src/lib/util/astring.h	2010-08-30 08:20:58.000000000 -0700
@@ -317,10 +317,24 @@
 	astring &operator=(const char *string) { return cpy(string); }
 	astring &operator=(const astring &string) { return cpy(string); }
 
+	bool operator==(const char *string) const { return (cmp(string) == 0); }
+	bool operator==(const astring &string) const { return (cmp(string) == 0); }
+	bool operator!=(const char *string) const { return (cmp(string) != 0); }
+	bool operator!=(const astring &string) const { return (cmp(string) != 0); }
+	bool operator<(const char *string) const { return (cmp(string) < 0); }
+	bool operator<(const astring &string) const { return (cmp(string) < 0); }
+	bool operator<=(const char *string) const { return (cmp(string) <= 0); }
+	bool operator<=(const astring &string) const { return (cmp(string) <= 0); }
+	bool operator>(const char *string) const { return (cmp(string) > 0); }
+	bool operator>(const astring &string) const { return (cmp(string) > 0); }
+	bool operator>=(const char *string) const { return (cmp(string) >= 0); }
+	bool operator>=(const astring &string) const { return (cmp(string) >= 0); }
+
 	astring &reset() { return cpy(""); }
 	astring &expand(int length) { astring_expand(this, length); return *this; }
 
-	operator char *() { return this->text; }
+	operator bool() { return this->text[0] != 0; }
+	operator bool() const { return this->text[0] != 0; }
 	operator const char *() const { return astring_c(this); }
 	const char *cstr() const { return astring_c(this); }
 	int len() const { return astring_len(this); }
diff -Nru src-old/mame/audio/8080bw.c src/mame/audio/8080bw.c
--- src-old/mame/audio/8080bw.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/audio/8080bw.c	2010-08-19 00:26:14.000000000 -0700
@@ -908,7 +908,7 @@
 static STATE_POSTLOAD( schaser_reinit_555_time_remain )
 {
 	mw8080bw_state *state = machine->driver_data<mw8080bw_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	state->schaser_effect_555_time_remain = double_to_attotime(state->schaser_effect_555_time_remain_savable);
 	schaser_sh_port_2_w(space, 0, state->port_2_last_extra);
 }
@@ -931,7 +931,7 @@
 MACHINE_RESET( schaser_sh )
 {
 	mw8080bw_state *state = machine->driver_data<mw8080bw_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	state->schaser_effect_555_is_low = 0;
 	timer_adjust_oneshot(state->schaser_effect_555_timer, attotime_never, 0);
diff -Nru src-old/mame/audio/cage.c src/mame/audio/cage.c
--- src-old/mame/audio/cage.c	2010-07-05 17:52:36.000000000 -0700
+++ src/mame/audio/cage.c	2010-08-19 01:27:05.000000000 -0700
@@ -237,7 +237,7 @@
 }
 
 
-static void update_dma_state(const address_space *space)
+static void update_dma_state(address_space *space)
 {
 	/* determine the new enabled state */
 	int enabled = ((tms32031_io_regs[DMA_GLOBAL_CTL] & 3) == 3) && (tms32031_io_regs[DMA_TRANSFER_COUNT] != 0);
@@ -260,7 +260,7 @@
 		inc = (tms32031_io_regs[DMA_GLOBAL_CTL] >> 4) & 1;
 		for (i = 0; i < tms32031_io_regs[DMA_TRANSFER_COUNT]; i++)
 		{
-			sound_data[i % STACK_SOUND_BUFSIZE] = memory_read_dword(space, addr * 4);
+			sound_data[i % STACK_SOUND_BUFSIZE] = space->read_dword(addr * 4);
 			addr += inc;
 			if (i % STACK_SOUND_BUFSIZE == STACK_SOUND_BUFSIZE - 1)
 				dmadac_transfer(&dmadac[0], DAC_BUFFER_CHANNELS, 1, DAC_BUFFER_CHANNELS, STACK_SOUND_BUFSIZE / DAC_BUFFER_CHANNELS, sound_data);
@@ -517,7 +517,7 @@
 }
 
 
-UINT16 main_from_cage_r(const address_space *space)
+UINT16 main_from_cage_r(address_space *space)
 {
 	if (LOG_COMM)
 		logerror("%s:main read data = %04X\n", cpuexec_describe_context(space->machine), soundlatch_word_r(space, 0, 0));
diff -Nru src-old/mame/audio/cage.h src/mame/audio/cage.h
--- src-old/mame/audio/cage.h	2008-11-15 03:20:18.000000000 -0800
+++ src/mame/audio/cage.h	2010-08-19 00:26:14.000000000 -0700
@@ -14,7 +14,7 @@
 void cage_set_irq_handler(void (*irqhandler)(running_machine *, int));
 void cage_reset_w(int state);
 
-UINT16 main_from_cage_r(const address_space *space);
+UINT16 main_from_cage_r(address_space *space);
 UINT16 cage_control_r(void);
 void main_to_cage_w(UINT16 data);
 void cage_control_w(running_machine *machine, UINT16 data);
diff -Nru src-old/mame/audio/dcs.c src/mame/audio/dcs.c
--- src-old/mame/audio/dcs.c	2010-07-07 14:01:36.000000000 -0700
+++ src/mame/audio/dcs.c	2010-08-19 01:27:05.000000000 -0700
@@ -285,8 +285,8 @@
 struct _dcs_state
 {
 	cpu_device *cpu;
-	const address_space *program;
-	const address_space *data;
+	address_space *program;
+	address_space *data;
 	UINT8		rev;
 	offs_t		polling_offset;
 	UINT32		polling_count;
@@ -1778,11 +1778,11 @@
 	{
 		/* Road Burners: @ 28: JMP $0032  18032F, same code at $32 */
 
-		if (memory_read_dword(dcs.program, 0x18*4) == 0x0c0030 &&		/* ENA SEC_REG */
-			memory_read_dword(dcs.program, 0x19*4) == 0x804828 &&		/* SI = DM($0482) */
-			memory_read_dword(dcs.program, 0x1a*4) == 0x904828 &&		/* DM($0482) = SI */
-			memory_read_dword(dcs.program, 0x1b*4) == 0x0C0020 &&		/* DIS SEC_REG */
-			memory_read_dword(dcs.program, 0x1c*4) == 0x0A001F)			/* RTI */
+		if (dcs.program->read_dword(0x18*4) == 0x0c0030 &&		/* ENA SEC_REG */
+			dcs.program->read_dword(0x19*4) == 0x804828 &&		/* SI = DM($0482) */
+			dcs.program->read_dword(0x1a*4) == 0x904828 &&		/* DM($0482) = SI */
+			dcs.program->read_dword(0x1b*4) == 0x0C0020 &&		/* DIS SEC_REG */
+			dcs.program->read_dword(0x1c*4) == 0x0A001F)			/* RTI */
 		{
 			dcs.timer_ignore = TRUE;
 		}
@@ -1952,7 +1952,7 @@
 
 		for (i = 0; i < count; i++)
 		{
-			buffer[i] = memory_read_word(dcs.data, reg * 2);
+			buffer[i] = dcs.data->read_word(reg * 2);
 			reg += dcs.incs;
 		}
 
@@ -2252,10 +2252,10 @@
 					if (transfer.writes_left & 1)
 						transfer.temp = data;
 					else
-						memory_write_dword(dcs.program, transfer.start++ * 4, (transfer.temp << 8) | (data & 0xff));
+						dcs.program->write_dword(transfer.start++ * 4, (transfer.temp << 8) | (data & 0xff));
 				}
 				else
-					memory_write_word(dcs.data, transfer.start++ * 2, data);
+					dcs.data->write_word(transfer.start++ * 2, data);
 
 				/* if we're done, start a timer to send the response words */
 				if (transfer.state == 0)
@@ -2270,7 +2270,7 @@
 
 static TIMER_CALLBACK( s2_ack_callback )
 {
-	const address_space *space = cpu_get_address_space(dcs.cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(dcs.cpu, ADDRESS_SPACE_PROGRAM);
 
 	/* if the output is full, stall for a usec */
 	if (IS_OUTPUT_FULL())
diff -Nru src-old/mame/audio/gottlieb.c src/mame/audio/gottlieb.c
--- src-old/mame/audio/gottlieb.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/audio/gottlieb.c	2010-08-19 00:26:14.000000000 -0700
@@ -42,7 +42,7 @@
 
 
 static void gottlieb1_sh_w(running_device *riot, UINT8 data);
-static void gottlieb2_sh_w(const address_space *space, UINT8 data);
+static void gottlieb2_sh_w(address_space *space, UINT8 data);
 static void trigger_sample(running_device *samples, UINT8 data);
 
 
@@ -369,7 +369,7 @@
  *
  *************************************/
 
-static void gottlieb2_sh_w(const address_space *space, UINT8 data)
+static void gottlieb2_sh_w(address_space *space, UINT8 data)
 {
 	/* when data is not 0xff, the transparent latch at A3 allows it to pass through unmolested */
 	if (data != 0xff)
diff -Nru src-old/mame/audio/harddriv.c src/mame/audio/harddriv.c
--- src-old/mame/audio/harddriv.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/audio/harddriv.c	2010-08-19 01:27:05.000000000 -0700
@@ -242,16 +242,16 @@
 READ16_HANDLER( hdsnd68k_320ports_r )
 {
 	harddriv_state *state = space->machine->driver_data<harddriv_state>();
-	const address_space *iospace = cpu_get_address_space(state->sounddsp, ADDRESS_SPACE_IO);
-	return memory_read_word(iospace, (offset & 7) << 1);
+	address_space *iospace = cpu_get_address_space(state->sounddsp, ADDRESS_SPACE_IO);
+	return iospace->read_word((offset & 7) << 1);
 }
 
 
 WRITE16_HANDLER( hdsnd68k_320ports_w )
 {
 	harddriv_state *state = space->machine->driver_data<harddriv_state>();
-	const address_space *iospace = cpu_get_address_space(state->sounddsp, ADDRESS_SPACE_IO);
-	memory_write_word(iospace, (offset & 7) << 1, data);
+	address_space *iospace = cpu_get_address_space(state->sounddsp, ADDRESS_SPACE_IO);
+	iospace->write_word((offset & 7) << 1, data);
 }
 
 
diff -Nru src-old/mame/audio/leland.c src/mame/audio/leland.c
--- src-old/mame/audio/leland.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/audio/leland.c	2010-08-19 01:27:05.000000000 -0700
@@ -380,7 +380,7 @@
 
 static STREAM_UPDATE( leland_80186_dma_update )
 {
-	const address_space *dmaspace = (const address_space *)param;
+	address_space *dmaspace = (address_space *)param;
 	stream_sample_t *buffer = outputs[0];
 	int i, j;
 
@@ -429,7 +429,7 @@
 				/* sample-rate convert to the output frequency */
 				for (j = 0; j < samples && count > 0; j++)
 				{
-					buffer[j] += ((int)memory_read_byte(dmaspace, source) - 0x80) * volume;
+					buffer[j] += ((int)dmaspace->read_byte(source) - 0x80) * volume;
 					frac += step;
 					source += frac >> 24;
 					count -= frac >> 24;
@@ -514,7 +514,7 @@
 static DEVICE_START( common_sh_start )
 {
 	running_machine *machine = device->machine;
-	const address_space *dmaspace = cputag_get_address_space(machine, "audiocpu", AS_PROGRAM);
+	address_space *dmaspace = cputag_get_address_space(machine, "audiocpu", AS_PROGRAM);
 	int i;
 
 	/* determine which sound hardware is installed */
diff -Nru src-old/mame/audio/mario.c src/mame/audio/mario.c
--- src-old/mame/audio/mario.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/audio/mario.c	2010-08-19 00:26:14.000000000 -0700
@@ -448,7 +448,7 @@
  *
  ****************************************************************/
 
-static void set_ea(const address_space *space, int ea)
+static void set_ea(address_space *space, int ea)
 {
 	mario_state	*state = space->machine->driver_data<mario_state>();
 	//printf("ea: %d\n", ea);
@@ -489,7 +489,7 @@
 static SOUND_RESET( mario )
 {
 	mario_state	*state = machine->driver_data<mario_state>();
-	const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 #if USE_8039
     set_ea(machine, 1);
diff -Nru src-old/mame/audio/segasnd.c src/mame/audio/segasnd.c
--- src-old/mame/audio/segasnd.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/audio/segasnd.c	2010-08-13 01:54:21.000000000 -0700
@@ -11,7 +11,6 @@
 
 #include "emu.h"
 #include "streams.h"
-#include "includes/segag80v.h"
 #include "cpu/mcs48/mcs48.h"
 #include "sound/sp0250.h"
 #include "segasnd.h"
diff -Nru src-old/mame/audio/seibu.c src/mame/audio/seibu.c
--- src-old/mame/audio/seibu.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/audio/seibu.c	2010-08-19 07:19:38.000000000 -0700
@@ -104,12 +104,12 @@
 
 void seibu_sound_decrypt(running_machine *machine,const char *cpu,int length)
 {
-	const address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, length);
 	UINT8 *rom = memory_region(machine, cpu);
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, (length < 0x10000) ? (length - 1) : 0x1fff, decrypt);
+	space->set_decrypted_region(0x0000, (length < 0x10000) ? (length - 1) : 0x1fff, decrypt);
 
 	for (i = 0;i < length;i++)
 	{
diff -Nru src-old/mame/audio/snk6502.c src/mame/audio/snk6502.c
--- src-old/mame/audio/snk6502.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/audio/snk6502.c	2010-08-26 20:55:49.000000000 -0700
@@ -42,14 +42,24 @@
 	INT16	form[16];
 } TONE;
 
-static TONE tone_channels[CHANNELS];
-static INT32 tone_clock_expire;
-static INT32 tone_clock;
-static sound_stream * tone_stream;
-
-static int Sound0StopOnRollover;
-static UINT8 LastPort1;
-
+typedef struct _snk6502_sound_state snk6502_sound_state;
+struct _snk6502_sound_state
+{
+	TONE tone_channels[CHANNELS];
+	INT32 tone_clock_expire;
+	INT32 tone_clock;
+	sound_stream * tone_stream;
+
+	running_device *samples;
+	UINT8 *ROM;
+	int Sound0StopOnRollover;
+	UINT8 LastPort1;
+
+	int hd38880_cmd;
+	UINT32 hd38880_addr;
+	int hd38880_data_bytes;
+	double hd38880_speed;
+};
 
 static const char *const sasuke_sample_names[] =
 {
@@ -372,13 +382,21 @@
 	DISCRETE_OUTPUT(NODE_23, 32760.0/12)
 DISCRETE_SOUND_END
 
+INLINE snk6502_sound_state *get_safe_token( running_device *device )
+{
+	assert(device != NULL);
+	assert(device->type() == SOUND_SNK6502);
+
+	return (snk6502_sound_state *)downcast<legacy_device_base *>(device)->token();
+}
 
-INLINE void validate_tone_channel(running_machine *machine, int channel)
+INLINE void validate_tone_channel(snk6502_sound_state *state, int channel)
 {
+	TONE *tone_channels = state->tone_channels;
+
 	if (!tone_channels[channel].mute)
 	{
-		UINT8 *ROM = memory_region(machine, "snk6502");
-		UINT8 romdata = ROM[tone_channels[channel].base + tone_channels[channel].offset];
+		UINT8 romdata = state->ROM[tone_channels[channel].base + tone_channels[channel].offset];
 
 		if (romdata != 0xff)
 			tone_channels[channel].sample_step = tone_channels[channel].sample_rate / (256 - romdata);
@@ -390,10 +408,12 @@
 static STREAM_UPDATE( snk6502_tone_update )
 {
 	stream_sample_t *buffer = outputs[0];
+	snk6502_sound_state *state = get_safe_token(device);
+	TONE *tone_channels = state->tone_channels;
 	int i;
 
 	for (i = 0; i < CHANNELS; i++)
-		validate_tone_channel(device->machine, i);
+		validate_tone_channel(state, i);
 
 	while (samples-- > 0)
 	{
@@ -420,29 +440,30 @@
 
 		*buffer++ = data;
 
-		tone_clock += FRAC_ONE;
-		if (tone_clock >= tone_clock_expire)
+		state->tone_clock += FRAC_ONE;
+		if (state->tone_clock >= state->tone_clock_expire)
 		{
 			for (i = 0; i < CHANNELS; i++)
 			{
 				tone_channels[i].offset++;
 				tone_channels[i].offset &= tone_channels[i].mask;
 
-				validate_tone_channel(device->machine, i);
+				validate_tone_channel(state, i);
 			}
 
-			if (tone_channels[0].offset == 0 && Sound0StopOnRollover)
+			if (tone_channels[0].offset == 0 && state->Sound0StopOnRollover)
 				tone_channels[0].mute = 1;
 
-			tone_clock -= tone_clock_expire;
+			state->tone_clock -= state->tone_clock_expire;
 		}
 
 	}
 }
 
 
-static void sasuke_build_waveform(int mask)
+static void sasuke_build_waveform(snk6502_sound_state *state, int mask)
 {
+	TONE *tone_channels = state->tone_channels;
 	int bit0, bit1, bit2, bit3;
 	int base;
 	int i;
@@ -483,8 +504,9 @@
 		tone_channels[0].form[i] *= 65535 / 16;
 }
 
-static void satansat_build_waveform(int mask)
+static void satansat_build_waveform(snk6502_sound_state *state, int mask)
 {
+	TONE *tone_channels = state->tone_channels;
 	int bit0, bit1, bit2, bit3;
 	int base;
 	int i;
@@ -521,8 +543,9 @@
 		tone_channels[1].form[i] *= 65535 / 16;
 }
 
-static void build_waveform(int channel, int mask)
+static void build_waveform(snk6502_sound_state *state, int channel, int mask)
 {
+	TONE *tone_channels = state->tone_channels;
 	int bit0, bit1, bit2, bit3;
 	int base;
 	int i;
@@ -596,8 +619,12 @@
 		tone_channels[channel].form[i] *= 65535 / 160;
 }
 
-void snk6502_set_music_freq(int freq)
+void snk6502_set_music_freq(running_machine *machine, int freq)
 {
+	running_device *device = machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	TONE *tone_channels = state->tone_channels;
+
 	int i;
 
 	for (i = 0; i < CHANNELS; i++)
@@ -610,31 +637,42 @@
 		tone_channels[i].sample_cur = 0;
 		tone_channels[i].sample_rate = (double)(freq * 8) / SAMPLE_RATE * FRAC_ONE;
 
-		build_waveform(i, 1);
+		build_waveform(state, i, 1);
 	}
 }
 
-void snk6502_set_music_clock(double clock_time)
+void snk6502_set_music_clock(running_machine *machine, double clock_time)
 {
-	tone_clock_expire = clock_time * SAMPLE_RATE * FRAC_ONE;
-	tone_clock = 0;
+	running_device *device = machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+
+	state->tone_clock_expire = clock_time * SAMPLE_RATE * FRAC_ONE;
+	state->tone_clock = 0;
 }
 
 static DEVICE_START( snk6502_sound )
 {
+	snk6502_sound_state *state = get_safe_token(device);
+
+	state->samples = device->machine->device("samples");
+	state->ROM = memory_region(device->machine, "snk6502");
+
 	// adjusted
-	snk6502_set_music_freq(43000);
+	snk6502_set_music_freq(device->machine, 43000);
 
 	// 38.99 Hz update (according to schematic)
-	snk6502_set_music_clock(M_LN2 * (RES_K(18) * 2 + RES_K(1)) * CAP_U(1));
+	snk6502_set_music_clock(device->machine, M_LN2 * (RES_K(18) * 2 + RES_K(1)) * CAP_U(1));
 
-	tone_stream = stream_create(device, 0, 1, SAMPLE_RATE, NULL, snk6502_tone_update);
+	state->tone_stream = stream_create(device, 0, 1, SAMPLE_RATE, NULL, snk6502_tone_update);
 }
 
 DEVICE_GET_INFO( snk6502_sound )
 {
 	switch (state)
 	{
+		/* --- the following bits of info are returned as 64-bit signed integers --- */
+		case DEVINFO_INT_TOKEN_BYTES:					info->i = sizeof(snk6502_sound_state);			break;
+
 		/* --- the following bits of info are returned as pointers to data or functions --- */
 		case DEVINFO_FCT_START:							info->start = DEVICE_START_NAME(snk6502_sound);	break;
 
@@ -644,15 +682,23 @@
 	}
 }
 
-int snk6502_music0_playing(void)
+int snk6502_music0_playing(running_machine *machine)
 {
+	running_device *device = machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	TONE *tone_channels = state->tone_channels;
+
 	return tone_channels[0].mute;
 }
 
 
 WRITE8_HANDLER( sasuke_sound_w )
 {
-	running_device *samples = space->machine->device("samples");
+	running_device *device = space->machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	running_device *samples = state->samples;
+	TONE *tone_channels = state->tone_channels;
+
 	switch (offset)
 	{
 	case 0:
@@ -669,25 +715,25 @@
             7   reset counter
         */
 
-		if ((~data & 0x01) && (LastPort1 & 0x01))
+		if ((~data & 0x01) && (state->LastPort1 & 0x01))
 			sample_start(samples, 0, 0, 0);
-		if ((~data & 0x02) && (LastPort1 & 0x02))
+		if ((~data & 0x02) && (state->LastPort1 & 0x02))
 			sample_start(samples, 1, 1, 0);
-		if ((~data & 0x04) && (LastPort1 & 0x04))
+		if ((~data & 0x04) && (state->LastPort1 & 0x04))
 			sample_start(samples, 2, 2, 0);
-		if ((~data & 0x08) && (LastPort1 & 0x08))
+		if ((~data & 0x08) && (state->LastPort1 & 0x08))
 			sample_start(samples, 3, 3, 0);
 
-		if ((data & 0x80) && (~LastPort1 & 0x80))
+		if ((data & 0x80) && (~state->LastPort1 & 0x80))
 		{
 			tone_channels[0].offset = 0;
 			tone_channels[0].mute = 0;
 		}
 
-		if ((~data & 0x80) && (LastPort1 & 0x80))
+		if ((~data & 0x80) && (state->LastPort1 & 0x80))
 			tone_channels[0].mute = 1;
 
-		LastPort1 = data;
+		state->LastPort1 = data;
 		break;
 
 	case 1:
@@ -708,17 +754,21 @@
 		tone_channels[0].base = 0x0000 + ((data & 0x70) << 4);
 		tone_channels[0].mask = 0xff;
 
-		Sound0StopOnRollover = 1;
+		state->Sound0StopOnRollover = 1;
 
 		/* bit 1-3 sound0 waveform control */
-		sasuke_build_waveform((data & 0x0e) >> 1);
+		sasuke_build_waveform(state, (data & 0x0e) >> 1);
 		break;
 	}
 }
 
 WRITE8_HANDLER( satansat_sound_w )
 {
-	running_device *samples = space->machine->device("samples");
+	running_device *device = space->machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	running_device *samples = state->samples;
+	TONE *tone_channels = state->tone_channels;
+
 	switch (offset)
 	{
 	case 0:
@@ -732,7 +782,7 @@
 		/* bit 1 = to 76477 */
 
 		/* bit 2 = analog sound trigger */
-		if (data & 0x04 && !(LastPort1 & 0x04))
+		if (data & 0x04 && !(state->LastPort1 & 0x04))
 			sample_start(samples, 0, 1, 0);
 
 		if (data & 0x08)
@@ -742,12 +792,12 @@
 		}
 
 		/* bit 4-6 sound0 waveform control */
-		sasuke_build_waveform((data & 0x70) >> 4);
+		sasuke_build_waveform(state, (data & 0x70) >> 4);
 
 		/* bit 7 sound1 waveform control */
-		satansat_build_waveform((data & 0x80) >> 7);
+		satansat_build_waveform(state, (data & 0x80) >> 7);
 
-		LastPort1 = data;
+		state->LastPort1 = data;
 		break;
 	case 1:
 		/*
@@ -761,7 +811,7 @@
 		tone_channels[1].base = 0x0800 + ((data & 0x60) << 4);
 		tone_channels[1].mask = 0x1ff;
 
-		Sound0StopOnRollover = 1;
+		state->Sound0StopOnRollover = 1;
 
 		if (data & 0x01)
 			tone_channels[0].mute = 0;
@@ -781,7 +831,11 @@
 
 WRITE8_HANDLER( vanguard_sound_w )
 {
-	running_device *samples = space->machine->device("samples");
+	running_device *device = space->machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	running_device *samples = state->samples;
+	TONE *tone_channels = state->tone_channels;
+
 	switch (offset)
 	{
 	case 0:
@@ -802,17 +856,17 @@
 		tone_channels[0].base = ((data & 0x07) << 8);
 		tone_channels[0].mask = 0xff;
 
-		Sound0StopOnRollover = 1;
+		state->Sound0StopOnRollover = 1;
 
 		/* play noise samples requested by sound command byte */
 		/* SHOT A */
-		if (data & 0x20 && !(LastPort1 & 0x20))
+		if (data & 0x20 && !(state->LastPort1 & 0x20))
 			sample_start(samples, 1, 0, 0);
-		else if (!(data & 0x20) && LastPort1 & 0x20)
+		else if (!(data & 0x20) && state->LastPort1 & 0x20)
 			sample_stop(samples, 1);
 
 		/* BOMB */
-		if (data & 0x80 && !(LastPort1 & 0x80))
+		if (data & 0x80 && !(state->LastPort1 & 0x80))
 			sample_start(samples, 2, 1, 0);
 
 		if (data & 0x08)
@@ -829,7 +883,7 @@
 		/* SHOT B */
 		sn76477_enable_w(space->machine->device("sn76477.2"), (data & 0x40) ? 0 : 1);
 
-		LastPort1 = data;
+		state->LastPort1 = data;
 		break;
 	case 1:
 		/*
@@ -871,13 +925,17 @@
             7   AS 8    (sound1 waveform)
         */
 
-		build_waveform(0, (data & 0x3) | ((data & 4) << 1) | ((data & 8) >> 1));
-		build_waveform(1, data >> 4);
+		build_waveform(state, 0, (data & 0x3) | ((data & 4) << 1) | ((data & 8) >> 1));
+		build_waveform(state, 1, data >> 4);
 	}
 }
 
 WRITE8_HANDLER( fantasy_sound_w )
 {
+	running_device *device = space->machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	TONE *tone_channels = state->tone_channels;
+
 	switch (offset)
 	{
 	case 0:
@@ -898,7 +956,7 @@
 		tone_channels[0].base = 0x0000 + ((data & 0x07) << 8);
 		tone_channels[0].mask = 0xff;
 
-		Sound0StopOnRollover = 0;
+		state->Sound0StopOnRollover = 0;
 
 		if (data & 0x08)
 			tone_channels[0].mute = 0;
@@ -919,7 +977,7 @@
 		/* BOMB */
 		discrete_sound_w(space->machine->device("discrete"), FANTASY_BOMB_EN, data & 0x80);
 
-		LastPort1 = data;
+		state->LastPort1 = data;
 		break;
 	case 1:
 		/*
@@ -961,8 +1019,8 @@
             7   AS 8    (sound1 waveform)
         */
 
-		build_waveform(0, (data & 0x9) | ((data & 2) << 1) | ((data & 4) >> 1));
-		build_waveform(1, data >> 4);
+		build_waveform(state, 0, (data & 0x9) | ((data & 2) << 1) | ((data & 4) >> 1));
+		build_waveform(state, 1, data >> 4);
 		break;
 	case 3:
 		/*
@@ -1012,11 +1070,6 @@
 #define HD38880_CMV	0x20
 #define HD68880_SYBS	0x0f
 
-static int	hd38880_cmd;
-static UINT32	hd38880_addr;
-static int	hd38880_data_bytes;
-static double	hd38880_speed;
-
 
 static void snk6502_speech_w(running_machine *machine, UINT8 data, const UINT16 *table, int start)
 {
@@ -1032,12 +1085,15 @@
         7
     */
 
+	running_device *device = machine->device("snk6502");
+	snk6502_sound_state *state = get_safe_token(device);
+	running_device *samples = state->samples;
+
 	if ((data & HD38880_CTP) && (data & HD38880_CMV))
 	{
-		running_device *samples = machine->device("samples");
 		data &= HD68880_SYBS;
 
-		switch (hd38880_cmd)
+		switch (state->hd38880_cmd)
 		{
 		case 0:
 			switch (data)
@@ -1045,15 +1101,14 @@
 			case HD38880_START:
 				logerror("speech: START\n");
 
-				if (hd38880_data_bytes == 5 && !sample_playing(samples, 0))
+				if (state->hd38880_data_bytes == 5 && !sample_playing(samples, 0))
 				{
 					int i;
 
 					for (i = 0; i < 16; i++)
 					{
-						if (table[i] && table[i] == hd38880_addr)
+						if (table[i] && table[i] == state->hd38880_addr)
 						{
-							running_device *samples = machine->device("samples");
 							sample_start(samples, 0, start + i, 0);
 							break;
 						}
@@ -1071,7 +1126,7 @@
 				break;
 
 			case HD38880_SYSPD:
-				hd38880_cmd = data;
+				state->hd38880_cmd = data;
 				break;
 
 			case HD38880_CONDT:
@@ -1079,9 +1134,9 @@
 				break;
 
 			case HD38880_ADSET:
-				hd38880_cmd = data;
-				hd38880_addr = 0;
-				hd38880_data_bytes = 0;
+				state->hd38880_cmd = data;
+				state->hd38880_addr = 0;
+				state->hd38880_data_bytes = 0;
 				break;
 
 			case HD38880_READ:
@@ -1089,11 +1144,11 @@
 				break;
 
 			case HD38880_INT1:
-				hd38880_cmd = data;
+				state->hd38880_cmd = data;
 				break;
 
 			case HD38880_INT2:
-				hd38880_cmd = data;
+				state->hd38880_cmd = data;
 				break;
 
 			case 0:
@@ -1118,7 +1173,7 @@
 			if ((data & 2) && (data & 8))
 				logerror("speech:   use external pitch control\n");
 
-			hd38880_cmd = 0;
+			state->hd38880_cmd = 0;
 			break;
 
 		case HD38880_INT2:
@@ -1129,21 +1184,21 @@
 			logerror("speech:   %sable repeat\n", data & 2 ? "en" : "dis");
 			logerror("speech:   %d operations\n", ((data & 8) == 0) || (data & 1) ? 10 : 8);
 
-			hd38880_cmd = 0;
+			state->hd38880_cmd = 0;
 			break;
 
 		case HD38880_SYSPD:
-			hd38880_speed = ((double)(data + 1)) / 10.0;
-			logerror("speech: SYSPD: %1.1f\n", hd38880_speed);
-			hd38880_cmd = 0;
+			state->hd38880_speed = ((double)(data + 1)) / 10.0;
+			logerror("speech: SYSPD: %1.1f\n", state->hd38880_speed);
+			state->hd38880_cmd = 0;
 			break;
 
 		case HD38880_ADSET:
-			hd38880_addr |= (data << (hd38880_data_bytes++ * 4));
-			if (hd38880_data_bytes == 5)
+			state->hd38880_addr |= (data << (state->hd38880_data_bytes++ * 4));
+			if (state->hd38880_data_bytes == 5)
 			{
-				logerror("speech: ADSET: 0x%05x\n", hd38880_addr);
-				hd38880_cmd = 0;
+				logerror("speech: ADSET: 0x%05x\n", state->hd38880_addr);
+				state->hd38880_cmd = 0;
 			}
 			break;
 		}
diff -Nru src-old/mame/audio/williams.c src/mame/audio/williams.c
--- src-old/mame/audio/williams.c	2010-07-16 04:59:31.000000000 -0700
+++ src/mame/audio/williams.c	2010-08-21 17:37:49.000000000 -0700
@@ -486,7 +486,7 @@
 
 void williams_cvsd_reset_w(int state)
 {
-	const address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
 
 	/* going high halts the CPU */
 	if (state)
@@ -581,7 +581,7 @@
 
 void williams_narc_data_w(int data)
 {
-	const address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
 
 	soundlatch_w(space, 0, data & 0xff);
 	cpu_set_input_line(sound_cpu, INPUT_LINE_NMI, (data & 0x100) ? CLEAR_LINE : ASSERT_LINE);
@@ -598,7 +598,7 @@
 	/* going high halts the CPU */
 	if (state)
 	{
-		const address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
+		address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
 		narc_master_bank_select_w(space, 0, 0);
 		narc_slave_bank_select_w(space, 0, 0);
 		init_audio_state(space->machine);
@@ -668,7 +668,7 @@
 
 void williams_adpcm_data_w(int data)
 {
-	const address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
 	soundlatch_w(space, 0, data & 0xff);
 	if (!(data & 0x200))
 	{
@@ -684,7 +684,7 @@
 	/* going high halts the CPU */
 	if (state)
 	{
-		const address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
+		address_space *space = cpu_get_address_space(sound_cpu, ADDRESS_SPACE_PROGRAM);
 		adpcm_bank_select_w(space, 0, 0);
 		init_audio_state(space->machine);
 		cpu_set_input_line(sound_cpu, INPUT_LINE_RESET, ASSERT_LINE);
diff -Nru src-old/mame/drivers/20pacgal.c src/mame/drivers/20pacgal.c
--- src-old/mame/drivers/20pacgal.c	2010-08-11 17:07:06.000000000 -0700
+++ src/mame/drivers/20pacgal.c	2010-08-12 07:06:03.000000000 -0700
@@ -455,7 +455,7 @@
  *
  *************************************/
 
-GAME( 2005, 25pacman,          0, 20pacgal, 25pacman, 25pacman, ROT90, "Namco", "Pacman - 25th Anniversary Edition (Rev 2.00)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE)
+GAME( 2005, 25pacman,          0, 20pacgal, 25pacman, 25pacman, ROT90, "Namco", "Pac-Man - 25th Anniversary Edition (Rev 2.00)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE)
 
 GAME( 2000, 20pacgal,          0, 20pacgal, 20pacgal, 20pacgal, ROT90, "Namco", "Ms. Pac-Man/Galaga - 20th Anniversary Class of 1981 Reunion (V1.08)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE)
 GAME( 2000, 20pacgalr4, 20pacgal, 20pacgal, 20pacgal, 20pacgal, ROT90, "Namco", "Ms. Pac-Man/Galaga - 20th Anniversary Class of 1981 Reunion (V1.04)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE)
diff -Nru src-old/mame/drivers/39in1.c src/mame/drivers/39in1.c
--- src-old/mame/drivers/39in1.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/39in1.c	2010-08-19 01:27:05.000000000 -0700
@@ -79,7 +79,7 @@
 static READ32_HANDLER( pxa255_gpio_r );
 static WRITE32_HANDLER( pxa255_gpio_w );
 
-static void pxa255_lcd_load_dma_descriptor(const address_space* space, UINT32 address, int channel);
+static void pxa255_lcd_load_dma_descriptor(address_space* space, UINT32 address, int channel);
 static void pxa255_lcd_irq_check(running_machine* machine);
 static void pxa255_lcd_dma_kickoff(running_machine* machine, int channel);
 static void pxa255_lcd_check_load_next_branch(running_machine* machine, int channel);
@@ -262,10 +262,11 @@
 
 	// Load the next descriptor
 
-	dma_regs->dsadr[channel] = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dma_regs->ddadr[channel] + 0x4);
-	dma_regs->dtadr[channel] = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dma_regs->ddadr[channel] + 0x8);
-	dma_regs->dcmd[channel]  = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dma_regs->ddadr[channel] + 0xc);
-	dma_regs->ddadr[channel] = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dma_regs->ddadr[channel]);
+	address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
+	dma_regs->dsadr[channel] = space->read_dword(dma_regs->ddadr[channel] + 0x4);
+	dma_regs->dtadr[channel] = space->read_dword(dma_regs->ddadr[channel] + 0x8);
+	dma_regs->dcmd[channel]  = space->read_dword(dma_regs->ddadr[channel] + 0xc);
+	dma_regs->ddadr[channel] = space->read_dword(dma_regs->ddadr[channel]);
 
 	// Start our end-of-transfer timer
 	switch(channel)
@@ -301,12 +302,13 @@
 	UINT16 temp16;
 	UINT32 temp32;
 
+	address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
 	switch(param)
 	{
 		case 3:
 			for(index = 0; index < count; index += 4)
 			{
-				state->words[index >> 2] = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sadr);
+				state->words[index >> 2] = space->read_dword(sadr);
 				state->samples[(index >> 1) + 0] = (INT16)(state->words[index >> 2] >> 16);
 				state->samples[(index >> 1) + 1] = (INT16)(state->words[index >> 2] & 0xffff);
 				sadr += 4;
@@ -319,18 +321,18 @@
 				switch(dma_regs->dcmd[param] & PXA255_DCMD_SIZE)
 				{
 					case PXA255_DCMD_SIZE_8:
-						temp8 = memory_read_byte_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sadr);
-						memory_write_byte_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tadr, temp8);
+						temp8 = space->read_byte(sadr);
+						space->write_byte(tadr, temp8);
 						index++;
 						break;
 					case PXA255_DCMD_SIZE_16:
-						temp16 = memory_read_word_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sadr);
-						memory_write_word_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tadr, temp16);
+						temp16 = space->read_word(sadr);
+						space->write_word(tadr, temp16);
 						index += 2;
 						break;
 					case PXA255_DCMD_SIZE_32:
-						temp32 = memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sadr);
-						memory_write_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tadr, temp32);
+						temp32 = space->read_dword(sadr);
+						space->write_dword(tadr, temp32);
 						index += 4;
 						break;
 					default:
@@ -1048,15 +1050,15 @@
 
 */
 
-static void pxa255_lcd_load_dma_descriptor(const address_space* space, UINT32 address, int channel)
+static void pxa255_lcd_load_dma_descriptor(address_space* space, UINT32 address, int channel)
 {
 	_39in1_state *state = space->machine->driver_data<_39in1_state>();
 	PXA255_LCD_Regs *lcd_regs = &state->lcd_regs;
 
-	lcd_regs->dma[channel].fdadr = memory_read_dword_32le(space, address);
-	lcd_regs->dma[channel].fsadr = memory_read_dword_32le(space, address + 0x04);
-	lcd_regs->dma[channel].fidr  = memory_read_dword_32le(space, address + 0x08);
-	lcd_regs->dma[channel].ldcmd = memory_read_dword_32le(space, address + 0x0c);
+	lcd_regs->dma[channel].fdadr = space->read_dword(address);
+	lcd_regs->dma[channel].fsadr = space->read_dword(address + 0x04);
+	lcd_regs->dma[channel].fidr  = space->read_dword(address + 0x08);
+	lcd_regs->dma[channel].ldcmd = space->read_dword(address + 0x0c);
 	verboselog( space->machine, 4, "pxa255_lcd_load_dma_descriptor, address = %08x, channel = %d\n", address, channel);
 	verboselog( space->machine, 4, "    DMA Frame Descriptor: %08x\n", lcd_regs->dma[channel].fdadr );
 	verboselog( space->machine, 4, "    DMA Frame Source Address: %08x\n", lcd_regs->dma[channel].fsadr );
@@ -1101,22 +1103,24 @@
 
 		if(lcd_regs->dma[channel].ldcmd & PXA255_LDCMD_PAL)
 		{
+			address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
 			int length = lcd_regs->dma[channel].ldcmd & 0x000fffff;
 			int index = 0;
 			for(index = 0; index < length; index += 2)
 			{
-				UINT16 color = memory_read_word_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), (lcd_regs->dma[channel].fsadr &~ 1) + index);
+				UINT16 color = space->read_word((lcd_regs->dma[channel].fsadr &~ 1) + index);
 				state->pxa255_lcd_palette[index >> 1] = (((((color >> 11) & 0x1f) << 3) | (color >> 13)) << 16) | (((((color >> 5) & 0x3f) << 2) | ((color >> 9) & 0x3)) << 8) | (((color & 0x1f) << 3) | ((color >> 2) & 0x7));
 				palette_set_color_rgb(machine, index >> 1, (((color >> 11) & 0x1f) << 3) | (color >> 13), (((color >> 5) & 0x3f) << 2) | ((color >> 9) & 0x3), ((color & 0x1f) << 3) | ((color >> 2) & 0x7));
 			}
 		}
 		else
 		{
+			address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
 			int length = lcd_regs->dma[channel].ldcmd & 0x000fffff;
 			int index = 0;
 			for(index = 0; index < length; index++)
 			{
-				state->pxa255_lcd_framebuffer[index] = memory_read_byte_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), lcd_regs->dma[channel].fsadr + index);
+				state->pxa255_lcd_framebuffer[index] = space->read_byte(lcd_regs->dma[channel].fsadr + index);
 			}
 		}
 	}
@@ -1131,10 +1135,11 @@
 	{
 		verboselog( machine, 4, "pxa255_lcd_check_load_next_branch: Taking branch\n" );
 		lcd_regs->fbr[channel] &= ~1;
-		//lcd_regs->fbr[channel] = (memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), lcd_regs->fbr[channel] & 0xfffffff0) & 0xfffffff0) | (lcd_regs->fbr[channel] & 0x00000003);
+		address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
+		//lcd_regs->fbr[channel] = (space->read_dword(lcd_regs->fbr[channel] & 0xfffffff0) & 0xfffffff0) | (lcd_regs->fbr[channel] & 0x00000003);
 		//printf( "%08x\n", lcd_regs->fbr[channel] );
-		pxa255_lcd_load_dma_descriptor(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), lcd_regs->fbr[channel] & 0xfffffff0, 0);
-		lcd_regs->fbr[channel] = (memory_read_dword_32le(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), lcd_regs->fbr[channel] & 0xfffffff0) & 0xfffffff0) | (lcd_regs->fbr[channel] & 0x00000003);
+		pxa255_lcd_load_dma_descriptor(space, lcd_regs->fbr[channel] & 0xfffffff0, 0);
+		lcd_regs->fbr[channel] = (space->read_dword(lcd_regs->fbr[channel] & 0xfffffff0) & 0xfffffff0) | (lcd_regs->fbr[channel] & 0x00000003);
 		pxa255_lcd_dma_kickoff(machine, 0);
 		if(lcd_regs->fbr[channel] & 2)
 		{
@@ -1430,7 +1435,7 @@
 	if (cpu_get_pc(space->cpu) == 0x2874)
 	{
 		state->state = 2;
-		state->magic = memory_read_byte_32le(space, 0x2d4ff0);
+		state->magic = space->read_byte(0x2d4ff0);
 	}
 	else if (offset == 0xa)
 	{
@@ -1456,7 +1461,8 @@
 	state->dmadac[1] = machine->device<dmadac_sound_device>("dac2");
 	state->eeprom = machine->device<eeprom_device>("eeprom");
 
-	memory_install_read32_handler (cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0xa0151648, 0xa015164b, 0, 0, prot_cheater_r);
+	address_space *space = machine->device<pxa255_device>("maincpu")->space(AS_PROGRAM);
+	memory_install_read32_handler (space, 0xa0151648, 0xa015164b, 0, 0, prot_cheater_r);
 }
 
 static ADDRESS_MAP_START( 39in1_map, ADDRESS_SPACE_PROGRAM, 32 )
diff -Nru src-old/mame/drivers/ace.c src/mame/drivers/ace.c
--- src-old/mame/drivers/ace.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/ace.c	2010-08-13 13:45:28.000000000 -0700
@@ -319,10 +319,19 @@
 	GFXDECODE_ENTRY( NULL          , 0x8000, scorelayout, 0, 2 )    /* the game dynamically modifies this */
 GFXDECODE_END
 
+static STATE_POSTLOAD( ace_postload )
+{
+	gfx_element_mark_dirty(machine->gfx[1], 0);
+	gfx_element_mark_dirty(machine->gfx[2], 0);
+	gfx_element_mark_dirty(machine->gfx[3], 0);
+	gfx_element_mark_dirty(machine->gfx[4], 0);
+}
+
 static MACHINE_START( ace )
 {
 	ace_state *state = machine->driver_data<ace_state>();
 	state_save_register_global_array(machine, state->objpos);
+	state_save_register_postload(machine, ace_postload, NULL);
 }
 
 static MACHINE_RESET( ace )
diff -Nru src-old/mame/drivers/aleck64.c src/mame/drivers/aleck64.c
--- src-old/mame/drivers/aleck64.c	2010-05-24 18:49:55.000000000 -0700
+++ src/mame/drivers/aleck64.c	2010-08-26 09:31:58.000000000 -0700
@@ -555,7 +555,7 @@
 INPUT_PORTS_END
 
 /* ?? */
-static const mips3_config config =
+static const mips3_config vr4300_config =
 {
 	16384,				/* code cache size */
 	8192,				/* data cache size */
@@ -573,7 +573,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", VR4300BE, 93750000)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(vr4300_config)
 	MDRV_CPU_PROGRAM_MAP(n64_map)
 	MDRV_CPU_VBLANK_INT("screen", n64_vblank)
 
diff -Nru src-old/mame/drivers/alg.c src/mame/drivers/alg.c
--- src-old/mame/drivers/alg.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/alg.c	2010-08-19 00:26:14.000000000 -0700
@@ -198,7 +198,7 @@
 
 static WRITE8_DEVICE_HANDLER( alg_cia_0_porta_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* switch banks as appropriate */
 	memory_set_bank(device->machine, "bank1", data & 1);
diff -Nru src-old/mame/drivers/alpha68k.c src/mame/drivers/alpha68k.c
--- src-old/mame/drivers/alpha68k.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/alpha68k.c	2010-08-30 08:20:58.000000000 -0700
@@ -26,6 +26,7 @@
     the microcontroller is able to write to anywhere within main memory.
 
     Gold Medalist (bootleg) has a 68705 in place of the Alpha controller.
+     (Kyros bootleg also? we have decapped MCU dumps of different types for it)
 
     V boards have more memory and double the amount of colours as II boards.
 
@@ -97,7 +98,7 @@
       * bit 6 (when "Difficulty" Dip Switch is set to DEF_STR( Hard ) or DEF_STR( Hardest ))
         determines if some coordonates are displayed.
 
- 8)  'gangwarsb'
+ 8)  'gangwars'
 
   - When "Coin Slots" Dip Switch is set to "1", COIN2 only adds ONE credit
     and this has nothing to do with the microcontroller stuff.
@@ -127,7 +128,7 @@
   - Add READ16_HANDLER( *_cycle_r ) for the following games :
       * timesold1  (based on the one from 'timesold')
       * btlfield  (based on the one from 'timesold')
-      * gangwarsb  (I splitted the one from 'gangwars')
+      * gangwars  (I splitted the one from 'gangwarsu')
       * skyadvnt, skyadvntu and skyadvntj
   - Change manufacturer for the following games :
       * timesold
@@ -180,7 +181,7 @@
 DIP locations verified from manuals for:
 - tnextspc
 - btlfield
-- gangwarsb
+- gangwars
 - skyadvnt
 - goldmedl
 - kyros
@@ -288,6 +289,7 @@
 	return input_port_read(space->machine, "IN0") | inp1 | inp2 << 4;
 }
 
+
 /******************************************************************************/
 
 static WRITE16_HANDLER( kyros_sound_w )
@@ -1371,7 +1373,9 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Free_Play ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( gangwars )
+
+
+static INPUT_PORTS_START( gangwarsu )
 	PORT_START("IN0")
 	ALPHA68K_PLAYER_INPUT_LSB( 1, IPT_BUTTON3, IPT_START1, IP_ACTIVE_LOW )
 
@@ -1423,9 +1427,9 @@
 	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
-/* Same as 'gangwars' but bits 0-3 of 2nd set of Dip Switches are different */
-static INPUT_PORTS_START( gangwarsb )
-	PORT_INCLUDE( gangwars )	/* See notes about "IN2" (microcontroller) */
+/* Same as 'gangwarsu' but bits 0-3 of 2nd set of Dip Switches are different */
+static INPUT_PORTS_START( gangwars )
+	PORT_INCLUDE( gangwarsu )	/* See notes about "IN2" (microcontroller) */
 
 	PORT_MODIFY("IN3")
 	PORT_DIPUNUSED_DIPLOC( 0x04, 0x04, "SW2:1" )		/* Listed as "Unused" */
@@ -1621,9 +1625,9 @@
 static const gfx_layout spritelayout_V =
 {
 	16,16,  /* 16*16 sprites */
-	0x5000,
+	RGN_FRAC(1,4),
 	4,      /* 4 bits per pixel */
-	{ 0, 0xa0000*8, 0x140000*8, 0x1e0000*8 },
+	{ RGN_FRAC(0,4), RGN_FRAC(1,4), RGN_FRAC(2,4), RGN_FRAC(3,4) },
 	{ 16*8+7, 16*8+6, 16*8+5, 16*8+4, 16*8+3, 16*8+2, 16*8+1, 16*8+0,
 	  7, 6, 5, 4, 3, 2, 1, 0 },
 	{ 0*8, 1*8, 2*8, 3*8, 4*8, 5*8, 6*8, 7*8,
@@ -2775,11 +2779,11 @@
 #endif
 
 	ROM_REGION( 0x80000, "audiocpu", 0 ) // banking is slightly different from other Alpha68kII games
-	ROM_LOAD( "38.bin",          0x00000,  0x08000, CRC(4bf251b8) SHA1(d69a6607e92dbe8081c7c66b6853f02d578ef73f) ) // we use the bootleg set instead
+	ROM_LOAD( "38.bin",          0x00000,  0x08000, BAD_DUMP CRC(4bf251b8) SHA1(d69a6607e92dbe8081c7c66b6853f02d578ef73f) ) // we use the bootleg set instead
 	ROM_CONTINUE(                0x18000,  0x08000 )
-	ROM_LOAD( "39.bin",          0x20000,  0x10000, CRC(1d92be86) SHA1(9b6e7141653ee7b7b1915a545d381419aec4e483) )
-	ROM_LOAD( "40.bin",          0x30000,  0x10000, CRC(8dafc4e8) SHA1(7d4898557ad638ab8461060bc7ae406d7d24c5a4) )
-	ROM_LOAD( "1.bin",           0x40000,  0x10000, CRC(1e78062c) SHA1(821c037edf32eb8b03e5c487d3bab0622337e80b) )
+	ROM_LOAD( "39.bin",          0x20000,  0x10000, BAD_DUMP CRC(1d92be86) SHA1(9b6e7141653ee7b7b1915a545d381419aec4e483) )
+	ROM_LOAD( "40.bin",          0x30000,  0x10000, BAD_DUMP CRC(8dafc4e8) SHA1(7d4898557ad638ab8461060bc7ae406d7d24c5a4) )
+	ROM_LOAD( "1.bin",           0x40000,  0x10000, BAD_DUMP CRC(1e78062c) SHA1(821c037edf32eb8b03e5c487d3bab0622337e80b) )
 //ZT
 	ROM_REGION( 0x010000, "gfx1", 0 )  /* chars */
 	ROM_LOAD( "gm.5",           0x000000, 0x08000, CRC(667f33f1) SHA1(6d05603b49927f09c9bb34e787b003eceaaf7062) )
@@ -2801,11 +2805,11 @@
 	ROM_LOAD16_BYTE( "gm2-7.bin", 0x20001, 0x10000, CRC(8d579505) SHA1(81f225edbba1cac65275e2929336d076afbbd2bf) )
 
 	ROM_REGION( 0x80000, "audiocpu", 0 ) // banking is slightly different from other Alpha68kII games
-	ROM_LOAD( "38.bin",          0x00000,  0x08000, CRC(4bf251b8) SHA1(d69a6607e92dbe8081c7c66b6853f02d578ef73f) ) // we use the bootleg set instead
+	ROM_LOAD( "38.bin",          0x00000,  0x08000, BAD_DUMP CRC(4bf251b8) SHA1(d69a6607e92dbe8081c7c66b6853f02d578ef73f) ) // we use the bootleg set instead
 	ROM_CONTINUE(                0x18000,  0x08000 )
-	ROM_LOAD( "39.bin",          0x20000,  0x10000, CRC(1d92be86) SHA1(9b6e7141653ee7b7b1915a545d381419aec4e483) )
-	ROM_LOAD( "40.bin",          0x30000,  0x10000, CRC(8dafc4e8) SHA1(7d4898557ad638ab8461060bc7ae406d7d24c5a4) )
-	ROM_LOAD( "1.bin",           0x40000,  0x10000, CRC(1e78062c) SHA1(821c037edf32eb8b03e5c487d3bab0622337e80b) )
+	ROM_LOAD( "39.bin",          0x20000,  0x10000, BAD_DUMP CRC(1d92be86) SHA1(9b6e7141653ee7b7b1915a545d381419aec4e483) )
+	ROM_LOAD( "40.bin",          0x30000,  0x10000, BAD_DUMP CRC(8dafc4e8) SHA1(7d4898557ad638ab8461060bc7ae406d7d24c5a4) )
+	ROM_LOAD( "1.bin",           0x40000,  0x10000, BAD_DUMP CRC(1e78062c) SHA1(821c037edf32eb8b03e5c487d3bab0622337e80b) )
 
 	ROM_REGION( 0x010000, "gfx1", 0 )  /* chars */
 	ROM_LOAD( "gm.5",           0x000000, 0x08000, CRC(667f33f1) SHA1(6d05603b49927f09c9bb34e787b003eceaaf7062) )
@@ -2919,31 +2923,37 @@
 	ROM_LOAD( "sachr0",         0x1e0000, 0x80000, CRC(e281b204) SHA1(50a041c701970013b84826d67c8002ccd291bfdd) )
 ROM_END
 
+
 ROM_START( gangwars )
 	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "u1",        0x00000, 0x20000, CRC(11433507) SHA1(df32c14d4105d3ad899dfa8e9dbc2a1fe51dfa6a) )
-	ROM_LOAD16_BYTE( "u2",        0x00001, 0x20000, CRC(44cc375f) SHA1(38fc402014a816d9b1f7680407175adecfa39efe) )
+	ROM_LOAD16_BYTE( "gw-ver1-e1.19c", 0x00000, 0x20000, CRC(7752478e) SHA1(7266dd0d2c57433191ae4d1d4e17b32c8c3c8c73) )
+	ROM_LOAD16_BYTE( "gw-ver1-e2.19d", 0x00001, 0x20000, CRC(c2f3b85e) SHA1(79c215d8b43ec7728e3745b359e64f6bb8240881) )
+	ROM_REGION16_BE( 0x40000, "user1", 0 ) /* Extra code bank */
+	ROM_LOAD16_BYTE( "gw-ver1-e3.18c", 0x00000, 0x20000, CRC(2a5fe86e) SHA1(0e668f51430983a17e1965143a0bf3aa4d3156ee) )
+	ROM_LOAD16_BYTE( "gw-ver1-e4.18d", 0x00001, 0x20000, CRC(c8b60c53) SHA1(352c3bcc18cf63bcb757d774c2c2247ce0c4e736) )
 
 	ROM_REGION( 0x90000, "audiocpu", 0 )   /* Sound CPU */
-	ROM_LOAD( "u12",            0x00000, 0x08000, CRC(2620caa1) SHA1(bd464abce0bedab68cb913321e76d83eb36ca374) )
-	ROM_CONTINUE(               0x18000, 0x08000 )
-	ROM_LOAD( "u9",             0x70000, 0x10000, CRC(9136745e) SHA1(d7a2bfeac69ab2dbd4565a5bd1abb1f3f1199b42) )
-	ROM_LOAD( "u10",            0x50000, 0x10000, CRC(636978ae) SHA1(5d8093bc43192c89e230af318609222a69866b6e) )
-	ROM_LOAD( "u11",            0x30000, 0x10000, CRC(2218ceb9) SHA1(69a843308cb0628ad856a09a33cd148f36ce0d24) )
-
-/*
-
-These roms are from the bootleg version, the original graphics
-should be the same.  The original uses 4 512k mask roms and 4 128k
-eeproms to store the same data.  The 512k roms are not dumped but
-the 128k ones are and match these ones.
-
-*/
+	ROM_LOAD( "gw-12.10f",      0x00000, 0x08000, CRC(e6d6c9cf) SHA1(c35a7a385592e55bdfe232d042f2228f4f7e9ffa) )
+	ROM_CONTINUE(                0x18000, 0x08000 )
+	ROM_LOAD( "gw-9.15f",      0x30000, 0x10000, CRC(84e5c946) SHA1(0b071d15b664a9c529713b1b896bdb5ebfa16c25) )
+	ROM_LOAD( "gw-10.13f",      0x50000, 0x10000, CRC(eb305d42) SHA1(93910cf60c1b8a87969888d8693c7d6782f1e799) )
+	ROM_LOAD( "gw-11.11f",      0x70000, 0x10000, CRC(7b9f2608) SHA1(8d61dfa32369450e396cc8a5d67c58eedb2167e6) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )  /* chars */
-	ROM_LOAD( "gwb_ic.m19",     0x000000, 0x10000, CRC(b75bf1d0) SHA1(c22c0049274c45701be0a7be2afc0517620a3a10) )
+	ROM_LOAD( "gw-13.4l",     0x000000, 0x10000, CRC(b75bf1d0) SHA1(c22c0049274c45701be0a7be2afc0517620a3a10) )
 
-	ROM_REGION( 0x280000, "gfx2", 0 )  /* sprites */
+	ROM_REGION( 0x400000, "gfx2", 0 )  /* sprites */
+	ROM_LOAD( "guernica-c3.17h",     0x000000, 0x80000, CRC(281a4138) SHA1(47fc0d91873996e05db87323c3b08a85863f90d9) )
+	ROM_LOAD( "gw-5.21f",            0x080000, 0x20000, CRC(9ef36031) SHA1(2faeb6a769991ab11403c6c37507b706a61bad69) )
+	ROM_LOAD( "guernica-c2.18h",     0x100000, 0x80000, CRC(2fcbea97) SHA1(eb60bf374ef771e379030d2b660a813be76bed5e) )
+	ROM_LOAD( "gw-6.20f",            0x180000, 0x20000, CRC(ddbbcda7) SHA1(1c368ad2a4ed31748c94545fc7c808aa53d76f64) )
+	ROM_LOAD( "guernica-c1.20h",     0x200000, 0x80000, CRC(5d384c3b) SHA1(9bc581501d52cc3280667a9ea34f2ba9c4b6ebb1) )
+	ROM_LOAD( "gw-7.18f",            0x280000, 0x20000, CRC(4656d377) SHA1(67d6f714cca3891be0173c543ece5e8ab699f645) )
+	ROM_LOAD( "guernica-c0.21h",     0x300000, 0x80000, CRC(e60c9882) SHA1(8cf1d9cf0db72977b303fd6b469611600631ab9a) )
+	ROM_LOAD( "gw-8.17f",            0x380000, 0x20000, CRC(798ed82a) SHA1(1932131e05aae0a77ba8d8ef947c1a3b0b5e3d43) )
+
+	/* there is a bootleg which is otherwise identical but has the following graphic ROM arrangement */
+#if 0
 	ROM_LOAD( "gwb_ic.308",     0x000000, 0x10000, CRC(321a2fdd) SHA1(b2f37f14a13bc2c2f78b2b0e27fde18a23146e22) )
 	ROM_LOAD( "gwb_ic.309",     0x010000, 0x10000, CRC(4d908f65) SHA1(6095a34ef4a6905d57c47af4a507dff3a04e5c07) )
 	ROM_LOAD( "gwb_ic.310",     0x020000, 0x10000, CRC(fc888541) SHA1(e732a03209a88fc7a23b4e4ff69a437d6fbfc2d1) )
@@ -2952,112 +2962,71 @@
 	ROM_LOAD( "gwb_ic.313",     0x050000, 0x10000, CRC(c18f4ca8) SHA1(f5cb666d5aa53f201b6664d1c18b89a211230e78) )
 	ROM_LOAD( "gwb_ic.314",     0x060000, 0x10000, CRC(dfc44b60) SHA1(311422d4ea77118c0058e9f1a824f74cfa79cb87) )
 	ROM_LOAD( "gwb_ic.307",     0x070000, 0x10000, CRC(28082a7f) SHA1(e30bade13e03bca49c1f7001c9440ce251ece15d) )
-//  ROM_LOAD( "gwb_ic.320",     0x080000, 0x10000, CRC(9a7b51d8) SHA1(0ab01972d838c938bfd07d7b4661a0ecd009b2cb) )
-	ROM_LOAD( "gwb_ic.280",     0x080000, 0x10000, CRC(222b3dcd) SHA1(f9afe24c01daefe61939672efa2cb68bcc7235f0) ) //AT
+	ROM_LOAD( "gwb_ic.280",     0x080000, 0x10000, CRC(222b3dcd) SHA1(f9afe24c01daefe61939672efa2cb68bcc7235f0) )
 	ROM_LOAD( "gwb_ic.321",     0x090000, 0x10000, CRC(6b421c7b) SHA1(d96f91dc7e5f46990b05701483edf43a828a8879) )
-	ROM_LOAD( "gwb_ic.300",     0x0a0000, 0x10000, CRC(f3fa0877) SHA1(7950ef86ee66d19693f0b7071a3a34d9200f5a19) )
-	ROM_LOAD( "gwb_ic.301",     0x0b0000, 0x10000, CRC(f8c866de) SHA1(c6baa41bab35d4d9e80c5c52db74e9eb6b9605f5) )
-	ROM_LOAD( "gwb_ic.302",     0x0c0000, 0x10000, CRC(5b0d587d) SHA1(852bec7d37d8cee33e5bc30080bf8a6a8d2472e5) )
-	ROM_LOAD( "gwb_ic.303",     0x0d0000, 0x10000, CRC(d8c0e102) SHA1(f660876ab3457230b1c37835f5ad1ccd1e8e821a) )
-	ROM_LOAD( "gwb_ic.304",     0x0e0000, 0x10000, CRC(b02bc9d8) SHA1(e0466b93c08363cceaba27c8d85e2609d12a10e7) )
-	ROM_LOAD( "gwb_ic.305",     0x0f0000, 0x10000, CRC(5e04a9aa) SHA1(663330b467eb6406719d4d6cf7b05835b1600a37) )
-	ROM_LOAD( "gwb_ic.306",     0x100000, 0x10000, CRC(e2172955) SHA1(af13776e6537e736815a1180a1f6bad385724b0c) )
-	ROM_LOAD( "gwb_ic.299",     0x110000, 0x10000, CRC(e39f5599) SHA1(3c08a8163b528ebbcb627c511ccc2edacf0653c2) )
-//  ROM_LOAD( "gwb_ic.318",     0x120000, 0x10000, CRC(9aeaddf9) SHA1(d609314015376672be8147b9eabbfe4c5611ab73) )
-	ROM_LOAD( "gwb_ic.320",     0x120000, 0x10000, CRC(9a7b51d8) SHA1(0ab01972d838c938bfd07d7b4661a0ecd009b2cb) ) //AT
-	ROM_LOAD( "gwb_ic.319",     0x130000, 0x10000, CRC(c5b862b7) SHA1(a48be3e32ae5a656d8d239796e6e7bddd4a0805b) )
-	ROM_LOAD( "gwb_ic.292",     0x140000, 0x10000, CRC(c125f7be) SHA1(5d68abd91fa4fa18275c0597c51ce6d3e743d84d) )
-	ROM_LOAD( "gwb_ic.293",     0x150000, 0x10000, CRC(c04fce8e) SHA1(499edd3b16770d20368f49e5c66c299740831ff0) )
-	ROM_LOAD( "gwb_ic.294",     0x160000, 0x10000, CRC(4eda3df5) SHA1(574fef723ebd8fa116b4a379036ee5ec3eb10c90) )
-	ROM_LOAD( "gwb_ic.295",     0x170000, 0x10000, CRC(6e60c475) SHA1(928494400bbdc3571cb5b1ccb51d39537c5fd904) )
-	ROM_LOAD( "gwb_ic.296",     0x180000, 0x10000, CRC(99b2a557) SHA1(7a4053909cb5f4b2a32f3caac4e2ccdb64c2ce84) )
-	ROM_LOAD( "gwb_ic.297",     0x190000, 0x10000, CRC(10373f63) SHA1(98ee65c68823530ad2eefd6e570db2f38b59c48e) )
-	ROM_LOAD( "gwb_ic.298",     0x1a0000, 0x10000, CRC(df37ec4d) SHA1(d2670dde87970a6f33ca3cd81bdc9991d663bac6) )
-	ROM_LOAD( "gwb_ic.291",     0x1b0000, 0x10000, CRC(beb07a2e) SHA1(f2751bef1850db7173f119fc0cfeefdf47ed7a86) )
-//  ROM_LOAD( "gwb_ic.316",     0x1c0000, 0x10000, CRC(655b1518) SHA1(d97fd911901f92786bc22dac8e085cf4fa0cb1e9) )
-	ROM_LOAD( "gwb_ic.318",     0x1c0000, 0x10000, CRC(9aeaddf9) SHA1(d609314015376672be8147b9eabbfe4c5611ab73) ) //AT
-	ROM_LOAD( "gwb_ic.317",     0x1d0000, 0x10000, CRC(1622fadd) SHA1(240eaf117145773e388220513c2906ad2ac5d68b) )
-	ROM_LOAD( "gwb_ic.284",     0x1e0000, 0x10000, CRC(4aa95d66) SHA1(e5bb51fd32a7e9dc23aa13de35b8757dc11f7908) )
-	ROM_LOAD( "gwb_ic.285",     0x1f0000, 0x10000, CRC(3a1f3ce0) SHA1(edd8820111a3ef9558286280dc819c6d9f21212f) )
-	ROM_LOAD( "gwb_ic.286",     0x200000, 0x10000, CRC(886e298b) SHA1(8e8b35a0b24c9c3a1d00079b60bdbaa6c8ce597b) )
-	ROM_LOAD( "gwb_ic.287",     0x210000, 0x10000, CRC(b9542e6a) SHA1(e5762db1a44a966d2c2b7e8a92abab577e24172f) )
-	ROM_LOAD( "gwb_ic.288",     0x220000, 0x10000, CRC(8e620056) SHA1(59ea29d681c4b001b656b4b8014b14ac78a69625) )
-	ROM_LOAD( "gwb_ic.289",     0x230000, 0x10000, CRC(c754d69f) SHA1(e64b8e1f719f5a95b7bcab2d25a40c8b819f7d4f) )
-	ROM_LOAD( "gwb_ic.290",     0x240000, 0x10000, CRC(306d1963) SHA1(2f19ba97b9bd1744b656095ae0244df2db03b09b) )
-	ROM_LOAD( "gwb_ic.283",     0x250000, 0x10000, CRC(b46e5761) SHA1(3c4c13c5896186fe36ace8704afeef84b0a0cb78) )
-//  ROM_LOAD( "gwb_ic.280",     0x260000, 0x10000, CRC(222b3dcd) SHA1(f9afe24c01daefe61939672efa2cb68bcc7235f0) )
-	ROM_LOAD( "gwb_ic.316",     0x260000, 0x10000, CRC(655b1518) SHA1(d97fd911901f92786bc22dac8e085cf4fa0cb1e9) ) //AT
-	ROM_LOAD( "gwb_ic.315",     0x270000, 0x10000, CRC(e7c9b103) SHA1(6f70ca9b6a7439f9250145477f682f7487e11710) )
 
-	ROM_REGION16_BE( 0x40000, "user1", 0 ) /* Extra code bank */
-	ROM_LOAD16_BYTE( "u3",        0x00000,  0x20000, CRC(de6fd3c0) SHA1(d957e8de3cb0eda1837376f687b8c272e97e1d11) )
-	ROM_LOAD16_BYTE( "u4",        0x00001,  0x20000, CRC(43f7f5d3) SHA1(13ea03cfae97d0067dcfdc6febb53dbe268a91eb) )
+	ROM_LOAD( "gwb_ic.300",     0x100000, 0x10000, CRC(f3fa0877) SHA1(7950ef86ee66d19693f0b7071a3a34d9200f5a19) )
+	ROM_LOAD( "gwb_ic.301",     0x110000, 0x10000, CRC(f8c866de) SHA1(c6baa41bab35d4d9e80c5c52db74e9eb6b9605f5) )
+	ROM_LOAD( "gwb_ic.302",     0x120000, 0x10000, CRC(5b0d587d) SHA1(852bec7d37d8cee33e5bc30080bf8a6a8d2472e5) )
+	ROM_LOAD( "gwb_ic.303",     0x130000, 0x10000, CRC(d8c0e102) SHA1(f660876ab3457230b1c37835f5ad1ccd1e8e821a) )
+	ROM_LOAD( "gwb_ic.304",     0x140000, 0x10000, CRC(b02bc9d8) SHA1(e0466b93c08363cceaba27c8d85e2609d12a10e7) )
+	ROM_LOAD( "gwb_ic.305",     0x150000, 0x10000, CRC(5e04a9aa) SHA1(663330b467eb6406719d4d6cf7b05835b1600a37) )
+	ROM_LOAD( "gwb_ic.306",     0x160000, 0x10000, CRC(e2172955) SHA1(af13776e6537e736815a1180a1f6bad385724b0c) )
+	ROM_LOAD( "gwb_ic.299",     0x170000, 0x10000, CRC(e39f5599) SHA1(3c08a8163b528ebbcb627c511ccc2edacf0653c2) )
+	ROM_LOAD( "gwb_ic.320",     0x180000, 0x10000, CRC(9a7b51d8) SHA1(0ab01972d838c938bfd07d7b4661a0ecd009b2cb) )
+	ROM_LOAD( "gwb_ic.319",     0x190000, 0x10000, CRC(c5b862b7) SHA1(a48be3e32ae5a656d8d239796e6e7bddd4a0805b) )
+
+	ROM_LOAD( "gwb_ic.292",     0x200000, 0x10000, CRC(c125f7be) SHA1(5d68abd91fa4fa18275c0597c51ce6d3e743d84d) )
+	ROM_LOAD( "gwb_ic.293",     0x210000, 0x10000, CRC(c04fce8e) SHA1(499edd3b16770d20368f49e5c66c299740831ff0) )
+	ROM_LOAD( "gwb_ic.294",     0x220000, 0x10000, CRC(4eda3df5) SHA1(574fef723ebd8fa116b4a379036ee5ec3eb10c90) )
+	ROM_LOAD( "gwb_ic.295",     0x230000, 0x10000, CRC(6e60c475) SHA1(928494400bbdc3571cb5b1ccb51d39537c5fd904) )
+	ROM_LOAD( "gwb_ic.296",     0x240000, 0x10000, CRC(99b2a557) SHA1(7a4053909cb5f4b2a32f3caac4e2ccdb64c2ce84) )
+	ROM_LOAD( "gwb_ic.297",     0x250000, 0x10000, CRC(10373f63) SHA1(98ee65c68823530ad2eefd6e570db2f38b59c48e) )
+	ROM_LOAD( "gwb_ic.298",     0x260000, 0x10000, CRC(df37ec4d) SHA1(d2670dde87970a6f33ca3cd81bdc9991d663bac6) )
+	ROM_LOAD( "gwb_ic.291",     0x270000, 0x10000, CRC(beb07a2e) SHA1(f2751bef1850db7173f119fc0cfeefdf47ed7a86) )
+	ROM_LOAD( "gwb_ic.318",     0x280000, 0x10000, CRC(9aeaddf9) SHA1(d609314015376672be8147b9eabbfe4c5611ab73) )
+	ROM_LOAD( "gwb_ic.317",     0x290000, 0x10000, CRC(1622fadd) SHA1(240eaf117145773e388220513c2906ad2ac5d68b) )
+
+	ROM_LOAD( "gwb_ic.284",     0x300000, 0x10000, CRC(4aa95d66) SHA1(e5bb51fd32a7e9dc23aa13de35b8757dc11f7908) )
+	ROM_LOAD( "gwb_ic.285",     0x310000, 0x10000, CRC(3a1f3ce0) SHA1(edd8820111a3ef9558286280dc819c6d9f21212f) )
+	ROM_LOAD( "gwb_ic.286",     0x320000, 0x10000, CRC(886e298b) SHA1(8e8b35a0b24c9c3a1d00079b60bdbaa6c8ce597b) )
+	ROM_LOAD( "gwb_ic.287",     0x330000, 0x10000, CRC(b9542e6a) SHA1(e5762db1a44a966d2c2b7e8a92abab577e24172f) )
+	ROM_LOAD( "gwb_ic.288",     0x340000, 0x10000, CRC(8e620056) SHA1(59ea29d681c4b001b656b4b8014b14ac78a69625) )
+	ROM_LOAD( "gwb_ic.289",     0x350000, 0x10000, CRC(c754d69f) SHA1(e64b8e1f719f5a95b7bcab2d25a40c8b819f7d4f) )
+	ROM_LOAD( "gwb_ic.290",     0x360000, 0x10000, CRC(306d1963) SHA1(2f19ba97b9bd1744b656095ae0244df2db03b09b) )
+	ROM_LOAD( "gwb_ic.283",     0x370000, 0x10000, CRC(b46e5761) SHA1(3c4c13c5896186fe36ace8704afeef84b0a0cb78) )
+	ROM_LOAD( "gwb_ic.316",     0x380000, 0x10000, CRC(655b1518) SHA1(d97fd911901f92786bc22dac8e085cf4fa0cb1e9) )
+	ROM_LOAD( "gwb_ic.315",     0x390000, 0x10000, CRC(e7c9b103) SHA1(6f70ca9b6a7439f9250145477f682f7487e11710) )
+#endif
 ROM_END
 
-ROM_START( gangwarsb )
+ROM_START( gangwarsu )
 	ROM_REGION( 0x40000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "gwb_ic.m15", 0x00000, 0x20000, CRC(7752478e) SHA1(7266dd0d2c57433191ae4d1d4e17b32c8c3c8c73) )
-	ROM_LOAD16_BYTE( "gwb_ic.m16", 0x00001, 0x20000, CRC(c2f3b85e) SHA1(79c215d8b43ec7728e3745b359e64f6bb8240881) )
+	ROM_LOAD16_BYTE( "u1",        0x00000, 0x20000, CRC(11433507) SHA1(df32c14d4105d3ad899dfa8e9dbc2a1fe51dfa6a) )
+	ROM_LOAD16_BYTE( "u2",        0x00001, 0x20000, CRC(44cc375f) SHA1(38fc402014a816d9b1f7680407175adecfa39efe) )
+	ROM_REGION16_BE( 0x40000, "user1", 0 ) /* Extra code bank */
+	ROM_LOAD16_BYTE( "u3",        0x00000,  0x20000, CRC(de6fd3c0) SHA1(d957e8de3cb0eda1837376f687b8c272e97e1d11) )
+	ROM_LOAD16_BYTE( "u4",        0x00001,  0x20000, CRC(43f7f5d3) SHA1(13ea03cfae97d0067dcfdc6febb53dbe268a91eb) )
 
 	ROM_REGION( 0x90000, "audiocpu", 0 )   /* Sound CPU */
-	ROM_LOAD( "gwb_ic.380",      0x00000, 0x08000, CRC(e6d6c9cf) SHA1(c35a7a385592e55bdfe232d042f2228f4f7e9ffa) )
-	ROM_CONTINUE(                0x18000, 0x08000 )
-	ROM_LOAD( "gwb_ic.419",      0x30000, 0x10000, CRC(84e5c946) SHA1(0b071d15b664a9c529713b1b896bdb5ebfa16c25) )
-	ROM_LOAD( "gwb_ic.420",      0x50000, 0x10000, CRC(eb305d42) SHA1(93910cf60c1b8a87969888d8693c7d6782f1e799) )
-	ROM_LOAD( "gwb_ic.421",      0x70000, 0x10000, CRC(7b9f2608) SHA1(8d61dfa32369450e396cc8a5d67c58eedb2167e6) )
+	ROM_LOAD( "u12",            0x00000, 0x08000, CRC(2620caa1) SHA1(bd464abce0bedab68cb913321e76d83eb36ca374) )
+	ROM_CONTINUE(               0x18000, 0x08000 )
+	ROM_LOAD( "u9",             0x70000, 0x10000, CRC(9136745e) SHA1(d7a2bfeac69ab2dbd4565a5bd1abb1f3f1199b42) )
+	ROM_LOAD( "u10",            0x50000, 0x10000, CRC(636978ae) SHA1(5d8093bc43192c89e230af318609222a69866b6e) )
+	ROM_LOAD( "u11",            0x30000, 0x10000, CRC(2218ceb9) SHA1(69a843308cb0628ad856a09a33cd148f36ce0d24) )
 
 	ROM_REGION( 0x020000, "gfx1", 0 )  /* chars */
 	ROM_LOAD( "gwb_ic.m19",     0x000000, 0x10000, CRC(b75bf1d0) SHA1(c22c0049274c45701be0a7be2afc0517620a3a10) )
 
-	ROM_REGION( 0x280000, "gfx2", 0 )  /* sprites */
-	ROM_LOAD( "gwb_ic.308",     0x000000, 0x10000, CRC(321a2fdd) SHA1(b2f37f14a13bc2c2f78b2b0e27fde18a23146e22) )
-	ROM_LOAD( "gwb_ic.309",     0x010000, 0x10000, CRC(4d908f65) SHA1(6095a34ef4a6905d57c47af4a507dff3a04e5c07) )
-	ROM_LOAD( "gwb_ic.310",     0x020000, 0x10000, CRC(fc888541) SHA1(e732a03209a88fc7a23b4e4ff69a437d6fbfc2d1) )
-	ROM_LOAD( "gwb_ic.311",     0x030000, 0x10000, CRC(181b128b) SHA1(2646c9f9cca6277ddd764c07478798c8af3eb297) )
-	ROM_LOAD( "gwb_ic.312",     0x040000, 0x10000, CRC(930665f3) SHA1(03af85c45acb9600b27dcdd6ec96d147046030e5) )
-	ROM_LOAD( "gwb_ic.313",     0x050000, 0x10000, CRC(c18f4ca8) SHA1(f5cb666d5aa53f201b6664d1c18b89a211230e78) )
-	ROM_LOAD( "gwb_ic.314",     0x060000, 0x10000, CRC(dfc44b60) SHA1(311422d4ea77118c0058e9f1a824f74cfa79cb87) )
-	ROM_LOAD( "gwb_ic.307",     0x070000, 0x10000, CRC(28082a7f) SHA1(e30bade13e03bca49c1f7001c9440ce251ece15d) )
-//  ROM_LOAD( "gwb_ic.320",     0x080000, 0x10000, CRC(9a7b51d8) SHA1(0ab01972d838c938bfd07d7b4661a0ecd009b2cb) )
-	ROM_LOAD( "gwb_ic.280",     0x080000, 0x10000, CRC(222b3dcd) SHA1(f9afe24c01daefe61939672efa2cb68bcc7235f0) ) //AT
-	ROM_LOAD( "gwb_ic.321",     0x090000, 0x10000, CRC(6b421c7b) SHA1(d96f91dc7e5f46990b05701483edf43a828a8879) )
-	ROM_LOAD( "gwb_ic.300",     0x0a0000, 0x10000, CRC(f3fa0877) SHA1(7950ef86ee66d19693f0b7071a3a34d9200f5a19) )
-	ROM_LOAD( "gwb_ic.301",     0x0b0000, 0x10000, CRC(f8c866de) SHA1(c6baa41bab35d4d9e80c5c52db74e9eb6b9605f5) )
-	ROM_LOAD( "gwb_ic.302",     0x0c0000, 0x10000, CRC(5b0d587d) SHA1(852bec7d37d8cee33e5bc30080bf8a6a8d2472e5) )
-	ROM_LOAD( "gwb_ic.303",     0x0d0000, 0x10000, CRC(d8c0e102) SHA1(f660876ab3457230b1c37835f5ad1ccd1e8e821a) )
-	ROM_LOAD( "gwb_ic.304",     0x0e0000, 0x10000, CRC(b02bc9d8) SHA1(e0466b93c08363cceaba27c8d85e2609d12a10e7) )
-	ROM_LOAD( "gwb_ic.305",     0x0f0000, 0x10000, CRC(5e04a9aa) SHA1(663330b467eb6406719d4d6cf7b05835b1600a37) )
-	ROM_LOAD( "gwb_ic.306",     0x100000, 0x10000, CRC(e2172955) SHA1(af13776e6537e736815a1180a1f6bad385724b0c) )
-	ROM_LOAD( "gwb_ic.299",     0x110000, 0x10000, CRC(e39f5599) SHA1(3c08a8163b528ebbcb627c511ccc2edacf0653c2) )
-//  ROM_LOAD( "gwb_ic.318",     0x120000, 0x10000, CRC(9aeaddf9) SHA1(d609314015376672be8147b9eabbfe4c5611ab73) )
-	ROM_LOAD( "gwb_ic.320",     0x120000, 0x10000, CRC(9a7b51d8) SHA1(0ab01972d838c938bfd07d7b4661a0ecd009b2cb) ) //AT
-	ROM_LOAD( "gwb_ic.319",     0x130000, 0x10000, CRC(c5b862b7) SHA1(a48be3e32ae5a656d8d239796e6e7bddd4a0805b) )
-	ROM_LOAD( "gwb_ic.292",     0x140000, 0x10000, CRC(c125f7be) SHA1(5d68abd91fa4fa18275c0597c51ce6d3e743d84d) )
-	ROM_LOAD( "gwb_ic.293",     0x150000, 0x10000, CRC(c04fce8e) SHA1(499edd3b16770d20368f49e5c66c299740831ff0) )
-	ROM_LOAD( "gwb_ic.294",     0x160000, 0x10000, CRC(4eda3df5) SHA1(574fef723ebd8fa116b4a379036ee5ec3eb10c90) )
-	ROM_LOAD( "gwb_ic.295",     0x170000, 0x10000, CRC(6e60c475) SHA1(928494400bbdc3571cb5b1ccb51d39537c5fd904) )
-	ROM_LOAD( "gwb_ic.296",     0x180000, 0x10000, CRC(99b2a557) SHA1(7a4053909cb5f4b2a32f3caac4e2ccdb64c2ce84) )
-	ROM_LOAD( "gwb_ic.297",     0x190000, 0x10000, CRC(10373f63) SHA1(98ee65c68823530ad2eefd6e570db2f38b59c48e) )
-	ROM_LOAD( "gwb_ic.298",     0x1a0000, 0x10000, CRC(df37ec4d) SHA1(d2670dde87970a6f33ca3cd81bdc9991d663bac6) )
-	ROM_LOAD( "gwb_ic.291",     0x1b0000, 0x10000, CRC(beb07a2e) SHA1(f2751bef1850db7173f119fc0cfeefdf47ed7a86) )
-//  ROM_LOAD( "gwb_ic.316",     0x1c0000, 0x10000, CRC(655b1518) SHA1(d97fd911901f92786bc22dac8e085cf4fa0cb1e9) )
-	ROM_LOAD( "gwb_ic.318",     0x1c0000, 0x10000, CRC(9aeaddf9) SHA1(d609314015376672be8147b9eabbfe4c5611ab73) ) //AT
-	ROM_LOAD( "gwb_ic.317",     0x1d0000, 0x10000, CRC(1622fadd) SHA1(240eaf117145773e388220513c2906ad2ac5d68b) )
-	ROM_LOAD( "gwb_ic.284",     0x1e0000, 0x10000, CRC(4aa95d66) SHA1(e5bb51fd32a7e9dc23aa13de35b8757dc11f7908) )
-	ROM_LOAD( "gwb_ic.285",     0x1f0000, 0x10000, CRC(3a1f3ce0) SHA1(edd8820111a3ef9558286280dc819c6d9f21212f) )
-	ROM_LOAD( "gwb_ic.286",     0x200000, 0x10000, CRC(886e298b) SHA1(8e8b35a0b24c9c3a1d00079b60bdbaa6c8ce597b) )
-	ROM_LOAD( "gwb_ic.287",     0x210000, 0x10000, CRC(b9542e6a) SHA1(e5762db1a44a966d2c2b7e8a92abab577e24172f) )
-	ROM_LOAD( "gwb_ic.288",     0x220000, 0x10000, CRC(8e620056) SHA1(59ea29d681c4b001b656b4b8014b14ac78a69625) )
-	ROM_LOAD( "gwb_ic.289",     0x230000, 0x10000, CRC(c754d69f) SHA1(e64b8e1f719f5a95b7bcab2d25a40c8b819f7d4f) )
-	ROM_LOAD( "gwb_ic.290",     0x240000, 0x10000, CRC(306d1963) SHA1(2f19ba97b9bd1744b656095ae0244df2db03b09b) )
-	ROM_LOAD( "gwb_ic.283",     0x250000, 0x10000, CRC(b46e5761) SHA1(3c4c13c5896186fe36ace8704afeef84b0a0cb78) )
-//  ROM_LOAD( "gwb_ic.280",     0x260000, 0x10000, CRC(222b3dcd) SHA1(f9afe24c01daefe61939672efa2cb68bcc7235f0) )
-	ROM_LOAD( "gwb_ic.316",     0x260000, 0x10000, CRC(655b1518) SHA1(d97fd911901f92786bc22dac8e085cf4fa0cb1e9) ) //AT
-	ROM_LOAD( "gwb_ic.315",     0x270000, 0x10000, CRC(e7c9b103) SHA1(6f70ca9b6a7439f9250145477f682f7487e11710) )
-
-	ROM_REGION16_BE( 0x40000, "user1", 0 ) /* Extra code bank */
-	ROM_LOAD16_BYTE( "gwb_ic.m17", 0x00000, 0x20000, CRC(2a5fe86e) SHA1(0e668f51430983a17e1965143a0bf3aa4d3156ee) )
-	ROM_LOAD16_BYTE( "gwb_ic.m18", 0x00001, 0x20000, CRC(c8b60c53) SHA1(352c3bcc18cf63bcb757d774c2c2247ce0c4e736) )
+	ROM_REGION( 0x400000, "gfx2", 0 )  /* sprites */
+	ROM_LOAD( "guernica-c3.17h",     0x000000, 0x80000, CRC(281a4138) SHA1(47fc0d91873996e05db87323c3b08a85863f90d9) )
+	ROM_LOAD( "gw-5.21f",            0x080000, 0x20000, CRC(9ef36031) SHA1(2faeb6a769991ab11403c6c37507b706a61bad69) )
+	ROM_LOAD( "guernica-c2.18h",     0x100000, 0x80000, CRC(2fcbea97) SHA1(eb60bf374ef771e379030d2b660a813be76bed5e) )
+	ROM_LOAD( "gw-6.20f",            0x180000, 0x20000, CRC(ddbbcda7) SHA1(1c368ad2a4ed31748c94545fc7c808aa53d76f64) )
+	ROM_LOAD( "guernica-c1.20h",     0x200000, 0x80000, CRC(5d384c3b) SHA1(9bc581501d52cc3280667a9ea34f2ba9c4b6ebb1) )
+	ROM_LOAD( "gw-7.18f",            0x280000, 0x20000, CRC(4656d377) SHA1(67d6f714cca3891be0173c543ece5e8ab699f645) )
+	ROM_LOAD( "guernica-c0.21h",     0x300000, 0x80000, CRC(e60c9882) SHA1(8cf1d9cf0db72977b303fd6b469611600631ab9a) )
+	ROM_LOAD( "gw-8.17f",            0x380000, 0x20000, CRC(798ed82a) SHA1(1932131e05aae0a77ba8d8ef947c1a3b0b5e3d43) )
 ROM_END
 
 ROM_START( sbasebal )
@@ -3128,106 +3097,6 @@
 
 /******************************************************************************/
 
-static READ16_HANDLER( timesold_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x4];
-
-	if (cpu_get_pc(space->cpu) == 0x9ea2 && (ret & 0xff00) == 0)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return 0x100 | (ret & 0xff);
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( timesold1_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x4];
-
-	if (cpu_get_pc(space->cpu) == 0x9e20 && (ret & 0xff00) == 0)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return 0x100 | (ret & 0xff);
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( btlfield_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x4];
-
-	if (cpu_get_pc(space->cpu) == 0x9e1c && (ret & 0xff00) == 0)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return 0x100 | (ret & 0xff);
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( skysoldr_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x4];
-
-	if (cpu_get_pc(space->cpu) == 0x1f4e && (ret & 0xff00) == 0)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return 0x100 | (ret & 0xff);
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( skyadvnt_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x4];
-
-	if (cpu_get_pc(space->cpu) == 0x1f78 && (ret & 0xff00) == 0)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return 0x100 | (ret & 0xff);
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( gangwars_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x103];
-
-	if (cpu_get_pc(space->cpu) == 0xbbb6)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return (ret + 2) & 0xff;
-	}
-
-	return ret;
-}
-
-static READ16_HANDLER( gangwarsb_cycle_r )
-{
-	alpha68k_state *state = space->machine->driver_data<alpha68k_state>();
-	int ret = state->shared_ram[0x103];
-
-	if (cpu_get_pc(space->cpu) == 0xbbca)
-	{
-		cpu_spinuntil_int(space->cpu);
-		return (ret + 2) & 0xff;
-	}
-
-	return ret;
-}
-
-/******************************************************************************/
-
 static DRIVER_INIT( sstingry )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
@@ -3265,7 +3134,6 @@
 static DRIVER_INIT( timesold )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, timesold_cycle_r);
 	state->invert_controls = 0;
 	state->microcontroller_id = 0;
 	state->coin_id = 0x22 | (0x22 << 8);
@@ -3274,7 +3142,6 @@
 static DRIVER_INIT( timesold1 )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, timesold1_cycle_r);
 	state->invert_controls = 1;
 	state->microcontroller_id = 0;
 	state->coin_id = 0x22 | (0x22 << 8);
@@ -3283,7 +3150,6 @@
 static DRIVER_INIT( btlfield )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, btlfield_cycle_r);
 	state->invert_controls = 1;
 	state->microcontroller_id = 0;
 	state->coin_id = 0x22 | (0x22 << 8);
@@ -3301,7 +3167,6 @@
 static DRIVER_INIT( skysoldr )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, skysoldr_cycle_r);
 	memory_set_bankptr(machine, "bank8", (memory_region(machine, "user1")) + 0x40000);
 	state->invert_controls = 0;
 	state->microcontroller_id = 0;
@@ -3328,7 +3193,6 @@
 static DRIVER_INIT( skyadvnt )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, skyadvnt_cycle_r);
 	state->invert_controls = 0;
 	state->microcontroller_id = 0x8814;
 	state->coin_id = 0x22 | (0x22 << 8);
@@ -3337,26 +3201,23 @@
 static DRIVER_INIT( skyadvntu )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40008, 0x40009, 0, 0, skyadvnt_cycle_r);
 	state->invert_controls = 0;
 	state->microcontroller_id = 0x8814;
 	state->coin_id = 0x23 | (0x24 << 8);
 }
 
-static DRIVER_INIT( gangwars )
+static DRIVER_INIT( gangwarsu )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40206, 0x40207, 0, 0, gangwars_cycle_r);
 	memory_set_bankptr(machine, "bank8", memory_region(machine, "user1"));
 	state->invert_controls = 0;
 	state->microcontroller_id = 0x8512;
 	state->coin_id = 0x23 | (0x24 << 8);
 }
 
-static DRIVER_INIT( gangwarsb )
+static DRIVER_INIT( gangwars )
 {
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x40206, 0x40207, 0, 0, gangwarsb_cycle_r);
 	memory_set_bankptr(machine, "bank8", memory_region(machine, "user1"));
 	state->invert_controls = 0;
 	state->microcontroller_id = 0x8512;
@@ -3368,7 +3229,12 @@
 	alpha68k_state *state = machine->driver_data<alpha68k_state>();
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 
-	/* Game hangs on divide by zero?!  Patch it */
+	/* Patch protection check, it does a divide by zero because the MCU is trying to
+       calculate the ball speed when a strike is scored, notice that current emulation
+       just returns 49 mi/h every time that this event happens.
+       68k reads at [0x4023e], then subtracts this value with [0x41838], presumably it's raw speed minus angle.
+       main CPU then writes the result to RAM location [0x41866], probably just to signal the result to the MCU.
+       */
 	rom[0xb672/2] = 0x4e71;
 
 	/* And patch the ROM checksums */
@@ -3397,28 +3263,35 @@
 
 /******************************************************************************/
 
-GAME( 1986, sstingry,  0,        sstingry,       sstingry, sstingry, ROT90, "Alpha Denshi Co.",   "Super Stingray", GAME_SUPPORTS_SAVE )
-GAME( 1987, kyros,     0,        kyros,          kyros,    kyros,    ROT90, "Alpha Denshi Co. (World Games Inc. license)", "Kyros", GAME_SUPPORTS_SAVE )
-GAME( 1986, kyrosj,    kyros,    kyros,          kyros,    kyros,    ROT90, "Alpha Denshi Co.",   "Kyros No Yakata (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1987, jongbou,   0,        jongbou,        jongbou,  jongbou,  ROT90, "SNK",                "Mahjong Block Jongbou (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1988, paddlema,  0,        alpha68k_I,     paddlema, paddlema, ROT90, "SNK",                "Paddle Mania", GAME_SUPPORTS_SAVE )
-GAME( 1987, timesold,  0,        alpha68k_II,    timesold, timesold, ROT90, "Alpha Denshi Co. (SNK/Romstar license)", "Time Soldiers (US Rev 3)", GAME_SUPPORTS_SAVE )
-GAME( 1987, timesold1, timesold, alpha68k_II,    timesold, timesold1,ROT90, "Alpha Denshi Co. (SNK/Romstar license)", "Time Soldiers (US Rev 1)", GAME_SUPPORTS_SAVE )
-GAME( 1987, btlfield,  timesold, alpha68k_II,    btlfield, btlfield, ROT90, "Alpha Denshi Co. (SNK license)", "Battle Field (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1987, btlfieldb, timesold, btlfieldb,      btlfieldb,btlfieldb,ROT90, "bootleg",            "Battle Field (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1986, sstingry,  0,        sstingry,       sstingry, sstingry, ROT90, "Alpha Denshi Co.",                                  "Super Stingray", GAME_SUPPORTS_SAVE )
+
+GAME( 1987, kyros,     0,        kyros,          kyros,    kyros,    ROT90, "Alpha Denshi Co. (World Games Inc. license)",       "Kyros", GAME_SUPPORTS_SAVE )
+GAME( 1986, kyrosj,    kyros,    kyros,          kyros,    kyros,    ROT90, "Alpha Denshi Co.",                                  "Kyros No Yakata (Japan)", GAME_SUPPORTS_SAVE )
+
+GAME( 1987, jongbou,   0,        jongbou,        jongbou,  jongbou,  ROT90, "SNK",                                               "Mahjong Block Jongbou (Japan)", GAME_SUPPORTS_SAVE )
+
+GAME( 1988, paddlema,  0,        alpha68k_I,     paddlema, paddlema, ROT90, "SNK",                                               "Paddle Mania", GAME_SUPPORTS_SAVE )
+
+GAME( 1987, timesold,  0,        alpha68k_II,    timesold, timesold, ROT90, "Alpha Denshi Co. (SNK/Romstar license)",            "Time Soldiers (US Rev 3)", GAME_SUPPORTS_SAVE )
+GAME( 1987, timesold1, timesold, alpha68k_II,    timesold, timesold1,ROT90, "Alpha Denshi Co. (SNK/Romstar license)",            "Time Soldiers (US Rev 1)", GAME_SUPPORTS_SAVE )
+
+GAME( 1987, btlfield,  timesold, alpha68k_II,    btlfield, btlfield, ROT90, "Alpha Denshi Co. (SNK license)",                    "Battle Field (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1987, btlfieldb, timesold, btlfieldb,      btlfieldb,btlfieldb,ROT90, "bootleg",                                           "Battle Field (bootleg)", GAME_SUPPORTS_SAVE )
+
 GAME( 1988, skysoldr,  0,        alpha68k_II,    skysoldr, skysoldr, ROT90, "Alpha Denshi Co. (SNK of America/Romstar license)", "Sky Soldiers (US)", GAME_SUPPORTS_SAVE )
-GAME( 1988, goldmedl,  0,        alpha68k_II_gm, goldmedl, goldmedl, ROT0,  "SNK",                "Gold Medalist", GAME_SUPPORTS_SAVE )
-GAME( 1988, goldmedla, goldmedl, alpha68k_II_gm, goldmedl, goldmedla,ROT0,  "SNK",                "Gold Medalist (alt)", GAME_SUPPORTS_SAVE )
-GAME( 1988, goldmedlb, goldmedl, alpha68k_II_gm, goldmedl, goldmedla,ROT0,  "bootleg",            "Gold Medalist (bootleg)", GAME_NOT_WORKING )
-GAME( 1989, skyadvnt,  0,        alpha68k_V,     skyadvnt, skyadvnt, ROT90, "Alpha Denshi Co.",   "Sky Adventure (World)", GAME_SUPPORTS_SAVE )
-GAME( 1989, skyadvntu, skyadvnt, alpha68k_V,     skyadvntu,skyadvntu,ROT90, "Alpha Denshi Co. (SNK of America license)", "Sky Adventure (US)", GAME_SUPPORTS_SAVE )
-GAME( 1989, skyadvntj, skyadvnt, alpha68k_V,     skyadvnt, skyadvnt, ROT90, "Alpha Denshi Co.",   "Sky Adventure (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1989, gangwars,  0,        alpha68k_V,     gangwars, gangwars, ROT0,  "Alpha Denshi Co.",   "Gang Wars (US)", GAME_SUPPORTS_SAVE )
-GAME( 1989, gangwarsb, gangwars, alpha68k_V,     gangwarsb,gangwarsb,ROT0,  "bootleg",            "Gang Wars (bootleg)", GAME_SUPPORTS_SAVE )
-#if SBASEBAL_HACK
-GAME( 1989, sbasebal,  0,        alpha68k_V_sb,  sbasebal, sbasebal, ROT0,  "Alpha Denshi Co.",   "Super Champion Baseball (Japan)", GAME_SUPPORTS_SAVE )
-#else
-GAME( 1989, sbasebal,  0,        alpha68k_V_sb,  sbasebal, sbasebal, ROT0,  "Alpha Denshi Co. (SNK of America license)", "Super Champion Baseball (US)", GAME_SUPPORTS_SAVE )
-#endif
-GAME( 1989, tnextspc,  0,        tnextspc,       tnextspc, tnextspc, ROT90, "SNK",                "The Next Space", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
-GAME( 1989, tnextspcj, tnextspc, tnextspc,       tnextspc, tnextspc, ROT90, "SNK (Pasadena International Corp. license)", "The Next Space (Japan)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+
+GAME( 1988, goldmedl,  0,        alpha68k_II_gm, goldmedl, goldmedl, ROT0,  "SNK",                                               "Gold Medalist", GAME_SUPPORTS_SAVE )
+GAME( 1988, goldmedla, goldmedl, alpha68k_II_gm, goldmedl, goldmedla,ROT0,  "SNK",                                               "Gold Medalist (alt)", GAME_SUPPORTS_SAVE )
+GAME( 1988, goldmedlb, goldmedl, alpha68k_II_gm, goldmedl, goldmedla,ROT0,  "bootleg",                                           "Gold Medalist (bootleg)", GAME_NOT_WORKING )
+
+GAME( 1989, skyadvnt,  0,        alpha68k_V,     skyadvnt, skyadvnt, ROT90, "Alpha Denshi Co.",                                  "Sky Adventure (World)", GAME_SUPPORTS_SAVE )
+GAME( 1989, skyadvntu, skyadvnt, alpha68k_V,     skyadvntu,skyadvntu,ROT90, "Alpha Denshi Co. (SNK of America license)",         "Sky Adventure (US)", GAME_SUPPORTS_SAVE )
+GAME( 1989, skyadvntj, skyadvnt, alpha68k_V,     skyadvnt, skyadvnt, ROT90, "Alpha Denshi Co.",                                  "Sky Adventure (Japan)", GAME_SUPPORTS_SAVE )
+
+GAME( 1989, gangwars,  0,        alpha68k_V,     gangwars, gangwars, ROT0,  "Alpha Denshi Co.",                                  "Gang Wars", GAME_SUPPORTS_SAVE )
+GAME( 1989, gangwarsu, gangwars, alpha68k_V,     gangwarsu,gangwarsu,ROT0,  "Alpha Denshi Co.",                                  "Gang Wars (US)", GAME_SUPPORTS_SAVE )
+
+GAME( 1989, sbasebal,  0,        alpha68k_V_sb,  sbasebal, sbasebal, ROT0,  "Alpha Denshi Co. (SNK of America license)",         "Super Champion Baseball (US)", GAME_SUPPORTS_SAVE | GAME_UNEMULATED_PROTECTION )
+
+GAME( 1989, tnextspc,  0,        tnextspc,       tnextspc, tnextspc, ROT90, "SNK",                                               "The Next Space", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
+GAME( 1989, tnextspcj, tnextspc, tnextspc,       tnextspc, tnextspc, ROT90, "SNK (Pasadena International Corp. license)",        "The Next Space (Japan)", GAME_SUPPORTS_SAVE | GAME_NO_COCKTAIL )
diff -Nru src-old/mame/drivers/appoooh.c src/mame/drivers/appoooh.c
--- src-old/mame/drivers/appoooh.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/appoooh.c	2010-08-19 07:19:38.000000000 -0700
@@ -605,8 +605,8 @@
 
 static DRIVER_INIT(robowresb)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x1c000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x1c000);
 }
 
 
diff -Nru src-old/mame/drivers/arabian.c src/mame/drivers/arabian.c
--- src-old/mame/drivers/arabian.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/arabian.c	2010-08-21 13:55:16.000000000 -0700
@@ -441,25 +441,25 @@
 	ROM_LOAD( "ic4rev2.90", 0x6000, 0x2000, CRC(32b77b44) SHA1(9d7951e723bc65e3d607f89836f1436b99f2585b) )
 
 	ROM_REGION( 0x10000, "gfx1", 0 )
-	ROM_LOAD( "ic84.91",    0x0000, 0x2000, CRC(c4637822) SHA1(0c73d9a4db925421a535784780ad93bb0f091051) )
-	ROM_LOAD( "ic85.92",    0x2000, 0x2000, CRC(f7c6866d) SHA1(34f545c5f7c152cd59f7be0a72105f739852cd6a) )
-	ROM_LOAD( "ic86.93",    0x4000, 0x2000, CRC(71acd48d) SHA1(cd0bffed351b14c9aebbfc1d3d4d232a5b91a68f) )
-	ROM_LOAD( "ic87.94",    0x6000, 0x2000, CRC(82160b9a) SHA1(03511f6ebcf22ba709a80a565e71acf5bdecbabb) )
+	ROM_LOAD( "tvg-91.ic84", 0x0000, 0x2000, CRC(c4637822) SHA1(0c73d9a4db925421a535784780ad93bb0f091051) )
+	ROM_LOAD( "tvg-92.ic85", 0x2000, 0x2000, CRC(f7c6866d) SHA1(34f545c5f7c152cd59f7be0a72105f739852cd6a) )
+	ROM_LOAD( "tvg-93.ic86", 0x4000, 0x2000, CRC(71acd48d) SHA1(cd0bffed351b14c9aebbfc1d3d4d232a5b91a68f) )
+	ROM_LOAD( "tvg-94.ic87", 0x6000, 0x2000, CRC(82160b9a) SHA1(03511f6ebcf22ba709a80a565e71acf5bdecbabb) )
 ROM_END
 
 
 ROM_START( arabiana )
 	ROM_REGION( 0x10000, "maincpu", 0 )
-	ROM_LOAD( "ic1.87",     0x0000, 0x2000, CRC(51e9a6b1) SHA1(a2e6beab5380eed56972f5625be21b01c7e2082a) )
-	ROM_LOAD( "ic2.88",     0x2000, 0x2000, CRC(1cdcc1ab) SHA1(46886d53cc8a1c1d540fd0e1ddf1811fb256c1f3) )
-	ROM_LOAD( "ic3.89",     0x4000, 0x2000, CRC(b7b7faa0) SHA1(719418b7b7c057acb6d3060cf7061ffacf00798c) )
-	ROM_LOAD( "ic4.90",     0x6000, 0x2000, CRC(dbded961) SHA1(ecc09fa95f6dd58c4ac0e095a89ffd3aae681da4) )
+	ROM_LOAD( "tvg-87.ic1", 0x0000, 0x2000, CRC(51e9a6b1) SHA1(a2e6beab5380eed56972f5625be21b01c7e2082a) )
+	ROM_LOAD( "tvg-88.ic2", 0x2000, 0x2000, CRC(1cdcc1ab) SHA1(46886d53cc8a1c1d540fd0e1ddf1811fb256c1f3) )
+	ROM_LOAD( "tvg-89.ic3", 0x4000, 0x2000, CRC(b7b7faa0) SHA1(719418b7b7c057acb6d3060cf7061ffacf00798c) )
+	ROM_LOAD( "tvg-90.ic4", 0x6000, 0x2000, CRC(dbded961) SHA1(ecc09fa95f6dd58c4ac0e095a89ffd3aae681da4) )
 
 	ROM_REGION( 0x10000, "gfx1", 0 )
-	ROM_LOAD( "ic84.91",    0x0000, 0x2000, CRC(c4637822) SHA1(0c73d9a4db925421a535784780ad93bb0f091051) )
-	ROM_LOAD( "ic85.92",    0x2000, 0x2000, CRC(f7c6866d) SHA1(34f545c5f7c152cd59f7be0a72105f739852cd6a) )
-	ROM_LOAD( "ic86.93",    0x4000, 0x2000, CRC(71acd48d) SHA1(cd0bffed351b14c9aebbfc1d3d4d232a5b91a68f) )
-	ROM_LOAD( "ic87.94",    0x6000, 0x2000, CRC(82160b9a) SHA1(03511f6ebcf22ba709a80a565e71acf5bdecbabb) )
+	ROM_LOAD( "tvg-91.ic84", 0x0000, 0x2000, CRC(c4637822) SHA1(0c73d9a4db925421a535784780ad93bb0f091051) )
+	ROM_LOAD( "tvg-92.ic85", 0x2000, 0x2000, CRC(f7c6866d) SHA1(34f545c5f7c152cd59f7be0a72105f739852cd6a) )
+	ROM_LOAD( "tvg-93.ic86", 0x4000, 0x2000, CRC(71acd48d) SHA1(cd0bffed351b14c9aebbfc1d3d4d232a5b91a68f) )
+	ROM_LOAD( "tvg-94.ic87", 0x6000, 0x2000, CRC(82160b9a) SHA1(03511f6ebcf22ba709a80a565e71acf5bdecbabb) )
 ROM_END
 
 
diff -Nru src-old/mame/drivers/aristmk4.c src/mame/drivers/aristmk4.c
--- src-old/mame/drivers/aristmk4.c	2010-07-07 14:01:36.000000000 -0700
+++ src/mame/drivers/aristmk4.c	2010-08-30 08:20:58.000000000 -0700
@@ -53,6 +53,12 @@
         30/5/10 - Palindrome
         Now using mc146818 rtc driver instead of rtc_get_reg.
 
+        19/8/10 - Roberto Fresca.
+        Added 3 Bags Full - 5VXFC790 (Victorian).
+        Set is now parent. Replaced the bad dumped GFX from NZ set with the new ones,
+        since they match 4 of 6 bitplanes. The PROM at U71 is also marked for Fantasy Fortune,
+        so maybe is the correct one for this game.
+
         The mc146818 driver is buggy - reported problem to Firewave and issues will be addressed.
         In this driver, the wrong day of the month is shown, wrong hours are shown.
         rtc causes game to freeze if the game is left in audit mode with continuous writes to 0xA reg - 0x80 data.
@@ -1212,6 +1218,30 @@
 
 MACHINE_DRIVER_END
 
+ROM_START( 3bagflvt )
+
+	ROM_REGION(0x10000, "maincpu", 0 )
+	 /* VIDEO AND SOUND EPROM */
+	ROM_LOAD("3_bag_full_video_sound.u59",  0x02000, 0x2000, CRC(84226547) SHA1(df9c2c01a7ac4d930c06a8c4863853ddb1a2adbe)) // sound and video rom
+
+	 /* GAME EPROMS */
+	ROM_LOAD("5vxfc790_3_bag_full_1-2.u87", 0x06000, 0x2000, CRC(79ee932f) SHA1(de85de107310315b69bd7564f1921c7501b679b2)) // game code
+	ROM_LOAD("5vxfc790_3_bag_full_2-2.u86", 0x08000, 0x8000, CRC(b6185f3b) SHA1(db642d7b1d1fd93483642bae518eb99a3e99aec9)) // game code
+
+	/* SHAPE EPROMS */
+	ROM_REGION(0xc000, "tile_gfx", 0 )
+	ROM_LOAD("1vlsh224_3_bag_full_1-6.u20", 0x00000, 0x2000, CRC(b02d4ce8) SHA1(eace41f870bfbc253124efd72f1c7d6021f2e99f)) // gfx
+	ROM_LOAD("1vlsh224_3_bag_full_3-6.u21", 0x02000, 0x2000, CRC(06218c95) SHA1(cbda8e50fd4e9c8a3c51a006921a85d4bfaa6f78))
+	ROM_LOAD("1vlsh224_3_bag_full_5-6.u22", 0x04000, 0x2000, CRC(191e73f1) SHA1(e6d510b155f9cd3427a70346e5ff28969309be4e))
+	ROM_LOAD("1vlsh224_3_bag_full_2-6.u45", 0x06000, 0x2000, CRC(054c55cb) SHA1(3df1893095f867220f3d6a52a40bcdffbfc8b529))
+	ROM_LOAD("1vlsh224_3_bag_full_4-6.u46", 0x08000, 0x2000, CRC(f33970b3) SHA1(8814a4d29383545c7c48e5b44f16a53e38b67fc3))
+	ROM_LOAD("1vlsh224_3_bag_full_6-6.u47", 0x0a000, 0x2000, CRC(609ecf9e) SHA1(9d819bb71f62eb4dd1b3d71748e87c7d77e2afe6))
+
+	 /* COLOR PROM */
+	ROM_REGION(0x200, "proms", 0 )
+	ROM_LOAD("1cm48.u71", 0x0000, 0x0200, CRC(81daeeb0) SHA1(7dfe198c6def5c4ae4ecac488d65c2911fb3a890))
+ROM_END
+
 ROM_START( 3bagflnz )
 
 	ROM_REGION(0x10000, "maincpu", 0 )
@@ -1223,13 +1253,13 @@
 	ROM_LOAD("u86.bin", 0x08000, 0x8000, CRC(c632c7c7) SHA1(f3090d037f71a0cf099bb55abbc509cf95f0cbba)) // game code
 
 	/* SHAPE EPROMS */
-	ROM_REGION(0xc000, "tile_gfx", 0 )
-	ROM_LOAD("u20.bin", 0x00000, 0x2000, BAD_DUMP CRC(44babe95) SHA1(047c00ebb21030563921108b8e24f62e9ef44a10)) // gfx
-	ROM_LOAD("u21.bin", 0x02000, 0x2000, BAD_DUMP CRC(06218c95) SHA1(cbda8e50fd4e9c8a3c51a006921a85d4bfaa6f78))
-	ROM_LOAD("u22.bin", 0x04000, 0x2000, BAD_DUMP CRC(191e73f1) SHA1(e6d510b155f9cd3427a70346e5ff28969309be4e))
-	ROM_LOAD("u45.bin", 0x06000, 0x2000, BAD_DUMP CRC(054c55cb) SHA1(3df1893095f867220f3d6a52a40bcdffbfc8b529))
-	ROM_LOAD("u46.bin", 0x08000, 0x2000, BAD_DUMP CRC(7a4e8b80) SHA1(35711d6a8f5675ad6c6496bf8e7e5a73504f2409))
-	ROM_LOAD("u47.bin", 0x0a000, 0x2000, BAD_DUMP CRC(609ecf9e) SHA1(9d819bb71f62eb4dd1b3d71748e87c7d77e2afe6))
+	ROM_REGION(0xc000, "tile_gfx", 0 )	/* GFX from parent set. They match 4 of 6 bitplanes */
+	ROM_LOAD("1vlsh224_3_bag_full_1-6.u20", 0x00000, 0x2000, CRC(b02d4ce8) SHA1(eace41f870bfbc253124efd72f1c7d6021f2e99f)) // gfx
+	ROM_LOAD("1vlsh224_3_bag_full_3-6.u21", 0x02000, 0x2000, CRC(06218c95) SHA1(cbda8e50fd4e9c8a3c51a006921a85d4bfaa6f78))
+	ROM_LOAD("1vlsh224_3_bag_full_5-6.u22", 0x04000, 0x2000, CRC(191e73f1) SHA1(e6d510b155f9cd3427a70346e5ff28969309be4e))
+	ROM_LOAD("1vlsh224_3_bag_full_2-6.u45", 0x06000, 0x2000, CRC(054c55cb) SHA1(3df1893095f867220f3d6a52a40bcdffbfc8b529))
+	ROM_LOAD("1vlsh224_3_bag_full_4-6.u46", 0x08000, 0x2000, CRC(f33970b3) SHA1(8814a4d29383545c7c48e5b44f16a53e38b67fc3))
+	ROM_LOAD("1vlsh224_3_bag_full_6-6.u47", 0x0a000, 0x2000, CRC(609ecf9e) SHA1(9d819bb71f62eb4dd1b3d71748e87c7d77e2afe6))
 
 	 /* COLOR PROM */
 	ROM_REGION(0x200, "proms", 0 )
@@ -1574,18 +1604,19 @@
 
 
 
-GAMEL( 1994, eforest,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 12XF528902", GAME_NOT_WORKING,layout_aristmk4)
-GAMEL( 1995, eforesta,eforest,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 4VXFC818", 0,layout_aristmk4 )
-GAMEL( 1996, eforestb,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 3VXFC5343 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1994, 3bagflnz,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "3 Bags Full - 3VXFC5345 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1996, blkrhino,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Black Rhino - 3VXFC5344 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1996, kgbird,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "K.G Bird - 4VXFC5341 (New Zealand, 87.98%)", 0,layout_aristmk4 )
-GAMEL( 1996, kgbirda,  kgbird,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "K.G Bird - 4VXFC5341 (New Zealand, 91.97%)", 0,layout_aristmk4 )
-GAMEL( 1998, swtht2nz,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Sweet Hearts II - 1VXFC5461 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1996, goldenc,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Golden Canaries - 1VXFC5462", 0,layout_aristmk4 )
-GAMEL( 1996, topgear,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Top Gear - 4VXFC969", GAME_NOT_WORKING,layout_aristmk4 )
-GAMEL( 1996, wtigernz,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "White Tiger - 3VXFC5342 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1998, phantomp,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Phantom Pays - 4VXFC5431 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 2000, coralr2,		0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Coral Riches II - 1VXFC5472 (New Zealand)", 0,layout_aristmk4 )
-GAMEL( 1999, ffortune,      0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Fantasy Fortune", 0,layout_aristmk4 )
-GAMEL( 1999, autmoon,       0,aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Autumn Moon", 0,layout_aristmk4 )
+GAMEL( 1994, eforest,  0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 12XF528902",              GAME_NOT_WORKING, layout_aristmk4)
+GAMEL( 1995, eforesta, eforest,  aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 4VXFC818",                0,                layout_aristmk4 )
+GAMEL( 1996, eforestb, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Enchanted Forest - 3VXFC5343 (New Zealand)", 0,                layout_aristmk4 )
+GAMEL( 1994, 3bagflvt, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "3 Bags Full - 5VXFC790 (Victorian)",         0,                layout_aristmk4 )
+GAMEL( 1994, 3bagflnz, 3bagflvt, aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "3 Bags Full - 3VXFC5345 (New Zealand)",      0,                layout_aristmk4 )
+GAMEL( 1996, blkrhino, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Black Rhino - 3VXFC5344 (New Zealand)",      0,                layout_aristmk4 )
+GAMEL( 1996, kgbird,   0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "K.G Bird - 4VXFC5341 (New Zealand, 87.98%)", 0,                layout_aristmk4 )
+GAMEL( 1996, kgbirda,  kgbird,   aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "K.G Bird - 4VXFC5341 (New Zealand, 91.97%)", 0,                layout_aristmk4 )
+GAMEL( 1998, swtht2nz, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Sweet Hearts II - 1VXFC5461 (New Zealand)",  0,                layout_aristmk4 )
+GAMEL( 1996, goldenc,  0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Golden Canaries - 1VXFC5462",                0,                layout_aristmk4 )
+GAMEL( 1996, topgear,  0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Top Gear - 4VXFC969",                        GAME_NOT_WORKING, layout_aristmk4 )
+GAMEL( 1996, wtigernz, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "White Tiger - 3VXFC5342 (New Zealand)",      0,                layout_aristmk4 )
+GAMEL( 1998, phantomp, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Phantom Pays - 4VXFC5431 (New Zealand)",     0,                layout_aristmk4 )
+GAMEL( 2000, coralr2,  0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Coral Riches II - 1VXFC5472 (New Zealand)",  0,                layout_aristmk4 )
+GAMEL( 1999, ffortune, 0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Fantasy Fortune",                            0,                layout_aristmk4 )
+GAMEL( 1999, autmoon,  0,        aristmk4, aristmk4, aristmk4, ROT0,  "Aristocrat", "Autumn Moon",                                0,                layout_aristmk4 )
diff -Nru src-old/mame/drivers/aristmk5.c src/mame/drivers/aristmk5.c
--- src-old/mame/drivers/aristmk5.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/aristmk5.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,9 +1,59 @@
 /*
 
-   Aristocrat MK5 / MKV hardware
-   possibly 'Acorn Archimedes on a chip' hardware
+    Aristocrat MK5 / MKV hardware
+    possibly 'Acorn Archimedes on a chip' hardware
 
-   Note: ARM250 mapping is not identical to
+    Note: ARM250 mapping is not identical to plain AA
+
+    BIOS ROMs are actually nowhere to be found on a regular MK5 system. They can be used to change the system configurations on a PCB board
+    by swapping them with the game ROMs u7/u11 locations.
+
+    TODO (MK-5 specific):
+    - Fix remaining errors
+    - If all tests passes, this msg is printed on the keyboard serial port:
+    "System Startup Code Entered \n Gos_create could not allocate stack for the new process \n Unrecoverable error occured. System will now restart"
+    Apparently it looks like some sort of protection device ...
+
+    code DASMing of POST (adonis):
+    - bp 0x3400224:
+      checks work RAM [0x87000], if bit 0 active high then all tests are skipped (presumably for debugging), otherwise check stuff;
+        - bp 0x3400230: EPROM checksum branch test
+        - bp 0x3400258: DRAM Check branch test
+        - bp 0x3400280: CPU Check branch test
+            bp 0x340027c: checks IRQ status A and FIQ status bit 7 (force IRQ flag)
+            - R0 == 0: CPU Check OK
+            - R0 == 1: IRQ status A force IRQ flag check failed
+            - R0 == 2: FIQ status force IRQ flag check failed
+            - R0 == 3: Internal Latch check 0x3250050 == 0xf5
+        - bp 0x34002a8: SRAM Check branch test (I2C)
+            - basically writes to the I2C clock/data then read-backs it
+        - bp 0x34002d0: 2KHz Timer branch test
+            bp 0x34002cc: it does various test with GO command reads (that are undefined on plain AA) and
+                          IRQA status bit 0, that's "printer busy" on original AA but here it have a completely
+                          different meaning.
+        - bp 0x34002f8: DRAM emulator branch tests
+            bp 0x34002f4:
+            - R0 == 0 "DRAM emulator found"
+            - R0 == 1 "DRAM emulator found"
+            - R0 == 3 "DRAM emulator not found - Error"
+            - R0 == 4 "DRAM emulator found instead of DRAM - Error"
+            - R0 == x "Undefined error in DRAM emulator area"
+            It r/w RAM location 0 and it expects to NOT read-back value written.
+
+    goldprmd: checks if a "keyboard IRQ" fires (IRQ status B bit 6), it seems a serial port with data on it,
+              returns an External Video Crystal Error (bp 3400278)
+
+    dmdtouch:
+        bp 3400640: checks 2MByte DRAM
+            - writes from 0x1000 to 0x100000, with 0x400 bytes index increment and 0xfb data increment
+            - writes from 0x100000 to 0x200000, with 0x400 bytes index increment and 0xfb data increment
+            - bp 3400720 checks if the aforementioned checks are ok (currently fails at the very first work RAM check at 0x1000, it returns the
+              value that actually should be at 0x141000)
+        bp 340064c: if R0 == 0 2MB DRAM is ok, otherwise there's an error
+
+    set chip (BIOS):
+        same as goldprmd (serial + ext video crystal check)
+        bp 3400110: External Video Crystal test
 
 */
 
@@ -11,33 +61,109 @@
 #include "cpu/arm/arm.h"
 #include "sound/dac.h"
 #include "includes/archimds.h"
+#include "machine/i2cmem.h"
+
+extern void archimedes_request_irq_a(running_machine *machine, int mask);
+static emu_timer *mk5_2KHz_timer;
+static UINT8 ext_latch;
+
+/* bit mirrors of I2C */
+static WRITE32_HANDLER( mk5_i2c_w )
+{
+	i2cmem_sda_write(space->machine->device("i2cmem"), (data & 0x40) >> 6);
+	i2cmem_scl_write(space->machine->device("i2cmem"), (data & 0x80) >> 7);
+	i2c_clk = (data & 0x80) >> 7;
+}
+
+static WRITE32_HANDLER( mk5_ext_latch_w )
+{
+	/* this banks "something" */
+	ext_latch = data & 1;
+}
+
+static READ32_HANDLER( ext_timer_latch_r )
+{
+	/* reset 2KHz timer */
+	ioc_regs[IRQ_STATUS_A] &= 0xfe;
+	timer_adjust_oneshot(mk5_2KHz_timer, ATTOTIME_IN_HZ(2000), 0);
+
+	return 0xffffffff; //value doesn't matter apparently
+}
+
+static READ32_HANDLER( mk5_ioc_r )
+{
+	return archimedes_ioc_r(space,offset,mem_mask);
+}
+
+static WRITE32_HANDLER( mk5_ioc_w )
+{
+	if(!ext_latch)
+		archimedes_ioc_w(space,offset,data,mem_mask);
+}
+
+static READ32_HANDLER( mk5_unk_r )
+{
+	return 0xf5; // checked inside the CPU check, unknown meaning
+}
+
+/* I'm not really optimistic that this thing really uses I2C ... */
+static READ32_HANDLER( mk5_econet_r )
+{
+	UINT8 i2c_data;
+
+	i2c_data = (i2cmem_sda_read(space->machine->device("i2cmem")) & 1);
+
+	return (ioc_regs[CONTROL] & 0xfc) | (i2c_clk<<1) | i2c_data;
+}
+
+static WRITE32_HANDLER( mk5_econet_w )
+{
+	//logerror("IOC I2C: CLK %d DAT %d\n", (data>>1)&1, data&1);
+	i2cmem_sda_write(space->machine->device("i2cmem"), data & 0x01);
+	i2cmem_scl_write(space->machine->device("i2cmem"), (data & 0x02) >> 1);
+	i2c_clk = (data & 2) >> 1;
+}
 
 static ADDRESS_MAP_START( aristmk5_map, ADDRESS_SPACE_PROGRAM, 32 )
 	AM_RANGE(0x00000000, 0x01ffffff) AM_READWRITE(archimedes_memc_logical_r, archimedes_memc_logical_w)
 	AM_RANGE(0x02000000, 0x02ffffff) AM_RAM AM_BASE(&archimedes_memc_physmem) /* physical RAM - 16 MB for now, should be 512k for the A310 */
-	AM_RANGE(0x03000000, 0x033fffff) AM_READWRITE(archimedes_ioc_r, archimedes_ioc_w)
-	AM_RANGE(0x03400000, 0x035fffff) AM_ROM AM_REGION("maincpu", 0) AM_WRITE(archimedes_memc_page_w)
+
+	/* MK-5 overrides */
+	AM_RANGE(0x03010420, 0x03010423) AM_RAM_WRITE(mk5_i2c_w)
+	AM_RANGE(0x03010810, 0x03010813) AM_READNOP //MK-5 specific, watchdog
+//  System Startup Code Enabled protection appears to be located at 0x3010400 - 0x30104ff
+	AM_RANGE(0x03220000, 0x03220003) AM_READWRITE(mk5_econet_r,mk5_econet_w)
+	AM_RANGE(0x03250048, 0x0325004b) AM_WRITE(mk5_ext_latch_w)
+	AM_RANGE(0x03250050, 0x03250053) AM_READ(mk5_unk_r)
+	AM_RANGE(0x03250058, 0x0325005b) AM_READ(ext_timer_latch_r)
+
+	AM_RANGE(0x03000000, 0x033fffff) AM_READWRITE(mk5_ioc_r, mk5_ioc_w)
+	AM_RANGE(0x03400000, 0x035fffff) AM_ROM AM_REGION("maincpu", 0) AM_WRITE(archimedes_vidc_w)
 	AM_RANGE(0x03600000, 0x037fffff) AM_READWRITE(archimedes_memc_r, archimedes_memc_w)
-	AM_RANGE(0x03800000, 0x039fffff) AM_READWRITE(archimedes_vidc_r, archimedes_vidc_w)
+	AM_RANGE(0x03800000, 0x039fffff) AM_WRITE(archimedes_memc_page_w)
 ADDRESS_MAP_END
 
 
 static INPUT_PORTS_START( aristmk5 )
+	/* This simulates the ROM swap */
+	PORT_START("ROM_LOAD")
+	PORT_CONFNAME( 0x03, 0x00, "System Mode" )
+	PORT_CONFSETTING(    0x00, "Set Chip v4.04 Mode" )
+	PORT_CONFSETTING(    0x01, "Set Chip v4.4 Mode" )
+//  Clear Chip (missing?)
+	PORT_CONFSETTING(    0x03, "Game Mode" )
 INPUT_PORTS_END
 
-static VIDEO_START(aristmk5)
+static DRIVER_INIT( aristmk5 )
 {
-
+	archimedes_driver_init(machine);
 }
 
-static VIDEO_UPDATE(aristmk5)
+static TIMER_CALLBACK( mk5_2KHz_callback )
 {
-	return 0;
-}
+	ioc_regs[4] |= 1;
 
-static DRIVER_INIT( aristmk5 )
-{
-	archimedes_driver_init(machine);
+	timer_adjust_oneshot(mk5_2KHz_timer, attotime_never, 0);
 }
 
 static MACHINE_START( aristmk5 )
@@ -45,151 +171,279 @@
 	archimedes_init(machine);
 
 	// reset the DAC to centerline
-	dac_signed_data_w(machine->device("dac"), 0x80);
+	//dac_signed_data_w(machine->device("dac"), 0x80);
+
+	mk5_2KHz_timer = timer_alloc(machine, mk5_2KHz_callback, 0);
 }
 
 static MACHINE_RESET( aristmk5 )
 {
 	archimedes_reset(machine);
+	timer_adjust_oneshot(mk5_2KHz_timer, ATTOTIME_IN_HZ(2000), 0);
+
+	ioc_regs[IRQ_STATUS_B] |= 0x40; //hack, set keyboard irq empty to be ON
+
+	/* load the roms according to what the operator wants */
+	{
+		UINT8 *ROM = memory_region(machine,"maincpu");
+		UINT8 *PRG = memory_region(machine,"prg_code");
+		int i;
+		UINT8 op_mode;
+
+		op_mode = input_port_read(machine, "ROM_LOAD");
+
+		if(op_mode == 3)
+		{
+			for(i=0;i<0x300000;i++)
+				ROM[i] = PRG[i+0x200000];
+		}
+		else
+		{
+			for(i=0;i<0x100000;i++)
+				ROM[i] = PRG[i+(op_mode*0x100000)];
+		}
+	}
 }
 
+#define	NVRAM_SIZE 256
+#define	NVRAM_PAGE_SIZE	0	/* max size of one write request */
+
+static const i2cmem_interface i2cmem_interface =
+{
+	I2CMEM_SLAVE_ADDRESS, NVRAM_PAGE_SIZE, NVRAM_SIZE
+};
+
+
 static MACHINE_DRIVER_START( aristmk5 )
 	MDRV_CPU_ADD("maincpu", ARM, 10000000) // ?
 	MDRV_CPU_PROGRAM_MAP(aristmk5_map)
 
-	MDRV_MACHINE_RESET( aristmk5 )
 	MDRV_MACHINE_START( aristmk5 )
+	MDRV_MACHINE_RESET( aristmk5 )
+
+	MDRV_I2CMEM_ADD("i2cmem",i2cmem_interface)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_REFRESH_RATE(60)
 	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
-	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_INDEXED16)
-	MDRV_SCREEN_SIZE(64*8, 32*8)
-	MDRV_SCREEN_VISIBLE_AREA(8*8, 48*8-1, 2*8, 30*8-1)
+	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
+	MDRV_SCREEN_SIZE(1280, 1024) //TODO: proper max size?
+	MDRV_SCREEN_VISIBLE_AREA(0, 1280-1, 0, 1024-1)
 
 	MDRV_PALETTE_LENGTH(0x200)
 
-	MDRV_VIDEO_START(aristmk5)
-	MDRV_VIDEO_UPDATE(aristmk5)
+	MDRV_VIDEO_START(archimds_vidc)
+	MDRV_VIDEO_UPDATE(archimds_vidc)
+
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+	MDRV_SOUND_ADD("dac0", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac1", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac2", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac3", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac4", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac5", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
 
-	MDRV_SPEAKER_STANDARD_MONO("aristmk5")
-	MDRV_SOUND_ADD("dac", DAC, 0)
-	MDRV_SOUND_ROUTE(0, "aristmk5", 1.00)
+	MDRV_SOUND_ADD("dac6", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac7", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
 MACHINE_DRIVER_END
 
+#define ARISTOCRAT_MK5_BIOS \
+	ROM_REGION( 0x800000, "prg_code", 0 ) \
+	/* setchip v4.04.08 4meg */ \
+	ROM_LOAD32_WORD( "setchip v4.04.08.u7",  0x000000, 0x80000, CRC(e8e8dc75) SHA1(201fe95256459ce34fdb6f7498135ab5016d07f3) ) \
+	ROM_LOAD32_WORD( "setchip v4.04.08.u11", 0x000002, 0x80000, CRC(ff7a9035) SHA1(4352c4336e61947c555fdc80c61f944076f64b64) ) \
+	/* setchip v4.4 4meg 42pin */ \
+	ROM_LOAD32_WORD( "setchip v4.4.u7",  0x100000, 0x80000, CRC(2453137e) SHA1(b59998e75ae3924da16faf47b9cfe9afd60d810c) ) \
+	ROM_LOAD32_WORD( "setchip v4.4.u11", 0x100002, 0x80000, CRC(82dfa12a) SHA1(86fd0f0ad8d5d1bc503392a40bbcdadb055b2765) ) \
+
+ROM_START( aristmk5 )
+	ARISTOCRAT_MK5_BIOS
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 )
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
+ROM_END
+
 ROM_START( reelrock )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "reelrock.u7",  0x000000, 0x80000, CRC(b60af34f) SHA1(1143380b765db234b3871c0fe04736472fde7de4) )
-	ROM_LOAD32_WORD( "reelrock.u11", 0x000002, 0x80000, CRC(57e341d0) SHA1(9b0d50763bb74ca5fe404c9cd526633721cf6677) )
-	ROM_LOAD32_WORD( "reelrock.u8",  0x100000, 0x80000, CRC(57eec667) SHA1(5f3888d75f48b6148f451d7ebb7f99e1a0939f3c) )
-	ROM_LOAD32_WORD( "reelrock.u12", 0x100002, 0x80000, CRC(4ac20679) SHA1(0ac732ffe6a33806e4a06e87ec875a3e1314e06b) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "reelrock.u7",  0x200000, 0x80000, CRC(b60af34f) SHA1(1143380b765db234b3871c0fe04736472fde7de4) )
+	ROM_LOAD32_WORD( "reelrock.u11", 0x200002, 0x80000, CRC(57e341d0) SHA1(9b0d50763bb74ca5fe404c9cd526633721cf6677) )
+	ROM_LOAD32_WORD( "reelrock.u8",  0x300000, 0x80000, CRC(57eec667) SHA1(5f3888d75f48b6148f451d7ebb7f99e1a0939f3c) )
+	ROM_LOAD32_WORD( "reelrock.u12", 0x300002, 0x80000, CRC(4ac20679) SHA1(0ac732ffe6a33806e4a06e87ec875a3e1314e06b) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( indiandr )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "indiandr.u7",  0x000000, 0x80000, CRC(0c924a3e) SHA1(499b4ae601e53173e3ba5f400a40e5ae7bbaa043) )
-	ROM_LOAD32_WORD( "indiandr.u11", 0x000002, 0x80000, CRC(e371dc0f) SHA1(a01ab7fb63a19c144f2c465ecdfc042695124bdf) )
-	ROM_LOAD32_WORD( "indiandr.u8",  0x100000, 0x80000, CRC(1c6bfb47) SHA1(7f751cb499a6185a0ab64eeec511583ceeee6ee8) )
-	ROM_LOAD32_WORD( "indiandr.u12", 0x100002, 0x80000, CRC(4bbe67f6) SHA1(928f88387da66697f1de54f086531f600f80a15e) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "indiandr.u7",  0x200000, 0x80000, CRC(0c924a3e) SHA1(499b4ae601e53173e3ba5f400a40e5ae7bbaa043) )
+	ROM_LOAD32_WORD( "indiandr.u11", 0x200002, 0x80000, CRC(e371dc0f) SHA1(a01ab7fb63a19c144f2c465ecdfc042695124bdf) )
+	ROM_LOAD32_WORD( "indiandr.u8",  0x300000, 0x80000, CRC(1c6bfb47) SHA1(7f751cb499a6185a0ab64eeec511583ceeee6ee8) )
+	ROM_LOAD32_WORD( "indiandr.u12", 0x300002, 0x80000, CRC(4bbe67f6) SHA1(928f88387da66697f1de54f086531f600f80a15e) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( dolphntr )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "0100424v.u7",  0x000000, 0x80000, CRC(657faef7) SHA1(09e1f9d461e855c10cf8b825ef83dd3e7db65b43) )
-	ROM_LOAD32_WORD( "0100424v.u11", 0x000002, 0x80000, CRC(65aa46ec) SHA1(3ad4270efbc2e947097d94a3258a544d79a1d599) )
-	ROM_LOAD32_WORD( "0100424v.u8",  0x100000, 0x80000, CRC(e77868ad) SHA1(3345da120075bc0da47bac0a4840790693382620) )
-	ROM_LOAD32_WORD( "0100424v.u12", 0x100002, 0x80000, CRC(6abd9309) SHA1(c405a13f5bfe447c1ab20d92e140e4fb145920d4) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "0100424v.u7",  0x200000, 0x80000, CRC(657faef7) SHA1(09e1f9d461e855c10cf8b825ef83dd3e7db65b43) )
+	ROM_LOAD32_WORD( "0100424v.u11", 0x200002, 0x80000, CRC(65aa46ec) SHA1(3ad4270efbc2e947097d94a3258a544d79a1d599) )
+	ROM_LOAD32_WORD( "0100424v.u8",  0x300000, 0x80000, CRC(e77868ad) SHA1(3345da120075bc0da47bac0a4840790693382620) )
+	ROM_LOAD32_WORD( "0100424v.u12", 0x300002, 0x80000, CRC(6abd9309) SHA1(c405a13f5bfe447c1ab20d92e140e4fb145920d4) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( dolphtra )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "0200424v.u7",  0x000000, 0x80000, CRC(5dd88306) SHA1(ee8ec7d123d057e8df9be0e8dadecea7dab7aafd) )
-	ROM_LOAD32_WORD( "0200424v.u11", 0x000002, 0x80000, CRC(bcb732ea) SHA1(838300914846c6e740780e5a24b9db7304a8a88d) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "0200424v.u7",  0x200000, 0x80000, CRC(5dd88306) SHA1(ee8ec7d123d057e8df9be0e8dadecea7dab7aafd) )
+	ROM_LOAD32_WORD( "0200424v.u11", 0x200002, 0x80000, CRC(bcb732ea) SHA1(838300914846c6e740780e5a24b9db7304a8a88d) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( goldprmd )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "goldprmd.u7",  0x000000, 0x80000, CRC(2fbed80c) SHA1(fb0d97cb2be96da37c487fc3aef06c6120efdb46) )
-	ROM_LOAD32_WORD( "goldprmd.u11", 0x000002, 0x80000, CRC(ec9c183c) SHA1(e405082ee779c4fee103fb7384469c9d6afbc95b) )
-	ROM_LOAD32_WORD( "goldprmd.u8",  0x100000, 0x80000, CRC(3cd7d8e5) SHA1(ae83a7c335564c398330d43295997b8ca547c92d) )
-	ROM_LOAD32_WORD( "goldprmd.u12", 0x100002, 0x80000, CRC(8bbf45d0) SHA1(f58f28e7cc4ac225197959566d81973b5aa0e836) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "goldprmd.u7",  0x200000, 0x80000, CRC(2fbed80c) SHA1(fb0d97cb2be96da37c487fc3aef06c6120efdb46) )
+	ROM_LOAD32_WORD( "goldprmd.u11", 0x200002, 0x80000, CRC(ec9c183c) SHA1(e405082ee779c4fee103fb7384469c9d6afbc95b) )
+	ROM_LOAD32_WORD( "goldprmd.u8",  0x300000, 0x80000, CRC(3cd7d8e5) SHA1(ae83a7c335564c398330d43295997b8ca547c92d) )
+	ROM_LOAD32_WORD( "goldprmd.u12", 0x300002, 0x80000, CRC(8bbf45d0) SHA1(f58f28e7cc4ac225197959566d81973b5aa0e836) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( qotn )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "0200439v.u7",  0x000000, 0x80000, CRC(d476a893) SHA1(186d6fb1830c33976f2d3c96e4f045ece885dc63) )
-	ROM_LOAD32_WORD( "0200439v.u11", 0x000002, 0x80000, CRC(8b0d7205) SHA1(ffa03f1c9332a1a7443eb91b0ded56e7cd9e3cee) )
-	ROM_LOAD32_WORD( "0200439v.u8",  0x100000, 0x80000, CRC(9b996ef1) SHA1(72489e9a0ee5c34f7cad3d121bcd08e09ef72360) )
-	ROM_LOAD32_WORD( "0200439v.u12", 0x100002, 0x80000, CRC(2a0f7feb) SHA1(27c89dadf759e6c892121650758c44ec50990cb6) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "0200439v.u7",  0x200000, 0x80000, CRC(d476a893) SHA1(186d6fb1830c33976f2d3c96e4f045ece885dc63) )
+	ROM_LOAD32_WORD( "0200439v.u11", 0x200002, 0x80000, CRC(8b0d7205) SHA1(ffa03f1c9332a1a7443eb91b0ded56e7cd9e3cee) )
+	ROM_LOAD32_WORD( "0200439v.u8",  0x300000, 0x80000, CRC(9b996ef1) SHA1(72489e9a0ee5c34f7cad3d121bcd08e09ef72360) )
+	ROM_LOAD32_WORD( "0200439v.u12", 0x300002, 0x80000, CRC(2a0f7feb) SHA1(27c89dadf759e6c892121650758c44ec50990cb6) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( swthrt2v )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "swthrt2v.u7",  0x000000, 0x80000, CRC(f51b2faa) SHA1(dbcfdbee92af5f89a8a2611bbc687ee0cc907642) )
-	ROM_LOAD32_WORD( "swthrt2v.u11", 0x000002, 0x80000, CRC(bd7ead91) SHA1(9f775428a4aa0b0a8ee17aed9be620edc2020c5e) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "swthrt2v.u7",  0x200000, 0x80000, CRC(f51b2faa) SHA1(dbcfdbee92af5f89a8a2611bbc687ee0cc907642) )
+	ROM_LOAD32_WORD( "swthrt2v.u11", 0x200002, 0x80000, CRC(bd7ead91) SHA1(9f775428a4aa0b0a8ee17aed9be620edc2020c5e) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( enchfrst )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "0400122v.u7",  0x000000, 0x80000, CRC(b5829b27) SHA1(f6f84c8dc524dcee95e37b93ead9090903bdca4f) )
-	ROM_LOAD32_WORD( "0400122v.u11", 0x000002, 0x80000, CRC(7a97adc8) SHA1(b52f7fdc7edf9ad92351154c01b8003c0576ed94) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "0400122v.u7",  0x200000, 0x80000, CRC(b5829b27) SHA1(f6f84c8dc524dcee95e37b93ead9090903bdca4f) )
+	ROM_LOAD32_WORD( "0400122v.u11", 0x200002, 0x80000, CRC(7a97adc8) SHA1(b52f7fdc7edf9ad92351154c01b8003c0576ed94) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( margmgc )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "margmgc.u7",  0x000000, 0x80000, CRC(eee7ebaf) SHA1(bad0c08578877f84325c07d51c6ed76c40b70720) )
-	ROM_LOAD32_WORD( "margmgc.u11", 0x000002, 0x80000, CRC(4901a166) SHA1(8afe6f08b4ac5c17744dff73939c4bc93124fdf1) )
-	ROM_LOAD32_WORD( "margmgc.u8",  0x100000, 0x80000, CRC(b0d78efe) SHA1(bc8b345290f4d31c6553f1e2700bc8324b4eeeac) )
-	ROM_LOAD32_WORD( "margmgc.u12", 0x100002, 0x80000, CRC(90ff59a8) SHA1(c9e342db2b5e8c3f45efa8496bc369385046e920) )
-	ROM_LOAD32_WORD( "margmgc.u9",  0x200000, 0x80000, CRC(1f0ca910) SHA1(be7a2f395eae09a29faf99ba34551fbc38f20fdb) )
-	ROM_LOAD32_WORD( "margmgc.u13", 0x200002, 0x80000, CRC(3f702945) SHA1(a6c9a848d059c1e564fdc5a65bf8c9600853edfa) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "margmgc.u7",  0x200000, 0x80000, CRC(eee7ebaf) SHA1(bad0c08578877f84325c07d51c6ed76c40b70720) )
+	ROM_LOAD32_WORD( "margmgc.u11", 0x200002, 0x80000, CRC(4901a166) SHA1(8afe6f08b4ac5c17744dff73939c4bc93124fdf1) )
+	ROM_LOAD32_WORD( "margmgc.u8",  0x300000, 0x80000, CRC(b0d78efe) SHA1(bc8b345290f4d31c6553f1e2700bc8324b4eeeac) )
+	ROM_LOAD32_WORD( "margmgc.u12", 0x300002, 0x80000, CRC(90ff59a8) SHA1(c9e342db2b5e8c3f45efa8496bc369385046e920) )
+	ROM_LOAD32_WORD( "margmgc.u9",  0x400000, 0x80000, CRC(1f0ca910) SHA1(be7a2f395eae09a29faf99ba34551fbc38f20fdb) )
+	ROM_LOAD32_WORD( "margmgc.u13", 0x400002, 0x80000, CRC(3f702945) SHA1(a6c9a848d059c1e564fdc5a65bf8c9600853edfa) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( adonis )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "adonis.u7",  0x000000, 0x80000, CRC(ab386ab0) SHA1(56c5baea4272866a9fe18bdc371a49f155251f86) )
-	ROM_LOAD32_WORD( "adonis.u11", 0x000002, 0x80000, CRC(ce8c8449) SHA1(9894f0286f27147dcc437e4406870fe695a6f61a) )
-	ROM_LOAD32_WORD( "adonis.u8",  0x100000, 0x80000, CRC(99097a82) SHA1(a08214ab4781b06b46fc3be5c48288e373230ef4) )
-	ROM_LOAD32_WORD( "adonis.u12", 0x100002, 0x80000, CRC(443a7b6d) SHA1(c19a1c50fb8774826a1e12adacba8bbfce320891) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "adonis.u7",  0x200000, 0x80000, CRC(ab386ab0) SHA1(56c5baea4272866a9fe18bdc371a49f155251f86) )
+	ROM_LOAD32_WORD( "adonis.u11", 0x200002, 0x80000, CRC(ce8c8449) SHA1(9894f0286f27147dcc437e4406870fe695a6f61a) )
+	ROM_LOAD32_WORD( "adonis.u8",  0x300000, 0x80000, CRC(99097a82) SHA1(a08214ab4781b06b46fc3be5c48288e373230ef4) )
+	ROM_LOAD32_WORD( "adonis.u12", 0x300002, 0x80000, CRC(443a7b6d) SHA1(c19a1c50fb8774826a1e12adacba8bbfce320891) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( dmdtouch )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "dmdtouch.u7",  0x000000, 0x80000, CRC(71b19365) SHA1(5a8ba1806af544d33e9acbcbbc0555805b4074e6) )
-	ROM_LOAD32_WORD( "dmdtouch.u11", 0x000002, 0x80000, CRC(3d836342) SHA1(b015a4ba998b39ed86cdb6247c9c7f1365641b59) )
-	ROM_LOAD32_WORD( "dmdtouch.u8",  0x100000, 0x80000, CRC(971bbf63) SHA1(082f81115209c7089c76fb207248da3c347a080b) )
-	ROM_LOAD32_WORD( "dmdtouch.u12", 0x100002, 0x80000, CRC(9e0d08e2) SHA1(38b10f7c37f1cefe9271549073dc0a4fed409aec) )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "dmdtouch.u7",  0x200000, 0x80000, CRC(71b19365) SHA1(5a8ba1806af544d33e9acbcbbc0555805b4074e6) )
+	ROM_LOAD32_WORD( "dmdtouch.u11", 0x200002, 0x80000, CRC(3d836342) SHA1(b015a4ba998b39ed86cdb6247c9c7f1365641b59) )
+	ROM_LOAD32_WORD( "dmdtouch.u8",  0x300000, 0x80000, CRC(971bbf63) SHA1(082f81115209c7089c76fb207248da3c347a080b) )
+	ROM_LOAD32_WORD( "dmdtouch.u12", 0x300002, 0x80000, CRC(9e0d08e2) SHA1(38b10f7c37f1cefe9271549073dc0a4fed409aec) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
 ROM_END
 
 ROM_START( magicmsk )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "magicmsk.u7",  0x000000, 0x80000, CRC(17317eb9) SHA1(3ddb8d61f23461c3194af534928164550208bbee) )
-	ROM_LOAD32_WORD( "magicmsk.u11", 0x000002, 0x80000, CRC(23aefb5a) SHA1(ba4488754794f75f53b9c81b74b6ccd992c64acc) )
-	ROM_LOAD32_WORD( "magicmsk.u8",  0x100000, 0x80000, CRC(23aefb5a) SHA1(ba4488754794f75f53b9c81b74b6ccd992c64acc) )
-	ROM_LOAD32_WORD( "magicmsk.u12", 0x100002, 0x80000, CRC(6829a7bf) SHA1(97eed83763d0ec5e753d6ad194e906b1307c4940) )
-ROM_END
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "magicmsk.u7",  0x200000, 0x80000, CRC(17317eb9) SHA1(3ddb8d61f23461c3194af534928164550208bbee) )
+	ROM_LOAD32_WORD( "magicmsk.u11", 0x200002, 0x80000, CRC(23aefb5a) SHA1(ba4488754794f75f53b9c81b74b6ccd992c64acc) )
+	ROM_LOAD32_WORD( "magicmsk.u8",  0x300000, 0x80000, BAD_DUMP CRC(971bbf63) SHA1(082f81115209c7089c76fb207248da3c347a080b) ) //same as dmdtouch u8 ROM
+	ROM_LOAD32_WORD( "magicmsk.u12", 0x300002, 0x80000, CRC(6829a7bf) SHA1(97eed83763d0ec5e753d6ad194e906b1307c4940) )
 
-ROM_START( geishanz )
-	ROM_REGION( 0x800000, "maincpu", 0 ) /* ARM Code */
-	ROM_LOAD32_WORD( "0101408.u7",  0x000000, 0x80000, CRC(ebdde248) SHA1(83f4f4deb5c6f5b33ae066d50e043a24cb0cbfe0) )
-	ROM_LOAD32_WORD( "0101408.u11", 0x000002, 0x80000, CRC(2f9e7cd4) SHA1(e9498879c9ca66740856c00fda0416f5d9f7c823) )
-	ROM_LOAD32_WORD( "0101408.u8",  0x100000, 0x80000, CRC(87e41b1b) SHA1(029687aeaed701e0f4b8da9d1d60a5a0a9445518) )
-	ROM_LOAD32_WORD( "0101408.u12", 0x100002, 0x80000, CRC(255f2368) SHA1(eb955452e1ed8d9d4f30f3372d7321f01d3654d3) )
-	ROM_LOAD32_WORD( "0101408.u9",  0x200000, 0x80000, CRC(5f161953) SHA1(d07353d006811813b94cb022857f49c4906fd87b) )
-	ROM_LOAD32_WORD( "0101408.u13", 0x200002, 0x80000, CRC(5ef6323e) SHA1(82a720d814ca06c6d286c59bbf325d9a1034375a) )
-ROM_END
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
 
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
+ROM_END
 
-GAME( 1995, swthrt2v, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Sweet Hearts II (C - 07/09/95, Venezuela version)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1995, enchfrst, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Enchanted Forest (E - 23/06/95, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1996, dolphntr, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Dolphin Treasure (B - 06/12/96, NSW/ACT, Rev 1.24.4.0)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1996, dolphtra, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Dolphin Treasure (B - 06/12/96, NSW/ACT, Rev 3)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1997, goldprmd, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Golden Pyramids (B - 13-05-97, USA)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1997, qotn,     0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Queen of the Nile (B - 13-05-97, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1997, dmdtouch, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Diamond Touch (E - 30-06-97, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1998, adonis,   0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Adonis (A - 25-05-98, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1998, reelrock, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Reelin-n-Rockin (A - 13/07/98, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1998, indiandr, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Indian Dreaming (B - 15/12/98, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 2000, magicmsk, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Magic Mask (A - 09/05/2000, Export))", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 2000, margmgc,  0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Margarita Magic (A - 07/07/2000, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 2001, geishanz, 0, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Geisha (A - 05/03/01, New Zealand)", GAME_NOT_WORKING|GAME_NO_SOUND )
+ROM_START( geishanz )
+	ARISTOCRAT_MK5_BIOS
+	ROM_LOAD32_WORD( "0101408.u7",  0x200000, 0x80000, CRC(ebdde248) SHA1(83f4f4deb5c6f5b33ae066d50e043a24cb0cbfe0) )
+	ROM_LOAD32_WORD( "0101408.u11", 0x200002, 0x80000, CRC(2f9e7cd4) SHA1(e9498879c9ca66740856c00fda0416f5d9f7c823) )
+	ROM_LOAD32_WORD( "0101408.u8",  0x300000, 0x80000, CRC(87e41b1b) SHA1(029687aeaed701e0f4b8da9d1d60a5a0a9445518) )
+	ROM_LOAD32_WORD( "0101408.u12", 0x300002, 0x80000, CRC(255f2368) SHA1(eb955452e1ed8d9d4f30f3372d7321f01d3654d3) )
+	ROM_LOAD32_WORD( "0101408.u9",  0x400000, 0x80000, CRC(5f161953) SHA1(d07353d006811813b94cb022857f49c4906fd87b) )
+	ROM_LOAD32_WORD( "0101408.u13", 0x400002, 0x80000, CRC(5ef6323e) SHA1(82a720d814ca06c6d286c59bbf325d9a1034375a) )
+
+	ROM_REGION( 0x800000, "maincpu", ROMREGION_ERASE00 ) /* ARM Code */
+
+	ROM_REGION( 0x200000, "vram", ROMREGION_ERASE00 )
+ROM_END
+
+GAME( 1995, aristmk5, 0,        aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "MK-V System", GAME_NOT_WORKING|GAME_IS_BIOS_ROOT )
+
+GAME( 1995, swthrt2v, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Sweet Hearts II (C - 07/09/95, Venezuela version)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1995, enchfrst, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Enchanted Forest (E - 23/06/95, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1996, dolphntr, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Dolphin Treasure (B - 06/12/96, NSW/ACT, Rev 1.24.4.0)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1996, dolphtra, dolphntr, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Dolphin Treasure (B - 06/12/96, NSW/ACT, Rev 3)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1997, goldprmd, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Golden Pyramids (B - 13-05-97, USA)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1997, qotn,     aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Queen of the Nile (B - 13-05-97, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1997, dmdtouch, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Diamond Touch (E - 30-06-97, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1998, adonis,   aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Adonis (A - 25-05-98, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1998, reelrock, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Reelin-n-Rockin (A - 13/07/98, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 1998, indiandr, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Indian Dreaming (B - 15/12/98, Local)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 2000, magicmsk, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Magic Mask (A - 09/05/2000, Export))", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 2000, margmgc,  aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Margarita Magic (A - 07/07/2000, NSW/ACT)", GAME_NOT_WORKING|GAME_NO_SOUND )
+GAME( 2001, geishanz, aristmk5, aristmk5, aristmk5, aristmk5, ROT0,  "Aristocrat", "Geisha (A - 05/03/01, New Zealand)", GAME_NOT_WORKING|GAME_NO_SOUND )
diff -Nru src-old/mame/drivers/artmagic.c src/mame/drivers/artmagic.c
--- src-old/mame/drivers/artmagic.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/artmagic.c	2010-08-15 17:41:11.000000000 -0700
@@ -93,7 +93,6 @@
 {
 	tms_irq = hack_irq = 0;
 	update_irq_state(machine);
-	tlc34076_reset(6);
 }
 
 
@@ -486,7 +485,7 @@
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM AM_BASE(&artmagic_vram0)
 	AM_RANGE(0x00400000, 0x005fffff) AM_RAM AM_BASE(&artmagic_vram1)
 	AM_RANGE(0x00800000, 0x0080007f) AM_READWRITE(artmagic_blitter_r, artmagic_blitter_w)
-	AM_RANGE(0x00c00000, 0x00c000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x00c00000, 0x00c000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0xc0000000, 0xc00001ff) AM_READWRITE(tms34010_io_register_r, tms34010_io_register_w)
 	AM_RANGE(0xffe00000, 0xffffffff) AM_RAM
 ADDRESS_MAP_END
@@ -496,7 +495,7 @@
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM AM_BASE(&artmagic_vram0)
 	AM_RANGE(0x00400000, 0x005fffff) AM_RAM AM_BASE(&artmagic_vram1)
 	AM_RANGE(0x00800000, 0x0080007f) AM_READWRITE(artmagic_blitter_r, artmagic_blitter_w)
-	AM_RANGE(0x00c00000, 0x00c000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x00c00000, 0x00c000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0xc0000000, 0xc00001ff) AM_READWRITE(tms34010_io_register_r, tms34010_io_register_w)
 	AM_RANGE(0xffc00000, 0xffffffff) AM_RAM
 ADDRESS_MAP_END
@@ -722,6 +721,8 @@
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_START(artmagic)
 	MDRV_VIDEO_UPDATE(tms340x0)
 
diff -Nru src-old/mame/drivers/asterix.c src/mame/drivers/asterix.c
--- src-old/mame/drivers/asterix.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/asterix.c	2010-08-19 01:27:05.000000000 -0700
@@ -107,8 +107,8 @@
 		{
 		case 0x64:
 			{
-			UINT32 param1 = (memory_read_word(space, cmd & 0xffffff) << 16) | memory_read_word(space, (cmd & 0xffffff) + 2);
-			UINT32 param2 = (memory_read_word(space, (cmd & 0xffffff) + 4) << 16) | memory_read_word(space, (cmd & 0xffffff) + 6);
+			UINT32 param1 = (space->read_word(cmd & 0xffffff) << 16) | space->read_word((cmd & 0xffffff) + 2);
+			UINT32 param2 = (space->read_word((cmd & 0xffffff) + 4) << 16) | space->read_word((cmd & 0xffffff) + 6);
 
 			switch (param1 >> 24)
 			{
@@ -119,7 +119,7 @@
 					param2 &= 0xffffff;
 					while(size >= 0)
 					{
-						memory_write_word(space, param2, memory_read_word(space, param1));
+						space->write_word(param2, space->read_word(param1));
 						param1 += 2;
 						param2 += 2;
 						size--;
@@ -147,10 +147,10 @@
 		{
 		case 0x64:
 		{
-			UINT32 param1 = (memory_read_word(space, cmd & 0xffffff) << 16)
-				| memory_read_word(space, (cmd & 0xffffff) + 2);
-			UINT32 param2 = (memory_read_word(space, (cmd & 0xffffff) + 4) << 16)
-				| memory_read_word(space, (cmd & 0xffffff) + 6);
+			UINT32 param1 = (space->read_word(cmd & 0xffffff) << 16)
+				| space->read_word((cmd & 0xffffff) + 2);
+			UINT32 param2 = (space->read_word((cmd & 0xffffff) + 4) << 16)
+				| space->read_word((cmd & 0xffffff) + 6);
 
 			switch (param1 >> 24)
 			{
@@ -161,7 +161,7 @@
 				param2 &= 0xffffff;
 				while(size >= 0)
 				{
-					memory_write_word(space, param2, memory_read_word(space, param1));
+					space->write_word(param2, space->read_word(param1));
 					param1 += 2;
 					param2 += 2;
 					size--;
diff -Nru src-old/mame/drivers/asteroid.c src/mame/drivers/asteroid.c
--- src-old/mame/drivers/asteroid.c	2010-06-30 17:34:46.000000000 -0700
+++ src/mame/drivers/asteroid.c	2010-08-13 01:54:21.000000000 -0700
@@ -249,7 +249,7 @@
 	AM_RANGE(0x3a00, 0x3a00) AM_DEVWRITE("discrete", asteroid_thump_w)
 	AM_RANGE(0x3c00, 0x3c05) AM_DEVWRITE("discrete", asteroid_sounds_w)
 	AM_RANGE(0x3e00, 0x3e00) AM_DEVWRITE("discrete", asteroid_noise_reset_w)
-	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x4000)
+	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x4000)
 	AM_RANGE(0x5000, 0x57ff) AM_ROM						/* vector rom */
 	AM_RANGE(0x6800, 0x7fff) AM_ROM
 ADDRESS_MAP_END
@@ -275,7 +275,7 @@
 	AM_RANGE(0x3c04, 0x3c04) AM_WRITE(astdelux_bank_switch_w)
 	AM_RANGE(0x3c05, 0x3c07) AM_WRITE(astdelux_coin_counter_w)
 	AM_RANGE(0x3e00, 0x3e00) AM_DEVWRITE("discrete", asteroid_noise_reset_w)
-	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x4000)
+	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x4000)
 	AM_RANGE(0x4800, 0x57ff) AM_ROM						/* vector rom */
 	AM_RANGE(0x6000, 0x7fff) AM_ROM
 ADDRESS_MAP_END
@@ -293,7 +293,7 @@
 	AM_RANGE(0x3400, 0x3400) AM_WRITE(watchdog_reset_w)
 	AM_RANGE(0x3c00, 0x3c00) AM_DEVWRITE("discrete", llander_sounds_w)
 	AM_RANGE(0x3e00, 0x3e00) AM_DEVWRITE("discrete", llander_snd_reset_w)
-	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x4000)
+	AM_RANGE(0x4000, 0x47ff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x4000)
 	AM_RANGE(0x4800, 0x5fff) AM_ROM						/* vector rom */
 	AM_RANGE(0x6000, 0x7fff) AM_ROM
 ADDRESS_MAP_END
diff -Nru src-old/mame/drivers/astrocde.c src/mame/drivers/astrocde.c
--- src-old/mame/drivers/astrocde.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/astrocde.c	2010-08-19 00:26:14.000000000 -0700
@@ -455,7 +455,7 @@
 
 static STATE_POSTLOAD( profbank_banksw_restore )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	profpac_banksw_w(space, 0, profpac_bank);
 }
@@ -1766,7 +1766,7 @@
 
 static DRIVER_INIT( profpac )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	astrocade_video_config = AC_SOUND_PRESENT;
 	memory_install_read8_handler(iospace, 0x14, 0x14, 0x0fff, 0xff00, profpac_io_1_r);
@@ -1780,7 +1780,7 @@
 
 static DRIVER_INIT( demndrgn )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	astrocade_video_config = 0x00;
 	memory_install_read8_handler(iospace, 0x14, 0x14, 0x1fff, 0xff00, demndrgn_io_r);
@@ -1796,7 +1796,7 @@
 
 static DRIVER_INIT( tenpindx )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	astrocade_video_config = 0x00;
 	memory_install_read_port(iospace, 0x60, 0x60, 0x0000, 0xff00, "P60");
diff -Nru src-old/mame/drivers/atarig42.c src/mame/drivers/atarig42.c
--- src-old/mame/drivers/atarig42.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/atarig42.c	2010-08-18 23:57:51.000000000 -0700
@@ -138,12 +138,12 @@
  *
  *************************************/
 
-static DIRECT_UPDATE_HANDLER( sloop_direct_handler )
+DIRECT_UPDATE_HANDLER( atarig42_sloop_direct_handler )
 {
-	atarig42_state *state = space->machine->driver_data<atarig42_state>();
 	if (address < 0x80000)
 	{
-		direct->raw = direct->decrypted = (UINT8 *)state->sloop_base;
+		atarig42_state *state = machine->driver_data<atarig42_state>();
+		direct.explicit_configure(0x00000, 0x7ffff, 0x7ffff, state->sloop_base);
 		return (offs_t)-1;
 	}
 	return address;
@@ -696,8 +696,9 @@
 	state->motion_object_base = 0x200;
 	state->motion_object_mask = 0x1ff;
 
-	state->sloop_base = memory_install_readwrite16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x000000, 0x07ffff, 0, 0, roadriot_sloop_data_r, roadriot_sloop_data_w);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sloop_direct_handler);
+	address_space *main = machine->device<m68000_device>("maincpu")->space(AS_PROGRAM);
+	state->sloop_base = memory_install_readwrite16_handler(main, 0x000000, 0x07ffff, 0, 0, roadriot_sloop_data_r, roadriot_sloop_data_w);
+	main->set_direct_update_handler(direct_update_delegate_create_static(atarig42_sloop_direct_handler, *machine));
 
 	asic65_config(machine, ASIC65_ROMBASED);
 /*
@@ -750,8 +751,9 @@
 	/* put an RTS there so we don't die */
 	*(UINT16 *)&memory_region(machine, "maincpu")[0x80000] = 0x4E75;
 
-	state->sloop_base = memory_install_readwrite16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x000000, 0x07ffff, 0, 0, guardians_sloop_data_r, guardians_sloop_data_w);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), sloop_direct_handler);
+	address_space *main = machine->device<m68000_device>("maincpu")->space(AS_PROGRAM);
+	state->sloop_base = memory_install_readwrite16_handler(main, 0x000000, 0x07ffff, 0, 0, guardians_sloop_data_r, guardians_sloop_data_w);
+	main->set_direct_update_handler(direct_update_delegate_create_static(atarig42_sloop_direct_handler, *machine));
 
 	asic65_config(machine, ASIC65_GUARDIANS);
 /*
diff -Nru src-old/mame/drivers/atarigt.c src/mame/drivers/atarigt.c
--- src-old/mame/drivers/atarigt.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/atarigt.c	2010-08-19 01:27:05.000000000 -0700
@@ -81,7 +81,7 @@
 
 static void cage_irq_callback(running_machine *machine, int reason)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if (reason)
 		atarigen_sound_int_gen(machine->device("maincpu"));
@@ -280,7 +280,7 @@
 }
 
 
-static void tmek_protection_w(const address_space *space, offs_t offset, UINT16 data)
+static void tmek_protection_w(address_space *space, offs_t offset, UINT16 data)
 {
 /*
     T-Mek init:
@@ -303,7 +303,7 @@
 	}
 }
 
-static void tmek_protection_r(const address_space *space, offs_t offset, UINT16 *data)
+static void tmek_protection_r(address_space *space, offs_t offset, UINT16 *data)
 {
 	if (LOG_PROTECTION) logerror("%06X:Protection R@%06X\n", cpu_get_previouspc(space->cpu), offset);
 
@@ -369,7 +369,7 @@
 
 
 
-static void primrage_protection_w(const address_space *space, offs_t offset, UINT16 data)
+static void primrage_protection_w(address_space *space, offs_t offset, UINT16 data)
 {
 	if (LOG_PROTECTION)
 	{
@@ -439,7 +439,7 @@
 
 
 
-static void primrage_protection_r(const address_space *space, offs_t offset, UINT16 *data)
+static void primrage_protection_r(address_space *space, offs_t offset, UINT16 *data)
 {
 	/* track accesses */
 	primage_update_mode(offset);
@@ -467,8 +467,8 @@
 			break;
 		case 0x275cc:
 			a6 = cpu_get_reg(space->cpu, M68K_A6);
-			p1 = (memory_read_word(space, a6+8) << 16) | memory_read_word(space, a6+10);
-			p2 = (memory_read_word(space, a6+12) << 16) | memory_read_word(space, a6+14);
+			p1 = (space->read_word(a6+8) << 16) | space->read_word(a6+10);
+			p2 = (space->read_word(a6+12) << 16) | space->read_word(a6+14);
 			logerror("Known Protection @ 275BC(%08X, %08X): R@%06X ", p1, p2, offset);
 			break;
 		case 0x275d2:
@@ -485,7 +485,7 @@
 		/* protection code from 3d8dc - 3d95a */
 		case 0x3d8f4:
 			a6 = cpu_get_reg(space->cpu, M68K_A6);
-			p1 = (memory_read_word(space, a6+12) << 16) | memory_read_word(space, a6+14);
+			p1 = (space->read_word(a6+12) << 16) | space->read_word(a6+14);
 			logerror("Known Protection @ 3D8F4(%08X): R@%06X ", p1, offset);
 			break;
 		case 0x3d8fa:
@@ -496,7 +496,7 @@
 		/* protection code from 437fa - 43860 */
 		case 0x43814:
 			a6 = cpu_get_reg(space->cpu, M68K_A6);
-			p1 = memory_read_dword(space, a6+14) & 0xffffff;
+			p1 = space->read_dword(a6+14) & 0xffffff;
 			logerror("Known Protection @ 43814(%08X): R@%06X ", p1, offset);
 			break;
 		case 0x4381c:
diff -Nru src-old/mame/drivers/atarisy2.c src/mame/drivers/atarisy2.c
--- src-old/mame/drivers/atarisy2.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/atarisy2.c	2010-08-19 00:26:14.000000000 -0700
@@ -208,14 +208,13 @@
  *
  *************************************/
 
-static DIRECT_UPDATE_HANDLER( atarisy2_direct_handler )
+DIRECT_UPDATE_HANDLER( atarisy2_direct_handler )
 {
-	atarisy2_state *state = space->machine->driver_data<atarisy2_state>();
-
 	/* make sure slapstic area looks like ROM */
 	if (address >= 0x8000 && address < 0x8200)
 	{
-		direct->raw = direct->decrypted = (UINT8 *)state->slapstic_base - 0x8000;
+		atarisy2_state *state = machine->driver_data<atarisy2_state>();
+		direct.explicit_configure(0x8000, 0x81ff, 0x1ff, (UINT8 *)state->slapstic_base);
 		return ~0;
 	}
 	return address;
@@ -245,7 +244,9 @@
 	atarigen_interrupt_reset(state, update_interrupts);
 	atarigen_sound_io_reset(machine->device("soundcpu"));
 	atarigen_scanline_timer_reset(*machine->primary_screen, scanline_update, 64);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), atarisy2_direct_handler);
+
+	address_space *main = machine->device<t11_device>("maincpu")->space(AS_PROGRAM);
+	main->set_direct_update_handler(direct_update_delegate_create_static(atarisy2_direct_handler, *machine));
 
 	state->p2portwr_state = 0;
 	state->p2portrd_state = 0;
@@ -345,7 +346,7 @@
 
 static STATE_POSTLOAD( bankselect_postload )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	atarisy2_state *state = machine->driver_data<atarisy2_state>();
 
 	bankselect_w(space, 0, state->bankselect[0], 0xffff);
diff -Nru src-old/mame/drivers/atarisy4.c src/mame/drivers/atarisy4.c
--- src-old/mame/drivers/atarisy4.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/atarisy4.c	2010-08-19 01:27:05.000000000 -0700
@@ -776,7 +776,7 @@
 		return in;
 }
 
-void load_ldafile(const address_space *space, const UINT8 *file)
+void load_ldafile(address_space *space, const UINT8 *file)
 {
 #define READ_CHAR()		file[i++]
 	int i = 0;
@@ -819,7 +819,7 @@
 		{
 			UINT8 data = READ_CHAR();
 			sum += data;
-			memory_write_byte(space, addr++, data);
+			space->write_byte(addr++, data);
 		} while (--len);
 
 		sum += READ_CHAR();
@@ -830,7 +830,7 @@
 }
 
 /* Load memory space with data from a Tektronix-Extended HEX file */
-void load_hexfile(const address_space *space, const UINT8 *file)
+void load_hexfile(address_space *space, const UINT8 *file)
 {
 #define READ_HEX_CHAR()		hex_to_ascii(file[i++])
 
@@ -914,7 +914,7 @@
 			sum += data & 0xf;
 
 			if (record == 6)
-				memory_write_byte(space, addr++, data);
+				space->write_byte(addr++, data);
 
 			len -= 2;
 		}
@@ -935,7 +935,7 @@
 
 static DRIVER_INIT( laststar )
 {
-	const address_space *main = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *main = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Allocate 16kB of shared RAM */
 	shared_ram[0] = auto_alloc_array_clear(machine, UINT16, 0x2000);
diff -Nru src-old/mame/drivers/attckufo.c src/mame/drivers/attckufo.c
--- src-old/mame/drivers/attckufo.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/attckufo.c	2010-08-19 01:27:05.000000000 -0700
@@ -172,13 +172,13 @@
 static int attckufo_dma_read( running_machine *machine, int offset )
 {
 	attckufo_state *state = machine->driver_data<attckufo_state>();
-	return memory_read_byte(state->maincpu->space(AS_PROGRAM), offset);
+	return state->maincpu->space(AS_PROGRAM)->read_byte(offset);
 }
 
 static int attckufo_dma_read_color( running_machine *machine, int offset )
 {
 	attckufo_state *state = machine->driver_data<attckufo_state>();
-	return memory_read_byte(state->maincpu->space(AS_PROGRAM), offset + 0x400);
+	return state->maincpu->space(AS_PROGRAM)->read_byte(offset + 0x400);
 }
 
 static const mos6560_interface attckufo_6560_intf =
diff -Nru src-old/mame/drivers/badlands.c src/mame/drivers/badlands.c
--- src-old/mame/drivers/badlands.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/badlands.c	2010-08-19 00:26:14.000000000 -0700
@@ -186,7 +186,7 @@
 
 static void scanline_update(screen_device &screen, int scanline)
 {
-	const address_space *space = cputag_get_address_space(screen.machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(screen.machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	/* sound IRQ is on 32V */
 	if (scanline & 32)
diff -Nru src-old/mame/drivers/bagman.c src/mame/drivers/bagman.c
--- src-old/mame/drivers/bagman.c	2010-06-02 08:53:52.000000000 -0700
+++ src/mame/drivers/bagman.c	2010-08-19 00:26:14.000000000 -0700
@@ -73,7 +73,7 @@
 
 static WRITE8_DEVICE_HANDLER( bagman_ls259_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	bagman_pal16r6_w(space, offset,data); /*this is just a simulation*/
 
 	if (ls259_buf[offset] != (data&1) )
diff -Nru src-old/mame/drivers/balsente.c src/mame/drivers/balsente.c
--- src-old/mame/drivers/balsente.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/balsente.c	2010-08-19 00:26:14.000000000 -0700
@@ -2135,45 +2135,45 @@
 static DRIVER_INIT( toggle )   { expand_roms(machine, EXPAND_ALL);  config_shooter_adc(machine, FALSE, 0 /* noanalog */); }
 static DRIVER_INIT( nametune )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_write8_handler(space, 0x9f00, 0x9f00, 0, 0, balsente_rombank2_select_w);
 	expand_roms(machine, EXPAND_NONE | SWAP_HALVES); config_shooter_adc(machine, FALSE, 0 /* noanalog */);
 }
 static DRIVER_INIT( nstocker )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_write8_handler(space, 0x9f00, 0x9f00, 0, 0, balsente_rombank2_select_w);
 	expand_roms(machine, EXPAND_NONE | SWAP_HALVES); config_shooter_adc(machine, TRUE, 1);
 }
 static DRIVER_INIT( sfootbal )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_write8_handler(space, 0x9f00, 0x9f00, 0, 0, balsente_rombank2_select_w);
 	expand_roms(machine, EXPAND_ALL  | SWAP_HALVES); config_shooter_adc(machine, FALSE, 0);
 }
 static DRIVER_INIT( spiker )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_readwrite8_handler(space, 0x9f80, 0x9f8f, 0, 0, spiker_expand_r, spiker_expand_w);
 	memory_install_write8_handler(space, 0x9f00, 0x9f00, 0, 0, balsente_rombank2_select_w);
 	expand_roms(machine, EXPAND_ALL  | SWAP_HALVES); config_shooter_adc(machine, FALSE, 1);
 }
 static DRIVER_INIT( stompin )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_write8_handler(space, 0x9f00, 0x9f00, 0, 0, balsente_rombank2_select_w);
 	expand_roms(machine, 0x0c | SWAP_HALVES); config_shooter_adc(machine, FALSE, 32);
 }
 static DRIVER_INIT( rescraid ) { expand_roms(machine, EXPAND_NONE); config_shooter_adc(machine, FALSE, 0 /* noanalog */); }
 static DRIVER_INIT( grudge )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_read8_handler(space, 0x9400, 0x9400, 0, 0, grudge_steering_r);
 	expand_roms(machine, EXPAND_NONE); config_shooter_adc(machine, FALSE, 0);
 }
 static DRIVER_INIT( shrike )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_readwrite8_handler(space, 0x9e00, 0x9fff, 0, 0, shrike_shared_6809_r, shrike_shared_6809_w);
 	memory_install_write8_handler(space, 0x9e01, 0x9e01, 0, 0, shrike_sprite_select_w );
 	memory_install_readwrite16_handler(cputag_get_address_space(machine, "68k", ADDRESS_SPACE_PROGRAM), 0x10000, 0x1001f, 0, 0, shrike_io_68k_r, shrike_io_68k_w);
diff -Nru src-old/mame/drivers/bbusters.c src/mame/drivers/bbusters.c
--- src-old/mame/drivers/bbusters.c	2010-05-04 18:10:40.000000000 -0700
+++ src/mame/drivers/bbusters.c	2010-08-26 20:55:49.000000000 -0700
@@ -202,20 +202,9 @@
 #include "cpu/m68000/m68000.h"
 #include "sound/2608intf.h"
 #include "sound/2610intf.h"
+#include "includes/bbusters.h"
 
 
-VIDEO_START( bbuster );
-VIDEO_START( mechatt );
-VIDEO_UPDATE( bbuster );
-VIDEO_UPDATE( mechatt );
-
-static UINT16 *bbusters_ram, *eprom_data;
-extern UINT16 *bbusters_pf1_data,*bbusters_pf2_data,*bbusters_pf1_scroll_data,*bbusters_pf2_scroll_data;
-
-WRITE16_HANDLER( bbusters_pf1_w );
-WRITE16_HANDLER( bbusters_pf2_w );
-WRITE16_HANDLER( bbusters_video_w );
-
 /******************************************************************************/
 
 
@@ -247,45 +236,43 @@
 
 /******************************************************************************/
 
-static int sound_status;
-
 static READ16_HANDLER( sound_status_r )
 {
-	return sound_status;
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
+
+	return state->sound_status;
 }
 
 static WRITE8_HANDLER( sound_status_w )
 {
-	sound_status = data;
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
 
+	state->sound_status = data;
 }
 
 static WRITE16_HANDLER( sound_cpu_w )
 {
-
 	if (ACCESSING_BITS_0_7)
 	{
-
-
 		soundlatch_w(space, 0, data&0xff);
 		cputag_set_input_line(space->machine, "audiocpu", INPUT_LINE_NMI, PULSE_LINE);
 	}
-
 }
 
 /* Eprom is byte wide, top half of word _must_ be 0xff */
 static READ16_HANDLER( eprom_r )
 {
-	return (eprom_data[offset]&0xff) | 0xff00;
-}
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
 
-static int gun_select;
+	return (state->eprom_data[offset]&0xff) | 0xff00;
+}
 
 static READ16_HANDLER( control_3_r )
 {
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
 	static const char *const port[] = { "GUNX1", "GUNY1", "GUNX2", "GUNY2", "GUNX3", "GUNY3" };
 
-	UINT16 retdata =  input_port_read(space->machine, port[gun_select]);
+	UINT16 retdata = input_port_read(space->machine, port[state->gun_select]);
 
 	retdata >>=1; // by lowering the precision of the gun reading hardware the game seems to work better
 
@@ -294,20 +281,19 @@
 
 static WRITE16_HANDLER( gun_select_w )
 {
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
+
 	logerror("%08x: gun r\n",cpu_get_pc(space->cpu));
 
 	cpu_set_input_line(space->cpu, 2, HOLD_LINE);
 
-	gun_select = data & 0xff;
-
+	state->gun_select = data & 0xff;
 }
 
 static WRITE16_HANDLER( two_gun_output_w )
 {
 	output_set_value("Player1_Gun_Recoil",(data & 0x01));
 	output_set_value("Player2_Gun_Recoil",(data & 0x02)>>1);
-
-
 }
 
 static WRITE16_HANDLER( three_gun_output_w )
@@ -315,15 +301,12 @@
 	output_set_value("Player1_Gun_Recoil",(data & 0x01));
 	output_set_value("Player2_Gun_Recoil",(data & 0x02)>>1);
 	output_set_value("Player3_Gun_Recoil",(data & 0x04)>>2);
-
-
 }
 
 static READ16_HANDLER( kludge_r )
 {
 	// might latch the gun value?
 	return 0x0000;
-
 }
 
 static READ16_HANDLER( mechatt_gun_r )
@@ -345,17 +328,17 @@
 
 static ADDRESS_MAP_START( bbusters_map, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
-	AM_RANGE(0x080000, 0x08ffff) AM_RAM AM_BASE(&bbusters_ram)
-	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0x080000, 0x08ffff) AM_RAM AM_BASE_MEMBER(bbusters_state, ram)
+	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_MEMBER(bbusters_state, videoram)
 	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
 	AM_RANGE(0x0a1000, 0x0a7fff) AM_RAM		/* service mode */
 	AM_RANGE(0x0a8000, 0x0a8fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram2)
 	AM_RANGE(0x0a9000, 0x0affff) AM_RAM		/* service mode */
-	AM_RANGE(0x0b0000, 0x0b1fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE(&bbusters_pf1_data)
-	AM_RANGE(0x0b2000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf2_w) AM_BASE(&bbusters_pf2_data)
+	AM_RANGE(0x0b0000, 0x0b1fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE_MEMBER(bbusters_state, pf1_data)
+	AM_RANGE(0x0b2000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf2_w) AM_BASE_MEMBER(bbusters_state, pf2_data)
 	AM_RANGE(0x0b4000, 0x0b5fff) AM_RAM		/* service mode */
-	AM_RANGE(0x0b8000, 0x0b8003) AM_WRITEONLY AM_BASE(&bbusters_pf1_scroll_data)
-	AM_RANGE(0x0b8008, 0x0b800b) AM_WRITEONLY AM_BASE(&bbusters_pf2_scroll_data)
+	AM_RANGE(0x0b8000, 0x0b8003) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, pf1_scroll_data)
+	AM_RANGE(0x0b8008, 0x0b800b) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, pf2_scroll_data)
 	AM_RANGE(0x0d0000, 0x0d0fff) AM_RAM_WRITE(paletteram16_RRRRGGGGBBBBxxxx_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x0e0000, 0x0e0001) AM_READ_PORT("COINS")	/* Coins */
 	AM_RANGE(0x0e0002, 0x0e0003) AM_READ_PORT("IN0")	/* Player 1 & 2 */
@@ -368,21 +351,21 @@
 	/* AM_RANGE(0x0f0008, 0x0f0009) AM_WRITENOP */
 	AM_RANGE(0x0f0008, 0x0f0009) AM_WRITE(three_gun_output_w)
 	AM_RANGE(0x0f0018, 0x0f0019) AM_WRITE(sound_cpu_w)
-	AM_RANGE(0x0f8000, 0x0f80ff) AM_READ(eprom_r) AM_WRITEONLY AM_BASE(&eprom_data) /* Eeprom */
+	AM_RANGE(0x0f8000, 0x0f80ff) AM_READ(eprom_r) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, eprom_data) /* Eeprom */
 ADDRESS_MAP_END
 
 /*******************************************************************************/
 
 static ADDRESS_MAP_START( mechatt_map, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x06ffff) AM_ROM
-	AM_RANGE(0x070000, 0x07ffff) AM_RAM AM_BASE(&bbusters_ram)
-	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0x070000, 0x07ffff) AM_RAM AM_BASE_MEMBER(bbusters_state, ram)
+	AM_RANGE(0x090000, 0x090fff) AM_RAM_WRITE(bbusters_video_w) AM_BASE_MEMBER(bbusters_state, videoram)
 	AM_RANGE(0x0a0000, 0x0a0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
 	AM_RANGE(0x0a1000, 0x0a7fff) AM_WRITENOP
-	AM_RANGE(0x0b0000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE(&bbusters_pf1_data)
-	AM_RANGE(0x0b8000, 0x0b8003) AM_WRITEONLY AM_BASE(&bbusters_pf1_scroll_data)
-	AM_RANGE(0x0c0000, 0x0c3fff) AM_RAM_WRITE(bbusters_pf2_w) AM_BASE(&bbusters_pf2_data)
-	AM_RANGE(0x0c8000, 0x0c8003) AM_WRITEONLY AM_BASE(&bbusters_pf2_scroll_data)
+	AM_RANGE(0x0b0000, 0x0b3fff) AM_RAM_WRITE(bbusters_pf1_w) AM_BASE_MEMBER(bbusters_state, pf1_data)
+	AM_RANGE(0x0b8000, 0x0b8003) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, pf1_scroll_data)
+	AM_RANGE(0x0c0000, 0x0c3fff) AM_RAM_WRITE(bbusters_pf2_w) AM_BASE_MEMBER(bbusters_state, pf2_data)
+	AM_RANGE(0x0c8000, 0x0c8003) AM_WRITEONLY AM_BASE_MEMBER(bbusters_state, pf2_scroll_data)
 	AM_RANGE(0x0d0000, 0x0d07ff) AM_RAM_WRITE(paletteram16_RRRRGGGGBBBBxxxx_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x0e0000, 0x0e0001) AM_READ_PORT("IN0")
 	AM_RANGE(0x0e0002, 0x0e0003) AM_READ_PORT("DSW1")
@@ -681,7 +664,8 @@
 /******************************************************************************/
 
 // default eeprom with reasonable calibration for MAME
-static const unsigned char bbusters_default_eeprom[128] = {
+static const unsigned char bbusters_default_eeprom[128] =
+{
 	                                    /*y*/                   /*y*/
 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00, 0x00, 0x00, 0xEE, 0x00,
 	0x00, 0x00, 0x00, 0x00,	0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0xFE, 0x00,
@@ -703,20 +687,24 @@
 
 static NVRAM_HANDLER( bbusters )
 {
-	if( read_or_write ) {
-		mame_fwrite (file, eprom_data, 0x80);
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+
+	if( read_or_write )
+	{
+		mame_fwrite (file, state->eprom_data, 0x80);
 	}
-	else {
+	else
+	{
 		if (file)
-			mame_fread (file, eprom_data, 0x80);
+			mame_fread (file, state->eprom_data, 0x80);
 		else
-			memcpy(eprom_data, bbusters_default_eeprom, 0x80);
+			memcpy(state->eprom_data, bbusters_default_eeprom, 0x80);
 	}
 }
 
 static VIDEO_EOF( bbuster )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space,0,0,0xffff);
 	buffer_spriteram16_2_w(space,0,0,0xffff);
@@ -724,12 +712,14 @@
 
 static VIDEO_EOF( mechatt )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram16_w(space,0,0,0xffff);
 }
 
 static MACHINE_DRIVER_START( bbusters )
 
+	MDRV_DRIVER_DATA( bbusters_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, 12000000)
 	MDRV_CPU_PROGRAM_MAP(bbusters_map)
@@ -769,6 +759,8 @@
 
 static MACHINE_DRIVER_START( mechatt )
 
+	MDRV_DRIVER_DATA( bbusters_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, 12000000)
 	MDRV_CPU_PROGRAM_MAP(mechatt_map)
diff -Nru src-old/mame/drivers/beathead.c src/mame/drivers/beathead.c
--- src-old/mame/drivers/beathead.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/beathead.c	2010-08-21 16:47:07.000000000 -0700
@@ -96,11 +96,9 @@
 
 ***************************************************************************/
 
+#define ADDRESS_MAP_MODERN
 
 #include "emu.h"
-#include "cpu/asap/asap.h"
-#include "machine/atarigen.h"
-#include "audio/atarijsa.h"
 #include "includes/beathead.h"
 
 
@@ -115,8 +113,6 @@
  *
  *************************************/
 
-static void update_interrupts(running_machine *machine);
-
 static TIMER_DEVICE_CALLBACK( scanline_callback )
 {
 	beathead_state *state = timer.machine->driver_data<beathead_state>();
@@ -135,42 +131,41 @@
 		scanline = 0;
 
 	/* set the scanline IRQ */
-	state->irq_state[2] = 1;
-	update_interrupts(timer.machine);
+	state->m_irq_state[2] = 1;
+	state->update_interrupts();
 
 	/* set the timer for the next one */
-	timer.adjust(double_to_attotime(attotime_to_double(timer.machine->primary_screen->time_until_pos(scanline)) - state->hblank_offset), scanline);
+	timer.adjust(double_to_attotime(attotime_to_double(timer.machine->primary_screen->time_until_pos(scanline)) - state->m_hblank_offset), scanline);
 }
 
 
-static MACHINE_START( beathead )
+void beathead_state::machine_start()
 {
-	atarigen_init(machine);
+	atarigen_init(&m_machine);
 }
 
 
-static MACHINE_RESET( beathead )
+static void update_interrupts(running_machine *machine) { machine->driver_data<beathead_state>()->update_interrupts(); }
+void beathead_state::machine_reset()
 {
-	beathead_state *state = machine->driver_data<beathead_state>();
-
 	/* reset the common subsystems */
-	atarigen_eeprom_reset(state);
-	atarigen_interrupt_reset(state, update_interrupts);
+	atarigen_eeprom_reset(this);
+	atarigen_interrupt_reset(this, ::update_interrupts);
 	atarijsa_reset();
 
 	/* the code is temporarily mapped at 0 at startup */
 	/* just copying the first 0x40 bytes is sufficient */
-	memcpy(state->ram_base, state->rom_base, 0x40);
+	memcpy(m_ram_base, m_rom_base, 0x40);
 
 	/* compute the timing of the HBLANK interrupt and set the first timer */
-	state->hblank_offset = attotime_to_double(machine->primary_screen->scan_period()) * ((455. - 336. - 25.) / 455.);
-	timer_device *scanline_timer = machine->device<timer_device>("scan_timer");
-	scanline_timer->adjust(double_to_attotime(attotime_to_double(machine->primary_screen->time_until_pos(0)) - state->hblank_offset));
+	m_hblank_offset = attotime_to_double(m_machine.primary_screen->scan_period()) * ((455. - 336. - 25.) / 455.);
+	timer_device *scanline_timer = m_machine.device<timer_device>("scan_timer");
+	scanline_timer->adjust(double_to_attotime(attotime_to_double(m_machine.primary_screen->time_until_pos(0)) - m_hblank_offset));
 
 	/* reset IRQs */
-	state->irq_line_state = CLEAR_LINE;
-	state->irq_state[0] = state->irq_state[1] = state->irq_state[2] = 0;
-	state->irq_enable[0] = state->irq_enable[1] = state->irq_enable[2] = 0;
+	m_irq_line_state = CLEAR_LINE;
+	m_irq_state[0] = m_irq_state[1] = m_irq_state[2] = 0;
+	m_irq_enable[0] = m_irq_enable[1] = m_irq_enable[2] = 0;
 }
 
 
@@ -181,54 +176,50 @@
  *
  *************************************/
 
-static void update_interrupts(running_machine *machine)
+void beathead_state::update_interrupts()
 {
-	beathead_state *state = machine->driver_data<beathead_state>();
 	int gen_int;
 
 	/* compute the combined interrupt signal */
-	gen_int  = state->irq_state[0] & state->irq_enable[0];
-	gen_int |= state->irq_state[1] & state->irq_enable[1];
-	gen_int |= state->irq_state[2] & state->irq_enable[2];
+	gen_int  = m_irq_state[0] & m_irq_enable[0];
+	gen_int |= m_irq_state[1] & m_irq_enable[1];
+	gen_int |= m_irq_state[2] & m_irq_enable[2];
 	gen_int  = gen_int ? ASSERT_LINE : CLEAR_LINE;
 
 	/* if it's changed since the last time, call through */
-	if (state->irq_line_state != gen_int)
+	if (m_irq_line_state != gen_int)
 	{
-		state->irq_line_state = gen_int;
-		//if (state->irq_line_state != CLEAR_LINE)
-			cputag_set_input_line(machine, "maincpu", ASAP_IRQ0, state->irq_line_state);
+		m_irq_line_state = gen_int;
+		//if (m_irq_line_state != CLEAR_LINE)
+			cputag_set_input_line(&m_machine, "maincpu", ASAP_IRQ0, m_irq_line_state);
 		//else
-			//asap_set_irq_line(ASAP_IRQ0, state->irq_line_state);
+			//asap_set_irq_line(ASAP_IRQ0, m_irq_line_state);
 	}
 }
 
 
-static WRITE32_HANDLER( interrupt_control_w )
+WRITE32_MEMBER( beathead_state::interrupt_control_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
 	int irq = offset & 3;
 	int control = (offset >> 2) & 1;
 
 	/* offsets 1-3 seem to be the enable latches for the IRQs */
 	if (irq != 0)
-		state->irq_enable[irq - 1] = control;
+		m_irq_enable[irq - 1] = control;
 
 	/* offset 0 seems to be the interrupt ack */
 	else
-		state->irq_state[0] = state->irq_state[1] = state->irq_state[2] = 0;
+		m_irq_state[0] = m_irq_state[1] = m_irq_state[2] = 0;
 
 	/* update the current state */
-	update_interrupts(space->machine);
+	update_interrupts();
 }
 
 
-static READ32_HANDLER( interrupt_control_r )
+READ32_MEMBER( beathead_state::interrupt_control_r )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
 	/* return the enables as a bitfield */
-	return (state->irq_enable[0]) | (state->irq_enable[1] << 1) | (state->irq_enable[2] << 2);
+	return (m_irq_enable[0]) | (m_irq_enable[1] << 1) | (m_irq_enable[2] << 2);
 }
 
 
@@ -239,24 +230,20 @@
  *
  *************************************/
 
-static WRITE32_HANDLER( eeprom_data_w )
+WRITE32_MEMBER( beathead_state::eeprom_data_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
-	if (state->eeprom_enabled)
+	if (m_eeprom_enabled)
 	{
 		mem_mask &= 0x000000ff;
-		COMBINE_DATA(space->machine->generic.nvram.u32 + offset);
-		state->eeprom_enabled = 0;
+		COMBINE_DATA(m_machine.generic.nvram.u32 + offset);
+		m_eeprom_enabled = 0;
 	}
 }
 
 
-static WRITE32_HANDLER( eeprom_enable_w )
+WRITE32_MEMBER( beathead_state::eeprom_enable_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
-	state->eeprom_enabled = 1;
+	m_eeprom_enabled = 1;
 }
 
 
@@ -267,12 +254,11 @@
  *
  *************************************/
 
-static READ32_HANDLER( input_2_r )
+READ32_MEMBER( beathead_state::input_2_r )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-	int result = input_port_read(space->machine, "IN2");
-	if (state->sound_to_cpu_ready) result ^= 0x10;
-	if (state->cpu_to_sound_ready) result ^= 0x20;
+	int result = input_port_read(&m_machine, "IN2");
+	if (sound_to_cpu_ready) result ^= 0x10;
+	if (cpu_to_sound_ready) result ^= 0x20;
 	return result;
 }
 
@@ -284,23 +270,23 @@
  *
  *************************************/
 
-static READ32_HANDLER( sound_data_r )
+READ32_MEMBER( beathead_state::sound_data_r )
 {
-	return atarigen_sound_r(space,offset,0xffff);
+	return atarigen_sound_r(&space, offset, 0xffff);
 }
 
 
-static WRITE32_HANDLER( sound_data_w )
+WRITE32_MEMBER( beathead_state::sound_data_w )
 {
 	if (ACCESSING_BITS_0_7)
-		atarigen_sound_w(space,offset, data, mem_mask);
+		atarigen_sound_w(&space, offset, data, mem_mask);
 }
 
 
-static WRITE32_HANDLER( sound_reset_w )
+WRITE32_MEMBER( beathead_state::sound_reset_w )
 {
 	logerror("Sound reset = %d\n", !offset);
-	cputag_set_input_line(space->machine, "jsa", INPUT_LINE_RESET, offset ? CLEAR_LINE : ASSERT_LINE);
+	cputag_set_input_line(&m_machine, "jsa", INPUT_LINE_RESET, offset ? CLEAR_LINE : ASSERT_LINE);
 }
 
 
@@ -311,9 +297,9 @@
  *
  *************************************/
 
-static WRITE32_HANDLER( coin_count_w )
+WRITE32_MEMBER( beathead_state::coin_count_w )
 {
-	coin_counter_w(space->machine, 0, !offset);
+	coin_counter_w(&m_machine, 0, !offset);
 }
 
 
@@ -324,9 +310,9 @@
  *
  *************************************/
 
-static ADDRESS_MAP_START( main_map, ADDRESS_SPACE_PROGRAM, 32 )
-	AM_RANGE(0x00000000, 0x0001ffff) AM_RAM AM_BASE_MEMBER(beathead_state, ram_base)
-	AM_RANGE(0x01800000, 0x01bfffff) AM_ROM AM_REGION("user1", 0) AM_BASE_MEMBER(beathead_state, rom_base)
+static ADDRESS_MAP_START( main_map, ADDRESS_SPACE_PROGRAM, 32, beathead_state)
+	AM_RANGE(0x00000000, 0x0001ffff) AM_RAM AM_BASE(m_ram_base)
+	AM_RANGE(0x01800000, 0x01bfffff) AM_ROM AM_REGION("user1", 0) AM_BASE(m_rom_base)
 	AM_RANGE(0x40000000, 0x400007ff) AM_RAM_WRITE(eeprom_data_w) AM_BASE_SIZE_GENERIC(nvram)
 	AM_RANGE(0x41000000, 0x41000003) AM_READWRITE(sound_data_r, sound_data_w)
 	AM_RANGE(0x41000100, 0x41000103) AM_READ(interrupt_control_r)
@@ -337,19 +323,19 @@
 	AM_RANGE(0x41000220, 0x41000227) AM_WRITE(coin_count_w)
 	AM_RANGE(0x41000300, 0x41000303) AM_READ(input_2_r)
 	AM_RANGE(0x41000304, 0x41000307) AM_READ_PORT("IN3")
-	AM_RANGE(0x41000400, 0x41000403) AM_WRITEONLY AM_BASE_MEMBER(beathead_state, palette_select)
+	AM_RANGE(0x41000400, 0x41000403) AM_WRITEONLY AM_BASE(m_palette_select)
 	AM_RANGE(0x41000500, 0x41000503) AM_WRITE(eeprom_enable_w)
-	AM_RANGE(0x41000600, 0x41000603) AM_WRITE(beathead_finescroll_w)
-	AM_RANGE(0x41000700, 0x41000703) AM_WRITE(watchdog_reset32_w)
-	AM_RANGE(0x42000000, 0x4201ffff) AM_RAM_WRITE(beathead_palette_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x43000000, 0x43000007) AM_READWRITE(beathead_hsync_ram_r, beathead_hsync_ram_w)
+	AM_RANGE(0x41000600, 0x41000603) AM_WRITE(finescroll_w)
+	AM_RANGE(0x41000700, 0x41000703) AM_WRITE_LEGACY(watchdog_reset32_w)
+	AM_RANGE(0x42000000, 0x4201ffff) AM_RAM_WRITE(palette_w) AM_BASE(m_paletteram)
+	AM_RANGE(0x43000000, 0x43000007) AM_READWRITE(hsync_ram_r, hsync_ram_w)
 	AM_RANGE(0x8df80000, 0x8df80003) AM_READNOP	/* noisy x4 during scanline int */
-	AM_RANGE(0x8f380000, 0x8f3fffff) AM_WRITE(beathead_vram_latch_w)
-	AM_RANGE(0x8f900000, 0x8f97ffff) AM_WRITE(beathead_vram_transparent_w)
-	AM_RANGE(0x8f980000, 0x8f9fffff) AM_RAM AM_BASE_GENERIC(videoram)
-	AM_RANGE(0x8fb80000, 0x8fbfffff) AM_WRITE(beathead_vram_bulk_w)
-	AM_RANGE(0x8fff8000, 0x8fff8003) AM_WRITEONLY AM_BASE_MEMBER(beathead_state, vram_bulk_latch)
-	AM_RANGE(0x9e280000, 0x9e2fffff) AM_WRITE(beathead_vram_copy_w)
+	AM_RANGE(0x8f380000, 0x8f3fffff) AM_WRITE(vram_latch_w)
+	AM_RANGE(0x8f900000, 0x8f97ffff) AM_WRITE(vram_transparent_w)
+	AM_RANGE(0x8f980000, 0x8f9fffff) AM_RAM AM_BASE(m_videoram)
+	AM_RANGE(0x8fb80000, 0x8fbfffff) AM_WRITE(vram_bulk_w)
+	AM_RANGE(0x8fff8000, 0x8fff8003) AM_WRITEONLY AM_BASE(m_vram_bulk_latch)
+	AM_RANGE(0x9e280000, 0x9e2fffff) AM_WRITE(vram_copy_w)
 ADDRESS_MAP_END
 
 
@@ -414,8 +400,6 @@
 	MDRV_CPU_ADD("maincpu", ASAP, ATARI_CLOCK_14MHz)
 	MDRV_CPU_PROGRAM_MAP(main_map)
 
-	MDRV_MACHINE_START(beathead)
-	MDRV_MACHINE_RESET(beathead)
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
 	MDRV_TIMER_ADD("scan_timer", scanline_callback)
@@ -430,9 +414,6 @@
 	MDRV_SCREEN_VISIBLE_AREA(0*8, 42*8-1, 0*8, 30*8-1)
 	MDRV_PALETTE_LENGTH(32768)
 
-	MDRV_VIDEO_START(beathead)
-	MDRV_VIDEO_UPDATE(beathead)
-
 	/* sound hardware */
 	MDRV_IMPORT_FROM(jsa_iii_mono)
 MACHINE_DRIVER_END
@@ -480,26 +461,24 @@
 */
 
 
-static UINT32 *speedup_data;
-static READ32_HANDLER( speedup_r )
+READ32_MEMBER( beathead_state::speedup_r )
 {
-	int result = *speedup_data;
-	if ((cpu_get_previouspc(space->cpu) & 0xfffff) == 0x006f0 && result == cpu_get_reg(space->cpu, ASAP_R3))
-		cpu_spinuntil_int(space->cpu);
+	int result = *m_speedup_data;
+	if ((cpu_get_previouspc(space.cpu) & 0xfffff) == 0x006f0 && result == cpu_get_reg(space.cpu, ASAP_R3))
+		cpu_spinuntil_int(space.cpu);
 	return result;
 }
 
 
-static UINT32 *movie_speedup_data;
-static READ32_HANDLER( movie_speedup_r )
+READ32_MEMBER( beathead_state::movie_speedup_r )
 {
-	int result = *movie_speedup_data;
-	if ((cpu_get_previouspc(space->cpu) & 0xfffff) == 0x00a88 && (cpu_get_reg(space->cpu, ASAP_R28) & 0xfffff) == 0x397c0 &&
-		movie_speedup_data[4] == cpu_get_reg(space->cpu, ASAP_R1))
+	int result = *m_movie_speedup_data;
+	if ((cpu_get_previouspc(space.cpu) & 0xfffff) == 0x00a88 && (cpu_get_reg(space.cpu, ASAP_R28) & 0xfffff) == 0x397c0 &&
+		m_movie_speedup_data[4] == cpu_get_reg(space.cpu, ASAP_R1))
 	{
-		UINT32 temp = (INT16)result + movie_speedup_data[4] * 262;
-		if (temp - (UINT32)cpu_get_reg(space->cpu, ASAP_R15) < (UINT32)cpu_get_reg(space->cpu, ASAP_R23))
-			cpu_spinuntil_int(space->cpu);
+		UINT32 temp = (INT16)result + m_movie_speedup_data[4] * 262;
+		if (temp - (UINT32)cpu_get_reg(space.cpu, ASAP_R15) < (UINT32)cpu_get_reg(space.cpu, ASAP_R23))
+			cpu_spinuntil_int(space.cpu);
 	}
 	return result;
 }
@@ -514,12 +493,14 @@
 
 static DRIVER_INIT( beathead )
 {
+	beathead_state *state = machine->driver_data<beathead_state>();
+
 	/* initialize the common systems */
 	atarijsa_init(machine, "IN2", 0x0040);
 
 	/* prepare the speedups */
-	speedup_data = memory_install_read32_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x00000ae8, 0x00000aeb, 0, 0, speedup_r);
-	movie_speedup_data = memory_install_read32_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x00000804, 0x00000807, 0, 0, movie_speedup_r);
+	state->m_speedup_data = state->m_maincpu.space(AS_PROGRAM)->install_handler(0x00000ae8, 0x00000aeb, 0, 0, read32_delegate_create(beathead_state, speedup_r, *state));
+	state->m_movie_speedup_data = state->m_maincpu.space(AS_PROGRAM)->install_handler(0x00000804, 0x00000807, 0, 0, read32_delegate_create(beathead_state, movie_speedup_r, *state));
 }
 
 
diff -Nru src-old/mame/drivers/berzerk.c src/mame/drivers/berzerk.c
--- src-old/mame/drivers/berzerk.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/berzerk.c	2010-08-19 00:26:14.000000000 -0700
@@ -544,7 +544,7 @@
 
 static SOUND_RESET(berzerk)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	/* clears the flip-flop controlling the volume and freq on the speech chip */
 	berzerk_audio_w(space, 4, 0x40);
 }
@@ -1185,7 +1185,7 @@
 
 static DRIVER_INIT( moonwarp )
 {
-	const address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	memory_install_read8_handler (io, 0x48, 0x48, 0, 0, moonwarp_p1_r);
 	memory_install_read8_handler (io, 0x4a, 0x4a, 0, 0, moonwarp_p2_r);
 }
diff -Nru src-old/mame/drivers/bfcobra.c src/mame/drivers/bfcobra.c
--- src-old/mame/drivers/bfcobra.c	2010-06-30 17:34:46.000000000 -0700
+++ src/mame/drivers/bfcobra.c	2010-08-19 00:26:14.000000000 -0700
@@ -409,7 +409,7 @@
     The Flare One blitter is a simpler design with slightly different parameters
     and will require hardware tests to figure everything out correctly.
 */
-static void RunBlit(const address_space *space)
+static void RunBlit(address_space *space)
 {
 #define BLITPRG_READ(x)		blitter.x = *(blitter_get_addr(space->machine, blitter.program.addr++))
 
diff -Nru src-old/mame/drivers/bigfghtr.c src/mame/drivers/bigfghtr.c
--- src-old/mame/drivers/bigfghtr.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/bigfghtr.c	2010-08-19 00:26:14.000000000 -0700
@@ -308,7 +308,7 @@
 
 static VIDEO_EOF( bigfghtr )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 }
 
diff -Nru src-old/mame/drivers/btime.c src/mame/drivers/btime.c
--- src-old/mame/drivers/btime.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/btime.c	2010-08-19 07:19:38.000000000 -0700
@@ -206,7 +206,7 @@
 }
 
 
-static void btime_decrypt( const address_space *space )
+static void btime_decrypt( address_space *space )
 {
 	btime_state *state = space->machine->driver_data<btime_state>();
 	UINT8 *src, *src1;
@@ -2077,12 +2077,12 @@
 
 static void decrypt_C10707_cpu(running_machine *machine, const char *cputag)
 {
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x10000);
 	UINT8 *rom = memory_region(machine, cputag);
 	offs_t addr;
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypt);
+	space->set_decrypted_region(0x0000, 0xffff, decrypt);
 
 	/* Swap bits 5 & 6 for opcodes */
 	for (addr = 0; addr < 0x10000; addr++)
@@ -2107,11 +2107,11 @@
 
 static void init_rom1(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 
 	decrypted = auto_alloc_array(machine, UINT8, 0x10000);
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypted);
+	space->set_decrypted_region(0x0000, 0xffff, decrypted);
 
 	/* For now, just copy the RAM array over to ROM. Decryption will happen */
 	/* at run time, since the CPU applies the decryption only if the previous */
diff -Nru src-old/mame/drivers/btoads.c src/mame/drivers/btoads.c
--- src-old/mame/drivers/btoads.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/btoads.c	2010-08-15 17:41:11.000000000 -0700
@@ -51,12 +51,6 @@
 }
 
 
-static MACHINE_RESET( btoads )
-{
-	tlc34076_reset(6);
-}
-
-
 
 /*************************************
  *
@@ -349,10 +343,11 @@
 	MDRV_CPU_PERIODIC_INT(irq0_line_assert, 183)
 
 	MDRV_MACHINE_START(btoads)
-	MDRV_MACHINE_RESET(btoads)
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_START(btoads)
 	MDRV_VIDEO_UPDATE(tms340x0)
 
diff -Nru src-old/mame/drivers/bwidow.c src/mame/drivers/bwidow.c
--- src-old/mame/drivers/bwidow.c	2010-06-30 17:34:46.000000000 -0700
+++ src/mame/drivers/bwidow.c	2010-08-13 01:54:21.000000000 -0700
@@ -353,7 +353,7 @@
 
 static ADDRESS_MAP_START( bwidow_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x07ff) AM_RAM
-	AM_RANGE(0x2000, 0x27ff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x2000)
+	AM_RANGE(0x2000, 0x27ff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x2000)
 	AM_RANGE(0x2800, 0x5fff) AM_ROM
 	AM_RANGE(0x6000, 0x67ff) AM_DEVREADWRITE("pokey1", pokey_r, pokey_w)
 	AM_RANGE(0x6800, 0x6fff) AM_DEVREADWRITE("pokey2", pokey_r, pokey_w)
@@ -387,7 +387,7 @@
 	AM_RANGE(0x0f00, 0x0f3f) AM_DEVWRITE("earom", atari_vg_earom_w)
 	AM_RANGE(0x1000, 0x100f) AM_DEVREADWRITE("pokey1", pokey_r, pokey_w)
 	AM_RANGE(0x1400, 0x140f) AM_DEVREADWRITE("pokey2", pokey_r, pokey_w)
-	AM_RANGE(0x2000, 0x27ff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x2000)
+	AM_RANGE(0x2000, 0x27ff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x2000)
 	AM_RANGE(0x2800, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0xffff) AM_ROM
 ADDRESS_MAP_END
diff -Nru src-old/mame/drivers/bzone.c src/mame/drivers/bzone.c
--- src-old/mame/drivers/bzone.c	2010-06-30 17:34:46.000000000 -0700
+++ src/mame/drivers/bzone.c	2010-08-19 00:26:14.000000000 -0700
@@ -308,7 +308,7 @@
 	AM_RANGE(0x1820, 0x182f) AM_DEVREADWRITE("pokey", pokey_r, pokey_w)
 	AM_RANGE(0x1840, 0x1840) AM_DEVWRITE("discrete", bzone_sounds_w)
 	AM_RANGE(0x1860, 0x187f) AM_DEVWRITE("mathbox", mathbox_go_w)
-	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x2000)
+	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x2000)
 	AM_RANGE(0x3000, 0x7fff) AM_ROM
 ADDRESS_MAP_END
 
@@ -332,7 +332,7 @@
 	AM_RANGE(0x1810, 0x181f) AM_DEVREADWRITE("pokey", pokey_r, pokey_w)
 	AM_RANGE(0x1820, 0x185f) AM_DEVREADWRITE("earom", atari_vg_earom_r, atari_vg_earom_w)
 	AM_RANGE(0x1860, 0x187f) AM_DEVWRITE("mathbox", mathbox_go_w)
-	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x2000)
+	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x2000)
 	AM_RANGE(0x3000, 0x7fff) AM_ROM
 ADDRESS_MAP_END
 
@@ -800,7 +800,7 @@
 
 static DRIVER_INIT( bradley )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	memory_install_ram(space, 0x400, 0x7ff, 0, 0, NULL);
 	memory_install_read_port(space, 0x1808, 0x1808, 0, 0, "1808");
 	memory_install_read_port(space, 0x1809, 0x1809, 0, 0, "1809");
diff -Nru src-old/mame/drivers/cabal.c src/mame/drivers/cabal.c
--- src-old/mame/drivers/cabal.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/cabal.c	2010-08-19 07:19:38.000000000 -0700
@@ -841,11 +841,11 @@
 
 static void seibu_sound_bootleg(running_machine *machine,const char *cpu,int length)
 {
-	const address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, length);
 	UINT8 *rom = memory_region(machine, cpu);
 
-	memory_set_decrypted_region(space, 0x0000, (length < 0x10000) ? (length - 1) : 0x1fff, decrypt);
+	space->set_decrypted_region(0x0000, (length < 0x10000) ? (length - 1) : 0x1fff, decrypt);
 
 	memcpy(decrypt, rom+length, length);
 
diff -Nru src-old/mame/drivers/calchase.c src/mame/drivers/calchase.c
--- src-old/mame/drivers/calchase.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/calchase.c	2010-08-19 01:27:05.000000000 -0700
@@ -228,7 +228,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -237,7 +237,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static void set_dma_channel(running_device *device, int channel, int state)
diff -Nru src-old/mame/drivers/calomega.c src/mame/drivers/calomega.c
--- src-old/mame/drivers/calomega.c	2010-05-22 13:51:23.000000000 -0700
+++ src/mame/drivers/calomega.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,17 +1,17 @@
 /**********************************************************************************
 
-    +-------------------------------------+
-    |                                     |
-    | CAL OMEGA - SYSTEMS 903/904/905/906 |
-    |                                     |
-    |      Driver by Roberto Fresca.      |
-    |                                     |
-    +-------------------------------------+
+    .----------------------------------------.
+    |                                        |
+    | CAL OMEGA - SYSTEMS 903/904/905/906III |
+    |                                        |
+    |        Driver by Roberto Fresca.       |
+    |                                        |
+    '----------------------------------------'
 
 
     --- Technical Notes ---
 
-    Name:    System 903, System 904, System 905 & System 906.
+    Name:    System 903, System 904, System 905 & System 906 III.
     Company: Cal Omega / Omega Products / Casino Electronics Inc.
     Year:    1981-1989
 
@@ -19,8 +19,8 @@
 ***********************************************************************************
 
 
-    Basic hardware for all systems:
-    -------------------------------
+    Basic hardware for systems 903/904/905:
+    ---------------------------------------
 
     CPU =  1x SY6502 @ 625 kHz.  ; M6502 compatible.
     SND =  1x AY8912 @ 1.25 MHz. ; AY-3-8910 compatible.
@@ -73,6 +73,33 @@
 
 
 
+    System 906 III:
+    ---------------
+
+    PCB silkscreened "CEI 906 III GAMEBOARD" "ASSY 4029063 REV"
+
+    CPU:   1x Rockwell R65C02P1 CPU. (U49)
+    Video: 1x Motorola MC6845P CRTC. (U47)
+    I/O:   2x Rockwell R65C24P2 PIAT. (U46, U48)
+           1x Motorola MC6850P ACIA. (U44)
+
+    Sound: 1x Microchip AY-3-8912. (U45)
+           1x LM380N (amplifier). (U34)
+
+    RAM: 1x NEC D4364C-15L. (U50)
+
+    PRG ROMs: 5x ST M2764AF1. (U28/EPR1, U29/EPR2, U30/EPR3, U31/EPR4, U32/EPR5)
+    GFX ROMs: 3x ST M2764AF1. (U4/CG2C, U5/CG2B, U6/CG2A)
+
+    Clock: 1x 10.000 MHz Xtal. (Y1)
+
+    2x 8 DIP switches banks. (SW1, SW2)
+    1x Battery. (BT1)
+    3x 1K Pots (video). (B, G, R)
+    1x 1K Pot (audio). (V)
+    2x 2x28 pins edge connectors.
+
+
 ***********************************************************************************
 
 
@@ -101,15 +128,15 @@
 ***********************************************************************************
 
 
-   ++++ System 903-906 official list of games (not complete) ++++
+   ++++ System 903/904/906III official list of games (not complete) ++++
 
    -----+--------------------------+--------+---------+----------+---------+----------+---------+---------------+------+------+-------
     VER |  NAME                    | SYSTEM | PROGRAM | CHAR GEN | CG P/N  | CLR PROM | CP P/N  | GAME TYPE     | DUMP | STAT | ADDED
    -----+--------------------------+--------+---------+----------+---------+----------+---------+---------------+------+------+-------
- *  7.4 | Gaming Poker (w. export) |  903   | AUG/81  | PKCG     | 6300010 | POKCLR   | 6600020 | Gaming        | Yes  | OK   | Yes
+ *  7.4 | Gaming Poker (w. export) |  903   | AUG/81  | PKCG     | 6300010 | unknown  | 6600020 | Gaming        | Yes  | OK   | Yes
     7.6 | Poker                    |  903   | AUG/81  | PKCG     | 6300010 | POKCLR   | 6600020 | Amusement     | Yes  | OK   | Yes
  *  7.9 | Arcade Poker             |  903   | AUG/81  | PKCG     | 6300010 | POKCLR   | 6600020 | Amusement     | Yes  | BD   | Yes
- *  8.0 | Arcade Black Jack        |  903   | SEP/81  | CPKCG    | 6300010 | POKCLR   | 6600020 | Amusement?    | Yes  | BD   | Yes
+ *  8.0 | Arcade Black Jack        |  903   | SEP/81  | CPKCG    | 6300010 | POKCLR   | 6600020 | Amusement     | Yes  | BD   | Yes
  *  9.4 | Keno                     |  903   | DEC/81  | KCG      | 6300060 | POKCLR   | 6600020 | Amusement     | Yes  | OK   | Yes
  * 10.7 | Big Game                 |  903   | MAR/82  | LOTCG    | unknown | BCLR     | unknown | Amusement?    | Yes  | OK   | Yes
  * 11.3 | Black Jack               |  903   |         | CPKCG?   | 6300010 | POKCLR   | 6600020 | Amusement?    | No   |      | No
@@ -179,7 +206,7 @@
  * 23.6 | Hotline                  |  905   | OCT/84  | HLCG     | 6300160 | HLCLR    | 6600110 | Amusement     | Yes  | OK   | Yes
    23.7 | AWP Blackjack            |   ?    |         | POKER    | 6300010 | POKCLR   | 6600020 | Gaming        | No   |      | No
    23.9 | G.Draw Poker (discard)   |  904   | JAN/85  | POKCG    | 6300010 | POKCLR   | 6600020 | Nevada Gaming | Yes  | OK   | Yes
-   24.0 | Poker (hold)             |   ?    |         | POKCG    | 6300010 | POKCLR   | 6600020 | Nevada Gaming | No   |      | No
+   24.0 | Gaming Draw Poker (hold) |  904   | MAY/85  | POKCG    | 6300010 | POKCLR   | 6600020 | Nevada Gaming | Yes  | OK   | Yes
    24.2 | Export Poker             |   ?    |         | GPKCG    | 6300010 | POKCLR   | 6600020 | Gaming        | No   |      | No
    24.3 | Gaming Blackjack         |   ?    |         | GPKCG    | 6300010 | POKCLR   | 6600020 | Nevada Gaming | No   |      | No
    24.5 | Wild Double-Up           |   ?    |         | JKPKCG   | 6300100 | WLDCLR   | 6600010 | Amusement     | No   |      | No
@@ -228,7 +255,7 @@
    46.0x| Gaming Poker             |   ?    |         | GPKCG    | 6300010 | POKCLR   | 6600020 | Nevada Gaming | No   |      | No
    47.0x| 4-Card Indian Bingo      |   ?    |         | FCB7CG   | 6300150 | FCB7CLR  | 6600100 | Amer-Indian   | No   |      | No
    48.0x| Keno                     |   ?    |         | KJCG     | 6300060 | POKCLR   | 6600020 | Montana       | No   |      | No
-   51.0x| Poker (906-III)          |  906   |         | GP2CG    | unknown | WILD     | unknown | Nevada Gaming | No   |      | No
+   51.08| Poker (906-III)          |  906   |         | GP2CG    | unknown | WILD     | unknown | Nevada Gaming | Yes  | OK   | Yes
         |                          |        |         |          |         |          |         |               |      |      |
  * 903d | System 903 Diag.PROM     |  903   | unknown | any      | unknown | any      | unknown | Testing H/W   | Yes  | OK   | Yes
  * 905d | System 905 Diag.PROM     |  905   | unknown | any      | unknown | any      | unknown | Testing H/W   | Yes  | OK   | Yes
@@ -365,8 +392,26 @@
     The whole map is mirrored to $8000-$FFFF.
 
 
+    --- System 906 III ---
+
+    $0000 - $07FF   NVRAM           ; All registers and settings.
+    $2C08 - $2C08   AY-8912         ; Read/Control.
+    $2C09 - $2C09   AY-8912         ; Write.
+    $280C - $280F   PIAT0           ; I/O unknown.
+    $2824 - $2827   PIAT1           ; I/O unknown.
+    $2C04 - $2C04   CRTC6845        ; MC6845 adressing.
+    $2C05 - $2C05   CRTC6845        ; MC6845 Read/Write.
+
+    $2000 - $23FF   VideoRAM
+    $2400 - $27FF   ColorRAM
+
+    $6000 - $FFFF   ROM space.      ; System 906.
 
-    *** MC6545 Initialization ***
+    No mirrors... Using the whole CPU addressing.
+
+
+
+    *** MC6545 Initialization (60Hz) ***
 
     ----------------------------------------------------------------------------------------------------------------------
     register:  R00   R01   R02   R03   R04   R05   R06   R07   R08   R09   R10   R11   R12   R13   R14   R15   R16   R17
@@ -374,8 +419,7 @@
     value:     0x27  0x20  0x23  0x03  0x1F  0x04  0x1F  0x1F  0x00  0x07  0x00  0x00  0x00  0x00  0x00  0x00  0x00  0x00.
 
 
-
-    *** MC6545 conditional change for elgrande if 0x8c4 (PIA0) has bit7 activated ***
+    *** MC6545 conditional 50Hz change for elgrande if 0x8c4 (PIA0) has bit7 deactivated ***
 
     ---------------------------------------------------------
     register:  R00   R01   R02   R03   R04   R05   R06   R07
@@ -387,68 +431,37 @@
 ***********************************************************************************
 
 
-    Dumper notes (old)
-
-
-    -- Gaming Draw Poker --------------------------------------------------------
-
-    Program roms are roms 23*.*, on the board, there is a number near each roms
-    looks to be the address of the rom :
-
-            23-91   1800
-            23-92   2000
-            23-93   2800
-            23-94   3000
-            23-9    3800
-
-    Graphics are in roms CG*.*, there is no type indication on these rams, i hope
-    i read them correctly.
-
-    There is also 3 sets of switches on the board :
-
-            SW1     1       300     SW2     1       OPT1
-                    2       600             2       OPT2
-                    3       1200            3       OPT3
-                    4       2400            4       OPT4
-                    5       4800            5       OPT5
-                    6       9600            6       DIS
-                    7       -               7       +VPOL
-                    8       -               8       +HPOL
-
-            SW3     no indications on the board
-
-    The sound rom is missing on the board :(
-
-
-    -- El Grande 5 Card Draw ----------------------------------------------------
-
-    ROM text showed poker stuff and "TUNI" "1982"
-
-    .u6    2716
-    .u7    2516
-    .u8    2516
-    .u9    2516
-    .u67   2516
-    .u68   2516
-    .u69   2716
-    .u70   2716
-    .u28   82s129
-
-    6502
-    HD46505
-    AY-3-8912
-    MC6821P x2
-    TC5501  x2
-    10MHz Crystal
-
-    empty socket at u5
+    DRIVER UPDATES
+    --------------
 
 
-***********************************************************************************
+    [2010-08-20]
 
+    - Added Game 24.0 (Gaming Draw Poker, hold). The game is playable.
+    - Added missing 50/60Hz output frequency selector to systems 903-905.
+       However, I dunno how it looks physically (switch/jumper/bridge?)
+    - Injected missing start and NMI vectors to comg080 (Arcade Black Jack),
+       from an exhaustive program ROM analysis / reverse engineering.
+       The game now starts ok and is triggering proper NMI's.
+    - Inputs from the scratch for comg080 (Arcade Black Jack).
+    - Added workaround to pass the vector-check protection.
+    - Reworked the lamps circuitry by system-basis.
+    - Updated games list and technical notes.
+    - Promoted comg080 (Arcade Black Jack) to working state.
 
-    DRIVER UPDATES
-    --------------
+    - Added support for system 906III:
+        - Accurate memory map, CRTC, and PIAs mapped.
+        - Preliminary PIAs support (no multiplexion yet).
+        - Added proper machine driver, with correct R65C02 CPU.
+        - Documented the hardware specs.
+        - Added Game 51.08 (CEI Video Poker, Jacks or Better),
+          running in CEI 906III hardware. The game is not working.
+        - Corrected docs about the 906III memory map.
+        - Mapped the AY8912.
+        - Added AY8912 proper interfase. Tied SW2 to AY8912 port.
+        - PIA0, portA is polled constantly. Tied some debug handlers
+           to understand how the input system works.
+        - Added notes about the PIAs R/W.
 
 
     [2009-09-03]
@@ -617,6 +630,7 @@
     - Improve 903/905 inputs.
     - Interrupts for System 903/904 UART.
     - Complete the PIAs connection.
+    - 906III: PIAs & AY8912 ports, inputs, etc...
     - Parent/clone relationship.
     - Fix lamps.
 
@@ -652,9 +666,9 @@
 VIDEO_UPDATE( calomega );
 
 
-/****************************
-*    Read/Write Handlers    *
-****************************/
+/**************************************************
+*               Read/Write Handlers               *
+**************************************************/
 
 static WRITE_LINE_DEVICE_HANDLER( tx_rx_clk )
 {
@@ -676,7 +690,8 @@
 		case 0x40: return input_port_read(device->machine, "IN0-2");
 		case 0x80: return input_port_read(device->machine, "IN0-3");
 	}
-	return 0xff;
+
+	return input_port_read(device->machine, "FRQ");	/* bit7 used for 50/60 Hz selector */
 }
 
 static WRITE8_DEVICE_HANDLER( s903_mux_w )
@@ -696,7 +711,8 @@
 		case 0x04: return input_port_read(device->machine, "IN0-2");
 		case 0x08: return input_port_read(device->machine, "IN0-3");
 	}
-	return 0xff;
+
+	return input_port_read(device->machine, "FRQ");	/* bit6 used for 50/60 Hz selector */
 }
 
 static WRITE8_DEVICE_HANDLER( s905_mux_w )
@@ -705,7 +721,74 @@
 }
 
 
-/****  Lamps debug  ****
+/********* 906III PIAs debug *********/
+
+static READ8_DEVICE_HANDLER( pia0_ain_r )
+{
+	/* Valid input port. Each polled value is stored at $0538 */
+	logerror("PIA0: Port A in\n");
+	return input_port_read(device->machine, "IN0");
+}
+
+static READ8_DEVICE_HANDLER( pia0_bin_r )
+{
+	logerror("PIA0: Port B in\n");
+	return 0xff;
+}
+
+static WRITE8_DEVICE_HANDLER( pia0_aout_w )
+{
+	logerror("PIA0: Port A out: %02X\n", data);
+}
+
+static WRITE8_DEVICE_HANDLER( pia0_bout_w )
+{
+	logerror("PIA0: Port B out: %02X\n", data);
+}
+
+static WRITE8_DEVICE_HANDLER( pia0_ca2_w )
+{
+	/* Seems a kind of "heartbit" watchdog, switching 1's and 0's */
+	logerror("PIA0: CA2: %02X\n", data);
+}
+
+
+
+static READ8_DEVICE_HANDLER( pia1_ain_r )
+{
+	logerror("PIA1: Port A in\n");
+	return 0xff;
+}
+
+static READ8_DEVICE_HANDLER( pia1_bin_r )
+{
+	logerror("PIA1: Port B in\n");
+	return 0xff;
+}
+
+static WRITE8_DEVICE_HANDLER( pia1_aout_w )
+{
+	logerror("PIA1: Port A out: %02X\n", data);
+}
+
+static WRITE8_DEVICE_HANDLER( pia1_bout_w )
+{
+	logerror("PIA1: Port B out: %02X\n", data);
+}
+
+
+static WRITE8_DEVICE_HANDLER( ay_aout_w )
+{
+	logerror("AY8910: Port A out: %02X\n", data);
+}
+
+static WRITE8_DEVICE_HANDLER( ay_bout_w )
+{
+	logerror("AY8910: Port B out: %02X\n", data);
+}
+
+
+/********  Lamps debug  ********
 
     PIA0-B  PIA1-A
 
@@ -725,34 +808,42 @@
     0xff    0x7b    = Take
 
 */
-static WRITE8_DEVICE_HANDLER( lamps_a_w )
+static WRITE8_DEVICE_HANDLER( lamps_903a_w )
 {
-	output_set_lamp_value(0, 1-((data) & 1));		// 0
-	output_set_lamp_value(1, 1-((data >> 1) & 1));	// 1
-	output_set_lamp_value(2, 1-((data >> 2) & 1));	// 2
-	output_set_lamp_value(3, 1-((data >> 3) & 1));	// 3
-	output_set_lamp_value(4, 1-((data >> 4) & 1));	// 4
-	output_set_lamp_value(5, 1-((data >> 5) & 1));	// 5
-	output_set_lamp_value(6, 1-((data >> 6) & 1));	// 6
-	output_set_lamp_value(7, 1-((data >> 7) & 1));	// 7
-}
-
-static WRITE8_DEVICE_HANDLER( lamps_b_w )
-{
-	output_set_lamp_value(8, 1-((data) & 1));		// 0
-	output_set_lamp_value(9, 1-((data >> 1) & 1));	// 1
-	output_set_lamp_value(10, 1-((data >> 2) & 1));	// 2
-	output_set_lamp_value(11, 1-((data >> 3) & 1));	// 3
-	output_set_lamp_value(12, 1-((data >> 4) & 1));	// 4
-	output_set_lamp_value(13, 1-((data >> 5) & 1));	// 5
-	output_set_lamp_value(14, 1-((data >> 6) & 1));	// 6
-	output_set_lamp_value(15, 1-((data >> 7) & 1));	// 7
+	/* First 5 bits of PIA0 port B */
+	output_set_lamp_value(1, 1-((data) & 1));		/* L1 (Hold 1) */
+	output_set_lamp_value(2, 1-((data >> 1) & 1));	/* L2 (Hold 2) */
+	output_set_lamp_value(3, 1-((data >> 2) & 1));	/* L3 (Hold 3) */
+	output_set_lamp_value(4, 1-((data >> 3) & 1));	/* L4 (Hold 4) */
+	output_set_lamp_value(5, 1-((data >> 4) & 1));	/* L5 (Hold 5) */
 }
 
+static WRITE8_DEVICE_HANDLER( lamps_903b_w )
+{
+	/* First 4 bits of PIA1 port A */
+	output_set_lamp_value(6, 1-((data) & 1));		/* L6 (Cancel) */
+	output_set_lamp_value(7, 1-((data >> 1) & 1));	/* L7 (Bet) */
+	output_set_lamp_value(8, 1-((data >> 2) & 1));	/* L8 (Take) */
+	output_set_lamp_value(9, 1-((data >> 3) & 1));	/* L9 (Door?) */
+}
 
-/*************************
-* Memory map information *
-*************************/
+static WRITE8_DEVICE_HANDLER( lamps_905_w )
+{
+	/* Whole 8 bits of PIA0 port B */
+	output_set_lamp_value(1, 1-((data) & 1));		/* L1 (Hold 1) */
+	output_set_lamp_value(2, 1-((data >> 1) & 1));	/* L2 (Hold 2) */
+	output_set_lamp_value(3, 1-((data >> 2) & 1));	/* L3 (Hold 3) */
+	output_set_lamp_value(4, 1-((data >> 3) & 1));	/* L4 (Hold 4) */
+	output_set_lamp_value(5, 1-((data >> 4) & 1));	/* L5 (Hold 5) */
+	output_set_lamp_value(6, 1-((data >> 5) & 1));	/* L6 (unknown) */
+	output_set_lamp_value(7, 1-((data >> 6) & 1));	/* L7 (unknown) */
+	output_set_lamp_value(8, 1-((data >> 7) & 1));	/* L8 (unknown) */
+}
+
+
+/*************************************************
+*             Memory map information             *
+*************************************************/
 
 static ADDRESS_MAP_START( sys903_map, ADDRESS_SPACE_PROGRAM, 8 )
 	ADDRESS_MAP_GLOBAL_MASK(0x3fff)
@@ -795,10 +886,22 @@
 	AM_RANGE(0x2800, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
+static ADDRESS_MAP_START( sys906_map, ADDRESS_SPACE_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x07ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
+	AM_RANGE(0x280c, 0x280f) AM_DEVREADWRITE("pia0", pia6821_r, pia6821_w)
+	AM_RANGE(0x2824, 0x2827) AM_DEVREADWRITE("pia1", pia6821_r, pia6821_w)
+	AM_RANGE(0x2c04, 0x2c04) AM_DEVWRITE("crtc", mc6845_address_w)
+	AM_RANGE(0x2c05, 0x2c05) AM_DEVREADWRITE("crtc", mc6845_register_r, mc6845_register_w)
+	AM_RANGE(0x2c08, 0x2c09) AM_DEVREADWRITE("ay8912", ay8910_r, ay8910_address_data_w)
+	AM_RANGE(0x2000, 0x23ff) AM_RAM_WRITE(calomega_videoram_w) AM_BASE(&calomega_videoram)
+	AM_RANGE(0x2400, 0x27ff) AM_RAM_WRITE(calomega_colorram_w) AM_BASE(&calomega_colorram)
+	AM_RANGE(0x6000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
 
-/*************************
-*      Input ports       *
-*************************/
+/*************************************************
+*                  Input ports                   *
+*************************************************/
 
 static INPUT_PORTS_START( stand903 )
 	PORT_START("IN0-0")
@@ -903,6 +1006,32 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( stand904 )
@@ -982,6 +1111,32 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )	PORT_DIPLOCATION("SW1:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( stand905 )
@@ -1052,9 +1207,35 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x40, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( gdrawpkr )
+static INPUT_PORTS_START( gdrwpkrd )
 	PORT_START("IN0-0")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2)	/* credits */
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Collect") PORT_CODE(KEYCODE_Q)
@@ -1155,6 +1336,292 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( gdrwpkrh )
+	PORT_START("IN0-0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(2)	/* credits */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Collect") PORT_CODE(KEYCODE_Q)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_D_UP )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_DEAL ) PORT_NAME("Deal / Draw")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_POKER_CANCEL ) PORT_NAME("Cancel Holds")
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_GAMBLE_STAND )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_GAMBLE_PAYOUT )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_DOOR ) PORT_NAME("Door Open")
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Test Mode")	/* in some games you need to open the door first */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Hand Pay") PORT_CODE(KEYCODE_W)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_NAME("Dispute") PORT_CODE(KEYCODE_0)	/* in some games you need to open the door first */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_POKER_HOLD1 ) PORT_NAME("Hold 1")
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_POKER_HOLD2 ) PORT_NAME("Hold 2")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_POKER_HOLD3 ) PORT_NAME("Hold 3")
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_POKER_HOLD4 ) PORT_NAME("Hold 4")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_POKER_HOLD5 ) PORT_NAME("Hold 5")
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_GAMBLE_LOW ) PORT_NAME("Small")
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_GAMBLE_BET )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_TAKE )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_HIGH ) PORT_NAME("Big")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("WT.Switch") PORT_CODE(KEYCODE_8)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+/*  SW1-5 should be wired to PIA0 portA, bit 6.
+    SW1-6 should be wired to H-POL.
+    SW1-7 should be wired to V-POL.
+*/
+	PORT_START("SW1")	/* settings (PIA1), SW2 in schematics */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L6 */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L7 */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L8 */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L9 */
+	PORT_DIPNAME( 0x30, 0x20, "Maximum Credits")	PORT_DIPLOCATION("SW2:1,2")
+	PORT_DIPSETTING(    0x00, "100" )
+	PORT_DIPSETTING(    0x10, "400" )
+	PORT_DIPSETTING(    0x20, "800" )
+	PORT_DIPSETTING(    0x30, "1600" )
+	PORT_DIPNAME( 0xC0, 0x40, "Maximum Bet")		PORT_DIPLOCATION("SW2:3,4")
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPSETTING(    0x40, "10" )
+	PORT_DIPSETTING(    0x80, "40" )
+	PORT_DIPSETTING(    0xC0, "80" )
+
+	PORT_START("SW2")	/* baud (serial 6850-4024), SW1 in schematics */
+	PORT_DIPNAME( 0x3f, 0x08, "Baud Rate" )			PORT_DIPLOCATION("SW1:1,2,3,4,5,6")
+	PORT_DIPSETTING(    0x01, "300" )
+	PORT_DIPSETTING(    0x02, "600" )
+	PORT_DIPSETTING(    0x04, "1200" )
+	PORT_DIPSETTING(    0x08, "2400" )
+	PORT_DIPSETTING(    0x10, "4800" )
+	PORT_DIPSETTING(    0x20, "9600" )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )	PORT_DIPLOCATION("SW1:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )	PORT_DIPLOCATION("SW1:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("SW3")	/* unknown (ay8912), SW3 in schematics */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:1")
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:2")
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:3")
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:6")
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( arcadebj )
+	PORT_START("IN0-0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )   PORT_IMPULSE(2)	/* credits */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 )   PORT_IMPULSE(2)	/* credits */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Door Open") PORT_CODE(KEYCODE_O)
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("Bet/Play")    PORT_CODE(KEYCODE_Z)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Start")       PORT_CODE(KEYCODE_X)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Double Down") PORT_CODE(KEYCODE_C)
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("Hit")         PORT_CODE(KEYCODE_V)
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON5 ) PORT_NAME("Stand")       PORT_CODE(KEYCODE_B)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("IN0-3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Service/Clear") PORT_CODE(KEYCODE_0)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )	/* connected to SW2-5 */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+/*  SW1-5 should be wired to PIA0 portA, bit 6.
+    SW1-6 should be wired to H-POL.
+    SW1-7 should be wired to V-POL.
+*/
+	PORT_START("SW1")	/* settings (PIA1), SW2 in schematics */
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L6 */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L7 */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L8 */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_UNKNOWN )		/* L9 */
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:2")
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:3")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("SW2")	/* baud (serial 6850-4024), SW1 in schematics */
+	PORT_DIPNAME( 0x3f, 0x08, "Baud Rate" )			PORT_DIPLOCATION("SW1:1,2,3,4,5,6")
+	PORT_DIPSETTING(    0x01, "300" )
+	PORT_DIPSETTING(    0x02, "600" )
+	PORT_DIPSETTING(    0x04, "1200" )
+	PORT_DIPSETTING(    0x08, "2400" )
+	PORT_DIPSETTING(    0x10, "4800" )
+	PORT_DIPSETTING(    0x20, "9600" )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )	PORT_DIPLOCATION("SW1:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )	PORT_DIPLOCATION("SW1:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("SW3")	/* unknown (ay8912), SW3 in schematics */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:1")
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:2")
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:3")
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:6")
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( comg074 )
@@ -1259,6 +1726,32 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( comg076 )
@@ -1341,27 +1834,53 @@
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:1")
 	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:2")
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:2")
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:3")
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:6")
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:3")
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:4")
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:5")
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:6")
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:7")
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( comg128 )
@@ -1466,6 +1985,32 @@
 	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW3:8")
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( elgrande )
@@ -1532,6 +2077,32 @@
 	PORT_DIPSETTING(    0x40, "10" )
 	PORT_DIPSETTING(    0x80, "20" )
 	PORT_DIPSETTING(    0xC0, "50" )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( jjpoker )
@@ -1598,6 +2169,32 @@
 	PORT_DIPSETTING(    0x40, "10" )
 	PORT_DIPSETTING(    0x80, "20" )
 	PORT_DIPSETTING(    0xC0, "50" )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( ssipkr )
@@ -1664,12 +2261,77 @@
 	PORT_DIPSETTING(    0x40, "10" )
 	PORT_DIPSETTING(    0x80, "20" )
 	PORT_DIPSETTING(    0xc0, "50" )
+
+	PORT_START("FRQ")	/* settings (PIA0) */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "Frequency" )			PORT_DIPLOCATION("FRQ:1")
+	PORT_DIPSETTING(    0x80, "60Hz." )
+	PORT_DIPSETTING(    0x00, "50Hz." )
+INPUT_PORTS_END
+
+static INPUT_PORTS_START( stand906 )
+
+	PORT_START("IN0")
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-1") PORT_CODE(KEYCODE_1)
+	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-2") PORT_CODE(KEYCODE_2)
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-3") PORT_CODE(KEYCODE_3)
+	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-4") PORT_CODE(KEYCODE_4)
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-5") PORT_CODE(KEYCODE_5)
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-6") PORT_CODE(KEYCODE_6)
+	PORT_BIT( 0x40, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-7") PORT_CODE(KEYCODE_7)
+	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_SERVICE ) PORT_NAME("0-8") PORT_CODE(KEYCODE_8)
+
+	PORT_START("SW2")	/* Tied to AY8912 port. Covered with tape except SW2-8 */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:1")
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:2")
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:3")
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:4")
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:5")
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:6")
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:7")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW2:8")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
 
-/*************************
-*    Graphics Layouts    *
-*************************/
+/*************************************************
+*                Graphics Layouts                *
+*************************************************/
 
 static const gfx_layout charlayout =
 {
@@ -1694,19 +2356,24 @@
 };
 
 
-/******************************
-* Graphics Decode Information *
-******************************/
+/*************************************************
+*          Graphics Decode Information           *
+*************************************************/
 
 static GFXDECODE_START( calomega )
 	GFXDECODE_ENTRY( "gfx1", 0, charlayout, 0, 16 )
 	GFXDECODE_ENTRY( "gfx2", 0, tilelayout, (8 * 3) + 128, 16 )
 GFXDECODE_END
 
+static GFXDECODE_START( sys906 )
+	GFXDECODE_ENTRY( "gfx1", 0, tilelayout, 0, 16 )
+	GFXDECODE_ENTRY( "gfx1", 0x1000, tilelayout, (8 * 3) + 128, 16 )
+GFXDECODE_END
+
 
-/***********************
-*    PIA Interfaces    *
-***********************/
+/*************************************************
+*                 PIA Interfaces                 *
+*************************************************/
 
 /********** System 903/904 PIA-0 (U54) wiring **********
 
@@ -1763,7 +2430,7 @@
 	DEVCB_NULL,		/* line CA2 in */
 	DEVCB_NULL,		/* line CB2 in */
 	DEVCB_NULL,		/* port A out */
-	DEVCB_HANDLER(lamps_a_w),		/* port B out */
+	DEVCB_HANDLER(lamps_903a_w),		/* port B out */
 	DEVCB_NULL,		/* line CA2 out */
 	DEVCB_NULL,		/* port CB2 out */
 	DEVCB_NULL,		/* IRQA */
@@ -1819,17 +2486,17 @@
 static const pia6821_interface sys903_pia1_intf =
 {
 	DEVCB_INPUT_PORT("SW1"),		/* port A in */
-	DEVCB_NULL,		/* port B in */
-	DEVCB_NULL,		/* line CA1 in */
-	DEVCB_NULL,		/* line CB1 in */
-	DEVCB_NULL,		/* line CA2 in */
-	DEVCB_NULL,		/* line CB2 in */
-	DEVCB_HANDLER(lamps_b_w),		/* port A out */
+	DEVCB_NULL,						/* port B in */
+	DEVCB_NULL,						/* line CA1 in */
+	DEVCB_NULL,						/* line CB1 in */
+	DEVCB_NULL,						/* line CA2 in */
+	DEVCB_NULL,						/* line CB2 in */
+	DEVCB_HANDLER(lamps_903b_w),	/* port A out */
 	DEVCB_HANDLER(s903_mux_w),		/* port B out */
-	DEVCB_NULL,		/* line CA2 out */
-	DEVCB_NULL,		/* port CB2 out */
-	DEVCB_NULL,		/* IRQA */
-	DEVCB_NULL		/* IRQB */
+	DEVCB_NULL,						/* line CA2 out */
+	DEVCB_NULL,						/* port CB2 out */
+	DEVCB_NULL,						/* IRQA */
+	DEVCB_NULL						/* IRQB */
 };
 
 /********** System 905 PIA-0 (U48) wiring **********
@@ -1880,18 +2547,18 @@
 */
 static const pia6821_interface sys905_pia0_intf =
 {
-	DEVCB_HANDLER(s905_mux_port_r),		/* port A in */
-	DEVCB_NULL,		/* port B in */
-	DEVCB_NULL,		/* line CA1 in */
-	DEVCB_NULL,		/* line CB1 in */
-	DEVCB_NULL,		/* line CA2 in */
-	DEVCB_NULL,		/* line CB2 in */
-	DEVCB_NULL,		/* port A out */
-	DEVCB_HANDLER(lamps_a_w),		/* port B out */
-	DEVCB_NULL,		/* line CA2 out */
-	DEVCB_NULL,		/* port CB2 out */
-	DEVCB_NULL,		/* IRQA */
-	DEVCB_NULL		/* IRQB */
+	DEVCB_HANDLER(s905_mux_port_r),	/* port A in */
+	DEVCB_NULL,						/* port B in */
+	DEVCB_NULL,						/* line CA1 in */
+	DEVCB_NULL,						/* line CB1 in */
+	DEVCB_NULL,						/* line CA2 in */
+	DEVCB_NULL,						/* line CB2 in */
+	DEVCB_NULL,						/* port A out */
+	DEVCB_HANDLER(lamps_905_w),		/* port B out */
+	DEVCB_NULL,						/* line CA2 out */
+	DEVCB_NULL,						/* port CB2 out */
+	DEVCB_NULL,						/* IRQA */
+	DEVCB_NULL						/* IRQB */
 };
 
 /********** Systems 905 PIA-1 (U63) wiring **********
@@ -1942,24 +2609,59 @@
 */
 static const pia6821_interface sys905_pia1_intf =
 {
-	DEVCB_INPUT_PORT("SW1"),		/* port A in */
-	DEVCB_NULL,		/* port B in */
-	DEVCB_NULL,		/* line CA1 in */
-	DEVCB_NULL,		/* line CB1 in */
-	DEVCB_NULL,		/* line CA2 in */
-	DEVCB_NULL,		/* line CB2 in */
-	DEVCB_HANDLER(lamps_b_w),		/* port A out */
-	DEVCB_HANDLER(s905_mux_w),		/* port B out */
-	DEVCB_NULL,		/* line CA2 out */
-	DEVCB_NULL,		/* port CB2 out */
-	DEVCB_NULL,		/* IRQA */
-	DEVCB_NULL		/* IRQB */
+	DEVCB_INPUT_PORT("SW1"),	/* port A in */
+	DEVCB_NULL,					/* port B in */
+	DEVCB_NULL,					/* line CA1 in */
+	DEVCB_NULL,					/* line CB1 in */
+	DEVCB_NULL,					/* line CA2 in */
+	DEVCB_NULL,					/* line CB2 in */
+	DEVCB_NULL,					/* port A out */
+	DEVCB_HANDLER(s905_mux_w),	/* port B out */
+	DEVCB_NULL,					/* line CA2 out */
+	DEVCB_NULL,					/* port CB2 out */
+	DEVCB_NULL,					/* IRQA */
+	DEVCB_NULL					/* IRQB */
+};
+
+
+/********** System 906 PIA-0  **********/
+static const pia6821_interface sys906_pia0_intf =
+{
+	DEVCB_HANDLER(pia0_ain_r),		/* port A in */		/* Valid input port. Each polled value is stored at $0538 */
+	DEVCB_HANDLER(pia0_bin_r),		/* port B in */
+	DEVCB_NULL,						/* line CA1 in */
+	DEVCB_NULL,						/* line CB1 in */
+	DEVCB_NULL,						/* line CA2 in */
+	DEVCB_NULL,						/* line CB2 in */
+	DEVCB_HANDLER(pia0_aout_w),		/* port A out */
+	DEVCB_HANDLER(pia0_bout_w),		/* port B out */
+	DEVCB_HANDLER(pia0_ca2_w),		/* line CA2 out */	/* Seems a kind of "heartbit" watchdog, switching 1's and 0's */
+	DEVCB_NULL,						/* port CB2 out */
+	DEVCB_NULL,						/* IRQA */
+	DEVCB_NULL						/* IRQB */
+};
+
+/********** System 906 PIA-1  **********/
+static const pia6821_interface sys906_pia1_intf =
+{
+	DEVCB_HANDLER(pia1_ain_r),		/* port A in */
+	DEVCB_HANDLER(pia1_bin_r),		/* port B in */
+	DEVCB_NULL,						/* line CA1 in */
+	DEVCB_NULL,						/* line CB1 in */
+	DEVCB_NULL,						/* line CA2 in */
+	DEVCB_NULL,						/* line CB2 in */
+	DEVCB_HANDLER(pia1_aout_w),		/* port A out */
+	DEVCB_HANDLER(pia1_bout_w),		/* port B out */
+	DEVCB_NULL,						/* line CA2 out */
+	DEVCB_NULL,						/* port CB2 out */
+	DEVCB_NULL,						/* IRQA */
+	DEVCB_NULL						/* IRQB */
 };
 
 
-/***********************
-*    ACIA Interface    *
-***********************/
+/*************************************************
+*                 ACIA Interface                 *
+*************************************************/
 
 static READ_LINE_DEVICE_HANDLER( acia_rx_r )
 {
@@ -1984,9 +2686,9 @@
 };
 
 
-/*************************
-*    Sound Interfaces    *
-*************************/
+/*************************************************
+*                Sound Interfaces                *
+*************************************************/
 
 static const ay8910_interface sys903_ay8912_intf =
 {
@@ -2008,10 +2710,20 @@
 	DEVCB_NULL
 };
 
+static const ay8910_interface sys906_ay8912_intf =
+{
+	AY8910_LEGACY_OUTPUT,
+	AY8910_DEFAULT_LOADS,
+	DEVCB_INPUT_PORT("SW2"),	/* From PCB pic. Value is stored at $0539 */
+	DEVCB_NULL,
+	DEVCB_HANDLER(ay_aout_w),
+	DEVCB_HANDLER(ay_bout_w)
+};
+
 
-/************************
-*    CRTC Interface    *
-************************/
+/*************************************************
+*                CRTC Interface                  *
+*************************************************/
 
 static const mc6845_interface mc6845_intf =
 {
@@ -2028,9 +2740,9 @@
 };
 
 
-/*************************
-*    Machine Drivers     *
-*************************/
+/*************************************************
+*                Machine Drivers                 *
+*************************************************/
 
 static MACHINE_DRIVER_START( sys903 )
 	/* basic machine hardware */
@@ -2070,15 +2782,13 @@
 	MDRV_ACIA6850_ADD("acia6850_0", acia6850_intf)
 MACHINE_DRIVER_END
 
-static MACHINE_DRIVER_START( sys905 )
+
+static MACHINE_DRIVER_START( s903mod )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM( sys903 )
 
 	MDRV_CPU_MODIFY("maincpu")
-	MDRV_CPU_PROGRAM_MAP(sys905_map)
-
-	MDRV_PIA6821_MODIFY("pia0", sys905_pia0_intf)
-	MDRV_PIA6821_MODIFY("pia1", sys905_pia1_intf)
+	MDRV_CPU_PROGRAM_MAP(s903mod_map)
 
 	/* sound hardware */
 	MDRV_SOUND_MODIFY("ay8912")
@@ -2088,12 +2798,16 @@
 	MDRV_DEVICE_REMOVE("acia6850_0")
 MACHINE_DRIVER_END
 
-static MACHINE_DRIVER_START( s903mod )
+
+static MACHINE_DRIVER_START( sys905 )
 	/* basic machine hardware */
 	MDRV_IMPORT_FROM( sys903 )
 
 	MDRV_CPU_MODIFY("maincpu")
-	MDRV_CPU_PROGRAM_MAP(s903mod_map)
+	MDRV_CPU_PROGRAM_MAP(sys905_map)
+
+	MDRV_PIA6821_MODIFY("pia0", sys905_pia0_intf)
+	MDRV_PIA6821_MODIFY("pia1", sys905_pia1_intf)
 
 	/* sound hardware */
 	MDRV_SOUND_MODIFY("ay8912")
@@ -2104,17 +2818,37 @@
 MACHINE_DRIVER_END
 
 
-/*************************
-*        ROM Load        *
-*************************/
-/*
+static MACHINE_DRIVER_START( sys906 )
+	/* basic machine hardware */
+	MDRV_IMPORT_FROM( sys903 )
 
-Notes:
+	MDRV_CPU_REPLACE("maincpu", M65C02, CPU_CLOCK)	/* guess */
+	MDRV_CPU_PROGRAM_MAP(sys906_map)
 
-jkrpkr, jkr2, jkrtwo: graphics are identical.
-cpkcg, pkcg:          graphics are identical.
+	MDRV_PIA6821_MODIFY("pia0", sys906_pia0_intf)
+	MDRV_PIA6821_MODIFY("pia1", sys906_pia1_intf)
 
-*/
+	MDRV_GFXDECODE(sys906)
+
+	/* sound hardware */
+	MDRV_SOUND_MODIFY("ay8912")
+	MDRV_SOUND_CONFIG(sys906_ay8912_intf)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.75)
+
+	MDRV_DEVICE_REMOVE("acia6850_0")
+MACHINE_DRIVER_END
+
+
+/*************************************************
+*                    ROM Load                    *
+**************************************************
+*
+* Notes:
+*
+*  jkrpkr, jkr2, jkrtwo: graphics are identical.
+*  cpkcg, pkcg:          graphics are identical.
+*
+*************************************************/
 
 ROM_START( comg074 )	/* Cal Omega v7.4 (Gaming Poker) */
 	ROM_REGION( 0x10000, "maincpu", 0 )
@@ -2128,9 +2862,9 @@
 	ROM_LOAD( "poker_cg0.u67",	0x0000, 0x0800, CRC(b626ad89) SHA1(551b75f4559d11a4f8f56e38982114a21c77d4e7) )
 
 	ROM_REGION( 0x1800, "gfx2", 0 )
-	ROM_LOAD( "poker_cgc.u70",	0x0000, 0x0800, CRC(f2f94661) SHA1(f37f7c0dff680fd02897dae64e13e297d0fdb3e7) )
-	ROM_LOAD( "poker_cgb.u69",	0x0800, 0x0800, CRC(6bbb1e2d) SHA1(51ee282219bf84218886ad11a24bc6a8e7337527) )
-	ROM_LOAD( "poker_cga.u68",	0x1000, 0x0800, CRC(6e3e9b1d) SHA1(14eb8d14ce16719a6ad7d13db01e47c8f05955f0) )
+	ROM_LOAD( "poker_cg2c.u70",	0x0000, 0x0800, CRC(f2f94661) SHA1(f37f7c0dff680fd02897dae64e13e297d0fdb3e7) )
+	ROM_LOAD( "poker_cg2b.u69",	0x0800, 0x0800, CRC(6bbb1e2d) SHA1(51ee282219bf84218886ad11a24bc6a8e7337527) )
+	ROM_LOAD( "poker_cg2a.u68",	0x1000, 0x0800, CRC(6e3e9b1d) SHA1(14eb8d14ce16719a6ad7d13db01e47c8f05955f0) )
 
 	ROM_REGION( 0x400, "proms", 0 )	/* from other set */
 	ROM_LOAD( "pokclr.u28",	0x0000, 0x0100, BAD_DUMP CRC(a8191ef7) SHA1(d6f777980179ab091e2713ee815d46bf9c0ac486) )
@@ -2195,7 +2929,7 @@
 	ROM_LOAD( "08-02.u6",	0x2000, 0x0800, CRC(abf8c48e) SHA1(fea059af900fd6d17725ccf7a5ff2eb0af5c8e0a) )
 	ROM_LOAD( "08-03.u7",	0x2800, 0x0800, CRC(e9ccb5af) SHA1(68a45d839afba3c6eafb7c75e5660de3a6be4eb5) )
 	ROM_LOAD( "08-04.u8",	0x3000, 0x0800, CRC(325bdae8) SHA1(5a94c96ec3980361570da58fb407a1dba38064b8) )
-	ROM_LOAD( "08-05.u9",	0x3800, 0x0800, BAD_DUMP CRC(71bd14d2) SHA1(00b3e2d965ac7ae1fc994b81246ad2c29ef4834c) ) /* bad dump */
+	ROM_LOAD( "08-05.u9",	0x3800, 0x0800, BAD_DUMP CRC(71bd14d2) SHA1(00b3e2d965ac7ae1fc994b81246ad2c29ef4834c) ) /* bad dump. 2nd half is blank */
 
 	ROM_REGION( 0x0800, "gfx1", 0 )
 	ROM_LOAD( "gpkcg0.u67",	0x0000, 0x0800, CRC(b626ad89) SHA1(551b75f4559d11a4f8f56e38982114a21c77d4e7) )
@@ -2790,6 +3524,39 @@
 	ROM_RELOAD(				0x0300, 0x0100 )
 ROM_END
 
+/*
+
+  Gaming Draw Poker.
+
+  Program roms are roms 23*.*, on the board, there is a number near each roms
+  looks to be the address of the rom :
+
+          23-91   1800
+          23-92   2000
+          23-93   2800
+          23-94   3000
+          23-9    3800
+
+  Graphics are in roms CG*.*, there is no type indication on these rams, i hope
+  i read them correctly.
+
+  There is also 3 sets of switches on the board :
+
+          SW1     1       300     SW2     1       OPT1
+                  2       600             2       OPT2
+                  3       1200            3       OPT3
+                  4       2400            4       OPT4
+                  5       4800            5       OPT5
+                  6       9600            6       DIS
+                  7       -               7       +VPOL
+                  8       -               8       +HPOL
+
+          SW3     no indications on the board
+
+  The sound rom is missing on the board :(
+
+*/
+
 ROM_START( comg239 )	/* Cal Omega v23.9 (Gaming Draw Poker) */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "23-91.u5",	0x1800, 0x0800, CRC(b49035e2) SHA1(b94a0245ca64d15b1496d1b272ffc0ce80f85526) )
@@ -2813,6 +3580,29 @@
 	ROM_RELOAD(					0x0300, 0x0100 )
 ROM_END
 
+ROM_START( comg240 )	/* Cal Omega v24.0 (Gaming Draw Poker) */
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "24-01.u5",		0x1800, 0x0800, CRC(445e4e1e) SHA1(11f1b2652fce0e507bde66296f57d689a8460df5) )
+	ROM_LOAD( "24-02.u6",		0x2000, 0x0800, CRC(53ef572d) SHA1(14c99f94a22d93de998f6418ea9dc3eab5119a82) )
+	ROM_LOAD( "24-03.u7",		0x2800, 0x0800, CRC(fe46b112) SHA1(b32ef6a09a0b9059840cef4f8847cdbb3cf96fa9) )
+	ROM_LOAD( "24-04.u8",		0x3000, 0x0800, CRC(0060978d) SHA1(f5ee296592520408d2bdd7022d5b82e712cfc643) )
+	ROM_LOAD( "24-05_02bt.u9",	0x3800, 0x0800, CRC(9637a6c0) SHA1(29589fcf8c4db760da95d29be74340fea65b550a) )
+
+	ROM_REGION( 0x0800, "gfx1", 0 )
+	ROM_LOAD( "cgo.u67",	0x0000, 0x0800, CRC(b626ad89) SHA1(551b75f4559d11a4f8f56e38982114a21c77d4e7) )
+
+	ROM_REGION( 0x1800, "gfx2", 0 )
+	ROM_LOAD( "cgc.u70",	0x0000, 0x0800, CRC(f2f94661) SHA1(f37f7c0dff680fd02897dae64e13e297d0fdb3e7) )
+	ROM_LOAD( "cgb.u69",	0x0800, 0x0800, CRC(6bbb1e2d) SHA1(51ee282219bf84218886ad11a24bc6a8e7337527) )
+	ROM_LOAD( "cga.u68",	0x1000, 0x0800, CRC(6e3e9b1d) SHA1(14eb8d14ce16719a6ad7d13db01e47c8f05955f0) )
+
+	ROM_REGION( 0x400, "proms", 0 )	/* is this prom ok? */
+	ROM_LOAD( "pok-6301.u28",	0x0000, 0x0100, CRC(56c2577b) SHA1(cb75882067e1e0d9f9369a37b5a829dd091d473e) )
+	ROM_RELOAD(					0x0100, 0x0100 )
+	ROM_RELOAD(					0x0200, 0x0100 )
+	ROM_RELOAD(					0x0300, 0x0100 )
+ROM_END
+
 ROM_START( comg246 )	/* Cal Omega v24.6 (Hotline) */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_FILL(				0x3000, 0x1000, 0xff )	/* empty socket */
@@ -2882,6 +3672,39 @@
 	ROM_RELOAD(				0x0300, 0x0100 )
 ROM_END
 
+/*
+
+  CEI Video Poker
+  Jacks or Better
+  V 51.08
+  Pay Schedule 05F Controled by EPR1- 50.081
+  906 board
+  PROMS 2764
+
+*/
+
+ROM_START( comg5108 )	/* Cal Omega v51.08 (Gaming Poker) */
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "epr1.u28",	0x6000, 0x2000, CRC(3d6abca9) SHA1(54a802f89bd64380abf269a2b507513c8db5319b) )	/* checked in offset $8034 */
+	ROM_LOAD( "epr2.u29",	0x8000, 0x2000, CRC(72cf8376) SHA1(fa1682244402e1b36164c670241f585bf4017ad9) )
+	ROM_LOAD( "epr3.u30",	0xa000, 0x2000, CRC(c79957e5) SHA1(64afdedf5369d56790e9ae7a8d3be5f52125ca1f) )
+	ROM_LOAD( "epr4.u31",	0xc000, 0x2000, CRC(eb0b0a86) SHA1(4fd29700db8fe183392cc66a54a128657c7e05e0) )
+	ROM_LOAD( "epr5.u32",	0xe000, 0x2000, CRC(b0981cea) SHA1(e56278176df1a6c20acfb8cbf2f5e7a946d93111) )
+
+	ROM_REGION( 0x6000, "gfx1", 0 )
+	ROM_LOAD( "cg2c.u4",	0x0000, 0x2000, CRC(dc77a6db) SHA1(3af5f568de3f2af1a6bbb00d673bdbff16c87a40) )
+	ROM_LOAD( "cg2b.u5",	0x2000, 0x2000, CRC(1f79f76d) SHA1(b2bce60e24dd61977f7bf6ee4705ca7d104ab388) )
+	ROM_LOAD( "cg2a.u6",	0x4000, 0x2000, CRC(d5fd9fc2) SHA1(68472e7271f835656197109620bb3988fc52308a) )
+
+	ROM_REGION( 0x400, "proms", 0 )	/* from other set */
+	ROM_LOAD( "bprom.u16",	0x0000, 0x0200, CRC(a6d43709) SHA1(cbff2cb60137462dc0b7c7719a64574218d96c62) )
+	ROM_RELOAD(				0x0200, 0x0200 )
+ROM_END
+
+
+
+/*********************** Diagnostic PROMs ***********************/
+
 ROM_START( comg903d )	/* Cal Omega 903d (System 903 diag.PROM) */
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_FILL(				0x1800, 0x0800, 0xff )	/* empty socket (requested by the manual) */
@@ -2925,7 +3748,35 @@
 ROM_END
 
 
-/******* Unofficial/3rd part games *******/
+
+/****************** Unofficial / 3rd part games *****************/
+
+/*
+
+  El Grande 5 Card Draw
+
+  ROM text showed poker stuff and "TUNI" "1982"
+
+  .u6    2716
+  .u7    2516
+  .u8    2516
+  .u9    2516
+  .u67   2516
+  .u68   2516
+  .u69   2716
+  .u70   2716
+  .u28   82s129
+
+  6502
+  HD46505
+  AY-3-8912
+  MC6821P x2
+  TC5501  x2
+  10MHz Crystal
+
+  empty socket at u5
+
+*/
 
 ROM_START( elgrande )
 	ROM_REGION( 0x10000, "maincpu", 0 )
@@ -3066,9 +3917,9 @@
 ROM_END
 
 
-/*************************
-*      Driver Init       *
-*************************/
+/*************************************************
+*                  Driver Init                   *
+*************************************************/
 
 static DRIVER_INIT( standard )
 {
@@ -3105,54 +3956,87 @@
 	for (x = 0x0000; x < 0x0400; x++)
 	{
 		if (BPR[x] == 0x02)
-			BPR[x] = 0x00;	/* blue background */
+			BPR[x] = 0x00;	/* black background */
+	}
+}
+
+static DRIVER_INIT( comg080 )
+{
+	/* background color is adjusted through RGB pots */
+	int x;
+	UINT8 *BPR = memory_region( machine, "proms" );
+
+	for (x = 0x0000; x < 0x0400; x++)
+	{
+		if (BPR[x] == 0x07)
+			BPR[x] = 0x04;	/* blue background */
 	}
+
+	/* Injecting missing Start and NMI vectors...
+       Start = $2042;  NMI = $26f8;
+       Also a fake vector at $3ff8-$3ff9. The code checks these values to continue.
+    */
+	UINT8 *PRGROM = memory_region( machine, "maincpu" );
+
+	PRGROM[0x3ff8] = 0x8e; /* checked by code */
+	PRGROM[0x3ff9] = 0x97; /* checked by code */
+
+	PRGROM[0x3ffc] = 0x42; /* Start vector */
+	PRGROM[0x3ffd] = 0x20;
+	PRGROM[0x3ffe] = 0xf8; /* NMI vector */
+	PRGROM[0x3fff] = 0x26;
 }
 
 
-/*************************
-*      Game Drivers      *
-*************************/
-
-/*    YEAR  NAME      PARENT    MACHINE   INPUT     INIT      ROT    COMPANY                                  FULLNAME                                        FLAGS   */
-GAME( 1981, comg074,  0,        sys903,   comg074,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.4 (Gaming Poker, W.Export)", 0 )
-GAME( 1981, comg076,  0,        sys903,   comg076,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.6 (Arcade Poker)",           0 )
-GAME( 1981, comg079,  0,        sys903,   comg076,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.9 (Arcade Poker)",           GAME_NOT_WORKING )	/* bad dump */
-GAME( 1981, comg080,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 8.0 (Arcade Black Jack)",      GAME_NOT_WORKING )	/* bad dump */
-GAME( 1981, comg094,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 9.4 (Keno)",                   GAME_NOT_WORKING )
-GAME( 1982, comg107,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 10.7c (Big Game)",             GAME_NOT_WORKING )
-GAME( 1982, comg123,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.3 (Ticket Poker)",          GAME_NOT_WORKING )	/* bad dump */
-GAME( 1982, comg125,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.5 (Bingo)",                 GAME_NOT_WORKING )
-GAME( 1982, comg127,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.7 (Keno)",                  GAME_NOT_WORKING )
-GAME( 1982, comg128,  0,        sys903,   comg128,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.8 (Arcade Game)",           0 )
-GAME( 1982, comg134,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 13.4 (Nudge Bingo)",           GAME_NOT_WORKING )
-GAME( 1982, comg145,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 14.5 (Pixels)",                GAME_NOT_WORKING )
-GAME( 1983, comg157,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 15.7 (Double-Draw Poker)",     GAME_NOT_WORKING )
-GAME( 1983, comg159,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 15.9 (Wild Double-Up)",        GAME_NOT_WORKING )
-GAME( 1983, comg164,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 16.4 (Keno)",                  GAME_NOT_WORKING )	/* incomplete dump */
-GAME( 1983, comg168,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 16.8 (Keno)",                  GAME_NOT_WORKING )
-GAME( 1983, comg172,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 17.2 (Double Double Poker)",   GAME_NOT_WORKING )
-GAME( 1984, comg175,  0,        sys903,   gdrawpkr, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 17.51 (Gaming Draw Poker)",    0 )
-GAME( 1982, comg176,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 17.6 (Nudge Bingo)",           GAME_NOT_WORKING )
-GAME( 1982, comg181,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.1 (Nudge Bingo)",           GAME_NOT_WORKING )
-GAME( 1983, comg183,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.3 (Pixels)",                GAME_NOT_WORKING )
-GAME( 1983, comg185,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.5 (Pixels)",                GAME_NOT_WORKING )
-GAME( 1983, comg186,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.6 (Pixels)",                GAME_NOT_WORKING )
-GAME( 1983, comg187,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.7 (Amusement Poker)",       GAME_NOT_WORKING )	/* bad dump */
-GAME( 1984, comg204,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 20.4 (Super Blackjack)",       GAME_NOT_WORKING )
-GAME( 1984, comg208,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 20.8 (Winner's Choice)",       GAME_NOT_WORKING )
-GAME( 1984, comg227,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 22.7 (Amusement Poker, d/d)",  GAME_NOT_WORKING )
-GAME( 1984, comg230,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 23.0 (FC Bingo (4-card))",     GAME_NOT_WORKING )	/* bad dump */
-GAME( 1984, comg236,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 23.6 (Hotline)",               GAME_NOT_WORKING )
-GAME( 1985, comg239,  0,        sys903,   gdrawpkr, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 23.9 (Gaming Draw Poker)",     0 )
-GAME( 1985, comg246,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 24.6 (Hotline)",               GAME_NOT_WORKING )
-GAME( 1985, comg272a, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 27.2 (Keno, amusement)",       GAME_NOT_WORKING )
-GAME( 1985, comg272b, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 27.2 (Keno, gaming)",          GAME_NOT_WORKING )
-GAME( 198?, comg903d, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - System 903 Diag.PROM",              GAME_NOT_WORKING )
-GAME( 198?, comg905d, 0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - System 905 Diag.PROM",              GAME_NOT_WORKING )
-GAME( 1982, elgrande, 0,        s903mod,  elgrande, elgrande, ROT0, "Tuni Electro Service / E.T. Marketing", "El Grande - 5 Card Draw (New)",                 0 )
-GAME( 1983, jjpoker,  0,        s903mod,  jjpoker,  jjpoker,  ROT0, "Enter-Tech (ETL)",                      "Jackpot Joker Poker (set 1)",                   0 )
-GAME( 1983, jjpokerb, jjpoker,  s903mod,  jjpoker,  jjpoker,  ROT0, "Enter-Tech (ETL)",                      "Jackpot Joker Poker (set 2)",                   0 )
-GAME( 1988, ssipkr24, 0,        s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v2.4)",                              0 )
-GAME( 1988, ssipkr30, ssipkr24, s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v3.0)",                              0 )
-GAME( 1990, ssipkr40, ssipkr24, s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v4.0)",                              0 )
+/*************************************************
+*                  Game Drivers                  *
+*************************************************/
+
+/*    YEAR  NAME      PARENT    MACHINE   INPUT     INIT      ROT    COMPANY                                  FULLNAME                                                    FLAGS   */
+GAME( 1981, comg074,  0,        sys903,   comg074,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.4 (Gaming Poker, W.Export)",             0 )
+GAME( 1981, comg076,  0,        sys903,   comg076,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.6 (Arcade Poker)",                       0 )
+GAME( 1981, comg079,  0,        sys903,   comg076,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 7.9 (Arcade Poker)",                       GAME_NOT_WORKING )	/* bad dump */
+GAME( 1981, comg080,  0,        sys903,   arcadebj, comg080,  ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 8.0 (Arcade Black Jack)",                  0 )					/* bad dump */
+GAME( 1981, comg094,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 9.4 (Keno)",                               GAME_NOT_WORKING )
+GAME( 1982, comg107,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 10.7c (Big Game)",                         GAME_NOT_WORKING )
+GAME( 1982, comg123,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.3 (Ticket Poker)",                      GAME_NOT_WORKING )	/* bad dump */
+GAME( 1982, comg125,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.5 (Bingo)",                             GAME_NOT_WORKING )
+GAME( 1982, comg127,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.7 (Keno)",                              GAME_NOT_WORKING )
+GAME( 1982, comg128,  0,        sys903,   comg128,  standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 12.8 (Arcade Game)",                       0 )
+GAME( 1982, comg134,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 13.4 (Nudge Bingo)",                       GAME_NOT_WORKING )
+GAME( 1982, comg145,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 14.5 (Pixels)",                            GAME_NOT_WORKING )
+GAME( 1983, comg157,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 15.7 (Double-Draw Poker)",                 GAME_NOT_WORKING )
+GAME( 1983, comg159,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 15.9 (Wild Double-Up)",                    GAME_NOT_WORKING )
+GAME( 1983, comg164,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 16.4 (Keno)",                              GAME_NOT_WORKING )	/* incomplete dump */
+GAME( 1983, comg168,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 16.8 (Keno)",                              GAME_NOT_WORKING )
+GAME( 1983, comg172,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 17.2 (Double Double Poker)",               GAME_NOT_WORKING )
+GAME( 1984, comg175,  0,        sys903,   gdrwpkrd, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 17.51 (Gaming Draw Poker)",                0 )
+GAME( 1982, comg176,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 17.6 (Nudge Bingo)",                       GAME_NOT_WORKING )
+GAME( 1982, comg181,  0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.1 (Nudge Bingo)",                       GAME_NOT_WORKING )
+GAME( 1983, comg183,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.3 (Pixels)",                            GAME_NOT_WORKING )
+GAME( 1983, comg185,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.5 (Pixels)",                            GAME_NOT_WORKING )
+GAME( 1983, comg186,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.6 (Pixels)",                            GAME_NOT_WORKING )
+GAME( 1983, comg187,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 18.7 (Amusement Poker)",                   GAME_NOT_WORKING )	/* bad dump */
+GAME( 1984, comg204,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 20.4 (Super Blackjack)",                   GAME_NOT_WORKING )
+GAME( 1984, comg208,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 20.8 (Winner's Choice)",                   GAME_NOT_WORKING )
+GAME( 1984, comg227,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 22.7 (Amusement Poker, d/d)",              GAME_NOT_WORKING )
+GAME( 1984, comg230,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 23.0 (FC Bingo (4-card))",                 GAME_NOT_WORKING )	/* bad dump */
+GAME( 1984, comg236,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 23.6 (Hotline)",                           GAME_NOT_WORKING )
+GAME( 1985, comg239,  0,        sys903,   gdrwpkrd, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 23.9 (Gaming Draw Poker)",                 0 )
+GAME( 1985, comg240,  0,        sys903,   gdrwpkrh, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 24.0 (Gaming Draw Poker, hold)",           0 )
+GAME( 1985, comg246,  0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 24.6 (Hotline)",                           GAME_NOT_WORKING )
+GAME( 1985, comg272a, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 27.2 (Keno, amusement)",                   GAME_NOT_WORKING )
+GAME( 1985, comg272b, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - Game 27.2 (Keno, gaming)",                      GAME_NOT_WORKING )
+GAME( 198?, comg5108, 0,        sys906,   stand906, standard, ROT0, "Cal Omega / Casino Electronics Inc.",   "Cal Omega - Game 51.08 (CEI Video Poker, Jacks or Better)", GAME_NOT_WORKING )
+
+/************ Diagnostic PROMs ************/
+GAME( 198?, comg903d, 0,        sys903,   stand903, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - System 903 Diag.PROM",                          GAME_NOT_WORKING )
+GAME( 198?, comg905d, 0,        sys905,   stand905, standard, ROT0, "Cal Omega Inc.",                        "Cal Omega - System 905 Diag.PROM",                          GAME_NOT_WORKING )
+
+/****** Unofficial / 3rd part games *******/
+GAME( 1982, elgrande, 0,        s903mod,  elgrande, elgrande, ROT0, "Tuni Electro Service / E.T. Marketing", "El Grande - 5 Card Draw (New)",                             0 )
+GAME( 1983, jjpoker,  0,        s903mod,  jjpoker,  jjpoker,  ROT0, "Enter-Tech (ETL)",                      "Jackpot Joker Poker (set 1)",                               0 )
+GAME( 1983, jjpokerb, jjpoker,  s903mod,  jjpoker,  jjpoker,  ROT0, "Enter-Tech (ETL)",                      "Jackpot Joker Poker (set 2)",                               0 )
+GAME( 1988, ssipkr24, 0,        s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v2.4)",                                          0 )
+GAME( 1988, ssipkr30, ssipkr24, s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v3.0)",                                          0 )
+GAME( 1990, ssipkr40, ssipkr24, s903mod,  ssipkr,   jjpoker,  ROT0, "SSI",                                   "SSI Poker (v4.0)",                                          0 )
diff -Nru src-old/mame/drivers/calorie.c src/mame/drivers/calorie.c
--- src-old/mame/drivers/calorie.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/calorie.c	2010-08-19 07:19:38.000000000 -0700
@@ -555,8 +555,8 @@
 
 static DRIVER_INIT( calorieb )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x10000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x10000);
 }
 
 
diff -Nru src-old/mame/drivers/cdi.c src/mame/drivers/cdi.c
--- src-old/mame/drivers/cdi.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/cdi.c	2010-08-22 10:21:55.000000000 -0700
@@ -4792,9 +4792,9 @@
 
 /*          rom       parent    machine   inp       init */
 GAME( 1991, cdi,      0,        cdi,      cdi,      0,        ROT0,     "Philips", "CD-i (Mono-I) BIOS", GAME_IS_BIOS_ROOT )
-GAME( 1996, quizard,  cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard 3.2",   GAME_NOT_WORKING )
-GAME( 1995, quizrd22, cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard 2.2",   GAME_NOT_WORKING )
-GAME( 1995, quizrd17, cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard 1.7",   GAME_NOT_WORKING )
-GAME( 1995, quizrd12, cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard 1.2",   GAME_NOT_WORKING )
-GAME( 1998, quizrr42, cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard Rainbow 4.2",   GAME_NOT_WORKING )
-GAME( 1998, quizrr41, cdi,      cdi,      cdi,      0,        ROT0,     "Disney",  "Quizard Rainbow 4.1",   GAME_NOT_WORKING )
+GAME( 1996, quizard,  cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard 3.2",   GAME_NOT_WORKING )
+GAME( 1995, quizrd22, cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard 2.2",   GAME_NOT_WORKING )
+GAME( 1995, quizrd17, cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard 1.7",   GAME_NOT_WORKING )
+GAME( 1995, quizrd12, cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard 1.2",   GAME_NOT_WORKING )
+GAME( 1998, quizrr42, cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard Rainbow 4.2",   GAME_NOT_WORKING )
+GAME( 1998, quizrr41, cdi,      cdi,      cdi,      0,        ROT0,     "TAB Austria",  "Quizard Rainbow 4.1",   GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/centiped.c src/mame/drivers/centiped.c
--- src-old/mame/drivers/centiped.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/centiped.c	2010-08-19 00:26:14.000000000 -0700
@@ -1976,7 +1976,7 @@
 
 static DRIVER_INIT( caterplr )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	running_device *device = machine->device("pokey");
 	memory_install_readwrite8_device_handler(space, device, 0x1000, 0x100f, 0, 0, caterplr_AY8910_r, caterplr_AY8910_w);
 	memory_install_read8_device_handler(space, device, 0x1780, 0x1780, 0, 0, caterplr_rand_r);
@@ -1985,7 +1985,7 @@
 
 static DRIVER_INIT( magworm )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	running_device *device = machine->device("pokey");
 	memory_install_write8_device_handler(space, device, 0x1001, 0x1001, 0, 0, ay8910_address_w);
 	memory_install_readwrite8_device_handler(space, device, 0x1003, 0x1003, 0, 0, ay8910_r, ay8910_data_w);
diff -Nru src-old/mame/drivers/chihiro.c src/mame/drivers/chihiro.c
--- src-old/mame/drivers/chihiro.c	2010-07-11 08:15:47.000000000 -0700
+++ src/mame/drivers/chihiro.c	2010-08-30 08:20:58.000000000 -0700
@@ -36,20 +36,135 @@
 
 #include "emu.h"
 #include "cpu/i386/i386.h"
+#include "machine/pci.h"
 #include "includes/naomibd.h"
+#include "debug/debugcon.h"
+#include "debug/debugcmd.h"
 
-static VIDEO_START(chihiro)
-{
+/* jamtable instructions for Chihiro
+St.     Instr.       Comment
+0x01    POKEPCI      PCICONF[OP2] := OP1
+0x02    OUTB         PORT[OP2] := OP1
+0x03    POKE         MEM[OP2] := OP1
+0x04    BNE          IF ACC <> OP2 THEN PC := PC + OP1
+0x05    PEEKPCI      ACC := PCICONF[OP2]
+0x06    AND/OR       ACC := (ACC & OP2) | OP1
+0x07    BRA          PC := PC + OP1
+0x08    INB          ACC := PORT[OP2]
+0x09    PEEK         ACC := MEM[OP2]
+0xE1    (prefix)     execute the instruction code in OP2 with OP2 := OP1, OP1 := ACC
+0xEE    END
+*/
 
+/* jamtable disassembler */
+static void jamtable_disasm(running_machine *machine, address_space *space,UINT32 address,UINT32 size) // 0xff000080 == fff00080
+{
+	UINT32 base,addr;
+	UINT32 opcode,op1,op2;
+	char sop1[16];
+	char sop2[16];
+	char pcrel[16];
+	int prefix;
+
+	addr=address;
+	while (1)
+	{
+		base=addr;
+		opcode=space->read_byte(addr);
+		addr++;
+		op1=space->read_dword(addr);
+		addr+=4;
+		op2=space->read_dword(addr);
+		addr+=4;
+		if (opcode == 0xe1)
+		{
+			opcode=op2 & 255;
+			op2=op1;
+			//op1=edi;
+			sprintf(sop2,"%08X",op2);
+			sprintf(sop1,"ACC");
+			sprintf(pcrel,"PC+ACC");
+			prefix=1;
+		}
+		else
+		{
+			sprintf(sop2,"%08X",op2);
+			sprintf(sop1,"%08X",op1);
+			sprintf(pcrel,"%08X",base+9+op1);
+			prefix=0;
+		}
+		debug_console_printf(machine,"%08X ",base);
+		// dl=instr ebx=par1 eax=par2
+		switch (opcode)
+		{
+			case 0x01:
+				// if ((op2 & 0xff) == 0x880) op1=op1 & 0xfffffffd
+				// out cf8,op2
+				// out cfc,op1
+				// out cf8,0
+				// cf8 (CONFIG_ADDRESS) format:
+				// 31 30      24 23        16 15           11 10              8 7               2 1 0
+				// +-+----------+------------+---------------+-----------------+-----------------+-+-+
+				// | | Reserved | Bus Number | Device Number | Function Number | Register Number |0|0|
+				// +-+----------+------------+---------------+-----------------+-----------------+-+-+
+				// 31 - Enable bit
+				debug_console_printf(machine,"POKEPCI PCICONF[%s]=%s\n",sop2,sop1);
+				break;
+			case 0x02:
+				debug_console_printf(machine,"OUTB    PORT[%s]=%s\n",sop2,sop1);
+				break;
+			case 0x03:
+				debug_console_printf(machine,"POKE    MEM[%s]=%s\n",sop2,sop1);
+				break;
+			case 0x04:
+				debug_console_printf(machine,"BNE     IF ACC != %s THEN PC=%s\n",sop2,pcrel);
+				break;
+			case 0x05:
+				// out cf8,op2
+				// in acc,cfc
+				debug_console_printf(machine,"PEEKPCI ACC=PCICONF[%s]\n",sop2);
+				break;
+			case 0x06:
+				debug_console_printf(machine,"AND/OR  ACC=(ACC & %s) | %s\n",sop2,sop1);
+				break;
+			case 0x07:
+				debug_console_printf(machine,"BRA     PC=%s\n",pcrel);
+				break;
+			case 0x08:
+				debug_console_printf(machine,"INB     ACC=PORT[%s]\n",sop2);
+				break;
+			case 0x09:
+				debug_console_printf(machine,"PEEK    ACC=MEM[%s]\n",sop2);
+				break;
+			case 0xee:
+				debug_console_printf(machine,"END\n");
+				break;
+			default:
+				debug_console_printf(machine,"NOP     ????\n");
+				break;
+		}
+		if (opcode == 0xee)
+			break;
+		if (size <= 9)
+			break;
+		size-=9;
+	}
 }
 
-static VIDEO_UPDATE(chihiro)
+void jamtable_disasm_command(running_machine *machine, int ref, int params, const char **param)
 {
+	address_space *space=machine->firstcpu->space();
+	UINT64	addr,size;
 
-	return 0;
+	if (params < 2)
+		return;
+	if (!debug_command_parameter_number(machine, param[0], &addr))
+		return;
+	if (!debug_command_parameter_number(machine, param[1], &size))
+		return;
+	jamtable_disasm(machine, space, (UINT32)addr, (UINT32)size);
 }
 
-
 /*
 St.     Instr.       Comment
 0x02    PEEK         ACC := MEM[OP1]
@@ -65,32 +180,142 @@
 0x12    INB          ACC := PORT(OP1)
 0xEE    END
 */
+#ifdef UNUSED_FUNCTION
 static READ32_HANDLER( chihiro_jamtable )
 {
 	return 0xEEEEEEEE;
 }
+#endif
+
+static UINT32 dummy_pci_r(running_device *busdevice, running_device *device, int function, int reg, UINT32 mem_mask)
+{
+	logerror("  bus:%d function:%d register:%d mask:%08X\n",((pci_bus_config *)downcast<const legacy_device_config_base &>(busdevice->baseconfig()).inline_config())->busnum,function,reg,mem_mask);
+	return 0;
+}
+
+static void dummy_pci_w(running_device *busdevice, running_device *device, int function, int reg, UINT32 data, UINT32 mem_mask)
+{
+	logerror("  bus:%d function:%d register:%d data:%08X mask:%08X\n",((pci_bus_config *)downcast<const legacy_device_config_base &>(busdevice->baseconfig()).inline_config())->busnum,function,reg,data,mem_mask);
+}
+
+static READ32_HANDLER( dummy_r )
+{
+	return 0;
+}
+
+static WRITE32_HANDLER( dummy_w )
+{
+}
+
+int smbus_cx25871(int command,int rw,int data)
+{
+	logerror("cx25871: %d %d %d\n",command,rw,data);
+	return 0;
+}
+
+typedef struct _smbus_state {
+	int status;
+	int control;
+	int address;
+	int data;
+	int command;
+	int rw;
+	int (*devices[128])(int command,int rw,int data);
+	UINT32 words[256/4];
+} smbus_state;
+smbus_state smbusst;
+
+void smbus_register_device(int address,int (*handler)(int command,int rw,int data))
+{
+	if (address < 128)
+		smbusst.devices[address]=handler;
+}
+
+static READ32_HANDLER( smbus_r )
+{
+	if ((offset == 0) && (mem_mask == 0xff)) // 0 smbus status
+		smbusst.words[offset] = (smbusst.words[offset] & ~mem_mask) | (smbusst.status << 0);
+	if ((offset == 1) && (mem_mask == 0xff0000)) // 6 smbus data
+		smbusst.words[offset] = (smbusst.words[offset] & ~mem_mask) | (smbusst.data << 16);
+	return smbusst.words[offset];
+}
+
+static WRITE32_HANDLER( smbus_w )
+{
+	COMBINE_DATA(smbusst.words);
+	if ((offset == 0) && (mem_mask == 0xff)) // 0 smbus status
+		smbusst.status &= ~data;
+	if ((offset == 0) && (mem_mask == 0xff0000)) // 2 smbus control
+	{
+		data=data>>16;
+		smbusst.control = data;
+		if ((smbusst.control & 6) == 2)
+		{
+			if (smbusst.devices[smbusst.address & 127]) {
+				if (smbusst.rw == 0) {
+					smbusst.devices[smbusst.address & 127](smbusst.command,smbusst.rw,smbusst.data);
+				}
+				else {
+					smbusst.data=smbusst.devices[smbusst.address & 127](smbusst.command,smbusst.rw,smbusst.data);
+				}
+			}
+			smbusst.status |= 0x10;
+		}
+	}
+	if ((offset == 1) && (mem_mask == 0xff)) // 4 smbus address
+	{
+		smbusst.address = data >> 1;
+		smbusst.rw = data & 1;
+	}
+	if ((offset == 1) && (mem_mask == 0xff0000)) // 6 smbus data
+	{
+		data=data>>16;
+		smbusst.data = data;
+	}
+	if ((offset == 2) && (mem_mask == 0xff)) // 8 smbus command
+		smbusst.command = data;
+}
 
 
 static ADDRESS_MAP_START( xbox_map, ADDRESS_SPACE_PROGRAM, 32 )
-	AM_RANGE(0x00000000, 0x004fffff) AM_RAM
-	AM_RANGE(0x07fd0000, 0x07feffff) AM_RAM // a table of some sort?
+	AM_RANGE(0x00000000, 0x07ffffff) AM_RAM
+	AM_RANGE(0xff000000, 0xffffffff) AM_ROM AM_REGION("bios", 0) AM_MIRROR(0x00f80000)
+ADDRESS_MAP_END
 
-	AM_RANGE(0xff000080, 0xff000083) AM_READ( chihiro_jamtable )
-	AM_RANGE(0xfff00000, 0xfff7ffff) AM_ROM AM_SHARE("biosflash")
-	AM_RANGE(0xfff80000, 0xffffffff) AM_ROM AM_REGION("bios", 0) AM_SHARE("biosflash")
+static ADDRESS_MAP_START(xbox_map_io, ADDRESS_SPACE_IO, 32)
+	AM_RANGE(0x0cf8, 0x0cff) AM_DEVREADWRITE("pcibus", pci_32le_r, pci_32le_w)
+	AM_RANGE(0x8000, 0x80ff) AM_READWRITE(dummy_r, dummy_w)
+	AM_RANGE(0xc000, 0xc0ff) AM_READWRITE(smbus_r, smbus_w)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( chihiro )
 INPUT_PORTS_END
 
+static MACHINE_START( chihiro )
+{
+	smbus_register_device(0x45,smbus_cx25871);
+	debug_console_register_command(machine,"jamdis",CMDFLAG_NONE,0,2,3,jamtable_disasm_command);
+}
+
 static MACHINE_DRIVER_START( chihiro_base )
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", PENTIUM, 733333333) /* Wrong! */
 	MDRV_CPU_PROGRAM_MAP(xbox_map)
+	MDRV_CPU_IO_MAP(xbox_map_io)
 
 	MDRV_QUANTUM_TIME(HZ(6000))
 
+	MDRV_PCI_BUS_ADD("pcibus", 0)
+	MDRV_PCI_BUS_DEVICE(0, "PCI Bridge Device - Host Bridge", dummy_pci_r, dummy_pci_w)
+	MDRV_PCI_BUS_DEVICE(1, "HUB Interface - ISA Bridge", dummy_pci_r, dummy_pci_w)
+	MDRV_PCI_BUS_DEVICE(2, "OHCI USB Controller 1", dummy_pci_r, dummy_pci_w)
+	MDRV_PCI_BUS_DEVICE(3, "OHCI USB Controller 2", dummy_pci_r, dummy_pci_w)
+	MDRV_PCI_BUS_DEVICE(30, "AGP Host to PCI Bridge", dummy_pci_r, dummy_pci_w)
+	MDRV_PCI_BUS_ADD("agpbus", 1)
+	MDRV_PCI_BUS_SIBLING("pcibus")
+	MDRV_PCI_BUS_DEVICE(0, "NV2A GeForce 3MX Integrated GPU/Northbridge", dummy_pci_r, dummy_pci_w)
+
 	/* video hardware */
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_REFRESH_RATE(60)
@@ -98,10 +323,9 @@
 	MDRV_SCREEN_SIZE(640, 480)
 	MDRV_SCREEN_VISIBLE_AREA(0, 639, 0, 479)
 
-	MDRV_PALETTE_LENGTH(65536)
+	MDRV_MACHINE_START(chihiro)
 
-	MDRV_VIDEO_START(chihiro)
-	MDRV_VIDEO_UPDATE(chihiro)
+	MDRV_PALETTE_LENGTH(65536)
 MACHINE_DRIVER_END
 
 static MACHINE_DRIVER_START( chihirogd )
@@ -116,7 +340,7 @@
 		ROMX_LOAD(name, offset, length, hash, ROM_BIOS(bios+1)) /* Note '+1' */
 
 #define CHIHIRO_BIOS \
-	ROM_REGION( 0x200000, "bios", 0) \
+	ROM_REGION( 0x1000000, "bios", 0) \
 	ROM_SYSTEM_BIOS( 0, "bios0", "Chihiro Bios" ) \
 	ROM_LOAD_BIOS( 0,  "chihiro_xbox_bios.bin", 0x000000, 0x80000, CRC(66232714) SHA1(b700b0041af8f84835e45d1d1250247bf7077188) ) \
 	ROM_REGION( 0x200000, "others", 0) \
@@ -310,4 +534,3 @@
 GAME( 2003, vcop3,    chihiro, chihirogd,    chihiro,    0, ROT0, "Sega",           "Virtua Cop 3 (GDX-0003A)", GAME_NO_SOUND|GAME_NOT_WORKING )
 GAME( 2005, mj3,      chihiro, chihirogd,    chihiro,    0, ROT0, "Sega",           "Sega Network Taisen Mahjong MJ 3 (Rev D) (GDX-0017D)", GAME_NO_SOUND|GAME_NOT_WORKING )
 GAME( 2006, scg06nt,  chihiro, chihirogd,    chihiro,    0, ROT0, "Sega",           "Sega Club Golf 2006 Next Tours (Rev A) (GDX-0018A)", GAME_NO_SOUND|GAME_NOT_WORKING )
-
diff -Nru src-old/mame/drivers/cojag.c src/mame/drivers/cojag.c
--- src-old/mame/drivers/cojag.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/cojag.c	2010-08-26 09:31:58.000000000 -0700
@@ -1082,7 +1082,7 @@
  *
  *************************************/
 
-static const r3000_cpu_core config =
+static const r3000_cpu_core r3000_config =
 {
 	0,		/* 1 if we have an FPU, 0 otherwise */
 	4096,	/* code cache size */
@@ -1106,7 +1106,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R3041BE, R3000_CLOCK)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r3000_config)
 	MDRV_CPU_PROGRAM_MAP(r3000_map)
 
 	MDRV_CPU_ADD("gpu", JAGUARGPU, JAGUAR_CLOCK/2)
diff -Nru src-old/mame/drivers/combatsc.c src/mame/drivers/combatsc.c
--- src-old/mame/drivers/combatsc.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/combatsc.c	2010-08-28 08:34:28.000000000 -0700
@@ -167,6 +167,20 @@
 static WRITE8_HANDLER( combatscb_priority_w )
 {
 	combatsc_state *state = space->machine->driver_data<combatsc_state>();
+
+	if (data & 0x40)
+	{
+		state->video_circuit = 1;
+		state->videoram = state->page[1];
+		state->scrollram = state->scrollram1;
+	}
+	else
+	{
+		state->video_circuit = 0;
+		state->videoram = state->page[0];
+		state->scrollram = state->scrollram0;
+	}
+
 	state->priority = data & 0x20;
 }
 
@@ -174,6 +188,8 @@
 {
 	combatsc_state *state = space->machine->driver_data<combatsc_state>();
 
+	state->priority = data & 0x20;
+
 	if (data & 0x40)
 	{
 		state->video_circuit = 1;
@@ -187,8 +203,6 @@
 		state->scrollram = state->scrollram0;
 	}
 
-	state->priority = data & 0x20;
-
 	if (data & 0x10)
 		memory_set_bank(space->machine, "bank1", (data & 0x0e) >> 1);
 	else
@@ -697,7 +711,7 @@
 static MACHINE_RESET( combatsc )
 {
 	combatsc_state *state = machine->driver_data<combatsc_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	memset(state->io_ram,  0x00, 0x4000);
diff -Nru src-old/mame/drivers/commando.c src/mame/drivers/commando.c
--- src-old/mame/drivers/commando.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/commando.c	2010-08-19 07:19:38.000000000 -0700
@@ -521,12 +521,12 @@
 
 static DRIVER_INIT( commando )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0xc000);
 	int A;
 
-	memory_set_decrypted_region(space, 0x0000, 0xbfff, decrypt);
+	space->set_decrypted_region(0x0000, 0xbfff, decrypt);
 
 	// the first opcode is *not* encrypted
 	decrypt[0] = rom[0];
@@ -541,12 +541,12 @@
 
 static DRIVER_INIT( spaceinv )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0xc000);
 	int A;
 
-	memory_set_decrypted_region(space, 0x0000, 0xbfff, decrypt);
+	space->set_decrypted_region(0x0000, 0xbfff, decrypt);
 
 	// the first opcode *is* encrypted
 	for (A = 0; A < 0xc000; A++)
diff -Nru src-old/mame/drivers/coolpool.c src/mame/drivers/coolpool.c
--- src-old/mame/drivers/coolpool.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/coolpool.c	2010-08-19 00:26:14.000000000 -0700
@@ -92,7 +92,7 @@
 
 	UINT16 *vram = &state->vram_base[(params->rowaddr << 8) & 0x1ff00];
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = params->coladdr;
 	int x;
 
@@ -112,7 +112,7 @@
  *
  *************************************/
 
-static void coolpool_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void coolpool_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	coolpool_state *state = space->machine->driver_data<coolpool_state>();
 
@@ -120,7 +120,7 @@
 }
 
 
-static void coolpool_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void coolpool_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	coolpool_state *state = space->machine->driver_data<coolpool_state>();
 
@@ -148,7 +148,6 @@
 
 static MACHINE_RESET( coolpool )
 {
-	tlc34076_reset(6);
 	nvram_write_enable = 0;
 }
 
@@ -318,7 +317,7 @@
 	return data;
 }
 
-static int amerdart_trackball_direction(const address_space *space, int num, int data)
+static int amerdart_trackball_direction(address_space *space, int num, int data)
 {
 	coolpool_state *state = space->machine->driver_data<coolpool_state>();
 
@@ -666,7 +665,7 @@
 
 static ADDRESS_MAP_START( coolpool_map, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM AM_BASE_MEMBER(coolpool_state,vram_base)
-	AM_RANGE(0x01000000, 0x010000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)	// IMSG176P-40
+	AM_RANGE(0x01000000, 0x010000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)	// IMSG176P-40
 	AM_RANGE(0x02000000, 0x020000ff) AM_READWRITE(coolpool_iop_r, coolpool_iop_w)
 	AM_RANGE(0x03000000, 0x0300000f) AM_WRITE(coolpool_misc_w)
 	AM_RANGE(0x03000000, 0x03ffffff) AM_ROM AM_REGION("gfx1", 0)
@@ -680,7 +679,7 @@
 	AM_RANGE(0x00000000, 0x001fffff) AM_RAM AM_BASE_MEMBER(coolpool_state,vram_base)
 	AM_RANGE(0x02000000, 0x020000ff) AM_READWRITE(coolpool_iop_r, coolpool_iop_w)
 	AM_RANGE(0x03000000, 0x0300000f) AM_WRITE(coolpool_misc_w)
-	AM_RANGE(0x04000000, 0x040000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)	// IMSG176P-40
+	AM_RANGE(0x04000000, 0x040000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)	// IMSG176P-40
 	AM_RANGE(0x06000000, 0x0601ffff) AM_MIRROR(0x00020000) AM_RAM_WRITE(nvram_thrash_data_w) AM_BASE_SIZE_GENERIC(nvram)
 	AM_RANGE(0xc0000000, 0xc00001ff) AM_READWRITE(tms34010_io_register_r, tms34010_io_register_w)
 	AM_RANGE(0xff000000, 0xff7fffff) AM_ROM AM_REGION("gfx1", 0)
@@ -917,6 +916,8 @@
 	MDRV_TIMER_ADD("nvram_timer", nvram_write_timeout)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_UPDATE(tms340x0)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/coolridr.c src/mame/drivers/coolridr.c
--- src-old/mame/drivers/coolridr.c	2010-07-01 21:49:37.000000000 -0700
+++ src/mame/drivers/coolridr.c	2010-08-19 01:27:05.000000000 -0700
@@ -450,7 +450,7 @@
 					size = (attr_buff[6] / 4)+1;
 					for(txt_index = 0;txt_index < size; txt_index++)
 					{
-						memory_write_dword(space,(dst_addr),txt_buff[txt_index]);
+						space->write_dword((dst_addr),txt_buff[txt_index]);
 						dst_addr+=4;
 					}
 				}
@@ -459,7 +459,7 @@
 			{
 				static UINT32 clear_vram;
 				for(clear_vram=0x3f40000;clear_vram < 0x3f4ffff;clear_vram+=4)
-					memory_write_dword(space,(clear_vram),0x00000000);
+					space->write_dword((clear_vram),0x00000000);
 			}
 			//else
 			//  printf("CMD = %04x PARAM = %04x DATA = %08x\n",cmd,param,data);
@@ -485,7 +485,7 @@
 
 
 /* FIXME: this seems to do a hell lot of stuff, it's not ST-V SCU but still somewhat complex :/ */
-static void sysh1_dma_transfer( const address_space *space, UINT16 dma_index )
+static void sysh1_dma_transfer( address_space *space, UINT16 dma_index )
 {
 	static UINT32 src,dst,size,type,s_i;
 	static UINT8 end_dma_mark;
@@ -542,7 +542,7 @@
 		{
 			for(s_i=0;s_i<size;s_i+=4)
 			{
-				memory_write_dword(space,dst,memory_read_dword(space,src));
+				space->write_dword(dst,space->read_dword(src));
 				dst+=4;
 				src+=4;
 			}
diff -Nru src-old/mame/drivers/cps1.c src/mame/drivers/cps1.c
--- src-old/mame/drivers/cps1.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/cps1.c	2010-08-30 08:20:58.000000000 -0700
@@ -221,7 +221,7 @@
       * 'ghoulsu'
       * 'willow', 'willowj' and 'willowje'
   - Checked sets with no debug features :
-      * 'forgottu' and 'lostwrld'
+      * 'forgottnua' and 'lostwrld'
       * 'ghouls' and 'daimakai'
       * 'dynwar' and 'dynwarj'
 
@@ -4140,37 +4140,50 @@
 ROM_END
 
 /* B-Board 88622B-3 */
-/* FIXME - GFX ROMs are wrong, copied from the other version */
-/* ROMs missing are WL_01 02 03 05 06 07 09 10 11 13 14 15 17 18 19 21 24 25 26 28 32 33 34 35 38 39 40 41 */
 ROM_START( willowj )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_BYTE( "wl_36.12f",         0x00000, 0x20000, CRC(2b0d7cbc) SHA1(58172b4fdf856efa8d77abbde76738de2424f712) )
-	ROM_LOAD16_BYTE( "wl_42.12h",         0x00001, 0x20000, CRC(1ac39615) SHA1(c9fa6d20418b9bdc5a08df1fb86368b40709280a) )
-	ROM_LOAD16_BYTE( "wl_37.13f",         0x40000, 0x20000, CRC(30a717fa) SHA1(cb815e9ee2691761925898e3932b502f8f399cb4) )
-	ROM_LOAD16_BYTE( "wl_43.13h",         0x40001, 0x20000, CRC(d0dddc9e) SHA1(1176b9a43b3355a5ba44e59abde01ee7eaa89c25) )
-	ROM_LOAD16_WORD_SWAP( "wl_32.rom",    0x80000, 0x80000, CRC(dfd9f643) SHA1(9c760c30af593a87e7fd39fb213a4c73c68ca440) )	/* WRONG */
-
-	ROM_REGION( 0x400000, "gfx", 0 )
-	ROMX_LOAD( "wl_gfx5.rom",  0x000000, 0x80000, CRC(afa74b73) SHA1(09081926260c76986a13ac5351dddd2ea11d7a10) , ROM_GROUPWORD | ROM_SKIP(6) )	/* WRONG */
-	ROMX_LOAD( "wl_gfx7.rom",  0x000002, 0x80000, CRC(12a0dc0b) SHA1(fea235ce9489f04919daf52f4d3f3bac9b558316) , ROM_GROUPWORD | ROM_SKIP(6) )	/* WRONG */
-	ROMX_LOAD( "wl_gfx1.rom",  0x000004, 0x80000, CRC(c6f2abce) SHA1(ff5fcfe417c43b4747bbe12db6052fdb60f5f0e4) , ROM_GROUPWORD | ROM_SKIP(6) )	/* WRONG */
-	ROMX_LOAD( "wl_gfx3.rom",  0x000006, 0x80000, CRC(4aa4c6d3) SHA1(7dd6f18f6126c380821a2ca8955439fd6864f4c6) , ROM_GROUPWORD | ROM_SKIP(6) )	/* WRONG */
-	ROMX_LOAD( "wl_24.rom",    0x200000, 0x20000, CRC(6f0adee5) SHA1(07b18e51b376001f25173b78e0e816f252400210) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_14.rom",    0x200001, 0x20000, CRC(9cf3027d) SHA1(1e8eb20d51a54f6f756c0ab9395ac38b96e67fb2) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_26.rom",    0x200002, 0x20000, CRC(f09c8ecf) SHA1(b39f83e80af010d6481693d9ec8b1d7e258b531d) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_16.rom",    0x200003, 0x20000, CRC(e35407aa) SHA1(7ddae9cef96839da72488c1fe73268c50e0262ff) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_20.rom",    0x200004, 0x20000, CRC(84992350) SHA1(f0ebd810ce099337cda94222dccce8ab9b3c3281) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_10.rom",    0x200005, 0x20000, CRC(b87b5a36) SHA1(25fb8f9698142473233ee509d4146089920e94e1) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_22.rom",    0x200006, 0x20000, CRC(fd3f89f0) SHA1(51ff95cff56ac78682ea56401b35a0aa63cef8cb) , ROM_SKIP(7) )	/* WRONG */
-	ROMX_LOAD( "wl_12.rom",    0x200007, 0x20000, CRC(7da49d69) SHA1(b0ae7ac4f858ee8d72e6877c4275da7a631e2e4c) , ROM_SKIP(7) )	/* WRONG */
+	ROM_LOAD16_BYTE( "wl_36.12f", 0x00000, 0x20000, CRC(2b0d7cbc) SHA1(58172b4fdf856efa8d77abbde76738de2424f712) )
+	ROM_LOAD16_BYTE( "wl_42.12h", 0x00001, 0x20000, CRC(1ac39615) SHA1(c9fa6d20418b9bdc5a08df1fb86368b40709280a) )
+	ROM_LOAD16_BYTE( "wl_37.13f", 0x40000, 0x20000, CRC(30a717fa) SHA1(cb815e9ee2691761925898e3932b502f8f399cb4) )
+	ROM_LOAD16_BYTE( "wl_43.13h", 0x40001, 0x20000, CRC(d0dddc9e) SHA1(1176b9a43b3355a5ba44e59abde01ee7eaa89c25) )
+	ROM_LOAD16_BYTE( "wl_34.10f", 0x80000, 0x20000, CRC(23a84f7a) SHA1(f7667ffc85e2dfb78f5ed8ea54b6223e7375433a) )	// == wlm-32.8h
+	ROM_LOAD16_BYTE( "wl_40.10h", 0x80001, 0x20000, CRC(c7a0ed21) SHA1(190aec48a8f528652b434425f64ea2e52029ad3d) )	// == wlm-32.8h
+	ROM_LOAD16_BYTE( "wl_35.11f", 0xc0000, 0x20000, CRC(5eff7951) SHA1(f336bfd07f3083e3b3e72c61d03abb52d443204d) )	// == wlm-32.8h
+	ROM_LOAD16_BYTE( "wl_41.11h", 0xc0001, 0x20000, CRC(8d6477a3) SHA1(1bdb98f89ec8c2dcd47ab90bdd1be862ea59a16b) )	// == wlm-32.8h
+
+	ROM_REGION( 0x400000, "gfx", 0 )
+	ROMX_LOAD( "wl_09.4b",  0x000000, 0x20000, CRC(05aa71b4) SHA1(791f845928ff164eace07cfcc35d0bd9d7cbb2d0) , ROM_SKIP(7) )	// == wlm-7.7a
+	ROMX_LOAD( "wl_01.4a",  0x000001, 0x20000, CRC(08c2df12) SHA1(269ca05ff6f9928e3b46f43b262c03ac3dd768b8) , ROM_SKIP(7) )	// == wlm-7.7a
+	ROMX_LOAD( "wl_13.9b",  0x000002, 0x20000, CRC(1f7c87cd) SHA1(6817c8b42ef4e8183fc2fbd2765e49ac955cca80) , ROM_SKIP(7) )	// == wlm-5.9a
+	ROMX_LOAD( "wl_05.9a",  0x000003, 0x20000, CRC(f5254bf2) SHA1(a53973b98b8e8903c731eb2514cb9ce4060d5164) , ROM_SKIP(7) )	// == wlm-5.9a
+	ROMX_LOAD( "wl_24.5e",  0x000004, 0x20000, CRC(d9d73ba1) SHA1(5f7b5e7e6fe64106cd96a968a54556e4f5ad9387) , ROM_SKIP(7) )	// == wlm-3.3a
+	ROMX_LOAD( "wl_17.5c",  0x000005, 0x20000, CRC(a652f30c) SHA1(b150d8978d37907c6d17042476c4608c76c4ea3f) , ROM_SKIP(7) )	// == wlm-3.3a
+	ROMX_LOAD( "wl_38.8h",  0x000006, 0x20000, CRC(f6f9111b) SHA1(bd44d1b6084fe2c09cdd91b5ad6eff7a84f3e601) , ROM_SKIP(7) )	// == wlm-1.5a
+	ROMX_LOAD( "wl_32.8f",  0x000007, 0x20000, CRC(10f64027) SHA1(abf387ba7d8f0530a562a984c08345a149cfa226) , ROM_SKIP(7) )	// == wlm-1.5a
+	ROMX_LOAD( "wl_10.5b",  0x100000, 0x20000, CRC(dbba0a3f) SHA1(38c0cdd87e6631721f35a0b85fd5165940454603) , ROM_SKIP(7) )	// == wlm-7.7a
+	ROMX_LOAD( "wl_02.5a",  0x100001, 0x20000, CRC(86fba7a5) SHA1(9389ad4e0968b3edd4baeac8b29637618f49dbfb) , ROM_SKIP(7) )	// == wlm-7.7a
+	ROMX_LOAD( "wl_14.10b", 0x100002, 0x20000, CRC(7d5798b2) SHA1(7dfcc172e5df0e8f4b9188381463f9eca00945dc) , ROM_SKIP(7) )	// == wlm-5.9a
+	ROMX_LOAD( "wl_06.10a", 0x100003, 0x20000, CRC(1f052948) SHA1(ca3a6be94ae50fa50604ee52704792b22cbbc083) , ROM_SKIP(7) )	// == wlm-5.9a
+	ROMX_LOAD( "wl_25.7e",  0x100004, 0x20000, CRC(857d17d2) SHA1(e6b383df9571df6743a7aa3087f0632dc4e6143b) , ROM_SKIP(7) )	// == wlm-3.3a
+	ROMX_LOAD( "wl_18.7c",  0x100005, 0x20000, CRC(316c7fbc) SHA1(631682c7f14fa73f5f5a4fb747bfb45d9613e507) , ROM_SKIP(7) )	// == wlm-3.3a
+	ROMX_LOAD( "wl_39.9h",  0x100006, 0x20000, CRC(e6fce9b0) SHA1(46d50cf32c3518ab3dc717553c5375f3cb022cde) , ROM_SKIP(7) )	// == wlm-1.5a
+	ROMX_LOAD( "wl_33.9f",  0x100007, 0x20000, CRC(a15d5517) SHA1(03a30e216f8240383d5fa9736b4fe5119d231685) , ROM_SKIP(7) )	// == wlm-1.5a
+	ROMX_LOAD( "wl_11.7b",  0x200000, 0x20000, CRC(6f0adee5) SHA1(07b18e51b376001f25173b78e0e816f252400210) , ROM_SKIP(7) )	// == wl_24.7d
+	ROMX_LOAD( "wl_03.7a",  0x200001, 0x20000, CRC(9cf3027d) SHA1(1e8eb20d51a54f6f756c0ab9395ac38b96e67fb2) , ROM_SKIP(7) )	// == wl_14.7c
+	ROMX_LOAD( "wl_15.11b", 0x200002, 0x20000, CRC(f09c8ecf) SHA1(b39f83e80af010d6481693d9ec8b1d7e258b531d) , ROM_SKIP(7) )	// == wl_26.9d
+	ROMX_LOAD( "wl_07.11a", 0x200003, 0x20000, CRC(e35407aa) SHA1(7ddae9cef96839da72488c1fe73268c50e0262ff) , ROM_SKIP(7) )	// == wl_16.9c
+	ROMX_LOAD( "wl_26.8e",  0x200004, 0x20000, CRC(84992350) SHA1(f0ebd810ce099337cda94222dccce8ab9b3c3281) , ROM_SKIP(7) )	// == wl_20.3d
+	ROMX_LOAD( "wl_19.8c",  0x200005, 0x20000, CRC(b87b5a36) SHA1(25fb8f9698142473233ee509d4146089920e94e1) , ROM_SKIP(7) )	// == wl_10.3c
+	ROMX_LOAD( "wl_28.10e", 0x200006, 0x20000, CRC(fd3f89f0) SHA1(51ff95cff56ac78682ea56401b35a0aa63cef8cb) , ROM_SKIP(7) )	// == wl_22.5d
+	ROMX_LOAD( "wl_21.10c", 0x200007, 0x20000, CRC(7da49d69) SHA1(b0ae7ac4f858ee8d72e6877c4275da7a631e2e4c) , ROM_SKIP(7) )	// == wl_12.5c
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "wl_23.13c",     0x00000, 0x08000, CRC(f6b3d060) SHA1(0ed2e2f64ba53ba2c371b66ab1e52e40b16d8baf) )	// == wl_09.12b
-	ROM_CONTINUE(              0x10000, 0x08000 )
+	ROM_LOAD( "wl_23.13c",  0x00000, 0x08000, CRC(f6b3d060) SHA1(0ed2e2f64ba53ba2c371b66ab1e52e40b16d8baf) )	// == wl_09.12b
+	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "wl_30.12e",    0x00000, 0x20000, CRC(bde23d4d) SHA1(d1fee2f99c858dfb07edcd600da491c7b656afe0) )	// == wl_18.11c
-	ROM_LOAD( "wl_31.13e",    0x20000, 0x20000, CRC(683898f5) SHA1(316a77b663d78c8b9ff6d85756cb05aaaeef4003) )	// == wl_19.12c
+	ROM_LOAD( "wl_30.12e",  0x00000, 0x20000, CRC(bde23d4d) SHA1(d1fee2f99c858dfb07edcd600da491c7b656afe0) )	// == wl_18.11c
+	ROM_LOAD( "wl_31.13e",  0x20000, 0x20000, CRC(683898f5) SHA1(316a77b663d78c8b9ff6d85756cb05aaaeef4003) )	// == wl_19.12c
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
 	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
@@ -5519,17 +5532,17 @@
 	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
-/* B-Board 90629B */
+/* B-Board 90629B-2 */
 ROM_START( sf2ua )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_BYTE( "sf2u.30a",      0x00000, 0x20000, CRC(08beb861) SHA1(d47f16d0d692dc6405df0aecd7d9fc3f9718c0d1) )
-	ROM_LOAD16_BYTE( "sf2u.37a",      0x00001, 0x20000, CRC(b7638d69) SHA1(b615a2e0e8772462fd875b2e8d2ccba82a8b3c47) )
-	ROM_LOAD16_BYTE( "sf2u.31a",      0x40000, 0x20000, CRC(0d5394e0) SHA1(e1d88ff3669f1dbe1e3fbdf8aa9e2c63adbbcb48) )
-	ROM_LOAD16_BYTE( "sf2u.38a",      0x40001, 0x20000, CRC(42d6a79e) SHA1(5f1e2c176d065325883a60767d05b1a542372b6a) )
-	ROM_LOAD16_BYTE( "sf2u.28a",      0x80000, 0x20000, CRC(387a175c) SHA1(2635bb82758cf217cee63b254a537b02275a6838) )
-	ROM_LOAD16_BYTE( "sf2u.35a",      0x80001, 0x20000, CRC(a1a5adcc) SHA1(47874e6d403256d828474b29e3d93c92efd9e1ce) )
-	ROM_LOAD16_BYTE( "sf2_29a.bin",   0xc0000, 0x20000, CRC(bb4af315) SHA1(75f0827f4f7e9f292add46467f8d4fe19b2514c9) )
-	ROM_LOAD16_BYTE( "sf2_36a.bin",   0xc0001, 0x20000, CRC(c02a13eb) SHA1(b807cc495bff3f95d03b061fc629c95f965cb6d8) )
+	ROM_LOAD16_BYTE( "sf2u_30a.11e", 0x00000, 0x20000, CRC(08beb861) SHA1(d47f16d0d692dc6405df0aecd7d9fc3f9718c0d1) )
+	ROM_LOAD16_BYTE( "sf2u_37a.11f", 0x00001, 0x20000, CRC(b7638d69) SHA1(b615a2e0e8772462fd875b2e8d2ccba82a8b3c47) )
+	ROM_LOAD16_BYTE( "sf2u_31a.12e", 0x40000, 0x20000, CRC(0d5394e0) SHA1(e1d88ff3669f1dbe1e3fbdf8aa9e2c63adbbcb48) )
+	ROM_LOAD16_BYTE( "sf2u_38a.12f", 0x40001, 0x20000, CRC(42d6a79e) SHA1(5f1e2c176d065325883a60767d05b1a542372b6a) )
+	ROM_LOAD16_BYTE( "sf2u_28a.9e",  0x80000, 0x20000, CRC(387a175c) SHA1(2635bb82758cf217cee63b254a537b02275a6838) )
+	ROM_LOAD16_BYTE( "sf2u_35a.9f",  0x80001, 0x20000, CRC(a1a5adcc) SHA1(47874e6d403256d828474b29e3d93c92efd9e1ce) )
+	ROM_LOAD16_BYTE( "sf2_29b.10e",  0xc0000, 0x20000, CRC(bb4af315) SHA1(75f0827f4f7e9f292add46467f8d4fe19b2514c9) )
+	ROM_LOAD16_BYTE( "sf2_36b.10f",  0xc0001, 0x20000, CRC(c02a13eb) SHA1(b807cc495bff3f95d03b061fc629c95f965cb6d8) )
 
 	ROM_REGION( 0x600000, "gfx", 0 )
 	ROMX_LOAD( "sf2-5m.4a",  0x000000, 0x80000, CRC(22c9cc8e) SHA1(b9194fb337b30502c1c9501cd6c64ae4035544d4) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "2" socket
@@ -5546,12 +5559,12 @@
 	ROMX_LOAD( "sf2-11m.5d", 0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "22" socket
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "sf2_09.bin",    0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )
-	ROM_CONTINUE(              0x10000, 0x08000 )
+	ROM_LOAD( "sf2_9.12a",   0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )	// == sf2_09.12a
+	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "sf2_18.bin",    0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
-	ROM_LOAD( "sf2_19.bin",    0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+	ROM_LOAD( "sf2_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
+	ROM_LOAD( "sf2_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
 	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
@@ -5793,7 +5806,7 @@
 	ROMX_LOAD( "sf2-11m.5d", 0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "22" socket
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "sf2_09.12a",  0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )
+	ROM_LOAD( "sf2_9.12a",  0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) ) // == sf2_09.12a
 	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
@@ -5971,8 +5984,8 @@
 	ROM_LOAD16_BYTE( "sf2j_38c.12f", 0x40001, 0x20000, CRC(8210fc0e) SHA1(7d6cfb99afa89d0e6e991d9f7c1808b740def125) )
 	ROM_LOAD16_BYTE( "sf2j_28c.9e",  0x80000, 0x20000, CRC(6eddd5e8) SHA1(62bd1c2fc0321809421c9a592f691b5b1a1d8807) )
 	ROM_LOAD16_BYTE( "sf2j_35c.9f",  0x80001, 0x20000, CRC(6bcb404c) SHA1(b5f24556c633c521aadd94e016d78db6922e3dfa) )
-	ROM_LOAD16_BYTE( "sf2j_29c.10e", 0xc0000, 0x20000, CRC(bb4af315) SHA1(75f0827f4f7e9f292add46467f8d4fe19b2514c9) )
-	ROM_LOAD16_BYTE( "sf2j_36c.10f", 0xc0001, 0x20000, CRC(c02a13eb) SHA1(b807cc495bff3f95d03b061fc629c95f965cb6d8) )
+	ROM_LOAD16_BYTE( "sf2j_29c.10e", 0xc0000, 0x20000, CRC(bb4af315) SHA1(75f0827f4f7e9f292add46467f8d4fe19b2514c9) )	// == sf2_29b.10e
+	ROM_LOAD16_BYTE( "sf2j_36c.10f", 0xc0001, 0x20000, CRC(c02a13eb) SHA1(b807cc495bff3f95d03b061fc629c95f965cb6d8) )	// == sf2_36b.10f
 
 	ROM_REGION( 0x600000, "gfx", 0 )
 	ROMX_LOAD( "sf2_06.8a",  0x000000, 0x80000, CRC(22c9cc8e) SHA1(b9194fb337b30502c1c9501cd6c64ae4035544d4) , ROM_GROUPWORD | ROM_SKIP(6) )	// == sf2-5m.4a
@@ -5989,12 +6002,12 @@
 	ROMX_LOAD( "sf2_26.9d",  0x400006, 0x80000, CRC(0627c831) SHA1(f9a92d614e8877d648449de2612fc8b43c85e4c2) , ROM_GROUPWORD | ROM_SKIP(6) )	// == sf2-11m.5d
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "sf2_09.12a",  0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )
+	ROM_LOAD( "sf2_09.12a",  0x00000, 0x08000, CRC(a4823a1b) SHA1(7b6bf59dfd578bfbbdb64c27988796783442d659) )	// could be sf2j_09.12a
 	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "sf2_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
-	ROM_LOAD( "sf2_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+	ROM_LOAD( "sf2_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )	// could be sf2j_18.11c
+	ROM_LOAD( "sf2_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )	// could be sf2j_19.12c
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
 	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
@@ -6466,11 +6479,11 @@
 /* B-Board 90629B-3 */
 ROM_START( kodj )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_BYTE( "kd30.bin",     0x00000, 0x20000, CRC(ebc788ad) SHA1(f4a297e409fcdbb2c15a13b39a16e4a83e7e060b) )
-	ROM_LOAD16_BYTE( "kd37.bin",     0x00001, 0x20000, CRC(e55c3529) SHA1(a5254895499a53b4fbaac6fd50464b9e08175b8d) )
-	ROM_LOAD16_BYTE( "kd31.bin",     0x40000, 0x20000, CRC(c710d722) SHA1(a2e9b84d3e7d835a910ab9f584bdc64c2559995a) )
-	ROM_LOAD16_BYTE( "kd38.bin",     0x40001, 0x20000, CRC(57d6ed3a) SHA1(a47da5068723c8e16ed458fbfa3e3db57b32d87d) )
-	ROM_LOAD16_WORD_SWAP("kd33.bin", 0x80000, 0x80000, CRC(9bd7ad4b) SHA1(7bece5d408fd13116bd5518014b632ecc9a2feaa) )
+	ROM_LOAD16_BYTE( "kdj_30a.11e",  0x00000, 0x20000, CRC(ebc788ad) SHA1(f4a297e409fcdbb2c15a13b39a16e4a83e7e060b) )
+	ROM_LOAD16_BYTE( "kdj_37a.11f",  0x00001, 0x20000, CRC(e55c3529) SHA1(a5254895499a53b4fbaac6fd50464b9e08175b8d) )
+	ROM_LOAD16_BYTE( "kdj_31a.12e",  0x40000, 0x20000, CRC(c710d722) SHA1(a2e9b84d3e7d835a910ab9f584bdc64c2559995a) )
+	ROM_LOAD16_BYTE( "kdj_38a.12f",  0x40001, 0x20000, CRC(57d6ed3a) SHA1(a47da5068723c8e16ed458fbfa3e3db57b32d87d) )
+	ROM_LOAD16_WORD_SWAP("kd_33.6f", 0x80000, 0x80000, CRC(9bd7ad4b) SHA1(7bece5d408fd13116bd5518014b632ecc9a2feaa) )	// incorrect label, could be kdj_33a, kdj_33, kd_33a
 
 	ROM_REGION( 0x400000, "gfx", 0 )
 	ROMX_LOAD( "kd_06.8a",  0x000000, 0x80000, CRC(e45b8701) SHA1(604e39e455e81695ee4f899f102d0bcd789cedd0) , ROM_GROUPWORD | ROM_SKIP(6) )	// == kd-5m.4a
@@ -6483,12 +6496,12 @@
 	ROMX_LOAD( "kd_16.9c",  0x200006, 0x80000, CRC(402b9b4f) SHA1(4c11976976eadf1ad293b31b0a4d047d05032b06) , ROM_GROUPWORD | ROM_SKIP(6) )	// == kd-4m.5c
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "kd09.bin",      0x00000, 0x08000, CRC(bac6ec26) SHA1(6cbb6d55660150ae3f5270e023328275ee1bbf50) )
-	ROM_CONTINUE(              0x10000, 0x08000 )
+	ROM_LOAD( "kd_09.12a",  0x00000, 0x08000, CRC(bac6ec26) SHA1(6cbb6d55660150ae3f5270e023328275ee1bbf50) )	/* different CRC from kod, pcb verified */
+	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "kd18.bin",      0x00000, 0x20000, CRC(4c63181d) SHA1(270f27534a95cb0be3ff3f9ca71c502320d8090b) )
-	ROM_LOAD( "kd19.bin",      0x20000, 0x20000, CRC(92941b80) SHA1(5fa7c2793e6febee54a83042d118ddd4f2b7d127) )
+	ROM_LOAD( "kd_18.18",   0x00000, 0x20000, CRC(4c63181d) SHA1(270f27534a95cb0be3ff3f9ca71c502320d8090b) )	/* different CRC from kod but same label, pcb verified */
+	ROM_LOAD( "kd_19.19",   0x20000, 0x20000, CRC(92941b80) SHA1(5fa7c2793e6febee54a83042d118ddd4f2b7d127) )	/* different CRC from kod but same label, pcb verified */
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
 	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
@@ -6506,6 +6519,76 @@
 	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
+/* B-Board 89625B-1 */
+ROM_START( kodja )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_BYTE( "kdj_36a.12f", 0x00000, 0x20000, CRC(ebc788ad) SHA1(f4a297e409fcdbb2c15a13b39a16e4a83e7e060b) )	// == kdj_30a.11e
+	ROM_LOAD16_BYTE( "kdj_42a.12h", 0x00001, 0x20000, CRC(e55c3529) SHA1(a5254895499a53b4fbaac6fd50464b9e08175b8d) )	// == kdj_37a.11f
+	ROM_LOAD16_BYTE( "kdj_37a.13f", 0x40000, 0x20000, CRC(c710d722) SHA1(a2e9b84d3e7d835a910ab9f584bdc64c2559995a) )	// == kdj_31a.12e
+	ROM_LOAD16_BYTE( "kdj_43a.13h", 0x40001, 0x20000, CRC(57d6ed3a) SHA1(a47da5068723c8e16ed458fbfa3e3db57b32d87d) )	// == kdj_38a.12f
+	ROM_LOAD16_BYTE( "kd_34.10f",   0x80000, 0x20000, CRC(9367bcd9) SHA1(8243b4b9bb9756f3fa726717e19a166cb2f5b50a) )	// == kd_33.6f
+	ROM_LOAD16_BYTE( "kd_40.10h",   0x80001, 0x20000, CRC(4ca6a48a) SHA1(9d440ecd8d2d0e293fecf64ca3915252b94e7aef) )	// == kd_33.6f
+	ROM_LOAD16_BYTE( "kd_35.11f",   0xc0000, 0x20000, CRC(0360fa72) SHA1(274769c8717a874397cf37369e3ef80a682d9ef2) )	// == kd_33.6f
+	ROM_LOAD16_BYTE( "kd_41a.11h",  0xc0001, 0x20000, CRC(95a3cef8) SHA1(9b75c1ed0eafacc230197ffd9b81e0c8f4f2c464) )	// == kd_33.6f
+
+	ROM_REGION( 0x400000, "gfx", 0 )
+	ROMX_LOAD( "kd_9.4b",   0x000000, 0x20000, CRC(401a98e3) SHA1(b762d0f0e38ad33b5135646a107c1d4279c02193) , ROM_SKIP(7) )	// == kd_06.8a
+	ROMX_LOAD( "kd_1.4a",   0x000001, 0x20000, CRC(5894399a) SHA1(ee0bff29d313b4d5a318bc7345cc356d6e7318fc) , ROM_SKIP(7) )	// == kd_06.8a
+	ROMX_LOAD( "kd_13.9b",  0x000002, 0x20000, CRC(b6685131) SHA1(c1fa66cb695cfcb61e8495031ce18e4c6736b561) , ROM_SKIP(7) )	// == kd_08.10a
+	ROMX_LOAD( "kd_5.9a",   0x000003, 0x20000, CRC(c29b9ab3) SHA1(3ffa906d22563c9ad29b9ba4cd22b4ce5605b66a) , ROM_SKIP(7) )	// == kd_08.10a
+	ROMX_LOAD( "kd_24.5e",  0x000004, 0x20000, CRC(97008fdb) SHA1(150a7907f48dede2de0c40f1bea46e95d2e31e9c) , ROM_SKIP(7) )	// == kd_05.7a
+	ROMX_LOAD( "kd_17.5c",  0x000005, 0x20000, CRC(dc9a83d3) SHA1(6ceb5e6b11e7a57933c03fb308e1c6a850cf5ac7) , ROM_SKIP(7) )	// == kd_05.7a
+	ROMX_LOAD( "kd_38.8h",  0x000006, 0x20000, CRC(9c3dd2d1) SHA1(3ab77954fbde45797fcb1c5d8a500b5ec2673e5f) , ROM_SKIP(7) )	// == kd_07.9a
+	ROMX_LOAD( "kd_32.8f",  0x000007, 0x20000, CRC(1b2a802a) SHA1(f9b9e6da6a49aaf7c88b7b806c273b464a584a7b) , ROM_SKIP(7) )	// == kd_07.9a
+	ROMX_LOAD( "kd_10.5b",  0x100000, 0x20000, CRC(e788ae96) SHA1(1c257a4c20842b8750e3ba3cf78adad0bc5e6f2c) , ROM_SKIP(7) )	// == kd_06.8a
+	ROMX_LOAD( "kd_2.5a",   0x100001, 0x20000, CRC(b022e3e3) SHA1(a1e3700638e99677d4ee9aea5a250eb2380413c2) , ROM_SKIP(7) )	// == kd_06.8a
+	ROMX_LOAD( "kd_14.10b", 0x100002, 0x20000, CRC(4840c5ef) SHA1(fcd7ee778ab4519887bd37ced5e04f7aa8748e5e) , ROM_SKIP(7) )	// == kd_08.10a
+	ROMX_LOAD( "kd_6.10a",  0x100003, 0x20000, CRC(519faee4) SHA1(038afb9d2df872a0b45a7a6a43f7bb1389e8539a) , ROM_SKIP(7) )	// == kd_08.10a
+	ROMX_LOAD( "kd_25.7e",  0x100004, 0x20000, CRC(5d0fa853) SHA1(81e69bfac5ad6909d47db0927b7387bd392b4ef3) , ROM_SKIP(7) )	// == kd_05.7a
+	ROMX_LOAD( "kd_18.7c",  0x100005, 0x20000, CRC(6ad3b2bb) SHA1(c8d3bd2ce6305772224b5419301b59b9e78e7d44) , ROM_SKIP(7) )	// == kd_05.7a
+	ROMX_LOAD( "kd_39.9h",  0x100006, 0x20000, CRC(d7920213) SHA1(ac7de3f6c8503e06ae27f7db43bf9884f244bf7a) , ROM_SKIP(7) )	// == kd_07.9a
+	ROMX_LOAD( "kd_33.9f",  0x100007, 0x20000, CRC(65c2bed6) SHA1(932be92a418a2d3960f0b071eb5ffe6dae60d933) , ROM_SKIP(7) )	// == kd_07.9a
+	ROMX_LOAD( "kd_11.7b",  0x200000, 0x20000, CRC(147e3310) SHA1(e371db6c6621d09c43325edf9e3e40777afb830c) , ROM_SKIP(7) )	// == kd_15.8c
+	ROMX_LOAD( "kd_3.7a",   0x200001, 0x20000, CRC(5d18bc83) SHA1(49191e1073cdfb32272e6daeddedc4b309cf9fe6) , ROM_SKIP(7) )	// == kd_15.8c
+	ROMX_LOAD( "kd_15.11b", 0x200002, 0x20000, CRC(57359746) SHA1(2f83b77e6ebbceffab10653018a1b54a91d39a3f) , ROM_SKIP(7) )	// == kd_17.10c
+	ROMX_LOAD( "kd_7.11a",  0x200003, 0x20000, CRC(7fe03079) SHA1(be3be96d63a53cd8b6dc67eadc718c4b3b182123) , ROM_SKIP(7) )	// == kd_17.10c
+	ROMX_LOAD( "kd_26.8e",  0x200004, 0x20000, CRC(57e5fab5) SHA1(e665ab581372b48b6a7a494fd65ed6c807b5c00a) , ROM_SKIP(7) )	// == kd_14.7c
+	ROMX_LOAD( "kd_19.8c",  0x200005, 0x20000, CRC(b1f30f7c) SHA1(80308091a0af6ca46011a9174838c4d9dbeb96ee) , ROM_SKIP(7) )	// == kd_14.7c
+	ROMX_LOAD( "kd_28.10e", 0x200006, 0x20000, CRC(3a424135) SHA1(05d77253f454d69553a39a5dca0798f6ccea6da0) , ROM_SKIP(7) )	// == kd_16.9c
+	ROMX_LOAD( "kd_21.10c", 0x200007, 0x20000, CRC(ce10d2c3) SHA1(b694325b370d451cb3bcfe7d753c53ef68b83276) , ROM_SKIP(7) )	// == kd_16.9c
+	ROMX_LOAD( "kd_12.8b",  0x300000, 0x20000, CRC(a6042aa2) SHA1(daa4e52574b53d125414401ad0fca6eea36abe64) , ROM_SKIP(7) )	// == kd_15.8c
+	ROMX_LOAD( "kd_4.8a",   0x300001, 0x20000, CRC(0ce0ba30) SHA1(a19049b5fc58921452bf7b69d2d86d0faa5362bf) , ROM_SKIP(7) )	// == kd_15.8c
+	ROMX_LOAD( "kd_16.12b", 0x300002, 0x20000, CRC(63dcb7e0) SHA1(1524321f31813452aabfef133fb64fd0cef165cf) , ROM_SKIP(7) )	// == kd_17.10c
+	ROMX_LOAD( "kd_8.12a",  0x300003, 0x20000, CRC(c69b77ae) SHA1(31cacace828d4e376347ecd896f3454f79285a8b) , ROM_SKIP(7) )	// == kd_17.10c
+	ROMX_LOAD( "kd_27.9e",  0x300004, 0x20000, CRC(40d7bfed) SHA1(924d3f981d85434d2a22d4ede45131720d7521c0) , ROM_SKIP(7) )	// == kd_14.7c
+	ROMX_LOAD( "kd_20.9c",  0x300005, 0x20000, CRC(01c1f399) SHA1(ea25d4efc9e538ee8ed09acb6e467c5b444bf728) , ROM_SKIP(7) )	// == kd_14.7c
+	ROMX_LOAD( "kd_29.11e", 0x300006, 0x20000, CRC(a1eeac03) SHA1(fdec33ec0becc4badf89c9019f3217c22e54e842) , ROM_SKIP(7) )	// == kd_16.9c
+	ROMX_LOAD( "kd_22.11c", 0x300007, 0x20000, CRC(5ade98eb) SHA1(5d2474864bf0e41e89fe44c69025101b8ef2b482) , ROM_SKIP(7) )	// == kd_16.9c
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "kd_23.13b",  0x00000, 0x08000, CRC(bac6ec26) SHA1(6cbb6d55660150ae3f5270e023328275ee1bbf50) )	// == kd_09.12a
+	ROM_CONTINUE(           0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "kd_30.12c",  0x00000, 0x20000, CRC(4c63181d) SHA1(270f27534a95cb0be3ff3f9ca71c502320d8090b) )	// == kd_18.18
+	ROM_LOAD( "kd_31.13c",  0x20000, 0x20000, CRC(92941b80) SHA1(5fa7c2793e6febee54a83042d118ddd4f2b7d127) )	// == kd_19.19
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "kd22b.1a",     0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "iob1.12e",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
 /* B-Board 91635B-2 */
 ROM_START( captcomm )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
@@ -6785,7 +6868,7 @@
 	ROM_LOAD16_WORD_SWAP( "kr_23e.8f", 0x00000, 0x80000, CRC(1b3997eb) SHA1(724b68eff319fcdf0dd3bc1eb6662996c1f6ecd9) )
 	ROM_LOAD16_WORD_SWAP( "kr_22.7f",  0x80000, 0x80000, CRC(d0b671a9) SHA1(9865472c5fc3f617345e23b5de5a9ba177945b5a) )
 
-	ROM_REGION( 0x400000, "gfx", 0 ) /* MASK roms */
+	ROM_REGION( 0x400000, "gfx", 0 )
 	ROMX_LOAD( "kr-5m.3a",  0x000000, 0x80000, CRC(9e36c1a4) SHA1(772daae74e119371dfb76fde9775bda78a8ba125) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "1" socket
 	ROMX_LOAD( "kr-7m.5a",  0x000002, 0x80000, CRC(c5832cae) SHA1(a188cf401cd3a2909b377d3059f14d22ec3b0643) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "3" socket
 	ROMX_LOAD( "kr-1m.4a",  0x000004, 0x80000, CRC(f095be2d) SHA1(0427d1574062f277a9d04440019d5638b05de561) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "2" socket
@@ -6826,7 +6909,7 @@
 	ROM_LOAD16_WORD_SWAP( "kr_23u.8f", 0x00000, 0x80000, CRC(252bc2ba) SHA1(4f4901c253bd64bbe68ea01994ae663fe2ccd056) )
 	ROM_LOAD16_WORD_SWAP( "kr_22.7f",  0x80000, 0x80000, CRC(d0b671a9) SHA1(9865472c5fc3f617345e23b5de5a9ba177945b5a) )
 
-	ROM_REGION( 0x400000, "gfx", 0 ) /* MASK roms */
+	ROM_REGION( 0x400000, "gfx", 0 )
 	ROMX_LOAD( "kr-5m.3a",  0x000000, 0x80000, CRC(9e36c1a4) SHA1(772daae74e119371dfb76fde9775bda78a8ba125) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "1" socket
 	ROMX_LOAD( "kr-7m.5a",  0x000002, 0x80000, CRC(c5832cae) SHA1(a188cf401cd3a2909b377d3059f14d22ec3b0643) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "3" socket
 	ROMX_LOAD( "kr-1m.4a",  0x000004, 0x80000, CRC(f095be2d) SHA1(0427d1574062f277a9d04440019d5638b05de561) , ROM_GROUPWORD | ROM_SKIP(6) )	// in "2" socket
@@ -6867,7 +6950,7 @@
 	ROM_LOAD16_WORD_SWAP( "kr_23j.8f", 0x00000, 0x80000, CRC(eae7417f) SHA1(2ec808265a9a231922e2397d7e8f3c3841a90859) )
 	ROM_LOAD16_WORD_SWAP( "kr_22.7f",  0x80000, 0x80000, CRC(d0b671a9) SHA1(9865472c5fc3f617345e23b5de5a9ba177945b5a) )
 
-	ROM_REGION( 0x400000, "gfx", 0 ) /* 27C4096 style EPROMs */
+	ROM_REGION( 0x400000, "gfx", 0 )
 	ROMX_LOAD( "kr_01.3a",  0x000000, 0x80000, CRC(9e36c1a4) SHA1(772daae74e119371dfb76fde9775bda78a8ba125) , ROM_GROUPWORD | ROM_SKIP(6) )	// == kr-5m.3a
 	ROMX_LOAD( "kr_02.4a",  0x000002, 0x80000, CRC(c5832cae) SHA1(a188cf401cd3a2909b377d3059f14d22ec3b0643) , ROM_GROUPWORD | ROM_SKIP(6) )	// == kr-7m.5a
 	ROMX_LOAD( "kr_03.5a",  0x000004, 0x80000, CRC(f095be2d) SHA1(0427d1574062f277a9d04440019d5638b05de561) , ROM_GROUPWORD | ROM_SKIP(6) )	// == kr-1m.4a
@@ -6902,6 +6985,76 @@
 	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
+/* B-Board 89625B-1 */
+ROM_START( knightsja )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_BYTE( "krj_36.12f", 0x00000, 0x20000, CRC(ad3d1a8e) SHA1(327f9e818f1500836fc549afeffbb2a3c5aafe8c) )	// == kr_23j.8f
+	ROM_LOAD16_BYTE( "krj_42.12h", 0x00001, 0x20000, CRC(e694a491) SHA1(5a4d27c879c10032c49880019501de3e45ab1b35) )	// == kr_23j.8f
+	ROM_LOAD16_BYTE( "krj_37.13f", 0x40000, 0x20000, CRC(85596094) SHA1(74ad294de63aa6b60aa8b885c45c3d41a07ce19a) )	// == kr_23j.8f
+	ROM_LOAD16_BYTE( "krj_43.13h", 0x40001, 0x20000, CRC(9198bf8f) SHA1(aa3610600286ab25ce81705ea1319d42e7cc7f6c) )	// == kr_23j.8f
+	ROM_LOAD16_BYTE( "kr_34.10f",  0x80000, 0x20000, CRC(fe6eb08d) SHA1(a67ca33895ff7f41e8521ff7b39e629048d04d30) )	// == kr_22.7f
+	ROM_LOAD16_BYTE( "kr_40.10h",  0x80001, 0x20000, CRC(1172806d) SHA1(5ad08bf9bada036d89a55f5a542ee1db22df45b2) )	// == kr_22.7f
+	ROM_LOAD16_BYTE( "kr_35.11f",  0xc0000, 0x20000, CRC(f854b020) SHA1(3d8bd0ab5e0fa2da3c868b591edff5c66f1f08ed) )	// == kr_22.7f
+	ROM_LOAD16_BYTE( "kr_41.11h",  0xc0001, 0x20000, CRC(eb52e78d) SHA1(b9462c9d97848a6dc4d55475053824df8c9e7f02) )	// == kr_22.7f
+
+	ROM_REGION( 0x400000, "gfx", 0 )
+	ROMX_LOAD( "kr_09.4b",  0x000000, 0x20000, CRC(08b76e10) SHA1(b18833c4794ef59f8eaf7aef4d62790c3fec9d4d) , ROM_SKIP(7) )	// == kr_01.3a
+	ROMX_LOAD( "kr_01.4a",  0x000001, 0x20000, CRC(40cecf5c) SHA1(a628199e1808664c403d0de183d1c6ae01670c57) , ROM_SKIP(7) )	// == kr_01.3a
+	ROMX_LOAD( "kr_13.9b",  0x000002, 0x20000, CRC(435aaa03) SHA1(60af266dccab12220d7efce68887b64826aba37d) , ROM_SKIP(7) )	// == kr_02.4a
+	ROMX_LOAD( "kr_05.9a",  0x000003, 0x20000, CRC(5b8a615b) SHA1(42aebdb7f338eac9a29380cb0b7553f0d3eaac04) , ROM_SKIP(7) )	// == kr_02.4a
+	ROMX_LOAD( "kr_24.5e",  0x000004, 0x20000, CRC(de65153e) SHA1(f28fcde0d08634d036d07c2a699026007d19718f) , ROM_SKIP(7) )	// == kr_03.5a
+	ROMX_LOAD( "kr_17.5c",  0x000005, 0x20000, CRC(b171c968) SHA1(cdbd7b0dc9fd2f3f027796d8f5cabf0a92a11941) , ROM_SKIP(7) )	// == kr_03.5a
+	ROMX_LOAD( "kr_38.8h",  0x000006, 0x20000, CRC(f4466bf4) SHA1(86e1ffc354b189504ca8f96143a62344a530d267) , ROM_SKIP(7) )	// == kr_04.6a
+	ROMX_LOAD( "kr_32.8f",  0x000007, 0x20000, CRC(87380ddd) SHA1(01e864060adcdafad987c5758db593525faed589) , ROM_SKIP(7) )	// == kr_04.6a
+	ROMX_LOAD( "kr_10.5b",  0x100000, 0x20000, CRC(37006d66) SHA1(0efec364ed5b0e121023bc3424d51241a4b208e0) , ROM_SKIP(7) )	// == kr_01.3a
+	ROMX_LOAD( "kr_02.5a",  0x100001, 0x20000, CRC(b54612e3) SHA1(1d33cf99fdaf3bf5c8d212d1a7c71f085c6c2cd4) , ROM_SKIP(7) )	// == kr_01.3a
+	ROMX_LOAD( "kr_14.10b", 0x100002, 0x20000, CRC(0ae88766) SHA1(5e3954b51b030d6e7cabd8f94cb849e963cc7d52) , ROM_SKIP(7) )	// == kr_02.4a
+	ROMX_LOAD( "kr_06.10a", 0x100003, 0x20000, CRC(ecb1a09a) SHA1(bbd96260774f52e50377ad020fc94d1b120f0a37) , ROM_SKIP(7) )	// == kr_02.4a
+	ROMX_LOAD( "kr_25.7e",  0x100004, 0x20000, CRC(9aace189) SHA1(95332a14dbe9d24a7e294a26530913b8cb5237f2) , ROM_SKIP(7) )	// == kr_03.5a
+	ROMX_LOAD( "kr_18.7c",  0x100005, 0x20000, CRC(09fa14a5) SHA1(36e7412a317d5f8b528d914d7e6c3c1872eb8533) , ROM_SKIP(7) )	// == kr_03.5a
+	ROMX_LOAD( "kr_39.9h",  0x100006, 0x20000, CRC(fd8a9aeb) SHA1(a38ea74de95a78fc72c6ad165157e4c22aaa5aed) , ROM_SKIP(7) )	// == kr_04.6a
+	ROMX_LOAD( "kr_33.9f",  0x100007, 0x20000, CRC(11803e95) SHA1(71603ba4a85967dd434d8499738014a9227d1d26) , ROM_SKIP(7) )	// == kr_04.6a
+	ROMX_LOAD( "kr_11.7b",  0x200000, 0x20000, CRC(a967ceb3) SHA1(43cdc0e0114f7ccedc7db5cd49b9041ed1a2614f) , ROM_SKIP(7) )	// == kr_05.7a
+	ROMX_LOAD( "kr_03.7a",  0x200001, 0x20000, CRC(ea10db07) SHA1(e537f3983ac32abcef06fa45afe51f82c87bfa86) , ROM_SKIP(7) )	// == kr_05.7a
+	ROMX_LOAD( "kr_15.11b", 0x200002, 0x20000, CRC(8140b83b) SHA1(e9cec517d84aa688d60f4201bcee00dbcdd44798) , ROM_SKIP(7) )	// == kr_06.8a
+	ROMX_LOAD( "kr_07.11a", 0x200003, 0x20000, CRC(6af10648) SHA1(b1d6c908496b1197e23571f5230f017502d5018c) , ROM_SKIP(7) )	// == kr_06.8a
+	ROMX_LOAD( "kr_26.8e",  0x200004, 0x20000, CRC(8865d86b) SHA1(a79b528d2f94ee350a39eb59860189809267cfad) , ROM_SKIP(7) )	// == kr_07.9a
+	ROMX_LOAD( "kr_19.8c",  0x200005, 0x20000, CRC(029f4abe) SHA1(e0f02d18e2a51eb02cabe507fbe77031ee3e67e7) , ROM_SKIP(7) )	// == kr_07.9a
+	ROMX_LOAD( "kr_28.10e", 0x200006, 0x20000, CRC(5f84f92f) SHA1(77b254e8159024490497533073fe302a82531835) , ROM_SKIP(7) )	// == kr_08.10a
+	ROMX_LOAD( "kr_21.10c", 0x200007, 0x20000, CRC(01b35065) SHA1(8a98860ec453ac88a3c0fc19c117bd4131d0c97c) , ROM_SKIP(7) )	// == kr_08.10a
+	ROMX_LOAD( "kr_12.8b",  0x300000, 0x20000, CRC(03d945b1) SHA1(88588891422247e6ab42f35a1b91a5801b8fd5b0) , ROM_SKIP(7) )	// == kr_05.7a
+	ROMX_LOAD( "kr_04.8a",  0x300001, 0x20000, CRC(e30c8388) SHA1(aa519f298f4156b339eb81767ca585e62dc9f4b5) , ROM_SKIP(7) )	// == kr_05.7a
+	ROMX_LOAD( "kr_16.12b", 0x300002, 0x20000, CRC(40c39d1b) SHA1(578d081f5e1bbfdc30b286cdd5165474b3ed79f7) , ROM_SKIP(7) )	// == kr_06.8a
+	ROMX_LOAD( "kr_08.12a", 0x300003, 0x20000, CRC(d310c9e8) SHA1(e23a4b318e7d3d6ea3bc6dd4509f49cd656d3d63) , ROM_SKIP(7) )	// == kr_06.8a
+	ROMX_LOAD( "kr_27.9e",  0x300004, 0x20000, CRC(3e041444) SHA1(7f84158bf2466625ff50befed7e3008b8fe09f70) , ROM_SKIP(7) )	// == kr_07.9a
+	ROMX_LOAD( "kr_20.9c",  0x300005, 0x20000, CRC(bd4bffb8) SHA1(b8f1162427a46ca9d2833390edc5723d28817a08) , ROM_SKIP(7) )	// == kr_07.9a
+	ROMX_LOAD( "kr_29.11e", 0x300006, 0x20000, CRC(1387a076) SHA1(5fe32ee8e8557c5bc6c865b2054f3c6c2a1eae7d) , ROM_SKIP(7) )	// == kr_08.10a
+	ROMX_LOAD( "kr_22.11c", 0x300007, 0x20000, CRC(fd351922) SHA1(7e08a9b23bf524d5fd566d81745aee1cd3a0f026) , ROM_SKIP(7) )	// == kr_08.10a
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "kr_23.13b",  0x00000, 0x08000, CRC(5e44d9ee) SHA1(47a7503321be8d52b5c44af838e3bb82ee15a415) )	// == kr_09.12a
+	ROM_CONTINUE(           0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "kr_30.12c",  0x00000, 0x20000, CRC(da69d15f) SHA1(9616207e693bae85705f786cef60b9f6951b5067) )	// == kr_18.11c
+	ROM_LOAD( "kr_31.13c",  0x20000, 0x20000, CRC(bfc654e9) SHA1(01b3d92e4dedf55ea3933d387c7ddb9ba2549773) )	// == kr_19.12c
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "kr22b.1a",     0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "lwio.12e",     0x0000, 0x0117, CRC(ad52b90c) SHA1(f0fd6aeea515ee449320fe15684e6b3ab7f97bf4) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
 /* bootleg */
 /* FIXME - GFX ROMs are wrong, copied from the other version */
 /* ROMs missing are KA.IC91 KB.IC92 KC.IC93 KD.IC94 */
@@ -6929,6 +7082,52 @@
 /* B-Board 91635B-2 */
 ROM_START( sf2ce )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "s92e_23b.8f", 0x000000, 0x80000, CRC(0aaa1a3a) SHA1(774a2b52f7c1876c0e10d8d57a0850ad2d016cf6) )
+	ROM_LOAD16_WORD_SWAP( "s92_22b.7f",  0x080000, 0x80000, CRC(2bbe15ed) SHA1(a8e2edef62fa99c5ef701b28bfb6bc42f3af183d) )
+	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
+
+	ROM_REGION( 0x600000, "gfx", 0 )
+	ROMX_LOAD( "s92-1m.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-3m.5a",  0x000002, 0x80000, CRC(840289ec) SHA1(2fb42a242f60ba7e74009b5a90eb26e035ba1e82) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-2m.4a",  0x000004, 0x80000, CRC(cdb5f027) SHA1(4c7d944fef200fdfcaf57758b901b5511188ed2e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-4m.6a",  0x000006, 0x80000, CRC(e2799472) SHA1(27d3796429338d82a8de246a0ea06dd487a87768) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-5m.7a",  0x200000, 0x80000, CRC(ba8a2761) SHA1(4b696d66c51611e43522bed752654314e76d33b6) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-7m.9a",  0x200002, 0x80000, CRC(e584bfb5) SHA1(ebdf1f5e2638eed3a65dda82b1ed9151a355f4c9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-6m.8a",  0x200004, 0x80000, CRC(21e3f87d) SHA1(4a4961bb68c3a1ce15f9d393d9c03ecb2466cc29) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-8m.10a", 0x200006, 0x80000, CRC(befc47df) SHA1(520390420da3a0271ba90b0a933e65143265e5cf) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-10m.3c", 0x400000, 0x80000, CRC(960687d5) SHA1(2868c31121b1c7564e9767b9a19cdbf655c7ed1d) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-12m.5c", 0x400002, 0x80000, CRC(978ecd18) SHA1(648a59706b93c84b4206a968ecbdc3e834c476f6) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-11m.4c", 0x400004, 0x80000, CRC(d6ec9a0a) SHA1(ed6143f8737013b6ef1684e37c05e037e7a80dae) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "s92-13m.6c", 0x400006, 0x80000, CRC(ed2c67f6) SHA1(0083c0ffaf6fe7659ff0cf822be4346cd6e61329) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "s92_09.11a",  0x00000, 0x08000, CRC(08f6b60e) SHA1(8258fcaca4ac419312531eec67079b97f471179c) )
+	ROM_CONTINUE(            0x10000, 0x08000 )
+
+	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
+	ROM_LOAD( "s92_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
+	ROM_LOAD( "s92_19.12c",  0x20000, 0x20000, CRC(beade53f) SHA1(277c397dc12752719ec6b47d2224750bd1c07f79) )
+
+	ROM_REGION( 0x0200, "aboardplds", 0 )
+	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
+	ROM_LOAD( "ioa1",         0x0000, 0x0117, CRC(59c7ee3b) SHA1(fbb887c5b4f5cb8df77cec710eaac2985bc482a6) )
+	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
+	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
+	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "s9263b.1a",    0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "iob1.12d",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "bprg1.11d",    0x0000, 0x0117, CRC(31793da7) SHA1(400fa7ac517421c978c1ee7773c30b9ed0c5d3f3) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
+ROM_END
+
+/* B-Board 91635B-2 */
+ROM_START( sf2ceea )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "s92e_23a.8f", 0x000000, 0x80000, CRC(3f846b74) SHA1(c8d7a01b626771870123f1663a01a81f9c8fe582) )
 	ROM_LOAD16_WORD_SWAP( "s92_22a.7f",  0x080000, 0x80000, CRC(99f1cca4) SHA1(64111eba81d743fc3fd51d7a89cd0b2eefcc900d) )
 	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
@@ -7115,7 +7314,7 @@
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "s92j_23b.8f", 0x000000, 0x80000, CRC(140876c5) SHA1(304630e6d8bae9f8d29090e05f7e013c7dafe9cc) )
 	ROM_LOAD16_WORD_SWAP( "s92j_22b.7f", 0x080000, 0x80000, CRC(2fbb3bfe) SHA1(e364564a12022730c2c0d0e8fd435e2c30ef9410) )
-	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )
+	ROM_LOAD16_WORD_SWAP( "s92_21a.6f",  0x100000, 0x80000, CRC(925a7877) SHA1(1960dca35f0ca6f2b399a9fccfbc0132ac6425d1) )	// could be s92j_21a.6f
 
 	ROM_REGION( 0x600000, "gfx", 0 )
 	ROMX_LOAD( "s92_01.3a",  0x000000, 0x80000, CRC(03b0d852) SHA1(f370f25c96ad2b94f8c53d6b7139100285a25bef) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-1m.3a
@@ -7132,8 +7331,8 @@
 	ROMX_LOAD( "s92_13.6c",  0x400006, 0x80000, CRC(ed2c67f6) SHA1(0083c0ffaf6fe7659ff0cf822be4346cd6e61329) , ROM_GROUPWORD | ROM_SKIP(6) )	// == s92-13m.6c
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "s92_09.11a",    0x00000, 0x08000, CRC(08f6b60e) SHA1(8258fcaca4ac419312531eec67079b97f471179c) )
-	ROM_CONTINUE(              0x10000, 0x08000 )
+	ROM_LOAD( "s92_09.12a",  0x00000, 0x08000, CRC(08f6b60e) SHA1(8258fcaca4ac419312531eec67079b97f471179c) )	// == s92_09.11a
+	ROM_CONTINUE(            0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
 	ROM_LOAD( "s92_18.11c",  0x00000, 0x20000, CRC(7f162009) SHA1(346bf42992b4c36c593e21901e22c87ae4a7d86d) )
@@ -7978,25 +8177,25 @@
 	ROM_LOAD( "ioc1.ic1",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
 ROM_END
 
-/* FIXME B-Board uncertain but should be 91634B from the program ROM names */
+/* B-Board 91634B-2 */
 ROM_START( qadj )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_WORD_SWAP( "qad23a.bin",   0x00000, 0x80000, CRC(4d3553de) SHA1(07eabcb02fbbe11397ce91405a2e6bb53b3d5d4f) )
-	ROM_LOAD16_WORD_SWAP( "qad22a.bin",   0x80000, 0x80000, CRC(3191ddd0) SHA1(2806021a5dc809ca43692bbe9c4f5ef690c9ac14) )
+	ROM_LOAD16_WORD_SWAP( "qad_23a.8f", 0x00000, 0x80000, CRC(4d3553de) SHA1(07eabcb02fbbe11397ce91405a2e6bb53b3d5d4f) )
+	ROM_LOAD16_WORD_SWAP( "qad_22a.7f", 0x80000, 0x80000, CRC(3191ddd0) SHA1(2806021a5dc809ca43692bbe9c4f5ef690c9ac14) )
 
 	ROM_REGION( 0x200000, "gfx", 0 )
-	ROMX_LOAD( "qad01.bin",   0x000000, 0x80000, CRC(9d853b57) SHA1(380b41a3eced1f4a5523999b63d80b7593a85eca) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "qad02.bin",   0x000002, 0x80000, CRC(b35976c4) SHA1(3e128db89186c4e88c46be9da310b755ae5b816c) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "qad03.bin",   0x000004, 0x80000, CRC(cea4ca8c) SHA1(5c50758647419129f2b35ab4dc712796fa801c12) , ROM_GROUPWORD | ROM_SKIP(6) )
-	ROMX_LOAD( "qad04.bin",   0x000006, 0x80000, CRC(41b74d1b) SHA1(78aa2faec512c505f98b4e8053fc161941d41773) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "qad_01.3a", 0x000000, 0x80000, CRC(9d853b57) SHA1(380b41a3eced1f4a5523999b63d80b7593a85eca) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "qad_02.4a", 0x000002, 0x80000, CRC(b35976c4) SHA1(3e128db89186c4e88c46be9da310b755ae5b816c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "qad_03.5a", 0x000004, 0x80000, CRC(cea4ca8c) SHA1(5c50758647419129f2b35ab4dc712796fa801c12) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "qad_04.6a", 0x000006, 0x80000, CRC(41b74d1b) SHA1(78aa2faec512c505f98b4e8053fc161941d41773) , ROM_GROUPWORD | ROM_SKIP(6) )
 
 	ROM_REGION( 0x18000, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
-	ROM_LOAD( "qad09.bin",     0x00000, 0x08000, CRC(733161cc) SHA1(dfb8c5a1037bd3b2712fb327122ec39ceb993b8d) )
-	ROM_CONTINUE(              0x10000, 0x08000 )
+	ROM_LOAD( "qad_09.12a", 0x00000, 0x08000, CRC(733161cc) SHA1(dfb8c5a1037bd3b2712fb327122ec39ceb993b8d) )
+	ROM_CONTINUE(           0x10000, 0x08000 )
 
 	ROM_REGION( 0x40000, "oki", 0 )	/* Samples */
-	ROM_LOAD( "qad18.bin",     0x00000, 0x20000, CRC(2bfe6f6a) SHA1(b2a98ac034c65b7ac8167431f05f35d4799032ea) )
-	ROM_LOAD( "qad19.bin",     0x20000, 0x20000, CRC(13d3236b) SHA1(785d49de484e9ac6971eaceebebfecb8e58563f6) )
+	ROM_LOAD( "qad_18.11c", 0x00000, 0x20000, CRC(2bfe6f6a) SHA1(b2a98ac034c65b7ac8167431f05f35d4799032ea) )
+	ROM_LOAD( "qad_19.12c", 0x20000, 0x20000, CRC(13d3236b) SHA1(785d49de484e9ac6971eaceebebfecb8e58563f6) )
 
 	ROM_REGION( 0x0200, "aboardplds", 0 )
 	ROM_LOAD( "buf1",         0x0000, 0x0117, CRC(eb122de7) SHA1(b26b5bfe258e3e184f069719f9fd008d6b8f6b9b) )
@@ -8004,6 +8203,15 @@
 	ROM_LOAD( "prg1",         0x0000, 0x0117, CRC(f1129744) SHA1(a5300f301c1a08a7da768f0773fa0fe3f683b237) )
 	ROM_LOAD( "rom1",         0x0000, 0x0117, CRC(41dc73b9) SHA1(7d4c9f1693c821fbf84e32dd6ef62ddf14967845) )
 	ROM_LOAD( "sou1",         0x0000, 0x0117, CRC(84f4b2fe) SHA1(dcc9e86cc36316fe42eace02d6df75d08bc8bb6d) )
+
+	ROM_REGION( 0x0200, "bboardplds", 0 )
+	ROM_LOAD( "qd63b.1a",     0x0000, 0x0117, NO_DUMP )
+	ROM_LOAD( "iob1.12d",     0x0000, 0x0117, CRC(3abc0700) SHA1(973043aa46ec6d5d1db20dc9d5937005a0f9f6ae) )
+	ROM_LOAD( "bprg1.11d",    0x0000, 0x0117, CRC(31793da7) SHA1(400fa7ac517421c978c1ee7773c30b9ed0c5d3f3) )
+
+	ROM_REGION( 0x0200, "cboardplds", 0 )
+	ROM_LOAD( "ioc1.ic7",     0x0000, 0x0117, CRC(0d182081) SHA1(475b3d417785da4bc512cce2b274bb00d4cc6792) )
+	ROM_LOAD( "c632.ic1",     0x0000, 0x0117, CRC(0fbd9270) SHA1(d7e737b20c44d41e29ca94be56114b31934dde81) )
 ROM_END
 
 /* FIXME B-Board uncertain but should be 91635B from the program ROM names */
@@ -9691,7 +9899,7 @@
 GAME( 1990, msword,      0,        cps1_10MHz, msword,     cps1,     ROT0,   "Capcom", "Magic Sword: Heroic Fantasy (World 900725)", GAME_SUPPORTS_SAVE )	// 25.07.1990  "OTHER COUNTRY"
 GAME( 1990, mswordr1,    msword,   cps1_10MHz, msword,     cps1,     ROT0,   "Capcom", "Magic Sword: Heroic Fantasy (World 900623)", GAME_SUPPORTS_SAVE )	// 23.06.1990  "OTHER COUNTRY"
 GAME( 1990, mswordu,     msword,   cps1_10MHz, msword,     cps1,     ROT0,   "Capcom", "Magic Sword: Heroic Fantasy (USA 900725)", GAME_SUPPORTS_SAVE )	// 25.07.1990  "U.S.A."
-GAME( 1990, mswordj,     msword,   cps1_10MHz, msword,     cps1,     ROT0,   "Capcom", "Magic Sword (Japan 900623)", GAME_SUPPORTS_SAVE )				// 23.06.1990  "JAPAN"
+GAME( 1990, mswordj,     msword,   cps1_10MHz, msword,     cps1,     ROT0,   "Capcom", "Magic Sword: Heroic Fantasy (Japan 900623)", GAME_SUPPORTS_SAVE )	// 23.06.1990  "JAPAN"
 GAME( 1990, cawing,      0,        cps1_10MHz, cawing,     cps1,     ROT0,   "Capcom", "Carrier Air Wing (World 901012)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1990, cawingr1,    cawing,   cps1_10MHz, cawing,     cps1,     ROT0,   "Capcom", "Carrier Air Wing (World 901009)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1990, cawingu,     cawing,   cps1_10MHz, cawing,     cps1,     ROT0,   "Capcom", "Carrier Air Wing (USA 901012)", GAME_SUPPORTS_SAVE )
@@ -9700,7 +9908,6 @@
 GAME( 1990, nemoj,       nemo,     cps1_10MHz, nemo,       cps1,     ROT0,   "Capcom", "Nemo (Japan 901120)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2,         0,        cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (World 910522)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1991, sf2eb,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (World 910214)", GAME_SUPPORTS_SAVE )	// "ETC"
-GAME( 1992, sf2ebbl,     sf2,      cps1_10MHz, sf2hack,    sf2hack,  ROT0,   "bootleg", "Street Fighter II: The World Warrior (TAB Austria, bootleg)", GAME_SUPPORTS_SAVE )	// 910214 - based on World version
 GAME( 1991, sf2ua,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910206)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2ub,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910214)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2ud,       sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (USA 910318)", GAME_SUPPORTS_SAVE )
@@ -9711,7 +9918,8 @@
 GAME( 1991, sf2j,        sf2,      cps1_10MHz, sf2j,       cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (Japan 911210)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2ja,       sf2,      cps1_10MHz, sf2j,       cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (Japan 910214)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sf2jc,       sf2,      cps1_10MHz, sf2j,       cps1,     ROT0,   "Capcom", "Street Fighter II: The World Warrior (Japan 910306)", GAME_SUPPORTS_SAVE )
-GAME( 1991, sf2qp1,      sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II: The World Warrior (Quicken Pt-I, bootleg)", GAME_SUPPORTS_SAVE )	// 910214 - based on World version
+GAME( 1992, sf2ebbl,     sf2,      cps1_10MHz, sf2hack,    sf2hack,  ROT0,   "bootleg", "Street Fighter II: The World Warrior (TAB Austria, bootleg)", GAME_SUPPORTS_SAVE )		// 910214 - based on World version
+GAME( 1991, sf2qp1,      sf2,      cps1_10MHz, sf2,        cps1,     ROT0,   "bootleg", "Street Fighter II: The World Warrior (Quicken Pt-I, bootleg)", GAME_SUPPORTS_SAVE )		// 910214 - based on World version
 GAME( 1991, sf2thndr,    sf2,      cps1_10MHz, sf2,        sf2thndr, ROT0,   "bootleg", "Street Fighter II: The World Warrior (Thunder Edition, bootleg)", GAME_SUPPORTS_SAVE )	// 910214 - based on World version
 GAME( 1991, 3wonders,    0,        cps1_10MHz, 3wonders,   cps1,     ROT0,   "Capcom", "Three Wonders (World 910520)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1991, 3wondersu,   3wonders, cps1_10MHz, 3wonders,   cps1,     ROT0,   "Capcom", "Three Wonders (USA 910520)", GAME_SUPPORTS_SAVE )
@@ -9719,7 +9927,8 @@
 GAME( 1991, 3wondersh,   3wonders, cps1_10MHz, 3wonders,   cps1,     ROT0,   "bootleg", "Three Wonders (hack)", GAME_SUPPORTS_SAVE )	// 910520 - based on World version
 GAME( 1991, kod,         0,        cps1_10MHz, kod,        cps1,     ROT0,   "Capcom", "The King of Dragons (World 910711)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1991, kodu,        kod,      cps1_10MHz, kodj,       cps1,     ROT0,   "Capcom", "The King of Dragons (USA 910910)", GAME_SUPPORTS_SAVE )
-GAME( 1991, kodj,        kod,      cps1_10MHz, kodj,       cps1,     ROT0,   "Capcom", "The King of Dragons (Japan 910805)", GAME_SUPPORTS_SAVE )
+GAME( 1991, kodj,        kod,      cps1_10MHz, kodj,       cps1,     ROT0,   "Capcom", "The King of Dragons (Japan 910805, B-Board 90629B-3)", GAME_SUPPORTS_SAVE )
+GAME( 1991, kodja,       kod,      cps1_10MHz, kodj,       cps1,     ROT0,   "Capcom", "The King of Dragons (Japan 910805, B-Board 89625B-1)", GAME_SUPPORTS_SAVE )
 GAME( 1991, captcomm,    0,        cps1_10MHz, captcomm,   cps1,     ROT0,   "Capcom", "Captain Commando (World 911202)", GAME_SUPPORTS_SAVE )	// "OTHER COUNTRY"
 GAME( 1991, captcommr1,  captcomm, cps1_10MHz, captcomm,   cps1,     ROT0,   "Capcom", "Captain Commando (World 911014)", GAME_SUPPORTS_SAVE )	// "OTHER COUNTRY"
 GAME( 1991, captcommu,   captcomm, cps1_10MHz, captcomm,   cps1,     ROT0,   "Capcom", "Captain Commando (USA 910928)", GAME_SUPPORTS_SAVE )
@@ -9728,9 +9937,11 @@
 GAME( 1991, captcommb,   captcomm, cps1_10MHz, captcomm,   cps1,     ROT0,   "bootleg", "Captain Commando (bootleg)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )	// 911014 - based on World version
 GAME( 1991, knights,     0,        cps1_10MHz, knights,    cps1,     ROT0,   "Capcom", "Knights of the Round (World 911127)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1991, knightsu,    knights,  cps1_10MHz, knights,    cps1,     ROT0,   "Capcom", "Knights of the Round (USA 911127)", GAME_SUPPORTS_SAVE )
-GAME( 1991, knightsj,    knights,  cps1_10MHz, knights,    cps1,     ROT0,   "Capcom", "Knights of the Round (Japan 911127)", GAME_SUPPORTS_SAVE )
+GAME( 1991, knightsj,    knights,  cps1_10MHz, knights,    cps1,     ROT0,   "Capcom", "Knights of the Round (Japan 911127, B-Board 91634B-2)", GAME_SUPPORTS_SAVE )
+GAME( 1991, knightsja,   knights,  cps1_10MHz, knights,    cps1,     ROT0,   "Capcom", "Knights of the Round (Japan 911127, B-Board 89625B-1)", GAME_SUPPORTS_SAVE )
 GAME( 1991, knightsb,    knights,  knightsb,   knights,    cps1,     ROT0,   "bootleg", "Knights of the Round (bootleg)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )	// 911127 - based on World version
-GAME( 1992, sf2ce,       0,        cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (World 920313)", GAME_SUPPORTS_SAVE )	// "ETC"
+GAME( 1992, sf2ce,       0,        cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (World 920513)", GAME_SUPPORTS_SAVE )	// "ETC"
+GAME( 1992, sf2ceea,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (World 920313)", GAME_SUPPORTS_SAVE )	// "ETC"
 GAME( 1992, sf2ceua,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920313)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceub,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920513)", GAME_SUPPORTS_SAVE )
 GAME( 1992, sf2ceuc,     sf2ce,    cps1_12MHz, sf2,        cps1,     ROT0,   "Capcom", "Street Fighter II': Champion Edition (USA 920803)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/cps2.c src/mame/drivers/cps2.c
--- src-old/mame/drivers/cps2.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/cps2.c	2010-08-30 08:20:58.000000000 -0700
@@ -1306,6 +1306,9 @@
 	ROM_LOAD16_WORD_SWAP( "nff.12m",   0x400000, 0x400000, CRC(4fcf1600) SHA1(36f18c5d92b79433bdf7088b29a244708929d48e) )
 ROM_END
 
+
+
+
 ROM_START( 1944j )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "nffj.03", 0x000000, 0x80000, CRC(247521ef) SHA1(c6a04f514dd5ab40d8813dcfb8430bce54e7aa28) )
@@ -7900,7 +7903,7 @@
 static DRIVER_INIT( gigamn2 )
 {
 	cps_state *state = machine->driver_data<cps_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 	int length = memory_region_length(machine, "maincpu");
 
@@ -7910,7 +7913,7 @@
 	state_save_register_global_pointer(machine, state->gigamn2_dummyqsound_ram, 0x20000 / 2);
 
 	memory_install_readwrite16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x618000, 0x619fff, 0, 0, gigamn2_dummyqsound_r, gigamn2_dummyqsound_w); // no qsound..
-	memory_set_decrypted_region(space, 0x000000, (length) - 1, &rom[length/4]);
+	space->set_decrypted_region(0x000000, (length) - 1, &rom[length/4]);
 	m68k_set_encrypted_opcode_range(machine->device("maincpu"), 0, length);
 }
 
@@ -8408,7 +8411,34 @@
 	ROM_LOAD16_WORD_SWAP( "dd2.12m",   0x200000, 0x200000, CRC(5ea2e7fa) SHA1(0e6a9fd007f637adcb2226c902394f07de45e803) )
 ROM_END
 
-ROM_START( gwingjd )
+ROM_START( ecofghtrd )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "ueced.03", 0x000000, 0x80000, CRC(ac725d2b) SHA1(f77a37d160aed34319ef810728de88a87bccb7a5) )
+	ROM_LOAD16_WORD_SWAP( "ueced.04", 0x080000, 0x80000, CRC(f800138d) SHA1(a8c05da5d33c338a82fed4f7b59c6ba8c10e8597) )
+	ROM_LOAD16_WORD_SWAP( "ueced.05", 0x100000, 0x80000, CRC(eb6a12f2) SHA1(5253a193a38b566eefbb8644511f283ac4a69850) )
+	ROM_LOAD16_WORD_SWAP( "ueced.06", 0x180000, 0x80000, CRC(8380ec9a) SHA1(4f3a95a2580f89ae214b588df9258bd9dc06f993) )
+
+	ROM_REGION( 0xc00000, "gfx", 0 )
+	ROMX_LOAD( "uec.13m",   0x000000, 0x200000, CRC(dcaf1436) SHA1(ba124cc0bb10c1d1c07592a3623add4ed054182e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.15m",   0x000002, 0x200000, CRC(2807df41) SHA1(66a9800af435055737ce50a0b0ced7c5718c2004) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.17m",   0x000004, 0x200000, CRC(8a708d02) SHA1(95ec527edc904a66e325667521b4d07d72579211) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.19m",   0x000006, 0x200000, CRC(de7be0ef) SHA1(bf8df9a31f8923f4b726ea12fe8327368463ebe1) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.14m",   0x800000, 0x100000, CRC(1a003558) SHA1(64bbd89e65dc0cf6f4ab5ea93a4cc6312d0d0802) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.16m",   0x800002, 0x100000, CRC(4ff8a6f9) SHA1(03968a301417e8843d42d4e0db42aa0a3a38664b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.18m",   0x800004, 0x100000, CRC(b167ae12) SHA1(48c552d02caad27d680aa51170560794f2a51478) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "uec.20m",   0x800006, 0x100000, CRC(1064bdc2) SHA1(c51f75ac8d3f02a771feda0a933314a928555c4e) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "uec.01",   0x00000, 0x08000, CRC(c235bd15) SHA1(feb7cd7db9dc0b9887b33eed9796bb0205fb719d) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "uec.11m",   0x000000, 0x200000, CRC(81b25d39) SHA1(448adfcc7d98873a48c710d857225cdd1580e5c9) )
+	ROM_LOAD16_WORD_SWAP( "uec.12m",   0x200000, 0x200000, CRC(27729e52) SHA1(a55c8159adf766dda70cb047f5ac85ce6bc0a3f3) )
+ROM_END
+
+
+ROM_START( gigawingjd )
 	ROM_REGION(CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "ggwjd.03a", 0x000000, 0x80000, CRC(cb1c756e) SHA1(f8b37120b429e14aad6e7d2106f8f8c422f2ce2b) )
 	ROM_LOAD16_WORD_SWAP( "ggwjd.04a", 0x080000, 0x80000, CRC(fa158e04) SHA1(bd0f0351fabe376944c28e327bcf83a8d9229441) )
@@ -8432,6 +8462,31 @@
 	ROM_LOAD16_WORD_SWAP( "ggw.12m",   0x400000, 0x400000, CRC(4bee4e8f) SHA1(c440b5a38359ec3b8002f39690b79bf78703f5d0) )
 ROM_END
 
+
+ROM_START( gigawingd )
+	ROM_REGION(CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "ggwu_d.03", 0x000000, 0x80000, CRC(dde92dfa) SHA1(37b052438663d771c256c6cc61cd3f15c560f1b8) )
+	ROM_LOAD16_WORD_SWAP( "ggwu_d.04", 0x080000, 0x80000, CRC(e0509ae2) SHA1(6962cda86351194fe901edd2b99d9da622c00c36) )
+	ROM_LOAD16_WORD_SWAP( "ggw_d.05", 0x100000, 0x80000, CRC(722d0042) SHA1(8587e42d4781c503bc8871b88d3f85e21659c50e) )
+
+	ROM_REGION16_BE( CODE_SIZE, "user1", 0 )
+	ROM_FILL( 0x000000, 0x100000, 0 )
+
+	ROM_REGION( 0x1000000, "gfx", 0 )
+	ROMX_LOAD( "ggw.13m",   0x000000, 0x400000, CRC(105530a4) SHA1(3be06c032985ea6bd3805d73a407bf748385087b) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ggw.15m",   0x000002, 0x400000, CRC(9e774ab9) SHA1(adea1e844f3d9ccd5ad116ff8277f16a96e68d76) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ggw.17m",   0x000004, 0x400000, CRC(466e0ba4) SHA1(9563455b95d36fafe508290659088b153539cfdf) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "ggw.19m",   0x000006, 0x400000, CRC(840c8dea) SHA1(ea04afce17f00b45d3d2cd5140d0dd7ab4bccc00) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION(QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "ggw.01",   0x00000, 0x08000, CRC(4c6351d5) SHA1(cef81fb7c4b8cb2ef1f8f3c27982aefbcbe38160) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "ggw.11m",   0x000000, 0x400000, CRC(e172acf5) SHA1(d7b0963d66165f3607d887741c5e7ab952bcf2ff) )
+	ROM_LOAD16_WORD_SWAP( "ggw.12m",   0x400000, 0x400000, CRC(4bee4e8f) SHA1(c440b5a38359ec3b8002f39690b79bf78703f5d0) )
+ROM_END
+
 ROM_START( hsf2d )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "hs2ad.03", 0x000000, 0x80000, CRC(0153d371) SHA1(137f89b4ca41346abd8d1ef4a17605f6622b741e) )
@@ -8873,10 +8928,13 @@
 	ROM_LOAD16_WORD_SWAP( "vam.12m",   0x200000, 0x200000, CRC(1a3e5c03) SHA1(c5a556e125d6c3d68da745b4d56cd7a851f2a23d) )
 ROM_END
 
-ROM_START( progerjd )
+
+
+
+ROM_START( progearud )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
-	ROM_LOAD16_WORD_SWAP( "pgajd.03", 0x000000, 0x80000, CRC(4fef676c) SHA1(f50f32403315f77e115141bbee6a1b9a800821eb) )
-	ROM_LOAD16_WORD_SWAP( "pgajd.04", 0x080000, 0x80000, CRC(a069bd3b) SHA1(6b7e20c883221da9b8eccb4f86017bb93e1fc11f) )
+	ROM_LOAD16_WORD_SWAP( "pgau_d.03", 0x000000, 0x80000, CRC(ba22b9c5) SHA1(3bacef465ad137b7d618ad7dbe4a0f29b3422a31) )
+	ROM_LOAD16_WORD_SWAP( "pgau_d.04", 0x080000, 0x80000, CRC(df3927ef) SHA1(2869f3f7c1ae76e9b3ce5c66eed277ee8484aeba) )
 
 	ROM_REGION( 0x1000000, "gfx", 0 )
 	ROMX_LOAD( "pga-simm.01c",   0x0000000, 0x200000,  CRC(452f98b0) SHA1(a10e615c32098f6d25becd466da8faa967523a7b) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
@@ -8899,6 +8957,53 @@
 	ROM_LOAD16_WORD_SWAP( "pga-simm.06b",   0x600000, 0x200000, CRC(8b39489a) SHA1(fd790efaf37dc2c4c16f657941044e3e2d3c2711) ) // ROM on a simm
 ROM_END
 
+
+ROM_START( progearjd )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "pgaj_d.03", 0x000000, 0x80000, CRC(0271f3a3) SHA1(caf5ce19aa3471e65931ebd7ef06693e9fdf11a7) )
+	ROM_LOAD16_WORD_SWAP( "pgaj_d.04", 0x080000, 0x80000, CRC(be4b7799) SHA1(0414922296079ca9380a41bf3c628ce67acec06d) )
+
+	ROM_REGION( 0x1000000, "gfx", 0 )
+	ROMX_LOAD( "pga-simm.01c",   0x0000000, 0x200000,  CRC(452f98b0) SHA1(a10e615c32098f6d25becd466da8faa967523a7b) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.01d",   0x0000001, 0x200000,  CRC(9e672092) SHA1(fce0b8b43a1c069262f4e3e81c1a04621e232c88) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.01a",   0x0000002, 0x200000,  CRC(ae9ddafe) SHA1(afbb26fed6cd0cb5c0099a10d35aeb453318c14d) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.01b",   0x0000003, 0x200000,  CRC(94d72d94) SHA1(df6a3fe49c008f73b160eb6f2a44dc371ff73cba) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.03c",   0x0000004, 0x200000,  CRC(48a1886d) SHA1(ebf44b42d784924e08a832a7e5f66a887bab244b) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.03d",   0x0000005, 0x200000,  CRC(172d7e37) SHA1(0eaedd24cd3fa87b6f35fbd63078d40c493c92d0) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.03a",   0x0000006, 0x200000,  CRC(9ee33d98) SHA1(85d1bd31940e35ac8c732165020881a2d65cd6b1) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+	ROMX_LOAD( "pga-simm.03b",   0x0000007, 0x200000,  CRC(848dee32) SHA1(c591288e86ad1624d0fe66563808af9fac786e64) , ROM_GROUPBYTE | ROM_SKIP(7) ) // ROM on a simm
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "pga.01",   0x00000, 0x08000, CRC(bdbfa992) SHA1(7c5496c1daaea6a7ab95c0b25625d325ec3427cc) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "pga-simm.05a",   0x000000, 0x200000, CRC(c0aac80c) SHA1(91784d35d4f7e113529bb5be6081b67094b150ea) ) // ROM on a simm
+	ROM_LOAD16_WORD_SWAP( "pga-simm.05b",   0x200000, 0x200000, CRC(37a65d86) SHA1(374d562a4648734f82aa2ddb6d258e870896dd45) ) // ROM on a simm
+	ROM_LOAD16_WORD_SWAP( "pga-simm.06a",   0x400000, 0x200000, CRC(d3f1e934) SHA1(5dcea28c873d0d472f5b94e07d97cd77ace2b252) ) // ROM on a simm
+	ROM_LOAD16_WORD_SWAP( "pga-simm.06b",   0x600000, 0x200000, CRC(8b39489a) SHA1(fd790efaf37dc2c4c16f657941044e3e2d3c2711) ) // ROM on a simm
+ROM_END
+
+ROM_START( progearjbl )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "pgaj_bl.03", 0x000000, 0x80000, CRC(4fef676c) SHA1(f50f32403315f77e115141bbee6a1b9a800821eb) )
+	ROM_LOAD16_WORD_SWAP( "pgaj_bl.04", 0x080000, 0x80000, CRC(a069bd3b) SHA1(6b7e20c883221da9b8eccb4f86017bb93e1fc11f) )
+
+	ROM_REGION( 0x1000000, "gfx", 0 )
+	ROMX_LOAD( "pga.13m",   0x0000000, 0x400000, CRC(5194c198) SHA1(f9ae16cad8b30547b8dd3a1ea1d6e845d76ccefe) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pga.15m",   0x0000002, 0x400000, CRC(b794e83f) SHA1(0332fa798b2955464ab336929866c9185bd4b520) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pga.17m",   0x0000004, 0x400000, CRC(87f22918) SHA1(7f048d66593f385526bd2c669cf6b8ad58d12bbf) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pga.19m",   0x0000006, 0x400000, CRC(65ffb45b) SHA1(9c21187519c1ec95c5a960b2c815ee41ace4fa7e) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "pga.01",   0x00000, 0x08000, CRC(bdbfa992) SHA1(7c5496c1daaea6a7ab95c0b25625d325ec3427cc) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "pga.11m",   0x000000, 0x400000, CRC(abdd224e) SHA1(3316708e050204eeee91c642a2546fab80984c60) )
+	ROM_LOAD16_WORD_SWAP( "pga.12m",   0x400000, 0x400000, CRC(dac53406) SHA1(53fd271495429a7cbdeecbbc62b322f019f854a5) )
+ROM_END
+
 ROM_START( ssf2ud )
 	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
 	ROM_LOAD16_WORD_SWAP( "ssfud.03a", 0x000000, 0x80000, CRC(fad5daf8) SHA1(5bed5d5af8dffc54d3b3371274a3905f46384f79) )
@@ -9108,9 +9213,268 @@
 ROM_END
 
 
+ROM_START( vhunt2d )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "vh2j_d.03a", 0x000000, 0x80000, CRC(696e0157) SHA1(a5c8c7e389f76952ce40ce5792eddb185dd76c41) )
+	ROM_LOAD16_WORD_SWAP( "vh2j_d.04a", 0x080000, 0x80000, CRC(ced9bba3) SHA1(ef7be9d39ae93ffde7d940736de9711a24585ef4) )
+	ROM_LOAD16_WORD_SWAP( "vh2j.05",    0x100000, 0x80000, CRC(de34f624) SHA1(60bbbd1765e76839b01c38765da2368c5188ec61) )
+	ROM_LOAD16_WORD_SWAP( "vh2j.06",    0x180000, 0x80000, CRC(6a3b9897) SHA1(4f3b37004db8a3d3dde709b51c94c392615134b5) )
+	ROM_LOAD16_WORD_SWAP( "vh2j_d.06",  0x200000, 0x80000, CRC(f320ea30) SHA1(c7853b83892a49917e7a0aa68bc66875a9263589) ) // fails rom test, bad? I don't see why this should change
+	ROM_LOAD16_WORD_SWAP( "vh2j.08",    0x280000, 0x80000, CRC(ac873dff) SHA1(ad9a085b8403801035683b6f63eee33daf4e97ae) )
+	ROM_LOAD16_WORD_SWAP( "vh2j.09",    0x300000, 0x80000, CRC(eaefce9c) SHA1(d842a824f0d0adc13a86f780084164c1273c45a4) )
+	ROM_LOAD16_WORD_SWAP( "vh2j.10",    0x380000, 0x80000, CRC(11730952) SHA1(2966b80b99ab065614a6ddb546110f482b998e32) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "vh2.13m",   0x0000000, 0x400000, CRC(3b02ddaa) SHA1(a73b0554afbfc7ace41bdf8e6cafd4c1ef0b0a08) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.15m",   0x0000002, 0x400000, CRC(4e40de66) SHA1(e8b80eadffad6070aa04c8ab426311c44e7c5507) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.17m",   0x0000004, 0x400000, CRC(b31d00c9) SHA1(7e7be64690663f52d10c8946aabec4250c8a8740) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.19m",   0x0000006, 0x400000, CRC(149be3ab) SHA1(afc8e96e6aa3cf1db6dfd8075030a6c50b4419a9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.14m",   0x1000000, 0x400000, CRC(cd09bd63) SHA1(e582b20a948ae54f52590496051688dbfae2bc9c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.16m",   0x1000002, 0x400000, CRC(e0182c15) SHA1(a924d53ab39f4d85173bdb92a197dde2db0dc3f7) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.18m",   0x1000004, 0x400000, CRC(778dc4f6) SHA1(8d0cd1c387b4b6ac7f92bb2e5a25983856328cdc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vh2.20m",   0x1000006, 0x400000, CRC(605d9d1d) SHA1(99bc27557741527ca678d7b6307164bc04ebedc6) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "vh2.01",  0x00000, 0x08000, CRC(67b9f779) SHA1(3994c65f888004b56ea9f478b1feaa81e306347e) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "vh2.02",  0x28000, 0x20000, CRC(aaf15fcb) SHA1(6f61daa162c835165a8aabaf1d0ea8816fbfbd40) )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "vh2.11m",  0x000000, 0x400000, CRC(38922efd) SHA1(8cfb36bdce3a524d0a81fec12ca0cba82222fa30) )
+	ROM_LOAD16_WORD_SWAP( "vh2.12m",  0x400000, 0x400000, CRC(6e2430af) SHA1(b475faf943bec4171ba0130f287e1948743ca273) )
+ROM_END
+
+
+ROM_START( vsav2d ) // all modified roms fail rom check
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.03", 0x000000, 0x80000, CRC(5ee19aee) SHA1(da16d64c4de0b14a39c4a19a00c59f59579d0bd8) )
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.04", 0x080000, 0x80000, CRC(80116c47) SHA1(e73c2d1fc006a74e3bb4c7a0e1b888b24b3f4c33) )
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.05", 0x100000, 0x80000, CRC(dc74a062) SHA1(723e806f70a1cfcfcb37d59fae30bfd27a581f3a) )
+	ROM_LOAD16_WORD_SWAP( "vs2j.06",   0x180000, 0x80000, CRC(f37c5bc2) SHA1(d8c1040a6ee6b9fc677a6a32b99bf02b6a707812) )
+	ROM_LOAD16_WORD_SWAP( "vs2j.07",   0x200000, 0x80000, CRC(8f885809) SHA1(69dac07e1f483b6478f792d20a137d6a081fbea3) )
+	ROM_LOAD16_WORD_SWAP( "vs2j_d.08", 0x280000, 0x80000, CRC(97554918) SHA1(da6a8f6ba160696b141117c7c0da6f459637a729) ) // should this really be different?
+	ROM_LOAD16_WORD_SWAP( "vs2j.09",   0x300000, 0x80000, CRC(fac3c217) SHA1(0e9dd54e401e6d7c4fe81107ffd27e42ca810fcb) )
+	ROM_LOAD16_WORD_SWAP( "vs2j.10",   0x380000, 0x80000, CRC(eb490213) SHA1(bf0416df66a33c7a4678ab4a047de334dfd3b31e) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "vs2.13m",   0x0000000, 0x400000, CRC(5c852f52) SHA1(528ce7fc9a0451e2e2d221dbf5e4a5796584e053) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.15m",   0x0000002, 0x400000, CRC(a20f58af) SHA1(e873ad3e0fc8a06a5029113faf991f5c1b765316) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.17m",   0x0000004, 0x400000, CRC(39db59ad) SHA1(da94f1529da82a6bf2129f51548412e1ab2b001a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.19m",   0x0000006, 0x400000, CRC(00c763a7) SHA1(0ff528e12e255ebf699101ac71f05b1f6bef7165) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.14m",   0x1000000, 0x400000, CRC(cd09bd63) SHA1(e582b20a948ae54f52590496051688dbfae2bc9c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.16m",   0x1000002, 0x400000, CRC(e0182c15) SHA1(a924d53ab39f4d85173bdb92a197dde2db0dc3f7) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.18m",   0x1000004, 0x400000, CRC(778dc4f6) SHA1(8d0cd1c387b4b6ac7f92bb2e5a25983856328cdc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "vs2.20m",   0x1000006, 0x400000, CRC(605d9d1d) SHA1(99bc27557741527ca678d7b6307164bc04ebedc6) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "vs2.01",   0x00000, 0x08000, CRC(35190139) SHA1(07f8e53ea398461de5dcda9814dde7c09faf9f65) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "vs2.02",   0x28000, 0x20000, CRC(c32dba09) SHA1(1fe337ff334fab79847f9677ba0e168e93daa1c8) )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "vs2.11m",   0x000000, 0x400000, CRC(d67e47b7) SHA1(15a3f6779eccb10551ed94edf7e6e406a79b3de7) )
+	ROM_LOAD16_WORD_SWAP( "vs2.12m",   0x400000, 0x400000, CRC(6d020a14) SHA1(e98f862fac1e357c90949768bb2646263d9981a0) )
+ROM_END
+
+
+ROM_START( csclub1d )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "csce_d.03", 0x000000, 0x80000, CRC(5aedc6e6) SHA1(1330959ac96b0c267e81237974ec44ed7189495a) )
+	ROM_LOAD16_WORD_SWAP( "csce_d.04", 0x080000, 0x80000, CRC(a3d9aa25) SHA1(d7a98cf4506c30b321d8c5a0687fa6938740f951) )
+	ROM_LOAD16_WORD_SWAP( "csce_d.05", 0x100000, 0x80000, CRC(0915c9d1) SHA1(071c6bcfb0ed1047f06c2fbe43a0340aef73dc1d) )
+	ROM_LOAD16_WORD_SWAP( "csce_d.06", 0x180000, 0x80000, CRC(09c77d99) SHA1(16b21f975ad07dd3156291e8c274a0c52d783938) )
+	ROM_LOAD16_WORD_SWAP( "csc_d.07", 0x200000, 0x80000, CRC(77478e25) SHA1(d2648a8d57a156c5a0416007dedb4c65af8403d5) )
+
+	ROM_REGION( 0x1000000, "gfx", 0 )
+	ROM_FILL(              0x000000, 0x800000, 0 )
+	ROMX_LOAD( "csc.73",  0x800000, 0x080000, CRC(335f07c3) SHA1(44e0385120e2c81fd1072e19b7e3ff05d42be226) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.74",  0xa00000, 0x080000, CRC(ab215357) SHA1(c2600b5ba62a570f8a32de9c06f93ea8ae6cd854) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.75",  0xc00000, 0x080000, CRC(a2367381) SHA1(49d562be42c10cdf4e55e3b76c388f0b0121a967) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.76",  0xe00000, 0x080000, CRC(728aac1f) SHA1(2d04e8803f41af2372fc342fcd8a076c14338198) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.63",  0x800002, 0x080000, CRC(3711b8ca) SHA1(ff7ba4f73d227212377327f4fcbe8f555ac4b9c9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.64",  0xa00002, 0x080000, CRC(828a06d8) SHA1(ce1d147f1d747fcd90d93f7dcca0cdd24c85a971) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.65",  0xc00002, 0x080000, CRC(86ee4569) SHA1(725d82a1669f6f78fb4ef8756ceac8b444dcbd43) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.66",  0xe00002, 0x080000, CRC(c24f577f) SHA1(d3b97091e1f0171e087feb9d497c94a48872cd21) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.83",  0x800004, 0x080000, CRC(0750d12a) SHA1(4c36cba88c58bdbfed923f56a6d489f42a4d0f6e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.84",  0xa00004, 0x080000, CRC(90a92f39) SHA1(75bef2440147bac417b48d61ff64b71ed5b9eb67) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.85",  0xc00004, 0x080000, CRC(d08ab012) SHA1(7f2e71b6bd85c6a3efbd417977261c21f3d6cb7c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.86",  0xe00004, 0x080000, CRC(41652583) SHA1(7132647dc9a29ce98866f489140703c5ed3d6051) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.93",  0x800006, 0x080000, CRC(a756c7f7) SHA1(d0f44f8ded12291d5c79282eac45d088cb365b09) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.94",  0xa00006, 0x080000, CRC(fb7ccc73) SHA1(763e6fe1baf73341747c74d89df9443561fca4fa) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.95",  0xc00006, 0x080000, CRC(4d014297) SHA1(df172a3723793b9955ff1f65e76fe5c20fc37b89) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "csc.96",  0xe00006, 0x080000, CRC(6754b1ef) SHA1(ab5d62056b19999ccecd0eeec7b7c5869ca8fea8) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "csc.01",   0x00000, 0x08000, CRC(ee162111) SHA1(ce8d4bd32bb10ee8b0274ba6fcef05a583b39d48) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "csc.51",   0x000000, 0x080000, CRC(5a52afd5) SHA1(ab873ec556933b75be82ba249357cceb01a7a0bd) )
+	ROM_LOAD16_WORD_SWAP( "csc.52",   0x080000, 0x080000, CRC(1408a811) SHA1(1d31e3cd505245b5ff4d3c55d5fa7017c0f1e168) )
+	ROM_LOAD16_WORD_SWAP( "csc.53",   0x100000, 0x080000, CRC(4fb9f57c) SHA1(093e8e3a03b62783a84fe4ae239e9eb46cbfd71e) )
+	ROM_LOAD16_WORD_SWAP( "csc.54",   0x180000, 0x080000, CRC(9a8f40ec) SHA1(c8db1ecfd6b08e9c83ae53a1d25c1387ab95535c) )
+	ROM_LOAD16_WORD_SWAP( "csc.55",   0x200000, 0x080000, CRC(91529a91) SHA1(183569100ae98e17688e0e25932850e73a41eb88) )
+	ROM_LOAD16_WORD_SWAP( "csc.56",   0x280000, 0x080000, CRC(9a345334) SHA1(330291400a73215c9797457507a86c90ba415247))
+	ROM_LOAD16_WORD_SWAP( "csc.57",   0x300000, 0x080000, CRC(aedc27f2) SHA1(55137f0f22c4823558e6a8ba76011695579a4f1f) )
+	ROM_LOAD16_WORD_SWAP( "csc.58",   0x380000, 0x080000, CRC(2300b7b3) SHA1(f5ecbb45c24f7de1c1aa435870695551d4e343ca) )
+ROM_END
+
+
+ROM_START( cybotsud )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "cybu_d.03", 0x000000, 0x80000, CRC(ee7560fb) SHA1(632e057a7b3a61127beee4ed833a39dcec4ccbd5) )
+	ROM_LOAD16_WORD_SWAP( "cybu_d.04", 0x080000, 0x80000, CRC(7e7425a0) SHA1(6368cf5b04271e68b27abecd67d107bbf58976b4) )
+	ROM_LOAD16_WORD_SWAP( "cyb.05",  0x100000, 0x80000, CRC(ec40408e) SHA1(dd611c1708e7ef86e4f7cac4b7b0dff7baaee5ed) )
+	ROM_LOAD16_WORD_SWAP( "cyb.06",  0x180000, 0x80000, CRC(1ad0bed2) SHA1(2ea005f3e73b05f8f0ec006cd9e95f7731a73897) )
+	ROM_LOAD16_WORD_SWAP( "cyb.07",  0x200000, 0x80000, CRC(6245a39a) SHA1(4f607e733e2dea80211497522be6d0f09571928d) )
+	ROM_LOAD16_WORD_SWAP( "cyb.08",  0x280000, 0x80000, CRC(4b48e223) SHA1(9714579a7a78b9716e44bca6c18bf1a93aa4e482) )
+	ROM_LOAD16_WORD_SWAP( "cyb.09",  0x300000, 0x80000, CRC(e15238f6) SHA1(16abd92ebed921a6a7e8eac4b098dc61f7e5485c) )
+	ROM_LOAD16_WORD_SWAP( "cyb.10",  0x380000, 0x80000, CRC(75f4003b) SHA1(8a65026ae35247cda016ce85a34034c62b3aa1a6) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "cyb.13m",   0x0000000, 0x400000, CRC(f0dce192) SHA1(b743938dc8e772dc3f63ed88a4a54c34fffdba21) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.15m",   0x0000002, 0x400000, CRC(187aa39c) SHA1(80e3cf5c69f13343de667e1476bb716d45d3ff63) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.17m",   0x0000004, 0x400000, CRC(8a0e4b12) SHA1(40132f3cc79b0a74460ebd4e0d4ddbe240efc06f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.19m",   0x0000006, 0x400000, CRC(34b62612) SHA1(154bbceb7d303a208abb1b2f3d507d5afacc71ed) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.14m",   0x1000000, 0x400000, CRC(c1537957) SHA1(bfb1cc6786277b94ce28bfd464e2bbb6f6d3486e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.16m",   0x1000002, 0x400000, CRC(15349e86) SHA1(b0cde577d29a9f4e718b673c8645529ef0ababc9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.18m",   0x1000004, 0x400000, CRC(d83e977d) SHA1(e03f4a120c95a2f476ffc8492bca85e0c5cea068) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "cyb.20m",   0x1000006, 0x400000, CRC(77cdad5c) SHA1(94d0cc5f05de4bc2d43977d91f887005dc10310c) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "cyb.01",   0x00000, 0x08000, CRC(9c0fb079) SHA1(06d260875a76da08d56ea2b2ae277e8c2dbae6e3) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "cyb.02",   0x28000, 0x20000, CRC(51cb0c4e) SHA1(c322957558d8d3e9dad090aebbe485978cbce8f5) )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "cyb.11m",   0x000000, 0x200000, CRC(362ccab2) SHA1(28e537067d4846f22657ee37166d18b8f05f4da1) )
+	ROM_LOAD16_WORD_SWAP( "cyb.12m",   0x200000, 0x200000, CRC(7066e9cc) SHA1(eb6a9d4998b3311344d73bae88d661d81609c492) )
+ROM_END
+
+
+
+ROM_START( mshvsfu1d )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "mvsu_d.03d", 0x000000, 0x80000, CRC(1c88bee3) SHA1(53ab6df85a900b221cabd62948e68d91cf6146e4) )
+	ROM_LOAD16_WORD_SWAP( "mvsu_d.04d", 0x080000, 0x80000, CRC(1e8b2535) SHA1(51ebede487f955e3f838b7906b619830e67fea52) )
+	ROM_LOAD16_WORD_SWAP( "mvs_d.05a",  0x100000, 0x80000, CRC(373856fb) SHA1(777bf7c74110c029c44a363ce79e50c1863950c2) )
+	ROM_LOAD16_WORD_SWAP( "mvs.06a",    0x180000, 0x80000, CRC(959f3030) SHA1(fbbaa915324815246738f3426232e623f039ce26) )
+	ROM_LOAD16_WORD_SWAP( "mvs.07b",    0x200000, 0x80000, CRC(7f915bdb) SHA1(683da09c5ba55e31b59aa95a8e13c45dc574ab3c) )
+	ROM_LOAD16_WORD_SWAP( "mvs.08a",    0x280000, 0x80000, CRC(c2813884) SHA1(49e5d4bc48f90c8146cb6aafb9240aff0119f1a7) )
+	ROM_LOAD16_WORD_SWAP( "mvs.09b",    0x300000, 0x80000, CRC(3ba08818) SHA1(9ab132a3cac55fcccebe6c99b6fb0ba1305f8f6e) )
+	ROM_LOAD16_WORD_SWAP( "mvs.10b",    0x380000, 0x80000, CRC(cf0dba98) SHA1(f4c1f8a6e7a79ecc6241d5268b3039f8a09ea516) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "mvs.13m",   0x0000000, 0x400000, CRC(29b05fd9) SHA1(e8fdb1ee5515a560eb4256ae4fd99bb1192e1a87) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.15m",   0x0000002, 0x400000, CRC(faddccf1) SHA1(4ed03ea91883a0413325f57edcc1614120b5922c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.17m",   0x0000004, 0x400000, CRC(97aaf4c7) SHA1(6a054921cc14fe080cb3f62c391f8ae3cc7e8ba9) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.19m",   0x0000006, 0x400000, CRC(cb70e915) SHA1(da4d2480d348ac6dfd01256a88f4f3db8357ae46) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.14m",   0x1000000, 0x400000, CRC(b3b1972d) SHA1(0f2c3fb7de014181ee481ec35d0578b2c116c2dc) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.16m",   0x1000002, 0x400000, CRC(08aadb5d) SHA1(3a2c222eca3e7df80ce69951b3db6442312751a4) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.18m",   0x1000004, 0x400000, CRC(c1228b35) SHA1(7afdfb552888c79d0fbb30242b3d917b87fad57a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "mvs.20m",   0x1000006, 0x400000, CRC(366cc6c2) SHA1(6f2a789087c8e404c5227b927fa8328c03593243) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "mvs.01",   0x00000, 0x08000, CRC(68252324) SHA1(138ef320ef27956b2ab5591d49a1315b7b0a194c) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "mvs.02",   0x28000, 0x20000, CRC(b34e773d) SHA1(3bcf44bf06c35814cff29d244142db7abe05bd39) )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "mvs.11m",   0x000000, 0x400000, CRC(86219770) SHA1(4e5b68d382a5aa37f8b0b6434c53a2b95f5f9a4d) )
+	ROM_LOAD16_WORD_SWAP( "mvs.12m",   0x400000, 0x400000, CRC(f2fd7f68) SHA1(28a30d55d3eaf963006c7cbe7c288099cd3ba536) )
+ROM_END
+
+
+ROM_START( spf2td )
+	ROM_REGION(CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "pzfu_d.03a", 0x000000, 0x80000, CRC(7836b903) SHA1(9a96a9080716a0cc4d13f51490fd850afe4479a7) )
+	ROM_LOAD16_WORD_SWAP( "pzf.04",    0x080000, 0x80000, CRC(b80649e2) SHA1(5bfccd656aea7ff82e9a20bb5856f4ab99b5a007) )
+
+	ROM_REGION16_BE( CODE_SIZE, "user1", 0 )
+	ROM_FILL( 0x000000, 0x100000, 0 )
+
+	ROM_REGION( 0xC00000, "gfx", 0 )
+	ROM_FILL(              0x000000, 0x800000, 0 )
+	ROMX_LOAD( "pzf.14m",  0x800000, 0x100000, CRC(2d4881cb) SHA1(fd3baa183c25bed153b19c251980e2fb761600e2) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pzf.16m",  0x800002, 0x100000, CRC(4b0fd1be) SHA1(377aafdcdb7a866b1c8487670e3598d8197976e4) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pzf.18m",  0x800004, 0x100000, CRC(e43aac33) SHA1(d041e0688c3807d3363861a7f216de43b34d846c) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "pzf.20m",  0x800006, 0x100000, CRC(7f536ff1) SHA1(905b9d62ef7bef47297c7f4a4dd697aed6df38a5) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION(QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "pzf.01",   0x00000, 0x08000, CRC(600fb2a3) SHA1(1fab1c2a23bf6ad8309d29ddbbc29435a8aeea13) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "pzf.02",   0x28000, 0x20000, CRC(496076e0) SHA1(1ee4e135140afd0e8e03231e570cd77d140f6367) )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "pzf.11m",   0x000000, 0x200000, CRC(78442743) SHA1(b61190bb586871de6d54af580e3e1d9cc0de0acb) )
+	ROM_LOAD16_WORD_SWAP( "pzf.12m",   0x200000, 0x200000, CRC(399d2c7b) SHA1(e849dea97b8d16540415c0d9bbc4f9f4eb755ec4) )
+ROM_END
+
+
+ROM_START( sfz3jr2d )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "sz3j_d.03", 0x000000, 0x80000, CRC(b0436151) SHA1(5170390d5d38bb003602d5714d557005bd7218be) )
+	ROM_LOAD16_WORD_SWAP( "sz3j_d.04", 0x080000, 0x80000, CRC(642d8170) SHA1(1a73f6090a384e7399e49e3a13fe02aa284d4775) )
+	ROM_LOAD16_WORD_SWAP( "sz3.05",  0x100000, 0x80000, CRC(9b21518a) SHA1(5a928307cb90a98a62e7598cb101fb66d62b85f9) )
+	ROM_LOAD16_WORD_SWAP( "sz3.06",  0x180000, 0x80000, CRC(e7a6c3a7) SHA1(63441eb19efcbf9149f4b723d3e9191fa972de2a) )
+	ROM_LOAD16_WORD_SWAP( "sz3.07",  0x200000, 0x80000, CRC(ec4c0cfd) SHA1(1a5148e77bf633c728a8179dacb59c776f981bc4) )
+	ROM_LOAD16_WORD_SWAP( "sz3.08",  0x280000, 0x80000, CRC(5c7e7240) SHA1(33bdcdd1889f8fa77916373ed33b0854410d0263) )
+	ROM_LOAD16_WORD_SWAP( "sz3.09",  0x300000, 0x80000, CRC(c5589553) SHA1(cda1fdc2ab2f390a2358defd9923a2796093926d) )
+	ROM_LOAD16_WORD_SWAP( "sz3.10",  0x380000, 0x80000, CRC(a9717252) SHA1(7ee94ace2a49e4e5d30474e49c0da04a488010fe) )
+
+	ROM_REGION( 0x2000000, "gfx", 0 )
+	ROMX_LOAD( "sz3.13m",   0x0000000, 0x400000, CRC(0f7a60d9) SHA1(c69e0ee22537312909dacc86d2e4be319d54e426) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.15m",   0x0000002, 0x400000, CRC(8e933741) SHA1(f4ac4bfe830dc7df9fe4f680e4e0c053e7cbd8fe) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.17m",   0x0000004, 0x400000, CRC(d6e98147) SHA1(37f331fbb1284db446faecade6f484f58c0e1b2a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.19m",   0x0000006, 0x400000, CRC(f31a728a) SHA1(f14136564648f006c1b74afda78349f260524b5f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.14m",   0x1000000, 0x400000, CRC(5ff98297) SHA1(9e0ce43380b776c7a03872bafd4856f6fa60bda7) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.16m",   0x1000002, 0x400000, CRC(52b5bdee) SHA1(7918204dc457f7a146d8fb8cf7242dfed3109fd8) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.18m",   0x1000004, 0x400000, CRC(40631ed5) SHA1(c18c56822b90a71ca5fbdf3440eb2671011f3d8f) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz3.20m",   0x1000006, 0x400000, CRC(763409b4) SHA1(af60a5116c1ca9050366a35ea29128921867f3cc) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "sz3.01",   0x00000, 0x08000, CRC(de810084) SHA1(fd0b969b732921ed8b40c16fbfa30ee09c7a7cbd) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "sz3.02",   0x28000, 0x20000, CRC(72445dc4) SHA1(14fca7596ac45ba655016eef5b6120f9f9671c23) )
+
+	ROM_REGION( 0x800000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "sz3.11m",   0x000000, 0x400000, CRC(1c89eed1) SHA1(649a0b0a3eb72e2e69e9fb1ac51a58b70daa39f3) )
+	ROM_LOAD16_WORD_SWAP( "sz3.12m",   0x400000, 0x400000, CRC(f392b13a) SHA1(fa04ce0370144a49bd1d5acd873eef87b0dc9d15) )
+ROM_END
+
+ROM_START( sfz2jd )
+	ROM_REGION( CODE_SIZE, "maincpu", 0 )      /* 68000 code */
+	ROM_LOAD16_WORD_SWAP( "sz2j_d.03a", 0x000000, 0x80000, CRC(b7325df8) SHA1(cd6e242a5681017463102dcb9133d8dcb262f923) )
+	ROM_LOAD16_WORD_SWAP( "sz2j_d.04a", 0x080000, 0x80000, CRC(a1022a3e) SHA1(4806637ddf22169f12d31f959982cb2f11693066) )
+	ROM_LOAD16_WORD_SWAP( "sz2.05a",  0x100000, 0x80000, CRC(98e8e992) SHA1(41745b63e6b3888081d189b8315ed3b7526b3d20) )
+	ROM_LOAD16_WORD_SWAP( "sz2.06",   0x180000, 0x80000, CRC(5b1d49c0) SHA1(f0a0c894c9cbe2b18e7f59058665949ee0025732) )
+	ROM_LOAD16_WORD_SWAP( "sz2j.07a", 0x200000, 0x80000, CRC(d910b2a2) SHA1(aa201660caa9cef993c147a1077c9e7767b34a78) )
+	ROM_LOAD16_WORD_SWAP( "sz2.08",   0x280000, 0x80000, CRC(0fe8585d) SHA1(0cd5369a5aa90c98d8dc1ff3342cd4d990631cff) )
+
+	ROM_REGION( 0x1400000, "gfx", 0 )
+	ROMX_LOAD( "sz2.13m",   0x0000000, 0x400000, CRC(4d1f1f22) SHA1(659fb4305bcf0cbbbbec97ede6e68a8323b13308) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.15m",   0x0000002, 0x400000, CRC(19cea680) SHA1(4cb88963a0fbcef191c8419b6379387c01b4c81e) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.17m",   0x0000004, 0x400000, CRC(e01b4588) SHA1(c2936608fd75ff6cd5fa94c6d6d6f0c77c44a450) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.19m",   0x0000006, 0x400000, CRC(0feeda64) SHA1(f5b350601437bd94b70d97feb23d791df19da6b3) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.14m",   0x1000000, 0x100000, CRC(0560c6aa) SHA1(f2bed3a8efef18052b51a7f0f6a888a18db813a1) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.16m",   0x1000002, 0x100000, CRC(ae940f87) SHA1(39ee26333abbe302ba76dced0196a2e6b3b1d02a) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.18m",   0x1000004, 0x100000, CRC(4bc3c8bc) SHA1(6256963c515bf56f39b6e559afefd653ead56c54) , ROM_GROUPWORD | ROM_SKIP(6) )
+	ROMX_LOAD( "sz2.20m",   0x1000006, 0x100000, CRC(39e674c0) SHA1(8e771a2d8c2accad0463bccd21d7b23af0c895a1) , ROM_GROUPWORD | ROM_SKIP(6) )
+
+	ROM_REGION( QSOUND_SIZE, "audiocpu", 0 ) /* 64k for the audio CPU (+banks) */
+	ROM_LOAD( "sz2.01a",   0x00000, 0x08000, CRC(1bc323cf) SHA1(83fbd6e9b327700dc9f1c59700b7385bc3705749) )
+	ROM_CONTINUE(         0x10000, 0x18000 )
+	ROM_LOAD( "sz2.02a",   0x28000, 0x20000, CRC(ba6a5013) SHA1(7814f3e56b69529b9860dd61c3b1e8d700244b03) )
+
+	ROM_REGION( 0x400000, "qsound", 0 ) /* QSound samples */
+	ROM_LOAD16_WORD_SWAP( "sz2.11m",   0x000000, 0x200000, CRC(aa47a601) SHA1(a4d1ee89c84a3b9db06469bb66e85293b5aa9ac9) )
+	ROM_LOAD16_WORD_SWAP( "sz2.12m",   0x200000, 0x200000, CRC(2237bc53) SHA1(96d5693047e4cf1ed10a8ee1905cea267a278e92) )
+ROM_END
+
 
 GAME( 1993, ssf2ud,   ssf2,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Super Street Fighter II: The New Challengers (USA 930911 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1993, ddtodd,   ddtod,    dead_cps2, cps2_4p4b, cps2,    ROT0,   "bootleg", "Dungeons & Dragons: Tower of Doom (Euro 940412 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1993, ecofghtrd,ecofghtr, dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Eco Fighters (World 931203 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1994, armwar1d, armwar,   dead_cps2, cps2_3p3b, cps2,    ROT0,   "bootleg", "Armored Warriors (Euro 941011 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1994, avspd,    avsp,     dead_cps2, cps2_3p3b, cps2,    ROT0,   "bootleg", "Alien vs. Predator (Euro 940520 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1994, dstlku1d, dstlk,    dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Darkstalkers: The Night Warriors (USA 940705 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
@@ -9121,6 +9485,8 @@
 GAME( 1995, mshud,    msh,      dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Marvel Super Heroes (US 951024 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1996, 19xxd,    19xx,     dead_cps2, cps2_2p2b, cps2,    ROT270, "bootleg", "19XX: The War Against Destiny (USA 951207 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1996, sfz2ad,   sfa2,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Street Fighter Zero 2 (Asia 960227 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1996, sfz2jd,   sfa2,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Street Fighter Zero 2 (Japan 960227 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1996, spf2td,   spf2t,    dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "Super Puzzle Fighter II Turbo (USA 960620 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1996, spf2xjd,  spf2t,    dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "Super Puzzle Fighter II X (Japan 960531 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1996, ddsomud,  ddsom,    dead_cps2, cps2_4p4b, cps2,    ROT0,   "bootleg", "Dungeons & Dragons: Shadow over Mystara (USA 960619 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1996, gigamn2,  megaman2, gigamn2,   cps2_2p3b, gigamn2, ROT0,   "bootleg", "Giga Man 2: The Power Fighters (bootleg of Mega Man 2: The Power Fighters)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE ) // flash roms aren't dumped, layer offsets different, different sound system
@@ -9131,12 +9497,21 @@
 GAME( 1997, vsavd,    vsav,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Savior: The Lord of Vampire (Euro 970519 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1998, mvscud,   mvsc,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Marvel Vs. Capcom: Clash of Super Heroes (USA 980123 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1998, sfa3ud,   sfa3,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Street Fighter Alpha 3 (USA 980904 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
-GAME( 1999, gwingjd,  gigawing, dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "Giga Wing (Japan 990223 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1999, gigawingd, gigawing,dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "Giga Wing (USA 990222 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1999, gigawingjd,gigawing,dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "Giga Wing (Japan 990223 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2000, 1944d,    1944,     dead_cps2, cps2_2p2b, cps2,    ROT0,   "bootleg", "1944: The Loop Master (USA 000620 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
-GAME( 2001, progerjd, progear,  dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Progear no Arashi (Japan 010117 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE ) // doesn't display phoenix edition screen, hacked bootleg?
+GAME( 2001, progearud, progear, dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Progear (USA 010117 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 2001, progearjd, progear, dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Progear no Arashi (Japan 010117 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 2001, progearjbl,progear, dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Progear no Arashi (Japan 010117) (decrypted bootleg)", GAME_SUPPORTS_SAVE ) // not an actual phoenix set, but works as one
 GAME( 2004, hsf2d,    hsf2,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Hyper Street Fighter II: The Anniversary Edition (Asia 040202 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1993, ssf2tbd,  ssf2,     dead_cps2, cps2_2p6b, ssf2tb,  ROT0,   "bootleg", "Super Street Fighter II: The Tournament Battle (World 931119 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1994, ssf2xjd,  ssf2t,    dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Super Street Fighter II X: Grand Master Challenge (Japan 940223 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 1997, sgemfd,   sgemf,    dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Super Gem Fighter Mini Mix (USA 970904 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2000, mmatrixd, mmatrix,  dead_cps2, cps2_2p1b, cps2,    ROT0,   "bootleg", "Mars Matrix: Hyper Solid Shooting (Japan 000412 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
 GAME( 2000, dimahoud, dimahoo,  dead_cps2, cps2_2p3b, cps2,    ROT270, "bootleg", "Dimahoo (USA 000121 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1997, vhunt2d,  vhunt2,   dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Hunter 2: Darkstalkers Revenge (Japan 970929 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1997, vsav2d,   vsav2,    dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Vampire Savior 2: The Lord of Vampire (Japan 970913 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1997, csclub1d, csclub,   dead_cps2, cps2_2p3b, cps2,    ROT0,   "bootleg", "Capcom Sports Club (Euro 970722 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1995, cybotsud, cybots,   dead_cps2, cybots,    cps2,    ROT0,   "bootleg", "Cyberbots: Fullmetal Madness (USA 950424 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1997, mshvsfu1d,mshvsf,   dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Marvel Super Heroes Vs. Street Fighter (USA 970625 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
+GAME( 1998, sfz3jr2d, sfa3,     dead_cps2, cps2_2p6b, cps2,    ROT0,   "bootleg", "Street Fighter Zero 3 (Japan 980629 Phoenix Edition) (bootleg)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/cps3.c src/mame/drivers/cps3.c
--- src-old/mame/drivers/cps3.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/cps3.c	2010-08-18 23:57:51.000000000 -0700
@@ -607,7 +607,7 @@
 
 
 
-static DIRECT_UPDATE_HANDLER( cps3_direct_handler );
+DIRECT_UPDATE_HANDLER( cps3_direct_handler );
 
 /* Encryption */
 
@@ -706,7 +706,9 @@
 
 
 	cps3_0xc0000000_ram_decrypted = auto_alloc_array(machine, UINT32, 0x400/4);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), cps3_direct_handler);
+
+	address_space *main = machine->device<sh2_device>("maincpu")->space(AS_PROGRAM);
+	main->set_direct_update_handler(direct_update_delegate_create_static(cps3_direct_handler, *machine));
 
 	// flash roms
 
@@ -1263,38 +1265,37 @@
 
 
 
-static DIRECT_UPDATE_HANDLER( cps3_direct_handler )
+DIRECT_UPDATE_HANDLER( cps3_direct_handler )
 {
 //  if(DEBUG_PRINTF) printf("address %04x\n",address);
 
 	/* BIOS ROM */
 	if (address < 0x80000)
 	{
-		direct->raw = direct->decrypted = memory_region(space->machine, "user1");
+		direct.explicit_configure(0x00000, 0x7ffff, 0x7ffff, *direct.space().m_machine.region("user1"));
 		return ~0;
 	}
 	/* RAM */
 	else if (address >= 0x06000000 && address <= 0x06ffffff)
 	{
-		direct->decrypted = (UINT8*)decrypted_gamerom-0x06000000;
-		direct->raw = (UINT8*)decrypted_gamerom-0x06000000;
+		UINT8 *decrypted = (UINT8*)decrypted_gamerom;
+		UINT8 *raw = decrypted;
 
-		if (cps3_altEncryption) direct->raw = (UINT8*) cps3_user4region-0x06000000;
+		if (cps3_altEncryption) raw = (UINT8*) cps3_user4region;
 
+		direct.explicit_configure(0x06000000, 0x06ffffff, 0x00ffffff, raw, decrypted);
 
 		return ~0;
 	}
 	else if (address >= 0xc0000000 && address <= 0xc00003ff)
 	{
 		//direct->decrypted = (void*)cps3_0xc0000000_ram_decrypted;
-		direct->decrypted = (UINT8*)cps3_0xc0000000_ram_decrypted-0xc0000000;
-		direct->raw = (UINT8*)cps3_0xc0000000_ram-0xc0000000;
+		direct.explicit_configure(0xc0000000, 0xc00003ff, 0x3ff, (UINT8*)cps3_0xc0000000_ram, (UINT8*)cps3_0xc0000000_ram_decrypted);
 		return ~0;
 	}
 
 	/* anything else falls through to NOPs */
-	direct->decrypted = (UINT8*)cps3_nops-address;
-	direct->raw = (UINT8*)cps3_nops-address;
+	direct.explicit_configure(address, address, 0, (UINT8*)cps3_nops, (UINT8*)cps3_nops);
 	return ~0;
 }
 
diff -Nru src-old/mame/drivers/crbaloon.c src/mame/drivers/crbaloon.c
--- src-old/mame/drivers/crbaloon.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/crbaloon.c	2010-08-19 00:26:14.000000000 -0700
@@ -342,7 +342,7 @@
 
 static MACHINE_RESET( crballoon )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	running_device *discrete = machine->device("discrete");
 
 	pc3092_reset();
diff -Nru src-old/mame/drivers/crospang.c src/mame/drivers/crospang.c
--- src-old/mame/drivers/crospang.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/crospang.c	2010-08-30 08:20:58.000000000 -0700
@@ -100,19 +100,20 @@
 ADDRESS_MAP_END
 
 
+/* verified from M68000 code */
 static INPUT_PORTS_START( crospang )
 	PORT_START("P1_P2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
@@ -126,48 +127,59 @@
 	PORT_BIT( 0xfc00, IP_ACTIVE_LOW, IPT_UNKNOWN )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0003, 0x0002, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:1,2")
+	PORT_DIPNAME( 0x0003, 0x0002, DEF_STR( Coinage ) )      PORT_DIPLOCATION("SW1:1,2")
 	PORT_DIPSETTING(      0x0000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_2C ) )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0004, 0x0004, "SW1:3" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0008, 0x0008, "SW1:4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0010, 0x0010, "SW1:5" )
-	PORT_DIPNAME( 0x0020, 0x0020, "Number of Powers" ) PORT_DIPLOCATION("SW1:6")
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Difficulty ) )   PORT_DIPLOCATION("SW1:3,4")   /* to be confirmed */
+	PORT_DIPSETTING(      0x0008, DEF_STR( Easy ) )         /* table at 0x02ee2c */
+	PORT_DIPSETTING(      0x000c, DEF_STR( Medium ) )       /* table at 0x02e88c */
+	PORT_DIPSETTING(      0x0000, DEF_STR( Hard ) )         /* table at 0x02f96c */
+	PORT_DIPSETTING(      0x0004, DEF_STR( Hardest ) )      /* table at 0x02f3cc */
+	PORT_DIPNAME( 0x0010, 0x0010, "Bonus Power (Points)" )  PORT_DIPLOCATION("SW1:6")
+	PORT_DIPSETTING(      0x0010, "5k 20k 15k+" )
+	PORT_DIPSETTING(      0x0000, "8k 23k 15k+" )
+	PORT_DIPNAME( 0x0020, 0x0020, "Number of Powers" )      PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(      0x0000, "1" )
 	PORT_DIPSETTING(      0x0020, "2" )
-	PORT_DIPNAME( 0x00c0, 0x0040, "Extra Balls" ) PORT_DIPLOCATION("SW1:7,8")
+	PORT_DIPNAME( 0x00c0, 0x0040, "Extra Balls per Move" )  PORT_DIPLOCATION("SW1:7,8")
 	PORT_DIPSETTING(      0x00c0, "1" )
 	PORT_DIPSETTING(      0x0080, "2" )
 	PORT_DIPSETTING(      0x0040, "3" )
 	PORT_DIPSETTING(      0x0000, "4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0100, 0x0100, "SW2:1" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0200, 0x0200, "SW2:2" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0400, 0x0400, "SW2:3" )
-	PORT_DIPNAME( 0x1800, 0x1000, "Minimum Balls per Row" ) PORT_DIPLOCATION("SW2:4,5")
+	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Unknown ) )      PORT_DIPLOCATION("SW2:1,2")   /* code at 0x021672 - occurs after level 6 */
+	PORT_DIPSETTING(      0x0300, "6/7" )
+	PORT_DIPSETTING(      0x0200, "7/8" )
+	PORT_DIPSETTING(      0x0100, "8/9" )
+	PORT_DIPSETTING(      0x0000, "9/10" )
+	PORT_DIPNAME( 0x0400, 0x0400, "Bonus Power (Bomb)" )    PORT_DIPLOCATION("SW2:3")
+	PORT_DIPSETTING(      0x0400, "3 Chain Reactions" )
+	PORT_DIPSETTING(      0x0000, "4 Chain Reactions" )
+	PORT_DIPNAME( 0x1800, 0x1800, "Minimum Balls per Row" ) PORT_DIPLOCATION("SW2:4,5")
 	PORT_DIPSETTING(      0x1800, "3" )
 	PORT_DIPSETTING(      0x1000, "4" )
 	PORT_DIPSETTING(      0x0800, "5" )
 	PORT_DIPSETTING(      0x0000, "6" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x2000, 0x2000, "SW2:6" )
+	PORT_DIPUNUSED_DIPLOC( 0x2000, 0x2000, "SW2:6" )        /* stored at 0x325414.w but not read back */
 	PORT_SERVICE_DIPLOC( 0x4000, IP_ACTIVE_LOW, "SW2:7" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x8000, 0x8000, "SW2:8" )
+	PORT_DIPUNUSED_DIPLOC( 0x8000, 0x8000, "SW2:8" )        /* stored at 0x325418.w but not read back */
 INPUT_PORTS_END
 
+/* verified from M68000 code */
 static INPUT_PORTS_START( heuksun )
 	PORT_START("P1_P2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
@@ -186,35 +198,44 @@
 	PORT_DIPSETTING(      0x0001, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_2C ) )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0004, 0x0004, "SW1:3" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0008, 0x0008, "SW1:4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0010, 0x0010, "SW1:5" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0020, 0x0020, "SW1:6" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0040, 0x0040, "SW1:7" )
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Difficulty ) )   PORT_DIPLOCATION("SW1:3,4")   /* stored at 0x324632.w */
+	PORT_DIPSETTING(      0x000c, DEF_STR( Easy ) )         /* 1 */
+	PORT_DIPSETTING(      0x0008, DEF_STR( Medium ) )       /* 2 */
+	PORT_DIPSETTING(      0x0004, DEF_STR( Hard ) )         /* 3 */
+	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )      /* 4 */
+	PORT_DIPNAME( 0x0010, 0x0010, "Help Penalty (Heuk Sun)" ) PORT_DIPLOCATION("SW1:5")   /* code at 0x01878e and 0x0187f6 */
+	PORT_DIPSETTING(      0x0010, "Constant" )
+	PORT_DIPSETTING(      0x0000, "Variable" )              /* based on "Difficulty" Dip Switch */
+	PORT_DIPUNUSED_DIPLOC( 0x0020, 0x0020, "SW1:6" )        /* read once during initialisation but not even stored */
+	PORT_DIPUNKNOWN_DIPLOC( 0x0040, 0x0040, "SW1:7" )       /* stored at 0x32463a.w but not read back ? */
 	PORT_SERVICE_DIPLOC( 0x0080, IP_ACTIVE_LOW, "SW1:8" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0100, 0x0100, "SW2:1" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0200, 0x0200, "SW2:2" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0400, 0x0400, "SW2:3" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0800, 0x0800, "SW2:4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x1000, 0x1000, "SW2:5" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x2000, 0x2000, "SW2:6" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x4000, 0x4000, "SW2:7" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x8000, 0x8000, "SW2:8" )
+	/* bits are tested from most to less significant - code at 0x01023e */
+	PORT_DIPNAME( 0xff00, 0xff00, DEF_STR( Unknown ) )      PORT_DIPLOCATION("SW2:1,2,3,4,5,6,7,8") /* stored at 0x324662.w but not read back ? */
+	PORT_DIPSETTING(      0xff00, "0" )
+	PORT_DIPSETTING(      0xfe00, "1" )
+	PORT_DIPSETTING(      0xfd00, "2" )
+	PORT_DIPSETTING(      0xfb00, "3" )
+	PORT_DIPSETTING(      0xf700, "4" )
+	PORT_DIPSETTING(      0xef00, "5" )
+	PORT_DIPSETTING(      0xdf00, "6" )
+	PORT_DIPSETTING(      0xbf00, "7" )
+	PORT_DIPSETTING(      0x7f00, "8" )
 INPUT_PORTS_END
 
+/* verified from M68000 code */
 static INPUT_PORTS_START( bestri )
 	PORT_START("P1_P2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(1)
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(1)
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY PORT_PLAYER(2)
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY PORT_PLAYER(2)
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_PLAYER(2)
@@ -229,24 +250,43 @@
 
 	PORT_START("DSW")
 	PORT_SERVICE_DIPLOC( 0x0001, IP_ACTIVE_LOW, "SW1:1" )
-	PORT_DIPNAME( 0x0006, 0x0002, DEF_STR( Coinage ) ) PORT_DIPLOCATION("SW1:2,3")
+	PORT_DIPNAME( 0x0006, 0x0002, DEF_STR( Coinage ) )      PORT_DIPLOCATION("SW1:2,3")
 	PORT_DIPSETTING(      0x0000, DEF_STR( 3C_1C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0006, DEF_STR( 1C_2C ) )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0008, 0x0008, "SW1:4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0010, 0x0010, "SW1:5" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0020, 0x0020, "SW1:6" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0040, 0x0040, "SW1:7" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0080, 0x0080, "SW1:8" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0100, 0x0100, "SW2:1" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0200, 0x0200, "SW2:2" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0400, 0x0400, "SW2:3" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0800, 0x0800, "SW2:4" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x1000, 0x1000, "SW2:5" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x2000, 0x2000, "SW2:6" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x4000, 0x4000, "SW2:7" )
-	PORT_DIPUNKNOWN_DIPLOC( 0x8000, 0x8000, "SW2:8" )
+	PORT_DIPNAME( 0x0018, 0x0018, DEF_STR( Difficulty ) )   PORT_DIPLOCATION("SW1:4,5")   /* stored at 0x3a6f78.w */
+	PORT_DIPSETTING(      0x0018, DEF_STR( Easy ) )         /* 1 */
+	PORT_DIPSETTING(      0x0008, DEF_STR( Medium ) )       /* 2 */
+	PORT_DIPSETTING(      0x0010, DEF_STR( Hard ) )         /* 3 */
+	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )      /* 4 */
+	PORT_DIPNAME( 0x0020, 0x0020, "Help Penalty (Heuk Sun)" ) PORT_DIPLOCATION("SW1:6")   /* code at 0x0b7152 and 0x07b1ba */
+	PORT_DIPSETTING(      0x0020, "Constant" )
+	PORT_DIPSETTING(      0x0000, "Variable" )              /* based on "Difficulty" Dip Switch */
+	PORT_DIPNAME( 0x00c0, 0x00c0, "Girls" )                 PORT_DIPLOCATION("SW1:7,8")   /* stored at 0x3a6faa.w */
+	PORT_DIPSETTING(      0x00c0, DEF_STR( No ) )
+	PORT_DIPSETTING(      0x0080, DEF_STR( Yes ) )
+//  PORT_DIPSETTING(      0x0040, DEF_STR( No ) )
+//  PORT_DIPSETTING(      0x0000, DEF_STR( No ) )
+	PORT_DIPNAME( 0x0700, 0x0700, DEF_STR( Unknown ) )      PORT_DIPLOCATION("SW2:1,2,3") /* stored at 0x3a6fa6.w but not read back ? */
+	PORT_DIPSETTING(      0x0700, "0" )
+	PORT_DIPSETTING(      0x0300, "1" )
+	PORT_DIPSETTING(      0x0500, "2" )
+	PORT_DIPSETTING(      0x0100, "3" )
+	PORT_DIPSETTING(      0x0600, "4" )
+	PORT_DIPSETTING(      0x0200, "5" )
+	PORT_DIPSETTING(      0x0400, "6" )
+	PORT_DIPSETTING(      0x0000, "7" )
+	PORT_DIPNAME( 0x1800, 0x1800, "Unknown (Die Break)" )   PORT_DIPLOCATION("SW2:4,5")   /* stored at 0x3a6fa8.w */
+	PORT_DIPSETTING(      0x1800, "0" )
+	PORT_DIPSETTING(      0x0800, "1" )
+	PORT_DIPSETTING(      0x1000, "2" )
+	PORT_DIPSETTING(      0x0000, "3" )
+	PORT_DIPNAME( 0x2000, 0x2000, "Time (Penta)" )          PORT_DIPLOCATION("SW2:6")     /* stored at 0x3a6fac.w */
+	PORT_DIPSETTING(      0x0000, "60" )
+	PORT_DIPSETTING(      0x2000, "90" )
+	PORT_DIPUNUSED_DIPLOC( 0x4000, 0x4000, "SW2:7" )        /* read once during initialisation but not even stored */
+	PORT_DIPUNUSED_DIPLOC( 0x8000, 0x8000, "SW2:8" )        /* read once during initialisation but not even stored */
 INPUT_PORTS_END
 
 static const gfx_layout tlayout =
@@ -544,7 +584,6 @@
 	ROM_CONTINUE ( 0x0c0000,0x20000)
 	ROM_CONTINUE ( 0x1c0000,0x20000)
 
-
 	ROM_REGION( 0x200000, "gfx2", 0 ) // sprites
 	ROM_LOAD16_BYTE( "ud14.j12", 0x000000, 0x80000, CRC(141c696e) SHA1(3d35a20f7c12a8d8a9f6d351f06fb9df0c673354) )
 	ROM_LOAD16_BYTE( "ud15.h12", 0x000001, 0x80000, CRC(7c04adc0) SHA1(9883565d6556ce8ae3da6c91cbf04894e87e6923) )
@@ -581,4 +620,4 @@
 
 GAME( 1998, crospang, 0, crospang, crospang, crospang, ROT0, "F2 System", "Cross Pang", GAME_SUPPORTS_SAVE )
 GAME( 199?, heuksun,  0, crospang, heuksun,  crospang, ROT0, "Oksan / F2 System", "Heuk Sun Baek Sa (Korea)", GAME_SUPPORTS_SAVE )
-GAME( 1998, bestri,   0, bestri,   bestri,   crospang, ROT0, "F2 System", "Bestri (Korea)", GAME_SUPPORTS_SAVE )
+GAME( 1998, bestri,   0, bestri,   bestri,   crospang, ROT0, "F2 System", "Bestri (Korea)", GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/crshrace.c src/mame/drivers/crshrace.c
--- src-old/mame/drivers/crshrace.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/crshrace.c	2010-08-15 13:05:41.000000000 -0700
@@ -157,12 +157,9 @@
 
 static WRITE8_HANDLER( crshrace_sh_bankswitch_w )
 {
-	UINT8 *rom = memory_region(space->machine, "audiocpu") + 0x10000;
-
-	memory_set_bankptr(space->machine, "bank1",rom + (data & 0x03) * 0x8000);
+	memory_set_bank(space->machine, "bank1", data & 0x03);
 }
 
-
 static WRITE16_HANDLER( sound_command_w )
 {
 	crshrace_state *state = space->machine->driver_data<crshrace_state>();
@@ -449,6 +446,8 @@
 {
 	crshrace_state *state = machine->driver_data<crshrace_state>();
 
+	memory_configure_bank(machine, "bank1", 0, 4, memory_region(machine, "audiocpu") + 0x10000, 0x8000);
+
 	state->audiocpu = machine->device("audiocpu");
 	state->k053936 = machine->device("k053936");
 
diff -Nru src-old/mame/drivers/crystal.c src/mame/drivers/crystal.c
--- src-old/mame/drivers/crystal.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/crystal.c	2010-08-19 01:27:05.000000000 -0700
@@ -161,13 +161,13 @@
 static void IntReq( running_machine *machine, int num )
 {
 	crystal_state *state = machine->driver_data<crystal_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
-	UINT32 IntEn = memory_read_dword(space, 0x01800c08);
-	UINT32 IntPend = memory_read_dword(space, 0x01800c0c);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	UINT32 IntEn = space->read_dword(0x01800c08);
+	UINT32 IntPend = space->read_dword(0x01800c0c);
 	if (IntEn & (1 << num))
 	{
 		IntPend |= (1 << num);
-		memory_write_dword(space, 0x01800c0c, IntPend);
+		space->write_dword(0x01800c0c, IntPend);
 		cpu_set_input_line(state->maincpu, SE3208_INT, ASSERT_LINE);
 	}
 #ifdef IDLE_LOOP_SPEEDUP
@@ -181,7 +181,7 @@
 	crystal_state *state = space->machine->driver_data<crystal_state>();
 
 #ifdef IDLE_LOOP_SPEEDUP
-	UINT32 IntPend = memory_read_dword(space, 0x01800c0c);
+	UINT32 IntPend = space->read_dword(0x01800c0c);
 	state->FlipCntRead++;
 	if (state->FlipCntRead >= 16 && !IntPend && state->FlipCount != 0)
 		cpu_suspend(state->maincpu, SUSPEND_REASON_SPIN, 1);
@@ -227,12 +227,12 @@
 static WRITE32_HANDLER( IntAck_w )
 {
 	crystal_state *state = space->machine->driver_data<crystal_state>();
-	UINT32 IntPend = memory_read_dword(space, 0x01800c0c);
+	UINT32 IntPend = space->read_dword(0x01800c0c);
 
 	if (mem_mask & 0xff)
 	{
 		IntPend &= ~(1 << (data & 0x1f));
-		memory_write_dword(space, 0x01800c0c, IntPend);
+		space->write_dword(0x01800c0c, IntPend);
 		if (!IntPend)
 			cpu_set_input_line(state->maincpu, SE3208_INT, CLEAR_LINE);
 	}
@@ -243,8 +243,8 @@
 static IRQ_CALLBACK( icallback )
 {
 	crystal_state *state = device->machine->driver_data<crystal_state>();
-	const address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
-	UINT32 IntPend = memory_read_dword(space, 0x01800c0c);
+	address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	UINT32 IntPend = space->read_dword(0x01800c0c);
 	int i;
 
 	for (i = 0; i < 32; ++i)
@@ -280,14 +280,14 @@
 	IntReq(machine, num[which]);
 }
 
-INLINE void Timer_w( const address_space *space, int which, UINT32 data, UINT32 mem_mask )
+INLINE void Timer_w( address_space *space, int which, UINT32 data, UINT32 mem_mask )
 {
 	crystal_state *state = space->machine->driver_data<crystal_state>();
 
 	if (((data ^ state->Timerctrl[which]) & 1) && (data & 1))	//Timer activate
 	{
 		int PD = (data >> 8) & 0xff;
-		int TCV = memory_read_dword(space, 0x01801404 + which * 8);
+		int TCV = space->read_dword(0x01801404 + which * 8);
 		attotime period = attotime_mul(ATTOTIME_IN_HZ(43000000), (PD + 1) * (TCV + 1));
 
 		if (state->Timerctrl[which] & 2)
@@ -392,51 +392,51 @@
 	ds1302_clk_w(state->ds1302, 0, CLK ? 1 : 0);
 
 	if (ds1302_read(state->ds1302, 0))
-		memory_write_dword(space, 0x01802008, memory_read_dword(space, 0x01802008) | 0x10000000);
+		space->write_dword(0x01802008, space->read_dword(0x01802008) | 0x10000000);
 	else
-		memory_write_dword(space, 0x01802008, memory_read_dword(space, 0x01802008) & (~0x10000000));
+		space->write_dword(0x01802008, space->read_dword(0x01802008) & (~0x10000000));
 
 	COMBINE_DATA(&state->PIO);
 }
 
-INLINE void DMA_w( const address_space *space, int which, UINT32 data, UINT32 mem_mask )
+INLINE void DMA_w( address_space *space, int which, UINT32 data, UINT32 mem_mask )
 {
 	crystal_state *state = space->machine->driver_data<crystal_state>();
 
 	if (((data ^ state->DMActrl[which]) & (1 << 10)) && (data & (1 << 10)))	//DMAOn
 	{
 		UINT32 CTR = data;
-		UINT32 SRC = memory_read_dword(space, 0x01800804 + which * 0x10);
-		UINT32 DST = memory_read_dword(space, 0x01800808 + which * 0x10);
-		UINT32 CNT = memory_read_dword(space, 0x0180080C + which * 0x10);
+		UINT32 SRC = space->read_dword(0x01800804 + which * 0x10);
+		UINT32 DST = space->read_dword(0x01800808 + which * 0x10);
+		UINT32 CNT = space->read_dword(0x0180080C + which * 0x10);
 		int i;
 
 		if (CTR & 0x2)	//32 bits
 		{
 			for (i = 0; i < CNT; ++i)
 			{
-				UINT32 v = memory_read_dword(space, SRC + i * 4);
-				memory_write_dword(space, DST + i * 4, v);
+				UINT32 v = space->read_dword(SRC + i * 4);
+				space->write_dword(DST + i * 4, v);
 			}
 		}
 		else if (CTR & 0x1)	//16 bits
 		{
 			for (i = 0; i < CNT; ++i)
 			{
-				UINT16 v = memory_read_word(space, SRC + i * 2);
-				memory_write_word(space, DST + i * 2, v);
+				UINT16 v = space->read_word(SRC + i * 2);
+				space->write_word(DST + i * 2, v);
 			}
 		}
 		else	//8 bits
 		{
 			for (i = 0; i < CNT; ++i)
 			{
-				UINT8 v = memory_read_byte(space, SRC + i);
-				memory_write_byte(space, DST + i, v);
+				UINT8 v = space->read_byte(SRC + i);
+				space->write_byte(DST + i, v);
 			}
 		}
 		data &= ~(1 << 10);
-		memory_write_dword(space, 0x0180080C + which * 0x10, 0);
+		space->write_dword(0x0180080C + which * 0x10, 0);
 		IntReq(space->machine, 7 + which);
 	}
 	COMBINE_DATA(&state->DMActrl[which]);
@@ -621,21 +621,21 @@
 	PatchReset(machine);
 }
 
-static UINT16 GetVidReg( const address_space *space, UINT16 reg )
+static UINT16 GetVidReg( address_space *space, UINT16 reg )
 {
-	return memory_read_word(space, 0x03000000 + reg);
+	return space->read_word(0x03000000 + reg);
 }
 
-static void SetVidReg( const address_space *space, UINT16 reg, UINT16 val )
+static void SetVidReg( address_space *space, UINT16 reg, UINT16 val )
 {
-	memory_write_word(space, 0x03000000 + reg, val);
+	space->write_word(0x03000000 + reg, val);
 }
 
 
 static VIDEO_UPDATE( crystal )
 {
 	crystal_state *state = screen->machine->driver_data<crystal_state>();
-	const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int DoFlip;
 
 	UINT32 B0 = 0x0;
@@ -696,7 +696,7 @@
 static VIDEO_EOF(crystal)
 {
 	crystal_state *state = machine->driver_data<crystal_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 head, tail;
 	int DoFlip = 0;
 
@@ -704,7 +704,7 @@
 	tail = GetVidReg(space, 0x80);
 	while ((head & 0x7ff) != (tail & 0x7ff))
 	{
-		UINT16 Packet0 = memory_read_word(space, 0x03800000 + head * 64);
+		UINT16 Packet0 = space->read_word(0x03800000 + head * 64);
 		if (Packet0 & 0x81)
 			DoFlip = 1;
 		head++;
diff -Nru src-old/mame/drivers/cshooter.c src/mame/drivers/cshooter.c
--- src-old/mame/drivers/cshooter.c	2010-07-09 13:07:39.000000000 -0700
+++ src/mame/drivers/cshooter.c	2010-08-19 07:19:38.000000000 -0700
@@ -661,12 +661,12 @@
 
 static DRIVER_INIT( cshootere )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int A;
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	for (A = 0x0000;A < 0x8000;A++)
 	{
diff -Nru src-old/mame/drivers/cvs.c src/mame/drivers/cvs.c
--- src-old/mame/drivers/cvs.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/cvs.c	2010-08-12 12:45:01.000000000 -0700
@@ -984,21 +984,24 @@
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 static const s2636_interface s2636_1_config =
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 static const s2636_interface s2636_2_config =
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 
diff -Nru src-old/mame/drivers/darkmist.c src/mame/drivers/darkmist.c
--- src-old/mame/drivers/darkmist.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/darkmist.c	2010-08-19 07:19:38.000000000 -0700
@@ -423,7 +423,7 @@
 
 static DRIVER_INIT(darkmist)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i, len;
 	UINT8 *ROM = memory_region(machine, "maincpu");
 	UINT8 *buffer = auto_alloc_array(machine, UINT8, 0x10000);
@@ -457,7 +457,7 @@
 		decrypt[i] = p;
 	}
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 	memory_set_bankptr(space->machine, "bank1",&ROM[0x010000]);
 
 	/* adr line swaps */
diff -Nru src-old/mame/drivers/ddayjlc.c src/mame/drivers/ddayjlc.c
--- src-old/mame/drivers/ddayjlc.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/ddayjlc.c	2010-08-19 01:27:05.000000000 -0700
@@ -232,7 +232,7 @@
 
 		for(i = 0; i < size; i++)
 		{
-			memory_write_byte(space, dst++, memory_read_byte(space, src++));
+			space->write_byte(dst++, space->read_byte(src++));
 		}
 
 		state->e00x_l[0] = 0;
diff -Nru src-old/mame/drivers/ddenlovr.c src/mame/drivers/ddenlovr.c
--- src-old/mame/drivers/ddenlovr.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/ddenlovr.c	2010-08-21 15:25:58.000000000 -0700
@@ -693,12 +693,12 @@
 #endif
 }
 
-static void blitter_w( const address_space *space, int blitter, offs_t offset, UINT8 data, int irq_vector )
+static void blitter_w( address_space *space, int blitter, offs_t offset, UINT8 data, int irq_vector )
 {
 	dynax_state *state = space->machine->driver_data<dynax_state>();
 	int hi_bits;
 
-profiler_mark_start(PROFILER_VIDEO);
+g_profiler.start(PROFILER_VIDEO);
 
 	switch (offset)
 	{
@@ -849,7 +849,7 @@
 		}
 	}
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -861,7 +861,7 @@
 	dynax_state *state = machine->driver_data<dynax_state>();
 	int hi_bits;
 
-profiler_mark_start(PROFILER_VIDEO);
+g_profiler.start(PROFILER_VIDEO);
 
 	switch(offset)
 	{
@@ -1007,7 +1007,7 @@
 		}
 	}
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -1025,7 +1025,7 @@
 	dynax_state *state = space->machine->driver_data<dynax_state>();
 	int hi_bits;
 
-profiler_mark_start(PROFILER_VIDEO);
+g_profiler.start(PROFILER_VIDEO);
 
 	hi_bits = (state->ddenlovr_blit_latch & 0x03) << 8;
 
@@ -1207,7 +1207,7 @@
 			break;
 	}
 
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -3060,7 +3060,7 @@
                              Hanafuda Hana Gokou
 ***************************************************************************/
 
-static UINT8 hgokou_player_r( const address_space *space, int player )
+static UINT8 hgokou_player_r( address_space *space, int player )
 {
 	dynax_state *state = space->machine->driver_data<dynax_state>();
 	UINT8 hopper_bit = ((state->hopper && !(space->machine->primary_screen->frame_number() % 10)) ? 0 : (1 << 6));
diff -Nru src-old/mame/drivers/dec8.c src/mame/drivers/dec8.c
--- src-old/mame/drivers/dec8.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/dec8.c	2010-08-19 07:19:38.000000000 -0700
@@ -54,7 +54,7 @@
 /* Only used by ghostb, gondo, garyoret, other games can control buffering */
 static VIDEO_EOF( dec8 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram_w(space, 0, 0);
 }
 
@@ -3444,7 +3444,7 @@
 static DRIVER_INIT( deco222 )
 {
 	dec8_state *state = machine->driver_data<dec8_state>();
-	const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	int A;
 	UINT8 *decrypt;
 	UINT8 *rom;
@@ -3453,7 +3453,7 @@
 	rom = memory_region(machine, "audiocpu");
 	decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 
-	memory_set_decrypted_region(space, 0x8000, 0xffff, decrypt);
+	space->set_decrypted_region(0x8000, 0xffff, decrypt);
 
 	for (A = 0x8000; A < 0x10000; A++)
 		decrypt[A - 0x8000] = (rom[A] & 0x9f) | ((rom[A] & 0x20) << 1) | ((rom[A] & 0x40) >> 1);
diff -Nru src-old/mame/drivers/deco32.c src/mame/drivers/deco32.c
--- src-old/mame/drivers/deco32.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/deco32.c	2010-08-19 01:27:05.000000000 -0700
@@ -495,7 +495,7 @@
 	static int readBitCount=0;
 	static int byteAddr=0;
 	eeprom_device *eeprom = space->machine->device<eeprom_device>("eeprom");
-	const address_space *eeprom_space = eeprom->space();
+	address_space *eeprom_space = eeprom->space();
 
 	/* Eprom in low byte */
 	if (mem_mask==0x000000ff) { /* Byte write to low byte only (different from word writing including low byte) */
@@ -545,7 +545,7 @@
 				int d=readBitCount/8;
 				int m=7-(readBitCount%8);
 				int a=(byteAddr+d)%1024;
-				int b=memory_read_byte(eeprom_space, a);
+				int b=eeprom_space->read_byte(a);
 
 				tattass_eprom_bit=(b>>m)&1;
 
@@ -562,7 +562,7 @@
 					int b=(buffer[24]<<7)|(buffer[25]<<6)|(buffer[26]<<5)|(buffer[27]<<4)
 						|(buffer[28]<<3)|(buffer[29]<<2)|(buffer[30]<<1)|(buffer[31]<<0);
 
-					memory_write_byte(eeprom_space, byteAddr, b);
+					eeprom_space->write_byte(byteAddr, b);
 				}
 				lastClock=data&0x20;
 				return;
@@ -577,7 +577,7 @@
 
 				/* Check for read command */
 				if (buffer[0] && buffer[1]) {
-					tattass_eprom_bit=(memory_read_byte(eeprom_space, byteAddr)>>7)&1;
+					tattass_eprom_bit=(eeprom_space->read_byte(byteAddr)>>7)&1;
 					readBitCount=1;
 					pendingCommand=1;
 				}
diff -Nru src-old/mame/drivers/decocass.c src/mame/drivers/decocass.c
--- src-old/mame/drivers/decocass.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/decocass.c	2010-08-19 07:19:38.000000000 -0700
@@ -1356,15 +1356,15 @@
 static DRIVER_INIT( decocass )
 {
 	decocass_state *state = machine->driver_data<decocass_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int A;
 
 	/* allocate memory and mark all RAM regions with their decrypted pointers */
 	state->decrypted = auto_alloc_array(machine, UINT8, 0x10000);
-	memory_set_decrypted_region(space, 0x0000, 0xc7ff, &state->decrypted[0x0000]);
-	memory_set_decrypted_region(space, 0xd000, 0xdbff, &state->decrypted[0xd000]);
-	memory_set_decrypted_region(space, 0xf000, 0xffff, &state->decrypted[0xf000]);
+	space->set_decrypted_region(0x0000, 0xc7ff, &state->decrypted[0x0000]);
+	space->set_decrypted_region(0xd000, 0xdbff, &state->decrypted[0xd000]);
+	space->set_decrypted_region(0xf000, 0xffff, &state->decrypted[0xf000]);
 
 	/* Swap bits 5 & 6 for opcodes */
 	for (A = 0xf000; A < 0x10000; A++)
diff -Nru src-old/mame/drivers/dkong.c src/mame/drivers/dkong.c
--- src-old/mame/drivers/dkong.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/dkong.c	2010-08-30 08:20:58.000000000 -0700
@@ -296,6 +296,17 @@
     2764.5Cp    DJR1-C-5C p    2764   5C(CPU)  F4FE
     ------------------------------------------------
 
+
+    D2K Jumpman returns Notes
+    =========================
+
+    This is a DKong/Hack combo using a Braze Technologies High Score Save pcb.
+    This pcb will be placed in the cpu socket and the Z80 together with an
+    additional 64K rom, a 74LS245, an eeprom and a pal/gal. It looks like the
+    "encryption" was a conincidence resulting from an easy pcb layout.
+    The pal is also used to switch A15 on and off. This is done in locations
+    6800 and E800.
+
 ***************************************************************************/
 
 #include "emu.h"
@@ -306,6 +317,7 @@
 #include "machine/8257dma.h"
 #include "machine/z80dma.h"
 #include "machine/latch8.h"
+#include "machine/eeprom.h"
 
 /*************************************
  *
@@ -335,6 +347,9 @@
  *
  *************************************/
 
+static UINT8 memory_read_byte(address_space *space, offs_t address) { return space->read_byte(address); }
+static void memory_write_byte(address_space *space, offs_t address, UINT8 data) { space->write_byte(address, data); }
+
 static Z80DMA_INTERFACE( dk3_dma )
 {
 	DEVCB_CPU_INPUT_LINE("maincpu", INPUT_LINE_HALT),
@@ -513,7 +528,7 @@
 
     addr = ((bucket << 7) & 0x7c00) | (offset & 0x3ff);
 
-    return memory_read_byte(space, addr);
+    return space->read_byte(addr);
 }
 
 static WRITE8_HANDLER( hb_dma_write_byte )
@@ -527,7 +542,7 @@
 
     addr = ((bucket << 7) & 0x7c00) | (offset & 0x3ff);
 
-    memory_write_byte(space, addr, data);
+    space->write_byte(addr, data);
 }
 
 static READ8_DEVICE_HANDLER( p8257_ctl_r )
@@ -589,13 +604,13 @@
 
 static READ8_HANDLER( s2650_mirror_r )
 {
-    return memory_read_byte(space, 0x1000 + offset);
+    return space->read_byte(0x1000 + offset);
 }
 
 
 static WRITE8_HANDLER( s2650_mirror_w )
 {
-    memory_write_byte(space, 0x1000 + offset, data);
+    space->write_byte(0x1000 + offset, data);
 }
 
 
@@ -1031,6 +1046,21 @@
     PORT_DIPSETTING(    0x60, DEF_STR( 1C_4C ) )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( dkongx )	/* Supposedly the physical DIPS are read as defaults for the NVRAM when it's initially created.
+                                           The settings here match those from the default DSW0 settings.  Beyond the initial NVRAM
+                                           creation, DIPS (other than CABINET) can only be adjusted from the Service Mode */
+    PORT_INCLUDE( dkong )
+
+    PORT_MODIFY("DSW0")
+    PORT_DIPUNUSED_DIPLOC( 0x01, 0x00, "SW1:!1" )
+    PORT_DIPUNUSED_DIPLOC( 0x02, 0x00, "SW1:!2" )
+    PORT_DIPUNUSED_DIPLOC( 0x04, 0x00, "SW1:!3" )
+    PORT_DIPUNUSED_DIPLOC( 0x08, 0x00, "SW1:!4" )
+    PORT_DIPUNUSED_DIPLOC( 0x10, 0x00, "SW1:!5" )
+    PORT_DIPUNUSED_DIPLOC( 0x20, 0x00, "SW1:!6" )
+    PORT_DIPUNUSED_DIPLOC( 0x40, 0x00, "SW1:!7" )
+INPUT_PORTS_END
+
 static INPUT_PORTS_START( radarscp )
     PORT_INCLUDE( radarscp_in0_2 )
     PORT_INCLUDE( radarscp_in1_2 )
@@ -1569,6 +1599,61 @@
 
 /*************************************
  *
+ *  Braze Tech Addon boards
+ *
+ *************************************/
+
+static const eeprom_interface braze_eeprom_intf =
+{
+	7,				/* address bits */
+	8,				/* data bits */
+	"*110",			/* read command */
+	"*101",			/* write command */
+	0,				/* erase command */
+	"*10000xxxxx",	/* lock command */
+	"*10011xxxxx",	/* unlock command */
+};
+
+static READ8_DEVICE_HANDLER( braze_eeprom_r )
+{
+	return eeprom_read_bit(device);
+}
+
+static WRITE8_HANDLER( braze_a15_w )
+{
+	memory_set_bank(space->machine, "bank1", data & 0x01);
+	memory_set_bank(space->machine, "bank2", data & 0x01);
+}
+
+static WRITE8_DEVICE_HANDLER( braze_eeprom_w )
+{
+	eeprom_write_bit(device, data & 0x01);
+	eeprom_set_cs_line(device, data & 0x04 ? CLEAR_LINE : ASSERT_LINE);
+	eeprom_set_clock_line(device, data & 0x02 ? ASSERT_LINE : CLEAR_LINE);
+}
+
+static void braze_decrypt_rom(running_machine *machine, UINT8 *dest)
+{
+	UINT8 oldbyte,newbyte;
+	UINT8 *ROM;
+	UINT32 mem;
+	UINT32 newmem;
+
+	ROM = memory_region(machine, "braze");
+
+	for (mem=0;mem<0x10000;mem++)
+	{
+		oldbyte = ROM[mem];
+
+		newmem = ((BITSWAP8((mem >> 8),7,2,3,1,0,6,4,5))<<8) | (mem & 0xff);
+		newbyte = BITSWAP8(oldbyte, 1,4,5,7,6,0,3,2);
+
+		dest[newmem] = newbyte;
+	}
+}
+
+/*************************************
+ *
  *  Machine driver
  *
  *************************************/
@@ -1641,6 +1726,12 @@
 
 MACHINE_DRIVER_END
 
+static MACHINE_DRIVER_START( braze )
+	MDRV_IMPORT_FROM(dkong2b)
+
+	MDRV_EEPROM_ADD("eeprom", braze_eeprom_intf)
+MACHINE_DRIVER_END
+
 static MACHINE_DRIVER_START( dkong3 )
 
     /* driver data */
@@ -2025,6 +2116,70 @@
     ROM_LOAD( "v-5e.bpr",     0x0200, 0x0100, CRC(b869b8f5) SHA1(c2bdccbf2654b64ea55cd589fd21323a9178a660) ) /* character color codes on a per-column basis */
 ROM_END
 
+ROM_START( dkongx )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "c_5et_g.bin",  0x0000, 0x1000, CRC(ba70b88b) SHA1(d76ebecfea1af098d843ee7e578e480cd658ac1a) )
+	ROM_LOAD( "c_5ct_g.bin",  0x1000, 0x1000, CRC(5ec461ec) SHA1(acb11a8fbdbb3ab46068385fe465f681e3c824bd) )
+	ROM_LOAD( "c_5bt_g.bin",  0x2000, 0x1000, CRC(1c97d324) SHA1(c7966261f3a1d3296927e0b6ee1c58039fc53c1f) )
+	ROM_LOAD( "c_5at_g.bin",  0x3000, 0x1000, CRC(b9005ac0) SHA1(3fe3599f6fa7c496f782053ddf7bacb453d197c4) )
+	/* space for diagnostic ROM */
+
+	ROM_REGION( 0x10000, "braze", 0 )
+	ROM_LOAD( "d2k12.bin",  0x0000, 0x10000,  CRC(6e95ca0d) SHA1(c058add0f146d577e3df0ba60828fe1734e78d01) ) /* Version 1.2 */
+
+	ROM_REGION( 0x1800, "soundcpu", 0 )	/* sound */
+	ROM_LOAD( "s_3i_b.bin",   0x0000, 0x0800, CRC(45a4ed06) SHA1(144d24464c1f9f01894eb12f846952290e6e32ef) )
+	ROM_RELOAD(               0x0800, 0x0800 )
+	ROM_LOAD( "s_3j_b.bin",   0x1000, 0x0800, CRC(4743fe92) SHA1(6c82b57637c0212a580591397e6a5a1718f19fd2) )
+
+	ROM_REGION( 0x1000, "gfx1", 0 )
+	ROM_LOAD( "v_5h_b.bin",   0x0000, 0x0800, CRC(12c8c95d) SHA1(a57ff5a231c45252a63b354137c920a1379b70a3) )
+	ROM_LOAD( "v_3pt.bin",    0x0800, 0x0800, CRC(15e9c5e9) SHA1(976eb1e18c74018193a35aa86cff482ebfc5cc4e) )
+
+	ROM_REGION( 0x2000, "gfx2", 0 )
+	ROM_LOAD( "l_4m_b.bin",   0x0000, 0x0800, CRC(59f8054d) SHA1(793dba9bf5a5fe76328acdfb90815c243d2a65f1) )
+	ROM_LOAD( "l_4n_b.bin",   0x0800, 0x0800, CRC(672e4714) SHA1(92e5d379f4838ac1fa44d448ce7d142dae42102f) )
+	ROM_LOAD( "l_4r_b.bin",   0x1000, 0x0800, CRC(feaa59ee) SHA1(ecf95db5a20098804fc8bd59232c66e2e0ed3db4) )
+	ROM_LOAD( "l_4s_b.bin",   0x1800, 0x0800, CRC(20f2ef7e) SHA1(3bc482a38bf579033f50082748ee95205b0f673d) )
+
+	ROM_REGION( 0x0300, "proms", 0 )
+	ROM_LOAD( "c-2k.bpr",     0x0000, 0x0100, CRC(e273ede5) SHA1(b50ec9e1837c00c20fb2a4369ec7dd0358321127) ) /* palette low 4 bits (inverted) */
+	ROM_LOAD( "c-2j.bpr",     0x0100, 0x0100, CRC(d6412358) SHA1(f9c872da2fe8e800574ae3bf483fb3ccacc92eb3) ) /* palette high 4 bits (inverted) */
+	ROM_LOAD( "v-5e.bpr",     0x0200, 0x0100, CRC(b869b8f5) SHA1(c2bdccbf2654b64ea55cd589fd21323a9178a660) ) /* character color codes on a per-column basis */
+ROM_END
+
+ROM_START( dkongx11 )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "c_5et_g.bin",  0x0000, 0x1000, CRC(ba70b88b) SHA1(d76ebecfea1af098d843ee7e578e480cd658ac1a) )
+	ROM_LOAD( "c_5ct_g.bin",  0x1000, 0x1000, CRC(5ec461ec) SHA1(acb11a8fbdbb3ab46068385fe465f681e3c824bd) )
+	ROM_LOAD( "c_5bt_g.bin",  0x2000, 0x1000, CRC(1c97d324) SHA1(c7966261f3a1d3296927e0b6ee1c58039fc53c1f) )
+	ROM_LOAD( "c_5at_g.bin",  0x3000, 0x1000, CRC(b9005ac0) SHA1(3fe3599f6fa7c496f782053ddf7bacb453d197c4) )
+	/* space for diagnostic ROM */
+
+	ROM_REGION( 0x10000, "braze", 0 )
+	ROM_LOAD( "d2k11.bin",    0x00000, 0x10000, CRC(2048fc42) SHA1(e427a09ed8e792ee8ce01cd0b07c6a0d5a7c5536) ) /* Version 1.1 */
+
+	ROM_REGION( 0x1800, "soundcpu", 0 )	/* sound */
+	ROM_LOAD( "s_3i_b.bin",   0x0000, 0x0800, CRC(45a4ed06) SHA1(144d24464c1f9f01894eb12f846952290e6e32ef) )
+	ROM_RELOAD(               0x0800, 0x0800 )
+	ROM_LOAD( "s_3j_b.bin",   0x1000, 0x0800, CRC(4743fe92) SHA1(6c82b57637c0212a580591397e6a5a1718f19fd2) )
+
+	ROM_REGION( 0x1000, "gfx1", 0 )
+	ROM_LOAD( "v_5h_b.bin",   0x0000, 0x0800, CRC(12c8c95d) SHA1(a57ff5a231c45252a63b354137c920a1379b70a3) )
+	ROM_LOAD( "v_3pt.bin",    0x0800, 0x0800, CRC(15e9c5e9) SHA1(976eb1e18c74018193a35aa86cff482ebfc5cc4e) )
+
+	ROM_REGION( 0x2000, "gfx2", 0 )
+	ROM_LOAD( "l_4m_b.bin",   0x0000, 0x0800, CRC(59f8054d) SHA1(793dba9bf5a5fe76328acdfb90815c243d2a65f1) )
+	ROM_LOAD( "l_4n_b.bin",   0x0800, 0x0800, CRC(672e4714) SHA1(92e5d379f4838ac1fa44d448ce7d142dae42102f) )
+	ROM_LOAD( "l_4r_b.bin",   0x1000, 0x0800, CRC(feaa59ee) SHA1(ecf95db5a20098804fc8bd59232c66e2e0ed3db4) )
+	ROM_LOAD( "l_4s_b.bin",   0x1800, 0x0800, CRC(20f2ef7e) SHA1(3bc482a38bf579033f50082748ee95205b0f673d) )
+
+	ROM_REGION( 0x0300, "proms", 0 )
+	ROM_LOAD( "c-2k.bpr",     0x0000, 0x0100, CRC(e273ede5) SHA1(b50ec9e1837c00c20fb2a4369ec7dd0358321127) ) /* palette low 4 bits (inverted) */
+	ROM_LOAD( "c-2j.bpr",     0x0100, 0x0100, CRC(d6412358) SHA1(f9c872da2fe8e800574ae3bf483fb3ccacc92eb3) ) /* palette high 4 bits (inverted) */
+	ROM_LOAD( "v-5e.bpr",     0x0200, 0x0100, CRC(b869b8f5) SHA1(c2bdccbf2654b64ea55cd589fd21323a9178a660) ) /* character color codes on a per-column basis */
+ROM_END
+
 ROM_START( dkongjr )
     ROM_REGION( 0x10000, "maincpu", 0 )
     ROM_LOAD( "dkj.5b",       0x0000, 0x1000, CRC(dea28158) SHA1(08baf84ae6f9b40a2c743fe1d8c158c74a40e95a) )
@@ -2941,6 +3096,31 @@
     memory_install_read8_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x7c80, 0x7c80, 0, 0, strtheat_inputport_1_r);
 }
 
+
+static DRIVER_INIT( dkongx )
+{
+	UINT8 *decrypted;
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	running_device *eeprom = machine->device("eeprom");
+
+	decrypted = auto_alloc_array(machine, UINT8, 0x10000);
+
+	memory_install_read_bank(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x0000, 0x5fff, 0, 0, "bank1" );
+    memory_install_read_bank(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x8000, 0xffff, 0, 0, "bank2" );
+
+	memory_install_write8_handler(space, 0xe000, 0xe000, 0, 0, braze_a15_w);
+
+	memory_install_read8_device_handler(space, eeprom, 0xc800, 0xc800, 0, 0, braze_eeprom_r);
+	memory_install_write8_device_handler(space, eeprom, 0xc800, 0xc800, 0, 0, braze_eeprom_w);
+
+	braze_decrypt_rom(machine, decrypted);
+
+	memory_configure_bank(machine,"bank1", 0, 2, &decrypted[0], 0x8000);
+	memory_set_bank(machine,"bank1", 0);
+	memory_configure_bank(machine,"bank2", 0, 2, &decrypted[0], 0x8000);
+	memory_set_bank(machine,"bank2", 0);
+}
+
 /*************************************
  *
  *  Game drivers
@@ -2954,8 +3134,10 @@
 GAME( 1981, dkongo,   dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (US set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1981, dkongj,   dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1981, dkongjo,  dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 2)", GAME_SUPPORTS_SAVE )
-GAME( 1981, dkongjo1, dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 3) (bad dump?)", GAME_SUPPORTS_SAVE )
+GAME( 1981, dkongjo1, dkong,    dkong2b,  dkong,          0,  ROT90, "Nintendo", "Donkey Kong (Japan set 3)", GAME_SUPPORTS_SAVE )
 GAME( 2004, dkongf,   dkong,    dkong2b,  dkongf,         0,  ROT90, "hack", "Donkey Kong Foundry (hack)", GAME_SUPPORTS_SAVE ) /* from Jeff's Romhack */
+GAME( 2006, dkongx,   dkong,    braze,    dkongx,    dkongx,  ROT90, "hack", "Donkey Kong II - Jumpman Returns (V1.2) (hack)", GAME_SUPPORTS_SAVE )
+GAME( 2006, dkongx11, dkong,    braze,    dkongx,    dkongx,  ROT90, "hack", "Donkey Kong II - Jumpman Returns (V1.1) (hack)", GAME_SUPPORTS_SAVE )
 
 GAME( 1982, dkongjr,  0,        dkongjr,  dkongjr,        0,  ROT90, "Nintendo of America", "Donkey Kong Junior (US)", GAME_SUPPORTS_SAVE )
 GAME( 1982, dkongjrj, dkongjr,  dkongjr,  dkongjr,        0,  ROT90, "Nintendo", "Donkey Kong Jr. (Japan)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/dooyong.c src/mame/drivers/dooyong.c
--- src-old/mame/drivers/dooyong.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/dooyong.c	2010-08-23 12:39:46.000000000 -0700
@@ -58,7 +58,6 @@
 #include "sound/okim6295.h"
 #include "includes/dooyong.h"
 
-
 static WRITE8_HANDLER( lastday_bankswitch_w )
 {
 	memory_set_bank(space->machine, "bank1", data & 0x07);
@@ -173,7 +172,7 @@
 	AM_RANGE(0xe020, 0xe020) AM_WRITE(soundlatch_w)
 	AM_RANGE(0xe030, 0xe037) AM_WRITE(dooyong_bgscroll8_w)
 	AM_RANGE(0xe040, 0xe047) AM_WRITE(dooyong_fgscroll8_w)
-	AM_RANGE(0xe800, 0xefff) AM_RAM_WRITE(paletteram_xRRRRRGGGGGBBBBB_le_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0xe800, 0xefff) AM_RAM_WRITE(paletteram_flytiger_w) AM_BASE(&paletteram_flytiger)
 	AM_RANGE(0xf000, 0xffff) AM_RAM_WRITE(dooyong_txvideoram8_w) AM_BASE(&dooyong_txvideoram)
 ADDRESS_MAP_END
 
@@ -1849,7 +1848,7 @@
 GAME( 1991, pollux,   0,        pollux,   pollux,   0, ROT270, "Dooyong",  "Pollux (set 1)",       GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1991, polluxa,  pollux,   pollux,   pollux,   0, ROT270, "Dooyong",  "Pollux (set 2)",       GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1991, polluxa2, pollux,   pollux,   pollux,   0, ROT270, "Dooyong",  "Pollux (set 3)",       GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE ) /* Original Dooyong Board distributed by TCH */
-GAME( 1992, flytiger, 0,        flytiger, flytiger, 0, ROT270, "Dooyong",  "Flying Tiger",         GAME_IMPERFECT_GRAPHICS | GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE )
+GAME( 1992, flytiger, 0,        flytiger, flytiger, 0, ROT270, "Dooyong",  "Flying Tiger",         GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
 GAME( 1993, bluehawk, 0,        bluehawk, bluehawk, 0, ROT270, "Dooyong",  "Blue Hawk",            GAME_SUPPORTS_SAVE )
 GAME( 1993, bluehawkn,bluehawk, bluehawk, bluehawk, 0, ROT270, "Dooyong (NTC license)", "Blue Hawk (NTC)", GAME_SUPPORTS_SAVE )
 GAME( 1993, sadari,   0,        primella, sadari,   0, ROT0,   "Dooyong (NTC license)", "Sadari",  GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/enigma2.c src/mame/drivers/enigma2.c
--- src-old/mame/drivers/enigma2.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/enigma2.c	2010-08-30 08:20:58.000000000 -0700
@@ -173,7 +173,6 @@
 	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_NMI, CLEAR_LINE);
 
 	state->last_sound_data = 0;
-	state->protection_data = 0;
 	state->flip_screen = 0;
 	state->sound_latch = 0;
 	state->blink_count = 0;
@@ -359,6 +358,8 @@
 	switch (offset)
 	{
 	case 0x01:
+		/* For the DIP switches to be read, protection_data must be
+           0xff on reset. The AY8910 reset ensures this. */
 		if (state->protection_data != 0xff)
 			ret = state->protection_data ^ 0x88;
 		else
diff -Nru src-old/mame/drivers/eolithsp.c src/mame/drivers/eolithsp.c
--- src-old/mame/drivers/eolithsp.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/eolithsp.c	2010-08-19 00:26:14.000000000 -0700
@@ -17,7 +17,7 @@
 static int eolith_vblank = 0;
 static int eolith_scanline = 0;
 
-void eolith_speedup_read(const address_space *space)
+void eolith_speedup_read(address_space *space)
 {
 	/* for debug */
 //  if ((cpu_get_pc(space->cpu)!=eolith_speedup_address) && (eolith_vblank!=1) )
diff -Nru src-old/mame/drivers/ertictac.c src/mame/drivers/ertictac.c
--- src-old/mame/drivers/ertictac.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/ertictac.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,184 +1,57 @@
-/*********************************************************************
- Erotictac/Tactic [Sisteme 1992]
- (title depends on "Sexy Views" DIP)
-
- driver by
-  Tomasz Slanina
-  Steve Ellenoff
-    Nicola Salmoria
-
-TODO:
- - sound
-    my guess:
-     - data (samples?) in mem range 0000-$0680 ($1f00000 - $1f00680)
-     - 4 chn?? ( masks $000000ff, $0000ff00, $00ff0000, $ff000000)
-     - INT7 (bit 1 in IRQRQB) = sound hw 'ready' flag (checked at $56c)
-     - writes to 3600000 - 3ffffff related to snd hardware
-
- - game doesn't work with 'demo sound' disabled
- - get rid of dirty hack in DRIVER_INIT (bug in the ARM core?)
- - is screen double buffered ?
- - flashing text in test mode
+/*******************************************************************************************
 
-  Poizone PCB appears to be a Jamam Acorn Archimedes based system,
-   Poizone was also released on the AA computer.
+    Erotictac/Tactic (c) 1990 Sisteme
+    Poizone (c) 1991 Eterna
 
- - Poizone controls are checked exactly once at bootup, breaking them.
+    Actually an Acorn Archimedes-based Arcade system
 
-**********************************************************************/
+    original driver by Tomasz Slanina, Steve Ellenoff, Nicola Salmoria
+    rewrite to use AA functions by R.Belmont & Angelo Salese
+    special thanks to Tom Walker (author of the Acorn Archimedes Arculator emulator)
+
+    TODO (specific issues only):
+    - Sound is currently ugly in both games, recognizable but still nowhere near perfection
+    - ertictac: 'music' dip-sw makes the game to just hang, BGM doesn't play either for
+                whatever reason (should be triggered as soon as it executes the POST)
+    - poizone: ARM core bugs causes it to crash at some point.
+    - Does this Arcade conversion have I2C device? It seems unused afaik.
+    - Need PCB for identify the exact model of AA, available RAM, what kind of i/o "podule"
+      it has etc.
+
+*******************************************************************************************/
 #include "emu.h"
 #include "cpu/arm/arm.h"
+#include "sound/dac.h"
+#include "includes/archimds.h"
+#include "machine/i2cmem.h"
 
-#define NUM_PENS	(0x100)
-
-static UINT32 *ertictac_mainram;
-static UINT32 *ertictac_videoram;
-static UINT32 IRQSTA, IRQMSKA, IRQMSKB, FIQMSK, T1low, T1high;
-static UINT32 vidFIFO[256];
-static pen_t pens[NUM_PENS];
-
-static WRITE32_HANDLER(video_fifo_w)
-{
-	vidFIFO[data >> 24] = data & 0xffffff;
-}
-
-static READ32_HANDLER(IOCR_r)
-{
-	return (input_port_read(space->machine, "dummy") & 0x80) | 0x34;
-}
-
-static WRITE32_HANDLER(IOCR_w)
-{
-	//ignored
-}
-
-
-static READ32_HANDLER(IRQSTA_r)
-{
-	return (IRQSTA & (~2)) | 0x80;
-}
-
-static READ32_HANDLER(IRQRQA_r)
-{
-	return (IRQSTA & IRQMSKA) | 0x80;
-}
-
-static WRITE32_HANDLER(IRQRQA_w)
-{
-	if(ACCESSING_BITS_0_7)
-		IRQSTA &= ~data;
-}
-
-static READ32_HANDLER(IRQMSKA_r)
-{
-	return IRQMSKA;
-}
-
-static WRITE32_HANDLER(IRQMSKA_w)
-{
-	if(ACCESSING_BITS_0_7)
-		IRQMSKA = (data & (~2)) | 0x80;
-}
-
-static READ32_HANDLER(IRQRQB_r)
-{
-	return mame_rand(space->machine) & IRQMSKB; /* hack  0x20 - controls,  0x02 - ?sound? */
-}
-
-static READ32_HANDLER(IRQMSKB_r)
-{
-	return IRQMSKB;
-}
-
-static WRITE32_HANDLER(IRQMSKB_w)
-{
-	if(ACCESSING_BITS_0_7)
-		IRQMSKB = data;
-}
-
-static READ32_HANDLER(FIQMSK_r)
-{
-	return FIQMSK;
-}
-
-static WRITE32_HANDLER(FIQMSK_w)
-{
-	if(ACCESSING_BITS_0_7)
-		FIQMSK = (data & (~0x2c)) | 0x80;
-}
-
-static READ32_HANDLER(T1low_r)
-{
-	return T1low;
-}
-
-static WRITE32_HANDLER(T1low_w)
-{
-	if(ACCESSING_BITS_0_7)
-		T1low = data;
-}
-
-static READ32_HANDLER(T1high_r)
-{
-	return T1high;
-}
-
-static WRITE32_HANDLER(T1high_w)
+static READ32_HANDLER( ertictac_podule_r )
 {
-	if(ACCESSING_BITS_0_7)
-		T1high = data;
-}
-
-static void startTimer(running_machine *machine);
+	ioc_regs[IRQ_STATUS_B] &= ~ARCHIMEDES_IRQB_PODULE_IRQ;
 
-static TIMER_CALLBACK( ertictacTimer )
-{
-	IRQSTA |= 0x40;
-	if(IRQMSKA & 0x40)
+	switch(offset)
 	{
-		cputag_set_input_line(machine, "maincpu", ARM_IRQ_LINE, HOLD_LINE);
+		case 0x04/4: return input_port_read(space->machine, "DSW1") & 0xff;
+		case 0x08/4: return input_port_read(space->machine, "DSW2") & 0xff;
+		case 0x10/4: return input_port_read(space->machine, "SYSTEM") & 0xff;
+		case 0x14/4: return input_port_read(space->machine, "P2") & 0xff;
+		case 0x18/4: return input_port_read(space->machine, "P1") & 0xff;
 	}
-	startTimer(machine);
-}
 
-static void startTimer(running_machine *machine)
-{
-	timer_set(machine, ATTOTIME_IN_USEC(((T1low & 0xff) | ((T1high & 0xff) << 8)) >> 4), NULL, 0, ertictacTimer);
-}
-
-static WRITE32_HANDLER(T1GO_w)
-{
-	startTimer(space->machine);
+	return 0;
 }
 
 static ADDRESS_MAP_START( ertictac_map, ADDRESS_SPACE_PROGRAM, 32 )
-	AM_RANGE(0x00000000, 0x0007ffff) AM_RAM AM_BASE (&ertictac_mainram)
-	AM_RANGE(0x01f00000, 0x01ffffff) AM_RAM AM_BASE (&ertictac_videoram)
-	AM_RANGE(0x03200000, 0x03200003) AM_READWRITE(IOCR_r, IOCR_w)
-	AM_RANGE(0x03200010, 0x03200013) AM_READ(IRQSTA_r)
-	AM_RANGE(0x03200014, 0x03200017) AM_READWRITE(IRQRQA_r, IRQRQA_w)
-	AM_RANGE(0x03200018, 0x0320001b) AM_READWRITE(IRQMSKA_r, IRQMSKA_w)
-	AM_RANGE(0x03200024, 0x03200027) AM_READ(IRQRQB_r)
-	AM_RANGE(0x03200028, 0x0320002b) AM_READWRITE(IRQMSKB_r, IRQMSKB_w)
-	AM_RANGE(0x03200038, 0x0320003b) AM_READWRITE(FIQMSK_r, FIQMSK_w)
-
-	AM_RANGE(0x03200050, 0x03200053) AM_READWRITE(T1low_r, T1low_w)
-	AM_RANGE(0x03200054, 0x03200057) AM_READWRITE(T1high_r, T1high_w)
-	AM_RANGE(0x03200058, 0x0320005b) AM_WRITE( T1GO_w )
-
-	AM_RANGE(0x03340000, 0x03340003) AM_NOP
-	AM_RANGE(0x03340010, 0x03340013) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0x03340014, 0x03340017) AM_READ_PORT("P2")
-	AM_RANGE(0x03340018, 0x0334001b) AM_READ_PORT("P1")
-
-	AM_RANGE(0x033c0004, 0x033c0007) AM_READ_PORT("DSW1")
-	AM_RANGE(0x033c0008, 0x033c000b) AM_READ_PORT("DSW2")
-	AM_RANGE(0x033c0010, 0x033c0013) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0x033c0014, 0x033c0017) AM_READ_PORT("P2")
-	AM_RANGE(0x033c0018, 0x033c001b) AM_READ_PORT("P1")
+	AM_RANGE(0x00000000, 0x01ffffff) AM_READWRITE(archimedes_memc_logical_r, archimedes_memc_logical_w)
+	AM_RANGE(0x02000000, 0x02ffffff) AM_RAM AM_BASE(&archimedes_memc_physmem) /* physical RAM - 16 MB for now, should be 512k for the A310 */
+
+	AM_RANGE(0x03340000, 0x0334001f) AM_READ(ertictac_podule_r)
+	AM_RANGE(0x033c0000, 0x033c001f) AM_READ(ertictac_podule_r)
 
-	AM_RANGE(0x03400000, 0x03400003) AM_WRITE(video_fifo_w)
-	AM_RANGE(0x03800000, 0x03ffffff) AM_ROM AM_REGION("user1", 0)
+	AM_RANGE(0x03000000, 0x033fffff) AM_READWRITE(archimedes_ioc_r, archimedes_ioc_w)
+	AM_RANGE(0x03400000, 0x035fffff) AM_READWRITE(archimedes_vidc_r, archimedes_vidc_w)
+	AM_RANGE(0x03600000, 0x037fffff) AM_READWRITE(archimedes_memc_r, archimedes_memc_w)
+	AM_RANGE(0x03800000, 0x03ffffff) AM_ROM AM_REGION("maincpu", 0) AM_WRITE(archimedes_memc_page_w)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START( ertictac )
@@ -194,6 +67,7 @@
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(1)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(1)
+	PORT_BIT( 0x00c4, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("P2")
 	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
@@ -201,6 +75,7 @@
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(2)
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(2)
+	PORT_BIT( 0x00c4, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("DSW1")
 	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Language ) )
@@ -247,44 +122,30 @@
 	PORT_DIPSETTING(    0x20, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Yes ) )
 
-	PORT_START("dummy")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_DIPNAME( 0x40, 0x40, "2-7" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "2-8" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
 static INPUT_PORTS_START( poizone )
-	PORT_START("SYSTEM")
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_START2 )
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_START1 )
-	PORT_BIT( 0x08, IP_ACTIVE_HIGH, IPT_COIN2 ) PORT_IMPULSE(1)
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 ) PORT_IMPULSE(1)
-
-	PORT_START("P1")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(1)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(1)
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(1)
-
-	PORT_START("P2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_PLAYER(2)
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_PLAYER(2)
-	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_PLAYER(2)
+	PORT_INCLUDE( ertictac )
 
-	PORT_START("DSW1")
-	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Language ) ) // 01
-	PORT_DIPSETTING(    0x01, DEF_STR( English ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( French ) )
+	PORT_MODIFY("DSW1")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Language ) ) // 01
+	PORT_DIPSETTING(    0x00, DEF_STR( English ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( French ) )
 	PORT_DIPNAME( 0x02, 0x02, "1-2" ) // 02
 	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Service_Mode ) ) // 04
 	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x00, "Demo Sound" ) // 08
-	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, "Demo Sound" ) // 08
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( On ) )
 	PORT_DIPNAME( 0x30, 0x40, "Coinage 1 (1-5, 1-6)" ) // 10 20
 	PORT_DIPSETTING(	0x30, DEF_STR( 4C_1C ) )
 	PORT_DIPSETTING(	0x10, DEF_STR( 3C_1C ) )
@@ -296,109 +157,116 @@
 	PORT_DIPSETTING(	0x40, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(	0xC0, DEF_STR( 1C_4C ) )
 
-	PORT_START("DSW2") /* DSW 2 doesn't work, may not be hooked up properly */
-//  PORT_DIPNAME( 0x01, 0x01, "2-1" )
-//  PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x02, "2-2" )
-//  PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x04, "2-3" )
-//  PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x08, "2-4" )
-//  PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x10, "2-5" )
-//  PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x20, "2-6" )
-//  PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x40, "2-7" )
-//  PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-//  PORT_DIPNAME( 0x01, 0x80, "2-8" )
-//  PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( On ) )
-
-
-	PORT_START("dummy")
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+	PORT_MODIFY("DSW2") /* TODO: uses conditional dip-switches */
+	PORT_DIPNAME( 0x01, 0x01, "2-1" )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "2-2" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, "2-3" )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, "2-4" )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, "2-5" )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, "2-6" )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, "2-7" )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, "2-8" )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
-static MACHINE_RESET( ertictac )
+static DRIVER_INIT( ertictac)
 {
-	ertictac_mainram[0]=0xeae00007; //reset vector
+	archimedes_driver_init(machine);
 }
 
-static INTERRUPT_GEN( ertictac_interrupt )
+static MACHINE_START( ertictac )
 {
-	IRQSTA|=0x08;
-	if(IRQMSKA&0x08)
-	{
-		cpu_set_input_line(device, ARM_IRQ_LINE, HOLD_LINE);
-	}
-}
+	archimedes_init(machine);
 
+	// reset the DAC to centerline
+	//dac_signed_data_w(machine->device("dac"), 0x80);
+}
 
-static VIDEO_START( ertictac )
+static MACHINE_RESET( ertictac )
 {
-	int color;
-
-	for (color = 0; color < NUM_PENS; color++)
-	{
-		UINT8 i = color & 0x03;
-		UINT8 r = ((color & 0x04) >> 0) | ((color & 0x10) >> 1) | i;
-		UINT8 g = ((color & 0x20) >> 3) | ((color & 0x40) >> 3) | i;
-		UINT8 b = ((color & 0x08) >> 1) | ((color & 0x80) >> 4) | i;
-
-		pens[color] = MAKE_RGB(pal4bit(r), pal4bit(g), pal4bit(b));
-	}
+	archimedes_reset(machine);
 }
 
-
-static VIDEO_UPDATE( ertictac )
+static INTERRUPT_GEN( ertictac_podule_irq )
 {
-	int y, x;
-
-	for (y = cliprect->min_y; y <= cliprect->max_y; y++)
-		for (x = 0; x < 0x140; x += 4)
-		{
-			offs_t offs = (y * 0x50) + (x >> 2) + (vidFIFO[0x88] >> 2);
-
-			*BITMAP_ADDR32(bitmap, y, x + 0) = pens[(ertictac_videoram[offs] >>  0) & 0xff];
-			*BITMAP_ADDR32(bitmap, y, x + 1) = pens[(ertictac_videoram[offs] >>  8) & 0xff];
-			*BITMAP_ADDR32(bitmap, y, x + 2) = pens[(ertictac_videoram[offs] >> 16) & 0xff];
-			*BITMAP_ADDR32(bitmap, y, x + 3) = pens[(ertictac_videoram[offs] >> 24) & 0xff];
-		}
-
-	return 0;
+	archimedes_request_irq_b(device->machine, ARCHIMEDES_IRQB_PODULE_IRQ);
 }
 
+/* TODO: Are we sure that this HW have I2C device? */
+#define	NVRAM_SIZE 256
+#define	NVRAM_PAGE_SIZE	0	/* max size of one write request */
+
+static const i2cmem_interface i2cmem_interface =
+{
+	I2CMEM_SLAVE_ADDRESS, NVRAM_PAGE_SIZE, NVRAM_SIZE
+};
 
 static MACHINE_DRIVER_START( ertictac )
 
-	MDRV_CPU_ADD("maincpu", ARM, 16000000) /* guess */
+	MDRV_CPU_ADD("maincpu", ARM, 8000000) /* guess */
 	MDRV_CPU_PROGRAM_MAP(ertictac_map)
-	MDRV_CPU_VBLANK_INT("screen", ertictac_interrupt)
+	MDRV_CPU_PERIODIC_INT(ertictac_podule_irq,60) // FIXME: timing of this
 
+	MDRV_MACHINE_START(ertictac)
 	MDRV_MACHINE_RESET(ertictac)
 
+	MDRV_I2CMEM_ADD("i2cmem",i2cmem_interface)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_REFRESH_RATE(60)
 	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(2500) /* not accurate */)
 	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
-	MDRV_SCREEN_SIZE(320, 256)
-	MDRV_SCREEN_VISIBLE_AREA(0, 319, 0, 255)
+	MDRV_SCREEN_SIZE(1280, 1024)
+	MDRV_SCREEN_VISIBLE_AREA(0, 1280-1, 0, 1024-1)
+
+	MDRV_PALETTE_LENGTH(0x200)
+
+	MDRV_VIDEO_START(archimds_vidc)
+	MDRV_VIDEO_UPDATE(archimds_vidc)
+
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+	MDRV_SOUND_ADD("dac0", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
 
-	MDRV_VIDEO_START(ertictac)
-	MDRV_VIDEO_UPDATE(ertictac)
+	MDRV_SOUND_ADD("dac1", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac2", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac3", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac4", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac5", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac6", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
+
+	MDRV_SOUND_ADD("dac7", DAC, 0)
+	MDRV_SOUND_ROUTE(0, "mono", 0.10)
 MACHINE_DRIVER_END
 
 ROM_START( ertictac )
-	ROM_REGION(0x800000, "user1", 0 )
+	ROM_REGION(0x800000, "maincpu", 0 )
 	ROM_LOAD32_BYTE( "01", 0x00000, 0x10000, CRC(8dce677c) SHA1(9f12b1febe796038caa1ecad1d17864dc546cfd8) )
 	ROM_LOAD32_BYTE( "02", 0x00001, 0x10000, CRC(7c5c916c) SHA1(d4ed5fc3a7b27253551e7d9176ed9e6513092e60) )
 	ROM_LOAD32_BYTE( "03", 0x00002, 0x10000, CRC(edca5ac6) SHA1(f6c4b8030f3c1c93922c5f7232f2159e0471b93a) )
@@ -415,10 +283,12 @@
 	ROM_LOAD32_BYTE( "14", 0xc0001, 0x10000, CRC(3029567c) SHA1(6d49bea3a3f6f11f4182a602d37b53f1f896c154) )
 	ROM_LOAD32_BYTE( "15", 0xc0002, 0x10000, CRC(500997ab) SHA1(028c7b3ca03141e5b596ab1e2ab98d0ccd9bf93a) )
 	ROM_LOAD32_BYTE( "16", 0xc0003, 0x10000, CRC(70a8d136) SHA1(50b11f5701ed5b79a5d59c9a3c7d5b7528e66a4d) )
+
+	ROM_REGION(0x200000, "vram", ROMREGION_ERASE00)
 ROM_END
 
 ROM_START( poizone )
-	ROM_REGION(0x800000, "user1", 0 )
+	ROM_REGION(0x800000, "maincpu", 0 )
 	ROM_LOAD32_BYTE( "p_son01.bin", 0x00000, 0x10000, CRC(28793c9f) SHA1(2d9f7d667203e745b47cd2cc97501ae961ae1a66) )
 	ROM_LOAD32_BYTE( "p_son02.bin", 0x00001, 0x10000, CRC(2d4b6f4b) SHA1(8df2680d6e5dc41787b3a72e594f01f5e732d0ec) )
 	ROM_LOAD32_BYTE( "p_son03.bin", 0x00002, 0x10000, CRC(0834d46e) SHA1(bf1cc9b47759ef39ed8fd8f334ed8f2902be3bf8) )
@@ -436,8 +306,10 @@
 	ROM_LOAD32_BYTE( "p_son22.bin", 0x140001, 0x10000, CRC(16f0bb52) SHA1(893ab1e72b84de7a38f88f9d713769968ebd4553) )
 	ROM_LOAD32_BYTE( "p_son23.bin", 0x140002, 0x10000, CRC(e9c118b2) SHA1(110d9a204e701b9b54d89f027f8892c3f3a819c7) )
 	ROM_LOAD32_BYTE( "p_son24.bin", 0x140003, 0x10000, CRC(a09d7f55) SHA1(e0d562c655c16034b40db93de801b98b7948beb2) )
+
+	ROM_REGION(0x200000, "vram", ROMREGION_ERASE00)
 ROM_END
 
-GAME( 1990, ertictac, 0, ertictac, ertictac, 0, ROT0, "Sisteme", "Erotictac/Tactic" ,GAME_NO_SOUND)
-GAME( 1991, poizone,  0, ertictac, poizone, 0,  ROT0, "Eterna" ,"Poizone" ,GAME_NO_SOUND|GAME_NOT_WORKING)
+GAME( 1990, ertictac, 0, ertictac, ertictac, ertictac, ROT0, "Sisteme", "Erotictac/Tactic" ,GAME_IMPERFECT_SOUND)
+GAME( 1991, poizone,  0, ertictac, poizone, ertictac,  ROT0, "Eterna" ,"Poizone" ,GAME_IMPERFECT_SOUND|GAME_NOT_WORKING)
 
diff -Nru src-old/mame/drivers/exidy.c src/mame/drivers/exidy.c
--- src-old/mame/drivers/exidy.c	2010-05-22 18:04:09.000000000 -0700
+++ src/mame/drivers/exidy.c	2010-08-19 00:26:14.000000000 -0700
@@ -1458,7 +1458,7 @@
 
 static DRIVER_INIT( fax )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	exidy_video_config(0x04, 0x04, TRUE);
 
diff -Nru src-old/mame/drivers/exterm.c src/mame/drivers/exterm.c
--- src-old/mame/drivers/exterm.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/exterm.c	2010-08-19 00:26:14.000000000 -0700
@@ -110,7 +110,7 @@
  *
  *************************************/
 
-static UINT16 exterm_trackball_port_r(const address_space *space, int which, UINT16 mem_mask)
+static UINT16 exterm_trackball_port_r(address_space *space, int which, UINT16 mem_mask)
 {
 	UINT16 port;
 
diff -Nru src-old/mame/drivers/fastlane.c src/mame/drivers/fastlane.c
--- src-old/mame/drivers/fastlane.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/fastlane.c	2010-08-21 21:48:06.000000000 -0700
@@ -103,6 +103,7 @@
 
 ***************************************************************************/
 
+/* verified from HD6309 code */
 static INPUT_PORTS_START( fastlane )
 	PORT_START("DSW1")
 	KONAMI_COINAGE(DEF_STR( Free_Play ), "No Coin B")
@@ -114,21 +115,21 @@
 	PORT_DIPSETTING(	0x02, "3" )
 	PORT_DIPSETTING(	0x01, "4" )
 	PORT_DIPSETTING(	0x00, "7" )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(	0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Cabinet ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Cocktail ) )
 	/* The bonus life affects the starting high score too, 20000 or 30000 */
 	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(	0x18, "20000 100000" )
-	PORT_DIPSETTING(	0x10, "30000 150000" )
-	PORT_DIPSETTING(	0x08, "20000" )
-	PORT_DIPSETTING(	0x00, "30000" )
+	PORT_DIPSETTING(	0x18, "20k 100k 200k 400k 800k" )
+	PORT_DIPSETTING(	0x10, "30k 150k 300k 600k" )
+	PORT_DIPSETTING(	0x08, "20k only" )
+	PORT_DIPSETTING(	0x00, "30k only" )
 	PORT_DIPNAME( 0x60, 0x40, DEF_STR( Difficulty ) )
 	PORT_DIPSETTING(	0x60, DEF_STR( Easy ) )
 	PORT_DIPSETTING(	0x40, DEF_STR( Medium ) )
 	PORT_DIPSETTING(	0x20, DEF_STR( Hard ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )
+	PORT_DIPNAME( 0x80, 0x00, "Demo Music" )                /* when levels are played by the computer */
 	PORT_DIPSETTING(	0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
 
@@ -136,9 +137,9 @@
 	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) )
 	PORT_DIPSETTING(	0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
-	PORT_DIPSETTING(	0x02, DEF_STR( Off ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "Upright Controls" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Single ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Dual ) )
 	PORT_SERVICE( 0x04, IP_ACTIVE_LOW )
 	PORT_DIPNAME( 0x08, 0x08, "Continue" )
 	PORT_DIPSETTING(	0x08, "3" )
@@ -279,4 +280,4 @@
 ROM_END
 
 
-GAME( 1987, fastlane, 0, fastlane, fastlane, 0, ROT90, "Konami", "Fast Lane", GAME_IMPERFECT_COLORS | GAME_SUPPORTS_SAVE )
+GAME( 1987, fastlane, 0, fastlane, fastlane, 0, ROT90, "Konami", "Fast Lane", GAME_NO_COCKTAIL | GAME_IMPERFECT_COLORS | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/firetrap.c src/mame/drivers/firetrap.c
--- src-old/mame/drivers/firetrap.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/firetrap.c	2010-08-24 09:24:55.000000000 -0700
@@ -129,6 +129,41 @@
       HSync - 15.6137kHz
       VSync - 57.4034Hz
 
+
+Stephh's notes (based on the games Z80 code and some tests) :
+
+1) 'firetrap' :
+
+  - US version, licensed to Data East.
+  - MCU missing and simulated (init command = 0x13).
+  - No warning screen.
+  - Instructions in English
+  - Initials : 3 letters.
+  - Bugs in test mode :
+      * when lives are set to "2", it displays "1".
+      * bonus lives is still the same as the Japan version even if table at 0x0ca3 has changed.
+
+2) 'firetrapj' :
+
+  - Japan version.
+  - MCU missing and simulated (init command = 0xf5).
+  - Additional warning screen.
+  - Instructions in Japanese
+  - Initials : 5 letters.
+  - Bugs in test mode :
+      * when lives are set to "2", it displays "1".
+
+3) 'firetrapbl' :
+
+  - Bootleg based on 'firetrapj'.
+  - Most MCU writes are patched while reads are handled differently.
+  - Additional ROM with code at 0xf800 to simulate the MCU initialisation routine.
+  - No warning screen.
+  - Instructions in Japanese
+  - Initials : 5 letters.
+  - Bugs in test mode :
+      * when lives are set to "2", it displays "1".
+
 ***************************************************************************/
 
 #include "emu.h"
@@ -158,8 +193,24 @@
 	/* Check for coin insertion */
 	/* the following only works in the bootleg version, which doesn't have an */
 	/* 8751 - the real thing is much more complicated than that. */
-	if ((input_port_read(space->machine, "IN2") & 0x70) != 0x70)
+	firetrap_state *state = space->machine->driver_data<firetrap_state>();
+	UINT8 coin = 0;
+	UINT8 port = input_port_read(space->machine, "IN2") & 0x70;
+
+	if (cpu_get_pc(space->cpu) == 0x1188)
+		return ~state->coin_command_pending;
+
+	if (port != 0x70)
+	{
+		if (!(port & 0x20)) /* COIN1 */
+			coin = 1;
+		if (!(port & 0x40)) /* COIN2 */
+			coin = 2;
+		if (!(port & 0x10)) /* SERVICE1 */
+			coin = 3;
+		state->coin_command_pending = coin;
 		return 0xff;
+	}
 
 	return 0;
 }
@@ -204,8 +255,8 @@
 		return;
 	}
 
-	/* Init sequence command */
-	else if (data == 0x13)
+	/* Init sequence command (0x13 : US - 0xf5 : Japan) */
+	else if ((data == 0x13) || (data == 0xf5))
 	{
 		if (!state->i8751_current_command)
 			state->i8751_init_ptr = 0;
@@ -363,26 +414,26 @@
 ADDRESS_MAP_END
 
 
-
+/* verified from Z80 code */
 static INPUT_PORTS_START( firetrap )
 	PORT_START("IN0")	/* IN0 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP ) PORT_4WAY
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN ) PORT_4WAY
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT ) PORT_4WAY
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT ) PORT_4WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP ) PORT_4WAY
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN ) PORT_4WAY
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT ) PORT_4WAY
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP )     PORT_4WAY
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN )   PORT_4WAY
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT )   PORT_4WAY
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT )  PORT_4WAY
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP )    PORT_4WAY
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN )  PORT_4WAY
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT )  PORT_4WAY
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_RIGHT ) PORT_4WAY
 
 	PORT_START("IN1")	/* IN1 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT ) PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP )     PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN )   PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT )   PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT )  PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP )    PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN )  PORT_4WAY PORT_COCKTAIL
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT )  PORT_4WAY PORT_COCKTAIL
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_RIGHT ) PORT_4WAY PORT_COCKTAIL
 
 	PORT_START("IN2")	/* IN2 */
@@ -427,15 +478,15 @@
 	PORT_DIPSETTING(    0x01, DEF_STR( Hard ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
 	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x00, "1" )
+	PORT_DIPSETTING(    0x00, "2" )                         /* "1" in the "test mode" */
 	PORT_DIPSETTING(    0x0c, "3" )
 	PORT_DIPSETTING(    0x08, "4" )
 	PORT_DIPSETTING(    0x04, "5" )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x30, "50000 70000" )
-	PORT_DIPSETTING(    0x20, "60000 80000" )
-	PORT_DIPSETTING(    0x10, "80000 100000" )
-	PORT_DIPSETTING(    0x00, "50000" )
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )       /* table at 0x0ca3 - 4*30 bytes */
+	PORT_DIPSETTING(    0x10, "30k and 70k" )
+	PORT_DIPSETTING(    0x00, "50k and 100k" )
+	PORT_DIPSETTING(    0x30, "30k only" )
+	PORT_DIPSETTING(    0x20, "50k only" )
 	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Allow_Continue ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
 	PORT_DIPSETTING(    0x40, DEF_STR( Yes ) )
@@ -447,82 +498,29 @@
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( firetrapbl )
-	PORT_START("IN0")	/* IN0 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP ) PORT_4WAY
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN ) PORT_4WAY
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT ) PORT_4WAY
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT ) PORT_4WAY
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP ) PORT_4WAY
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN ) PORT_4WAY
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT ) PORT_4WAY
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_RIGHT ) PORT_4WAY
-
-	PORT_START("IN1")	/* IN1 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_DOWN ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_LEFT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_JOYSTICKLEFT_RIGHT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_UP ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_DOWN ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_LEFT ) PORT_4WAY PORT_COCKTAIL
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICKRIGHT_RIGHT ) PORT_4WAY PORT_COCKTAIL
+/* verified from Z80 code */
+static INPUT_PORTS_START( firetrapj )
+	PORT_INCLUDE( firetrap )
+
+	PORT_MODIFY("DSW1")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )       /* table at 0x0ca3 - 4*30 bytes */
+	PORT_DIPSETTING(    0x30, "50k 120k 70k+" )             /* last bonus life at 960k */
+	PORT_DIPSETTING(    0x20, "60k 140k 80k+" )             /* last bonus life at 940k */
+	PORT_DIPSETTING(    0x10, "80k 180k 100k+" )            /* last bonus life at 980k */
+	PORT_DIPSETTING(    0x00, "50k only" )
+INPUT_PORTS_END
 
-	PORT_START("IN2")	/* IN2 */
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
-	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START2 )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN3 )	/* bootleg only */
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )	/* bootleg only */
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )	/* bootleg only */
-	PORT_BIT( 0x80, IP_ACTIVE_HIGH, IPT_VBLANK )
+/* verified from Z80 code */
+static INPUT_PORTS_START( firetrapbl )
+	PORT_INCLUDE( firetrapj )
 
-	PORT_START("DSW0")	/* DSW0 */
-	PORT_DIPNAME( 0x07, 0x07, DEF_STR( Coin_A ) )
-//  PORT_DIPSETTING(    0x00, DEF_STR( 1C_1C ) )
-//  PORT_DIPSETTING(    0x01, DEF_STR( 1C_1C ) )
-//  PORT_DIPSETTING(    0x02, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x07, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(    0x06, DEF_STR( 1C_2C ) )
-	PORT_DIPSETTING(    0x05, DEF_STR( 1C_3C ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( 1C_4C ) )
-	PORT_DIPSETTING(    0x04, DEF_STR( 1C_6C ) )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( 4C_1C ) )
-	PORT_DIPSETTING(    0x08, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(    0x10, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(    0x18, DEF_STR( 1C_1C ) )
-	PORT_DIPNAME( 0x20, 0x00, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
-	PORT_DIPSETTING(    0x20, DEF_STR( Cocktail ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Flip_Screen ) )
-	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_MODIFY("IN2")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
 
-	PORT_START("DSW1")	/* DSW1 */
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Easy ) )
-	PORT_DIPSETTING(    0x03, DEF_STR( Normal ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( Hard ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x0c, 0x0c, DEF_STR( Lives ) )
-	PORT_DIPSETTING(    0x00, "1" )
-	PORT_DIPSETTING(    0x0c, "3" )
-	PORT_DIPSETTING(    0x08, "4" )
-	PORT_DIPSETTING(    0x04, "5" )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x30, "50000 70000" )
-	PORT_DIPSETTING(    0x20, "60000 80000" )
-	PORT_DIPSETTING(    0x10, "80000 100000" )
-	PORT_DIPSETTING(    0x00, "50000" )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( No ) )
-	PORT_DIPSETTING(    0x40, DEF_STR( Yes ) )
-	PORT_SERVICE( 0x80, IP_ACTIVE_LOW )
+	PORT_MODIFY("COIN")
+	PORT_BIT( 0x07, IP_ACTIVE_LOW, IPT_UNUSED )
 INPUT_PORTS_END
 
 
@@ -579,16 +577,24 @@
 static INTERRUPT_GEN( firetrap )
 {
 	firetrap_state *state = device->machine->driver_data<firetrap_state>();
+	UINT8 coin = 0;
+	UINT8 port = input_port_read(device->machine, "COIN") & 0x07;
 
 	/* Check for coin IRQ */
 	if (cpu_getiloops(device))
 	{
-		if ((input_port_read(device->machine, "COIN") & 0x7) != 0x7 && !state->int_latch)
+		if (port != 0x07 && !state->int_latch)
 		{
-			state->coin_command_pending = ~input_port_read(device->machine, "COIN");
+			if (!(port & 0x01)) /* COIN1 */
+				coin = 1;
+			if (!(port & 0x02)) /* COIN2 */
+				coin = 2;
+			if (!(port & 0x04)) /* SERVICE1 */
+				coin = 3;
+			state->coin_command_pending = coin;
 			state->int_latch = 1;
 		}
-		if ((input_port_read(device->machine, "COIN") & 0x7) == 0x7)
+		if (port == 0x07)
 			state->int_latch = 0;
 
 		/* Make sure coin IRQ's aren't generated when another command is pending, the main cpu
@@ -955,5 +961,5 @@
 
 
 GAME( 1986, firetrap,   0,        firetrap,   firetrap,   0, ROT90, "Wood Place Inc. (Data East USA license)", "Fire Trap (US)", GAME_SUPPORTS_SAVE )
-GAME( 1986, firetrapj,  firetrap, firetrap,   firetrap,   0, ROT90, "Wood Place Inc.", "Fire Trap (Japan)", GAME_NOT_WORKING | GAME_UNEMULATED_PROTECTION | GAME_SUPPORTS_SAVE )
+GAME( 1986, firetrapj,  firetrap, firetrap,   firetrapj,  0, ROT90, "Wood Place Inc.", "Fire Trap (Japan)", GAME_SUPPORTS_SAVE )
 GAME( 1986, firetrapbl, firetrap, firetrapbl, firetrapbl, 0, ROT90, "bootleg", "Fire Trap (Japan bootleg)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/flstory.c src/mame/drivers/flstory.c
--- src-old/mame/drivers/flstory.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/flstory.c	2010-08-19 00:26:14.000000000 -0700
@@ -126,7 +126,7 @@
 static CUSTOM_INPUT( victnine_mcu_status_bit01_r )
 {
 	flstory_state *state = field->port->machine->driver_data<flstory_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	return (victnine_mcu_status_r(space, 0) & 3);
 }
diff -Nru src-old/mame/drivers/freekick.c src/mame/drivers/freekick.c
--- src-old/mame/drivers/freekick.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/freekick.c	2010-08-19 07:19:38.000000000 -0700
@@ -1111,8 +1111,8 @@
 
 static DRIVER_INIT(gigasb)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0xbfff, memory_region(machine, "maincpu") + 0x10000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0xbfff, memory_region(machine, "maincpu") + 0x10000);
 }
 
 
diff -Nru src-old/mame/drivers/funworld.c src/mame/drivers/funworld.c
--- src-old/mame/drivers/funworld.c	2010-06-09 13:08:10.000000000 -0700
+++ src/mame/drivers/funworld.c	2010-08-19 07:19:38.000000000 -0700
@@ -4229,7 +4229,7 @@
 ******************************************************/
 {
 	UINT8 *ROM = memory_region(machine, "maincpu");
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	int x;
 
@@ -4247,7 +4247,7 @@
 		ROM[x+0x10000] = code;
 	}
 
-	memory_set_decrypted_region(space, 0x8000, 0xffff, memory_region(machine, "maincpu") + 0x18000);
+	space->set_decrypted_region(0x8000, 0xffff, memory_region(machine, "maincpu") + 0x18000);
 }
 
 static DRIVER_INIT( royalcdc )
@@ -4262,7 +4262,7 @@
 ******************************************************/
 
 	UINT8 *ROM = memory_region(machine, "maincpu");
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	int x;
 
@@ -4300,7 +4300,7 @@
 		ROM[x+0x10000] = code;
 	}
 
-	memory_set_decrypted_region(space, 0x6000, 0xffff, memory_region(machine, "maincpu") + 0x16000);
+	space->set_decrypted_region(0x6000, 0xffff, memory_region(machine, "maincpu") + 0x16000);
 }
 
 
diff -Nru src-old/mame/drivers/galaga.c src/mame/drivers/galaga.c
--- src-old/mame/drivers/galaga.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/galaga.c	2010-08-19 00:26:14.000000000 -0700
@@ -887,7 +887,7 @@
 
 static void bosco_latch_reset(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Reset all latches */
diff -Nru src-old/mame/drivers/galaxia.c src/mame/drivers/galaxia.c
--- src-old/mame/drivers/galaxia.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/galaxia.c	2010-08-12 12:45:01.000000000 -0700
@@ -25,6 +25,7 @@
 
 #include "emu.h"
 #include "video/s2636.h"
+#include "sound/s2636.h"
 #include "cpu/s2650/s2650.h"
 
 static UINT8 *galaxia_video;
@@ -235,21 +236,24 @@
 {
 	"screen",
 	0x100,
-	3, -27
+	3, -27,
+	"s2636snd_0"
 };
 
 static const s2636_interface s2636_1_config =
 {
 	"screen",
 	0x100,
-	3, -27
+	3, -27,
+	"s2636snd_1"
 };
 
 static const s2636_interface s2636_2_config =
 {
 	"screen",
 	0x100,
-	3, -27
+	3, -27,
+	"s2636snd_2"
 };
 
 static MACHINE_DRIVER_START( galaxia )
@@ -275,6 +279,17 @@
 	MDRV_S2636_ADD("s2636_2", s2636_2_config)
 
 	MDRV_VIDEO_UPDATE(galaxia)
+
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+
+	MDRV_SOUND_ADD("s2636snd_0", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+
+	MDRV_SOUND_ADD("s2636snd_1", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+
+	MDRV_SOUND_ADD("s2636snd_2", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_DRIVER_END
 
 static MACHINE_DRIVER_START( astrowar )
@@ -334,5 +349,5 @@
 	galaxia_color=auto_alloc_array(machine, UINT8, 0x400);
 }
 
-GAME( 1979, galaxia, 0, galaxia, galaxia, galaxia, ROT90, "Zaccaria", "Galaxia", GAME_NOT_WORKING|GAME_NO_SOUND )
-GAME( 1980, astrowar, 0, astrowar, galaxia, galaxia, ROT90, "Zaccaria", "Astro Wars", GAME_NOT_WORKING|GAME_NO_SOUND|GAME_WRONG_COLORS )
+GAME( 1979, galaxia, 0, galaxia, galaxia, galaxia, ROT90, "Zaccaria", "Galaxia", GAME_NOT_WORKING )
+GAME( 1980, astrowar, 0, astrowar, galaxia, galaxia, ROT90, "Zaccaria", "Astro Wars", GAME_NOT_WORKING|GAME_WRONG_COLORS )
diff -Nru src-old/mame/drivers/galaxian.c src/mame/drivers/galaxian.c
--- src-old/mame/drivers/galaxian.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/galaxian.c	2010-08-19 07:19:38.000000000 -0700
@@ -1022,7 +1022,7 @@
 
 static INPUT_CHANGED( gmgalax_game_changed )
 {
-	const address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* new value is the selected game */
 	gmgalax_selected_game = newval;
@@ -2601,7 +2601,7 @@
 
 static void unmap_galaxian_sound(running_machine *machine, offs_t base)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	memory_unmap_write(space, base + 0x0004, base + 0x0007, 0, 0x07f8);
 	memory_unmap_write(space, base + 0x0800, base + 0x0807, 0, 0x07f8);
@@ -2624,7 +2624,7 @@
 
 static DRIVER_INIT( nolock )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* same as galaxian... */
 	DRIVER_INIT_CALL(galaxian);
@@ -2636,7 +2636,7 @@
 
 static DRIVER_INIT( azurian )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* yellow bullets instead of white ones */
 	common_init(machine, scramble_draw_bullet, galaxian_draw_background, NULL, NULL);
@@ -2648,7 +2648,7 @@
 
 static DRIVER_INIT( gmgalax )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, gmgalax_extend_tile_info, gmgalax_extend_sprite_info);
@@ -2665,7 +2665,7 @@
 
 static DRIVER_INIT( pisces )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, pisces_extend_tile_info, pisces_extend_sprite_info);
@@ -2677,7 +2677,7 @@
 
 static DRIVER_INIT( batman2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, batman2_extend_tile_info, upper_extend_sprite_info);
@@ -2689,7 +2689,7 @@
 
 static DRIVER_INIT( frogg )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* same as galaxian... */
 	common_init(machine, galaxian_draw_bullet, frogger_draw_background, frogger_extend_tile_info, frogger_extend_sprite_info);
@@ -2725,7 +2725,7 @@
 
 static DRIVER_INIT( mooncrgx )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, mooncrst_extend_tile_info, mooncrst_extend_sprite_info);
@@ -2737,7 +2737,7 @@
 
 static DRIVER_INIT( moonqsr )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 
 	/* video extensions */
@@ -2745,7 +2745,7 @@
 
 	/* decrypt program code */
 	decode_mooncrst(machine, 0x8000, decrypt);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 }
 
 static WRITE8_HANDLER( artic_gfxbank_w )
@@ -2755,7 +2755,7 @@
 
 static DRIVER_INIT( pacmanbl )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* same as galaxian... */
 	DRIVER_INIT_CALL(galaxian);
@@ -2821,7 +2821,7 @@
 
 static DRIVER_INIT( tenspot )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* these are needed for batman part 2 to work properly, this banking is probably a property of the artic board,
        which tenspot appears to have copied */
@@ -2858,7 +2858,7 @@
 
 static DRIVER_INIT( zigzag )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, NULL, galaxian_draw_background, NULL, NULL);
@@ -2898,8 +2898,8 @@
 
 static DRIVER_INIT( checkman )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, mooncrst_extend_tile_info, mooncrst_extend_sprite_info);
@@ -2918,7 +2918,7 @@
 
 static DRIVER_INIT( checkmaj )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, NULL, NULL);
@@ -2933,7 +2933,7 @@
 
 static DRIVER_INIT( dingo )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, NULL, NULL);
@@ -2948,8 +2948,8 @@
 
 static DRIVER_INIT( dingoe )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, mooncrst_extend_tile_info, mooncrst_extend_sprite_info);
@@ -2970,7 +2970,7 @@
 
 static DRIVER_INIT( skybase )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, pisces_extend_tile_info, pisces_extend_sprite_info);
@@ -3014,7 +3014,7 @@
 
 static DRIVER_INIT( kingball )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, NULL, NULL);
@@ -3031,7 +3031,7 @@
 
 static DRIVER_INIT( scorpnmc )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, batman2_extend_tile_info, upper_extend_sprite_info);
@@ -3052,7 +3052,7 @@
 
 static DRIVER_INIT( thepitm )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, galaxian_draw_bullet, galaxian_draw_background, mooncrst_extend_tile_info, mooncrst_extend_sprite_info);
@@ -3076,7 +3076,7 @@
 
 static DRIVER_INIT( theend )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, theend_draw_bullet, galaxian_draw_background, NULL, NULL);
@@ -3095,7 +3095,7 @@
 
 static DRIVER_INIT( explorer )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, scramble_draw_bullet, scramble_draw_background, NULL, NULL);
@@ -3128,7 +3128,7 @@
 
 static DRIVER_INIT( atlantis )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, scramble_draw_bullet, scramble_draw_background, NULL, NULL);
@@ -3170,7 +3170,7 @@
 
 static DRIVER_INIT( froggrmc )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* video extensions */
 	common_init(machine, NULL, frogger_draw_background, frogger_extend_tile_info, frogger_extend_sprite_info);
@@ -3215,7 +3215,7 @@
 
 static DRIVER_INIT( scorpion )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	common_init(machine, scramble_draw_bullet, scramble_draw_background, batman2_extend_tile_info, upper_extend_sprite_info);
 
diff -Nru src-old/mame/drivers/galpani2.c src/mame/drivers/galpani2.c
--- src-old/mame/drivers/galpani2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/galpani2.c	2010-08-19 01:27:05.000000000 -0700
@@ -82,7 +82,7 @@
 
 static void galpani2_write_kaneko(running_device *device)
 {
-	const address_space *dstspace = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	address_space *dstspace = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
 	int i,x,tpattidx;
 	unsigned char testpattern[] = {0xFF,0x55,0xAA,0xDD,0xBB,0x99};
 
@@ -94,58 +94,58 @@
 	{
 		for (tpattidx = 0; tpattidx < 6; tpattidx++)
 		{
-			if (memory_read_byte(dstspace,i) == testpattern[tpattidx]) x = 1; //ram test fragment present
+			if (dstspace->read_byte(i) == testpattern[tpattidx]) x = 1; //ram test fragment present
 		}
 	}
 
 	if	( x == 0 )
 	{
-		memory_write_byte(dstspace,0x100000,0x4b); //K
-		memory_write_byte(dstspace,0x100001,0x41); //A
-		memory_write_byte(dstspace,0x100002,0x4e); //N
-		memory_write_byte(dstspace,0x100003,0x45); //E
-		memory_write_byte(dstspace,0x100004,0x4b); //K
-		memory_write_byte(dstspace,0x100005,0x4f); //O
+		dstspace->write_byte(0x100000,0x4b); //K
+		dstspace->write_byte(0x100001,0x41); //A
+		dstspace->write_byte(0x100002,0x4e); //N
+		dstspace->write_byte(0x100003,0x45); //E
+		dstspace->write_byte(0x100004,0x4b); //K
+		dstspace->write_byte(0x100005,0x4f); //O
 	}
 }
 
 static WRITE8_HANDLER( galpani2_mcu_init_w )
 {
 	running_machine *machine = space->machine;
-	const address_space *srcspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *dstspace = cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM);
+	address_space *srcspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *dstspace = cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM);
 	UINT32 mcu_address, mcu_data;
 
 	for ( mcu_address = 0x100010; mcu_address < (0x100010 + 6); mcu_address += 1 )
 	{
-		mcu_data	=	memory_read_byte(srcspace, mcu_address );
-		memory_write_byte(dstspace, mcu_address-0x10, mcu_data);
+		mcu_data	=	srcspace->read_byte(mcu_address );
+		dstspace->write_byte(mcu_address-0x10, mcu_data);
 	}
 	cputag_set_input_line(machine, "sub", INPUT_LINE_IRQ7, HOLD_LINE); //MCU Initialised
 }
 
 static void galpani2_mcu_nmi1(running_machine *machine)
 {
-	const address_space *srcspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *dstspace = cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM);
+	address_space *srcspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *dstspace = cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM);
 	UINT32 mcu_list, mcu_command, mcu_address, mcu_extra, mcu_src, mcu_dst, mcu_size;
 
 	for ( mcu_list = 0x100021; mcu_list < (0x100021 + 0x40); mcu_list += 4 )
 	{
-		mcu_command		=	memory_read_byte(srcspace, mcu_list);
+		mcu_command		=	srcspace->read_byte(mcu_list);
 
 		mcu_address		=	0x100000 +
-							(memory_read_byte(srcspace, mcu_list + 1)<<8) +
-							(memory_read_byte(srcspace, mcu_list + 2)<<0) ;
+							(srcspace->read_byte(mcu_list + 1)<<8) +
+							(srcspace->read_byte(mcu_list + 2)<<0) ;
 
-		mcu_extra		=	memory_read_byte(srcspace, mcu_list + 3); //0xff for command $A and $2, 0x02 for others
+		mcu_extra		=	srcspace->read_byte(mcu_list + 3); //0xff for command $A and $2, 0x02 for others
 
 		if (mcu_command != 0)
 		{
 			logerror("%s : MCU [$%06X] endidx = $%02X / command = $%02X addr = $%04X ? = $%02X.\n",
 			cpuexec_describe_context(machine),
 			mcu_list,
-			memory_read_byte(srcspace, 0x100020),
+			srcspace->read_byte(0x100020),
 			mcu_command,
 			mcu_address,
 			mcu_extra
@@ -158,51 +158,51 @@
 			break;
 
 		case 0x02: //Copy N bytes from RAM2 to RAM1?, gp2se is the only one to use it, often!
-			mcu_src		=	(memory_read_byte(srcspace, mcu_address + 2)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 3)<<0) ;
+			mcu_src		=	(srcspace->read_byte(mcu_address + 2)<<8) +
+							(srcspace->read_byte(mcu_address + 3)<<0) ;
 
-			mcu_dst		=	(memory_read_byte(srcspace, mcu_address + 6)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 7)<<0) ;
+			mcu_dst		=	(srcspace->read_byte(mcu_address + 6)<<8) +
+							(srcspace->read_byte(mcu_address + 7)<<0) ;
 
-			mcu_size	=	(memory_read_byte(srcspace, mcu_address + 8)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 9)<<0) ;
+			mcu_size	=	(srcspace->read_byte(mcu_address + 8)<<8) +
+							(srcspace->read_byte(mcu_address + 9)<<0) ;
 			logerror("%s : MCU executes command $%02X, %04X %02X-> %04x\n",cpuexec_describe_context(machine),mcu_command,mcu_src,mcu_size,mcu_dst);
 
 			for( ; mcu_size > 0 ; mcu_size-- )
 			{
 				mcu_src &= 0xffff;	mcu_dst &= 0xffff;
-				memory_write_byte(srcspace,0x100000 + mcu_dst,memory_read_byte(dstspace,0x100000 + mcu_src));
+				srcspace->write_byte(0x100000 + mcu_dst,dstspace->read_byte(0x100000 + mcu_src));
 				mcu_src ++;			mcu_dst ++;
 			}
 
 			/* Raise a "job done" flag */
-			memory_write_byte(srcspace,mcu_address+0,0xff);
-			memory_write_byte(srcspace,mcu_address+1,0xff);
+			srcspace->write_byte(mcu_address+0,0xff);
+			srcspace->write_byte(mcu_address+1,0xff);
 
 			break;
 
 		case 0x0a:	// Copy N bytes from RAM1 to RAM2
-			mcu_src		=	(memory_read_byte(srcspace, mcu_address + 2)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 3)<<0) ;
+			mcu_src		=	(srcspace->read_byte(mcu_address + 2)<<8) +
+							(srcspace->read_byte(mcu_address + 3)<<0) ;
 
-			mcu_dst		=	(memory_read_byte(srcspace, mcu_address + 6)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 7)<<0) ;
+			mcu_dst		=	(srcspace->read_byte(mcu_address + 6)<<8) +
+							(srcspace->read_byte(mcu_address + 7)<<0) ;
 
-			mcu_size	=	(memory_read_byte(srcspace, mcu_address + 8)<<8) +
-							(memory_read_byte(srcspace, mcu_address + 9)<<0) ;
+			mcu_size	=	(srcspace->read_byte(mcu_address + 8)<<8) +
+							(srcspace->read_byte(mcu_address + 9)<<0) ;
 
 			logerror("%s : MCU executes command $%02X, %04X %02X-> %04x\n",cpuexec_describe_context(machine),mcu_command,mcu_src,mcu_size,mcu_dst);
 
 			for( ; mcu_size > 0 ; mcu_size-- )
 			{
 				mcu_src &= 0xffff;	mcu_dst &= 0xffff;
-				memory_write_byte(dstspace,0x100000 + mcu_dst,memory_read_byte(srcspace,0x100000 + mcu_src));
+				dstspace->write_byte(0x100000 + mcu_dst,srcspace->read_byte(0x100000 + mcu_src));
 				mcu_src ++;			mcu_dst ++;
 			}
 
 			/* Raise a "job done" flag */
-			memory_write_byte(srcspace,mcu_address+0,0xff);
-			memory_write_byte(srcspace,mcu_address+1,0xff);
+			srcspace->write_byte(mcu_address+0,0xff);
+			srcspace->write_byte(mcu_address+1,0xff);
 
 			break;
 
@@ -216,14 +216,14 @@
 		//case 0x85: //? Do what?
 		default:
 			/* Raise a "job done" flag */
-			memory_write_byte(srcspace,mcu_address+0,0xff);
-			memory_write_byte(srcspace,mcu_address+1,0xff);
+			srcspace->write_byte(mcu_address+0,0xff);
+			srcspace->write_byte(mcu_address+1,0xff);
 
 			logerror("%s : MCU ERROR, unknown command $%02X\n",cpuexec_describe_context(machine),mcu_command);
 		}
 
 		/* Erase command (so that it won't be processed again)? */
-		memory_write_byte(srcspace,mcu_list,0x00);
+		srcspace->write_byte(mcu_list,0x00);
 	}
 }
 
diff -Nru src-old/mame/drivers/gamecstl.c src/mame/drivers/gamecstl.c
--- src-old/mame/drivers/gamecstl.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/gamecstl.c	2010-08-19 01:27:05.000000000 -0700
@@ -435,7 +435,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -444,7 +444,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static void set_dma_channel(running_device *device, int channel, int state)
diff -Nru src-old/mame/drivers/gameplan.c src/mame/drivers/gameplan.c
--- src-old/mame/drivers/gameplan.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/gameplan.c	2010-08-19 00:26:14.000000000 -0700
@@ -194,7 +194,7 @@
 
 static WRITE8_DEVICE_HANDLER( r6532_soundlatch_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	soundlatch_w(space, 0, data);
 }
 
diff -Nru src-old/mame/drivers/gauntlet.c src/mame/drivers/gauntlet.c
--- src-old/mame/drivers/gauntlet.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/gauntlet.c	2010-08-19 00:26:14.000000000 -0700
@@ -144,7 +144,7 @@
 
 static void scanline_update(screen_device &screen, int scanline)
 {
-	const address_space *space = cputag_get_address_space(screen.machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(screen.machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	/* sound IRQ is on 32V */
 	if (scanline & 32)
diff -Nru src-old/mame/drivers/gei.c src/mame/drivers/gei.c
--- src-old/mame/drivers/gei.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/gei.c	2010-08-27 14:16:06.000000000 -0700
@@ -91,8 +91,6 @@
 	static int prevoffset, yadd;
 	int i;
 
-	space->machine->generic.videoram.u8[offset] = data;
-
 	yadd = (offset==prevoffset) ? (yadd+1):0;
 	prevoffset = offset;
 
@@ -143,7 +141,7 @@
 
 static WRITE8_DEVICE_HANDLER( sound_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* bit 3 - coin lockout, lamp10 in poker / lamp6 in trivia test modes */
 	coin_lockout_global_w(device->machine, ~data & 0x08);
@@ -184,7 +182,7 @@
 
 static WRITE8_DEVICE_HANDLER( nmi_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* bit 4 - play/raise button lamp, lamp 9 in selection test mode  */
 	set_led_status(device->machine, 8,data & 0x10);
@@ -385,7 +383,7 @@
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0x9fff) AM_ROM /* space for diagnostic ROM? */
 	AM_RANGE(0xa000, 0xbfff) AM_ROM
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( gselect_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -399,7 +397,7 @@
 	AM_RANGE(0x4800, 0x4803) AM_DEVREADWRITE("ppi8255_0", ppi8255_r, ppi8255_w)
 	AM_RANGE(0x5000, 0x5003) AM_DEVREADWRITE("ppi8255_1", ppi8255_r, ppi8255_w)
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 // TODO: where are mapped the lower 0x2000 bytes of the banks?
@@ -416,7 +414,7 @@
 	AM_RANGE(0x607e, 0x607e) AM_WRITE(banksel_1_1_w)
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0xbfff) AM_ROM
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( gepoker_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -433,7 +431,7 @@
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0xbfff) AM_ROM /* space for diagnostic ROM? */
 	AM_RANGE(0xe000, 0xffff) AM_ROM
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( amuse1_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -450,7 +448,7 @@
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0xbfff) AM_ROM /* space for diagnostic ROM? */
 	AM_RANGE(0xe000, 0xffff) AM_ROM
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( findout_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -470,7 +468,7 @@
 	AM_RANGE(0x7800, 0x7fff) AM_ROM /*space for diagnostic ROM?*/
 	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
-	AM_RANGE(0xc000, 0xffff) AM_WRITE(gei_bitmap_w)  AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_WRITE(gei_bitmap_w)
 	AM_RANGE(0x0000, 0xffff) AM_READ(catchall)
 ADDRESS_MAP_END
 
@@ -488,7 +486,7 @@
 	AM_RANGE(0x7800, 0x7fff) AM_ROM /*space for diagnostic ROM?*/
 	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
-	AM_RANGE(0xc000, 0xffff) AM_WRITE(gei_bitmap_w)  AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_WRITE(gei_bitmap_w)
 	AM_RANGE(0x0000, 0xffff) AM_READ(catchall)
 ADDRESS_MAP_END
 
@@ -500,9 +498,8 @@
 	AM_RANGE(0x6200, 0x6200) AM_WRITE(signature2_w)
 	AM_RANGE(0x6400, 0x6400) AM_READ(signature_r)
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
-	AM_RANGE(0x8000, 0xbfff) AM_ROM /* space for diagnostic ROM? */
-	AM_RANGE(0xe000, 0xffff) AM_ROM
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_WRITE(gei_bitmap_w)
+	AM_RANGE(0x8000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( geimulti_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -515,7 +512,7 @@
 	AM_RANGE(0x6000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( sprtauth_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -529,7 +526,7 @@
 	AM_RANGE(0x6000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0x8002) AM_WRITE(gei_drawctrl_w)
 	AM_RANGE(0x8000, 0xffff) AM_ROMBANK("bank1")
-	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w) AM_BASE_GENERIC(videoram)
+	AM_RANGE(0xc000, 0xffff) AM_RAM_WRITE(gei_bitmap_w)
 ADDRESS_MAP_END
 
 static INPUT_PORTS_START(reelfun_standard)
@@ -1534,7 +1531,15 @@
 ROM_START( suprpokr )
 	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASEFF )
 	ROM_LOAD( "10-19s-1.e1",  0x00000, 0x4000, CRC(50662b4d) SHA1(967161a755db43d2cfd5ce92e14c5284f1f1f8ad) )
-	ROM_LOAD( "10-19s-1.e2",  0x08000, 0x4000, BAD_DUMP CRC(22b45aeb) SHA1(006c3072cc44c6fde9b4d15163dc70707bbd5a9c) ) /* Self test reports this ROM bad */
+	ROM_LOAD( "10-19s-1.e2",  0x08000, 0x4000, CRC(22b45aeb) SHA1(006c3072cc44c6fde9b4d15163dc70707bbd5a9c) )
+	ROM_RELOAD( 0xc000, 0x4000 )
+ROM_END
+
+ROM_START( suprpkr1 )
+	ROM_REGION( 0x10000, "maincpu", ROMREGION_ERASEFF )
+	ROM_LOAD( "e1.bin",  0x00000, 0x4000, CRC(5cc7c1e0) SHA1(1cdca32c4df7227dab77574abe344b291741139e) )
+	ROM_LOAD( "e2.bin",  0x08000, 0x4000, CRC(e47d6e2a) SHA1(9cabc42275dad8be6cd5b167e381ddb5bf08276d) )
+	ROM_RELOAD( 0xc000, 0x4000 )
 ROM_END
 
 ROM_START( reelfun ) /* v7.03 */
@@ -1872,7 +1877,8 @@
 GAME( 1986, reelfun1, reelfun,  findout,  reelfun,  0,       ROT0, "Greyhound Electronics", "Reel Fun (Version 7.01)",                 GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 GAME( 1987, findout,  0,        findout,  findout,  0,       ROT0, "Elettronolo",           "Find Out (Version 4.04)",                 GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 
-GAME( 1987, suprpokr, 0,        suprpokr, suprpokr, 0,       ROT0, "Greyhound Electronics", "Super Poker",                             GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
+GAME( 1986, suprpokr, 0,        suprpokr, suprpokr, 0,       ROT0, "Grayhound Electronics", "Super Poker (Version 10.19S)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
+GAME( 1986, suprpkr1, suprpokr, suprpokr, suprpokr, 0,       ROT0, "Grayhound Electronics", "Super Poker (Version 10.15S)",            GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 
 GAME( 1991, quiz211,  0,        findout,  quiz,     0,       ROT0, "Elettronolo",           "Quiz (Revision 2.11)",                    GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND )
 
diff -Nru src-old/mame/drivers/genesisb.c src/mame/drivers/genesisb.c
--- src-old/mame/drivers/genesisb.c	2010-08-11 12:12:32.000000000 -0700
+++ src/mame/drivers/genesisb.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,333 +0,0 @@
-/***************************************************************************
-
-    Sega Genesis/Mega Drive-based bootlegs
-
-    Games supported:
-        * Aladdin
-        * Mortal Kombat 3
-        * Super Street Fighter II - The New Challengers
-
-
-Aladdin PCB info
-================
-
-CPU
-Main CPU 68000P10
-Work RAM 64kB (62256 x2)
-Sound CPU Z80B
-Sound RAM 8kB (76c88-6264 x1)
-Sound IC YM2612 (identified by pins,code was been erased.Named on board as TA07)
-
-Other ICs
-Microchip PIC16C57 (probably it contains the MD modified bios)
-Osc 50 MHz
-There are present 3 flat-pack chips with code erased again and named TA04,TA05,TA06 on board,which i have
-identified (generically) by looking the PCB as:
-TA04-Intercommunication and sync generator chip
-TA05-Input controller
-TA06-VDP (probably MD clone) Uses 2x D41264 SIL package as video RAM
-
-ROMs
-
-M3,M4 main program
-M1,M2 graphics
-All EPROMs are 27C040
-
-Notes:
-
-Dip-switch 8 x1
-
-------------------------
-
-This romset comes from a bootleg PCB.The game is a coin-op conversion of the one developed for the Megadrive
-console.I cannot know gameplay differences since PCB is faulty.
-
-However,hardware is totally different.It seems to be based on Sega Mega Drive hardware with CPU clock increased,
-and since exists an "unlicensed" porting of the game for this system probably the "producers" are the same.
-
-
-Stephh's notes (based on the game M68000 code and some tests) :
-
-1) Useful addresses
-
-  - 0xffff88.b = number of credits (range 0x00-0xff but display limited to 9)
-  - 0xff7e3c.b = lives (range 0x30-0x39)
-  - 0xffeffa.b = energy (range 0x00-0x08)
-  - 0xffefe0.w = apples (range 0x30-0x39 * 2 , MSB first)
-  - 0xffefe2.w = jewels (range 0x30-0x39 * 2 , MSB first)
-  - 0xff7e29.b to 0xff7e2e.b = score (range 0x30-0x39 * 6) - MSDigit first
-  - 0xff7e12.b to 0xff7e15.b = ??? (range 0x30-0x33 * 3 + 0x00) - MSDigit first - see below
-  - 0xff7e16.b to 0xff7e19.b = ??? (range 0x30-0x33 * 3 + 0x00) - MSDigit first - see below
-  - 0xff7e21.b = difficulty (range 0x00-0x02) - see below
-
-2) Adresses notes
-
-  - I can't tell what adresses 0xff7r12.l and 0xff7e16.l are supposed to be designed for :
-    they are written once at the begining of each level (code at 0x1a9030) but I haven't found
-    when they were read back (I've only played the 2 first levels though as well as the bonus level,
-    but I also watched all demo levels till the end after the games full credits).
-    I guess they were originally designed for bonus lives (additional and first), but no evidence.
-  - 0xff7e21.b affects contents of 0xff7e3c.b, 0xffefe0.w, 0xff7e12.l and 0xff7e16.l :
-
-                         Easy             Normal             Hard
-                    0xff7e21.b=0x00   0xff7e21.b=0x01   0xff7e21.b=0x02
-      0xff7e3c.b      0x32              0x31              0x30
-      0xffefe0.w      0x3035            0x3032            0x3030
-      0xff7e12.l      0x30313000        0x30313200        0x30313400
-      0xff7e16.l      0x30303900        0x30313200        0x30313500
-
-3) MCU notes
-
-  - As I don't know how it is on real hardware, MCU simulation is more a guess than anything;
-    anyway, the game now runs correctly (coins are handled and settings change)
-  - Difficulty Dip Switches are correct (see code at 0x1b2680)
-  - Coinage Dip Switches might be wrong because I don't know what the possible values can be,
-    but setting them the way I did isn't that bad (see code at 0x1b2a50)
-  - It's possible that writes to 0x220000 are in fact a mask for what is read back from 0x330000,
-    but I haven't found any formula (thus the "lame" read/write handlers you may investigate)
-
-4) Controls notes
-
-  - This game is a one player only game (same as the MegaDrive version);
-    that's why I've "blanked" player 2 inputs which are never read.
-  - I've labelled the buttons the same way as in 'g_aladj' with default options.
-
-5) MegaDrive comparaison ('g_aladj' in HazeMD)
-
-  - There is no "OPTIONS" menu as the difficulty is handled via the MCU / Dip Switches.
-    Some code has been patched but most is still there (see the texts in the ROM ares);
-    Unfortunately, there seems to be no way to access them (no "service" button).
-  - Even with the same settings (same value for 0xff7e21.b), lives and apples,
-    as well as contents of 0xff7e12.l and 0xff7e16.l are really different) !
-    Here is the same data as above for 'g_aladj' :
-
-                         Easy             Normal             Hard
-                    0xff7e21.b=0x00   0xff7e21.b=0x01   0xff7e21.b=0x02
-      0xff7e3c.b      0x35              0x33              0x32
-      0xffefe0.w      0x3135            0x3130            0x3035
-      0xff7e12.l      0x30303600        0x30303800        0x30313000
-      0xff7e16.l      0x30303300        0x30303600        0x30303900
-
-    But what makes the arcade version much harder is how energy is handled : in 'g_aladj', you can
-    be hit 8 times before you lose a life, while in 'aladbl', you lose a life as soon as you are hit !
-    This is done via code change at 0x1aee3c and patched code at 0x1afc00 :
-
-      diff aladbl.asm g_aladj.asm
-
-      < 1AEE3C: 4EB9 001A FC00             jsr     $1afc00.l
-      > 1AEE3C: 5339 00FF EFFA             subq.b  #1, $ffeffa.l
-
-      < 1AFC00: 0C39 0001 00FF F57C        cmpi.b  #$1, $fff57c.l
-      < 1AFC08: 6700 000A                  beq     $1afc14
-      < 1AFC0C: 4239 00FF EFFA             clr.b   $ffeffa.l
-      < 1AFC12: 4E75                       rts
-      < 1AFC14: 5339 00FF EFFA             subq.b  #1, $ffeffa.l
-      < 1AFC1A: 4E75                       rts
-
-    Surprisingly, when you are in "demo mode", player can be again be hit 8 times
-    before losing a life (this is the purpose of the 0xfff57c "flag") !
-
-****************************************************************************/
-
-#include "emu.h"
-#include "includes/megadriv.h"
-
-
-/*************************************
- *
- *  Games memory handlers
- *
- *************************************/
-
-static WRITE16_HANDLER( aladbl_w )
-{
-    /*
-    Values returned from the log file :
-      - aladbl_w : 1b2a6c - data = 6600 (each time a coin is inserted)
-      - aladbl_w : 1b2a82 - data = 0000 (each time a coin is inserted)
-      - aladbl_w : 1b2d18 - data = aa00 (only once on reset)
-      - aladbl_w : 1b2d42 - data = 0000 (only once on reset)
-    */
-	logerror("aladbl_w : %06x - data = %04x\n",cpu_get_pc(space->cpu),data);
-}
-
-static READ16_HANDLER( aladbl_r )
-{
-	if (cpu_get_pc(space->cpu)==0x1b2a56)
-	{
-		static UINT16 mcu_port;
-
-		mcu_port = input_port_read(space->machine, "MCU");
-
-		if(mcu_port & 0x100)
-			return ((mcu_port & 0x0f) | 0x100); // coin inserted, calculate the number of coins
-		else
-			return (0x100); //MCU status, needed if you fall into a pitfall
-	}
-	if (cpu_get_pc(space->cpu)==0x1b2a72) return 0x0000;
-	if (cpu_get_pc(space->cpu)==0x1b2d24) return (input_port_read(space->machine, "MCU") & 0x00f0) | 0x1200;    // difficulty
-	if (cpu_get_pc(space->cpu)==0x1b2d4e) return 0x0000;
-
-	logerror("aladbl_r : %06x\n",cpu_get_pc(space->cpu));
-
-	return 0x0000;
-}
-
-
-static READ16_HANDLER( mk3ghw_dsw_r )
-{
-	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
-	return input_port_read(space->machine, dswname[offset]);
-}
-
-static READ16_HANDLER( ssf2ghw_dsw_r )
-{
-	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
-	return input_port_read(space->machine, dswname[offset]);
-}
-
-/*************************************
- *
- *  ROM definition(s)
- *
- *************************************/
-
-ROM_START( aladbl )
-	ROM_REGION( 0x400000, "maincpu", 0 ) /* 68000 Code */
-	ROM_LOAD16_BYTE( "m1.bin", 0x000001, 0x080000,  CRC(5e2671e4) SHA1(54705c7614fc7b5a1065478fa41f51dd1d8045b7) )
-	ROM_LOAD16_BYTE( "m2.bin", 0x000000, 0x080000,  CRC(142a0366) SHA1(6c94aa9936cd11ccda503b52019a6721e64a32f0) )
-	ROM_LOAD16_BYTE( "m3.bin", 0x100001, 0x080000,  CRC(0feeeb19) SHA1(bd567a33077ab9997871d21736066140d50e3d70) )
-	ROM_LOAD16_BYTE( "m4.bin", 0x100000, 0x080000,  CRC(bc712661) SHA1(dfd554d000399e17b4ddc69761e572195ed4e1f0))
-ROM_END
-
-ROM_START( mk3ghw ) // roms are scrambled, we take care of the address descramble in the ROM load, and the data descramble in the init
-                    // this is bootlegged from  "Mortal Kombat 3 (4) [!].bin"
-	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASE00 ) /* 68000 Code */
-	ROM_LOAD16_BYTE( "1.u1", 0x080001, 0x020000,  CRC(0dc01b23) SHA1(f1aa7ac88c8e3deb5a0a065862722e9d27b87b4c) )
-	ROM_CONTINUE(            0x000001, 0x020000)
-	ROM_CONTINUE(            0x0c0001, 0x020000)
-	ROM_CONTINUE(            0x040001, 0x020000)
-	ROM_LOAD16_BYTE( "2.u3", 0x180001, 0x040000,  CRC(50250235) SHA1(9f9e06f26163b92c76397fde43b38b3536bcb637) )
-	ROM_CONTINUE(            0x100001, 0x040000)
-	ROM_LOAD16_BYTE( "3.u9", 0x280001, 0x040000,  CRC(493404c1) SHA1(73f4bd1eeeee3f175f4378ab406a97f94f88880b) )
-	ROM_CONTINUE(            0x200001, 0x040000)
-	ROM_LOAD16_BYTE( "4.u11",0x380001, 0x040000,  CRC(a52156b8) SHA1(0990ef1fb3427a5d3c262e264feb25c1db75ed33) )
-	ROM_CONTINUE(            0x300001, 0x040000)
-	ROM_LOAD16_BYTE( "6.u2", 0x080000, 0x020000,  CRC(9852fd6f) SHA1(348befeca5129c5ea2c142760ec93511f98f23cc) )
-	ROM_CONTINUE(            0x000000, 0x020000)
-	ROM_CONTINUE(            0x0c0000, 0x020000)
-	ROM_CONTINUE(            0x040000, 0x020000)
-	ROM_LOAD16_BYTE( "5.u4", 0x180000, 0x040000,  CRC(ed6a6d13) SHA1(eaab912ee035ece03f7cfceb1b546004399daad5) )
-	ROM_CONTINUE(            0x100000, 0x040000)
-	ROM_LOAD16_BYTE( "7.u10",0x280000, 0x040000,  CRC(a124d8d1) SHA1(d391b130992701d0fae7e827ba314b8368d809de) )
-	ROM_CONTINUE(            0x200000, 0x040000)
-	ROM_LOAD16_BYTE( "8.u12",0x380000, 0x040000,  CRC(8176f7cc) SHA1(375e1e982b97ba709fb160b04f56f6aa2d580104) )
-	ROM_CONTINUE(            0x300000, 0x040000)
-ROM_END
-
-ROM_START( ssf2ghw )
-	ROM_REGION( 0x1400000, "maincpu", 0 ) /* 68000 Code */
-	/* Special Case, custom PCB, linear ROM mapping of 5meg */
-	ROM_LOAD16_BYTE( "rom_a", 0x000000, 0x200000,  CRC(59726521) SHA1(3120bac17f56c01ffb9d3f9e31efa0263e3774af) )
-	ROM_LOAD16_BYTE( "rom_b", 0x000001, 0x200000,  CRC(7dad5540) SHA1(9279068b2218d239fdd557dd959ac70e74853178) )
-	ROM_LOAD16_BYTE( "rom_c", 0x400000, 0x080000,  CRC(deb48624) SHA1(39ffa7de7b808e0b95cb039bb381705d77420933) )
-	ROM_LOAD16_BYTE( "rom_d", 0x400001, 0x080000,  CRC(b99f6a5b) SHA1(adbe28a7522024bc66328ac86fecf9ded3310e8e) )
-ROM_END
-
-/*************************************
- *
- *  Game-specific driver inits
- *
- *************************************/
-
-#define ENERGY_CONSOLE_MODE 0
-
-static DRIVER_INIT( aladbl )
-{
-	/*
-     * Game does a check @ 1afc00 with work RAM fff57c that makes it play like the original console version (i.e. 8 energy hits instead of 2)
-     */
-	#if ENERGY_CONSOLE_MODE
-	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
-	rom[0x1afc08/2] = 0x6600;
-	#endif
-
-	// 220000 = writes to mcu? 330000 = reads?
-	memory_install_write16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x220000, 0x220001, 0, 0, aladbl_w);
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x330000, 0x330001, 0, 0, aladbl_r);
-
-	DRIVER_INIT_CALL(megadrij);
-}
-
-// this should be correct, the areas of the ROM that differ to the original
-// after this decode look like intentional changes
-static DRIVER_INIT( mk3ghw )
-{
-	int x;
-	UINT8 *rom = memory_region(machine, "maincpu");
-
-	for (x=0x000001;x<0x100001;x+=2)
-	{
-		if (x&0x80000)
-		{
-			rom[x] = rom[x]^0xff;
-			rom[x] = BITSWAP8(rom[x], 0,3,2,5,4,6,7,1);
-		}
-		else
-		{
-			rom[x] = rom[x]^0xff;
-			rom[x] = BITSWAP8(rom[x], 4,0,7,1,3,6,2,5);
-		}
-	}
-
-	for (x=0x100001;x<0x400000;x+=2)
-	{
-		if (x&0x80000)
-		{
-			rom[x] = rom[x]^0xff;
-			rom[x] = BITSWAP8(rom[x], 2,7,5,4,1,0,3,6);
-		}
-		else
-		{
-			rom[x] = BITSWAP8(rom[x], 6,1,4,2,7,0,3,5);
-		}
-	}
-
-	// boot vectors don't seem to be valid, so they are patched...
-	rom[0x01] = 0x01;
-	rom[0x00] = 0x00;
-	rom[0x03] = 0x00;
-	rom[0x02] = 0x00;
-	rom[0x05] = 0x00;
-	rom[0x04] = 0x00;
-	rom[0x07] = 0x02;
-	rom[0x06] = 0x10;
-
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x770070, 0x770075, 0, 0, mk3ghw_dsw_r );
-
-	DRIVER_INIT_CALL(megadriv);
-}
-
-static DRIVER_INIT( ssf2ghw )
-{
-	memory_nop_write(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0xA130F0, 0xA130FF, 0, 0); // custom banking is disabled (!)
-	memory_install_read_bank(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x400000, 0x5fffff, 0, 0, "bank5");
-	memory_unmap_write(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x400000, 0x5fffff, 0, 0);
-
-	memory_set_bankptr(machine,  "bank5", memory_region( machine, "maincpu" ) + 0x400000 );
-
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x770070, 0x770075, 0, 0, ssf2ghw_dsw_r );
-
-	DRIVER_INIT_CALL(megadrij);
-
-}
-
-/*************************************
- *
- *  Game driver(s)
- *
- *************************************/
-
-GAME( 1993, aladbl,   0, megadriv, aladbl,   aladbl,   ROT0, "bootleg / Sega",   "Aladdin (bootleg of Japanese Megadrive version)", 0)
-GAME( 1996, mk3ghw,   0, megadriv, mk3ghw,   mk3ghw,   ROT0, "bootleg / Midway", "Mortal Kombat 3 (bootleg of Megadrive version)", 0)
-GAME( 1994, ssf2ghw,  0, megadriv, ssf2ghw,  ssf2ghw,  ROT0, "bootleg / Capcom", "Super Street Fighter II - The New Challengers (Arcade bootleg of Japanese MegaDrive version)", 0 )
diff -Nru src-old/mame/drivers/goldnpkr.c src/mame/drivers/goldnpkr.c
--- src-old/mame/drivers/goldnpkr.c	2010-06-27 23:40:44.000000000 -0700
+++ src/mame/drivers/goldnpkr.c	2010-08-30 08:20:58.000000000 -0700
@@ -54,6 +54,7 @@
     * Buena Suerte (Spanish, set 20).           1991, Unknown.
     * Buena Suerte (Spanish, set 21).           1991, Unknown.
     * Buena Suerte (Spanish, set 22).           1991, Unknown.
+    * Genie.                                    198?, Video Fun Games Ltd.
 
 
 *******************************************************************************
@@ -626,9 +627,9 @@
 #include "goldnpkr.lh"
 
 
-/*************************
-*     Video Hardware     *
-*************************/
+/*********************************************
+*               Video Hardware               *
+*********************************************/
 
 static UINT8 *videoram;
 static UINT8 *colorram;
@@ -666,7 +667,7 @@
 
 static VIDEO_START( goldnpkr )
 {
-	bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 29);
+	bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 }
 
 static VIDEO_UPDATE( goldnpkr )
@@ -766,9 +767,9 @@
 }
 
 
-/***********************
-*     R/W Handlers     *
-***********************/
+/*******************************************
+*               R/W Handlers               *
+*******************************************/
 
 static int mux_data = 0;
 static UINT8 pia0_PA_data;
@@ -889,9 +890,9 @@
 }
 
 
-/*************************
-* Memory Map Information *
-*************************/
+/*********************************************
+*           Memory Map Information           *
+*********************************************/
 
 static ADDRESS_MAP_START( goldnpkr_map, ADDRESS_SPACE_PROGRAM, 8 )
 	ADDRESS_MAP_GLOBAL_MASK(0x7fff)
@@ -943,9 +944,22 @@
 
 */
 
-/*************************
-*      Input Ports       *
-*************************/
+static ADDRESS_MAP_START( genie_map, ADDRESS_SPACE_PROGRAM, 8 )
+	ADDRESS_MAP_GLOBAL_MASK(0x3fff)
+	AM_RANGE(0x0000, 0x07ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)	/* battery backed RAM */
+	AM_RANGE(0x0800, 0x0800) AM_DEVWRITE("crtc", mc6845_address_w)
+	AM_RANGE(0x0801, 0x0801) AM_DEVREADWRITE("crtc", mc6845_register_r, mc6845_register_w)
+	AM_RANGE(0x0844, 0x0847) AM_DEVREADWRITE("pia0", pia6821_r, pia6821_w)
+	AM_RANGE(0x0848, 0x084b) AM_DEVREADWRITE("pia1", pia6821_r, pia6821_w)
+	AM_RANGE(0x1000, 0x17ff) AM_RAM_WRITE(goldnpkr_videoram_w) AM_BASE(&videoram)
+	AM_RANGE(0x1800, 0x1fff) AM_RAM_WRITE(goldnpkr_colorram_w) AM_BASE(&colorram)
+	AM_RANGE(0x2000, 0x3fff) AM_ROM
+ADDRESS_MAP_END
+
+
+/*********************************************
+*                Input Ports                 *
+*********************************************/
 
 static INPUT_PORTS_START( goldnpkr )
 	/* Multiplexed - 4x5bits */
@@ -1960,10 +1974,80 @@
 	PORT_DIPSETTING(    0x00, "Oculta" )
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( genie )
+	/* Multiplexed - 4x5bits */
+	PORT_START("IN0-0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_GAMBLE_BET )   PORT_CODE(KEYCODE_1)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_GAMBLE_BOOK )  PORT_NAME("Bookkeeping")
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_D_UP )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_DEAL )  PORT_NAME("Play")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_POKER_CANCEL )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER )        PORT_NAME("Collect") PORT_CODE(KEYCODE_W)
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_GAMBLE_TAKE )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_GAMBLE_HIGH )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_GAMBLE_LOW )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_POKER_HOLD1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_POKER_HOLD2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_POKER_HOLD3 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_POKER_HOLD4 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_POKER_HOLD5 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0-3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_NAME("Settings") PORT_CODE(KEYCODE_9)
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN2 )   PORT_NAME("Coupon (Note In)")
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_COIN1 )   PORT_IMPULSE(3) PORT_NAME("Coin In")
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("SW1")
+	/* only bits 4-7 are connected here and were routed to SW1 1-4 */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unused ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x00, "Min Wining Hand" )	PORT_DIPLOCATION("SW1:1")
+	PORT_DIPSETTING(    0x10, "Double Pair" )
+	PORT_DIPSETTING(    0x00, "Pair of 11's" )
+	PORT_DIPNAME( 0x20, 0x20, "50hz/60hz" )			PORT_DIPLOCATION("SW1:2")
+	PORT_DIPSETTING(    0x20, "50hz" )
+	PORT_DIPSETTING(    0x00, "60hz" )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW1:3")
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unknown ) )	PORT_DIPLOCATION("SW1:4")
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+INPUT_PORTS_END
+
 
-/*************************
-*    Graphics Layouts    *
-*************************/
+/*********************************************
+*              Graphics Layouts              *
+*********************************************/
 
 static const gfx_layout tilelayout =
 {
@@ -1977,9 +2061,9 @@
 };
 
 
-/******************************
-* Graphics Decode Information *
-******************************/
+/**************************************************
+*           Graphics Decode Information           *
+**************************************************/
 
 static GFXDECODE_START( goldnpkr )
 	GFXDECODE_ENTRY( "gfx1", 0, tilelayout, 0, 16 )
@@ -1987,9 +2071,9 @@
 GFXDECODE_END
 
 
-/***********************
-*    PIA Interfaces    *
-***********************/
+/*******************************************
+*              PIA Interfaces              *
+*******************************************/
 
 /***** Golden Poker Double Up *****/
 
@@ -2044,9 +2128,9 @@
 };
 
 
-/************************
-*    CRTC Interface    *
-************************/
+/*******************************************
+*              CRTC Interface              *
+*******************************************/
 
 static const mc6845_interface mc6845_intf =
 {
@@ -2063,9 +2147,9 @@
 };
 
 
-/**************************************
-*       Discrete Sound Routines       *
-***************************************
+/**********************************************************
+*                 Discrete Sound Routines                 *
+***********************************************************
 
     Golden Poker Double-Up discrete sound circuitry.
     ------------------------------------------------
@@ -2199,9 +2283,9 @@
 DISCRETE_SOUND_END
 
 
-/*************************
-*    Machine Drivers     *
-*************************/
+/*********************************************
+*              Machine Drivers               *
+*********************************************/
 
 static MACHINE_DRIVER_START( goldnpkr_base )
 
@@ -2262,6 +2346,7 @@
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_DRIVER_END
 
+
 static MACHINE_DRIVER_START( witchcrd )
 
 	MDRV_IMPORT_FROM(goldnpkr_base)
@@ -2283,9 +2368,30 @@
 MACHINE_DRIVER_END
 
 
-/*************************
-*        Rom Load        *
-*************************/
+static MACHINE_DRIVER_START( genie )
+
+	MDRV_IMPORT_FROM(goldnpkr_base)
+
+	/* basic machine hardware */
+	MDRV_CPU_MODIFY("maincpu")
+	MDRV_CPU_PROGRAM_MAP(genie_map)
+
+	MDRV_PIA6821_MODIFY("pia0", pottnpkr_pia0_intf)
+
+	/* video hardware */
+	MDRV_PALETTE_INIT(witchcrd)
+
+	/* sound hardware */
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+	MDRV_SOUND_ADD("discrete", DISCRETE, 0)
+	MDRV_SOUND_CONFIG_DISCRETE(goldnpkr)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_DRIVER_END
+
+
+/*********************************************
+*                  Rom Load                  *
+*********************************************/
 
 /*  the original goldnpkr u40_4a.bin rom is bit corrupted.
     U43_2A.bin        BADADDR      --xxxxxxxxxxx
@@ -2463,7 +2569,7 @@
 ROM_END
 
 
-/***************** NEW SETS **************************/
+/************************* NEW SETS **************************/
 
 
 ROM_START( potnpkrd )
@@ -2796,7 +2902,7 @@
 ROM_END
 
 
-/******************************* bsuerte sets **************************/
+/******************************* bsuerte sets *******************************/
 /*
     checksum routine at $5827
     protect $4000+ & $7ff9.
@@ -3177,10 +3283,61 @@
 	ROM_LOAD( "82s129.9c",		0x0000, 0x0100, CRC(7f31066b) SHA1(15420780ec6b2870fc4539ec3afe4f0c58eedf12) ) /* PROM dump needed */
 ROM_END
 
+/******************************* Other sets *******************************/
+
+/****************************************************
+
+  Genie (Video Fun Games Ltd.)
+  Skill game. Only for amusement.
+
+  PCB is a heavily modified Golden Poker hardware.
+  Silkscreened "ICP-1".
+
+  CPU:   1x SY6502.
+  Video: 1x HD6845P CRTC.
+  I/O:   2x HD6821P PIAs.
+
+  Sound: Discrete.
+
+  RAMs:  2x M5L5101LP-1.
+
+  ROMs:  2x 2732 for program. (2m.16a, 3m.17a)
+         1x 2716 for char gen. (4.8a)
+         3x 2716 for gfx bitplanes. (1.4a, 2.6a, 3.7a)
+
+  1x Reset switch. (R.SW)
+  1x 8 DIP switches bank.
+  1x 2x10 Edge connector. (GM1)
+  1x 2x22 Edge connector. (GM2)
+
+
+*****************************************************/
+
+ROM_START( genie )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "2m.16a",	0x2000, 0x1000, CRC(30df75f5) SHA1(0696fb3db0b9927e6366db7316d605914ff8d464) )
+	ROM_LOAD( "3m.17a",	0x3000, 0x1000, CRC(9d67f5c9) SHA1(d3bc13ce07a7b1713544756d7723dd0bcd59cd1a) )
+
+	ROM_REGION( 0x1800, "gfx1", 0 )
+	ROM_FILL(			0x0000, 0x1000, 0 ) /* filling the R-G bitplanes */
+	ROM_LOAD( "4.8a",	0x1000, 0x0800, CRC(1cdd1db9) SHA1(1940c6654b4a892abc3e4557666d341f407ac54f) )  /* chars gfx */
+
+	ROM_REGION( 0x1800, "gfx2", 0 )
+	ROM_LOAD( "1.4a",	0x0000, 0x0800, CRC(40c52b9d) SHA1(64145bd2aa19b584fa56022303dc595320952c24) )  /* tiles, bitplane1 */
+	ROM_LOAD( "2.6a",	0x0800, 0x0800, CRC(b0b61ffa) SHA1(d0a01027bd6acd7c72eb5bbdb37d6dd97df8aced) )  /* tiles, bitplane2 */
+	ROM_LOAD( "3.7a",	0x1000, 0x0800, CRC(151e4af7) SHA1(a44feaa69a00a6db31c018267b8b67a248e7c66e) )  /* tiles, bitplane3 */
+
+	ROM_REGION( 0x0800,	"nvram", 0 )	/* default NVRAM, otherwise the game isn't stable */
+	ROM_LOAD( "genie_nvram.bin", 0x0000, 0x0800, CRC(1b062ae7) SHA1(9d01635f3968d4b91b4a5d9fadfaf6edd0dea7ba) )
+
+	ROM_REGION( 0x0100, "proms", 0 )	/* using original golden poker color prom */
+	ROM_LOAD( "n82s129.9c",	0x0000, 0x0100, BAD_DUMP CRC(7f31066b) SHA1(15420780ec6b2870fc4539ec3afe4f0c58eedf12) )
+ROM_END
+
 
-/*************************
-*      Driver Init       *
-*************************/
+/*********************************************
+*                Driver Init                 *
+*********************************************/
 
 /*
     Golden Poker H/W sets:
@@ -3229,9 +3386,9 @@
 //  ROM[0x60bc] = 0xea;
 }
 
-/*************************
-*      Game Drivers      *
-*************************/
+/*********************************************
+*                Game Drivers                *
+*********************************************/
 
 /*     YEAR  NAME      PARENT    MACHINE   INPUT     INIT      ROT      COMPANY                      FULLNAME                                  FLAGS             LAYOUT  */
 GAMEL( 1981, goldnpkr, 0,        goldnpkr, goldnpkr, 0,        ROT0,   "Bonanza Enterprises, Ltd",  "Golden Poker Double Up (Big Boy)",        0,                layout_goldnpkr )
@@ -3280,3 +3437,4 @@
 GAMEL( 1991, bsuertes, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                 "Buena Suerte (Spanish, set 20)",          0,                layout_goldnpkr )
 GAMEL( 1991, bsuertet, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                 "Buena Suerte (Spanish, set 21)",          0,                layout_goldnpkr )
 GAMEL( 1991, bsuerteu, bsuerte,  witchcrd, bsuerte,  0,        ROT0,   "<unknown>",                 "Buena Suerte (Spanish, set 22)",          0,                layout_goldnpkr )
+GAME(  198?, genie,    0,        genie,    genie,    0,        ROT0,   "Video Fun Games Ltd.",      "Genie",                                   0 )
diff -Nru src-old/mame/drivers/goldstar.c src/mame/drivers/goldstar.c
--- src-old/mame/drivers/goldstar.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/goldstar.c	2010-08-26 08:21:19.000000000 -0700
@@ -5855,6 +5855,7 @@
 
 MACHINE_DRIVER_END
 
+#ifdef UNUSED_CODE
 static MACHINE_DRIVER_START( cmnobmp )
 
 	MDRV_DRIVER_DATA(goldstar_state)
@@ -5891,6 +5892,7 @@
 	MDRV_SOUND_CONFIG(cm_ay8910_config)
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_DRIVER_END
+#endif
 
 static MACHINE_DRIVER_START( cmast91 )
 
diff -Nru src-old/mame/drivers/guab.c src/mame/drivers/guab.c
--- src-old/mame/drivers/guab.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/guab.c	2010-08-19 01:27:05.000000000 -0700
@@ -573,11 +573,11 @@
 	if (newval == 0)
 	{
 		UINT32 credit;
-		const address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 		/* Get the current credit value and add the new coin value */
-		credit = memory_read_dword(space, 0x8002c) + (UINT32)(FPTR)param;
-		memory_write_dword(space, 0x8002c, credit);
+		credit = space->read_dword(0x8002c) + (UINT32)(FPTR)param;
+		space->write_dword(0x8002c, credit);
 	}
 }
 
diff -Nru src-old/mame/drivers/harddriv.c src/mame/drivers/harddriv.c
--- src-old/mame/drivers/harddriv.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/harddriv.c	2010-08-19 06:30:03.000000000 -0700
@@ -3963,25 +3963,6 @@
 }
 
 
-static READ32_HANDLER( rddsp32_speedup_r )
-{
-	harddriv_state *state = space->machine->driver_data<harddriv_state>();
-	if (cpu_get_pc(space->cpu) == state->rddsp32_speedup_pc && (*state->rddsp32_speedup >> 16) == 0)
-	{
-		UINT32 r14 = cpu_get_reg(space->cpu, DSP32_R14);
-		UINT32 r1 = memory_read_word(space, r14 - 0x14);
-		int cycles_to_burn = 17 * 4 * (0x2bc - r1 - 2);
-		if (cycles_to_burn > 20 * 4)
-		{
-			cpu_eat_cycles(space->cpu, cycles_to_burn);
-			memory_write_word(space, r14 - 0x14, r1 + cycles_to_burn / 17);
-		}
-		state->msp_speedup_count[0]++;
-	}
-	return *state->rddsp32_speedup;
-}
-
-
 static DRIVER_INIT( racedriv )
 {
 	harddriv_state *state = machine->driver_data<harddriv_state>();
@@ -4002,10 +3983,6 @@
 
 	/* set up adsp speedup handlers */
 	memory_install_read16_handler(cpu_get_address_space(state->adsp, ADDRESS_SPACE_DATA), 0x1fff, 0x1fff, 0, 0, hdadsp_speedup_r);
-
-	/* set up dsp32 speedup handlers */
-	state->rddsp32_speedup = memory_install_read32_handler(cpu_get_address_space(state->dsp32, ADDRESS_SPACE_PROGRAM), 0x613e04, 0x613e07, 0, 0, rddsp32_speedup_r);
-	state->rddsp32_speedup_pc = 0x6054b0;
 }
 
 
@@ -4037,10 +4014,6 @@
 
 	/* set up adsp speedup handlers */
 	memory_install_read16_handler(cpu_get_address_space(state->adsp, ADDRESS_SPACE_DATA), 0x1fff, 0x1fff, 0, 0, hdadsp_speedup_r);
-
-	/* set up dsp32 speedup handlers */
-	state->rddsp32_speedup = memory_install_read32_handler(cpu_get_address_space(state->dsp32, ADDRESS_SPACE_PROGRAM), 0x613e04, 0x613e07, 0, 0, rddsp32_speedup_r);
-	state->rddsp32_speedup_pc = 0x6054b0;
 }
 
 static DRIVER_INIT( racedrivc ) { racedrivc_init_common(machine, 0xfff95cd0); }
diff -Nru src-old/mame/drivers/hng64.c src/mame/drivers/hng64.c
--- src-old/mame/drivers/hng64.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/hng64.c	2010-08-26 20:55:49.000000000 -0700
@@ -447,46 +447,7 @@
 #include "cpu/mips/mips3.h"
 #include "includes/hng64.h"
 
-int hng64_mcu_type = 0;
-static UINT32 fake_mcu_time;
-static UINT16 hng_mcu_en;
-
-static UINT32 *rombase;
-static UINT32 *hng_mainram;
-static UINT32 *hng_cart;
-static UINT32 *hng64_dualport;
-static UINT16 *hng64_soundram;
-static UINT32 *hng64_sysregs;
-
-// Stuff from over in video...
-extern WRITE32_HANDLER( hng64_videoram_w );
-extern UINT32 *hng64_spriteram, *hng64_videoregs, *hng64_spriteregs;
-extern UINT32 *hng64_videoram;
-extern UINT32 *hng64_tcram;
-extern UINT32 *hng64_3dregs;
-
-extern void hng64_command3d(running_machine* machine, const UINT16* packet);
-
-extern UINT8 hng64_screen_dis;
-
-VIDEO_START( hng64 );
-VIDEO_UPDATE( hng64 );
-
-static UINT32 activeBuffer;
-static UINT32 no_machine_error_code;
-static int hng64_interrupt_level_request;
-
-/* 3D stuff */
-static UINT32 *hng64_3d_1;
-static UINT32 *hng64_3d_2;
-static UINT32 *hng64_dl;
-//static UINT32 *hng64_q2;
-
-/* Communications stuff */
-static UINT32 *hng64_com_ram;
-static UINT8  *hng64_com_op_base;
-static UINT8  *hng64_com_mmu_mem;
-static UINT8  *hng64_com_virtual_mem;
+
 
 
 #ifdef UNUSED_FUNCTION
@@ -503,34 +464,36 @@
 
 static READ32_HANDLER( hng64_com_r )
 {
-	logerror("com read  (PC=%08x): %08x %08x = %08x\n", cpu_get_pc(space->cpu), (offset*4)+0xc0000000, mem_mask, hng64_com_ram[offset]);
-	return hng64_com_ram[offset];
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	logerror("com read  (PC=%08x): %08x %08x = %08x\n", cpu_get_pc(space->cpu), (offset*4)+0xc0000000, mem_mask, state->com_ram[offset]);
+	return state->com_ram[offset];
 }
 
 static WRITE32_HANDLER( hng64_com_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	logerror("com write (PC=%08x): %08x %08x = %08x\n", cpu_get_pc(space->cpu), (offset*4)+0xc0000000, mem_mask, data);
-	COMBINE_DATA(&hng64_com_ram[offset]);
+	COMBINE_DATA(&state->com_ram[offset]);
 }
 
-
-static UINT32 hng64_com_shared_a;
-static UINT32 hng64_com_shared_b;
-
 static WRITE32_HANDLER( hng64_com_share_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	logerror("commw  (PC=%08x): %08x %08x %08x\n", cpu_get_pc(space->cpu), data, (offset*4)+0xc0001000, mem_mask);
 
-	if (offset==0x0) COMBINE_DATA(&hng64_com_shared_a);
-	if (offset==0x1) COMBINE_DATA(&hng64_com_shared_b);
+	if (offset == 0x0) COMBINE_DATA(&state->com_shared_a);
+	if (offset == 0x1) COMBINE_DATA(&state->com_shared_b);
 }
 
 static READ32_HANDLER( hng64_com_share_r )
 {
 	logerror("commr  (PC=%08x): %08x %08x\n", cpu_get_pc(space->cpu), (offset*4)+0xc0001000, mem_mask);
 
-//  if(offset==0x0) return hng64_com_shared_a;
-//  if(offset==0x1) return hng64_com_shared_b;
+	//if(offset == 0x0) return state->com_shared_a;
+	//if(offset == 0x1) return state->com_shared_b;
 
 	if(offset==0x0) return 0x0000aaaa;
 	if(offset==0x1)	return 0x00030000;		// fatfurwa : at bfc06624 it wants a 01 : at bfc06650 it wants a 02
@@ -540,23 +503,29 @@
 
 static WRITE32_HANDLER( hng64_pal_w )
 {
+	UINT32 *paletteram = space->machine->generic.paletteram.u32;
 	int r, g, b/*, a*/;
-	COMBINE_DATA(&space->machine->generic.paletteram.u32[offset]);
 
-	b = ((space->machine->generic.paletteram.u32[offset] & 0x000000ff) >>0);
-	g = ((space->machine->generic.paletteram.u32[offset] & 0x0000ff00) >>8);
-	r = ((space->machine->generic.paletteram.u32[offset] & 0x00ff0000) >>16);
-	//a = ((space->machine->generic.paletteram.u32[offset] & 0xff000000) >>24);
+	COMBINE_DATA(&paletteram[offset]);
+
+	b = ((paletteram[offset] & 0x000000ff) >>0);
+	g = ((paletteram[offset] & 0x0000ff00) >>8);
+	r = ((paletteram[offset] & 0x00ff0000) >>16);
+	//a = ((paletteram[offset] & 0xff000000) >>24);
 	palette_set_color(space->machine,offset,MAKE_RGB(r,g,b));
 }
 
 static READ32_HANDLER( hng64_sysregs_r )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
 	system_time systime;
+
 	space->machine->base_datetime(systime);
 
-//  if((offset*4) != 0x1084)
-//      printf("HNG64 port read (PC=%08x) 0x%08x\n", cpu_get_pc(space->cpu),offset*4);
+#if 0
+	if((offset*4) != 0x1084)
+		printf("HNG64 port read (PC=%08x) 0x%08x\n", cpu_get_pc(space->cpu), offset*4);
+#endif
 
 	switch(offset*4)
 	{
@@ -565,7 +534,7 @@
 		//case 0x107c:
 		case 0x1084: return 0x00000002; //MCU->MIPS latch port
 		//case 0x108c:
-		case 0x1104: return hng64_interrupt_level_request;
+		case 0x1104: return state->interrupt_level_request;
 		case 0x1254: return 0x00000000; //dma status, 0x800
 		/* 4-bit RTC */
 		case 0x2104: return (systime.local_time.second % 10);
@@ -590,25 +559,25 @@
 //  printf("%08x\n",offset*4);
 
 //  return mame_rand(space->machine)&0xffffffff;
-	return hng64_sysregs[offset];
+	return state->sysregs[offset];
 }
 
 /* preliminary dma code, dma is used to copy program code -> ram */
-static INT32 hng_dma_start,hng_dma_dst,hng_dma_len;
-
-static void hng64_do_dma(const address_space *space)
+static void hng64_do_dma(address_space *space)
 {
-//  printf("Performing DMA Start %08x Len %08x Dst %08x\n",hng_dma_start, hng_dma_len, hng_dma_dst);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
 
-	while (hng_dma_len>=0)
+	//printf("Performing DMA Start %08x Len %08x Dst %08x\n", state->dma_start, state->dma_len, state->dma_dst);
+
+	while (state->dma_len >= 0)
 	{
 		UINT32 dat;
 
-		dat = memory_read_dword(space,hng_dma_start);
-		memory_write_dword(space,hng_dma_dst,dat);
-		hng_dma_start+=4;
-		hng_dma_dst+=4;
-		hng_dma_len--;
+		dat = space->read_dword(state->dma_start);
+		space->write_dword(state->dma_dst, dat);
+		state->dma_start += 4;
+		state->dma_dst += 4;
+		state->dma_len--;
 	}
 }
 
@@ -626,28 +595,32 @@
 
 static WRITE32_HANDLER( hng64_sysregs_w )
 {
-	COMBINE_DATA (&hng64_sysregs[offset]);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	COMBINE_DATA (&state->sysregs[offset]);
 
-//  if(((offset*4) & 0x1200) == 0x1200)
-//      printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, hng64_sysregs[offset], cpu_get_pc(space->cpu));
+#if 0
+	if(((offset*4) & 0x1200) == 0x1200)
+		printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, state->sysregs[offset], cpu_get_pc(space->cpu));
+#endif
 
 	switch(offset*4)
 	{
 		//case 0x100c: *DOCUMENT*
 
 		case 0x1084: //MIPS->MCU latch port
-			hng_mcu_en = (data & 0xff); //command-based, i.e. doesn't control halt line and such?
-			//printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, hng64_sysregs[offset], cpu_get_pc(space->cpu));
+			state->mcu_en = (data & 0xff); //command-based, i.e. doesn't control halt line and such?
+			//printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, state->sysregs[offset], cpu_get_pc(space->cpu));
 			break;
 		case 0x111c: /*irq ack */ break;
-		case 0x1204: hng_dma_start = hng64_sysregs[offset]; break;
-		case 0x1214: hng_dma_dst = hng64_sysregs[offset]; break;
+		case 0x1204: state->dma_start = state->sysregs[offset]; break;
+		case 0x1214: state->dma_dst = state->sysregs[offset]; break;
 		case 0x1224:
-			hng_dma_len = hng64_sysregs[offset];
+			state->dma_len = state->sysregs[offset];
 			hng64_do_dma(space);
 			break;
 		//default:
-			//printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, hng64_sysregs[offset], cpu_get_pc(space->cpu));
+			//printf("HNG64 writing to SYSTEM Registers 0x%08x == 0x%08x. (PC=%08x)\n", offset*4, state->sysregs[offset], cpu_get_pc(space->cpu));
 	}
 }
 
@@ -658,56 +631,62 @@
 /* Fatal Fury Wild Ambition / Buriki One */
 static READ32_HANDLER( fight_io_r )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	switch (offset*4)
 	{
 		case 0x000: return 0x00000400;
 		case 0x004: return input_port_read(space->machine, "SYSTEM");
 		case 0x008: return input_port_read(space->machine, "P1_P2");
-		case 0x600: return no_machine_error_code;
+		case 0x600: return state->no_machine_error_code;
 	}
 
-	return hng64_dualport[offset];
+	return state->dualport[offset];
 }
 
 /* Samurai Shodown 64 / Samurai Shodown 64 2 */
 static READ32_HANDLER( samsho_io_r )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	switch (offset*4)
 	{
         case 0x000:
 		{
 			/* this is used on post by the io mcu to signal that a init task is complete, zeroed otherwise. */
-			//popmessage("%04x",fake_mcu_time);
+			//popmessage("%04x", state->mcu_fake_time);
 
-			if(fake_mcu_time < 0x100)
-				fake_mcu_time++;
+			if(state->mcu_fake_time < 0x100)
+				state->mcu_fake_time++;
 
-			if(fake_mcu_time < 0x80) //i/o init 1
+			if(state->mcu_fake_time < 0x80) //i/o init 1
 				return 0x300;
-			else if(fake_mcu_time < 0x100)//i/o init 2
+			else if(state->mcu_fake_time < 0x100)//i/o init 2
 				return 0x400;
 			else
 				return 0x000;
 		}
 		case 0x004: return input_port_read(space->machine, "SYSTEM");
 		case 0x008: return input_port_read(space->machine, "P1_P2");
-		case 0x600: return no_machine_error_code;
+		case 0x600: return state->no_machine_error_code;
 	}
 
-	return hng64_dualport[offset];
+	return state->dualport[offset];
 }
 
 /* Beast Busters 2 */
 /* FIXME: trigger input doesn't work? */
 static READ32_HANDLER( shoot_io_r )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	switch (offset*4)
 	{
         case 0x000:
         {
-			if(fake_mcu_time < 0x100)//i/o init
+			if(state->mcu_fake_time < 0x100)//i/o init
 			{
-				fake_mcu_time++;
+				state->mcu_fake_time++;
 				return 0x400;
 			}
 			else
@@ -715,13 +694,11 @@
 		}
 		case 0x010:
 		{
-			static UINT32 p1_trig;
-
 			/* Quick kludge for use the input test items */
 			if(input_port_read(space->machine, "D_IN") & 0x01000000)
-				p1_trig = mame_rand(space->machine) & 0x01000000;
+				state->p1_trig = mame_rand(space->machine) & 0x01000000;
 
-			return (input_port_read(space->machine, "D_IN") & ~0x01000000) | (p1_trig);
+			return (input_port_read(space->machine, "D_IN") & ~0x01000000) | (state->p1_trig);
 		}
 		case 0x018:
 		{
@@ -741,22 +718,24 @@
 
 			return p3_x<<24 | p3_y<<16 | p3_x<<8 | p3_y; //FIXME: see what's the right bank here when the trigger works
 		}
-		case 0x600: return no_machine_error_code;
+		case 0x600: return state->no_machine_error_code;
 	}
 
-	return hng64_dualport[offset];
+	return state->dualport[offset];
 }
 
 /* Roads Edge / Xtreme Rally */
 static READ32_HANDLER( racing_io_r )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
 	switch (offset*4)
 	{
         case 0x000:
         {
-			if(fake_mcu_time < 0x100)//i/o init
+			if(state->mcu_fake_time < 0x100)//i/o init
 			{
-				fake_mcu_time++;
+				state->mcu_fake_time++;
 				return 0x400;
 			}
 			else
@@ -764,15 +743,17 @@
 		}
 		case 0x004: return input_port_read(space->machine, "SYSTEM");
 		case 0x008: return input_port_read(space->machine, "P1_P2");
-		case 0x600: return no_machine_error_code;
+		case 0x600: return state->no_machine_error_code;
 	}
 
-	return hng64_dualport[offset];
+	return state->dualport[offset];
 }
 
 static READ32_HANDLER( hng64_dualport_r )
 {
-//  printf("dualport R %08x %08x (PC=%08x)\n", offset*4, hng64_dualport[offset], cpu_get_pc(space->cpu));
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	//printf("dualport R %08x %08x (PC=%08x)\n", offset*4, hng64_dualport[offset], cpu_get_pc(space->cpu));
 
 	/*
     command table:
@@ -783,11 +764,10 @@
 
     (*) 0x11 is followed by 0x0b if the latter is used, JVS-esque indirect/direct mode?
     */
+	if (state->mcu_en == 0x0c)
+		return state->dualport[offset];
 
-	if(hng_mcu_en == 0x0c)
-		return hng64_dualport[offset];
-
-	switch(hng64_mcu_type)
+	switch (state->mcu_type)
 	{
 		case FIGHT_MCU:  return fight_io_r(space, offset,0xffffffff);
 		case SHOOT_MCU:  return shoot_io_r(space, offset,0xffffffff);
@@ -795,7 +775,7 @@
 		case SAMSHO_MCU: return samsho_io_r(space, offset,0xffffffff);
 	}
 
-	return hng64_dualport[offset];
+	return state->dualport[offset];
 }
 
 /*
@@ -810,8 +790,10 @@
 
 static WRITE32_HANDLER( hng64_dualport_w )
 {
-//  printf("dualport WRITE %08x %08x (PC=%08x)\n", offset*4, hng64_dualport[offset], cpu_get_pc(space->cpu));
-	COMBINE_DATA (&hng64_dualport[offset]);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	//printf("dualport WRITE %08x %08x (PC=%08x)\n", offset*4, hng64_dualport[offset], cpu_get_pc(space->cpu));
+	COMBINE_DATA (&state->dualport[offset]);
 }
 
 
@@ -823,7 +805,9 @@
 //   <ElSemi> 30140000-3015ffff is ZBuffer A
 static READ32_HANDLER( hng64_3d_1_r )
 {
-	return hng64_3d_1[offset];
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	return state->_3d_1[offset];
 }
 
 #ifdef UNUSED_FUNCTION
@@ -835,18 +819,24 @@
 
 static READ32_HANDLER( hng64_3d_2_r )
 {
-	return hng64_3d_2[offset];
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	return state->_3d_2[offset];
 }
 
 static WRITE32_HANDLER( hng64_3d_2_w )
 {
-	COMBINE_DATA (&hng64_3d_1[offset]);
-	COMBINE_DATA (&hng64_3d_2[offset]);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	COMBINE_DATA (&state->_3d_1[offset]);
+	COMBINE_DATA (&state->_3d_2[offset]);
 }
 
 // The 3d 'display list'
 static WRITE32_HANDLER( dl_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+	UINT32 *hng64_dl = state->dl;
 	int i;
 	UINT16 packet3d[16];
 
@@ -913,11 +903,14 @@
 // Transition Control memory.
 static WRITE32_HANDLER( tcram_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+	UINT32 *hng64_tcram = state->tcram;
+
 	COMBINE_DATA (&hng64_tcram[offset]);
 
 	if(offset == 0x02)
 	{
-		static UINT16 min_x,min_y,max_x,max_y;
+		UINT16 min_x, min_y, max_x, max_y;
 		rectangle visarea = space->machine->primary_screen->visible_area();
 
 		min_x = (hng64_tcram[1] & 0xffff0000) >> 16;
@@ -927,11 +920,11 @@
 
 		if(max_x == 0 || max_y == 0) // bail out if values are invalid, Fatal Fury WA sets this to disable the screen.
 		{
-			hng64_screen_dis = 1;
+			state->screen_dis = 1;
 			return;
 		}
 
-		hng64_screen_dis = 0;
+		state->screen_dis = 0;
 
 		visarea.min_x = min_x;
 		visarea.max_x = min_x + max_x - 1;
@@ -943,24 +936,28 @@
 
 static READ32_HANDLER( tcram_r )
 {
-//  printf("Q1 R : %.8x %.8x\n", offset, hng64_tcram[offset]);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	//printf("Q1 R : %.8x %.8x\n", offset, hng64_tcram[offset]);
 	if(offset == 0x12)
 		return input_port_read(space->machine, "VBLANK");
 
-	return hng64_tcram[offset];
+	return state->tcram[offset];
 }
 
 /* Some games (namely sams64 after the title screen) tests bit 15 of this to be high,
    unknown purpose (vblank? related to the display list?). */
 static READ32_HANDLER( unk_vreg_r )
 {
-	static UINT32 toggle;
-	return ++toggle;
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	return ++state->unk_vreg_toggle;
 }
 
 
 static WRITE32_HANDLER( hng64_soundram_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
 	UINT32 mem_mask32 = mem_mask;
 	UINT32 data32 = data;
 
@@ -969,19 +966,20 @@
 	data = FLIPENDIAN_INT16(data);
 	mem_mask = mem_mask32 >> 16;
 	mem_mask = FLIPENDIAN_INT16(mem_mask);
-	COMBINE_DATA(&hng64_soundram[offset * 2 + 0]);
+	COMBINE_DATA(&state->soundram[offset * 2 + 0]);
 
 	data = data32 & 0xffff;
 	data = FLIPENDIAN_INT16(data);
 	mem_mask = mem_mask32 & 0xffff;
 	mem_mask = FLIPENDIAN_INT16(mem_mask);
-	COMBINE_DATA(&hng64_soundram[offset * 2 + 1]);
+	COMBINE_DATA(&state->soundram[offset * 2 + 1]);
 }
 
 static READ32_HANDLER( hng64_soundram_r )
 {
-	UINT16 datalo = hng64_soundram[offset * 2 + 0];
-	UINT16 datahi = hng64_soundram[offset * 2 + 1];
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+	UINT16 datalo = state->soundram[offset * 2 + 0];
+	UINT16 datahi = state->soundram[offset * 2 + 1];
 
 	return FLIPENDIAN_INT16(datahi) | (FLIPENDIAN_INT16(datalo) << 16);
 }
@@ -989,45 +987,45 @@
 /* The following is guesswork, needs confirmation with a test on the real board. */
 static WRITE32_HANDLER( hng64_sprite_clear_even_w )
 {
-	static UINT32 spr_offs;
+	UINT32 spr_offs;
 
 	spr_offs = (offset) * 0x10 * 4;
 
 	if(ACCESSING_BITS_16_31)
 	{
-		memory_write_dword(space, 0x20000000+0x00+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x08+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x10+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x18+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x00+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x08+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x10+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x18+0x00+spr_offs, 0x00000000);
 	}
 	if(ACCESSING_BITS_8_15)
 	{
-		memory_write_dword(space, 0x20000000+0x00+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x08+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x10+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x18+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x00+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x08+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x10+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x18+0x20+spr_offs, 0x00000000);
 	}
 }
 
 static WRITE32_HANDLER( hng64_sprite_clear_odd_w )
 {
-	static UINT32 spr_offs;
+	UINT32 spr_offs;
 
 	spr_offs = (offset) * 0x10 * 4;
 
 	if(ACCESSING_BITS_16_31)
 	{
-		memory_write_dword(space, 0x20000000+0x04+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x0c+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x14+0x00+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x1c+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x04+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x0c+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x14+0x00+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x1c+0x00+spr_offs, 0x00000000);
 	}
 	if(ACCESSING_BITS_0_15)
 	{
-		memory_write_dword(space, 0x20000000+0x04+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x0c+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x14+0x20+spr_offs, 0x00000000);
-		memory_write_dword(space, 0x20000000+0x1c+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x04+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x0c+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x14+0x20+spr_offs, 0x00000000);
+		space->write_dword(0x20000000+0x1c+0x20+spr_offs, 0x00000000);
 	}
 }
 
@@ -1044,39 +1042,39 @@
 */
 static ADDRESS_MAP_START( hng_map, ADDRESS_SPACE_PROGRAM, 32 )
 
-	AM_RANGE(0x00000000, 0x00ffffff) AM_RAM AM_BASE(&hng_mainram)
-	AM_RANGE(0x04000000, 0x05ffffff) AM_WRITENOP AM_ROM AM_REGION("user3",0) AM_BASE(&hng_cart)
+	AM_RANGE(0x00000000, 0x00ffffff) AM_RAM AM_BASE_MEMBER(hng64_state, mainram)
+	AM_RANGE(0x04000000, 0x05ffffff) AM_WRITENOP AM_ROM AM_REGION("user3", 0) AM_BASE_MEMBER(hng64_state, cart)
 
 	// Ports
-	AM_RANGE(0x1f700000, 0x1f702fff) AM_READWRITE(hng64_sysregs_r,hng64_sysregs_w) AM_BASE(&hng64_sysregs)
+	AM_RANGE(0x1f700000, 0x1f702fff) AM_READWRITE(hng64_sysregs_r, hng64_sysregs_w) AM_BASE_MEMBER(hng64_state, sysregs)
 
 	// SRAM.  Coin data, Player Statistics, etc.
 	AM_RANGE(0x1F800000, 0x1F803fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
 
 	// Dualport RAM
-	AM_RANGE(0x1F808000, 0x1F8087ff) AM_READWRITE(hng64_dualport_r, hng64_dualport_w) AM_BASE(&hng64_dualport)
+	AM_RANGE(0x1F808000, 0x1F8087ff) AM_READWRITE(hng64_dualport_r, hng64_dualport_w) AM_BASE_MEMBER(hng64_state, dualport)
 
 	// BIOS
-	AM_RANGE(0x1fc00000, 0x1fc7ffff) AM_WRITENOP AM_ROM AM_REGION("user1", 0) AM_BASE(&rombase)
+	AM_RANGE(0x1fc00000, 0x1fc7ffff) AM_WRITENOP AM_ROM AM_REGION("user1", 0) AM_BASE_MEMBER(hng64_state, rombase)
 
 	// Video
-	AM_RANGE(0x20000000, 0x2000bfff) AM_RAM AM_BASE(&hng64_spriteram)
+	AM_RANGE(0x20000000, 0x2000bfff) AM_RAM AM_BASE_MEMBER(hng64_state, spriteram)
 	AM_RANGE(0x2000d800, 0x2000e3ff) AM_WRITE(hng64_sprite_clear_even_w)
 	AM_RANGE(0x2000e400, 0x2000efff) AM_WRITE(hng64_sprite_clear_odd_w)
-	AM_RANGE(0x20010000, 0x20010013) AM_RAM AM_BASE(&hng64_spriteregs)
-	AM_RANGE(0x20100000, 0x2017ffff) AM_RAM_WRITE(hng64_videoram_w) AM_BASE(&hng64_videoram)	// Tilemap
-	AM_RANGE(0x20190000, 0x20190037) AM_RAM AM_BASE(&hng64_videoregs)
+	AM_RANGE(0x20010000, 0x20010013) AM_RAM AM_BASE_MEMBER(hng64_state, spriteregs)
+	AM_RANGE(0x20100000, 0x2017ffff) AM_RAM_WRITE(hng64_videoram_w) AM_BASE_MEMBER(hng64_state, videoram)	// Tilemap
+	AM_RANGE(0x20190000, 0x20190037) AM_RAM AM_BASE_MEMBER(hng64_state, videoregs)
 	AM_RANGE(0x20200000, 0x20203fff) AM_RAM_WRITE(hng64_pal_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x20208000, 0x2020805f) AM_READWRITE(tcram_r, tcram_w) AM_BASE(&hng64_tcram)	// Transition Control
-	AM_RANGE(0x20300000, 0x203001ff) AM_RAM_WRITE(dl_w) AM_BASE(&hng64_dl)	// 3d Display List
-//  AM_RANGE(0x20300200, 0x20300213) AM_RAM_WRITE(xxxx) AM_BASE(&xxxxxxxx)  // 3d Display List Upload?
+	AM_RANGE(0x20208000, 0x2020805f) AM_READWRITE(tcram_r, tcram_w) AM_BASE_MEMBER(hng64_state, tcram)	// Transition Control
+	AM_RANGE(0x20300000, 0x203001ff) AM_RAM_WRITE(dl_w) AM_BASE_MEMBER(hng64_state, dl)	// 3d Display List
+//  AM_RANGE(0x20300200, 0x20300213) AM_RAM_WRITE(xxxx) AM_BASE_MEMBER(hng64_state, xxxxxxxx)  // 3d Display List Upload?
 	AM_RANGE(0x20300214, 0x20300217) AM_WRITE(dl_control_w)
 	AM_RANGE(0x20300218, 0x2030021b) AM_READ(unk_vreg_r)
 
 	// 3d?
-	AM_RANGE(0x30000000, 0x3000002f) AM_RAM AM_BASE(&hng64_3dregs)
-	AM_RANGE(0x30100000, 0x3015ffff) AM_READWRITE(hng64_3d_1_r,hng64_3d_2_w) AM_BASE(&hng64_3d_1)	// 3D Display Buffer A
-	AM_RANGE(0x30200000, 0x3025ffff) AM_READWRITE(hng64_3d_2_r,hng64_3d_2_w) AM_BASE(&hng64_3d_2)	// 3D Display Buffer B
+	AM_RANGE(0x30000000, 0x3000002f) AM_RAM AM_BASE_MEMBER(hng64_state, _3dregs)
+	AM_RANGE(0x30100000, 0x3015ffff) AM_READWRITE(hng64_3d_1_r, hng64_3d_2_w) AM_BASE_MEMBER(hng64_state, _3d_1)	// 3D Display Buffer A
+	AM_RANGE(0x30200000, 0x3025ffff) AM_READWRITE(hng64_3d_2_r, hng64_3d_2_w) AM_BASE_MEMBER(hng64_state, _3d_2)	// 3D Display Buffer B
 
 	// Sound
 	AM_RANGE(0x60000000, 0x601fffff) AM_RAM												// Sound ??
@@ -1089,7 +1087,7 @@
 //  AM_RANGE(0x6f000000, 0x6f000003) AM_WRITENOP    // halt / reset line for the sound CPU
 
 	// Communications
-	AM_RANGE(0xc0000000, 0xc0000fff) AM_READWRITE(hng64_com_r, hng64_com_w) AM_BASE(&hng64_com_ram)
+	AM_RANGE(0xc0000000, 0xc0000fff) AM_READWRITE(hng64_com_r, hng64_com_w) AM_BASE_MEMBER(hng64_state, com_ram)
 	AM_RANGE(0xc0001000, 0xc0001007) AM_READWRITE(hng64_com_share_r, hng64_com_share_w)
 
 	/* 6e000000-6fffffff */
@@ -1103,16 +1101,18 @@
 /**************/
 /** COMM CPU **/
 /**************/
-#define KL5C_MMU_A(xxx) ( (xxx==0) ? 0x0000 : (hng64_com_mmu_mem[((xxx-1)*2)+1] << 2) | ((hng64_com_mmu_mem[(xxx-1)*2] & 0xc0) >> 6) )
-#define KL5C_MMU_B(xxx) ( (xxx==0) ? 0x0000 : (hng64_com_mmu_mem[(xxx-1)*2] & 0x3f) )
+#define KL5C_MMU_A(xxx) ( (xxx == 0) ? 0x0000 : (state->com_mmu_mem[((xxx-1)*2)+1] << 2) | ((state->com_mmu_mem[(xxx-1)*2] & 0xc0) >> 6) )
+#define KL5C_MMU_B(xxx) ( (xxx == 0) ? 0x0000 : (state->com_mmu_mem[(xxx-1)*2] & 0x3f) )
 
-static DIRECT_UPDATE_HANDLER( KL5C80_direct_handler )
+DIRECT_UPDATE_HANDLER( KL5C80_direct_handler )
 {
-	direct->raw = direct->decrypted = hng64_com_op_base;
+	hng64_state *state = machine->driver_data<hng64_state>();
+
+	direct.explicit_configure(0x0000, 0xffff, 0xffff, state->com_op_base);
 	return ~0;
 }
 
-static UINT32 KL5C80_translate_address(UINT16 vAddr)
+static UINT32 KL5C80_translate_address(hng64_state *state, UINT16 vAddr)
 {
 	int i;
 	UINT8 bNum = 4;
@@ -1138,7 +1138,7 @@
 	}
 }
 
-static void KL5C80_virtual_mem_sync(void)
+static void KL5C80_virtual_mem_sync(hng64_state *state)
 {
 	/* The KL5C80 maps each progressive chunk from the beginning of the
        virtual region until the beginning of the next virtual region.
@@ -1162,13 +1162,15 @@
 		for (i = logical_offset; i <= 0xffff; i++)
 		{
 			if (physical_offset+i <= 0xfffff)
-				hng64_com_op_base[i] = hng64_com_virtual_mem[physical_offset+i];
+				state->com_op_base[i] = state->com_virtual_mem[physical_offset+i];
 		}
 	}
 }
 
-static void KL5C80_init(void)
+static void KL5C80_init(hng64_state *state)
 {
+	UINT8 *hng64_com_mmu_mem = state->com_mmu_mem;
+
 	/* init the MMU */
 	hng64_com_mmu_mem[0] =
 	hng64_com_mmu_mem[2] =
@@ -1183,8 +1185,9 @@
 
 static READ8_HANDLER( hng64_comm_memory_r )
 {
-	UINT32 physical_address = KL5C80_translate_address(offset);
-	logerror("READING 0x%02x from 0x%04x (0x%05x)\n", hng64_com_virtual_mem[physical_address], offset, physical_address);
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+	UINT32 physical_address = KL5C80_translate_address(state, offset);
+	logerror("READING 0x%02x from 0x%04x (0x%05x)\n", state->com_virtual_mem[physical_address], offset, physical_address);
 
 	/* Custom "virtual" memory map */
 	if (physical_address >= 0x26000 && physical_address <= 0x28000)
@@ -1193,7 +1196,7 @@
 	}
 
 
-	return hng64_com_virtual_mem[physical_address];
+	return state->com_virtual_mem[physical_address];
 }
 
 static WRITE8_HANDLER( hng64_comm_memory_w )
@@ -1206,16 +1209,18 @@
 /* KL5C80 I/O handlers */
 static WRITE8_HANDLER( hng64_comm_io_mmu )
 {
-	hng64_com_mmu_mem[offset] = data;
+	hng64_state *state = space->machine->driver_data<hng64_state>();
+
+	state->com_mmu_mem[offset] = data;
 
 	/* Debugging - you can't change A4 - the hardware doesn't let you */
-	if (hng64_com_mmu_mem[7] != 0xf0 || ((hng64_com_mmu_mem[6] & 0xc0) != 0x00))
+	if (state->com_mmu_mem[7] != 0xf0 || ((state->com_mmu_mem[6] & 0xc0) != 0x00))
 		logerror("KL5C MMU error !!! Code is trying to change A4!\n");
 
 	logerror("COMM CPU MMU WRITE : ");
 	logerror("B : %02x %02x %02x %02x  A : %03x %03x %03x %03x\n", KL5C_MMU_B(1), KL5C_MMU_B(2), KL5C_MMU_B(3), KL5C_MMU_B(4),
 																   KL5C_MMU_A(1), KL5C_MMU_A(2), KL5C_MMU_A(3), KL5C_MMU_A(4));
-	KL5C80_virtual_mem_sync();
+	KL5C80_virtual_mem_sync(state);
 }
 
 #ifdef UNUSED_FUNCTION
@@ -1254,7 +1259,7 @@
 static ADDRESS_MAP_START( hng_comm_io_map, ADDRESS_SPACE_IO, 8 )
 	ADDRESS_MAP_GLOBAL_MASK(0xff)
 	/* Reserved for the KL5C80 internal hardware */
-	AM_RANGE(0x00,0x07) AM_WRITE( hng64_comm_io_mmu ) AM_BASE(&hng64_com_mmu_mem)
+	AM_RANGE(0x00, 0x07) AM_WRITE( hng64_comm_io_mmu ) AM_BASE_MEMBER(hng64_state, com_mmu_mem)
 //  AM_RANGE(0x08,0x1f) AM_NOP              /* Reserved */
 //  AM_RANGE(0x20,0x25) AM_READWRITE        /* Timer/Counter B */           /* hng64 writes here */
 //  AM_RANGE(0x27,0x27) AM_NOP              /* Reserved */
@@ -1555,6 +1560,8 @@
 
 static DRIVER_INIT( hng64 )
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+
 	// region hacking, english error messages are more useful to us, but no english bios is dumped...
 #ifdef HACK_REGION
 // versions according to fatal fury test mode
@@ -1566,49 +1573,59 @@
 #endif
 
 	/* 1 meg of virtual address space for the com cpu */
-	hng64_com_virtual_mem = auto_alloc_array(machine, UINT8, 0x100000);
-	hng64_com_op_base     = auto_alloc_array(machine, UINT8, 0x10000);
+	state->com_virtual_mem = auto_alloc_array(machine, UINT8, 0x100000);
+	state->com_op_base     = auto_alloc_array(machine, UINT8, 0x10000);
 
-	hng64_soundram=auto_alloc_array(machine, UINT16, 0x200000/2);
+	state->soundram = auto_alloc_array(machine, UINT16, 0x200000/2);
 	DRIVER_INIT_CALL(hng64_reorder_gfx);
 }
 
 static DRIVER_INIT(hng64_fght)
 {
-	no_machine_error_code=0x01000000;
+	hng64_state *state = machine->driver_data<hng64_state>();
+
+	state->no_machine_error_code = 0x01000000;
 	DRIVER_INIT_CALL(hng64);
 }
 
 static DRIVER_INIT( fatfurwa )
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+
 	/* FILE* fp = fopen("/tmp/test.bin", "wb"); fwrite(memory_region(machine, "verts"), 1, 0x0c00000*2, fp); fclose(fp); */
 	DRIVER_INIT_CALL(hng64_fght);
-	hng64_mcu_type = FIGHT_MCU;
+	state->mcu_type = FIGHT_MCU;
 }
 
 static DRIVER_INIT( ss64 )
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+
 	DRIVER_INIT_CALL(hng64_fght);
-	hng64_mcu_type = SAMSHO_MCU;
+	state->mcu_type = SAMSHO_MCU;
 }
 
 static DRIVER_INIT(hng64_race)
 {
-	no_machine_error_code=0x02000000;
-	hng64_mcu_type = RACING_MCU;
+	hng64_state *state = machine->driver_data<hng64_state>();
+
+	state->no_machine_error_code = 0x02000000;
+	state->mcu_type = RACING_MCU;
 	DRIVER_INIT_CALL(hng64);
 }
 
 static DRIVER_INIT(hng64_shoot)
 {
-	hng64_mcu_type = SHOOT_MCU;
-	no_machine_error_code=0x03000000;
+	hng64_state *state = machine->driver_data<hng64_state>();
+
+	state->mcu_type = SHOOT_MCU;
+	state->no_machine_error_code = 0x03000000;
 	DRIVER_INIT_CALL(hng64);
 }
 
 
 /* ?? */
-static const mips3_config config =
+static const mips3_config vr4300_config =
 {
 	16384,				/* code cache size */
 	16384				/* data cache size */
@@ -1621,20 +1638,22 @@
 
 static INTERRUPT_GEN( irq_start )
 {
+	hng64_state *state = device->machine->driver_data<hng64_state>();
+
 	logerror("HNG64 interrupt level %x\n", cpu_getiloops(device));
 
 	/* there are more, the sources are unknown at the moment */
 	switch (cpu_getiloops(device))
 	{
-		case 0x00: hng64_interrupt_level_request = 0;
+		case 0x00: state->interrupt_level_request = 0;
 		break;
-		case 0x01: hng64_interrupt_level_request = 1;
+		case 0x01: state->interrupt_level_request = 1;
 		break;
-		case 0x02: hng64_interrupt_level_request = 2;
+		case 0x02: state->interrupt_level_request = 2;
 		break;
 		case 0x03:
-		if(hng64_mcu_type == RACING_MCU)
-			hng64_interrupt_level_request = 11; //network irq
+		if (state->mcu_type == RACING_MCU)
+			state->interrupt_level_request = 11; //network irq
 		else
 			return;
 		break;
@@ -1647,53 +1666,61 @@
 
 static MACHINE_START(hyperneo)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+
 	/* set the fastest DRC options */
 	mips3drc_set_options(machine->device("maincpu"), MIPS3DRC_FASTEST_OPTIONS + MIPS3DRC_STRICT_VERIFY);
 
 	/* configure fast RAM regions for DRC */
-	mips3drc_add_fastram(machine->device("maincpu"), 0x00000000, 0x00ffffff, FALSE, hng_mainram);
-	mips3drc_add_fastram(machine->device("maincpu"), 0x04000000, 0x05ffffff, TRUE,  hng_cart);
-	mips3drc_add_fastram(machine->device("maincpu"), 0x1fc00000, 0x1fc7ffff, TRUE,  rombase);
+	mips3drc_add_fastram(machine->device("maincpu"), 0x00000000, 0x00ffffff, FALSE, state->mainram);
+	mips3drc_add_fastram(machine->device("maincpu"), 0x04000000, 0x05ffffff, TRUE,  state->cart);
+	mips3drc_add_fastram(machine->device("maincpu"), 0x1fc00000, 0x1fc7ffff, TRUE,  state->rombase);
 }
 
 
 static MACHINE_RESET(hyperneo)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
 	int i;
 	const UINT8 *rom = memory_region(machine, "user2");
 
 	/* Sound CPU */
-	UINT8 *RAM = (UINT8*)hng64_soundram;
+	UINT8 *RAM = (UINT8*)state->soundram;
 	memory_set_bankptr(machine, "bank1",&RAM[0x1e0000]);
 	memory_set_bankptr(machine, "bank2",&RAM[0x001000]); // where..
 	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_HALT, ASSERT_LINE);
 	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_RESET, ASSERT_LINE);
 
 	/* Comm CPU */
-	KL5C80_init();
+	KL5C80_init(state);
 
 	/* Fill up virtual memory with ROM */
 	for (i = 0x0; i < 0x100000; i++)
-		hng64_com_virtual_mem[i] = rom[i];
+		state->com_virtual_mem[i] = rom[i];
+
+	KL5C80_virtual_mem_sync(state);
 
-	KL5C80_virtual_mem_sync();
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "comm", ADDRESS_SPACE_PROGRAM), KL5C80_direct_handler);
+	address_space *space = machine->device<z80_device>("comm")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(KL5C80_direct_handler, *machine));
 
 	cputag_set_input_line(machine, "comm", INPUT_LINE_RESET, PULSE_LINE);     // reset the CPU and let 'er rip
 //  cputag_set_input_line(machine, "comm", INPUT_LINE_HALT, ASSERT_LINE);     // hold on there pardner...
 
 	// "Display List" init - ugly
-	activeBuffer = 0;
+	state->activeBuffer = 0;
 
 	/* For simulate MCU stepping */
-	fake_mcu_time = 0;
-	hng_mcu_en = 0;
+	state->mcu_fake_time = 0;
+	state->mcu_en = 0;
 }
 
 static MACHINE_DRIVER_START( hng64 )
+
+	MDRV_DRIVER_DATA( hng64_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", VR4300BE, MASTER_CLOCK) 	// actually R4300
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(vr4300_config)
 	MDRV_CPU_PROGRAM_MAP(hng_map)
 	MDRV_CPU_VBLANK_INT_HACK(irq_start,4)
 
diff -Nru src-old/mame/drivers/homedata.c src/mame/drivers/homedata.c
--- src-old/mame/drivers/homedata.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/homedata.c	2010-08-19 00:26:14.000000000 -0700
@@ -1222,7 +1222,7 @@
 static MACHINE_RESET( pteacher )
 {
 	homedata_state *state = machine->driver_data<homedata_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* on reset, ports are set as input (high impedance), therefore 0xff output */
 	pteacher_upd7807_portc_w(space, 0, 0xff);
@@ -1239,7 +1239,7 @@
 static MACHINE_RESET( reikaids )
 {
 	homedata_state *state = machine->driver_data<homedata_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* on reset, ports are set as input (high impedance), therefore 0xff output */
 	reikaids_upd7807_portc_w(space, 0, 0xff);
diff -Nru src-old/mame/drivers/hotstuff.c src/mame/drivers/hotstuff.c
--- src-old/mame/drivers/hotstuff.c	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/drivers/hotstuff.c	2010-08-16 05:15:54.000000000 -0700
@@ -0,0 +1,96 @@
+/* TAS 5 REEL system? by Olympic Video Gaming */
+
+#include "emu.h"
+#include "cpu/m68000/m68000.h"
+
+static UINT16* hotstuff_bitmapram;
+
+VIDEO_START( hotstuff )
+{
+
+}
+
+/* the first 0x20 bytes in every 0x200 (each line) of video ram are the colour data, providing a palette of 16 RGB444 colours for that line */
+
+VIDEO_UPDATE( hotstuff )
+{
+	int count, y,yyy,x,xxx;
+	UINT16 row_palette_data[0x10];
+	rgb_t row_palette_data_as_rgb32_pen_data[0x10];
+
+	yyy=512;xxx=512*2;
+
+	count = 0;
+	for (y = 0; y < yyy; y++)
+	{
+		// the current palette is stored in the first 0x20 bytes of each row!
+		int p;
+
+		for (p=0;p<0x10;p++)
+		{
+			row_palette_data[p] = hotstuff_bitmapram[count+p];
+
+			row_palette_data_as_rgb32_pen_data[p] = MAKE_RGB( (row_palette_data[p] & 0x0f00)>>4, (row_palette_data[p] & 0x00f0)>>0, (row_palette_data[p] & 0x000f)<<4  );
+
+		}
+
+		for(x = 0; x < xxx; x++)
+		{
+			{
+				*BITMAP_ADDR32(bitmap, y, x) = row_palette_data_as_rgb32_pen_data[(hotstuff_bitmapram[count] &0xf000)>>12];
+				x++;
+				*BITMAP_ADDR32(bitmap, y, x) = row_palette_data_as_rgb32_pen_data[(hotstuff_bitmapram[count] &0x0f00)>>8];
+				x++;
+				*BITMAP_ADDR32(bitmap, y, x) = row_palette_data_as_rgb32_pen_data[(hotstuff_bitmapram[count] &0x00f0)>>4];
+				x++;
+				*BITMAP_ADDR32(bitmap, y, x) = row_palette_data_as_rgb32_pen_data[(hotstuff_bitmapram[count] &0x000f)>>0];
+			}
+
+			count++;
+		}
+	}
+
+	return 0;
+}
+
+static ADDRESS_MAP_START( hotstuff_map, ADDRESS_SPACE_PROGRAM, 16 )
+	AM_RANGE(0x000000, 0x07ffff) AM_ROM
+
+	AM_RANGE(0x400000, 0x40ffff) AM_RAM
+
+	AM_RANGE(0x980000, 0x9bffff) AM_RAM AM_BASE(&hotstuff_bitmapram)
+ADDRESS_MAP_END
+
+static INPUT_PORTS_START( hotstuff )
+INPUT_PORTS_END
+
+static MACHINE_DRIVER_START( hotstuff )
+
+	MDRV_CPU_ADD("maincpu", M68000, 16000000)
+	MDRV_CPU_PROGRAM_MAP(hotstuff_map)
+	MDRV_CPU_VBLANK_INT("screen", irq1_line_hold)
+
+	MDRV_SCREEN_ADD("screen", RASTER)
+	MDRV_SCREEN_REFRESH_RATE(60)
+	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
+	MDRV_SCREEN_SIZE(128*8, 64*8)
+	MDRV_SCREEN_VISIBLE_AREA((0x10*4)+8, 101*8-1, 0*8, 33*8-1)
+
+	MDRV_PALETTE_LENGTH(0x200)
+
+	MDRV_VIDEO_START(hotstuff)
+	MDRV_VIDEO_UPDATE(hotstuff)
+MACHINE_DRIVER_END
+
+
+
+ROM_START( hotstuff )
+	ROM_REGION( 0x80000, "maincpu", 0 ) /* 68000 Code */
+	ROM_LOAD16_WORD_SWAP( "hot stuff game u6 (68000).bin", 0x00000, 0x80000, CRC(65f6a72f) SHA1(3a6d489ec3bf351018e279605d42f10b0a2c61b1) )
+
+	ROM_REGION( 0x80000, "data", 0 ) /* 68000 Data? */
+	ROM_LOAD16_WORD_SWAP( "hot stuff symbol u8 (68000).bin", 0x00000, 0x80000, CRC(f154a157) SHA1(92ae0fb977e2dcc0377487d768f95c6e447e990b) )
+ROM_END
+
+GAME( ????, hotstuff,    0,        hotstuff,    hotstuff,    0, ROT0,  "Olympic Video Gaming", "Olympic Hot Stuff (TAS 5 Reel System)", GAME_NOT_WORKING | GAME_NO_SOUND )
diff -Nru src-old/mame/drivers/hshavoc.c src/mame/drivers/hshavoc.c
--- src-old/mame/drivers/hshavoc.c	2010-01-31 11:07:57.000000000 -0800
+++ src/mame/drivers/hshavoc.c	2010-08-19 00:26:14.000000000 -0700
@@ -218,7 +218,7 @@
 */
 
 	{
-		const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 		memory_nop_write(space, 0x200000, 0x201fff, 0, 0);
 	}
 
diff -Nru src-old/mame/drivers/hyprduel.c src/mame/drivers/hyprduel.c
--- src-old/mame/drivers/hyprduel.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/hyprduel.c	2010-08-19 00:26:14.000000000 -0700
@@ -277,7 +277,7 @@
 	return ROM[offs];
 }
 
-INLINE void blt_write( const address_space *space, const int tmap, const offs_t offs, const UINT16 data, const UINT16 mask )
+INLINE void blt_write( address_space *space, const int tmap, const offs_t offs, const UINT16 data, const UINT16 mask )
 {
 	switch( tmap )
 	{
diff -Nru src-old/mame/drivers/igs011.c src/mame/drivers/igs011.c
--- src-old/mame/drivers/igs011.c	2010-06-27 09:04:13.000000000 -0700
+++ src/mame/drivers/igs011.c	2010-08-19 00:26:14.000000000 -0700
@@ -881,7 +881,7 @@
 
 //  igs011_prot2 = 0x00;
 
-	const address_space *sp = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *sp = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(space->machine, "maincpu");
 
 	// Plug previous address range with ROM access
diff -Nru src-old/mame/drivers/itech32.c src/mame/drivers/itech32.c
--- src-old/mame/drivers/itech32.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/itech32.c	2010-08-19 00:26:14.000000000 -0700
@@ -726,7 +726,7 @@
 
 static WRITE8_DEVICE_HANDLER( drivedge_portb_out )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 //  logerror("PIA port B write = %02x\n", data);
 
 	/* bit 0 controls the fan light */
@@ -751,7 +751,7 @@
 
 static WRITE8_DEVICE_HANDLER( pia_portb_out )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 //  logerror("PIA port B write = %02x\n", data);
 
 	/* bit 4 controls the ticket dispenser */
diff -Nru src-old/mame/drivers/itech8.c src/mame/drivers/itech8.c
--- src-old/mame/drivers/itech8.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/itech8.c	2010-08-15 17:41:11.000000000 -0700
@@ -680,9 +680,6 @@
 		machine->device("maincpu")->reset();
 	}
 
-	/* reset the palette chip */
-	tlc34076_reset(6);
-
 	/* set the visible area */
 	if (visarea)
 	{
@@ -1730,6 +1727,8 @@
 	MDRV_TICKET_DISPENSER_ADD("ticket", 200, TICKET_MOTOR_ACTIVE_HIGH, TICKET_STATUS_ACTIVE_LOW)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
 	MDRV_VIDEO_START(itech8)
 
diff -Nru src-old/mame/drivers/itgamble.c src/mame/drivers/itgamble.c
--- src-old/mame/drivers/itgamble.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/itgamble.c	2010-08-26 08:21:19.000000000 -0700
@@ -217,6 +217,7 @@
 MACHINE_DRIVER_END
 
 
+#ifdef UNUSED_CODE
 static MACHINE_DRIVER_START( ejollyx5 )
 
 	MDRV_IMPORT_FROM(itgamble)
@@ -227,6 +228,7 @@
 	MDRV_OKIM6295_REPLACE("oki", MNUMBER_SND_CLOCK/16, OKIM6295_PIN7_HIGH) /* clock frequency & pin 7 not verified */
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_DRIVER_END
+#endif
 
 
 /*************************
diff -Nru src-old/mame/drivers/jack.c src/mame/drivers/jack.c
--- src-old/mame/drivers/jack.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/jack.c	2010-08-19 07:19:38.000000000 -0700
@@ -1312,12 +1312,12 @@
 static void treahunt_decode( running_machine *machine )
 {
 	int A;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x4000);
 	int data;
 
-	memory_set_decrypted_region(space, 0x0000, 0x3fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x3fff, decrypt);
 
 	/* Thanks to Mike Balfour for helping out with the decryption */
 	for (A = 0; A < 0x4000; A++)
diff -Nru src-old/mame/drivers/jalmah.c src/mame/drivers/jalmah.c
--- src-old/mame/drivers/jalmah.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/jalmah.c	2010-08-19 01:27:05.000000000 -0700
@@ -627,14 +627,14 @@
 	{
 		UINT32 i;
 		for(i = 0; i < 0x200; i += 2)
-			memory_write_word(space, 0x88200 + i, memory_read_word(space, 0x88400 + i));
+			space->write_word(0x88200 + i, space->read_word(0x88400 + i));
 	}
 }
 
 /*same as $f00c0 sub-routine,but with additional work-around,to remove from here...*/
 static void daireika_palette_dma(running_machine *machine, UINT16 val)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT32 index_1, index_2, src_addr, tmp_addr;
 	/*a0=301c0+jm_shared_ram[0x540/2] & 0xf00 */
 	/*a1=88000*/
@@ -643,10 +643,10 @@
 	for(index_1 = 0; index_1 < 0x200; index_1 += 0x20)
 	{
 		tmp_addr = src_addr;
-		src_addr = memory_read_dword(space,src_addr);
+		src_addr = space->read_dword(src_addr);
 
 		for(index_2 = 0; index_2 < 0x20; index_2 += 2)
-			memory_write_word(space, 0x88000 + index_2 + index_1, memory_read_word(space, src_addr + index_2));
+			space->write_word(0x88000 + index_2 + index_1, space->read_word(src_addr + index_2));
 
 		src_addr = tmp_addr + 4;
 	}
diff -Nru src-old/mame/drivers/jangou.c src/mame/drivers/jangou.c
--- src-old/mame/drivers/jangou.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/jangou.c	2010-08-25 01:57:16.000000000 -0700
@@ -477,6 +477,31 @@
 
 /*************************************
  *
+ *  Royal Card Memory Map
+ *
+ *************************************/
+
+static ADDRESS_MAP_START( roylcrdn_cpu0_map, ADDRESS_SPACE_PROGRAM, 8 )
+	AM_RANGE(0x0000, 0x2fff) AM_ROM
+	AM_RANGE(0x7000, 0x77ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)	/* MK48Z02B-15 ZEROPOWER RAM */
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START( roylcrdn_cpu0_io, ADDRESS_SPACE_IO, 8 )
+	ADDRESS_MAP_GLOBAL_MASK(0xff)
+	AM_RANGE(0x01,0x01) AM_DEVREAD("aysnd", ay8910_r)
+	AM_RANGE(0x02,0x03) AM_DEVWRITE("aysnd", ay8910_data_address_w)
+	AM_RANGE(0x10,0x10) AM_READ_PORT("DSW")			/* DSW + blitter busy flag */
+	AM_RANGE(0x10,0x10) AM_WRITENOP					/* Writes continuosly 0's in attract mode, and 1's in game */
+	AM_RANGE(0x11,0x11) AM_WRITE(mux_w)
+	AM_RANGE(0x13,0x13) AM_READNOP					/* Often reads bit7 with unknown purposes */
+	AM_RANGE(0x12,0x17) AM_WRITE(blitter_process_w)
+	AM_RANGE(0x20,0x2f) AM_WRITE(blit_vregs_w)
+	AM_RANGE(0x30,0x30) AM_WRITENOP					/* Seems to write 0x10 on each sound event */
+ADDRESS_MAP_END
+
+
+/*************************************
+ *
  *  Input Port Definitions
  *
  *************************************/
@@ -759,6 +784,90 @@
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN ) //blitter busy flag
 INPUT_PORTS_END
 
+static INPUT_PORTS_START( roylcrdn )
+	PORT_START("PL1_1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_Z) PORT_NAME("1P Bet1")				/* 1P Bet1 */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_X) PORT_NAME("1P Bet2")				/* 1P Bet2 */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_C) PORT_NAME("1P Bet3")				/* 1P Bet3 */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_V) PORT_NAME("1P Bet4")				/* 1P Bet4 */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_B) PORT_NAME("1P Bet5")				/* 1P Bet5 */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_LCONTROL) PORT_NAME("1P Flip-Flop")	/* 1P Flip-Flop */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_1) PORT_NAME("1P Start")				/* 1P Start */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("PL1_2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_4) PORT_NAME("1P Take Score")			/* 1P Take Score */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_3) PORT_NAME("1P Hi-Lo (W-Up)")		/* 1P W-Up */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_A) PORT_NAME("1P Hi (Big)")			/* 1P Big */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_S) PORT_NAME("1P Lo (Small)")			/* 1P Small */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_F) PORT_NAME("1P Stand")				/* 1P Stand */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_D) PORT_NAME("1P Hit")					/* 1P Hit */
+	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("PL2_1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_1_PAD) PORT_NAME("2P Bet1")			/* 2P Bet1 */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_2_PAD) PORT_NAME("2P Bet2")			/* 2P Bet2 */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_3_PAD) PORT_NAME("2P Bet3")			/* 2P Bet3 */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_4_PAD) PORT_NAME("2P Bet4")			/* 2P Bet4 */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_5_PAD) PORT_NAME("2P Bet5")			/* 2P Bet5 */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_RCONTROL) PORT_NAME("2P Flip-Flop")	/* 2P Flip-Flop */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_0_PAD) PORT_NAME("2P Start")			/* 2P Start */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("PL2_2")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_LEFT)  PORT_NAME("2P Take Score")		/* 2P Take Score */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_RIGHT) PORT_NAME("2P Hi-Lo (W-Up)")	/* 2P W-Up */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_UP)    PORT_NAME("2P Hi (Big)")		/* 2P Big */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_DOWN)  PORT_NAME("2P Lo (Small)")		/* 2P Small */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_8_PAD) PORT_NAME("2P Stand")			/* 2P Stand */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_OTHER ) PORT_CODE(KEYCODE_7_PAD) PORT_NAME("2P Hit")				/* 2P Hit */
+	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("PL1_3")
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("PL2_3")
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNUSED )																	/* Spare 2 */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )										PORT_NAME("Note In")		/* Note In */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_TOGGLE  PORT_CODE(KEYCODE_9)	PORT_NAME("Memory Reset")	/* Memory Reset */
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_TOGGLE  PORT_CODE(KEYCODE_0)	PORT_NAME("Analyzer")		/* Analyzer */
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_SERVICE ) PORT_TOGGLE  PORT_CODE(KEYCODE_F2) PORT_NAME("Test Mode")		/* Test Mode */
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )										PORT_NAME("Coin In")		/* Coin In */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_GAMBLE_KEYOUT )								PORT_NAME("Credit Clear")	/* Credit Clear */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNUSED )																	/* Spare 1 */
+
+	PORT_START("DSW")	/* Not a real DSW on PCB */
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x02, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x08, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unknown ) )
+	PORT_DIPSETTING(    0x40, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* blitter busy flag */
+
+	PORT_START("IN_NOMUX")
+	PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNUSED )
+INPUT_PORTS_END
+
+
 /*************************************
  *
  *  Sound HW Config
@@ -960,6 +1069,27 @@
 	MDRV_DEVICE_REMOVE("cvsd")
 MACHINE_DRIVER_END
 
+static MACHINE_DRIVER_START( roylcrdn )
+	/* basic machine hardware */
+	MDRV_IMPORT_FROM(jangou)
+
+	MDRV_CPU_MODIFY("cpu0")
+	MDRV_CPU_PROGRAM_MAP(roylcrdn_cpu0_map )
+	MDRV_CPU_IO_MAP(roylcrdn_cpu0_io )
+
+	MDRV_DEVICE_REMOVE("cpu1")
+
+	MDRV_NVRAM_HANDLER(generic_0fill)
+
+	MDRV_MACHINE_START(common)
+	MDRV_MACHINE_RESET(common)
+
+	/* sound hardware */
+	MDRV_SOUND_START(0)
+	MDRV_DEVICE_REMOVE("cvsd")
+MACHINE_DRIVER_END
+
+
 /*************************************
  *
  *  ROM definition(s)
@@ -1174,6 +1304,36 @@
 	ROM_LOAD( "tbp18s30n.4f", 0x00, 0x20, CRC(dc54dc52) SHA1(db91a7ae05eb6b6e4b42f91dfe20ac0da6680b46) ) //verified on real hardware
 ROM_END
 
+/****************************************
+
+  Royal Card (amusement).
+  PCB silkscreened "FD-510"
+
+  1x Z80 @ 2.5 MHz. (measured)
+  1x AY-3-8910 @ 1.25 MHz. (measured)
+
+  1x MK48Z02B-15 ZEROPOWER RAM.
+
+  1x Xtal 20.000 MHz.
+
+****************************************/
+
+ROM_START( roylcrdn )
+	ROM_REGION( 0x10000, "cpu0", 0 )
+	ROM_LOAD( "prg.p1",		0x0000, 0x1000, CRC(9c3b1662) SHA1(b874f88521a21ba6cf9670ed4d81b5d275cf4d12) )
+	ROM_LOAD( "prg.p2",		0x1000, 0x1000, CRC(7e10259d) SHA1(d1279922a8c2475c3c73d9960b0a728c0ef851fb) )
+	ROM_LOAD( "prg.p3",		0x2000, 0x1000, CRC(06ef7073) SHA1(d3f990d710629b23daec76cd7ad6ccc7e066e710) )
+
+	ROM_REGION( 0x20000, "gfx", 0 )
+	ROM_LOAD( "chrgen.cr1",	0x0000, 0x1000, CRC(935d0e1c) SHA1(0d5b067f6931585c8138b211cf73e5f585af8101) )
+	ROM_LOAD( "chrgen.cr2",	0x1000, 0x1000, CRC(4429362e) SHA1(0bbb6dedf919e0453be2db6343827c5787d139f3) )
+	ROM_LOAD( "chrgen.cr3",	0x2000, 0x1000, CRC(dc059cc9) SHA1(3041e83b9a265adfe4e1da889ae6a18593de0894) )
+
+	ROM_REGION( 0x0020, "proms", 0 )
+	ROM_LOAD( "mb7051.3h",	0x0000, 0x0020, CRC(cb6f1aec) SHA1(84136393f9cf8bd836123a31483e9a746ca00cdc) )
+ROM_END
+
+
 ROM_START( luckygrl )
 	ROM_REGION( 0x10000, "cpu0", 0 ) //encrypted z80 cpu
 	ROM_LOAD( "5.9c", 0x00000, 0x01000, CRC(79b34eb2) SHA1(4b4916e09bfd6573fd2c7a7254fa4419164e0c4d) )
@@ -1263,6 +1423,8 @@
 GAME( 1984,  cntrygrl,   0,        cntrygrl, cntrygrl,  0,        ROT0, "Royal Denshi",   "Country Girl (Japan set 1)",  GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1984,  cntrygrla,  cntrygrl, cntrygrl, cntrygrl,  0,        ROT0, "Nichibutsu",     "Country Girl (Japan set 2)",  GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
 GAME( 1984,  fruitbun,   cntrygrl, cntrygrl, cntrygrl,  0,        ROT0, "Nichibutsu",     "Fruits & Bunny (World?)",  GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+GAME( 1985,  roylcrdn,   0,        roylcrdn, roylcrdn,  0,        ROT0, "Nichibutsu",     "Royal Card (Nichibutsu)", GAME_NO_COCKTAIL | GAME_SUPPORTS_SAVE )
+
 /* The following might not run there... */
 GAME( 1984?, luckygrl,   0,        cntrygrl, cntrygrl,  luckygrl, ROT0, "Wing Co., Ltd.", "Lucky Girl? (Wing)", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 
@@ -1273,5 +1435,4 @@
     Jangou Lady (BET version) (images on the flyer, it might not exists)
     Hana Royal
     Hana Puter
-    Royal Card
 */
diff -Nru src-old/mame/drivers/karnov.c src/mame/drivers/karnov.c
--- src-old/mame/drivers/karnov.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/karnov.c	2010-08-30 08:20:58.000000000 -0700
@@ -35,6 +35,44 @@
     Karnov - put 0x30 at 0x60201 to skip a level
     Chelnov - level number at 0x60189 - enter a value at cartoon intro
 
+
+Stephh's notes (based on the games M68000 code and some tests) :
+
+1) 'karnov' and its clones :
+
+  - DSW1 bit 7 is called "No Die Mode" in the manual. It used to give invulnerability
+    to shots (but not to falls), but it has no effect due to the "bra" instruction
+    at 0x001334 ('karnov') or 0x00131a ('karnovj').
+
+2) 'wndrplnt'
+
+  - There is code at 0x01c000 which tests DSW2 bit 6 which seems to act as a "Freeze"
+    Dip Switch, but this address doesn't seem to be reached. Leftover from another game ?
+  - DSW2 bit 7 used to give invulnerability, but it has no effect due to
+    the "andi.w  #$7fff, D5" instruction at 0x0011a2.
+
+3) 'chelnov' and its clones :
+
+3a) 'chelnov'
+
+  - DSW2 bit 6 isn't tested in this set.
+  - DSW2 bit 7 used to give invulnerability, but it has no effect due to
+    the "andi.w  #$3fff, D5" instruction at 0x000ed0.
+
+3b) 'chelnovu'
+
+  - DSW2 bit 6 freezes the game (code at 0x000654), but when you turn
+    the Dip Swicth back to "Off", it adds credits as if COIN1 was pressed.
+    Is that the correct behaviour ?
+  - Even if there is a "andi.w  #$ffff, D5" instruction at 0x000ef0,
+    DSW2 bit 7 isn't tested in this set.
+
+3c) 'chelnovj'
+
+  - DSW2 bit 6 isn't tested in this set.
+  - DSW2 bit 7 used to give invulnerability, but it has no effect due to
+    the "andi.w  #$3fff, D5" instruction at 0x000ed8.
+
 *******************************************************************************/
 
 #include "emu.h"
@@ -65,12 +103,12 @@
 
 	state->i8751_return = 0;
 
-	if (data == 0x100 && state->microcontroller_id == KARNOVJ)	/* Japan version */
-		state->i8751_return = 0x56a;
-
 	if (data == 0x100 && state->microcontroller_id == KARNOV)	/* USA version */
 		state->i8751_return = 0x56b;
 
+	if (data == 0x100 && state->microcontroller_id == KARNOVJ)	/* Japan version */
+		state->i8751_return = 0x56a;
+
 	if ((data & 0xf00) == 0x300)
 		state->i8751_return = (data & 0xff) * 0x12; /* Player sprite mapping */
 
@@ -164,28 +202,28 @@
 
 	state->i8751_return = 0;
 
-	if (data == 0x200 && state->microcontroller_id == CHELNOVJ)	/* Japan version */
-		state->i8751_return = 0x7734;
+	if (data == 0x200 && state->microcontroller_id == CHELNOV)	/* World version */
+		state->i8751_return = 0x7736;
 
-	if (data == 0x200 && state->microcontroller_id == CHELNOV)	/* USA version */
+	if (data == 0x200 && state->microcontroller_id == CHELNOVU)	/* USA version */
 		state->i8751_return = 0x783e;
 
-	if (data == 0x200 && state->microcontroller_id == CHELNOVW)	/* World version */
-		state->i8751_return = 0x7736;
+	if (data == 0x200 && state->microcontroller_id == CHELNOVJ)	/* Japan version */
+		state->i8751_return = 0x7734;
 
-	if (data == 0x100 && state->microcontroller_id == CHELNOVJ)	/* Japan version */
-		state->i8751_return = 0x71a;
+	if (data == 0x100 && state->microcontroller_id == CHELNOV)	/* World version */
+		state->i8751_return = 0x71c;
 
-	if (data == 0x100 && state->microcontroller_id == CHELNOV)	/* USA version */
+	if (data == 0x100 && state->microcontroller_id == CHELNOVU)	/* USA version */
 		state->i8751_return = 0x71b;
 
-	if (data == 0x100 && state->microcontroller_id == CHELNOVW)	/* World version */
-		state->i8751_return = 0x71c;
+	if (data == 0x100 && state->microcontroller_id == CHELNOVJ)	/* Japan version */
+		state->i8751_return = 0x71a;
 
 	if (data >= 0x6000 && data < 0x8000)
 		state->i8751_return = 1;  /* patched */
 
-	if ((data & 0xf000) == 0x1000) state->i8751_level = 1;	/* Level 1 */
+	if ((data & 0xf000) == 0x1000) state->i8751_level = 1;		/* Level 1 */
 	if ((data & 0xf000) == 0x2000) state->i8751_level++;		/* Level Increment */
 
 	if ((data & 0xf000) == 0x3000)
@@ -195,7 +233,7 @@
 		switch (state->i8751_level)
 		{
 			case 1: /* Level 1, Sprite mapping tables */
-				if (state->microcontroller_id == CHELNOV) /* USA */
+				if (state->microcontroller_id == CHELNOVU) /* USA */
 				{
 					if (b < 2) state->i8751_return = 0;
 					else if (b < 6) state->i8751_return = 1;
@@ -217,7 +255,7 @@
 					else state->i8751_return = 8;
 				}
 				break;
-			case 2: /* Level 2, Sprite mapping tables, USA & Japan are the same */
+			case 2: /* Level 2, Sprite mapping tables, all sets are the same */
 				if (b < 3) state->i8751_return = 0;
 				else if (b < 9) state->i8751_return = 1;
 				else if (b < 0x11) state->i8751_return = 2;
@@ -226,7 +264,7 @@
 				else if (b < 0x28) state->i8751_return = 5;
 				else state->i8751_return = 6;
 				break;
-			case 3: /* Level 3, Sprite mapping tables, USA & Japan are the same */
+			case 3: /* Level 3, Sprite mapping tables, all sets are the same */
 				if (b < 5) state->i8751_return = 0;
 				else if (b < 9) state->i8751_return = 1;
 				else if (b < 0xd) state->i8751_return = 2;
@@ -237,7 +275,7 @@
 				else if (b < 0x27) state->i8751_return = 7;
 				else state->i8751_return = 8;
 				break;
-			case 4: /* Level 4, Sprite mapping tables, USA & Japan are the same */
+			case 4: /* Level 4, Sprite mapping tables, all sets are the same */
 				if (b < 4) state->i8751_return = 0;
 				else if (b < 0xc) state->i8751_return = 1;
 				else if (b < 0xf) state->i8751_return = 2;
@@ -247,7 +285,7 @@
 				else if (b < 0x29) state->i8751_return = 6;
 				else state->i8751_return = 7;
 				break;
-			case 5: /* Level 5, Sprite mapping tables */
+			case 5: /* Level 5, Sprite mapping tables, all sets are the same  */
 				if (b < 7) state->i8751_return = 0;
 				else if (b < 0xe) state->i8751_return = 1;
 				else if (b < 0x14) state->i8751_return = 2;
@@ -256,7 +294,7 @@
 				else if (b < 0x27) state->i8751_return = 5;
 				else state->i8751_return = 6;
 				break;
-			case 6: /* Level 6, Sprite mapping tables */
+			case 6: /* Level 6, Sprite mapping tables, all sets are the same  */
 				if (b < 3) state->i8751_return = 0;
 				else if (b < 0xb) state->i8751_return = 1;
 				else if (b < 0x11) state->i8751_return = 2;
@@ -265,7 +303,7 @@
 				else if (b < 0x24) state->i8751_return = 5;
 				else state->i8751_return = 6;
 				break;
-			case 7: /* Level 7, Sprite mapping tables */
+			case 7: /* Level 7, Sprite mapping tables, all sets are the same  */
 				if (b < 5) state->i8751_return = 0;
 				else if (b < 0xb) state->i8751_return = 1;
 				else if (b < 0x11) state->i8751_return = 2;
@@ -334,7 +372,7 @@
 		case 6: /* SECREQ (Interrupt & Data to i8751) */
 			if (state->microcontroller_id == KARNOV || state->microcontroller_id == KARNOVJ)
 				karnov_i8751_w(space->machine, data);
-			if (state->microcontroller_id == CHELNOV || state->microcontroller_id == CHELNOVJ || state->microcontroller_id == CHELNOVW)
+			if (state->microcontroller_id == CHELNOV || state->microcontroller_id == CHELNOVU || state->microcontroller_id == CHELNOVJ)
 				chelnov_i8751_w(space->machine, data);
 			if (state->microcontroller_id == WNDRPLNT)
 				wndrplnt_i8751_w(space->machine, data);
@@ -418,18 +456,18 @@
 
 static INPUT_PORTS_START( common )
 	PORT_START("P1_P2")
-	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY
-	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY
-	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY
+	PORT_BIT( 0x0001, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY
+	PORT_BIT( 0x0002, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY
+	PORT_BIT( 0x0004, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY
 	PORT_BIT( 0x0008, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY
 	PORT_BIT( 0x0010, IP_ACTIVE_LOW, IPT_BUTTON1 )
 	PORT_BIT( 0x0020, IP_ACTIVE_LOW, IPT_BUTTON2 )
 	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_BUTTON3 )
 	PORT_BIT( 0x0080, IP_ACTIVE_LOW, IPT_UNUSED ) /* Button 4 on karnov schematics */
 
-	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_8WAY PORT_COCKTAIL
-	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x0100, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x0200, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_8WAY PORT_COCKTAIL
+	PORT_BIT( 0x0400, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x0800, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_8WAY PORT_COCKTAIL
 	PORT_BIT( 0x1000, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL
 	PORT_BIT( 0x2000, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_COCKTAIL
@@ -448,78 +486,84 @@
 INPUT_PORTS_END
 
 
+/* verified from M68000 code */
 static INPUT_PORTS_START( karnov )
 	PORT_INCLUDE( common )
 
 	PORT_START("FAKE")	/* Dummy input for i8751 */
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 )
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SERVICE1 )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_B ) ) PORT_DIPLOCATION("SW1:3,4")
+	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A ) )       PORT_DIPLOCATION("SW1:1,2")
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_A ) ) PORT_DIPLOCATION("SW1:1,2")
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B ) )       PORT_DIPLOCATION("SW1:3,4")
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_3C ) )
-	PORT_DIPUNUSED_DIPLOC( 0x0010, 0x0000, "SW1:5" )
-	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Flip_Screen ) ) PORT_DIPLOCATION("SW1:6")
+	PORT_DIPUNUSED_DIPLOC( 0x0010, 0x0010, "SW1:5" )
+	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Flip_Screen ) )  PORT_DIPLOCATION("SW1:6")
 	PORT_DIPSETTING(      0x0020, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0040, 0x0000, DEF_STR( Cabinet ) ) PORT_DIPLOCATION("SW1:7")
+	PORT_DIPNAME( 0x0040, 0x0000, DEF_STR( Cabinet ) )      PORT_DIPLOCATION("SW1:7")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Upright ) )
 	PORT_DIPSETTING(      0x0040, DEF_STR( Cocktail ) )
-	PORT_DIPUNKNOWN_DIPLOC( 0x0080, 0x0080, "SW1:8" )
-	/* 0x0080 called No Die Mode according to the manual, but it doesn't seem to have any effect */
+	PORT_DIPUNUSED_DIPLOC( 0x0080, 0x0080, "SW1:8" )        /* see notes */
 
-	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) ) PORT_DIPLOCATION("SW2:1,2")
+	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) )        PORT_DIPLOCATION("SW2:1,2")
 	PORT_DIPSETTING(      0x0100, "1" )
 	PORT_DIPSETTING(      0x0300, "3" )
 	PORT_DIPSETTING(      0x0200, "5" )
 	PORT_DIPSETTING(      0x0000, "Infinite (Cheat)")
-	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Bonus_Life ) ) PORT_DIPLOCATION("SW2:3,4")
-	PORT_DIPSETTING(      0x0c00, "50 K" )
-	PORT_DIPSETTING(      0x0800, "70 K" )
-	PORT_DIPSETTING(      0x0400, "90 K" )
-	PORT_DIPSETTING(      0x0000, "100 K" )
-	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Difficulty ) ) PORT_DIPLOCATION("SW2:5,6")
+	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Bonus_Life ) )   PORT_DIPLOCATION("SW2:3,4")
+	PORT_DIPSETTING(      0x0c00, "50 'K'" )
+	PORT_DIPSETTING(      0x0800, "70 'K'" )
+	PORT_DIPSETTING(      0x0400, "90 'K'" )
+	PORT_DIPSETTING(      0x0000, "100 'K'" )
+	PORT_DIPNAME( 0x3000, 0x3000, DEF_STR( Difficulty ) )   PORT_DIPLOCATION("SW2:5,6")
 	PORT_DIPSETTING(      0x2000, DEF_STR( Easy ) )
 	PORT_DIPSETTING(      0x3000, DEF_STR( Normal ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( Hard ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Very_Hard ) )
-	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Demo_Sounds ) ) PORT_DIPLOCATION("SW2:7")
+	PORT_DIPNAME( 0x4000, 0x4000, DEF_STR( Demo_Sounds ) )  PORT_DIPLOCATION("SW2:7")
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x4000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x8000, 0x8000, "Timer Speed" ) PORT_DIPLOCATION("SW2:8")
+	PORT_DIPNAME( 0x8000, 0x8000, "Timer Speed" )           PORT_DIPLOCATION("SW2:8")
 	PORT_DIPSETTING(      0x8000, DEF_STR( Normal ) )
 	PORT_DIPSETTING(      0x0000, "Fast" )
 INPUT_PORTS_END
 
+
+/* verified from M68000 code */
 static INPUT_PORTS_START( wndrplnt )
 	PORT_INCLUDE( common )
 
+	PORT_MODIFY("P1_P2")
+	PORT_BIT( 0x0040, IP_ACTIVE_LOW, IPT_UNUSED )           /* BUTTON3 */
+	PORT_BIT( 0x4000, IP_ACTIVE_LOW, IPT_UNUSED )           /* BUTTON3 PORT_COCKTAIL */
+
 	PORT_START("FAKE")	/* Dummy input for i8751 */
-	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_COIN1 )
+	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_COIN1 )
 	PORT_BIT( 0x02, IP_ACTIVE_HIGH, IPT_COIN2 )
-	PORT_BIT( 0x01, IP_ACTIVE_HIGH, IPT_SERVICE1 )
+	PORT_BIT( 0x04, IP_ACTIVE_HIGH, IPT_SERVICE1 )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_B ) )
+	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_3C ) )
-	PORT_DIPUNKNOWN( 0x0010, 0x0000 )
+	PORT_DIPUNUSED( 0x0010, 0x0010 )
 	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0020, DEF_STR( On ) )
@@ -535,44 +579,41 @@
 	PORT_DIPSETTING(      0x0300, "3" )
 	PORT_DIPSETTING(      0x0200, "5" )
 	PORT_DIPSETTING(      0x0000, "Infinite (Cheat)")
-	PORT_DIPUNKNOWN( 0x0400, 0x0400 )
-	PORT_DIPUNKNOWN( 0x0800, 0x0800 )
+	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(      0x0800, DEF_STR( Easy ) )
+	PORT_DIPSETTING(      0x0c00, DEF_STR( Normal ) )
+	PORT_DIPSETTING(      0x0400, DEF_STR( Hard ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
 	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Allow_Continue ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( No ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( Yes ) )
-	PORT_DIPUNKNOWN( 0x2000, 0x2000 )
-	PORT_DIPNAME( 0xc000, 0xc000, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(      0x8000, DEF_STR( Easy ) )
-	PORT_DIPSETTING(      0xc000, DEF_STR( Normal ) )
-	PORT_DIPSETTING(      0x4000, DEF_STR( Hard ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
+	PORT_DIPUNUSED( 0x2000, 0x2000 )
+	PORT_DIPUNUSED( 0x4000, 0x4000 )                        /* see notes */
+	PORT_DIPUNUSED( 0x8000, 0x8000 )                        /* see notes */
 INPUT_PORTS_END
 
+
+/* verified from M68000 code */
 static INPUT_PORTS_START( chelnov )
 	PORT_INCLUDE( common )
 
-	PORT_MODIFY("SYSTEM")
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-
 	PORT_START("FAKE")	/* Dummy input for i8751 */
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN2 )
 	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SERVICE1 )
 
 	PORT_START("DSW")
-	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )
-	PORT_DIPSETTING(      0x0004, DEF_STR( 3C_1C ) )
-	PORT_DIPSETTING(      0x0008, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )
 	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_3C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_4C ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 1C_6C ) )
-	PORT_DIPUNKNOWN( 0x0010, 0x0010 )
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B ) )
+	PORT_DIPSETTING(      0x0000, DEF_STR( 4C_1C ) )
+	PORT_DIPSETTING(      0x0004, DEF_STR( 3C_1C ) )
+	PORT_DIPSETTING(      0x0008, DEF_STR( 2C_1C ) )
+	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )
+	PORT_DIPUNUSED( 0x0010, 0x0010 )
 	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0020, DEF_STR( On ) )
@@ -588,74 +629,44 @@
 	PORT_DIPSETTING(      0x0300, "3" )
 	PORT_DIPSETTING(      0x0200, "5" )
 	PORT_DIPSETTING(      0x0000, "Infinite (Cheat)")
-	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(      0x0400, DEF_STR( Easy ) )
-	PORT_DIPSETTING(      0x0c00, DEF_STR( Normal ) )
-	PORT_DIPSETTING(      0x0800, DEF_STR( Hard ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
+	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )   /* also determines "Bonus Life" settings */
+	PORT_DIPSETTING(      0x0800, DEF_STR( Easy ) )         /* bonus life at 30k 60k 100k 150k 250k 100k+ */
+	PORT_DIPSETTING(      0x0c00, DEF_STR( Normal ) )       /* bonus life at 50k 120k 200k 300k 100k+ */
+	PORT_DIPSETTING(      0x0400, DEF_STR( Hard ) )         /* bonus life at 80k 160k 260k 100k+ */
+	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )      /* bonus life at every 100k */
 	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Allow_Continue ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( No ) )
 	PORT_DIPSETTING(      0x1000, DEF_STR( Yes ) )
-	PORT_DIPUNKNOWN( 0x2000, 0x2000 )
-	PORT_DIPNAME( 0x4000, 0x4000, "Freeze" )
-	PORT_DIPSETTING(      0x4000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPUNUSED( 0x8000, 0x8000 )
+	PORT_DIPUNUSED( 0x2000, 0x2000 )
+	PORT_DIPUNUSED( 0x4000, 0x4000 )                        /* see notes */
+	PORT_DIPUNUSED( 0x8000, 0x8000 )                        /* see notes */
 INPUT_PORTS_END
 
-static INPUT_PORTS_START( chelnovu )
-	PORT_INCLUDE( common )
-
-	PORT_MODIFY("SYSTEM")
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNUSED )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
-
-	PORT_START("FAKE")	/* Dummy input for i8751 */
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_SERVICE1 )
+/* verified from M68000 code */
+static INPUT_PORTS_START( chelnovj )
+	PORT_INCLUDE( chelnov )
 
-	PORT_START("DSW")
-	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_B ) )
+	PORT_MODIFY("DSW")
+	PORT_DIPNAME( 0x0003, 0x0003, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x0003, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0002, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0001, DEF_STR( 1C_3C ) )
-	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_A ) )
+	PORT_DIPNAME( 0x000c, 0x000c, DEF_STR( Coin_B ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING(      0x000c, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING(      0x0008, DEF_STR( 1C_2C ) )
 	PORT_DIPSETTING(      0x0004, DEF_STR( 1C_3C ) )
-	PORT_DIPUNKNOWN( 0x0010, 0x0010 )
-	PORT_DIPNAME( 0x0020, 0x0020, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0020, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0040, 0x0040, DEF_STR( Flip_Screen ) )
-	PORT_DIPSETTING(      0x0040, DEF_STR( Off ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPNAME( 0x0080, 0x0000, DEF_STR( Cabinet ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Upright ) )
-	PORT_DIPSETTING(      0x0080, DEF_STR( Cocktail ) )
+INPUT_PORTS_END
 
-	PORT_DIPNAME( 0x0300, 0x0300, DEF_STR( Lives ) )
-	PORT_DIPSETTING(      0x0100, "1" )
-	PORT_DIPSETTING(      0x0300, "3" )
-	PORT_DIPSETTING(      0x0200, "5" )
-	PORT_DIPSETTING(      0x0000, "Infinite (Cheat)")
-	PORT_DIPNAME( 0x0c00, 0x0c00, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(      0x0400, DEF_STR( Easy ) )
-	PORT_DIPSETTING(      0x0c00, DEF_STR( Normal ) )
-	PORT_DIPSETTING(      0x0800, DEF_STR( Hard ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x1000, 0x1000, DEF_STR( Allow_Continue ) )
-	PORT_DIPSETTING(      0x0000, DEF_STR( No ) )
-	PORT_DIPSETTING(      0x1000, DEF_STR( Yes ) )
-	PORT_DIPUNKNOWN( 0x2000, 0x2000 )
-	PORT_DIPNAME( 0x4000, 0x4000, "Freeze" )
+/* verified from M68000 code */
+static INPUT_PORTS_START( chelnovu )
+	PORT_INCLUDE( chelnovj )
+
+	PORT_MODIFY("DSW")
+	PORT_DIPNAME( 0x4000, 0x4000, "Freeze" )                /* see notes */
 	PORT_DIPSETTING(      0x4000, DEF_STR( Off ) )
 	PORT_DIPSETTING(      0x0000, DEF_STR( On ) )
-	PORT_DIPUNUSED( 0x8000, 0x8000 )
 INPUT_PORTS_END
 
 
@@ -718,21 +729,22 @@
 static INTERRUPT_GEN( karnov_interrupt )
 {
 	karnov_state *state = device->machine->driver_data<karnov_state>();
+	UINT8 port = input_port_read(device->machine, "FAKE");
 
 	/* Coin input to the i8751 generates an interrupt to the main cpu */
-	if (input_port_read(device->machine, "FAKE") == state->coin_mask)
+	if (port == state->coin_mask)
 		state->latch = 1;
 
-	if (input_port_read(device->machine, "FAKE") != state->coin_mask && state->latch)
+	if (port != state->coin_mask && state->latch)
 	{
 		if (state->i8751_needs_ack)
 		{
 			/* i8751 is busy - queue the command */
-			state->i8751_coin_pending = input_port_read(device->machine, "FAKE") | 0x8000;
+			state->i8751_coin_pending = port | 0x8000;
 		}
 		else
 		{
-			state->i8751_return = input_port_read(device->machine, "FAKE") | 0x8000;
+			state->i8751_return = port | 0x8000;
 			cpu_set_input_line(device, 6, HOLD_LINE);
 			state->i8751_needs_ack = 1;
 		}
@@ -1002,12 +1014,12 @@
 	ROM_LOAD( "ea20.prm",      0x0400, 0x0400, CRC(619f9d1e) SHA1(17fe49b6c9ce17be4a03e3400229e3ef4998a46f) )
 ROM_END
 
-ROM_START( chelnovu )
+ROM_START( chelnov )
 	ROM_REGION( 0x60000, "maincpu", 0 )	/* 6*64k for 68000 code */
-	ROM_LOAD16_BYTE( "ee08-a.j15",   0x00000, 0x10000, CRC(2f2fb37b) SHA1(f89b424099097a95cf184d20a15b876c5b639552) )
-	ROM_LOAD16_BYTE( "ee11-a.j20",   0x00001, 0x10000, CRC(f306d05f) SHA1(e523ffd17fb0104fe28eac288b6ebf7fc0ea2908) )
-	ROM_LOAD16_BYTE( "ee07-a.j14",   0x20000, 0x10000, CRC(9c69ed56) SHA1(23606d2fc7c550eaddf0fd4b0da1a4e2c9263e14) )
-	ROM_LOAD16_BYTE( "ee10-a.j18",   0x20001, 0x10000, CRC(d5c5fe4b) SHA1(183b2f5dfa4e0a9067674a29abab2744a887fd19) )
+	ROM_LOAD16_BYTE( "ee08-e.j16",   0x00000, 0x10000, CRC(8275cc3a) SHA1(961166226b68744eef15fed6a306010757b83556) )
+	ROM_LOAD16_BYTE( "ee11-e.j19",   0x00001, 0x10000, CRC(889e40a0) SHA1(e927f32d9bc448a331fb7b3478b2d07154f5013b) )
+	ROM_LOAD16_BYTE( "a-j14.bin",    0x20000, 0x10000, CRC(51465486) SHA1(e165e754eb756db3abc1f8477171ab817d03a890) )
+	ROM_LOAD16_BYTE( "a-j18.bin",    0x20001, 0x10000, CRC(d09dda33) SHA1(1764215606eec61e4fe30c0fc82ea2faf17821dc) )
 	ROM_LOAD16_BYTE( "ee06-e.j13",   0x40000, 0x10000, CRC(55acafdb) SHA1(9dc0528c888dd73617f8cab76690b9296715680a) )
 	ROM_LOAD16_BYTE( "ee09-e.j17",   0x40001, 0x10000, CRC(303e252c) SHA1(d5d2570e42aa1e1b3600d14cc694677248e12750) )
 
@@ -1035,12 +1047,12 @@
 	ROM_LOAD( "ee20.l6",      0x0400, 0x0400, CRC(41816132) SHA1(89a1194bd8bf39f13419df685e489440bdb05676) )
 ROM_END
 
-ROM_START( chelnov )
+ROM_START( chelnovu )
 	ROM_REGION( 0x60000, "maincpu", 0 )	/* 6*64k for 68000 code */
-	ROM_LOAD16_BYTE( "ee08-e.j16",   0x00000, 0x10000, CRC(8275cc3a) SHA1(961166226b68744eef15fed6a306010757b83556) )
-	ROM_LOAD16_BYTE( "ee11-e.j19",   0x00001, 0x10000, CRC(889e40a0) SHA1(e927f32d9bc448a331fb7b3478b2d07154f5013b) )
-	ROM_LOAD16_BYTE( "a-j14.bin",    0x20000, 0x10000, CRC(51465486) SHA1(e165e754eb756db3abc1f8477171ab817d03a890) )
-	ROM_LOAD16_BYTE( "a-j18.bin",    0x20001, 0x10000, CRC(d09dda33) SHA1(1764215606eec61e4fe30c0fc82ea2faf17821dc) )
+	ROM_LOAD16_BYTE( "ee08-a.j15",   0x00000, 0x10000, CRC(2f2fb37b) SHA1(f89b424099097a95cf184d20a15b876c5b639552) )
+	ROM_LOAD16_BYTE( "ee11-a.j20",   0x00001, 0x10000, CRC(f306d05f) SHA1(e523ffd17fb0104fe28eac288b6ebf7fc0ea2908) )
+	ROM_LOAD16_BYTE( "ee07-a.j14",   0x20000, 0x10000, CRC(9c69ed56) SHA1(23606d2fc7c550eaddf0fd4b0da1a4e2c9263e14) )
+	ROM_LOAD16_BYTE( "ee10-a.j18",   0x20001, 0x10000, CRC(d5c5fe4b) SHA1(183b2f5dfa4e0a9067674a29abab2744a887fd19) )
 	ROM_LOAD16_BYTE( "ee06-e.j13",   0x40000, 0x10000, CRC(55acafdb) SHA1(9dc0528c888dd73617f8cab76690b9296715680a) )
 	ROM_LOAD16_BYTE( "ee09-e.j17",   0x40001, 0x10000, CRC(303e252c) SHA1(d5d2570e42aa1e1b3600d14cc694677248e12750) )
 
@@ -1112,21 +1124,21 @@
 {
 	karnov_state *state = machine->driver_data<karnov_state>();
 	state->microcontroller_id = KARNOV;
-	state->coin_mask = 0;
+	state->coin_mask = 0x07;
 }
 
 static DRIVER_INIT( karnovj )
 {
 	karnov_state *state = machine->driver_data<karnov_state>();
 	state->microcontroller_id = KARNOVJ;
-	state->coin_mask = 0;
+	state->coin_mask = 0x07;
 }
 
 static DRIVER_INIT( wndrplnt )
 {
 	karnov_state *state = machine->driver_data<karnov_state>();
 	state->microcontroller_id = WNDRPLNT;
-	state->coin_mask = 0;
+	state->coin_mask = 0x00;
 }
 
 static DRIVER_INIT( chelnov )
@@ -1140,12 +1152,12 @@
 	RAM[0x062a/2] = 0x4e71;  /* hangs waiting on i8751 int */
 }
 
-static DRIVER_INIT( chelnovw )
+static DRIVER_INIT( chelnovu )
 {
 	karnov_state *state = machine->driver_data<karnov_state>();
 	UINT16 *RAM = (UINT16 *)memory_region(machine, "maincpu");
 
-	state->microcontroller_id = CHELNOVW;
+	state->microcontroller_id = CHELNOVU;
 	state->coin_mask = 0xe0;
 	RAM[0x0a26/2] = 0x4e71;  /* removes a protection lookup table */
 	RAM[0x062a/2] = 0x4e71;  /* hangs waiting on i8751 int */
@@ -1172,6 +1184,6 @@
 GAME( 1987, karnov,   0,       karnov,   karnov,   karnov,   ROT0,   "Data East USA",         "Karnov (US)", GAME_SUPPORTS_SAVE )
 GAME( 1987, karnovj,  karnov,  karnov,   karnov,   karnovj,  ROT0,   "Data East Corporation", "Karnov (Japan)", GAME_SUPPORTS_SAVE )
 GAME( 1987, wndrplnt, 0,       wndrplnt, wndrplnt, wndrplnt, ROT270, "Data East Corporation", "Wonder Planet (Japan)", GAME_SUPPORTS_SAVE )
-GAME( 1988, chelnov,  0,       karnov,   chelnov,  chelnovw, ROT0,   "Data East Corporation", "Chelnov - Atomic Runner (World)", GAME_SUPPORTS_SAVE )
-GAME( 1988, chelnovu, chelnov, karnov,   chelnovu, chelnov,  ROT0,   "Data East USA",         "Chelnov - Atomic Runner (US)", GAME_SUPPORTS_SAVE )
-GAME( 1988, chelnovj, chelnov, karnov,   chelnovu, chelnovj, ROT0,   "Data East Corporation", "Chelnov - Atomic Runner (Japan)", GAME_SUPPORTS_SAVE )
+GAME( 1988, chelnov,  0,       karnov,   chelnov,  chelnov,  ROT0,   "Data East Corporation", "Chelnov - Atomic Runner (World)", GAME_SUPPORTS_SAVE )
+GAME( 1988, chelnovu, chelnov, karnov,   chelnovu, chelnovu, ROT0,   "Data East USA",         "Chelnov - Atomic Runner (US)", GAME_SUPPORTS_SAVE )
+GAME( 1988, chelnovj, chelnov, karnov,   chelnovj, chelnovj, ROT0,   "Data East Corporation", "Chelnov - Atomic Runner (Japan)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/kchamp.c src/mame/drivers/kchamp.c
--- src-old/mame/drivers/kchamp.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/kchamp.c	2010-08-19 07:19:38.000000000 -0700
@@ -736,12 +736,12 @@
 
 static UINT8 *decrypt_code(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int A;
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypted);
+	space->set_decrypted_region(0x0000, 0xffff, decrypted);
 
 	for (A = 0; A < 0x10000; A++)
 		decrypted[A] = (rom[A] & 0x55) | ((rom[A] & 0x88) >> 2) | ((rom[A] & 0x22) << 2);
diff -Nru src-old/mame/drivers/kinst.c src/mame/drivers/kinst.c
--- src-old/mame/drivers/kinst.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/kinst.c	2010-08-26 09:31:58.000000000 -0700
@@ -629,7 +629,7 @@
  *
  *************************************/
 
-static const mips3_config config =
+static const mips3_config r4600_config =
 {
 	16384,				/* code cache size */
 	16384				/* data cache size */
@@ -640,7 +640,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R4600LE, MASTER_CLOCK*2)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r4600_config)
 	MDRV_CPU_PROGRAM_MAP(main_map)
 	MDRV_CPU_VBLANK_INT("screen", irq0_start)
 
diff -Nru src-old/mame/drivers/konamigx.c src/mame/drivers/konamigx.c
--- src-old/mame/drivers/konamigx.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/konamigx.c	2010-08-19 01:27:05.000000000 -0700
@@ -185,7 +185,7 @@
 	UINT32 adr;
 } sprites[0x100];
 
-static void generate_sprites(const address_space *space, UINT32 src, UINT32 spr, int count)
+static void generate_sprites(address_space *space, UINT32 src, UINT32 spr, int count)
 {
 	int i;
 	int scount;
@@ -196,9 +196,9 @@
 	for(i=0; i<count; i++) {
 		UINT32 adr = src + 0x100*i;
 		int pri;
-		if(!memory_read_word(space, adr+2))
+		if(!space->read_word(adr+2))
 			continue;
-		pri = memory_read_word(space, adr+28);
+		pri = space->read_word(adr+28);
 
 		if(pri < 256) {
 			sprites[ecount].pri = pri;
@@ -211,39 +211,39 @@
 	for(i=0; i<ecount; i++) {
 		UINT32 adr = sprites[i].adr;
 		if(adr) {
-			UINT32 set =(memory_read_word(space, adr) << 16)|memory_read_word(space, adr+2);
-			UINT16 glob_x = memory_read_word(space, adr+4);
-			UINT16 glob_y = memory_read_word(space, adr+8);
-			UINT16 flip_x = memory_read_word(space, adr+12) ? 0x1000 : 0x0000;
-			UINT16 flip_y = memory_read_word(space, adr+14) ? 0x2000 : 0x0000;
+			UINT32 set =(space->read_word(adr) << 16)|space->read_word(adr+2);
+			UINT16 glob_x = space->read_word(adr+4);
+			UINT16 glob_y = space->read_word(adr+8);
+			UINT16 flip_x = space->read_word(adr+12) ? 0x1000 : 0x0000;
+			UINT16 flip_y = space->read_word(adr+14) ? 0x2000 : 0x0000;
 			UINT16 glob_f = flip_x | (flip_y ^ 0x2000);
-			UINT16 zoom_x = memory_read_word(space, adr+20);
-			UINT16 zoom_y = memory_read_word(space, adr+22);
+			UINT16 zoom_x = space->read_word(adr+20);
+			UINT16 zoom_y = space->read_word(adr+22);
 			UINT16 color_val    = 0x0000;
 			UINT16 color_mask   = 0xffff;
 			UINT16 color_set    = 0x0000;
 			UINT16 color_rotate = 0x0000;
 			UINT16 v;
 
-			v = memory_read_word(space, adr+24);
+			v = space->read_word(adr+24);
 			if(v & 0x8000) {
 				color_mask = 0xf3ff;
 				color_val |= (v & 3) << 10;
 			}
 
-			v = memory_read_word(space, adr+26);
+			v = space->read_word(adr+26);
 			if(v & 0x8000) {
 				color_mask &= 0xfcff;
 				color_val  |= (v & 3) << 8;
 			}
 
-			v = memory_read_word(space, adr+18);
+			v = space->read_word(adr+18);
 			if(v & 0x8000) {
 				color_mask &= 0xff1f;
 				color_val  |= v & 0xe0;
 			}
 
-			v = memory_read_word(space, adr+16);
+			v = space->read_word(adr+16);
 			if(v & 0x8000)
 				color_set = v & 0x1f;
 			if(v & 0x4000)
@@ -256,14 +256,14 @@
 
 			if(set >= 0x200000 && set < 0xd00000)
 			{
-				UINT16 count2 = memory_read_word(space, set);
+				UINT16 count2 = space->read_word(set);
 				set += 2;
 				while(count2) {
-					UINT16 idx  = memory_read_word(space, set);
-					UINT16 flip = memory_read_word(space, set+2);
-					UINT16 col  = memory_read_word(space, set+4);
-					short y = memory_read_word(space, set+6);
-					short x = memory_read_word(space, set+8);
+					UINT16 idx  = space->read_word(set);
+					UINT16 flip = space->read_word(set+2);
+					UINT16 col  = space->read_word(set+4);
+					short y = space->read_word(set+6);
+					short x = space->read_word(set+8);
 
 					if(idx == 0xffff) {
 						set = (flip<<16) | col;
@@ -298,13 +298,13 @@
 					if(color_rotate)
 						col = (col & 0xffe0) | ((col + color_rotate) & 0x1f);
 
-					memory_write_word(space, spr   , (flip ^ glob_f) | sprites[i].pri);
-					memory_write_word(space, spr+ 2, idx);
-					memory_write_word(space, spr+ 4, y);
-					memory_write_word(space, spr+ 6, x);
-					memory_write_word(space, spr+ 8, zoom_y);
-					memory_write_word(space, spr+10, zoom_x);
-					memory_write_word(space, spr+12, col);
+					space->write_word(spr   , (flip ^ glob_f) | sprites[i].pri);
+					space->write_word(spr+ 2, idx);
+					space->write_word(spr+ 4, y);
+					space->write_word(spr+ 6, x);
+					space->write_word(spr+ 8, zoom_y);
+					space->write_word(spr+10, zoom_x);
+					space->write_word(spr+12, col);
 					spr += 16;
 					scount++;
 					if(scount == 256)
@@ -317,45 +317,45 @@
 		}
 	}
 	while(scount < 256) {
-		memory_write_word(space, spr, scount);
+		space->write_word(spr, scount);
 		scount++;
 		spr += 16;
 	}
 }
 
-static void tkmmpzdm_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void tkmmpzdm_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	konamigx_esc_alert(gx_workram, 0x0142, 0x100, 0);
 }
 
-static void dragoonj_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void dragoonj_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	konamigx_esc_alert(gx_workram, 0x5c00, 0x100, 0);
 }
 
-static void sal2_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void sal2_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	konamigx_esc_alert(gx_workram, 0x1c8c, 0x172, 1);
 }
 
-static void sexyparo_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void sexyparo_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	// The d20000 should probably be p3
 	generate_sprites(space, 0xc00604, 0xd20000, 0xfc);
 }
 
-static void tbyahhoo_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void tbyahhoo_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	generate_sprites(space, 0xc00000, 0xd20000, 0x100);
 }
 
-static void daiskiss_esc(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
+static void daiskiss_esc(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4)
 {
 	generate_sprites(space, 0xc00000, 0xd20000, 0x100);
 }
 
 static UINT8 esc_program[4096];
-static void (*esc_cb)(const address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4);
+static void (*esc_cb)(address_space *space, UINT32 p1, UINT32 p2, UINT32 p3, UINT32 p4);
 
 static WRITE32_HANDLER( esc_w )
 {
@@ -375,7 +375,7 @@
 	}
 
 	/* the master opcode can be at an unaligned address, so get it "safely" */
-	opcode = (memory_read_word(space, data+2))|(memory_read_word(space, data)<<16);
+	opcode = (space->read_word(data+2))|(space->read_word(data)<<16);
 
 	/* if there's an OBJECT_MAGIC_ID, that means
        there is a valid ESC command packet. */
@@ -383,15 +383,15 @@
 	{
 		int i;
 		/* get the subop now */
-		opcode = memory_read_byte(space, data+8);
-		params = (memory_read_word(space, data+12) << 16) | memory_read_word(space, data+14);
+		opcode = space->read_byte(data+8);
+		params = (space->read_word(data+12) << 16) | space->read_word(data+14);
 
 		switch(opcode) {
 		case 5: // Reset
 			break;
 		case 2: // Load program
 			for(i=0; i<4096; i++)
-				esc_program[i] = memory_read_byte(space, params+i);
+				esc_program[i] = space->read_byte(params+i);
 /*
             {
                 FILE *f;
@@ -406,10 +406,10 @@
 			break;
 		case 1: // Run program
 			if(esc_cb) {
-				UINT32 p1 = (memory_read_word(space, params+0)<<16) | memory_read_word(space, params+2);
-				UINT32 p2 = (memory_read_word(space, params+4)<<16) | memory_read_word(space, params+6);
-				UINT32 p3 = (memory_read_word(space, params+8)<<16) | memory_read_word(space, params+10);
-				UINT32 p4 = (memory_read_word(space, params+12)<<16) | memory_read_word(space, params+14);
+				UINT32 p1 = (space->read_word(params+0)<<16) | space->read_word(params+2);
+				UINT32 p2 = (space->read_word(params+4)<<16) | space->read_word(params+6);
+				UINT32 p3 = (space->read_word(params+8)<<16) | space->read_word(params+10);
+				UINT32 p4 = (space->read_word(params+12)<<16) | space->read_word(params+14);
 				esc_cb(space, p1, p2, p3, p4);
 			}
 			break;
@@ -417,7 +417,7 @@
 //          logerror("Unknown ESC opcode %d\n", opcode);
 			break;
 		}
-		memory_write_byte(space, data+9, ESTATE_END);
+		space->write_byte(data+9, ESTATE_END);
 
 		if (konamigx_wrport1_1 & 0x10)
 		{
@@ -1063,20 +1063,20 @@
 					// memcpy from c01000 to c01400 for 0x400 bytes (startup check for type 4 games)
 					for (i = 0; i < 0x400; i += 2)
 					{
-						memory_write_word(space, 0xc01400+i, memory_read_word(space, 0xc01000+i));
+						space->write_word(0xc01400+i, space->read_word(0xc01000+i));
 					}
 				}
 				else if(last_prot_op == 0x57a)	// winspike
 				{
 					/* player 1 input buffer protection */
-					memory_write_dword(space, 0xc10f00, memory_read_dword(space, 0xc00f10));
-					memory_write_dword(space, 0xc10f04, memory_read_dword(space, 0xc00f14));
+					space->write_dword(0xc10f00, space->read_dword(0xc00f10));
+					space->write_dword(0xc10f04, space->read_dword(0xc00f14));
 					/* player 2 input buffer protection */
-					memory_write_dword(space, 0xc10f20, memory_read_dword(space, 0xc00f20));
-					memory_write_dword(space, 0xc10f24, memory_read_dword(space, 0xc00f24));
+					space->write_dword(0xc10f20, space->read_dword(0xc00f20));
+					space->write_dword(0xc10f24, space->read_dword(0xc00f24));
 					/* ... */
-					memory_write_dword(space, 0xc0fe00, memory_read_dword(space, 0xc00f30));
-					memory_write_dword(space, 0xc0fe04, memory_read_dword(space, 0xc00f34));
+					space->write_dword(0xc0fe00, space->read_dword(0xc00f30));
+					space->write_dword(0xc0fe04, space->read_dword(0xc00f34));
 				}
 				else if(last_prot_op == 0xd97)	// rushhero
 				{
@@ -1088,7 +1088,7 @@
 					{
 						for (i = 0; i <= 0x10; i += 4)
 						{
-							memory_write_dword(space, dst + i, memory_read_dword(space, src+i));
+							space->write_dword(dst + i, space->read_dword(src+i));
 						}
 
 						src -= 0x10;
@@ -1096,10 +1096,10 @@
 					}
 
 					/* Input buffer copiers, only this command is executed so it's safe to assume that's polled here */
-					memory_write_byte(space, 0xc01cc0, ~memory_read_byte(space, 0xc00507));
-					memory_write_byte(space, 0xc01cc1, ~memory_read_byte(space, 0xc00527));
-					memory_write_byte(space, 0xc01cc4, ~memory_read_byte(space, 0xc00547));
-					memory_write_byte(space, 0xc01cc5, ~memory_read_byte(space, 0xc00567));
+					space->write_byte(0xc01cc0, ~space->read_byte(0xc00507));
+					space->write_byte(0xc01cc1, ~space->read_byte(0xc00527));
+					space->write_byte(0xc01cc4, ~space->read_byte(0xc00547));
+					space->write_byte(0xc01cc5, ~space->read_byte(0xc00567));
 				}
 				else if(last_prot_op == 0xb16) // slamdnk2
 				{
@@ -1109,7 +1109,7 @@
 
 					for (spr = 0; spr < 0x100; spr++)
 					{
-						memory_write_word(space, dst, memory_read_word(space, src));
+						space->write_word(dst, space->read_word(src));
 						src += 4;
 						dst += 2;
 					}
@@ -1121,14 +1121,14 @@
 					int adr;
 					//printf("GXT4: command %x %d (PC=%x)\n", last_prot_op, cc++, cpu_get_pc(space->cpu));
 					for (adr = 0; adr < 0x400; adr += 2)
-						memory_write_word(space, 0xc01c00+adr, memory_read_word(space, 0xc01800+adr));
+						space->write_word(0xc01c00+adr, space->read_word(0xc01800+adr));
 				}
 				else if(last_prot_op == 0x115d) // vsnetscr screen 2
 				{
 					int adr;
 					//printf("GXT4: command %x %d (PC=%x)\n", last_prot_op, cc++, cpu_get_pc(space->cpu));
 					for (adr = 0; adr < 0x400; adr += 2)
-						memory_write_word(space, 0xc18c00+adr, memory_read_word(space, 0xc18800+adr));
+						space->write_word(0xc18c00+adr, space->read_word(0xc18800+adr));
 				}
 				else
 				{
diff -Nru src-old/mame/drivers/konamim2.c src/mame/drivers/konamim2.c
--- src-old/mame/drivers/konamim2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/konamim2.c	2010-08-19 01:27:05.000000000 -0700
@@ -786,7 +786,7 @@
 	}
 }
 
-static void cde_dma_transfer(const address_space *space, int channel, int next)
+static void cde_dma_transfer(address_space *space, int channel, int next)
 {
 	UINT32 address;
 	//int length;
@@ -805,7 +805,7 @@
 
 	for (i=0; i < cde_dma[channel].next_length; i++)
 	{
-		memory_write_byte(space, address, 0xff);		// TODO: do the real transfer...
+		space->write_byte(address, 0xff);		// TODO: do the real transfer...
 		address++;
 	}
 }
diff -Nru src-old/mame/drivers/kyugo.c src/mame/drivers/kyugo.c
--- src-old/mame/drivers/kyugo.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/kyugo.c	2010-08-30 08:20:58.000000000 -0700
@@ -465,7 +465,7 @@
 static MACHINE_RESET( kyugo )
 {
 	kyugo_state *state = machine->driver_data<kyugo_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	// must start with interrupts and sub CPU disabled
 	cpu_interrupt_enable(machine->device("maincpu"), 0);
 	kyugo_sub_cpu_control_w(space, 0, 0);
@@ -1286,6 +1286,51 @@
 	ROM_LOAD( "epl12p6.9j", 0x0200, 0x0034, CRC(dcae870d) SHA1(2224724a3faf0608083f5d6ff76712adc7616a54) )
 ROM_END
 
+ROM_START( legendb )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "06.s02",    0x0000, 0x2000, CRC(227f3e88) SHA1(d31da7fe685f3249af6f42940d22d17399b9582c) )
+	ROM_LOAD( "07.s03",    0x2000, 0x2000, CRC(9352e9dc) SHA1(ad7e0edce658bc6c0069025512ea4a2050a61533) )
+	ROM_LOAD( "08.s04",    0x4000, 0x2000, CRC(41cee2b2) SHA1(166c0581aa83ba67f1912ebed80c1f02bd843ab6) )
+	ROM_LOAD( "05.n03",    0x6000, 0x2000, CRC(d8fd4e37) SHA1(7c9d2d48a57a4d75682e0f910151a5c0e3229413) )
+
+	ROM_REGION( 0x10000, "sub", 0 )
+	ROM_LOAD( "02.s07",    0x0000, 0x2000, CRC(abfe5eb4) SHA1(fbeb5ee14aaebb6321fe97fe523f08833fad9c7c) )
+	ROM_LOAD( "03.s08",    0x2000, 0x2000, CRC(7e7b9ba9) SHA1(897779129108b0f3936234ea797d47cf46cb7a16) )
+	ROM_LOAD( "04.s09",    0x4000, 0x2000, CRC(0dd50aa7) SHA1(001ba0d5e0b50fb030a95fdbeba40005ffc5c182) )
+	ROM_LOAD( "01.n07",    0x6000, 0x2000, CRC(13915a53) SHA1(25ba3babc8eb0df413bdfe7dbcd8642e4c658120) )
+
+	ROM_REGION(  0x1000, "gfx1", 0 )	/* fg tiles */
+	ROM_LOAD( "15.b05",    0x0000, 0x1000, CRC(6c879f76) SHA1(9da84446e463264ed86e912589d826d86c27bf59) )
+
+	ROM_REGION(  0x6000, "gfx2", 0 )	/* bg tiles */
+	ROM_LOAD( "18.j09",   0x0000, 0x2000, CRC(3bdcd028) SHA1(2fb2ecc5333e50834badb4b00093ca8e9a64bce4) )
+	ROM_LOAD( "17.j10",   0x2000, 0x2000, CRC(105c5b53) SHA1(269da6bdef55024e593ea0178597e37ff2fefc10) )
+	ROM_LOAD( "16.j11",   0x4000, 0x2000, CRC(b9ca4efd) SHA1(680c3ca88c65c1643ae82945b937d34579c0efeb) )
+
+	ROM_REGION( 0x18000, "gfx3", 0 )	/* sprites */
+	ROM_LOAD( "14.b06",   0x00000, 0x4000, CRC(1689f21c) SHA1(fafb13dc8ca27a7506065bbf08102afc6d722843) )
+	ROM_LOAD( "13.b07",   0x04000, 0x4000, CRC(f527c909) SHA1(40f44828502018c73283965eb7a2a68ed25ebfe5) )
+	ROM_LOAD( "12.b08",   0x08000, 0x4000, CRC(8d618629) SHA1(3cc49fd8066464ee940de010da3f33ed8573df3d) )
+	ROM_LOAD( "11.b09",   0x0c000, 0x4000, CRC(7d7e2d55) SHA1(efd4817a0f5e14cb5a3d0c1f69e6ad408a813202) )
+	ROM_LOAD( "10.b10",   0x10000, 0x4000, CRC(f12232fe) SHA1(2d8accc10f0703eeb075c4053d4165b90552e6a7) )
+	ROM_LOAD( "09.b11",   0x14000, 0x4000, CRC(8c09243d) SHA1(8f0f68921f8ab6c016b7481714febb68abb7ce79) )
+
+	ROM_REGION( 0x0340, "proms", 0 )
+	ROM_LOAD( "82s129.1j",   0x0000, 0x0100, CRC(40590ac0) SHA1(30a8e24e34c4ee0a7df91c0633becfce1c8d856c) ) /* red */
+	ROM_LOAD( "82s129.1h",   0x0100, 0x0100, CRC(e542b363) SHA1(6775209b9a4aaf374878c06cf4dc693b921abd87) ) /* green */
+	ROM_LOAD( "82s129.1f",   0x0200, 0x0100, CRC(75536fc8) SHA1(e713efafcdc7f2a595444af75d2083eb3e38a480) ) /* blue */
+	ROM_LOAD( "82s123.5j",   0x0300, 0x0020, CRC(c98f0651) SHA1(4f1b95213c28ad017c8d6542e8d522e4d69f91e3) ) /* char lookup table */
+	ROM_LOAD( "m1.2c",       0x0320, 0x0020, CRC(83a39201) SHA1(4fdc722c9e20ee152c890342ef0dce18e35e2ef8) ) /* timing? not used */
+
+	ROM_REGION( 0x0300, "plds", 0 )
+	ROM_LOAD( "epl10p8.2j", 0x0000, 0x002c, CRC(8abc03bf) SHA1(05a7085583f76cb46ec623adfc1e0dd35c6a36e6) )
+	ROM_LOAD( "epl12p6.9k", 0x0100, 0x0034, CRC(9b0bd6f8) SHA1(9dceb37245969537301b1f3c74f2c4ee088faa93) )
+	ROM_LOAD( "epl12p6.9j", 0x0200, 0x0034, CRC(dcae870d) SHA1(2224724a3faf0608083f5d6ff76712adc7616a54) )
+ROM_END
+
+
+
+
 
 /*************************************
  *
@@ -1331,7 +1376,8 @@
 GAME( 1985, flashgala, flashgal, flashgala,flashgal, 0,        ROT0,  "Sega", "Flashgal (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1986, srdmissn,  0,        srdmissn, srdmissn, srdmissn, ROT90, "Taito Corporation", "S.R.D. Mission", GAME_SUPPORTS_SAVE )
 GAME( 1986, fx,        srdmissn, srdmissn, srdmissn, srdmissn, ROT90, "bootleg", "F-X", GAME_SUPPORTS_SAVE )
-GAME( 1986, legend,    0,        legend,   legend,   srdmissn, ROT0,  "Sega / Coreland", "Legend", GAME_SUPPORTS_SAVE )
+GAME( 1986, legend,    0,        legend,   legend,   srdmissn, ROT0,  "Sega / Coreland", "Legend", GAME_SUPPORTS_SAVE ) // no copyright (maybe also a bootleg?)
+GAME( 1986, legendb,   legend,   legend,   legend,   srdmissn, ROT0,  "bootleg", "Legion (bootleg of Legend)", GAME_SUPPORTS_SAVE ) // no copyright
 GAME( 1987, airwolf,   0,        srdmissn, airwolf,  srdmissn, ROT0,  "Kyugo", "Airwolf", GAME_SUPPORTS_SAVE )
 GAME( 1987, airwolfa,  airwolf,  srdmissn, airwolf,  srdmissn, ROT0,  "Kyugo (UA Theatre license)", "Airwolf (US)", GAME_SUPPORTS_SAVE )
 GAME( 1987, skywolf,   airwolf,  srdmissn, skywolf,  srdmissn, ROT0,  "bootleg", "Sky Wolf (set 1)", GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/ladybug.c src/mame/drivers/ladybug.c
--- src-old/mame/drivers/ladybug.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/ladybug.c	2010-08-19 07:19:38.000000000 -0700
@@ -1068,12 +1068,12 @@
 	/* decode the opcodes */
 
 	offs_t i;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x6000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *table = memory_region(machine, "user1");
 
-	memory_set_decrypted_region(space, 0x0000, 0x5fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x5fff, decrypted);
 
 	for (i = 0; i < 0x6000; i++)
 		decrypted[i] = table[rom[i]];
diff -Nru src-old/mame/drivers/laserbat.c src/mame/drivers/laserbat.c
--- src-old/mame/drivers/laserbat.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/laserbat.c	2010-08-12 12:45:01.000000000 -0700
@@ -685,21 +685,24 @@
 {
 	"screen",
 	0x100,
-	0, -19
+	0, -19,
+	NULL
 };
 
 static const s2636_interface s2636_2_config =
 {
 	"screen",
 	0x100,
-	0, -19
+	0, -19,
+	NULL
 };
 
 static const s2636_interface s2636_3_config =
 {
 	"screen",
 	0x100,
-	0, -19
+	0, -19,
+	NULL
 };
 
 static MACHINE_START( laserbat )
diff -Nru src-old/mame/drivers/leland.c src/mame/drivers/leland.c
--- src-old/mame/drivers/leland.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/leland.c	2010-08-21 15:41:02.000000000 -0700
@@ -1597,15 +1597,15 @@
 	ROM_LOAD( "03-28002.u8",   0x70000, 0x10000, CRC(c3e09811) SHA1(9b6e036a53000c9bcb104677d9c71743f02fd841) )
 
 	ROM_REGION( 0x100000, "audiocpu", 0 )
-    ROM_LOAD16_BYTE( "24019-01.u25", 0x040001, 0x10000, CRC(9e344768) SHA1(7f16d29c52f3d7f0046f414185c4d889f6128597) )
-    ROM_LOAD16_BYTE( "24016-01.u13", 0x040000, 0x10000, CRC(6997025f) SHA1(5eda3bcae896933385fe97a4e1396ae2da7576cb) )
-    ROM_LOAD16_BYTE( "24020-01.u26", 0x060001, 0x10000, CRC(0788f2a5) SHA1(75eb1ab00185f8efa71f1d46197b5f6d20d721f2) )
-    ROM_LOAD16_BYTE( "24017-01.u14", 0x060000, 0x10000, CRC(a48bd721) SHA1(e099074165594a7c289a25c522005db7e9554ca1) )
-    ROM_LOAD16_BYTE( "24021-01.u27", 0x0e0001, 0x10000, CRC(94081899) SHA1(289eb2f494d1110d169552e8898296e4a47fcb1d) )
-    ROM_LOAD16_BYTE( "24018-01.u15", 0x0e0000, 0x10000, CRC(76eb6077) SHA1(255731c63f4a846bb01d4203a786eb34a4734e66) )
+	ROM_LOAD16_BYTE( "24019-01.u25", 0x040001, 0x10000, CRC(9e344768) SHA1(7f16d29c52f3d7f0046f414185c4d889f6128597) )
+	ROM_LOAD16_BYTE( "24016-01.u13", 0x040000, 0x10000, CRC(6997025f) SHA1(5eda3bcae896933385fe97a4e1396ae2da7576cb) )
+	ROM_LOAD16_BYTE( "24020-01.u26", 0x060001, 0x10000, CRC(0788f2a5) SHA1(75eb1ab00185f8efa71f1d46197b5f6d20d721f2) )
+	ROM_LOAD16_BYTE( "24017-01.u14", 0x060000, 0x10000, CRC(a48bd721) SHA1(e099074165594a7c289a25c522005db7e9554ca1) )
+	ROM_LOAD16_BYTE( "24021-01.u27", 0x0e0001, 0x10000, CRC(94081899) SHA1(289eb2f494d1110d169552e8898296e4a47fcb1d) )
+	ROM_LOAD16_BYTE( "24018-01.u15", 0x0e0000, 0x10000, CRC(76eb6077) SHA1(255731c63f4a846bb01d4203a786eb34a4734e66) )
 
 	ROM_REGION( 0x0c000, "gfx1", 0 )
-	ROM_LOAD( "03-28008.u93", 0x00000, 0x04000, NO_DUMP )
+	ROM_LOAD( "03-28008.u93", 0x00000, 0x04000, CRC(68f8addc) SHA1(a52c408e2e9022f96fb766065d7266deb0df2e5f) )
 	ROM_LOAD( "03-28009.u94", 0x04000, 0x04000, CRC(669791ac) SHA1(e8b7bdec313ea9d40f89f13499a31f0b125951a8) )
 	ROM_LOAD( "03-28010.u95", 0x08000, 0x04000, CRC(bd62aa8a) SHA1(c8a177a11ec94671bb3bd5883b40692495c049a2) )
 
@@ -1627,7 +1627,7 @@
 ROM_START( aafbb )
 	ROM_REGION( 0x20000, "master", 0 )
 	ROM_LOAD( "24014-02.u58",   0x00000, 0x10000, CRC(5db4a3d0) SHA1(f759ab16de48562db1640bc5df68be188725aecf) )
-	ROM_LOAD( "24015-02.u59",   0x10000, 0x10000, CRC(f384f716) SHA1(e689ec6b76bfdf58a059409850c397d407740dda) )
+	ROM_LOAD( "24015-02.u59",   0x10000, 0x10000, BAD_DUMP CRC(f384f716) SHA1(e689ec6b76bfdf58a059409850c397d407740dda) )
 
 	ROM_REGION( 0x80000, "slave", 0 )
 	ROM_LOAD( "24000-02.u3",   0x00000, 0x02000, CRC(52df0354) SHA1(a39a2538b733e336eac5a1491c42c89fd4f4d1aa) )
@@ -1769,12 +1769,12 @@
 	ROM_LOAD( "22112-01.u8",  0x70000, 0x10000, CRC(3eef38d3) SHA1(9131960592a44c8567ab483f72955d2cc8898445) )
 
 	ROM_REGION( 0x100000, "audiocpu", 0 )
-    ROM_LOAD16_BYTE( "22116-03.u25", 0x040001, 0x10000, CRC(95bb31d3) SHA1(e7bc43b63126fd33663865b2e41bacc58e962628) )
-    ROM_LOAD16_BYTE( "22113-03.u13", 0x040000, 0x10000, CRC(71b28df6) SHA1(caf8e4c98a1650dbaedf83f4d38da920d0976f78) )
-    ROM_LOAD16_BYTE( "22117-03.u26", 0x060001, 0x10000, CRC(703d81ce) SHA1(caf5363fb468a461a260e0ec636b0a7a8dc9cd3d) )
-    ROM_LOAD16_BYTE( "22114-03.u14", 0x060000, 0x10000, CRC(f8b31bf8) SHA1(cb8133effe5484c5b4c40b77769f6ec72441c333) )
-    ROM_LOAD16_BYTE( "22118-03.u27", 0x0e0001, 0x10000, CRC(806ccf8b) SHA1(7335a85fc84d5c2f7537548c3856c9cd2f267609) )
-    ROM_LOAD16_BYTE( "22115-03.u15", 0x0e0000, 0x10000, CRC(c8439a7a) SHA1(9a8bb1fca8d3414dcfd4839bc0c4289e4d810943) )
+	ROM_LOAD16_BYTE( "22116-03.u25", 0x040001, 0x10000, CRC(95bb31d3) SHA1(e7bc43b63126fd33663865b2e41bacc58e962628) )
+	ROM_LOAD16_BYTE( "22113-03.u13", 0x040000, 0x10000, CRC(71b28df6) SHA1(caf8e4c98a1650dbaedf83f4d38da920d0976f78) )
+	ROM_LOAD16_BYTE( "22117-03.u26", 0x060001, 0x10000, CRC(703d81ce) SHA1(caf5363fb468a461a260e0ec636b0a7a8dc9cd3d) )
+	ROM_LOAD16_BYTE( "22114-03.u14", 0x060000, 0x10000, CRC(f8b31bf8) SHA1(cb8133effe5484c5b4c40b77769f6ec72441c333) )
+	ROM_LOAD16_BYTE( "22118-03.u27", 0x0e0001, 0x10000, CRC(806ccf8b) SHA1(7335a85fc84d5c2f7537548c3856c9cd2f267609) )
+	ROM_LOAD16_BYTE( "22115-03.u15", 0x0e0000, 0x10000, CRC(c8439a7a) SHA1(9a8bb1fca8d3414dcfd4839bc0c4289e4d810943) )
 
 	ROM_REGION( 0x18000, "gfx1", 0 )
 	ROM_LOAD( "22105-01.u93", 0x00000, 0x08000, CRC(4426e367) SHA1(298203112d724feb9a75a7bfc34b3dbb4d7fffe7) )
@@ -2321,7 +2321,7 @@
 GAME( 1989, aafb,     0,       lelandi,  teamqb,   aafb,     ROT270, "Leland Corp.", "All American Football (rev E)", 0 )
 GAME( 1989, aafbd2p,  aafb,    lelandi,  aafb2p,   aafbd2p,  ROT270, "Leland Corp.", "All American Football (rev D, 2 Players)", 0 )
 GAME( 1989, aafbc,    aafb,    lelandi,  teamqb,   aafbb,    ROT270, "Leland Corp.", "All American Football (rev C)", 0 )
-GAME( 1989, aafbb,    aafb,    lelandi,  teamqb,   aafbb,    ROT270, "Leland Corp.", "All American Football (rev B)", 0 )
+GAME( 1989, aafbb,    aafb,    lelandi,  teamqb,   aafbb,    ROT270, "Leland Corp.", "All American Football (rev B)", GAME_NOT_WORKING )
 
 /* huge master banks, large slave banks, 80186 sound */
 GAME( 1989, offroad,    0,       lelandi,  offroad,    offroad,  ROT0,   "Leland Corp.", "Ironman Ivan Stewart's Super Off-Road", 0 )
diff -Nru src-old/mame/drivers/lethal.c src/mame/drivers/lethal.c
--- src-old/mame/drivers/lethal.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/lethal.c	2010-08-29 15:55:27.000000000 -0700
@@ -158,8 +158,6 @@
 
 'external' rowscroll not hooked up correctly (1st attract level, highscores)
 
-can't find the flip bits used for the tiles.. (p2 start screen, reload indicator)
-
 maybe some priority issues / sprite placement issues..
 
 ***************************************************************************/
@@ -275,6 +273,15 @@
 				case 0x44:
 				case 0x45:
 				case 0x46:
+				case 0x47:
+				case 0x48:
+				case 0x49:
+				case 0x4a:
+				case 0x4b:
+				case 0x4c:
+				case 0x4d:
+				case 0x4e:
+				case 0x4f:
 					return k053244_r(state->k053244, offset - 0x40);
 
 				case 0x80:
@@ -359,6 +366,15 @@
 				case 0x44:
 				case 0x45:
 				case 0x46:
+				case 0x47:
+				case 0x48:
+				case 0x49:
+				case 0x4a:
+				case 0x4b:
+				case 0x4c:
+				case 0x4d:
+				case 0x4e:
+				case 0x4f:
 					k053244_w(state->k053244, offset - 0x40, data);
 					break;
 
diff -Nru src-old/mame/drivers/liberate.c src/mame/drivers/liberate.c
--- src-old/mame/drivers/liberate.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/liberate.c	2010-08-19 07:19:38.000000000 -0700
@@ -1364,7 +1364,7 @@
 
 static void sound_cpu_decrypt(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x4000);
 	UINT8 *rom = memory_region(machine, "audiocpu");
 	int i;
@@ -1373,7 +1373,7 @@
 	for (i = 0xc000; i < 0x10000; i++)
 		decrypted[i - 0xc000] = ((rom[i] & 0x20) << 1) | ((rom[i] & 0x40) >> 1) | (rom[i] & 0x9f);
 
-	memory_set_decrypted_region(space, 0xc000, 0xffff, decrypted);
+	space->set_decrypted_region(0xc000, 0xffff, decrypted);
 }
 
 static DRIVER_INIT( prosport )
@@ -1398,11 +1398,11 @@
 static DRIVER_INIT( liberate )
 {
 	int A;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 	UINT8 *ROM = memory_region(machine, "maincpu");
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypted);
+	space->set_decrypted_region(0x0000, 0xffff, decrypted);
 
 	/* Swap bits for opcodes only, not data */
 	for (A = 0; A < 0x10000; A++) {
diff -Nru src-old/mame/drivers/littlerb.c src/mame/drivers/littlerb.c
--- src-old/mame/drivers/littlerb.c	2010-07-06 10:30:28.000000000 -0700
+++ src/mame/drivers/littlerb.c	2010-08-19 01:27:05.000000000 -0700
@@ -213,10 +213,10 @@
 static void littlerb_data_write(running_machine *machine, UINT16 data, UINT16 mem_mask)
 {
 	UINT32 addr = littlerb_write_address>>4; // is this right? should we shift?
-	const address_space *vdp_space = machine->device<littlerb_vdp_device>("littlerbvdp")->space();
+	address_space *vdp_space = machine->device<littlerb_vdp_device>("littlerbvdp")->space();
 
 
-	memory_write_word_masked(vdp_space, addr*2, data, mem_mask);
+	vdp_space->write_word(addr*2, data, mem_mask);
 
 
 	// e000 / 2000 are used for palette writes, which should go to a RAMDAC, so probably mean no auto inc.
diff -Nru src-old/mame/drivers/lockon.c src/mame/drivers/lockon.c
--- src-old/mame/drivers/lockon.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/lockon.c	2010-08-19 01:27:05.000000000 -0700
@@ -65,37 +65,37 @@
 static READ16_HANDLER( main_gnd_r )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
-	return memory_read_word(gndspace, V30_GND_ADDR | offset * 2);
+	address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
+	return gndspace->read_word(V30_GND_ADDR | offset * 2);
 }
 
 static WRITE16_HANDLER( main_gnd_w )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
+	address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
 
 	if (ACCESSING_BITS_0_7)
-		memory_write_byte(gndspace, V30_GND_ADDR | (offset * 2 + 0), data);
+		gndspace->write_byte(V30_GND_ADDR | (offset * 2 + 0), data);
 	if (ACCESSING_BITS_8_15)
-		memory_write_byte(gndspace, V30_GND_ADDR | (offset * 2 + 1), data >> 8);
+		gndspace->write_byte(V30_GND_ADDR | (offset * 2 + 1), data >> 8);
 }
 
 static READ16_HANDLER( main_obj_r )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
-	return memory_read_word(objspace, V30_OBJ_ADDR | offset * 2);
+	address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
+	return objspace->read_word(V30_OBJ_ADDR | offset * 2);
 }
 
 static WRITE16_HANDLER( main_obj_w )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
+	address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
 
 	if (ACCESSING_BITS_0_7)
-		memory_write_byte(objspace, V30_OBJ_ADDR | (offset * 2 + 0), data);
+		objspace->write_byte(V30_OBJ_ADDR | (offset * 2 + 0), data);
 	if (ACCESSING_BITS_8_15)
-		memory_write_byte(objspace, V30_OBJ_ADDR | (offset * 2 + 1), data >> 8);
+		objspace->write_byte(V30_OBJ_ADDR | (offset * 2 + 1), data >> 8);
 }
 
 static WRITE16_HANDLER( tst_w )
@@ -104,33 +104,33 @@
 
 	if (offset < 0x800)
 	{
-		const address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
-		const address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
+		address_space *gndspace = cpu_get_address_space(state->ground, ADDRESS_SPACE_PROGRAM);
+		address_space *objspace = cpu_get_address_space(state->object, ADDRESS_SPACE_PROGRAM);
 
 		if (ACCESSING_BITS_0_7)
-			memory_write_byte(gndspace, V30_GND_ADDR | (offset * 2 + 0), data);
+			gndspace->write_byte(V30_GND_ADDR | (offset * 2 + 0), data);
 		if (ACCESSING_BITS_8_15)
-			memory_write_byte(gndspace, V30_GND_ADDR | (offset * 2 + 1), data >> 8);
+			gndspace->write_byte(V30_GND_ADDR | (offset * 2 + 1), data >> 8);
 
 		if (ACCESSING_BITS_0_7)
-			memory_write_byte(objspace, V30_OBJ_ADDR | (offset * 2 + 0), data);
+			objspace->write_byte(V30_OBJ_ADDR | (offset * 2 + 0), data);
 		if (ACCESSING_BITS_8_15)
-			memory_write_byte(objspace, V30_OBJ_ADDR | (offset * 2 + 1), data >> 8);
+			objspace->write_byte(V30_OBJ_ADDR | (offset * 2 + 1), data >> 8);
 	}
 }
 
 static READ16_HANDLER( main_z80_r )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *sndspace = cpu_get_address_space(state->audiocpu, ADDRESS_SPACE_PROGRAM);
-	return 0xff00 | memory_read_byte(sndspace, offset);
+	address_space *sndspace = cpu_get_address_space(state->audiocpu, ADDRESS_SPACE_PROGRAM);
+	return 0xff00 | sndspace->read_byte(offset);
 }
 
 static WRITE16_HANDLER( main_z80_w )
 {
 	lockon_state *state = space->machine->driver_data<lockon_state>();
-	const address_space *sndspace = cpu_get_address_space(state->audiocpu, ADDRESS_SPACE_PROGRAM);
-	memory_write_byte(sndspace, offset, data);
+	address_space *sndspace = cpu_get_address_space(state->audiocpu, ADDRESS_SPACE_PROGRAM);
+	sndspace->write_byte(offset, data);
 }
 
 static WRITE16_HANDLER( inten_w )
diff -Nru src-old/mame/drivers/m10.c src/mame/drivers/m10.c
--- src-old/mame/drivers/m10.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/m10.c	2010-08-23 03:03:39.000000000 -0700
@@ -145,7 +145,7 @@
 	ttl74123_a_w(state->ic8j1, 0, data);
 }
 
-static const ttl74123_config ic8j1_intf =
+static const ttl74123_interface ic8j1_intf =
 {
 	/* completely illegible */
 	TTL74123_NOT_GROUNDED_DIODE,	/* the hook up type */
@@ -157,7 +157,7 @@
 	ic8j1_output_changed
 };
 
-static const ttl74123_config ic8j2_intf =
+static const ttl74123_interface ic8j2_intf =
 {
 	TTL74123_NOT_GROUNDED_DIODE,	/* the hook up type */
 	/* 10k + 20k variable resistor */
diff -Nru src-old/mame/drivers/m72.c src/mame/drivers/m72.c
--- src-old/mame/drivers/m72.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/m72.c	2010-08-19 00:26:14.000000000 -0700
@@ -319,9 +319,9 @@
 
 INLINE DRIVER_INIT( m72_8751 )
 {
-	const address_space *program = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
-	const address_space *sndio = cputag_get_address_space(machine, "soundcpu", ADDRESS_SPACE_IO);
+	address_space *program = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *sndio = cputag_get_address_space(machine, "soundcpu", ADDRESS_SPACE_IO);
 	running_device *dac = machine->device("dac");
 
 	protection_ram = auto_alloc_array(machine, UINT16, 0x10000/2);
@@ -403,7 +403,7 @@
 
 static INTERRUPT_GEN(fake_nmi)
 {
-	const address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
 	int sample = m72_sample_r(space,0);
 	if (sample)
 		m72_sample_w(device->machine->device("dac"),0,sample);
diff -Nru src-old/mame/drivers/magictg.c src/mame/drivers/magictg.c
--- src-old/mame/drivers/magictg.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/magictg.c	2010-08-26 09:31:58.000000000 -0700
@@ -125,7 +125,7 @@
 }
 
 /* ?? */
-static const mips3_config config =
+static const mips3_config r4600_config =
 {
 	16384,				/* code cache size */
 	16384				/* data cache size */
@@ -142,7 +142,7 @@
 static MACHINE_DRIVER_START( magictg )
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R4600BE, 10000000)  // ?? what cpu?
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r4600_config)
 	MDRV_CPU_PROGRAM_MAP(magictg_map)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/mainsnk.c src/mame/drivers/mainsnk.c
--- src-old/mame/drivers/mainsnk.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/mainsnk.c	2010-08-26 20:55:49.000000000 -0700
@@ -111,21 +111,13 @@
 #include "cpu/z80/z80.h"
 #include "includes/snk.h"
 #include "sound/ay8910.h"
-
-extern UINT8 *mainsnk_fgram;
-extern UINT8 *mainsnk_bgram;
-WRITE8_HANDLER(mainsnk_c600_w);
-WRITE8_HANDLER(mainsnk_fgram_w);
-WRITE8_HANDLER(mainsnk_bgram_w);
-VIDEO_START(mainsnk);
-VIDEO_UPDATE(mainsnk);
-
-static int sound_cpu_busy;
-
+#include "includes/mainsnk.h"
 
 static WRITE8_HANDLER( sound_command_w )
 {
-	sound_cpu_busy = 1;
+	mainsnk_state *state = space->machine->driver_data<mainsnk_state>();
+
+	state->sound_cpu_busy = 1;
 	soundlatch_w(space, 0, data);
 	cputag_set_input_line(space->machine, "audiocpu", INPUT_LINE_NMI, PULSE_LINE);
 }
@@ -137,13 +129,17 @@
 
 static READ8_HANDLER( sound_ack_r )
 {
-	sound_cpu_busy = 0;
+	mainsnk_state *state = space->machine->driver_data<mainsnk_state>();
+
+	state->sound_cpu_busy = 0;
 	return 0xff;
 }
 
 static CUSTOM_INPUT( mainsnk_sound_r )
 {
-	return (sound_cpu_busy) ? 0x01 : 0x00;
+	mainsnk_state *state = field->port->machine->driver_data<mainsnk_state>();
+
+	return (state->sound_cpu_busy) ? 0x01 : 0x00;
 }
 
 
@@ -158,10 +154,10 @@
 	AM_RANGE(0xc500, 0xc500) AM_READ_PORT("DSW2")
 	AM_RANGE(0xc600, 0xc600) AM_WRITE(mainsnk_c600_w)
 	AM_RANGE(0xc700, 0xc700) AM_WRITE(sound_command_w)
-	AM_RANGE(0xd800, 0xdbff) AM_RAM_WRITE(mainsnk_bgram_w) AM_BASE(&mainsnk_bgram)
+	AM_RANGE(0xd800, 0xdbff) AM_RAM_WRITE(mainsnk_bgram_w) AM_BASE_MEMBER(mainsnk_state, bgram)
 	AM_RANGE(0xdc00, 0xe7ff) AM_RAM
-	AM_RANGE(0xe800, 0xefff) AM_RAM AM_BASE_GENERIC(spriteram)
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(mainsnk_fgram_w) AM_BASE(&mainsnk_fgram)	// + work RAM
+	AM_RANGE(0xe800, 0xefff) AM_RAM AM_BASE_MEMBER(mainsnk_state, spriteram)
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(mainsnk_fgram_w) AM_BASE_MEMBER(mainsnk_state, fgram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( sound_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -395,6 +391,9 @@
 
 
 static MACHINE_DRIVER_START( mainsnk )
+
+	MDRV_DRIVER_DATA( mainsnk_state )
+
 	MDRV_CPU_ADD("maincpu", Z80, 3360000)
 	MDRV_CPU_PROGRAM_MAP(main_map)
 	MDRV_CPU_VBLANK_INT("screen", irq0_line_hold)
diff -Nru src-old/mame/drivers/malzak.c src/mame/drivers/malzak.c
--- src-old/mame/drivers/malzak.c	2010-08-05 02:44:25.000000000 -0700
+++ src/mame/drivers/malzak.c	2010-08-12 12:45:01.000000000 -0700
@@ -65,6 +65,7 @@
 #include "emu.h"
 #include "cpu/s2650/s2650.h"
 #include "sound/sn76477.h"
+#include "sound/s2636.h"
 #include "video/s2636.h"
 #include "video/saa5050.h"
 #include "includes/malzak.h"
@@ -347,14 +348,16 @@
 {
 	"screen",
 	0x100,
-	0, -16	/* -8, -16 */
+	0, -16,	/* -8, -16 */
+	"s2636snd_0"
 };
 
 static const s2636_interface malzac_s2636_1_config =
 {
 	"screen",
 	0x100,
-	0, -16	/* -9, -16 */
+	0, -16,	/* -9, -16 */
+	"s2636snd_1"
 };
 
 static const saa5050_interface malzac_saa5050_intf =
@@ -432,6 +435,12 @@
 	MDRV_SOUND_ADD("sn2", SN76477, 0)
 	MDRV_SOUND_CONFIG(sn76477_intf)
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+
+	MDRV_SOUND_ADD("s2636snd_0", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
+
+	MDRV_SOUND_ADD("s2636snd_1", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_DRIVER_END
 
 static MACHINE_DRIVER_START( malzak2 )
@@ -489,5 +498,5 @@
 ROM_END
 
 
-GAME( 19??, malzak,   0,       malzak,  malzak,  0,        ROT0, "Kitronix", "Malzak", GAME_NOT_WORKING | GAME_NO_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
-GAME( 19??, malzak2, malzak,   malzak2, malzak2, 0,        ROT0, "Kitronix", "Malzak II", GAME_NOT_WORKING | GAME_NO_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 19??, malzak,   0,       malzak,  malzak,  0,        ROT0, "Kitronix", "Malzak", GAME_NOT_WORKING | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 19??, malzak2, malzak,   malzak2, malzak2, 0,        ROT0, "Kitronix", "Malzak II", GAME_NOT_WORKING | GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/mappy.c src/mame/drivers/mappy.c
--- src-old/mame/drivers/mappy.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/mappy.c	2010-08-19 00:26:14.000000000 -0700
@@ -717,7 +717,7 @@
 
 static MACHINE_RESET( superpac )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Reset all latches */
@@ -727,7 +727,7 @@
 
 static MACHINE_RESET( phozon )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Reset all latches */
@@ -737,7 +737,7 @@
 
 static MACHINE_RESET( mappy )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Reset all latches */
diff -Nru src-old/mame/drivers/mario.c src/mame/drivers/mario.c
--- src-old/mame/drivers/mario.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/mario.c	2010-08-19 01:27:05.000000000 -0700
@@ -101,6 +101,9 @@
  *
  *************************************/
 
+static UINT8 memory_read_byte(address_space *space, offs_t address) { return space->read_byte(address); }
+static void memory_write_byte(address_space *space, offs_t address, UINT8 data) { space->write_byte(address, data); }
+
 static Z80DMA_INTERFACE( mario_dma )
 {
 	DEVCB_CPU_INPUT_LINE("maincpu", INPUT_LINE_HALT),
diff -Nru src-old/mame/drivers/mediagx.c src/mame/drivers/mediagx.c
--- src-old/mame/drivers/mediagx.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/mediagx.c	2010-08-19 01:27:05.000000000 -0700
@@ -846,7 +846,7 @@
 	offs_t page_offset = (((offs_t) state->dma_offset[0][state->dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -856,7 +856,7 @@
 	offs_t page_offset = (((offs_t) state->dma_offset[0][state->dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static void set_dma_channel(running_device *device, int channel, int _state)
@@ -1206,7 +1206,7 @@
 
 #if SPEEDUP_HACKS
 
-INLINE UINT32 generic_speedup(const address_space *space, int idx)
+INLINE UINT32 generic_speedup(address_space *space, int idx)
 {
 	mediagx_state *state = space->machine->driver_data<mediagx_state>();
 
diff -Nru src-old/mame/drivers/megadriv.c src/mame/drivers/megadriv.c
--- src-old/mame/drivers/megadriv.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/megadriv.c	2010-08-19 01:27:05.000000000 -0700
@@ -174,7 +174,7 @@
 #ifdef UNUSED_FUNCTION
 /* taken from segaic16.c */
 /* doesn't seem to meet my needs, not used */
-static UINT16 read_next_instruction(const address_space *space)
+static UINT16 read_next_instruction(address_space *space)
 {
 	static UINT8 recurse = 0;
 	UINT16 result;
@@ -193,7 +193,7 @@
 
 	/* read original encrypted memory at that address */
 	recurse = 1;
-	result = memory_read_word(space, cpu_get_pc(space->cpu));
+	result = space->read_word(cpu_get_pc(space->cpu));
 	recurse = 0;
 	return result;
 }
@@ -3545,7 +3545,7 @@
 	if (d & 0x000f) { *dst &= ~0x000f; *dst |= d & 0x000f; }
 }
 
-static UINT32 pm_io(const address_space *space, int reg, int write, UINT32 d)
+static UINT32 pm_io(address_space *space, int reg, int write, UINT32 d)
 {
 	if (svp.emu_status & SSP_PMC_SET)
 	{
diff -Nru src-old/mame/drivers/megadrvb.c src/mame/drivers/megadrvb.c
--- src-old/mame/drivers/megadrvb.c	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/drivers/megadrvb.c	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,505 @@
+/***************************************************************************
+
+    Sega Mega Drive/Genesis-based bootlegs
+
+    Games supported:
+        * Aladdin
+        * Mortal Kombat 3
+        * Super Street Fighter II - The New Challengers
+        * Top Shooter
+
+
+Aladdin PCB info
+================
+
+CPU
+Main CPU 68000P10
+Work RAM 64kB (62256 x2)
+Sound CPU Z80B
+Sound RAM 8kB (76c88-6264 x1)
+Sound IC YM2612 (identified by pins,code was been erased.Named on board as TA07)
+
+Other ICs
+Microchip PIC16C57 (probably it contains the MD modified bios)
+Osc 50 MHz
+There are present 3 flat-pack chips with code erased again and named TA04,TA05,TA06 on board,which i have
+identified (generically) by looking the PCB as:
+TA04-Intercommunication and sync generator chip
+TA05-Input controller
+TA06-VDP (probably MD clone) Uses 2x D41264 SIL package as video RAM
+
+ROMs
+
+M3,M4 main program
+M1,M2 graphics
+All EPROMs are 27C040
+
+Notes:
+
+Dip-switch 8 x1
+
+------------------------
+
+This ROMset comes from a bootleg PCB.The game is a coin-op conversion of the one developed for the Megadrive
+console.I cannot know gameplay differences since PCB is faulty.
+
+However,hardware is totally different.It seems to be based on Sega Mega Drive hardware with CPU clock increased,
+and since exists an "unlicensed" porting of the game for this system probably the "producers" are the same.
+
+
+Stephh's notes (based on the game M68000 code and some tests) :
+
+1) Useful addresses
+
+  - 0xffff88.b = number of credits (range 0x00-0xff but display limited to 9)
+  - 0xff7e3c.b = lives (range 0x30-0x39)
+  - 0xffeffa.b = energy (range 0x00-0x08)
+  - 0xffefe0.w = apples (range 0x30-0x39 * 2 , MSB first)
+  - 0xffefe2.w = jewels (range 0x30-0x39 * 2 , MSB first)
+  - 0xff7e29.b to 0xff7e2e.b = score (range 0x30-0x39 * 6) - MSDigit first
+  - 0xff7e12.b to 0xff7e15.b = ??? (range 0x30-0x33 * 3 + 0x00) - MSDigit first - see below
+  - 0xff7e16.b to 0xff7e19.b = ??? (range 0x30-0x33 * 3 + 0x00) - MSDigit first - see below
+  - 0xff7e21.b = difficulty (range 0x00-0x02) - see below
+
+2) Adresses notes
+
+  - I can't tell what adresses 0xff7r12.l and 0xff7e16.l are supposed to be designed for :
+    they are written once at the begining of each level (code at 0x1a9030) but I haven't found
+    when they were read back (I've only played the 2 first levels though as well as the bonus level,
+    but I also watched all demo levels till the end after the games full credits).
+    I guess they were originally designed for bonus lives (additional and first), but no evidence.
+  - 0xff7e21.b affects contents of 0xff7e3c.b, 0xffefe0.w, 0xff7e12.l and 0xff7e16.l :
+
+                         Easy             Normal             Hard
+                    0xff7e21.b=0x00   0xff7e21.b=0x01   0xff7e21.b=0x02
+      0xff7e3c.b      0x32              0x31              0x30
+      0xffefe0.w      0x3035            0x3032            0x3030
+      0xff7e12.l      0x30313000        0x30313200        0x30313400
+      0xff7e16.l      0x30303900        0x30313200        0x30313500
+
+3) MCU notes
+
+  - As I don't know how it is on real hardware, MCU simulation is more a guess than anything;
+    anyway, the game now runs correctly (coins are handled and settings change)
+  - Difficulty Dip Switches are correct (see code at 0x1b2680)
+  - Coinage Dip Switches might be wrong because I don't know what the possible values can be,
+    but setting them the way I did isn't that bad (see code at 0x1b2a50)
+  - It's possible that writes to 0x220000 are in fact a mask for what is read back from 0x330000,
+    but I haven't found any formula (thus the "lame" read/write handlers you may investigate)
+
+4) Controls notes
+
+  - This game is a one player only game (same as the MegaDrive version);
+    that's why I've "blanked" player 2 inputs which are never read.
+  - I've labelled the buttons the same way as in 'g_aladj' with default options.
+
+5) MegaDrive comparaison ('g_aladj' in HazeMD)
+
+  - There is no "OPTIONS" menu as the difficulty is handled via the MCU / Dip Switches.
+    Some code has been patched but most is still there (see the texts in the ROM ares);
+    Unfortunately, there seems to be no way to access them (no "service" button).
+  - Even with the same settings (same value for 0xff7e21.b), lives and apples,
+    as well as contents of 0xff7e12.l and 0xff7e16.l are really different) !
+    Here is the same data as above for 'g_aladj' :
+
+                         Easy             Normal             Hard
+                    0xff7e21.b=0x00   0xff7e21.b=0x01   0xff7e21.b=0x02
+      0xff7e3c.b      0x35              0x33              0x32
+      0xffefe0.w      0x3135            0x3130            0x3035
+      0xff7e12.l      0x30303600        0x30303800        0x30313000
+      0xff7e16.l      0x30303300        0x30303600        0x30303900
+
+    But what makes the arcade version much harder is how energy is handled : in 'g_aladj', you can
+    be hit 8 times before you lose a life, while in 'aladbl', you lose a life as soon as you are hit !
+    This is done via code change at 0x1aee3c and patched code at 0x1afc00 :
+
+      diff aladbl.asm g_aladj.asm
+
+      < 1AEE3C: 4EB9 001A FC00             jsr     $1afc00.l
+      > 1AEE3C: 5339 00FF EFFA             subq.b  #1, $ffeffa.l
+
+      < 1AFC00: 0C39 0001 00FF F57C        cmpi.b  #$1, $fff57c.l
+      < 1AFC08: 6700 000A                  beq     $1afc14
+      < 1AFC0C: 4239 00FF EFFA             clr.b   $ffeffa.l
+      < 1AFC12: 4E75                       rts
+      < 1AFC14: 5339 00FF EFFA             subq.b  #1, $ffeffa.l
+      < 1AFC1A: 4E75                       rts
+
+    Surprisingly, when you are in "demo mode", player can be again be hit 8 times
+    before losing a life (this is the purpose of the 0xfff57c "flag") !
+
+****************************************************************************
+
+Top Shooter PCB info
+====================
+
+ Sun Mixing board, looks like a hacked up Genesis clone.
+
+ Original driver by David Haywood
+ Inputs by Mariusz Wojcieszek
+
+ Top Shooter - (c)1995  - older board, look more like an actual hacked cart system, has an MCU
+
+ Not Dumped
+
+ Super Bubble Bobble (a bubble bobble rip-off from Sun Mixing, looks like it may be on this hardware)
+
+TOP SHOOTER - Sun Mixing Co. Ltd. 1995
+
+To me it seems like an original cartridge-based arcade board
+hacked to use an external ROM board and a standard JAMMA
+connector, but of course, I can be wrong.
+
+
+   UPPER BOARD
+
+   _________________________________________________________
+   |            ___________  ___________  _____      __    |
+   | 74LS245P  |U14 Empty | |U12 ROM1  |  |IC1|      |B|   |
+   | 74LS245P  |__________| |__________|  |___|            |
+   | 74LS245P   ___________  ___________    _____________  |
+ __|           |U13 Empty | |U11 ROM2  |   | AT89C51    |  |
+ |_ J          |__________| |__________|   |____________|  |_
+ |_ A           ______________________              _____  |_ J
+ |_ M          | U10 MC68000P10       |             |OSC|  |_ P
+ |_ M          | Motorola             |                    |_ 2
+ |_ A          |______________________|            74HC00P |_
+ |_  74LS245P   ______________________           ________  |
+ |_            | U9 Empty             |          |HM6116L  |
+ |_            |                      |          |_______| |_ J
+ |_            |______________________|                    |_ P
+ |_  74LS245P                           TD62oo3AP 74LS373P |_ 3
+ |_                                            __________  |
+ |_  74LS245P                                  |GALv20V8B| |
+ |_                                    ______              |
+ |_               _____                |DIPS|              |_ P
+   |             |U24  |                                   |_ 1
+   | 74LS245P                                              |
+   | TD62oo3AP                                             |
+   |                                                       |
+   |_            97              ____________         _____|
+     |_|_|_|_|_|_|_|_|_|_|_|_|_|_|           |_|_|_|_|
+
+
+  IC1 = Surface scracthed out, don't know what is it
+  U24 = Surface scratched out, seems like a PROM
+ DIPs = Fixed as: 00001000
+ ROMs = Toshiba TC574000AD
+
+  JP2, JP3 and P1 connects both boards, also another
+  on-board connector is used, see notes for the 68K socket
+  for the lower board.
+
+
+   LOWER BOARD
+
+   _________________________________________________________
+   |                                     ____ ____         |
+   |  ___                                | I| | I|         |
+   |  |I|                                | C| | C|         |
+   |  |C|                                | 3| | 2|         |
+   |  |1|                                |__| |__|         |
+   |  |3|                                                  |__
+   |   _                _________________________           __|
+   |  |_|               |||||||||||||||||||||||||           __|
+   |  IC14              ---------- SLOT ---------           __|
+   |               ______________________                   __|
+   |              |                      |                  __|
+   |  ___         | 68K (to upper board) |   _______        __|
+   |  |I|         |______________________|   |SE-94|        __|
+   |  |C|                                    |JDDB |      _|
+   |  |1|           _______                  |_____|      |
+   |  |2|           |SE-93|                    IC4        |
+   |                |JDDA |                               |
+   |                |_____|                ___________    |_
+   |                  IC8                  |Z8400A PS|     |
+   |                                       |_________|     |
+   |                  ______         _________  _________  |
+   |                  | OSC|         | IC11  |  | IC7   |  |
+   |            _____________        |_______|  |_______|  |
+   |    RST    |            |           CN5        CN6     |
+   |___________|            |______________________________|
+
+
+   IC3 = IC2 = Winbond W24257V
+   IC7  = 6264LD 9440
+   IC11 = SE-95 JDDC
+   IC12 = Sony CXA1634P
+   IC13 = Sony CXA1145P
+   IC14 = GL358 N16
+
+   RST is a reset button.
+
+   OSC = 53.693175 MHz
+
+   CN5 and CN6 are 9-pin connectors... serial ports?
+
+   There are two wires soldered directly to two connectors
+   of the slot, going to the upper board (via P1).
+
+   The whole upper board is plugged using the 68000 socket,
+   there is no 68K on the lower board.
+
+   There is an edge connector, but it isn't JAMMA.
+
+   "HK-986 (KINYO)" is written on the PCB, near the slot.
+
+****************************************************************************/
+
+#include "emu.h"
+#include "includes/megadriv.h"
+
+
+/*************************************
+ *
+ *  Games memory handlers
+ *
+ *************************************/
+
+static WRITE16_HANDLER( aladbl_w )
+{
+    /*
+    Values returned from the log file :
+      - aladbl_w : 1b2a6c - data = 6600 (each time a coin is inserted)
+      - aladbl_w : 1b2a82 - data = 0000 (each time a coin is inserted)
+      - aladbl_w : 1b2d18 - data = aa00 (only once on reset)
+      - aladbl_w : 1b2d42 - data = 0000 (only once on reset)
+    */
+	logerror("aladbl_w : %06x - data = %04x\n",cpu_get_pc(space->cpu),data);
+}
+
+static READ16_HANDLER( aladbl_r )
+{
+	if (cpu_get_pc(space->cpu)==0x1b2a56)
+	{
+		static UINT16 mcu_port;
+
+		mcu_port = input_port_read(space->machine, "MCU");
+
+		if(mcu_port & 0x100)
+			return ((mcu_port & 0x0f) | 0x100); // coin inserted, calculate the number of coins
+		else
+			return (0x100); //MCU status, needed if you fall into a pitfall
+	}
+	if (cpu_get_pc(space->cpu)==0x1b2a72) return 0x0000;
+	if (cpu_get_pc(space->cpu)==0x1b2d24) return (input_port_read(space->machine, "MCU") & 0x00f0) | 0x1200;    // difficulty
+	if (cpu_get_pc(space->cpu)==0x1b2d4e) return 0x0000;
+
+	logerror("aladbl_r : %06x\n",cpu_get_pc(space->cpu));
+
+	return 0x0000;
+}
+
+
+static READ16_HANDLER( mk3ghw_dsw_r )
+{
+	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
+	return input_port_read(space->machine, dswname[offset]);
+}
+
+static READ16_HANDLER( ssf2ghw_dsw_r )
+{
+	static const char *const dswname[3] = { "DSWA", "DSWB", "DSWC" };
+	return input_port_read(space->machine, dswname[offset]);
+}
+
+static READ16_HANDLER(topshoot_200051_r)
+{
+	return -0x5b;
+}
+
+/*************************************
+ *
+ *  Game-specific port definitions
+ *
+ *************************************/
+
+static INPUT_PORTS_START( topshoot ) /* Top Shooter Input Ports */
+
+	PORT_START("IN0")
+	PORT_BIT( 0x4f, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Bet") PORT_IMPULSE(1)
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Start") PORT_IMPULSE(1)
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("Fire") PORT_IMPULSE(1)
+
+	PORT_START("IN1")
+	PORT_BIT( 0xe7, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_SERVICE_NO_TOGGLE( 0x08, IP_ACTIVE_LOW )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("Test mode down") PORT_IMPULSE(1)
+
+	PORT_START("IN2")
+	PORT_BIT( 0xfd, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
+
+	PORT_START("IN3")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(1)
+	PORT_BIT( 0xfe, IP_ACTIVE_LOW, IPT_UNKNOWN )
+INPUT_PORTS_END
+
+/*************************************
+ *
+ *  ROM definition(s)
+ *
+ *************************************/
+
+ROM_START( aladbl )
+	ROM_REGION( 0x400000, "maincpu", 0 ) /* 68000 Code */
+	ROM_LOAD16_BYTE( "m1.bin", 0x000001, 0x080000,  CRC(5e2671e4) SHA1(54705c7614fc7b5a1065478fa41f51dd1d8045b7) )
+	ROM_LOAD16_BYTE( "m2.bin", 0x000000, 0x080000,  CRC(142a0366) SHA1(6c94aa9936cd11ccda503b52019a6721e64a32f0) )
+	ROM_LOAD16_BYTE( "m3.bin", 0x100001, 0x080000,  CRC(0feeeb19) SHA1(bd567a33077ab9997871d21736066140d50e3d70) )
+	ROM_LOAD16_BYTE( "m4.bin", 0x100000, 0x080000,  CRC(bc712661) SHA1(dfd554d000399e17b4ddc69761e572195ed4e1f0))
+ROM_END
+
+ROM_START( mk3ghw ) // roms are scrambled, we take care of the address descramble in the ROM load, and the data descramble in the init
+                    // this is bootlegged from  "Mortal Kombat 3 (4) [!].bin"
+	ROM_REGION( 0x400000, "maincpu", ROMREGION_ERASE00 ) /* 68000 Code */
+	ROM_LOAD16_BYTE( "1.u1", 0x080001, 0x020000,  CRC(0dc01b23) SHA1(f1aa7ac88c8e3deb5a0a065862722e9d27b87b4c) )
+	ROM_CONTINUE(            0x000001, 0x020000)
+	ROM_CONTINUE(            0x0c0001, 0x020000)
+	ROM_CONTINUE(            0x040001, 0x020000)
+	ROM_LOAD16_BYTE( "2.u3", 0x180001, 0x040000,  CRC(50250235) SHA1(9f9e06f26163b92c76397fde43b38b3536bcb637) )
+	ROM_CONTINUE(            0x100001, 0x040000)
+	ROM_LOAD16_BYTE( "3.u9", 0x280001, 0x040000,  CRC(493404c1) SHA1(73f4bd1eeeee3f175f4378ab406a97f94f88880b) )
+	ROM_CONTINUE(            0x200001, 0x040000)
+	ROM_LOAD16_BYTE( "4.u11",0x380001, 0x040000,  CRC(a52156b8) SHA1(0990ef1fb3427a5d3c262e264feb25c1db75ed33) )
+	ROM_CONTINUE(            0x300001, 0x040000)
+	ROM_LOAD16_BYTE( "6.u2", 0x080000, 0x020000,  CRC(9852fd6f) SHA1(348befeca5129c5ea2c142760ec93511f98f23cc) )
+	ROM_CONTINUE(            0x000000, 0x020000)
+	ROM_CONTINUE(            0x0c0000, 0x020000)
+	ROM_CONTINUE(            0x040000, 0x020000)
+	ROM_LOAD16_BYTE( "5.u4", 0x180000, 0x040000,  CRC(ed6a6d13) SHA1(eaab912ee035ece03f7cfceb1b546004399daad5) )
+	ROM_CONTINUE(            0x100000, 0x040000)
+	ROM_LOAD16_BYTE( "7.u10",0x280000, 0x040000,  CRC(a124d8d1) SHA1(d391b130992701d0fae7e827ba314b8368d809de) )
+	ROM_CONTINUE(            0x200000, 0x040000)
+	ROM_LOAD16_BYTE( "8.u12",0x380000, 0x040000,  CRC(8176f7cc) SHA1(375e1e982b97ba709fb160b04f56f6aa2d580104) )
+	ROM_CONTINUE(            0x300000, 0x040000)
+ROM_END
+
+ROM_START( ssf2ghw )
+	ROM_REGION( 0x1400000, "maincpu", 0 ) /* 68000 Code */
+	/* Special Case, custom PCB, linear ROM mapping of 5meg */
+	ROM_LOAD16_BYTE( "rom_a", 0x000000, 0x200000,  CRC(59726521) SHA1(3120bac17f56c01ffb9d3f9e31efa0263e3774af) )
+	ROM_LOAD16_BYTE( "rom_b", 0x000001, 0x200000,  CRC(7dad5540) SHA1(9279068b2218d239fdd557dd959ac70e74853178) )
+	ROM_LOAD16_BYTE( "rom_c", 0x400000, 0x080000,  CRC(deb48624) SHA1(39ffa7de7b808e0b95cb039bb381705d77420933) )
+	ROM_LOAD16_BYTE( "rom_d", 0x400001, 0x080000,  CRC(b99f6a5b) SHA1(adbe28a7522024bc66328ac86fecf9ded3310e8e) )
+ROM_END
+
+ROM_START( topshoot ) /* Top Shooter (c)1995 Sun Mixing */
+	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_LOAD16_BYTE( "tc574000ad_u11_2.bin", 0x000000, 0x080000, CRC(b235c4d9) SHA1(fbb308a5f6e769f3277824cb6a3b50c308969ac2) )
+	ROM_LOAD16_BYTE( "tc574000ad_u12_1.bin", 0x000001, 0x080000, CRC(e826f6ad) SHA1(23ec8bb608f954d3b915f061e7076c0c63b8259e) )
+
+	// not hooked up yet
+	ROM_REGION( 0x1000, "mcu", 0 )
+	ROM_LOAD( "89c51.bin", 0x0000, 0x1000, CRC(595475c8) SHA1(8313819ba06cc92b54f88c1ca9f34be8d1ec94d0) )
+ROM_END
+
+/*************************************
+ *
+ *  Game-specific driver inits
+ *
+ *************************************/
+
+#define ENERGY_CONSOLE_MODE 0
+
+static DRIVER_INIT( aladbl )
+{
+	/*
+     * Game does a check @ 1afc00 with work RAM fff57c that makes it play like the original console version (i.e. 8 energy hits instead of 2)
+     */
+	#if ENERGY_CONSOLE_MODE
+	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
+	rom[0x1afc08/2] = 0x6600;
+	#endif
+
+	// 220000 = writes to mcu? 330000 = reads?
+	memory_install_write16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x220000, 0x220001, 0, 0, aladbl_w);
+	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x330000, 0x330001, 0, 0, aladbl_r);
+
+	DRIVER_INIT_CALL(megadrij);
+}
+
+// this should be correct, the areas of the ROM that differ to the original
+// after this decode look like intentional changes
+static DRIVER_INIT( mk3ghw )
+{
+	int x;
+	UINT8 *rom = memory_region(machine, "maincpu");
+
+	for (x=0x000001;x<0x100001;x+=2)
+	{
+		if (x&0x80000)
+		{
+			rom[x] = rom[x]^0xff;
+			rom[x] = BITSWAP8(rom[x], 0,3,2,5,4,6,7,1);
+		}
+		else
+		{
+			rom[x] = rom[x]^0xff;
+			rom[x] = BITSWAP8(rom[x], 4,0,7,1,3,6,2,5);
+		}
+	}
+
+	for (x=0x100001;x<0x400000;x+=2)
+	{
+		if (x&0x80000)
+		{
+			rom[x] = rom[x]^0xff;
+			rom[x] = BITSWAP8(rom[x], 2,7,5,4,1,0,3,6);
+		}
+		else
+		{
+			rom[x] = BITSWAP8(rom[x], 6,1,4,2,7,0,3,5);
+		}
+	}
+
+	// boot vectors don't seem to be valid, so they are patched...
+	rom[0x01] = 0x01;
+	rom[0x00] = 0x00;
+	rom[0x03] = 0x00;
+	rom[0x02] = 0x00;
+	rom[0x05] = 0x00;
+	rom[0x04] = 0x00;
+	rom[0x07] = 0x02;
+	rom[0x06] = 0x10;
+
+	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x770070, 0x770075, 0, 0, mk3ghw_dsw_r );
+
+	DRIVER_INIT_CALL(megadriv);
+}
+
+static DRIVER_INIT( ssf2ghw )
+{
+	memory_nop_write(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0xA130F0, 0xA130FF, 0, 0); // custom banking is disabled (!)
+	memory_install_read_bank(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x400000, 0x5fffff, 0, 0, "bank5");
+	memory_unmap_write(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x400000, 0x5fffff, 0, 0);
+
+	memory_set_bankptr(machine,  "bank5", memory_region( machine, "maincpu" ) + 0x400000 );
+
+	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x770070, 0x770075, 0, 0, ssf2ghw_dsw_r );
+
+	DRIVER_INIT_CALL(megadrij);
+
+}
+
+static DRIVER_INIT(topshoot)
+{
+	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200050, 0x200051, 0, 0, topshoot_200051_r );
+	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200042, 0x200043, 0, 0, "IN0");
+	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200044, 0x200045, 0, 0, "IN1");
+	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200046, 0x200047, 0, 0, "IN2");
+	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200048, 0x200049, 0, 0, "IN3");
+
+	DRIVER_INIT_CALL(megadriv);
+}
+
+/*************************************
+ *
+ *  Game driver(s)
+ *
+ *************************************/
+
+GAME( 1993, aladbl,   0, megadriv,   aladbl,   aladbl,   ROT0, "bootleg / Sega",   "Aladdin (bootleg of Japanese Megadrive version)", 0)
+GAME( 1996, mk3ghw,   0, megadriv,   mk3ghw,   mk3ghw,   ROT0, "bootleg / Midway", "Mortal Kombat 3 (bootleg of Megadrive version)", 0)
+GAME( 1994, ssf2ghw,  0, megadriv,   ssf2ghw,  ssf2ghw,  ROT0, "bootleg / Capcom", "Super Street Fighter II - The New Challengers (Arcade bootleg of Japanese MegaDrive version)", 0)
+GAME( 1995, topshoot, 0, md_bootleg, topshoot, topshoot, ROT0, "Sun Mixing",       "Top Shooter", 0)
diff -Nru src-old/mame/drivers/metalmx.c src/mame/drivers/metalmx.c
--- src-old/mame/drivers/metalmx.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/metalmx.c	2010-08-19 01:27:05.000000000 -0700
@@ -453,19 +453,19 @@
 
 static WRITE32_HANDLER( host_gsp_w )
 {
-	const address_space *gsp_space = cputag_get_address_space(space->machine, "gsp", ADDRESS_SPACE_PROGRAM);
+	address_space *gsp_space = cputag_get_address_space(space->machine, "gsp", ADDRESS_SPACE_PROGRAM);
 
-	memory_write_word(gsp_space, (0xc0000000 + (offset << 5) + 0x10) / 8, data);
-	memory_write_word(gsp_space, (0xc0000000 + (offset << 5))/ 8 , data >> 16);
+	gsp_space->write_word((0xc0000000 + (offset << 5) + 0x10) / 8, data);
+	gsp_space->write_word((0xc0000000 + (offset << 5))/ 8 , data >> 16);
 }
 
 static READ32_HANDLER( host_gsp_r )
 {
-	const address_space *gsp_space = cputag_get_address_space(space->machine, "gsp", ADDRESS_SPACE_PROGRAM);
+	address_space *gsp_space = cputag_get_address_space(space->machine, "gsp", ADDRESS_SPACE_PROGRAM);
 	UINT32 val;
 
-	val  = memory_read_word(gsp_space, (0xc0000000 + (offset << 5) + 0x10) / 8);
-	val |= memory_read_word(gsp_space, (0xc0000000 + (offset << 5)) / 8) << 16;
+	val  = gsp_space->read_word((0xc0000000 + (offset << 5) + 0x10) / 8);
+	val |= gsp_space->read_word((0xc0000000 + (offset << 5)) / 8) << 16;
 	return val;
 }
 
diff -Nru src-old/mame/drivers/metro.c src/mame/drivers/metro.c
--- src-old/mame/drivers/metro.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/metro.c	2010-08-19 00:26:14.000000000 -0700
@@ -129,7 +129,7 @@
 static void update_irq_state( running_machine *machine )
 {
 	metro_state *state = machine->driver_data<metro_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	/*  Get the pending IRQs (only the enabled ones, e.g. where irq_enable is *0*)  */
 	UINT16 irq = metro_irq_cause_r(space, 0, 0xffff) & ~*state->irq_enable;
@@ -340,7 +340,7 @@
 static int metro_io_callback( running_device *device, int ioline, int state )
 {
 	metro_state *driver_state = device->machine->driver_data<metro_state>();
-	const address_space *space = cpu_get_address_space(driver_state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(driver_state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT8 data = 0;
 
 	switch (ioline)
@@ -665,7 +665,7 @@
 	return ROM[offs];
 }
 
-INLINE void blt_write( const address_space *space, const int tmap, const offs_t offs, const UINT16 data, const UINT16 mask )
+INLINE void blt_write( address_space *space, const int tmap, const offs_t offs, const UINT16 data, const UINT16 mask )
 {
 	switch(tmap)
 	{
@@ -6095,7 +6095,7 @@
 static DRIVER_INIT( metro )
 {
 	metro_state *state = machine->driver_data<metro_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	metro_common(machine);
 
@@ -6128,7 +6128,7 @@
 static DRIVER_INIT( daitorid )
 {
 	metro_state *state = machine->driver_data<metro_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	metro_common(machine);
 
diff -Nru src-old/mame/drivers/mhavoc.c src/mame/drivers/mhavoc.c
--- src-old/mame/drivers/mhavoc.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/mhavoc.c	2010-08-13 01:54:21.000000000 -0700
@@ -237,7 +237,7 @@
 	AM_RANGE(0x0a00, 0x0fff) AM_RAMBANK("bank1") AM_BASE(&mhavoc_zram1)
 	AM_RANGE(0x1000, 0x1000) AM_READ(mhavoc_gamma_r)			/* Gamma Read Port */
 	AM_RANGE(0x1200, 0x1200) AM_READ_PORT("IN0") AM_WRITENOP	/* Alpha Input Port 0 */
-	AM_RANGE(0x1400, 0x141f) AM_RAM AM_BASE(&mhavoc_colorram)	/* ColorRAM */
+	AM_RANGE(0x1400, 0x141f) AM_RAM AM_BASE(&avgdvg_colorram)	/* ColorRAM */
 	AM_RANGE(0x1600, 0x1600) AM_WRITE(mhavoc_out_0_w)			/* Control Signals */
 	AM_RANGE(0x1640, 0x1640) AM_WRITE(avgdvg_go_w)				/* Vector Generator GO */
 	AM_RANGE(0x1680, 0x1680) AM_WRITE(watchdog_reset_w)			/* Watchdog Clear */
@@ -248,7 +248,7 @@
 	AM_RANGE(0x17c0, 0x17c0) AM_WRITE(mhavoc_gamma_w)			/* Gamma Communication Write Port */
 	AM_RANGE(0x1800, 0x1fff) AM_RAM								/* Shared Beta Ram */
 	AM_RANGE(0x2000, 0x3fff) AM_ROMBANK("bank2")						/* Paged Program ROM (32K) */
-	AM_RANGE(0x4000, 0x4fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("alpha", 0x4000)	/* Vector Generator RAM */
+	AM_RANGE(0x4000, 0x4fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("alpha", 0x4000)	/* Vector Generator RAM */
 	AM_RANGE(0x5000, 0x7fff) AM_ROM								/* Vector ROM */
 	AM_RANGE(0x8000, 0xffff) AM_ROM					/* Program ROM (32K) */
 ADDRESS_MAP_END
@@ -300,10 +300,10 @@
 	AM_RANGE(0x10b0, 0x10b0) AM_WRITE(mhavoc_alpha_irq_ack_w)	/* IRQ ack */
 	AM_RANGE(0x10b4, 0x10b4) AM_WRITE(mhavoc_rom_banksel_w)
 	AM_RANGE(0x10b8, 0x10b8) AM_WRITE(mhavoc_ram_banksel_w)
-	AM_RANGE(0x10e0, 0x10ff) AM_WRITEONLY AM_BASE(&mhavoc_colorram)	/* ColorRAM */
+	AM_RANGE(0x10e0, 0x10ff) AM_WRITEONLY AM_BASE(&avgdvg_colorram)	/* ColorRAM */
 	AM_RANGE(0x1800, 0x18ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)	/* EEROM */
 	AM_RANGE(0x2000, 0x3fff) AM_ROMBANK("bank2")						/* Paged Program ROM (32K) */
-	AM_RANGE(0x4000, 0x4fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("alpha", 0x4000) /* Vector Generator RAM */
+	AM_RANGE(0x4000, 0x4fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("alpha", 0x4000) /* Vector Generator RAM */
 	AM_RANGE(0x5000, 0x7fff) AM_ROM								/* Vector ROM */
 	AM_RANGE(0x8000, 0xffff) AM_ROM								/* Program ROM (32K) */
 ADDRESS_MAP_END
diff -Nru src-old/mame/drivers/mikie.c src/mame/drivers/mikie.c
--- src-old/mame/drivers/mikie.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/mikie.c	2010-08-24 09:24:55.000000000 -0700
@@ -14,6 +14,26 @@
     6000-ffff ROM
 
 
+Stephh's notes (based on the games M6809 code and some tests) :
+
+  - To enter service mode, keep START1 and START2 pressed on reset.
+    Then press START1 to cycle through the different tests.
+  - According to code at 0x618f, you can start a game with 255 lives
+    if you set DSW1 and DSW2 to the following settings :
+      * "Coin A"      : "Free Play"
+      * "Coin B"      : "No Coin B"
+      * "Lives"       : "7"
+      * "Cabinet"     : "Upright"
+      * "Bonus Life"  : "20k 70k 50k+"
+      * "Difficulty"  : "Medium"
+      * "Demo Sounds" : "Off"
+    DSW3 is not tested here, so settings can be anything.
+  - I'm very surprised to notice that 'mikie' and 'mikiej' have the same
+    PRG ROMS but different GFX ROMS.
+    This is very rare (unique ?) for the Konami games.
+  - There might exist undumped Konami/Centuri version(s) of this game :
+    the manual I've found speaks about a "conversion kit".
+
 ***************************************************************************/
 
 #include "emu.h"
@@ -81,9 +101,9 @@
 	AM_RANGE(0x2400, 0x2400) AM_READ_PORT("SYSTEM") AM_WRITE(soundlatch_w)
 	AM_RANGE(0x2401, 0x2401) AM_READ_PORT("P1")
 	AM_RANGE(0x2402, 0x2402) AM_READ_PORT("P2")
-	AM_RANGE(0x2403, 0x2403) AM_READ_PORT("DSW2")
-	AM_RANGE(0x2500, 0x2500) AM_READ_PORT("DSW0")
-	AM_RANGE(0x2501, 0x2501) AM_READ_PORT("DSW1")
+	AM_RANGE(0x2403, 0x2403) AM_READ_PORT("DSW3")
+	AM_RANGE(0x2500, 0x2500) AM_READ_PORT("DSW1")
+	AM_RANGE(0x2501, 0x2501) AM_READ_PORT("DSW2")
 	AM_RANGE(0x2800, 0x288f) AM_RAM AM_BASE_SIZE_MEMBER(mikie_state, spriteram, spriteram_size)
 	AM_RANGE(0x2890, 0x37ff) AM_RAM
 	AM_RANGE(0x3800, 0x3bff) AM_RAM_WRITE(mikie_colorram_w) AM_BASE_MEMBER(mikie_state, colorram)
@@ -111,6 +131,7 @@
  *
  *************************************/
 
+/* verified from M6809 code */
 static INPUT_PORTS_START( mikie )
 	PORT_START("SYSTEM")
 	KONAMI8_SYSTEM_UNK
@@ -121,20 +142,11 @@
 	PORT_START("P2")
 	KONAMI8_COCKTAIL_4WAY_B12_UNK
 
-	PORT_START("DSW2")
-	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Flip_Screen ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
-	PORT_DIPNAME( 0x02, 0x00, DEF_STR( Controls ) )
-	PORT_DIPSETTING(    0x00, DEF_STR( Single ) )
-	PORT_DIPSETTING(    0x02, DEF_STR( Dual ) )
-	PORT_BIT( 0xfc, IP_ACTIVE_HIGH, IPT_UNKNOWN )
-
-	PORT_START("DSW0")
+	PORT_START("DSW1")
 	KONAMI_COINAGE(DEF_STR( Free_Play ), "No Coin B")
 	/* "No Coin B" = coins produce sound, but no effect on coin counter */
 
-	PORT_START("DSW1")
+	PORT_START("DSW2")
 	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Lives ) )
 	PORT_DIPSETTING(    0x03, "3" )
 	PORT_DIPSETTING(    0x02, "4" )
@@ -144,18 +156,29 @@
 	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
 	PORT_DIPSETTING(    0x04, DEF_STR( Cocktail ) )
 	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(    0x18, "20K 50K+" )
-	PORT_DIPSETTING(    0x10, "30K 60K+" )
-	PORT_DIPSETTING(    0x08, "30K" )
-	PORT_DIPSETTING(    0x00, "40K" )
+	PORT_DIPSETTING(    0x18, "20k 70k 50k+" )
+	PORT_DIPSETTING(    0x10, "30K 90k 60k+" )
+	PORT_DIPSETTING(    0x08, "30k only" )
+	PORT_DIPSETTING(    0x00, "40K only" )
 	PORT_DIPNAME( 0x60, 0x60, DEF_STR( Difficulty ) )
-	PORT_DIPSETTING(    0x60, "1 (Easy)" )
-	PORT_DIPSETTING(    0x40, "2" )
-	PORT_DIPSETTING(    0x20, "3" )
-	PORT_DIPSETTING(    0x00, "4 (Hard)" )
+	PORT_DIPSETTING(	0x60, DEF_STR( Easy ) )             /* 1 */
+	PORT_DIPSETTING(	0x40, DEF_STR( Medium ) )           /* 2 */
+	PORT_DIPSETTING(	0x20, DEF_STR( Hard ) )             /* 3 */
+	PORT_DIPSETTING(	0x00, DEF_STR( Hardest ) )          /* 4 */
 	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Demo_Sounds ) )
 	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
 	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x01, 0x00, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "Upright Controls" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Single ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Dual ) )
+	PORT_DIPUNUSED( 0x04, 0x04 )
+	PORT_DIPUNUSED( 0x08, 0x08 )
+	PORT_BIT( 0xf0, IP_ACTIVE_LOW, IPT_UNKNOWN )
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/mil4000.c src/mame/drivers/mil4000.c
--- src-old/mame/drivers/mil4000.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/mil4000.c	2010-08-19 00:26:14.000000000 -0700
@@ -147,7 +147,7 @@
 
 static VIDEO_START(mil4000)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	// game doesn't clear the palette, so to avoid seeing mame defaults we clear it
diff -Nru src-old/mame/drivers/missile.c src/mame/drivers/missile.c
--- src-old/mame/drivers/missile.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/missile.c	2010-08-19 09:10:19.000000000 -0700
@@ -445,7 +445,7 @@
 }
 
 
-static DIRECT_UPDATE_HANDLER( missile_direct_handler )
+DIRECT_UPDATE_HANDLER( missile_direct_handler )
 {
 	/* offset accounts for lack of A15 decoding */
 	int offset = address & 0x8000;
@@ -454,14 +454,14 @@
 	/* RAM? */
 	if (address < 0x4000)
 	{
-		direct->raw = direct->decrypted = space->machine->generic.videoram.u8 - offset;
+		direct.explicit_configure(0x0000 | offset, 0x3fff | offset, 0x3fff, direct.space().m_machine.generic.videoram.u8);
 		return ~0;
 	}
 
 	/* ROM? */
 	else if (address >= 0x5000)
 	{
-		direct->raw = direct->decrypted = memory_region(space->machine, "maincpu") - offset;
+		direct.explicit_configure(0x5000 | offset, 0x7fff | offset, 0x7fff, direct.space().m_machine.region("maincpu")->base() + 0x5000);
 		return ~0;
 	}
 
@@ -477,7 +477,8 @@
 	flipscreen = 0;
 
 	/* set up an opcode base handler since we use mapped handlers for RAM */
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), missile_direct_handler);
+	address_space *space = machine->device<m6502_device>("maincpu")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(missile_direct_handler, *machine));
 
 	/* create a timer to speed/slow the CPU */
 	cpu_timer = timer_alloc(machine, adjust_cpu_speed, NULL);
@@ -511,7 +512,7 @@
  *
  *************************************/
 
-INLINE int get_madsel(const address_space *space)
+INLINE int get_madsel(address_space *space)
 {
 	UINT16 pc = cpu_get_previouspc(space->cpu);
 
@@ -522,7 +523,7 @@
 	/* MADSEL signal disables standard address decoding and routes
         writes to video RAM; it is enabled if the IRQ signal is clear
         and the low 5 bits of the fetched opcode are 0x01 */
-	if (!irq_state && (memory_decrypted_read_byte(space, pc) & 0x1f) == 0x01)
+	if (!irq_state && (space->direct().read_decrypted_byte(pc) & 0x1f) == 0x01)
 	{
 		/* the MADSEL signal goes high 5 cycles after the opcode is identified;
             this effectively skips the indirect memory read. Since this is difficult
@@ -548,7 +549,7 @@
 }
 
 
-static void write_vram(const address_space *space, offs_t address, UINT8 data)
+static void write_vram(address_space *space, offs_t address, UINT8 data)
 {
 	static const UINT8 data_lookup[4] = { 0x00, 0x0f, 0xf0, 0xff };
 	offs_t vramaddr;
@@ -578,7 +579,7 @@
 }
 
 
-static UINT8 read_vram(const address_space *space, offs_t address)
+static UINT8 read_vram(address_space *space, offs_t address)
 {
 	offs_t vramaddr;
 	UINT8 vramdata;
diff -Nru src-old/mame/drivers/mitchell.c src/mame/drivers/mitchell.c
--- src-old/mame/drivers/mitchell.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/mitchell.c	2010-08-19 07:19:38.000000000 -0700
@@ -2119,8 +2119,8 @@
 
 static void bootleg_decode( running_machine *machine )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x50000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x50000);
 	memory_configure_bank_decrypted(machine, "bank1", 0, 16, memory_region(machine, "maincpu") + 0x60000, 0x4000);
 }
 
diff -Nru src-old/mame/drivers/model2.c src/mame/drivers/model2.c
--- src-old/mame/drivers/model2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/model2.c	2010-08-19 00:26:14.000000000 -0700
@@ -199,7 +199,7 @@
 static int copro_fifoout_rpos, copro_fifoout_wpos;
 static UINT32 copro_fifoout_data[COPRO_FIFOOUT_SIZE];
 static int copro_fifoout_num = 0;
-static UINT32 copro_fifoout_pop(const address_space *space)
+static UINT32 copro_fifoout_pop(address_space *space)
 {
 	UINT32 r;
 
@@ -1012,7 +1012,7 @@
 
 static int to_68k;
 
-static int snd_68k_ready_r(const address_space *space)
+static int snd_68k_ready_r(address_space *space)
 {
 	int sr = cpu_get_reg(space->machine->device("audiocpu"), M68K_SR);
 
@@ -1025,7 +1025,7 @@
 	return 0xff;
 }
 
-static void snd_latch_to_68k_w(const address_space *space, int data)
+static void snd_latch_to_68k_w(address_space *space, int data)
 {
 	if (!snd_68k_ready_r(space))
 	{
diff -Nru src-old/mame/drivers/model3.c src/mame/drivers/model3.c
--- src-old/mame/drivers/model3.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/model3.c	2010-08-19 01:27:05.000000000 -0700
@@ -1014,9 +1014,9 @@
 
 static UINT32 scsi_fetch(running_machine *machine, UINT32 dsp)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT32 result;
-	result = memory_read_dword(space, dsp);
+	result = space->read_dword(dsp);
 	return FLIPENDIAN_INT32(result);
 }
 
@@ -1119,7 +1119,7 @@
 
 static void real3d_dma_callback(running_machine *machine, UINT32 src, UINT32 dst, int length, int byteswap)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	switch(dst >> 24)
 	{
 		case 0x88:		/* Display List End Trigger */
diff -Nru src-old/mame/drivers/moo.c src/mame/drivers/moo.c
--- src-old/mame/drivers/moo.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/moo.c	2010-08-19 01:27:05.000000000 -0700
@@ -236,11 +236,11 @@
 
 		while (length)
 		{
-			a = memory_read_word(space, src1);
-			b = memory_read_word(space, src2);
+			a = space->read_word(src1);
+			b = space->read_word(src2);
 			res = a + 2 * b;
 
-			memory_write_word(space, dst, res);
+			space->write_word(dst, res);
 
 			src1 += 2;
 			src2 += 2;
diff -Nru src-old/mame/drivers/mouser.c src/mame/drivers/mouser.c
--- src-old/mame/drivers/mouser.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/mouser.c	2010-08-19 07:19:38.000000000 -0700
@@ -286,12 +286,12 @@
 	/* Decode the opcodes */
 
 	offs_t i;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x6000);
 	UINT8 *table = memory_region(machine, "user1");
 
-	memory_set_decrypted_region(space, 0x0000, 0x5fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x5fff, decrypted);
 
 	for (i = 0; i < 0x6000; i++)
 	{
diff -Nru src-old/mame/drivers/mpu4drvr.c src/mame/drivers/mpu4drvr.c
--- src-old/mame/drivers/mpu4drvr.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/mpu4drvr.c	2010-08-19 00:26:14.000000000 -0700
@@ -2582,7 +2582,7 @@
 
 static DRIVER_INIT (mating)
 {
-	const address_space *space = cputag_get_address_space(machine, "video", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "video", ADDRESS_SPACE_PROGRAM);
 	running_device *device = machine->device("oki");
 
 	/* The Mating Game has an extra 256kB RAM on the program card */
diff -Nru src-old/mame/drivers/mrflea.c src/mame/drivers/mrflea.c
--- src-old/mame/drivers/mrflea.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/mrflea.c	2010-08-25 12:59:47.000000000 -0700
@@ -37,6 +37,27 @@
    x  x  VD_J11 VD_J10  x  x  VD_J7 VD_J6     VD_K4 VD_K3 VD_K2 VD_K1
    x  x  VD-L11 VD_L10  x  x  VD_L7 VD_L6     VD_L4 VD_L3 VD_L2 VD_L1
 
+
+Stephh's notes (based on the games Z80 code and some tests) :
+
+  - DSW1 bits 0 and 1 determine the "Bonus life" value (1 OFF - 0 ON) :
+      * ......11 : 10000 points
+      * ......10 : 20000 points
+      * ......01 : 30000 points
+      * ......00 : 40000 points
+  - DSW1 bit 2 determines the "Bonus life" occurence (1 OFF - 0 ON) :
+      * .....1.. : many extra lives can be awarded every "value" points
+      * .....0.. : only one extra life can be awarded at "value" points
+  - When DSW1 bit 3 is OFF, you can't get any extra lives (code at 0x3368).
+  - I've decided to merge these 4 bits in a single choice for the end-user.
+  - Credits are coded on 1 byte (0xc6bd) then are divided by 2 for display
+    so it can display 1/2 credits when coinage is set to 2C_1C or 2C_3C.
+    Surprisingly, due to code at 0x2f77, credits are limited to 15 when
+    coinage is set to 1C_1C or 1C_2C and to 14 1/2 is set to 2C_1C or 2C_3C.
+  - Level is stored 1 byte (0xc70c), range 0x00-0x07 (code at 0x071d and 0x072c).
+    This means that if you complete level 8, you'll restart from level 1
+    with its initial difficulty (based on the Dip Switch settings).
+
 ******************************************************************/
 
 #include "emu.h"
@@ -192,54 +213,44 @@
  *
  *************************************/
 
+/* verified from Z80 code */
 static INPUT_PORTS_START( mrflea )
+	/* AY1 port 1 -> 0x807d (CPU1) -> 0xcabe (CPU0) with bits in reverse order */
 	PORT_START("IN0")
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN ) PORT_4WAY
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_UP ) PORT_4WAY
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT ) PORT_4WAY
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_JOYSTICK_DOWN )  PORT_4WAY
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_JOYSTICK_UP )    PORT_4WAY
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_JOYSTICK_LEFT )  PORT_4WAY
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_JOYSTICK_RIGHT ) PORT_4WAY
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_START2 )
 	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_UNUSED )
 
+	/* AY1 port 0 -> 0x807e (CPU1) -> 0xcabf (CPU0) with bits in reverse order */
 	PORT_START("IN1")
-	PORT_BIT( 0x03, IP_ACTIVE_LOW, IPT_UNKNOWN )
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_COIN1 )
-	PORT_BIT( 0xf8, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0xfb, IP_ACTIVE_LOW, IPT_UNUSED )
 
+	/* AY2 port 1, cpl'ed -> 0x807f (CPU1) -> 0xcac1 (CPU0) */
 	PORT_START("DSW1")
-/*
-    ------xx
-    -----x--
-    ----x---
-*/
-	PORT_DIPNAME( 0x03, 0x03, "Bonus?" )
-	PORT_DIPSETTING( 0x03, "A" )
-	PORT_DIPSETTING( 0x02, "B" )
-	PORT_DIPSETTING( 0x01, "C" )
-	PORT_DIPSETTING( 0x00, "D" )
-	PORT_DIPNAME( 0x04, 0x04, DEF_STR( Unknown ) )
-	PORT_DIPSETTING( 0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Unknown ) )
-	PORT_DIPSETTING( 0x08, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x10, 0x10, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x10, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x20, 0x20, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x20, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x0f, 0x07, DEF_STR( Bonus_Life ) )       /* see notes - table of tables at 0x3475 (4 * 1 word, LSB first) */
+	PORT_DIPSETTING(    0x07, "Every 10k" )
+	PORT_DIPSETTING(    0x06, "Every 20k" )
+	PORT_DIPSETTING(    0x05, "Every 30k" )
+	PORT_DIPSETTING(    0x04, "Every 40k" )
+	PORT_DIPSETTING(    0x03, "10k only" )
+	PORT_DIPSETTING(    0x02, "20k only" )
+	PORT_DIPSETTING(    0x01, "30k only" )
+	PORT_DIPSETTING(    0x00, "40K only" )
+	PORT_DIPSETTING(    0x0f, DEF_STR( None ) )
+	PORT_DIPUNUSED( 0x10, 0x10 )
+	PORT_DIPUNUSED( 0x20, 0x20 )
+	PORT_DIPUNUSED( 0x40, 0x40 )
+	PORT_DIPUNUSED( 0x80, 0x80 )
 
+	/* AY2 port 0, cpl'ed -> 0x8080 (CPU1) -> 0xcac0 (CPU0) */
 	PORT_START("DSW2")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coinage ) )
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Coinage ) )          /* see notes */
 	PORT_DIPSETTING( 0x02, DEF_STR( 2C_1C ) )
 	PORT_DIPSETTING( 0x03, DEF_STR( 1C_1C ) )
 	PORT_DIPSETTING( 0x00, DEF_STR( 2C_3C ) )
@@ -249,17 +260,13 @@
 	PORT_DIPSETTING( 0x08, "4" )
 	PORT_DIPSETTING( 0x04, "5" )
 	PORT_DIPSETTING( 0x00, "7" )
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Difficulty ) )
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Difficulty ) )       /* see notes */
 	PORT_DIPSETTING( 0x30, DEF_STR( Easy ) )
 	PORT_DIPSETTING( 0x20, DEF_STR( Medium ) )
 	PORT_DIPSETTING( 0x10, DEF_STR( Hard ) )
 	PORT_DIPSETTING( 0x00, DEF_STR( Hardest ) )
-	PORT_DIPNAME( 0x40, 0x40, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x40, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x80, 0x80, DEF_STR( Unused ) )
-	PORT_DIPSETTING( 0x80, DEF_STR( Off ) )
-	PORT_DIPSETTING( 0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x40, 0x40 )
+	PORT_DIPUNUSED( 0x80, 0x80 )
 INPUT_PORTS_END
 
 
diff -Nru src-old/mame/drivers/multigam.c src/mame/drivers/multigam.c
--- src-old/mame/drivers/multigam.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/multigam.c	2010-08-19 00:26:14.000000000 -0700
@@ -1079,7 +1079,7 @@
 
 static MACHINE_RESET( multigm3 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	/* reset the ppu */
 	multigm3_switch_prg_rom(space, 0, 0x01 );
 };
@@ -1309,7 +1309,7 @@
 
 static DRIVER_INIT( multigam )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	multigam_switch_prg_rom(space, 0x0, 0x01);
 }
 
@@ -1324,7 +1324,7 @@
 
 static DRIVER_INIT(multigm3)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	const UINT8 decode[16]  = { 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00, 0x0f, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a };
 
@@ -1338,7 +1338,7 @@
 
 static DRIVER_INIT(multigmt)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	UINT8* buf = auto_alloc_array(machine, UINT8, 0x80000);
 	UINT8 *rom;
diff -Nru src-old/mame/drivers/namcona1.c src/mame/drivers/namcona1.c
--- src-old/mame/drivers/namcona1.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/namcona1.c	2010-08-19 00:26:14.000000000 -0700
@@ -499,7 +499,7 @@
 static int transfer_dword( running_machine *machine, UINT32 dest, UINT32 source )
 {
 	UINT16 data;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if( source>=0x400000 && source<0xc00000 )
 	{
diff -Nru src-old/mame/drivers/namcops2.c src/mame/drivers/namcops2.c
--- src-old/mame/drivers/namcops2.c	2010-08-05 19:11:10.000000000 -0700
+++ src/mame/drivers/namcops2.c	2010-08-26 09:31:58.000000000 -0700
@@ -41,7 +41,7 @@
 static INPUT_PORTS_START( system246 )
 INPUT_PORTS_END
 
-static const mips3_config config =
+static const mips3_config r5000_config =
 {
 	16384,				/* code cache size - probably wrong */
 	16384				/* data cache size */
@@ -50,7 +50,7 @@
 static MACHINE_DRIVER_START( system246 )
 	MDRV_CPU_ADD("maincpu", R5000LE, 294000000)	// actually R5900 @ 294 MHz
 	MDRV_CPU_PROGRAM_MAP(ps2_map)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 
 	/* video hardware */
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/namcos1.c src/mame/drivers/namcos1.c
--- src-old/mame/drivers/namcos1.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/namcos1.c	2010-08-25 18:01:06.000000000 -0700
@@ -2530,43 +2530,6 @@
 	ROM_LOAD( "sb1_obj0.bin",       0x00000, 0x10000, CRC(ed810da4) SHA1(b3172b50b15d0e2fd40d38d32abf4de22b6f7a85) )
 ROM_END
 
-
-/*
-Puzzle Club
-Yunsung, 2000
-
-PCB Layout
-----------
-
-YS-2113
-|----------------------------------------------|
-|ROM1.128 ROM2.137 ROM3.7  62256  ROM5.97      |
-|  6116 Z80  6295  ROM4.2  62256  ROM6.95      |
-|  YMXXXX   16MHz     PAL         ROM7.105     |
-|  YM3014             PAL  PAL    ROM8.83      |
-|          62256    68000         ROM9.82      |
-|          62256           6116     14.38383MHz|
-|                          6116   PAL     PAL  |
-|J           6116   QL2003        PAL          |
-|A           6116                 PAL          |
-|M           6116   QL12X16B      PAL          |
-|M DIP1      6116                 PAL          |
-|A DIP2                                        |
-|            62256  QL2003                     |
-|            62256                             |
-|                                              |
-|  ROM11.166  ROM10.167                        |
-|                   QL2003        PAL          |
-|  ROM13.164  ROM12.165           PAL          |
-|----------------------------------------------|
-Notes:
-      68000 clock : 16.000MHz
-      Z80 clock   : 4.000MHz (16/4)
-      M6295 clock : 1.000MHz (16/16). Sample Rate = 1000000 / 132
-      YMXXXX clock: 4.000MHz (16/4). Chip is either YM2151 or YM3812
-      VSync       : 60Hz
-*/
-
 ROM_START( puzlclub )
 	ROM_REGION( 0x2c000, "audiocpu", 0 )       /* 176k for the sound cpu */
 	ROM_LOAD( "pc1_s0.bin",         0x0c000, 0x10000, CRC(44737c02) SHA1(bcacfed1c3522d6ecddd3ac79ded620e5334df35) )
diff -Nru src-old/mame/drivers/namcos11.c src/mame/drivers/namcos11.c
--- src-old/mame/drivers/namcos11.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/namcos11.c	2010-08-19 00:26:14.000000000 -0700
@@ -573,7 +573,7 @@
 
 static UINT32 m_n_bankoffset;
 
-INLINE void bankswitch_rom8( const address_space *space, const char *bank, int n_data )
+INLINE void bankswitch_rom8( address_space *space, const char *bank, int n_data )
 {
 	memory_set_bank( space->machine, bank, ( ( n_data & 0xc0 ) >> 4 ) + ( n_data & 0x03 ) );
 }
@@ -608,7 +608,7 @@
 	}
 }
 
-INLINE void bankswitch_rom64( const address_space *space, const char *bank, int n_data )
+INLINE void bankswitch_rom64( address_space *space, const char *bank, int n_data )
 {
 	/* todo: verify behaviour */
 	memory_set_bank( space->machine,  bank, ( ( ( ( n_data & 0xc0 ) >> 3 ) + ( n_data & 0x07 ) ) ^ m_n_bankoffset ) );
diff -Nru src-old/mame/drivers/namcos12.c src/mame/drivers/namcos12.c
--- src-old/mame/drivers/namcos12.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/namcos12.c	2010-08-19 00:26:14.000000000 -0700
@@ -1238,7 +1238,7 @@
 
 static MACHINE_RESET( namcos12 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	psx_machine_init(machine);
 	bankoffset_w(space,0,0,0xffffffff);
 	has_tektagt_dma = 0;
diff -Nru src-old/mame/drivers/namcos21.c src/mame/drivers/namcos21.c
--- src-old/mame/drivers/namcos21.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/namcos21.c	2010-08-19 00:26:14.000000000 -0700
@@ -562,7 +562,7 @@
 }
 
 static UINT16
-ReadWordFromSlaveInput( const address_space *space )
+ReadWordFromSlaveInput( address_space *space )
 {
 	UINT16 data = 0;
 	if( mpDspState->slaveBytesAvailable>0 )
diff -Nru src-old/mame/drivers/namcos22.c src/mame/drivers/namcos22.c
--- src-old/mame/drivers/namcos22.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/namcos22.c	2010-08-19 01:27:05.000000000 -0700
@@ -2435,7 +2435,7 @@
 	for(i=0;i<4;i++)
 	{
 		mAlpineSurferProtData<<=8;
-		mAlpineSurferProtData |= memory_read_byte(space, sptr+4+i );
+		mAlpineSurferProtData |= space->read_byte(sptr+4+i );
 	}
 #endif
 } /* alpinesa_prot_w */
diff -Nru src-old/mame/drivers/namcos23.c src/mame/drivers/namcos23.c
--- src-old/mame/drivers/namcos23.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/drivers/namcos23.c	2010-08-26 09:31:58.000000000 -0700
@@ -1911,13 +1911,13 @@
 	render_count[render_cur]++;
 }
 
-static void p3d_dma(const address_space *space, UINT32 adr, UINT32 size)
+static void p3d_dma(address_space *space, UINT32 adr, UINT32 size)
 {
 	adr &= 0x1fffffff;
 	UINT16 buffer[256];
 	int pos = 0;
 	while(pos < size) {
-		UINT16 h = memory_read_word(space, adr+pos);
+		UINT16 h = space->read_word(adr+pos);
 
 		pos += 2;
 
@@ -1937,7 +1937,7 @@
 		}
 
 		for(int i=0; i < psize; i++) {
-			buffer[i] = memory_read_word(space, adr+pos);
+			buffer[i] = space->read_word(adr+pos);
 			pos += 2;
 		}
 
@@ -2865,7 +2865,7 @@
 	GFXDECODE_ENTRY( NULL, 0, namcos23_cg_layout, 0x7f00, 0x80 )
 GFXDECODE_END
 
-static const mips3_config config =
+static const mips3_config r4650_config =
 {
 	8192,				/* code cache size - VERIFIED */
 	8192				/* data cache size - VERIFIED */
@@ -2875,7 +2875,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R4650BE, S23_BUSCLOCK*4)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r4650_config)
 	MDRV_CPU_PROGRAM_MAP(gorgon_map)
 	MDRV_CPU_VBLANK_INT("screen", s23_interrupt)
 
@@ -2921,7 +2921,7 @@
 static MACHINE_DRIVER_START( s23 )
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R4650BE, S23_BUSCLOCK*4)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r4650_config)
 	MDRV_CPU_PROGRAM_MAP(ss23_map)
 	MDRV_CPU_VBLANK_INT("screen", s23_interrupt)
 
@@ -2967,7 +2967,7 @@
 static MACHINE_DRIVER_START( ss23 )
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R4650BE, S23_BUSCLOCK*5)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r4650_config)
 	MDRV_CPU_PROGRAM_MAP(ss23_map)
 	MDRV_CPU_VBLANK_INT("screen", s23_interrupt)
 
diff -Nru src-old/mame/drivers/naomi.c src/mame/drivers/naomi.c
--- src-old/mame/drivers/naomi.c	2010-07-26 11:30:13.000000000 -0700
+++ src/mame/drivers/naomi.c	2010-08-30 08:20:58.000000000 -0700
@@ -192,12 +192,12 @@
       The other side of the cart PCB just has more locations for
       SOP44 MASKROMs... IC12S to IC21S (ROM12 to ROM21)
 
-  IC1-IC21S - MaskROM (SOP44), either 32Mb or 64Mb. Not all positions are populated.
+  IC1-IC21S - MaskROM (SOP44), either 32Mb or 64Mb. Not all positions are populated
       IC22  - EPROM (DIP42), either 27C160 or 27C322
       JP1   - JUMPER Sets the size of the EPROM. 1-2 = 32M, 2-3 = 16M
       IC37  - FLASHROM (SOIC8) Xicor X76F100 Secure SerialFlash
       IC41  - Sega 315-6213 Xilinx XC9536 (PLCC44)
-      IC42  - SEGA 315-5581 (QFP100). Probably some kind of FPGA or CPLD. Usually different per game.
+      IC42  - SEGA 315-5581 (QFP100). Probably some kind of FPGA or CPLD. Usually different per game
               On the end of the number, -JPN means it requires Japanese BIOS, -COM will run with any BIOS
  IC44-IC45  - SRAM (SOJ28) 32kx8, either IDT71256 or CY7C199
    CN1/2/3  - connectors joining to main board
@@ -277,20 +277,21 @@
 Notes:
 
       OSC1  - oscillator 50.0000MHz
-      IC1   - FPGA ACTEL A54SX32A (QFP208) SEGA part number 317-xxxx-yyy; -JPN means it requires Japanese BIOS, -COM will run with any BIOS
+      IC1   - FPGA ACTEL A54SX32A (QFP208) SEGA part number 317-xxxx-yyy
+              On the end of the number, -JPN means it requires Japanese BIOS, -COM will run with any BIOS
       IC11  - EPROM (DIP42), either 27C160 or 27C322
       JP1   - JUMPER Sets the size of the EPROM. 1-2 = 32M, 2-3 = 16M
       IC13S - EEPROM (SOIC8) 25LC040 serial EEPROM
       IC14  - 256 x 9 AsyncFIFO, 5.0V (SOP28)
       IC15  - SRAM (SOJ28) 32kx8, IDT71256
-IC17S-IC38S - MaskROM (SOP44), either 32Mb or 64Mb
+IC17S-IC38S - MaskROM (SOP44), either 32Mb or 64Mb. Not all positions are populated
    CN1/2/3  - connectors joining to main board
 
 Games known to use this PCB include....
                                         Sticker    EPROM   # of SOP44
 Game                                    on cart    IC11#   MASKROMs   IC1#      label IC1#    Notes
 ---------------------------------------------------------------------------------------------------------------------
-Giant Gram 2000                         840-0039C  23373   20 (64Mb)  A54SX32   317-0296-COM
+Giant Gram 2000                         840-0039C  23377   20 (64Mb)  A54SX32   317-0296-COM
 Kick '4' Cash                           840-0140C  24212   16 (64Mb)  A54SX32A  317-0397-COM
 Marvel Vs. Capcom 2                     841-0007C  23085A  14 (64Mb)  A54SX32   317-5058-COM  +2x 32Mb (full cart #:841-0007C-03)
 Quiz Ah Megamisama                      840-0030C  23227   16 (64Mb)  A54SX32   317-0280-JPN
@@ -320,12 +321,12 @@
       The female side of the cart PCB only has traces
 
       OSC1  - oscillator 28.000MHz
-  IC1-IC11  - MaskROM (TSOP48), 128Mb
+  IC1-IC11  - MaskROM (TSOP48), 128Mb. Not all positions are populated
       IC22  - EPROM (DIP42), either 27C160 or 27C322
       JP1   - JUMPER Sets the size of the EPROM. 1-2 = 32M, 2-3 = 16M
       IC27  - PLD Sega 315-6319A ALTERA EPM7032 (PLCC44)
       IC41  - Sega 315-6213 Xilinx XC9536 (PLCC44)
-      IC42  - SEGA 315-5581 (QFP100). Probably some kind of FPGA or CPLD. Usually different per game.
+      IC42  - SEGA 315-5581 (QFP100). Probably some kind of FPGA or CPLD. Usually different per game
               On the end of the number, -JPN means it requires Japanese BIOS, -COM will run with any BIOS
  IC44-IC45  - SRAM (SOJ28) 32kx8, either IDT71256 or CY7C199
       JP2   - JUMPER unknown function
@@ -339,6 +340,7 @@
 Capcom Vs. SNK Millennium Fight 2000    841-0011C  23511C   7 (128Mb)  315-6319   315-6213  317-5059-COM  (000904)
 Derby Owners Club 2                     840-0083C  22306B  11 (128Mb)  315-6319A  315-6213  not populated
 Derby Owners Club World Edition (Rev C) 840-0088C  22336C   7 (128Mb)  315-6319A  315-6213  not populated
+Derby Owners Club World Edition (Rev D) 840-0088C  22336D   7 (128Mb)  315-6319A  315-6213  not populated  2 MaskROM are different from Rev C
 Giga Wing 2                             841-0014C  22270    5 (128Mb)  315-6319A  315-6213  317-5064-COM
 Moero Justice Gakuen / Project Justice  841-0015C  23548A  11 (128Mb)  315-6319A  315-6213  317-5065-COM
 Samba de Amigo Ver.2000                 840-0047C  23600    ? (128Mb)  315-6319A  315-6213  317-0295-COM
@@ -368,13 +370,13 @@
 
       IC1   - 74LVCH16245A (16bit transceiver with direction pin)
       IC2   - XC3S50 Xilinx Spartan FPGA (TQFP144)
-      IC3   - PIC16C621A EPROM-Based 8-Bit CMOS Microcontroller (PDIP18) with internal memory.
+      IC3   - PIC16C621A EPROM-Based 8-Bit CMOS Microcontroller (PDIP18) with internal memory
               On the end of the number, -JPN means it requires Japanese BIOS, -COM will run with any BIOS
       IC4   - XCF01SVG Xilinx Platform Flash In-System Programmable Configuration PROMS (TSSOP20)
       IC5   - 74LVC08A (Quad 2-input AND gate)
       IC6   - 74LVCH16245A (16bit transceiver with direction pin)
       IC7   - empty socket for EPROM (DIP42), either 27C160 or 27C322
-  IC8-IC15  - S29GL512N FlashROM (TSOP56), 512Mb.
+  IC8-IC15  - S29GL512N FlashROM (TSOP56), 512Mb. Not all positions are populated
       IC16  - R3112N431A Low voltage detector with output delay (SOT-23-5)
       JP1   - JUMPER Sets the size of the EPROM. 1-2 = 32M, 2-3 = 16M
       JP2   - JUMPER unknown function
@@ -388,6 +390,57 @@
 Touch De Zunou (Rev A)    840-0166C  unpopulated   2 (512Mb)  XC3S50  317-0435-JPN  XCF01S  IC4# is marked "18"
 
 
+
+MASK B-F2X (C) Namco 2000
+|-------------------------------------------------------------------------------------|
+|                                                               ----CN2----            -|
+|                                                                                       |
+|7        LED1                                                                          |
+|                                                                                       |
+|6        MA23  MA22  MA21  MA20  MA19  MA18  MA17  MA16  MA15  MA14  MA13  MA12        |
+|                                                                                       |
+|5                                                                          ISSI        |
+|                                                                                       |
+|4        MA11  MA10  MA9   MA8   MA7   MA6   MA5   MA4   MA3   MA2   MA1   ISSI        | male side
+|                                                                                       |
+|3                                            OSC1                                      |
+|                                                                                       |
+|2       FLASH FLASH FLASH FLASH                    NAOD                                |
+|         FL3   FL2   FL1   FL0                     EC1B                                |
+|1 J J J                          X76F  NAOD                    SEGA                    |
+|  P P P                          100   EC2A                  315-5881                  |
+|  3 2 1                                                                                |
+|    A     B     C     D     E     F     H     J     K     L     M     N     P     R    |
+|             ----CN3----                                       ----CN1----             |
+|---------------------------------------------------------------------------------------|
+Notes:
+      The female side of the cart PCB only has traces
+
+        JP1 - JUMPER silkscreened   USE - NOT USE
+        JP2 - JUMPER silkscreened   64M - 128M
+        JP3 - JUMPER silkscreened BANK0 - BANK1
+         1F - FLASHROM (SOIC8) Xicor X76F100 Secure SerialFlash. Silkscreened X76F100
+         1H - NAODEC2A (QFP100) Altera MAX EPM7064S. Silkscreened NAODEC2A
+         1M - SEGA 315-5581 (QFP100). Probably some kind of FPGA or CPLD. Usually different per game
+              On the end of the number, -JPN means it requires Japanese BIOS, -COM will run with any BIOS
+2B,2C,2D,2F - DA28F640J5 FlashROM (SSOP56), 64Mb. Not all positions are populated. Silkscreened VOYAGER64
+              Looks like the equivalent of IC11/22 on Sega carts
+         2K - NAODEC1B (QFP100) Altera MAX EPM7064S. Silkscreened NAODEC1A
+         3J - oscillator 28.000MHz
+4B-4N,6B-6P - MASKROM (TSOP48), 128Mb. Not all positions are populated. Silkscreened MASK128MT
+      4P,5P - SRAM (SOJ28) 32kx8, ISSI IS61C256AH-15J
+   CN1/2/3  - connectors joining to main board
+
+
+   Games known to use this PCB include....
+                                  Sticker   FL0-FL3    # of SOP48  IC @ 1F        IC @ 1M
+ Game                              on cart   FLASHROM   FLASHROMs   X76F100        315-5581      Notes
+---------------------------------------------------------------------------------------------------------------------------------------
+/Shin Nihon Prowrestling                                                                         FL0 & FL1 have pin55 raised from PCB.
+\Toukon Retsuden 4 Arcade Edition  25349801   2 (64Mb)  15 (128Mb)  not populated  317-5040-com  They are connected togheter and go to pin89 on 2K.
+
+
+
       Note! Generally, games that require a special I/O board or controller will not boot at all with a
             standard NAOMI I/O board. Usually they display a message saying the I/O board is not acceptable
             or not connected properly.
@@ -4702,6 +4755,7 @@
 	ROM_LOAD("317-5072-com.pic", 0x00, 0x4000, CRC(3238ba01) SHA1(07c28f17c19eaa652295bbf2d3a96aa27c3748ae) )
 ROM_END
 
+
 ROM_START( cvsgd )
 	NAOMIGD_BIOS
 	NAOMI_DEFAULT_EEPROM
@@ -4719,6 +4773,28 @@
 ROM_END
 
 
+ROM_START( starseek )
+	NAOMIGD_BIOS
+	NAOMI_DEFAULT_EEPROM
+
+	DISK_REGION( "gdrom" )
+	DISK_IMAGE_READONLY( "gdl-0005", 0, SHA1(f5513c88528741798ee49f936b9b69480360f103) )
+
+	ROM_REGION( 0x50, "picreturn", ROMREGION_ERASE)
+
+	/*
+    Note:
+    There was no sticker or silk screen markings on this PIC.
+    I have used the product number as a label instead.
+
+    PIC16C621A-20 (317-0005-JPN)
+    Sticker: 253-5509-0005J
+    */
+	ROM_REGION( 0x4000, "pic", ROMREGION_ERASEFF)
+	ROM_LOAD("317-0005-jpn.pic", 0x00, 0x4000, CRC(19f8d4d0) SHA1(d256f26f757d7019cab7950d81992902cdb65e07) )
+ROM_END
+
+
 ROM_START( gundmxgd )
 	NAOMIGD_BIOS
 	NAOMI_DEFAULT_EEPROM
@@ -4752,6 +4828,7 @@
 	ROM_LOAD("317-5078-com.pic", 0x00, 0x4000, CRC(e7bb621d) SHA1(0882d0e12ca4fb81dda2268cd12724a10278c220) )
 ROM_END
 
+
 ROM_START( ikaruga )
 	NAOMIGD_BIOS
 	NAOMI_DEFAULT_EEPROM
@@ -5750,7 +5827,7 @@
 GAME( 2001, sfz3ugd,   naomigd,  naomigd,  naomi,    sfz3ugd, ROT0,   "Capcom",                 "Street Fighter Zero 3 Upper (GDL-0002)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND|GAME_NOT_WORKING )
 //GDL-0003
 GAME( 2001, cvsgd,     naomigd,  naomigd,  naomi,    naomi,   ROT0,   "Capcom / SNK",           "Capcom Vs. SNK Millenium Fight 2000 Pro (GDL-0004)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND|GAME_NOT_WORKING )
-//GDL-0005 Doki Doki Idol Star Seeker
+GAME( 2001, starseek,  naomigd,  naomigd,  naomi,    naomi,   ROT0,   "G-Rev",                  "Doki Doki Idol Star Seeker (GDL-0005)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 2001, gundmxgd,  naomigd,  naomigd,  naomi,    naomi,   ROT0,   "Capcom",                 "Mobile Suit Gundam: Federation VS Zeon DX  (GDL-0006)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND|GAME_NOT_WORKING )
 //GDL-0007 Capcom Vs. SNK 2
 GAME( 2001, cvs2gd,    naomigd,  naomigd,  naomi,    naomi,   ROT0,   "Capcom / SNK",           "Capcom Vs. SNK 2 Millionaire Fighting 2001 (Rev A) (GDL-0007A)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND|GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/nbmj9195.c src/mame/drivers/nbmj9195.c
--- src-old/mame/drivers/nbmj9195.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/nbmj9195.c	2010-08-19 00:26:14.000000000 -0700
@@ -496,7 +496,7 @@
 
 static MACHINE_RESET( sailorws )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	// initialize TMPZ84C011 PIO
@@ -509,7 +509,7 @@
 
 static DRIVER_INIT( nbmj9195 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *ROM = memory_region(machine, "audiocpu");
 
 	// sound program patch
diff -Nru src-old/mame/drivers/neodrvr.c src/mame/drivers/neodrvr.c
--- src-old/mame/drivers/neodrvr.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/neodrvr.c	2010-08-30 08:20:58.000000000 -0700
@@ -747,7 +747,7 @@
     Information about this can be found at 'The NeoGeo Master List' (unofficial) - http://www.neo-geo.com
     and the official NeoGeo museum - http://neogeomuseum.snkplaymore.co.jp/english/index.php
     Several unofficial 'conversions' of these sets can be found across the internet.
-    For completeness sake: Some of these have sets have been relesead for the CD system.
+    For completeness sake: Some of these have sets have been released for the CD system.
 
 
     M1 (sound driver) rom information:
@@ -1262,7 +1262,7 @@
 	ROM_LOAD16_BYTE( "017-c4.bin", 0x200001, 0x100000, CRC(f4f3c9cb) SHA1(8faafa89dbd0345218f71f891419d2e4e7578200) ) /* Plane 2,3 */
 ROM_END
 
-ROM_START( sengokh ) /* AES VERSION */
+ROM_START( sengokuh ) /* AES VERSION */
 	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "017-hp1.bin", 0x000000, 0x080000, CRC(33eccae0) SHA1(000ccf9a9c73df75eeba3f2c367c3a1a9e0a3a6b) )
 	ROM_LOAD16_WORD_SWAP( "017-p2.bin",  0x080000, 0x020000, CRC(3024bbb3) SHA1(88892e1292dd60f35a76f9a22e623d4f0f9693cc) )
@@ -2013,14 +2013,6 @@
 	ROM_LOAD16_BYTE( "045-c6.bin", 0x800001, 0x080000, CRC(4fa71252) SHA1(afe374a9d1f2d955a59efe7b6196b89e021b164c) ) /* Plane 2,3 */
 ROM_END
 
-	/* Old version looked like this; p's on eprom?
-    ROM_START( samsho )
-    ROM_REGION( 0x180000, "maincpu", 0 )
-    ROM_LOAD16_WORD_SWAP( "045-p1.bin", 0x000000, 0x080000, CRC(80aa6c97) SHA1(6e07a4aa7b4719ae487a10cee9389cb55a370a7a) )
-    ROM_LOAD16_WORD_SWAP( "045-p2.bin", 0x080000, 0x080000, CRC(71768728) SHA1(9ff0e01d3fb73ad04279d4fdf4c53c3160888179) )
-    ROM_LOAD16_WORD_SWAP( "045-p3.bin", 0x100000, 0x080000, CRC(38ee9ba9) SHA1(48190699a6be83cb6257365ae81f93fdd23abe09) )
-    */
-
 ROM_START( tophuntr ) /* MVS VERSION */
 	ROM_REGION( 0x200000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "046-p1.bin", 0x000000, 0x100000, CRC(69fa9e29) SHA1(9a40a16163193bb506a32bd34f6323b25ec69622) )
@@ -2304,7 +2296,7 @@
 ROM_END
 
 ROM_START( aof2 ) /* MVS AND AES VERSION */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "056-p1.bin", 0x000000, 0x100000, CRC(a3b1d021) SHA1(ee42f3ca4516226b0088d0303ed28e3ecdabcd71) )
 
 	NEO_SFIX_128K( "056-s1.bin", CRC(8b02638e) SHA1(aa4d28804ca602da776948b5f223ea89e427906b) )
@@ -2330,7 +2322,7 @@
 ROM_END
 
 ROM_START( aof2a ) /* MVS AND AES VERSION */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "056-p1.bin",  0x000000, 0x100000, CRC(a3b1d021) SHA1(ee42f3ca4516226b0088d0303ed28e3ecdabcd71) )
 	/* the rom below acts as a patch to the program rom in the cart, replacing the first 512kb */
 	ROM_LOAD16_WORD_SWAP( "056-ep1.bin", 0x000000, 0x80000, CRC(75d6301c) SHA1(e72d15fba55f96be7b4fa29e705a7b78f56edf7d) )
@@ -2406,7 +2398,7 @@
 	ROM_LOAD16_BYTE( "058-c6.bin", 0x800001, 0x200000, CRC(8ff1f43d) SHA1(6180ceb5412a3e2e34e9513a3283b9f63087f747) ) /* Plane 2,3 */
 ROM_END
 
-ROM_START( fatfursa ) /* MVS AND AES VERSION */
+ROM_START( fatfurspa ) /* MVS AND AES VERSION */
 	ROM_REGION( 0x180000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "058-p1.bin", 0x000000, 0x100000, CRC(2f585ba2) SHA1(429b4bf43fb9b1082c15d645ca328f9d175b976b) )
 	ROM_LOAD16_WORD_SWAP( "058-p2.bin", 0x100000, 0x080000, CRC(d7c71a6b) SHA1(b3428063031a2e5857da40a5d2ffa87fb550c1bb) )
@@ -2461,7 +2453,7 @@
 ROM_END
 
 ROM_START( fightfev ) /* MVS ONLY RELEASE */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "060-p1.bin", 0x000000, 0x080000, CRC(3032041b) SHA1(4b8ed2e6f74579ea35a53e06ccac42d6905b0f51) )
 	ROM_LOAD16_WORD_SWAP( "060-p2.bin", 0x080000, 0x080000, CRC(b0801d5f) SHA1(085746d8f5d271d5f84ccbb7f577193c391f88d4) )
 
@@ -2483,7 +2475,7 @@
 ROM_END
 
 ROM_START( fightfeva ) /* MVS ONLY RELEASE */
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "060-p1.rom", 0x0000000, 0x100000, CRC(2a104b50) SHA1(3eb663d3df7074e1cdf4c0e450a35c9cf55d8979) )
 	/* There was also a copy of the 060-p1.bin with the name 060-p2.bin maybe it should be loaded over the top or this
     larger rom is an older revision... */
@@ -2611,29 +2603,7 @@
 	ROM_LOAD16_BYTE( "063-c8.bin", 0xc00001, 0x200000, CRC(1ffc6dfa) SHA1(acea18aca76c072e0bac2a364fc96d49cfc86e77) ) /* Plane 2,3 */
 ROM_END
 
-ROM_START( wh2j ) /* MVS VERSION */
-	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "064-p1.bin", 0x100000, 0x100000, CRC(385a2e86) SHA1(cfde4a1aeae038a3d6ca9946065624f097682d3d) )
-	ROM_CONTINUE( 0x000000, 0x100000 )
-
-	NEO_SFIX_128K( "064-s1.bin", CRC(2a03998a) SHA1(5e33f469982f12d4622a06d323a345f192bf88e6) )
-
-	NEO_BIOS_AUDIO_128K( "064-m1.bin", CRC(d2eec9d3) SHA1(09478787045f1448d19d064dd3d540d1741fd619) )
-
-	ROM_REGION( 0x400000, "ymsnd", 0 )
-	ROM_LOAD( "064-v1.bin", 0x000000, 0x200000, CRC(aa277109) SHA1(35c22b15bb0a4d0ab118cb22a2d450d03995a17c) )
-	ROM_LOAD( "064-v2.bin", 0x200000, 0x200000, CRC(b6527edd) SHA1(2bcf5bfa6e117cf4a3728a5e5f5771313c93f22a) )
-
-	NO_DELTAT_REGION
-
-	ROM_REGION( 0x1000000, "sprites", 0 )
-	ROM_LOAD16_BYTE( "064-c13.bin", 0x000000, 0x400000, CRC(771a6365) SHA1(646bdf3a79819fbca98f513c172b9e9500c073be) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "064-c24.bin", 0x000001, 0x400000, CRC(e7863a05) SHA1(39d34119137216f914b8b8b7b3e622a6c210f130) ) /* Plane 2,3 */
-	ROM_LOAD16_BYTE( "064-c57.bin", 0x800000, 0x400000, CRC(64594ed4) SHA1(982dbb932c0cb2eb9292bf19c463fd618c8180f3) ) /* Plane 0,1 */
-	ROM_LOAD16_BYTE( "064-c68.bin", 0x800001, 0x400000, CRC(6e385398) SHA1(e74a0e72876bff8766152b76e5d94f2958b03cf2) ) /* Plane 2,3 */
-ROM_END
-
-ROM_START( wh2jh ) /* AES VERSION */
+ROM_START( wh2j ) /* MVS AND AES VERSION */
 	ROM_REGION( 0x200000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "064-p1.bin", 0x100000, 0x100000, CRC(385a2e86) SHA1(cfde4a1aeae038a3d6ca9946065624f097682d3d) )
 	ROM_CONTINUE( 0x000000, 0x100000 )
@@ -3395,11 +3365,9 @@
 ROM_END
 
 ROM_START( rbff1a ) /* MVS VERSION */
-	ROM_REGION( 0x300000, "maincpu", 0 )
-
 	/* This is a bug fixed revision applied over the original cart. The original P1 and P2 stayed in the cart and this */
 	/* 512k ROM was added to replace the first 512k of P1. */
-
+	ROM_REGION( 0x300000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "095-p1.bin",  0x000000, 0x100000, CRC(63b4d8ae) SHA1(03aa9f6bab6aee685d1b57a52823797704eea845) )
 	ROM_LOAD16_WORD_SWAP( "095-p2.bin",  0x100000, 0x200000, CRC(cc15826e) SHA1(44d6ac6c0ca697a6f367dcfd809b1e1771cb0635) )
 	/* the rom below acts as a patch to the program rom in the cart, replacing the first 512kb */
@@ -4019,7 +3987,7 @@
 ROM_END
 
 ROM_START( twinspri )
-	ROM_REGION( 0x400000, "maincpu", 0 )
+	ROM_REGION( 0x200000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "224-p1.bin", 0x100000, 0x100000, CRC(7697e445) SHA1(5b55ca120f77a931d40719b14e0bfc8cac1d628c) )
 	ROM_CONTINUE( 0x000000, 0x100000 )
 
@@ -4087,7 +4055,7 @@
 ROM_END
 
 ROM_START( ghostlop )
-	ROM_REGION( 0x200000, "maincpu", 0 )
+	ROM_REGION( 0x100000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "gl-p1.bin", 0x000000, 0x100000, CRC(6033172e) SHA1(f57fb706aa8dd9e5f9e992a5d35c1799578b59f8) )
 
 	NEO_SFIX_128K( "gl-s1.bin", CRC(83c24e81) SHA1(585ef209d8bfc23bdccc1f37d8b764eeedfedc1c) )
@@ -4315,7 +4283,8 @@
 
 ROM_START( irrmaze ) /* MVS ONLY RELEASE */
 	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "236-p1.bin", 0x000000, 0x200000, CRC(6d536c6e) SHA1(87d66683304a6617da8af7dfdfcbf4a3ab63056a) )
+	ROM_LOAD16_WORD_SWAP( "236-p1.bin", 0x100000, 0x100000, CRC(4c2ff660) SHA1(4a0cbd09044648ff9ec67723729f16d422c34bda) )
+	ROM_CONTINUE( 0x000000, 0x100000 )
 
 	NEO_SFIX_128K( "236-s1.bin", CRC(5d1ca640) SHA1(40a9668a1742a44597a07ce72273d17119815637) )
 
@@ -4385,7 +4354,7 @@
 	ROM_LOAD16_BYTE( "238-c8.bin", 0x1800001, 0x400000, CRC(1c7c2efb) SHA1(b055ee43cbdaf9a3cb19e4e1f9dd2c40bde69d70) ) /* Plane 2,3 */
 ROM_END
 
-ROM_START( shocktra ) /* MVS ONLY RELEASE */
+ROM_START( shocktroa ) /* MVS ONLY RELEASE */
 	ROM_REGION( 0x500000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "238-pg1.bin", 0x000000, 0x100000, CRC(efedf8dc) SHA1(f638df9bf7aa7d514ee2bccfc7f2adbf39ca83fc) )
 	ROM_LOAD16_WORD_SWAP( "238-p2.bin", 0x100000, 0x400000, CRC(5b4a09c5) SHA1(de04036cba2da4bb2da73d902d1822b82b4f67a9) )
@@ -4836,11 +4805,11 @@
 	ROM_LOAD16_BYTE( "250-c6.bin", 0x2000001, 0x800000, CRC(83e3e69d) SHA1(39be66287696829d243fb71b3fb8b7dc2bc3298f) ) /* Plane 0,1 */
 ROM_END
 
-ROM_START( kof99 ) /* Original Version - Encrypted Code & GFX */ /* AES VERSION */
+ROM_START( kof99 ) /* Original Version - Encrypted Code & GFX */ /* MVS VERSION */
 	ROM_REGION( 0x900000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "251-sma.kc",  0x0c0000, 0x040000, CRC(6c9d0647) SHA1(2a0ce62ca6c18007e8fbe1b60475c7874ab79389) )	/* stored in the custom chip */
-	ROM_LOAD16_WORD_SWAP( "251-p1.bin",  0x100000, 0x400000, CRC(006e4532) SHA1(47791ab4044ad55988b1d3412d95b65b91a163c8) )
-	ROM_LOAD16_WORD_SWAP( "251-pg2.bin", 0x500000, 0x400000, CRC(d9057f51) SHA1(8d365b4dd40351495df99d6c765df1434b0b0548) )
+	ROM_LOAD16_WORD_SWAP( "251-sma.ka", 0x0c0000, 0x040000, CRC(7766d09e) SHA1(4e0a49d1ad669a62676cb30f527c6590cde80194) )	/* stored in the custom chip */
+	ROM_LOAD16_WORD_SWAP( "251-p1.bin", 0x100000, 0x400000, CRC(006e4532) SHA1(47791ab4044ad55988b1d3412d95b65b91a163c8) )
+	ROM_LOAD16_WORD_SWAP( "251-p2.bin", 0x500000, 0x400000, CRC(90175f15) SHA1(aa9e75810438a8b45808a8bf32cb04d91b5c0b3a) )
 
 	ROM_Y_ZOOM
 
@@ -4872,11 +4841,11 @@
 	ROM_LOAD16_BYTE( "251-c8.bin", 0x3000001, 0x800000, CRC(8d921c68) SHA1(42acf1d27d52a8e3b6262eb7df50693c0b135565) ) /* Plane 2,3 */
 ROM_END
 
-ROM_START( kof99a ) /* Original Version - Encrypted Code & GFX */ /* MVS VERSION */
+ROM_START( kof99h ) /* Original Version - Encrypted Code & GFX */ /* AES VERSION */
 	ROM_REGION( 0x900000, "maincpu", 0 )
-	ROM_LOAD16_WORD_SWAP( "251-sma.ka", 0x0c0000, 0x040000, CRC(7766d09e) SHA1(4e0a49d1ad669a62676cb30f527c6590cde80194) )	/* stored in the custom chip */
-	ROM_LOAD16_WORD_SWAP( "251-p1.bin", 0x100000, 0x400000, CRC(006e4532) SHA1(47791ab4044ad55988b1d3412d95b65b91a163c8) )
-	ROM_LOAD16_WORD_SWAP( "251-p2.bin", 0x500000, 0x400000, CRC(90175f15) SHA1(aa9e75810438a8b45808a8bf32cb04d91b5c0b3a) )
+	ROM_LOAD16_WORD_SWAP( "251-sma.kc",  0x0c0000, 0x040000, CRC(6c9d0647) SHA1(2a0ce62ca6c18007e8fbe1b60475c7874ab79389) )	/* stored in the custom chip */
+	ROM_LOAD16_WORD_SWAP( "251-p1.bin",  0x100000, 0x400000, CRC(006e4532) SHA1(47791ab4044ad55988b1d3412d95b65b91a163c8) )
+	ROM_LOAD16_WORD_SWAP( "251-pg2.bin", 0x500000, 0x400000, CRC(d9057f51) SHA1(8d365b4dd40351495df99d6c765df1434b0b0548) )
 
 	ROM_Y_ZOOM
 
@@ -4911,6 +4880,7 @@
 ROM_START( kof99e ) /* Original Version - Encrypted Code & GFX */
 	ROM_REGION( 0x900000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "251-sma.ka", 0x0c0000, 0x040000, CRC(7766d09e) SHA1(4e0a49d1ad669a62676cb30f527c6590cde80194) )	/* stored in the custom chip */
+	/* Is the SMA for this set correct? A set with this layout and a SMA.KB is known */
 	ROM_LOAD16_WORD_SWAP( "251-ep1.p1", 0x100000, 0x200000, CRC(1e8d692d) SHA1(eea1aa8c0a17f089ac14831889c36535e559072c) )
 	ROM_LOAD16_WORD_SWAP( "251-ep2.p2", 0x300000, 0x200000, CRC(d6206e5a) SHA1(0e1100d03c40c6d5cfa899d009e319ae73fce6b8) )
 	ROM_LOAD16_WORD_SWAP( "251-ep3.p3", 0x500000, 0x200000, CRC(d58c3ef8) SHA1(f927d90d55b49944f448d6286e0cb913cc70ade1) )
@@ -5429,7 +5399,6 @@
 
 ROM_START( sengoku3 ) /* Original Version - Encrypted GFX */
 	ROM_REGION( 0x200000, "maincpu", 0 )
-	//ROM_LOAD16_WORD_SWAP( "261-p1.bin", 0x100000, 0x100000, CRC(5b557201) SHA1(d01421d1dc80fe7d2a46b9f79c0f344b3c81c1e7) ) this one is almost certainly bad
 	ROM_LOAD16_WORD_SWAP( "261-ph1.bin", 0x100000, 0x100000, CRC(e0d4bc0a) SHA1(8df366097f224771ca6d1aa5c1691cd46776cd12) )
 	ROM_CONTINUE( 0x000000, 0x100000 )
 
@@ -5441,7 +5410,7 @@
 	ROM_REGION( 0x20000, "fixedbios", 0 )
 	ROM_LOAD( "sfix.sfix", 0x000000, 0x20000, CRC(c2ea0cfd) SHA1(fd4a618cdcdbf849374f0a50dd8efe9dbab706c3) )
 
-	NEO_BIOS_AUDIO_128K( "261-m1.bin", CRC(36ed9cdd) SHA1(78a7d755e9e9f52255ac6228d9d402fd6a02c126) )
+	NEO_BIOS_AUDIO_512K( "261-m1.bin", CRC(7d501c39) SHA1(8e6bcc428f5ac7532d9c9be7e07ad0821461a080) )
 
 	ROM_REGION( 0x0e00000, "ymsnd", 0 )
 	ROM_LOAD( "261-v1.bin", 0x000000, 0x400000, CRC(64c30081) SHA1(f9ebd20cf59b72e864b7274c1bdb6d99ecaf4595) )
@@ -5532,10 +5501,8 @@
 ROM_END
 
 ROM_START( mslug4 ) /* Original Version - Encrypted GFX */ /* MVS VERSION */
-	/* There also exist carts where p1 label is pg1;
-    The PG1 revision has a Japanese cart label, SN 02Jxxxxx
-    The P1 revision has a US/EUR cart label, SN 02Txxxxx
-    Rom data on both is identical.
+	/* There also exist carts where p1 label is pg1; the PG1 revision has a Japanese cart label, SN 02Jxxxxx
+    The P1 revision has a US/EUR cart label, SN 02Txxxxx ; Rom data on both is identical.
     These carts were manufactured by Mega Enterprise, not SNK. */
 	ROM_REGION( 0x500000, "maincpu", 0 )
 	ROM_LOAD16_WORD_SWAP( "263-p1.bin", 0x000000, 0x100000, CRC(27e4def3) SHA1(a08785e8145981bb6b5332a3b2df7eb321253cca) )
@@ -8327,7 +8294,7 @@
 GAME( 1991, kotm,      neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "King of the Monsters (set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1991, kotmh,     kotm,     neogeo,   neogeo,   neogeo,   ROT0, "SNK", "King of the Monsters (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1991, sengoku,   neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Sengoku / Sengoku Denshou (set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1991, sengokh,   sengoku,  neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Sengoku / Sengoku Denshou (set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1991, sengokuh,  sengoku,  neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Sengoku / Sengoku Denshou (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1991, burningf,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Burning Fight (set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1991, burningfh, burningf, neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Burning Fight (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1990, lbowling,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "League Bowling", GAME_SUPPORTS_SAVE )
@@ -8364,7 +8331,7 @@
 GAME( 1994, aof2,      neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Art of Fighting 2 / Ryuuko no Ken 2 (set 1)", GAME_SUPPORTS_SAVE )
 GAME( 1994, aof2a,     aof2,     neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Art of Fighting 2 / Ryuuko no Ken 2 (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1993, fatfursp,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Fatal Fury Special / Garou Densetsu Special (set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1993, fatfursa,  fatfursp, neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Fatal Fury Special / Garou Densetsu Special (set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1993, fatfurspa, fatfursp, neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Fatal Fury Special / Garou Densetsu Special (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1995, savagere,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Savage Reign / Fu'un Mokushiroku - kakutou sousei", GAME_SUPPORTS_SAVE )
 GAME( 1994, ssideki2,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Super Sidekicks 2 - The World Championship / Tokuten Ou 2 - real fight football", GAME_SUPPORTS_SAVE )
 GAME( 1994, samsho2,   neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Samurai Shodown II / Shin Samurai Spirits - Haohmaru jigokuhen", GAME_SUPPORTS_SAVE )
@@ -8408,7 +8375,7 @@
 GAME( 1998, neocup98,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "SNK", "Neo-Geo Cup '98 - The Road to the Victory", GAME_SUPPORTS_SAVE )
 GAME( 1999, mslugx,    neogeo,   neogeo,   neogeo,   mslugx,   ROT0, "SNK", "Metal Slug X - Super Vehicle-001", GAME_SUPPORTS_SAVE )
 GAME( 1999, kof99,     neogeo,   neogeo,   neogeo,   kof99,    ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (set 1)" , GAME_SUPPORTS_SAVE ) /* Encrypted Code & GFX */
-GAME( 1999, kof99a,    kof99,    neogeo,   neogeo,   kof99,    ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (set 2)" , GAME_SUPPORTS_SAVE ) /* Encrypted Code & GFX, crashes going into attract demo */
+GAME( 1999, kof99h,    kof99,    neogeo,   neogeo,   kof99,    ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (set 2)" , GAME_SUPPORTS_SAVE ) /* Encrypted Code & GFX, crashes going into attract demo */
 GAME( 1999, kof99e,    kof99,    neogeo,   neogeo,   kof99,    ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (earlier)" , GAME_SUPPORTS_SAVE ) /* Encrypted Code & GFX */
 GAME( 1999, kof99k,    kof99,    neogeo,   neogeo,   kof99k,   ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (Korean release)" , GAME_SUPPORTS_SAVE )	/* Encrypted GFX */
 GAME( 1999, kof99p,    kof99,    neogeo,   neogeo,   neogeo,   ROT0, "SNK", "The King of Fighters '99 - Millennium Battle (prototype)", GAME_SUPPORTS_SAVE )
@@ -8478,8 +8445,7 @@
 GAME( 1992, wh1h,      wh1,      neogeo,   neogeo,   neogeo,   ROT0, "Alpha Denshi Co.", "World Heroes (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1992, wh1ha,     wh1,      neogeo,   neogeo,   neogeo,   ROT0, "Alpha Denshi Co.", "World Heroes (set 3)", GAME_SUPPORTS_SAVE )
 GAME( 1993, wh2,       neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK",              "World Heroes 2", GAME_SUPPORTS_SAVE )
-GAME( 1994, wh2j,      neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "World Heroes 2 Jet (set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1994, wh2jh,     wh2j,     neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "World Heroes 2 Jet (set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1994, wh2j,      neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "World Heroes 2 Jet", GAME_SUPPORTS_SAVE )
 GAME( 1994, aodk,      neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "Aggressors of Dark Kombat / Tsuukai GANGAN Koushinkyoku", GAME_SUPPORTS_SAVE )
 GAME( 1995, whp,       neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "World Heroes Perfect", GAME_SUPPORTS_SAVE )
 GAME( 1995, mosyougi,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "ADK / SNK",        "Syougi No Tatsujin - Master of Syougi", GAME_SUPPORTS_SAVE )
@@ -8539,7 +8505,7 @@
 GAME( 1996, pgoal,     neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Pleasure Goal / Futsal - 5 on 5 Mini Soccer", GAME_SUPPORTS_SAVE )
 GAME( 1996, stakwin2,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Stakes Winner 2", GAME_SUPPORTS_SAVE )
 GAME( 1997, shocktro,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Shock Troopers (set 1)", GAME_SUPPORTS_SAVE )
-GAME( 1997, shocktra,  shocktro, neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Shock Troopers (set 2)", GAME_SUPPORTS_SAVE )
+GAME( 1997, shocktroa, shocktro, neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Shock Troopers (set 2)", GAME_SUPPORTS_SAVE )
 GAME( 1998, shocktr2,  neogeo,   neogeo,   neogeo,   neogeo,   ROT0, "Saurus", "Shock Troopers - 2nd Squad", GAME_SUPPORTS_SAVE )
 GAME( 1998, lans2004,  shocktr2, neogeo,   neogeo,   lans2004, ROT0, "bootleg", "Lansquenet 2004 (Shock Troopers - 2nd Squad bootleg)", GAME_SUPPORTS_SAVE )
 
diff -Nru src-old/mame/drivers/neogeo.c src/mame/drivers/neogeo.c
--- src-old/mame/drivers/neogeo.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/neogeo.c	2010-08-19 01:27:05.000000000 -0700
@@ -260,7 +260,7 @@
 }
 
 
-void neogeo_set_display_counter_msb( const address_space *space, UINT16 data )
+void neogeo_set_display_counter_msb( address_space *space, UINT16 data )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 
@@ -270,7 +270,7 @@
 }
 
 
-void neogeo_set_display_counter_lsb( const address_space *space, UINT16 data )
+void neogeo_set_display_counter_lsb( address_space *space, UINT16 data )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 
@@ -507,7 +507,7 @@
 	else
 	{
 		state->recurse = 1;
-		ret = memory_read_word(space, cpu_get_pc(space->cpu));
+		ret = space->read_word(cpu_get_pc(space->cpu));
 		state->recurse = 0;
 	}
 
@@ -717,7 +717,7 @@
 }
 
 
-void neogeo_set_main_cpu_bank_address( const address_space *space, UINT32 bank_address )
+void neogeo_set_main_cpu_bank_address( address_space *space, UINT32 bank_address )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 
@@ -753,7 +753,7 @@
 
 static void main_cpu_banking_init( running_machine *machine )
 {
-	const address_space *mainspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *mainspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* create vector banks */
 	memory_configure_bank(machine, NEOGEO_BANK_VECTORS, 0, 1, memory_region(machine, "mainbios"), 0);
@@ -784,7 +784,7 @@
 }
 
 
-static void audio_cpu_bank_select( const address_space *space, int region, UINT8 bank )
+static void audio_cpu_bank_select( address_space *space, int region, UINT8 bank )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 
@@ -828,7 +828,7 @@
 }
 
 
-static void _set_audio_cpu_rom_source( const address_space *space )
+static void _set_audio_cpu_rom_source( address_space *space )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 
@@ -849,7 +849,7 @@
 }
 
 
-static void set_audio_cpu_rom_source( const address_space *space, UINT8 data )
+static void set_audio_cpu_rom_source( address_space *space, UINT8 data )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 	state->audio_cpu_rom_source = data;
@@ -1117,7 +1117,7 @@
 {
 	neogeo_state *state = machine->driver_data<neogeo_state>();
 	offs_t offs;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* reset system control registers */
 	for (offs = 0; offs < 8; offs++)
diff -Nru src-old/mame/drivers/ninjakd2.c src/mame/drivers/ninjakd2.c
--- src-old/mame/drivers/ninjakd2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/ninjakd2.c	2010-08-19 07:19:38.000000000 -0700
@@ -1446,8 +1446,8 @@
 
 static DRIVER_INIT( bootleg )
 {
-	const address_space *space = cputag_get_address_space(machine, "soundcpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "soundcpu") + 0x10000);
+	address_space *space = cputag_get_address_space(machine, "soundcpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "soundcpu") + 0x10000);
 
 	gfx_unscramble(machine);
 }
diff -Nru src-old/mame/drivers/niyanpai.c src/mame/drivers/niyanpai.c
--- src-old/mame/drivers/niyanpai.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/niyanpai.c	2010-08-19 00:26:14.000000000 -0700
@@ -176,7 +176,7 @@
 
 static MACHINE_RESET( niyanpai )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	// initialize TMPZ84C011 PIO
@@ -246,7 +246,7 @@
 
 static CUSTOM_INPUT( musobana_outcoin_flag_r )
 {
-	const address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(field->port->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	// tmp68301_parallel_interface[0x05]
 	//  bit 0   coin counter
 	//  bit 2   motor on
diff -Nru src-old/mame/drivers/norautp.c src/mame/drivers/norautp.c
--- src-old/mame/drivers/norautp.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/norautp.c	2010-08-26 08:21:19.000000000 -0700
@@ -14,7 +14,7 @@
    * Noraut Deluxe Poker (console),       198?,  Noraut Ltd.
    * Noraut Deluxe Poker (bootleg),       198?,  Unknown.
    * Noraut Joker Poker (original),       198?,  Noraut Ltd.
-   * Noraut Joker Poker (Prologic HW),    198?,  Prologic / Noraut Ltd.
+   * Noraut Joker Poker (Prologic HW),    198?,  Video Fun Games Ltd.
    * Noraut Joker Poker (alt),            1988,  Noraut Ltd.
    * Noraut Red Hot Joker Poker,          1988,  Noraut Ltd.
    * Noraut Red Hot Joker Poker (alt HW), 198?,  Noraut Ltd.
@@ -848,10 +848,12 @@
 	AM_RANGE(0x6000, 0x67ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram) /* 6116 */
 ADDRESS_MAP_END
 
+#ifdef UNUSED_CODE
 static ADDRESS_MAP_START( norautx8_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM	/* need to be checked */
 	AM_RANGE(0xc000, 0xc7ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram) /* 6116 */
 ADDRESS_MAP_END
+#endif
 
 static ADDRESS_MAP_START( kimble_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0xbfff) AM_ROM
@@ -1322,6 +1324,7 @@
 MACHINE_DRIVER_END
 
 
+#ifdef UNUSED_CODE
 static MACHINE_DRIVER_START( norautx8 )
 	MDRV_IMPORT_FROM(noraut_base)
 
@@ -1330,6 +1333,7 @@
 	MDRV_CPU_PROGRAM_MAP(norautx8_map)
 	MDRV_CPU_VBLANK_INT("screen", irq0_line_hold)
 MACHINE_DRIVER_END
+#endif
 
 
 static MACHINE_DRIVER_START( kimble )
@@ -3477,7 +3481,7 @@
 GAMEL( 198?, norautdx, 0,       norautp,  norautpn, 0,   ROT0, "Noraut Ltd.",              "Noraut Deluxe Poker (console)",       0,                layout_noraut12 )
 GAMEL( 198?, norautpn, norautp, norautp,  norautpn, 0,   ROT0, "bootleg",                  "Noraut Deluxe Poker (bootleg)",       0,                layout_noraut12 )
 GAMEL( 198?, norautjo, 0,       norautp,  mainline, 0,   ROT0, "Noraut Ltd.",              "Noraut Joker Poker (original)",       0,                layout_noraut12 )
-GAMEL( 198?, norautpl, 0,       norautpl, mainline, 0,   ROT0, "Prologic / Noraut Ltd.",   "Noraut Joker Poker (Prologic HW)",    0,                layout_noraut12 )
+GAMEL( 198?, norautpl, 0,       norautpl, mainline, 0,   ROT0, "Video Fun Games Ltd.",     "Noraut Joker Poker (Prologic HW)",    0,                layout_noraut12 )
 GAMEL( 1988, norautjp, norautp, norautp,  norautp,  0,   ROT0, "Noraut Ltd.",              "Noraut Joker Poker (alt)",            0,                layout_noraut11 )
 GAMEL( 1988, norautrh, 0,       norautp,  norautrh, 0,   ROT0, "Noraut Ltd.",              "Noraut Red Hot Joker Poker",          0,                layout_noraut12 )
 GAMEL( 198?, norautra, 0,       norautp,  norautrh, 0,   ROT0, "Noraut Ltd.",              "Noraut Red Hot Joker Poker (alt HW)", 0,                layout_noraut12 ) // 1-bet?? where??...
diff -Nru src-old/mame/drivers/nycaptor.c src/mame/drivers/nycaptor.c
--- src-old/mame/drivers/nycaptor.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/nycaptor.c	2010-08-13 17:39:50.000000000 -0700
@@ -24,6 +24,8 @@
  - unknown R/W
  - 13th bit in color defs (priority? bit is set for all colors in spot1,
                            for 3/4 screen cols in spot2 etc)
+ - handle coin counters and coin lockout
+
 Notes :
 
  $d000 - MCU data read/write
@@ -129,17 +131,60 @@
 
 Stephh's additional notes (based on the game Z80 code and some tests) :
 
+1) 'nycaptor' and clones
+
+1a) 'nycaptor'
+
   - You need to press SERVICE1 while resetting the game to enter the "test mode".
     Note that the grid is always displayed, so it's IMPOSSIBLE to see what's in it 8(
-
   - When "Infinite Bullets" is set to ON, there is no timer to reload the bullets.
   - When "No Hit" Dip Switch is ON, damage is still incremented, but there are
     no test made if it reaches the limit (0x0a).
-
-  - Bit 2 of 0xd802 also determines the precision of a shot
+  - DSWC bit 2 also determines the precision of a shot
     (= range around a bullet where the enemies can be killed) :
-      * 0 : small range (0x0a)
-      * 1 : high  range (0x0c)
+      * 0 : small range (0x0a or 0x10)
+      * 1 : high  range (0x0c or 0x12)
+  - Even when "Coin Slots" is set to "1", pressing COIN2 will be based on "Coin B" settings.
+
+1b) 'colt'
+
+  - Due to patched code at 0x9fd, lives (BCD coded) settings are different than in 'nycaptor'.
+    Display at start will be lives-1, but it will also display "0" when you select 100 lives.
+  - The game is much harder than 'nycaptor' :
+      * Due to the 4 'nop' instructions at 0x0b03, you can't get any extra life.
+      * Due to patched code from 0x0bea to 0x0bf4, you lose a life as soon as you get hit
+        by en enemy or when you shoot at an innocent.
+        Furthermore, shooting birds kills you instead of recovering 3 "steps" of damage !
+  - I can't tell if it's an ingame bug of this bootleg, but the game hangs after bonus stage
+    (level 4) instead of looping back to level 1 with higher difficulty.
+    The game also frezees sometimes for some unknown reasons.
+
+2) 'cyclshtg' and clones
+
+2a) 'cyclshtg'
+
+  - Lives (BCD coded) settings are not read from MCU, but from table at 0x0fee.
+  - Even if it isn't mentionned in the manual, DSWB bit 7 allows you to reset damage to 0
+    at the end of a level (check code at 0x328d).
+  - When "Infinite Bullets" is set to ON, there is no timer to reload the bullets.
+    However, it's hard to notice as you don't see an indicator as in 'nycaptor'.
+  - There is a leftover from 'nycaptor' in CPU1 which reads DSWA bits 0 and 1 to determine
+    "Bonus Lives" settings (code at 0x009b). These values are overwritten via code in CPU 0.
+
+2b) 'bronx'
+
+  - Lives (BCD coded) settings are different than in 'cyclshtg' (table at 0x0fea).
+  - The game is much harder than 'cyclshtg' :
+      * You start with less lives with default settings (2 instead of 3).
+      * Due to the 'add  a,$00' instruction at 0x1131, you can't get any extra life
+        (when you get enough points, or even when you hit the "1UP" bonus).
+      * Due to extra code at 0x3062, you start the game as if you had already sustained
+        8 "steps" of damage. However, when you end a level, if "Damage Reset" Dip Switch
+        is ON, your damage will be reset to 0.
+        Furthermore, the game starts as if you had completed the 6 stages 8 times.
+      * Due to the 'ld   (ix+$0e),$08' instruction at 0x32b1, you also start the
+        other lives as if you had already sustained 8 "steps" of damage. However, again,
+        when you end a level, if "Damage Reset" Dip Switch is ON, your damage will be reset to 0.
 
 ***************************************************************************/
 
@@ -149,6 +194,7 @@
 #include "emu.h"
 #include "cpu/z80/z80.h"
 #include "cpu/m6805/m6805.h"
+#include "includes/taitoipt.h"
 #include "sound/ay8910.h"
 #include "sound/msm5232.h"
 #include "includes/nycaptor.h"
@@ -309,9 +355,9 @@
 	AM_RANGE(0xd400, 0xd400) AM_READWRITE(from_snd_r, sound_command_w)
 	AM_RANGE(0xd401, 0xd401) AM_READNOP
 	AM_RANGE(0xd403, 0xd403) AM_WRITE(sound_cpu_reset_w)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xd805, 0xd805) AM_READ(nycaptor_mcu_status_r1)
@@ -328,9 +374,9 @@
 static ADDRESS_MAP_START( nycaptor_slave_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0xc000, 0xc7ff) AM_READWRITE(nycaptor_videoram_r, nycaptor_videoram_w) AM_BASE_SIZE_MEMBER(nycaptor_state, videoram, videoram_size)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xdc00, 0xdc9f) AM_READWRITE(nycaptor_spriteram_r, nycaptor_spriteram_w)
@@ -415,9 +461,9 @@
 	AM_RANGE(0xd002, 0xd002) AM_READWRITE(nycaptor_generic_control_r, cyclshtg_generic_control_w)
 	AM_RANGE(0xd400, 0xd400) AM_READWRITE(from_snd_r, sound_command_w)
 	AM_RANGE(0xd403, 0xd403) AM_WRITE(sound_cpu_reset_w)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xd805, 0xd805) AM_READ(cyclshtg_mcu_status_r)
@@ -434,9 +480,9 @@
 static ADDRESS_MAP_START( cyclshtg_slave_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0xbfff) AM_ROM
 	AM_RANGE(0xc000, 0xcfff) AM_READWRITE(nycaptor_videoram_r, nycaptor_videoram_w) AM_BASE_SIZE_MEMBER(nycaptor_state, videoram, videoram_size)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xdc00, 0xdc9f) AM_READWRITE(nycaptor_spriteram_r, nycaptor_spriteram_w)
@@ -465,9 +511,9 @@
 	AM_RANGE(0xd400, 0xd400) AM_READWRITE(from_snd_r, sound_command_w)
 	AM_RANGE(0xd401, 0xd401) AM_READ(unk_r)
 	AM_RANGE(0xd403, 0xd403) AM_WRITE(sound_cpu_reset_w)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xd805, 0xd805) AM_READ(cyclshtg_mcu_status_r)
@@ -483,9 +529,9 @@
 static ADDRESS_MAP_START( bronx_slave_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0xc000, 0xcfff) AM_READWRITE(nycaptor_videoram_r, nycaptor_videoram_w) AM_BASE_SIZE_MEMBER(nycaptor_state, videoram, videoram_size)
-	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSW0")
-	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSW1")
-	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSW2")
+	AM_RANGE(0xd800, 0xd800) AM_READ_PORT("DSWA")
+	AM_RANGE(0xd801, 0xd801) AM_READ_PORT("DSWB")
+	AM_RANGE(0xd802, 0xd802) AM_READ_PORT("DSWC")
 	AM_RANGE(0xd803, 0xd803) AM_READ_PORT("IN0")
 	AM_RANGE(0xd804, 0xd804) AM_READ_PORT("IN1")
 	AM_RANGE(0xd805, 0xd805) AM_READ(cyclshtg_mcu_status_r1)
@@ -505,68 +551,18 @@
 ADDRESS_MAP_END
 
 
-/* Cycle Shooting */
-
-static INPUT_PORTS_START( cyclshtg )
-	PORT_START("DSW0")
-	PORT_DIPNAME( 0x04, 0x04, "Test Mode" )
-	PORT_DIPSETTING(	0x04, DEF_STR( Off ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
-
-	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Coin_A ) )
-	PORT_DIPSETTING(	0x10, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(	0x30, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( 2C_3C ) )
-	PORT_DIPSETTING(	0x20, DEF_STR( 1C_2C ) )
-
-	PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_B ) )
-	PORT_DIPSETTING(	0x40, DEF_STR( 2C_1C ) )
-	PORT_DIPSETTING(	0xc0, DEF_STR( 1C_1C ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( 2C_3C ) )
-	PORT_DIPSETTING(	0x80, DEF_STR( 1C_2C ) )
-
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Demo_Sounds ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( Off ) )
-	PORT_DIPSETTING(	0x08, DEF_STR( On ) )
-
-	PORT_START("DSW1")
-
-	PORT_START("DSW2")
-
-	PORT_START("IN0")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_START2 )//?
-	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
-	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Tilt ) )
-	PORT_DIPSETTING(	0x08, DEF_STR( No ) )
-	PORT_DIPSETTING(	0x00, DEF_STR( Yes ) )
-	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 )
-	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
-	PORT_BIT( 0xc0, IP_ACTIVE_LOW, IPT_UNKNOWN )
-
-
-	PORT_START("IN1")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
-
-	PORT_START("LIGHTX")
-	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_Y ) PORT_CROSSHAIR(X, 1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
-
-	PORT_START("LIGHTY")
-	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_X ) PORT_CROSSHAIR(Y, -1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
-INPUT_PORTS_END
-
-
+/* verified from Z80 code */
 static INPUT_PORTS_START( nycaptor )
-	PORT_START("DSW0")
-	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Bonus_Life ) )
-	PORT_DIPSETTING(	0x02, "20k, 80k then every 80k" )
-	PORT_DIPSETTING(	0x03, "50k, 150k then every 200k" )
-	PORT_DIPSETTING(	0x01, "100k, 300k then every 300k" )
-	PORT_DIPSETTING(	0x00, "150k, 300k then every 300k" )
-	PORT_DIPNAME( 0x04, 0x04, "Infinite Bullets (Cheat)")
+	PORT_START("DSWA")
+	PORT_DIPNAME( 0x03, 0x03, DEF_STR( Bonus_Life ) )       /* table at 0x00e5 in CPU1 - see notes for 'colt' */
+	PORT_DIPSETTING(	0x02, "20k 80k 80k+" )
+	PORT_DIPSETTING(	0x03, "50k 150k 200k+" )
+	PORT_DIPSETTING(	0x01, "100k 300k 300k+" )
+	PORT_DIPSETTING(	0x00, "150k 300k 300k+" )
+	PORT_DIPNAME( 0x04, 0x04, "Infinite Bullets")           /* see notes */
 	PORT_DIPSETTING(	0x04, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
-	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Lives ) )
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Lives ) )            /* values are read from the MCU */
 	PORT_DIPSETTING(	0x08, "1" )
 	PORT_DIPSETTING(	0x00, "2" )
 	PORT_DIPSETTING(	0x18, "3" )
@@ -581,7 +577,7 @@
 	PORT_DIPSETTING(	0x00, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x80, DEF_STR( On ) )
 
-	PORT_START("DSW1")
+	PORT_START("DSWB")
 	PORT_DIPNAME( 0x0f, 0x00, DEF_STR( Coin_A ) )
 	PORT_DIPSETTING(	0x0f, DEF_STR( 9C_1C ) )
 	PORT_DIPSETTING(	0x0e, DEF_STR( 8C_1C ) )
@@ -617,7 +613,7 @@
 	PORT_DIPSETTING(	0x60, DEF_STR( 1C_7C ) )
 	PORT_DIPSETTING(	0x70, DEF_STR( 1C_8C ) )
 
-	PORT_START("DSW2")
+	PORT_START("DSWC")
 	PORT_DIPNAME( 0x01, 0x01, "Freeze" )
 	PORT_DIPSETTING(	0x01, DEF_STR( Off ) )
 	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
@@ -644,17 +640,17 @@
 
 	PORT_START("IN0")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* IPT_START2 is some similar Taito games (eg: 'flstory') */
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )            /* IPT_START2 is some similar Taito games (eg: 'flstory') */
 	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
 	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_TILT )
 	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_COIN1 )
 	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_COIN2 )
-	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* "I/O ERROR" if active */
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )	/* "I/O ERROR" if active */
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )            /* "I/O ERROR" if active - code at 0x083d */
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )            /* "I/O ERROR" if active - code at 0x083d */
 
 	PORT_START("IN1")
 	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
-	PORT_BIT( 0xfe, IP_ACTIVE_HIGH, IPT_UNUSED )
+	PORT_BIT( 0xfe, IP_ACTIVE_LOW, IPT_UNUSED )
 
 	PORT_START("LIGHTX")
 	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_X ) PORT_CROSSHAIR(X, 1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
@@ -663,6 +659,90 @@
 	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_Y ) PORT_CROSSHAIR(Y, 1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
 INPUT_PORTS_END
 
+/* verified from Z80 code */
+static INPUT_PORTS_START( colt )
+	PORT_INCLUDE( nycaptor )
+
+	PORT_MODIFY("DSWA")
+	PORT_DIPNAME( 0x18, 0x18, DEF_STR( Lives ) )            /* see notes */
+	PORT_DIPSETTING(	0x08, "1" )
+	PORT_DIPSETTING(	0x10, "2" )
+	PORT_DIPSETTING(	0x18, "3" )
+	PORT_DIPSETTING(	0x00, "100" )
+INPUT_PORTS_END
+
+
+/* verified from Z80 code */
+static INPUT_PORTS_START( cyclshtg )
+	PORT_START("DSWA")
+	PORT_DIPUNUSED( 0x01, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x02, IP_ACTIVE_LOW )
+	TAITO_DSWA_BITS_2_TO_3
+	TAITO_COINAGE_JAPAN_OLD                                 /* coinage B isn't mentionned in the manual */
+
+	PORT_START("DSWB")
+	TAITO_DIFFICULTY
+	PORT_DIPNAME( 0x0c, 0x08, DEF_STR( Bonus_Life ) )       /* table at 0x100f - see notes for 'bronx' */
+	PORT_DIPSETTING(	0x0c, "150k 350k 200k+" )
+	PORT_DIPSETTING(	0x08, "200k 500k 300k+" )
+	PORT_DIPSETTING(	0x04, "300k 700k 400k+" )
+	PORT_DIPSETTING(	0x00, "400k 900k 500k+" )
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Lives ) )            /* see notes */
+	PORT_DIPSETTING(	0x00, "1" )
+	PORT_DIPSETTING(	0x30, "3" )
+	PORT_DIPSETTING(	0x10, "4" )
+	PORT_DIPSETTING(	0x20, "5" )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x80, 0x80, "Reset Damage (Cheat)" )      /* see notes */
+	PORT_DIPSETTING(	0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
+
+	PORT_START("DSWC")
+	PORT_DIPUNUSED( 0x01, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x02, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x04, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x08, IP_ACTIVE_LOW )
+	PORT_DIPNAME( 0x10, 0x10, "Infinite Bullets" )          /* see notes */
+	PORT_DIPSETTING(	0x10, DEF_STR( Off ) )
+	PORT_DIPSETTING(	0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x20, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x40, IP_ACTIVE_LOW )
+	PORT_DIPUNUSED( 0x80, IP_ACTIVE_LOW )
+
+	PORT_START("IN0")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_UNKNOWN )            /* IPT_START2 is some similar Taito games (eg: 'flstory') */
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_TILT )
+	PORT_BIT( 0x10, IP_ACTIVE_HIGH, IPT_COIN1 )
+	PORT_BIT( 0x20, IP_ACTIVE_HIGH, IPT_COIN2 )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN1")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_BUTTON1 )
+	PORT_BIT( 0xfe, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("LIGHTX")
+	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_Y ) PORT_CROSSHAIR(X, 1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
+
+	PORT_START("LIGHTY")
+	PORT_BIT( 0xff, 0x80, IPT_LIGHTGUN_X ) PORT_CROSSHAIR(Y, -1.0, 0.0, 0) PORT_SENSITIVITY(25) PORT_KEYDELTA(15) PORT_PLAYER(1)
+INPUT_PORTS_END
+
+/* verified from Z80 code */
+static INPUT_PORTS_START( bronx )
+	PORT_INCLUDE( cyclshtg )
+
+	PORT_MODIFY("DSWB")
+	PORT_DIPNAME( 0x30, 0x30, DEF_STR( Lives ) )            /* see notes */
+	PORT_DIPSETTING(	0x00, "1" )
+	PORT_DIPSETTING(	0x30, "2" )
+	PORT_DIPSETTING(	0x10, "4" )
+	PORT_DIPSETTING(	0x20, "5" )
+INPUT_PORTS_END
+
+
 static const gfx_layout charlayout =
 {
 	8,8,
@@ -1282,6 +1362,18 @@
 	ROM_LOAD( "a50_14",   0x1c000, 0x4000, CRC(24b2f1bf) SHA1(4757aec2e4b99ce33d993ce1e19ee46a4eb76e86) )
 ROM_END
 
+static DRIVER_INIT( nycaptor )
+{
+	nycaptor_state *state = machine->driver_data<nycaptor_state>();
+	state->gametype = 0;
+}
+
+static DRIVER_INIT( cyclshtg )
+{
+	nycaptor_state *state = machine->driver_data<nycaptor_state>();
+	state->gametype = 1;
+}
+
 static DRIVER_INIT( bronx )
 {
 	nycaptor_state *state = machine->driver_data<nycaptor_state>();
@@ -1306,20 +1398,8 @@
 	state->gametype = 2;
 }
 
-static DRIVER_INIT( nycaptor )
-{
-	nycaptor_state *state = machine->driver_data<nycaptor_state>();
-	state->gametype = 0;
-}
-
-static DRIVER_INIT( cyclshtg )
-{
-	nycaptor_state *state = machine->driver_data<nycaptor_state>();
-	state->gametype = 1;
-}
-
 GAME( 1985, nycaptor, 0,        nycaptor, nycaptor, nycaptor, ROT0,  "Taito",   "N.Y. Captor", GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1986, cyclshtg, 0,        cyclshtg, cyclshtg, cyclshtg, ROT90, "Taito",   "Cycle Shooting", GAME_NOT_WORKING | GAME_SUPPORTS_SAVE )
 /* bootlegs */
-GAME( 1986, bronx,    cyclshtg, bronx,    cyclshtg, bronx,    ROT90, "bootleg", "Bronx", GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
-GAME( 1986, colt ,    nycaptor, bronx,    nycaptor, colt,     ROT0,  "bootleg", "Colt", GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND | GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE )
+GAME( 1986, bronx,    cyclshtg, bronx,    bronx,    bronx,    ROT90, "bootleg", "Bronx", GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1986, colt,     nycaptor, bronx,    colt,     colt,     ROT0,  "bootleg", "Colt", GAME_IMPERFECT_GRAPHICS | GAME_IMPERFECT_SOUND | GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE )
diff -Nru src-old/mame/drivers/nyny.c src/mame/drivers/nyny.c
--- src-old/mame/drivers/nyny.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/nyny.c	2010-08-23 03:03:39.000000000 -0700
@@ -253,7 +253,7 @@
 }
 
 
-static const ttl74123_config ic48_1_config =
+static const ttl74123_interface ic48_1_config =
 {
 	TTL74123_GROUNDED,	/* the hook up type */
 	RES_K(22),			/* resistor connected to RCext */
diff -Nru src-old/mame/drivers/offtwall.c src/mame/drivers/offtwall.c
--- src-old/mame/drivers/offtwall.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/offtwall.c	2010-08-19 01:27:05.000000000 -0700
@@ -171,7 +171,7 @@
         ROM bank area, we need to return the correct value to give the proper checksum */
 	if ((offset == 0x3000 || offset == 0x3001) && cpu_get_previouspc(space->cpu) > 0x37000)
 	{
-		UINT32 checksum = (memory_read_word(space, 0x3fd210) << 16) | memory_read_word(space, 0x3fd212);
+		UINT32 checksum = (space->read_word(0x3fd210) << 16) | space->read_word(0x3fd212);
 		UINT32 us = 0xaaaa5555 - checksum;
 		if (offset == 0x3001)
 			return us & 0xffff;
diff -Nru src-old/mame/drivers/omegrace.c src/mame/drivers/omegrace.c
--- src-old/mame/drivers/omegrace.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/omegrace.c	2010-08-19 00:26:14.000000000 -0700
@@ -231,7 +231,7 @@
 
 static MACHINE_RESET( omegrace )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	/* Omega Race expects the vector processor to be ready. */
 	avgdvg_reset_w(space, 0, 0);
 }
@@ -329,7 +329,7 @@
 	AM_RANGE(0x0000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x4bff) AM_RAM
 	AM_RANGE(0x5c00, 0x5cff) AM_RAM AM_BASE_SIZE_GENERIC(nvram) /* NVRAM */
-	AM_RANGE(0x8000, 0x8fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x8000) /* vector ram */
+	AM_RANGE(0x8000, 0x8fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x8000) /* vector ram */
 	AM_RANGE(0x9000, 0x9fff) AM_ROM /* vector rom */
 ADDRESS_MAP_END
 
diff -Nru src-old/mame/drivers/pachifev.c src/mame/drivers/pachifev.c
--- src-old/mame/drivers/pachifev.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/pachifev.c	2010-08-30 08:20:58.000000000 -0700
@@ -20,22 +20,60 @@
 
 - TODO:
   - what's the correct game title - Pachifever ? Fever 777 ?
-  - remaing DSW
   - unknown writes ($ffxx range)
+  - coins : try to understand why they don't always register (use PORT_IMPULSE ?)
   - controls : unused bits (is the BUTTON1 used _only_ for entering initials?)
   - controls : make PLUNGER (or whatever it is in reality) implementation more clear
+               and find a better way to handle cocktail mode;
                here's some code used to read plunger pos(angle?):
 
-0284: 04CC             clr  R12            ; CRU address
-0286: 0208 FF00        li   R8,>ff00     ; R8=ff00 - initial data ($ff)
-028A: D688             movb R8,*R10     ; ff-> ff40  - write to output
-028C: 3449             stcr R9,1        ; CRU read (one bit)
-028E: 1603             jne  >0296        ; not zer0 - end
-0290: 0228 FC00        ai   R8,>fc00    ; R8=R8-4
-0294: 18FA             joc  >028a        ; loop
-
-0296: D6A0 020F        movb @>020f,*R10  ; 00 ->ff40 - end of controls read
-029A: 045B             b    *R11        ; b $1ca - process data in R8
+0284: 04CC             clr  R12             ; CRU address
+0286: 0208 FF00        li   R8,>ff00        ; R8=ff00 - initial data ($ff)
+028A: D688             movb R8,*R10         ; ff-> ff40  - write to output
+028C: 3449             stcr R9,1            ; CRU read (one bit)
+028E: 1603             jne  >0296           ; not zer0 - end
+0290: 0228 FC00        ai   R8,>fc00        ; R8=R8-4
+0294: 18FA             joc  >028a           ; loop
+
+0296: D6A0 020F        movb @>020f,*R10     ; 00 ->ff40 - end of controls read
+029A: 045B             b    *R11            ; b $1ca - process data in R8
+
+
+Stephh's notes (based on the game TMS9995 code and some tests) :
+
+  - "Difficulty" Dip Switch is a guess, but I can't see what else it can be. The values (-8 to +8) are
+    correct, but it's impossible for me to tell what are the easiest and the hardest settings.
+  - In "attract mode", the game plays the 4th level. This "attract mode" will end when the computer's
+    balls reaches the limit or when the time is over (same rules as for the players - see gameplay below).
+  - Gameplay :
+      * On levels 1 to 3, your number of balls must reach the limit based on DSW2 bits 6 and 7
+        to complete the level; once this is done, you go to next level or bonus stage (after level 3).
+        Time is reset to value based on DSW2 bits 6 and 7 only at the begining of level 1,
+        while balls are reset on each level to value based on DSW1 bits 4 and 5.
+      * On the bonus stage, you only have 3 balls (which are decremented from your number of balls)
+        to get maximum bonus time, bonus balls, and points. During this stage, time is not decremented.
+      * On level 4, your number of balls must reach the limit based on DSW2 bits 4 and 5 (making the game
+        sometimes harder) to complete the level; once this is done, the game is over for current player.
+        The main difference with levels 1 to 3 is that balls are not reset at the begining of the level.
+      * Once time or game is over, the game switches player 2 (if available). When all players have ended
+        their game, they can decide to continue : a message is displayed but you don't see any timer.
+        When you continue, only the balls aren't reset, while score, time and level (GASP !) are.
+        If you want to continue in a 2 players game, BOTH players will have to continue, which means that
+        you must have at least 2 credits ("REPLAY") and that you can't continue player 2 without player 1.
+      * If you manage to get a score, use BUTTON1 to cycle through avaiable symbols (letters A-Z and '.'),
+        and pull the plunger to at least 63% (the code expects a value >= 0xa0) to go to next initial.
+        Be aware that again there is a timer to do so, but that again the timer is not displayed.
+  - Usefull addresses :
+      * 0xe001.b : level (0x00-0x04 : 0x01 = level 1 - 0x02 = level 2 - 0x00 = level 3 - 0x3 = bonus - 0x04 = level 4)
+      * 0xe00f.b : player (0x00 = P1 - 0x01 = P2)
+      * 0xe016.w : P1 balls (MSB first)
+      * 0xe018.d : P1 score (MSB first)
+      * 0xe01c.w : P1 time  (MSB first)
+      * 0xe01e.w : P2 balls (MSB first)
+      * 0xe024.w : P2 time  (MSB first)
+      * 0xe020.d : P1 score (MSB first)
+      * 0xe028.w : limit (DSW2 bits 6 and 7) for levels 1 to 3 (MSB first)
+      * 0xe02a.w : limit (DSW2 bits 4 and 5) for level  4      (MSB first)
 
 ***********************************************************************************************************/
 
@@ -115,68 +153,94 @@
     AM_RANGE(0x000, 0x000) AM_READ(controls_r)
 ADDRESS_MAP_END
 
+
+/* verified from TMS9995 code */
 static INPUT_PORTS_START( pachifev )
+	/* 0xff00, cpl'ed -> 0xf0a0 (internal RAM) */
     PORT_START("IN0")
-    PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON1 )  /* used to enter player initials in top 5 */
-    PORT_BIT( 0x4d, IP_ACTIVE_LOW, IPT_UNKNOWN )
+    PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON1 )                 /* select initial for player 1 and player 2 (upright) */
     PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START1 )
     PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_START2 )
     PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_COIN1 )
+    PORT_BIT( 0x4d, IP_ACTIVE_LOW, IPT_UNUSED )
 
+	/* 0xff02, cpl'ed -> 0xf0a1 (internal RAM) */
     PORT_START("IN1")
-    PORT_BIT( 0xff, IP_ACTIVE_LOW, IPT_UNKNOWN )
+    PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_COCKTAIL   /* select initial for player 2 (cocktail) */
+    PORT_BIT( 0xfd, IP_ACTIVE_LOW, IPT_UNUSED )
 
+	/* 0xff04, cpl'ed -> 0xf0a2 (internal RAM) */
     PORT_START("DSW1")
-    PORT_DIPUNKNOWN( 0x07, 0x07 )
-
+	PORT_DIPNAME( 0x07, 0x07, "Difficulty ?" )              /* table at 0x5000 - see notes */
+	PORT_DIPSETTING(    0x07, "-8" )
+	PORT_DIPSETTING(    0x06, "-6" )
+	PORT_DIPSETTING(    0x05, "-4" )
+	PORT_DIPSETTING(    0x04, "-2" )
+	PORT_DIPSETTING(    0x03, "+2" )
+	PORT_DIPSETTING(    0x02, "+4" )
+	PORT_DIPSETTING(    0x01, "+6" )
+	PORT_DIPSETTING(    0x00, "+8" )
     PORT_DIPNAME( 0x08, 0x08, DEF_STR( Cabinet ) )
     PORT_DIPSETTING(    0x08, DEF_STR( Upright ) )
     PORT_DIPSETTING(    0x00, DEF_STR( Cocktail ) )
-
-    PORT_DIPNAME( 0x30, 0x10, "Balls" )
-    PORT_DIPSETTING(    0x00, "200")
-    PORT_DIPSETTING(    0x10, "100")
-    PORT_DIPSETTING(    0x20, "50")
-    PORT_DIPSETTING(    0x30, "25")
-
-    PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coin_A ) )
-    PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ))
+    PORT_DIPNAME( 0x30, 0x00, "Balls" )                     /* table at 0x5020 */
+    PORT_DIPSETTING(    0x30, "25" )
+    PORT_DIPSETTING(    0x20, "50" )
+    PORT_DIPSETTING(    0x10, "100" )
+    PORT_DIPSETTING(    0x00, "200" )
+    PORT_DIPNAME( 0xc0, 0xc0, DEF_STR( Coinage ) )
+    PORT_DIPSETTING(    0xc0, DEF_STR( 1C_1C ) )
     PORT_DIPSETTING(    0x80, DEF_STR( 1C_2C ) )
     PORT_DIPSETTING(    0x40, DEF_STR( 1C_3C ) )
     PORT_DIPSETTING(    0x00, DEF_STR( 1C_4C ) )
 
+	/* 0xff06, cpl'ed -> 0xf0a3 (internal RAM) */
     PORT_START("DSW2")
+    PORT_DIPNAME( 0x03, 0x00, "Time" )                      /* table at 0x5028 */
+    PORT_DIPSETTING(    0x00, "180" )
+    PORT_DIPSETTING(    0x01, "120" )
+    PORT_DIPSETTING(    0x02, "150" )
+    PORT_DIPSETTING(    0x03, "90" )
+	PORT_DIPUNUSED( 0x04, 0x04 )
+	PORT_DIPUNUSED( 0x08, 0x08 )
+    PORT_DIPNAME( 0x30, 0x30, "Limit (Level 4)" )           /* table at 0x5038 - stored at 0xe02a.w */
+    PORT_DIPSETTING(    0x30, "500" )
+    PORT_DIPSETTING(    0x20, "1000" )
+    PORT_DIPSETTING(    0x10, "1500" )
+    PORT_DIPSETTING(    0x00, "2000" )
+    PORT_DIPNAME( 0xc0, 0xc0, "Limit (Levels 1 to 3)" )     /* table at 0x5030 - stored at 0xe028.w */
+    PORT_DIPSETTING(    0xc0, "300" )
+    PORT_DIPSETTING(    0x80, "500" )
+    PORT_DIPSETTING(    0x40, "1000" )
+    PORT_DIPSETTING(    0x00, "1500" )
 
-    PORT_DIPNAME( 0x03, 0x01, "Time" )
-    PORT_DIPSETTING(    0x00, "180")
-    PORT_DIPSETTING(    0x01, "120")
-    PORT_DIPSETTING(    0x02, "150")
-    PORT_DIPSETTING(    0x03, "90")
-
-    PORT_DIPUNKNOWN( 0x0c, 0x0c )
-
-    PORT_DIPNAME( 0x30, 0x20, "Limit (attract)" ) /* attract mode only??? */
-    PORT_DIPSETTING(    0x00, "2000")
-    PORT_DIPSETTING(    0x10, "1500")
-    PORT_DIPSETTING(    0x20, "1000")
-    PORT_DIPSETTING(    0x30, "500")
-
-    PORT_DIPNAME( 0xc0, 0xc0, "Limit (game)" )  /* ball limit in game */
-    PORT_DIPSETTING(    0x00, "1500")
-    PORT_DIPSETTING(    0x40, "1000")
-    PORT_DIPSETTING(    0x80, "500")
-    PORT_DIPSETTING(    0xc0, "300")
-
+	/* 0xff08, cpl'ed -> 0xf0a4 (internal RAM) */
     PORT_START("DSW3")
     PORT_DIPNAME( 0x01, 0x00, DEF_STR( Demo_Sounds ) )
     PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
     PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPUNUSED( 0x02, 0x02 )
+	PORT_DIPUNUSED( 0x04, 0x04 )
+    PORT_DIPNAME( 0x18, 0x18, "Bonus Time" )                /* table at 0x3500 */
+    PORT_DIPSETTING(    0x18, "5" )
+    PORT_DIPSETTING(    0x10, "8" )
+    PORT_DIPSETTING(    0x08, "10" )
+    PORT_DIPSETTING(    0x00, "15" )
+	PORT_DIPNAME( 0xe0, 0xe0, "Bonus Ball" )                /* table at 0x3508 */
+	PORT_DIPSETTING(    0xe0, "3" )
+	PORT_DIPSETTING(    0xc0, "4" )
+	PORT_DIPSETTING(    0xa0, "5" )
+	PORT_DIPSETTING(    0x80, "8" )
+	PORT_DIPSETTING(    0x60, "10" )
+	PORT_DIPSETTING(    0x40, "11" )
+	PORT_DIPSETTING(    0x20, "13" )
+	PORT_DIPSETTING(    0x00, "15" )
 
-    PORT_DIPUNKNOWN( 0xfe, 0xfe )
-
-    PORT_START("PLUNGER")
+    PORT_START("PLUNGER_P1")
     PORT_BIT( 0x3f, 0x00, IPT_POSITIONAL ) PORT_MINMAX(0x00,0x3f) PORT_SENSITIVITY(30) PORT_KEYDELTA(4) PORT_CENTERDELTA(0xff)
 
+    PORT_START("PLUNGER_P2")
+    PORT_BIT( 0x3f, 0x00, IPT_POSITIONAL ) PORT_MINMAX(0x00,0x3f) PORT_SENSITIVITY(30) PORT_KEYDELTA(4) PORT_CENTERDELTA(0xff) PORT_COCKTAIL
 INPUT_PORTS_END
 
 
@@ -240,8 +304,19 @@
     TMS9928A_interrupt(device->machine);
 
     {
+		static const char *const inname[2] = { "PLUNGER_P1", "PLUNGER_P2" };
         pachifev_state *state = device->machine->driver_data<pachifev_state>();
-        int current_power=input_port_read(device->machine, "PLUNGER") & 0x3f;
+
+		/* I wish I had found a better way to handle cocktail inputs, but I can't find a way to access internal RAM */
+		/* (bit 5 of 0xf0aa : 0 = player 1 and 1 = player 2 - bit 6 of 0xf0aa : 0 = upright and 1 = cocktail). */
+		/* All I found is that in main RAM, 0xe00f.b determines the player : 0x00 = player 1 and 0x01 = player 2. */
+		address_space *ramspace = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+		UINT8 player = 0;
+
+		if ((ramspace->read_byte(0xe00f) == 0x01) && ((input_port_read(device->machine, "DSW1") & 0x08) == 0x00))
+			player = 1;
+
+        int current_power=input_port_read(device->machine, inname[player]) & 0x3f;
         if(current_power != state->previous_power)
         {
             popmessage    ("%d%%", (current_power * 100) / 0x3f);
diff -Nru src-old/mame/drivers/pacman.c src/mame/drivers/pacman.c
--- src-old/mame/drivers/pacman.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/pacman.c	2010-08-19 07:19:38.000000000 -0700
@@ -5348,13 +5348,13 @@
 
 static void maketrax_rom_decode(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x4000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 
 	/* patch protection using a copy of the opcodes so ROM checksum */
 	/* tests will not fail */
-	memory_set_decrypted_region(space, 0x0000, 0x3fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x3fff, decrypted);
 
 	memcpy(decrypted,rom,0x4000);
 
@@ -5380,13 +5380,13 @@
 
 static void korosuke_rom_decode(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x4000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 
 	/* patch protection using a copy of the opcodes so ROM checksum */
 	/* tests will not fail */
-	memory_set_decrypted_region(space, 0x0000, 0x3fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x3fff, decrypted);
 
 	memcpy(decrypted,rom,0x4000);
 
diff -Nru src-old/mame/drivers/pcat_dyn.c src/mame/drivers/pcat_dyn.c
--- src-old/mame/drivers/pcat_dyn.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/pcat_dyn.c	2010-08-19 01:27:05.000000000 -0700
@@ -184,7 +184,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -193,7 +193,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static void set_dma_channel(running_device *device, int channel, int state)
diff -Nru src-old/mame/drivers/pcktgal.c src/mame/drivers/pcktgal.c
--- src-old/mame/drivers/pcktgal.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/drivers/pcktgal.c	2010-08-19 07:19:38.000000000 -0700
@@ -414,11 +414,11 @@
 static DRIVER_INIT( deco222 )
 {
 	int A;
-	const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 	UINT8 *rom = memory_region(machine, "audiocpu");
 
-	memory_set_decrypted_region(space, 0x8000, 0xffff, decrypted);
+	space->set_decrypted_region(0x8000, 0xffff, decrypted);
 
 	/* bits 5 and 6 of the opcodes are swapped */
 	for (A = 0x8000;A < 0x18000;A++)
diff -Nru src-old/mame/drivers/pcxt.c src/mame/drivers/pcxt.c
--- src-old/mame/drivers/pcxt.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/pcxt.c	2010-08-19 01:27:05.000000000 -0700
@@ -563,7 +563,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -572,7 +572,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static READ8_HANDLER(dma_page_select_r)
diff -Nru src-old/mame/drivers/pengo.c src/mame/drivers/pengo.c
--- src-old/mame/drivers/pengo.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/pengo.c	2010-08-19 07:19:38.000000000 -0700
@@ -660,12 +660,12 @@
 		{ 0x88,0x0a,0x82,0x00,0xa0,0x22,0xaa,0x28 },	/* ...1...1...0.... */
 		{ 0x88,0x0a,0x82,0x00,0xa0,0x22,0xaa,0x28 }		/* ...1...1...1.... */
 	};
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int A;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	for (A = 0x0000;A < 0x8000;A++)
 	{
diff -Nru src-old/mame/drivers/photoply.c src/mame/drivers/photoply.c
--- src-old/mame/drivers/photoply.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/photoply.c	2010-08-19 01:27:05.000000000 -0700
@@ -132,7 +132,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -141,7 +141,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static READ8_HANDLER(dma_page_select_r)
diff -Nru src-old/mame/drivers/pinkiri8.c src/mame/drivers/pinkiri8.c
--- src-old/mame/drivers/pinkiri8.c	2010-07-06 10:30:28.000000000 -0700
+++ src/mame/drivers/pinkiri8.c	2010-08-19 01:27:05.000000000 -0700
@@ -432,13 +432,13 @@
 
 		case 3:
 
-			const address_space *vdp_space = space->machine->device<janshi_vdp_device>("janshivdp")->space();
+			address_space *vdp_space = space->machine->device<janshi_vdp_device>("janshivdp")->space();
 
 			if (LOG_VRAM) printf("%02x ", data);
 			prev_writes++;
 			vram_addr++;
 
-			memory_write_byte_8le(vdp_space, vram_addr, data);
+			vdp_space->write_byte(vram_addr, data);
 			break;
 	}
 }
diff -Nru src-old/mame/drivers/playmark.c src/mame/drivers/playmark.c
--- src-old/mame/drivers/playmark.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/playmark.c	2010-08-19 00:26:14.000000000 -0700
@@ -186,7 +186,7 @@
 static WRITE8_DEVICE_HANDLER( playmark_snd_control_w )
 {
 	playmark_state *state = device->machine->driver_data<playmark_state>();
-//  const address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+//  address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
     /*  This port controls communications to and from the 68K, and the OKI
         device.
diff -Nru src-old/mame/drivers/plygonet.c src/mame/drivers/plygonet.c
--- src-old/mame/drivers/plygonet.c	2010-08-08 00:07:15.000000000 -0700
+++ src/mame/drivers/plygonet.c	2010-08-18 23:57:51.000000000 -0700
@@ -319,26 +319,26 @@
 	return 0x7fff;
 }
 
-static DIRECT_UPDATE_HANDLER( plygonet_dsp56k_direct_handler )
+DIRECT_UPDATE_HANDLER( plygonet_dsp56k_direct_handler )
 {
-	polygonet_state *state = space->machine->driver_data<polygonet_state>();
+	polygonet_state *state = machine->driver_data<polygonet_state>();
 
 	/* Call the dsp's update handler first */
-	if (state->dsp56k_update_handler != NULL)
+	if (!state->dsp56k_update_handler.isnull())
 	{
-		if ((*state->dsp56k_update_handler)(space, address, direct) == ~0)
+		if (state->dsp56k_update_handler(direct, address) == ~0)
 			return ~0;
 	}
 
 	/* If the requested region wasn't in there, see if it needs to be caught driver-side */
 	if (address >= (0x7000<<1) && address <= (0x7fff<<1))
 	{
-		direct->raw = direct->decrypted = (UINT8*)(state->dsp56k_p_mirror) - (0x7000<<1);
+		direct.explicit_configure(0x7000<<1, 0x7fff<<1, 0xfff<<1, state->dsp56k_p_mirror);
 		return ~0;
 	}
 	else if (address >= (0x8000<<1) && address <= (0x87ff<<1))
 	{
-		direct->raw = direct->decrypted = (UINT8*)(state->dsp56k_p_8000) - (0x8000<<1);
+		direct.explicit_configure(0x8000<<1, 0x87ff<<1, 0x7ff<<1, state->dsp56k_p_8000);
 		return ~0;
 	}
 
@@ -764,7 +764,8 @@
 	state->dsp56k_bank04_ram    = auto_alloc_array_clear(machine, UINT16, 2 * 8 * dsp56k_bank04_size);
 
 	/* The dsp56k occasionally executes out of mapped memory */
-	state->dsp56k_update_handler = memory_set_direct_update_handler(cputag_get_address_space(machine, "dsp", ADDRESS_SPACE_PROGRAM), plygonet_dsp56k_direct_handler);
+	address_space *space = machine->device<dsp56k_device>("dsp")->space(AS_PROGRAM);
+	state->dsp56k_update_handler = space->set_direct_update_handler(direct_update_delegate_create_static(plygonet_dsp56k_direct_handler, *machine));
 
     /* save states */
 	state_save_register_global_pointer(machine, state->dsp56k_bank00_ram,    2 * 8 * dsp56k_bank00_size);
diff -Nru src-old/mame/drivers/polepos.c src/mame/drivers/polepos.c
--- src-old/mame/drivers/polepos.c	2010-08-04 08:52:00.000000000 -0700
+++ src/mame/drivers/polepos.c	2010-08-19 00:26:14.000000000 -0700
@@ -458,7 +458,7 @@
 
 static MACHINE_RESET( polepos )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Reset all latches */
diff -Nru src-old/mame/drivers/policetr.c src/mame/drivers/policetr.c
--- src-old/mame/drivers/policetr.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/policetr.c	2010-08-26 09:31:58.000000000 -0700
@@ -417,7 +417,7 @@
  *
  *************************************/
 
-static const r3000_cpu_core config =
+static const r3000_cpu_core r3000_config =
 {
 	0,		/* 1 if we have an FPU, 0 otherwise */
 	4096,	/* code cache size */
@@ -429,7 +429,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R3000BE, MASTER_CLOCK/2)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r3000_config)
 	MDRV_CPU_PROGRAM_MAP(policetr_map)
 	MDRV_CPU_VBLANK_INT("screen", irq4_gen)
 
diff -Nru src-old/mame/drivers/prehisle.c src/mame/drivers/prehisle.c
--- src-old/mame/drivers/prehisle.c	2010-05-24 18:49:55.000000000 -0700
+++ src/mame/drivers/prehisle.c	2010-08-26 20:55:49.000000000 -0700
@@ -13,16 +13,7 @@
 #include "cpu/m68000/m68000.h"
 #include "sound/upd7759.h"
 #include "sound/3812intf.h"
-
-extern WRITE16_HANDLER( prehisle_bg_videoram16_w );
-extern WRITE16_HANDLER( prehisle_fg_videoram16_w );
-extern WRITE16_HANDLER( prehisle_control16_w );
-extern READ16_HANDLER( prehisle_control16_r );
-
-extern VIDEO_START( prehisle );
-extern VIDEO_UPDATE( prehisle );
-
-extern UINT16 *prehisle_bg_videoram16;
+#include "includes/prehisle.h"
 
 /******************************************************************************/
 
@@ -37,9 +28,9 @@
 static ADDRESS_MAP_START( prehisle_map, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x03ffff) AM_ROM
 	AM_RANGE(0x070000, 0x073fff) AM_RAM
-	AM_RANGE(0x090000, 0x0907ff) AM_RAM_WRITE(prehisle_fg_videoram16_w) AM_BASE_GENERIC(videoram)
-	AM_RANGE(0x0a0000, 0x0a07ff) AM_RAM AM_BASE_GENERIC(spriteram)
-	AM_RANGE(0x0b0000, 0x0b3fff) AM_RAM_WRITE(prehisle_bg_videoram16_w) AM_BASE(&prehisle_bg_videoram16)
+	AM_RANGE(0x090000, 0x0907ff) AM_RAM_WRITE(prehisle_fg_videoram16_w) AM_BASE_MEMBER(prehisle_state, videoram)
+	AM_RANGE(0x0a0000, 0x0a07ff) AM_RAM AM_BASE_MEMBER(prehisle_state, spriteram)
+	AM_RANGE(0x0b0000, 0x0b3fff) AM_RAM_WRITE(prehisle_bg_videoram16_w) AM_BASE_MEMBER(prehisle_state, bg_videoram16)
 	AM_RANGE(0x0d0000, 0x0d07ff) AM_RAM_WRITE(paletteram16_RRRRGGGGBBBBxxxx_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x0e0000, 0x0e00ff) AM_READ(prehisle_control16_r)
 	AM_RANGE(0x0f0070, 0x0ff071) AM_WRITE(prehisle_sound16_w)
@@ -214,6 +205,8 @@
 
 static MACHINE_DRIVER_START( prehisle )
 
+	MDRV_DRIVER_DATA( prehisle_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_18MHz/2)	/* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(prehisle_map)
diff -Nru src-old/mame/drivers/progolf.c src/mame/drivers/progolf.c
--- src-old/mame/drivers/progolf.c	2010-06-27 23:40:44.000000000 -0700
+++ src/mame/drivers/progolf.c	2010-08-19 07:19:38.000000000 -0700
@@ -511,11 +511,11 @@
 static DRIVER_INIT( progolf )
 {
 	int A;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8* decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 
-	memory_set_decrypted_region(space,0x0000,0xffff, decrypted);
+	space->set_decrypted_region(0x0000,0xffff, decrypted);
 
 	/* Swap bits 5 & 6 for opcodes */
 	for (A = 0xb000 ; A < 0x10000 ; A++)
@@ -525,11 +525,11 @@
 static DRIVER_INIT( progolfa )
 {
 	int A;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8* decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 
-	memory_set_decrypted_region(space,0x0000,0xffff, decrypted);
+	space->set_decrypted_region(0x0000,0xffff, decrypted);
 
 	/* data is likely to not be encrypted, just the opcodes are. */
 	for (A = 0x0000 ; A < 0x10000 ; A++)
diff -Nru src-old/mame/drivers/pturn.c src/mame/drivers/pturn.c
--- src-old/mame/drivers/pturn.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/pturn.c	2010-08-19 00:26:14.000000000 -0700
@@ -440,7 +440,7 @@
 
 static MACHINE_RESET( pturn )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	soundlatch_clear_w(space,0,0);
 }
 
diff -Nru src-old/mame/drivers/qix.c src/mame/drivers/qix.c
--- src-old/mame/drivers/qix.c	2010-04-23 16:21:39.000000000 -0700
+++ src/mame/drivers/qix.c	2010-08-19 07:19:38.000000000 -0700
@@ -1262,8 +1262,8 @@
 
 static DRIVER_INIT( kram3 )
 {
-	const address_space *mainspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *videospace = cputag_get_address_space(machine, "videocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *mainspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *videospace = cputag_get_address_space(machine, "videocpu", ADDRESS_SPACE_PROGRAM);
 	//const UINT8 *patch;
 	UINT8 *rom, *decrypted;
 	int i;
@@ -1287,7 +1287,7 @@
 	rom = memory_region(machine, "maincpu");
 	decrypted = auto_alloc_array(machine, UINT8, 0x6000);
 
-	memory_set_decrypted_region(mainspace, 0xa000, 0xffff, decrypted);
+	mainspace->set_decrypted_region(0xa000, 0xffff, decrypted);
 
 	memcpy(decrypted,&rom[0xa000],0x6000);
 	for (i = 0xa000; i < 0x10000; ++i)
@@ -1300,7 +1300,7 @@
 	rom = memory_region(machine, "videocpu");
 	decrypted = auto_alloc_array(machine, UINT8, 0x6000);
 
-	memory_set_decrypted_region(videospace, 0xa000, 0xffff, decrypted);
+	videospace->set_decrypted_region(0xa000, 0xffff, decrypted);
 
 	memcpy(decrypted,&rom[0xa000],0x6000);
 	for (i = 0xa000; i < 0x10000; ++i)
diff -Nru src-old/mame/drivers/quantum.c src/mame/drivers/quantum.c
--- src-old/mame/drivers/quantum.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/quantum.c	2010-08-13 01:54:21.000000000 -0700
@@ -115,13 +115,13 @@
 static ADDRESS_MAP_START( main_map, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x013fff) AM_ROM
 	AM_RANGE(0x018000, 0x01cfff) AM_RAM
-	AM_RANGE(0x800000, 0x801fff) AM_RAM AM_BASE(&quantum_vectorram) AM_SIZE(&vectorram_size)
+	AM_RANGE(0x800000, 0x801fff) AM_RAM AM_BASE((UINT16 **)&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size)
 	AM_RANGE(0x840000, 0x84001f) AM_DEVREADWRITE8("pokey1", pokey_r, pokey_w, 0x00ff)
 	AM_RANGE(0x840020, 0x84003f) AM_DEVREADWRITE8("pokey2", pokey_r, pokey_w, 0x00ff)
 	AM_RANGE(0x900000, 0x9001ff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
 	AM_RANGE(0x940000, 0x940001) AM_READ(trackball_r) /* trackball */
 	AM_RANGE(0x948000, 0x948001) AM_READ_PORT("SYSTEM")
-	AM_RANGE(0x950000, 0x95001f) AM_WRITEONLY AM_BASE(&quantum_colorram)
+	AM_RANGE(0x950000, 0x95001f) AM_WRITEONLY AM_BASE((UINT16**)&avgdvg_colorram)
 	AM_RANGE(0x958000, 0x958001) AM_WRITE(led_w)
 	AM_RANGE(0x960000, 0x960001) AM_WRITENOP
 	AM_RANGE(0x968000, 0x968001) AM_WRITE(avgdvg_reset_word_w)
diff -Nru src-old/mame/drivers/quasar.c src/mame/drivers/quasar.c
--- src-old/mame/drivers/quasar.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/quasar.c	2010-08-12 12:45:01.000000000 -0700
@@ -312,21 +312,24 @@
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 static const s2636_interface s2636_1_config =
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 static const s2636_interface s2636_2_config =
 {
 	"screen",
 	0x100,
-	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET
+	CVS_S2636_Y_OFFSET, CVS_S2636_X_OFFSET,
+	NULL
 };
 
 // ****************************************
diff -Nru src-old/mame/drivers/quizpun2.c src/mame/drivers/quizpun2.c
--- src-old/mame/drivers/quizpun2.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/quizpun2.c	2010-08-19 00:26:14.000000000 -0700
@@ -137,7 +137,7 @@
 	prot.addr = 0;
 }
 
-static void log_protection( const address_space *space, const char *warning )
+static void log_protection( address_space *space, const char *warning )
 {
 	logerror("%04x: protection - %s (state %x, wait %x, param %02x, cmd %02x, addr %02x)\n", cpu_get_pc(space->cpu), warning,
 		prot.state,
diff -Nru src-old/mame/drivers/r2dtank.c src/mame/drivers/r2dtank.c
--- src-old/mame/drivers/r2dtank.c	2010-07-16 04:59:31.000000000 -0700
+++ src/mame/drivers/r2dtank.c	2010-08-23 03:03:39.000000000 -0700
@@ -218,7 +218,7 @@
 }
 
 
-static const ttl74123_config ttl74123_intf =
+static const ttl74123_interface ttl74123_intf =
 {
 	TTL74123_GROUNDED,	/* the hook up type */
 	RES_K(22),			/* resistor connected to RCext */
diff -Nru src-old/mame/drivers/raiden.c src/mame/drivers/raiden.c
--- src-old/mame/drivers/raiden.c	2010-02-14 09:59:22.000000000 -0800
+++ src/mame/drivers/raiden.c	2010-08-19 00:26:14.000000000 -0700
@@ -254,7 +254,7 @@
 
 static VIDEO_EOF( raiden )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram16_w(space,0,0,0xffff); /* Could be a memory location instead */
 }
 
diff -Nru src-old/mame/drivers/raiden2.c src/mame/drivers/raiden2.c
--- src-old/mame/drivers/raiden2.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/raiden2.c	2010-08-19 00:26:14.000000000 -0700
@@ -682,13 +682,13 @@
 // XXX
 // write only: 4c0 4c1 500 501 502 503
 
-static UINT16 handle_io_r(const address_space *space, int offset)
+static UINT16 handle_io_r(address_space *space, int offset)
 {
 	logerror("io_r %04x, %04x (%x)\n", offset*2, mainram[offset], cpu_get_pc(space->cpu));
 	return mainram[offset];
 }
 
-static void handle_io_w(const address_space *space, int offset, UINT16 data, UINT16 mem_mask)
+static void handle_io_w(address_space *space, int offset, UINT16 data, UINT16 mem_mask)
 {
 	COMBINE_DATA(&mainram[offset]);
 	switch(offset) {
diff -Nru src-old/mame/drivers/realbrk.c src/mame/drivers/realbrk.c
--- src-old/mame/drivers/realbrk.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/realbrk.c	2010-08-13 01:54:21.000000000 -0700
@@ -166,7 +166,7 @@
 	AM_RANGE(0x605000, 0x61ffff) AM_RAM							            	//
 	AM_RANGE(0x800000, 0x800003) AM_DEVREADWRITE8("ymz", ymz280b_r, ymz280b_w, 0xff00)	// YMZ280
 	AM_RANGE(0xfe0000, 0xfeffff) AM_RAM						                	// RAM
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs	)	// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)	// TMP68301 Registers
 ADDRESS_MAP_END
 
 /*realbrk specific memory map*/
diff -Nru src-old/mame/drivers/renegade.c src/mame/drivers/renegade.c
--- src-old/mame/drivers/renegade.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/renegade.c	2010-08-19 00:26:14.000000000 -0700
@@ -295,7 +295,7 @@
 
 static DRIVER_INIT( kuniokunb )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Remove the MCU handlers */
 	memory_unmap_readwrite(space, 0x3804, 0x3804, 0, 0);
diff -Nru src-old/mame/drivers/safarir.c src/mame/drivers/safarir.c
--- src-old/mame/drivers/safarir.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/safarir.c	2010-08-19 00:26:14.000000000 -0700
@@ -146,7 +146,7 @@
 static TILE_GET_INFO( get_bg_tile_info )
 {
 	int color;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 code = ram_r(space,tile_index | 0x400);
 
 	if (code & 0x80)
@@ -168,7 +168,7 @@
 static TILE_GET_INFO( get_fg_tile_info )
 {
 	int color, flags;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	UINT8 code = ram_r(space,tile_index);
 
diff -Nru src-old/mame/drivers/savquest.c src/mame/drivers/savquest.c
--- src-old/mame/drivers/savquest.c	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/drivers/savquest.c	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,84 @@
+/***************************************************************************
+
+    savquest.c
+
+    "Savage Quest" (c) 1999 Interactive Light, developed by Angel Studios.
+    Skeleton by R. Belmont
+
+    H/W is a white-box PC consisting of:
+    Pentium II 450 CPU
+    DFI P2XBL motherboard (i440BX chipset)
+    128 MB RAM
+    Guillemot Maxi Gamer 3D2 Voodoo II
+    Sound Blaster AWE64
+
+    Protected by a HASP brand parallel port dongle.
+    I/O board has a PIC17C43 which is not readable.
+
+    Copyright Nicola Salmoria and the MAME Team.
+    Visit http://mamedev.org for licensing and usage restrictions.
+
+***************************************************************************/
+
+#include "emu.h"
+#include "cpu/i386/i386.h"
+#include "memconv.h"
+#include "devconv.h"
+#include "machine/8237dma.h"
+#include "machine/pic8259.h"
+#include "machine/pit8253.h"
+#include "machine/mc146818.h"
+#include "machine/pcshare.h"
+#include "machine/pci.h"
+#include "machine/8042kbdc.h"
+#include "machine/pckeybrd.h"
+#include "machine/idectrl.h"
+
+static VIDEO_START(savquest)
+{
+}
+
+static VIDEO_UPDATE(savquest)
+{
+	return 0;
+}
+
+static ADDRESS_MAP_START(savquest_map, ADDRESS_SPACE_PROGRAM, 32)
+	AM_RANGE(0x00000000, 0x0009ffff) AM_RAM
+	AM_RANGE(0xfffc0000, 0xffffffff) AM_ROM AM_REGION("user1", 0)	/* System BIOS */
+ADDRESS_MAP_END
+
+static ADDRESS_MAP_START(savquest_io, ADDRESS_SPACE_IO, 32)
+ADDRESS_MAP_END
+
+static INPUT_PORTS_START( savquest )
+INPUT_PORTS_END
+
+static MACHINE_DRIVER_START( savquest )
+	MDRV_CPU_ADD("maincpu", PENTIUM, 450000000)	// actually Pentium II 450
+	MDRV_CPU_PROGRAM_MAP(savquest_map)
+	MDRV_CPU_IO_MAP(savquest_io)
+
+	/* video hardware */
+	MDRV_SCREEN_ADD("screen", RASTER)
+	MDRV_SCREEN_REFRESH_RATE(60)
+	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_INDEXED16)
+	MDRV_SCREEN_SIZE(640, 480)
+	MDRV_SCREEN_VISIBLE_AREA(0, 639, 0, 199)
+	MDRV_PALETTE_LENGTH(16)
+
+	MDRV_VIDEO_START(savquest)
+	MDRV_VIDEO_UPDATE(savquest)
+MACHINE_DRIVER_END
+
+ROM_START( savquest )
+	ROM_REGION32_LE(0x40000, "user1", 0)
+	ROM_LOAD( "sq-aflash.bin", 0x000000, 0x040000, CRC(0b4f406f) SHA1(4003b0e6d46dcb47012acc118837f0f7cf529faf) )
+
+	DISK_REGION( "disk" )
+	DISK_IMAGE( "savquest", 0, SHA1(b20cacf45e093b533c538bf4fc08f05f9475d640) )
+ROM_END
+
+GAME(1999, savquest, 0, savquest, savquest, 0, ROT0, "Interactive Light", "Savage Quest", GAME_NO_SOUND|GAME_NOT_WORKING)
+
diff -Nru src-old/mame/drivers/seattle.c src/mame/drivers/seattle.c
--- src-old/mame/drivers/seattle.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/seattle.c	2010-08-26 09:31:58.000000000 -0700
@@ -470,7 +470,7 @@
 static void update_vblank_irq(running_machine *machine);
 static void galileo_reset(void);
 static TIMER_CALLBACK( galileo_timer_callback );
-static void galileo_perform_dma(const address_space *space, int which);
+static void galileo_perform_dma(address_space *space, int which);
 static void voodoo_stall(running_device *device, int stall);
 static void widget_reset(running_machine *machine);
 static void update_widget_irq(running_machine *machine);
@@ -758,7 +758,7 @@
  *
  *************************************/
 
-static UINT32 pci_bridge_r(const address_space *space, UINT8 reg, UINT8 type)
+static UINT32 pci_bridge_r(address_space *space, UINT8 reg, UINT8 type)
 {
 	UINT32 result = galileo.pci_bridge_regs[reg];
 
@@ -779,7 +779,7 @@
 }
 
 
-static void pci_bridge_w(const address_space *space, UINT8 reg, UINT8 type, UINT32 data)
+static void pci_bridge_w(address_space *space, UINT8 reg, UINT8 type, UINT32 data)
 {
 	galileo.pci_bridge_regs[reg] = data;
 	if (LOG_PCI)
@@ -794,7 +794,7 @@
  *
  *************************************/
 
-static UINT32 pci_3dfx_r(const address_space *space, UINT8 reg, UINT8 type)
+static UINT32 pci_3dfx_r(address_space *space, UINT8 reg, UINT8 type)
 {
 	UINT32 result = galileo.pci_3dfx_regs[reg];
 
@@ -815,7 +815,7 @@
 }
 
 
-static void pci_3dfx_w(const address_space *space, UINT8 reg, UINT8 type, UINT32 data)
+static void pci_3dfx_w(address_space *space, UINT8 reg, UINT8 type, UINT32 data)
 {
 	galileo.pci_3dfx_regs[reg] = data;
 
@@ -843,7 +843,7 @@
  *
  *************************************/
 
-static UINT32 pci_ide_r(const address_space *space, UINT8 reg, UINT8 type)
+static UINT32 pci_ide_r(address_space *space, UINT8 reg, UINT8 type)
 {
 	UINT32 result = galileo.pci_ide_regs[reg];
 
@@ -864,7 +864,7 @@
 }
 
 
-static void pci_ide_w(const address_space *space, UINT8 reg, UINT8 type, UINT32 data)
+static void pci_ide_w(address_space *space, UINT8 reg, UINT8 type, UINT32 data)
 {
 	galileo.pci_ide_regs[reg] = data;
 	if (LOG_PCI)
@@ -925,7 +925,7 @@
  *
  *************************************/
 
-static int galileo_dma_fetch_next(const address_space *space, int which)
+static int galileo_dma_fetch_next(address_space *space, int which)
 {
 	offs_t address = 0;
 	UINT32 data;
@@ -947,25 +947,25 @@
 	}
 
 	/* fetch the byte count */
-	data = memory_read_dword(space, address); address += 4;
+	data = space->read_dword(address); address += 4;
 	galileo.reg[GREG_DMA0_COUNT + which] = data;
 
 	/* fetch the source address */
-	data = memory_read_dword(space, address); address += 4;
+	data = space->read_dword(address); address += 4;
 	galileo.reg[GREG_DMA0_SOURCE + which] = data;
 
 	/* fetch the dest address */
-	data = memory_read_dword(space, address); address += 4;
+	data = space->read_dword(address); address += 4;
 	galileo.reg[GREG_DMA0_DEST + which] = data;
 
 	/* fetch the next record address */
-	data = memory_read_dword(space, address); address += 4;
+	data = space->read_dword(address); address += 4;
 	galileo.reg[GREG_DMA0_NEXT + which] = data;
 	return 1;
 }
 
 
-static void galileo_perform_dma(const address_space *space, int which)
+static void galileo_perform_dma(address_space *space, int which)
 {
 	do
 	{
@@ -1016,7 +1016,7 @@
 				}
 
 				/* write the data and advance */
-				voodoo_w(voodoo, (dstaddr & 0xffffff) / 4, memory_read_dword(space, srcaddr), 0xffffffff);
+				voodoo_w(voodoo, (dstaddr & 0xffffff) / 4, space->read_dword(srcaddr), 0xffffffff);
 				srcaddr += srcinc;
 				dstaddr += dstinc;
 				bytesleft -= 4;
@@ -1028,7 +1028,7 @@
 		{
 			while (bytesleft > 0)
 			{
-				memory_write_byte(space, dstaddr, memory_read_byte(space, srcaddr));
+				space->write_byte(dstaddr, space->read_byte(srcaddr));
 				srcaddr += srcinc;
 				dstaddr += dstinc;
 				bytesleft--;
@@ -1347,7 +1347,7 @@
 		for (which = 0; which < 4; which++)
 			if (galileo.dma_stalled_on_voodoo[which])
 			{
-				const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+				address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 				if (LOG_DMA) logerror("Resuming DMA%d on voodoo\n", which);
 
 				/* mark this DMA as no longer stalled */
@@ -2450,7 +2450,7 @@
  *
  *************************************/
 
-static const mips3_config config =
+static const mips3_config r5000_config =
 {
 	16384,		/* code cache size */
 	16384,		/* data cache size */
@@ -2461,7 +2461,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R5000LE, SYSTEM_CLOCK*3)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(seattle_map)
 
 	MDRV_MACHINE_START(seattle)
@@ -2495,7 +2495,7 @@
 	MDRV_IMPORT_FROM(dcs2_audio_2115)
 
 	MDRV_CPU_REPLACE("maincpu", R4700LE, SYSTEM_CLOCK*2)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(seattle_map)
 MACHINE_DRIVER_END
 
@@ -2505,7 +2505,7 @@
 	MDRV_IMPORT_FROM(dcs2_audio_2115)
 
 	MDRV_CPU_REPLACE("maincpu", R5000LE, SYSTEM_CLOCK*3)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(seattle_map)
 MACHINE_DRIVER_END
 
@@ -2521,7 +2521,7 @@
 	MDRV_IMPORT_FROM(dcs2_audio_2115)
 
 	MDRV_CPU_REPLACE("maincpu", R5000LE, SYSTEM_CLOCK*4)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(seattle_map)
 MACHINE_DRIVER_END
 
@@ -2537,7 +2537,7 @@
 	MDRV_IMPORT_FROM(cage_seattle)
 
 	MDRV_CPU_REPLACE("maincpu", R5000LE, SYSTEM_CLOCK*4)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(seattle_map)
 
 	MDRV_SMC91C94_ADD("ethernet", ethernet_interrupt)
diff -Nru src-old/mame/drivers/segae.c src/mame/drivers/segae.c
--- src-old/mame/drivers/segae.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/segae.c	2010-08-19 00:26:14.000000000 -0700
@@ -363,7 +363,7 @@
 {
 	/* INIT THE PORTS *********************************************************************************************/
 
-	const address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *io = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	running_device *sn1 = machine->device("sn1");
 	running_device *sn2 = machine->device("sn2");
 
diff -Nru src-old/mame/drivers/segag80r.c src/mame/drivers/segag80r.c
--- src-old/mame/drivers/segag80r.c	2010-05-23 15:19:36.000000000 -0700
+++ src/mame/drivers/segag80r.c	2010-08-19 01:27:05.000000000 -0700
@@ -184,15 +184,15 @@
  *
  *************************************/
 
-static offs_t decrypt_offset(const address_space *space, offs_t offset)
+static offs_t decrypt_offset(address_space *space, offs_t offset)
 {
 	/* ignore anything but accesses via opcode $32 (LD $(XXYY),A) */
 	offs_t pc = cpu_get_previouspc(space->cpu);
-	if ((UINT16)pc == 0xffff || memory_read_byte(space, pc) != 0x32)
+	if ((UINT16)pc == 0xffff || space->read_byte(pc) != 0x32)
 		return offset;
 
 	/* fetch the low byte of the address and munge it */
-	return (offset & 0xff00) | (*sega_decrypt)(pc, memory_read_byte(space, pc + 1));
+	return (offset & 0xff00) | (*sega_decrypt)(pc, space->read_byte(pc + 1));
 }
 
 static WRITE8_HANDLER( mainram_w )         { mainram[decrypt_offset(space, offset)] = data; }
@@ -297,7 +297,7 @@
 
 static WRITE8_DEVICE_HANDLER( sindbadm_soundport_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	soundlatch_w(space, 0, data);
 	cputag_set_input_line(device->machine, "audiocpu", INPUT_LINE_NMI, PULSE_LINE);
 	cpuexec_boost_interleave(device->machine, attotime_zero, ATTOTIME_IN_USEC(50));
diff -Nru src-old/mame/drivers/segag80v.c src/mame/drivers/segag80v.c
--- src-old/mame/drivers/segag80v.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/segag80v.c	2010-08-19 01:27:05.000000000 -0700
@@ -137,7 +137,6 @@
 #include "sound/ay8910.h"
 #include "sound/samples.h"
 #include "audio/segasnd.h"
-#include "video/vector.h"
 #include "includes/segag80r.h"
 #include "includes/segag80v.h"
 
@@ -159,8 +158,6 @@
  *
  *************************************/
 
-extern UINT8 (*sega_decrypt)(offs_t, UINT8);
-
 static UINT8 *mainram;
 static UINT8 has_usb;
 
@@ -213,20 +210,20 @@
  *
  *************************************/
 
-static offs_t decrypt_offset(const address_space *space, offs_t offset)
+static offs_t decrypt_offset(address_space *space, offs_t offset)
 {
 	/* ignore anything but accesses via opcode $32 (LD $(XXYY),A) */
 	offs_t pc = cpu_get_previouspc(space->cpu);
-	if ((UINT16)pc == 0xffff || memory_read_byte(space, pc) != 0x32)
+	if ((UINT16)pc == 0xffff || space->read_byte(pc) != 0x32)
 		return offset;
 
 	/* fetch the low byte of the address and munge it */
-	return (offset & 0xff00) | (*sega_decrypt)(pc, memory_read_byte(space, pc + 1));
+	return (offset & 0xff00) | (*sega_decrypt)(pc, space->read_byte(pc + 1));
 }
 
 static WRITE8_HANDLER( mainram_w ) { mainram[decrypt_offset(space, offset)] = data; }
 static WRITE8_HANDLER( usb_ram_w ) { sega_usb_ram_w(space, decrypt_offset(space, offset), data); }
-static WRITE8_HANDLER( vectorram_w ) { vectorram[decrypt_offset(space, offset)] = data; }
+static WRITE8_HANDLER( vectorram_w ) { segag80v_vectorram[decrypt_offset(space, offset)] = data; }
 
 
 
@@ -396,7 +393,7 @@
 	AM_RANGE(0x0000, 0x07ff) AM_ROM		/* CPU board ROM */
 	AM_RANGE(0x0800, 0xbfff) AM_ROM		/* PROM board ROM area */
 	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(mainram_w) AM_BASE(&mainram)
-	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(vectorram_w) AM_BASE(&vectorram) AM_SIZE(&vectorram_size)
+	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(vectorram_w) AM_BASE(&segag80v_vectorram) AM_SIZE(&segag80v_vectorram_size)
 ADDRESS_MAP_END
 
 
@@ -929,8 +926,8 @@
 	MDRV_SCREEN_SIZE(400, 300)
 	MDRV_SCREEN_VISIBLE_AREA(512, 1536, 640-32, 1408+32)
 
-	MDRV_VIDEO_START(sega)
-	MDRV_VIDEO_UPDATE(sega)
+	MDRV_VIDEO_START(segag80v)
+	MDRV_VIDEO_UPDATE(segag80v)
 
 	/* sound hardware */
 	MDRV_SPEAKER_STANDARD_MONO("mono")
@@ -1318,7 +1315,7 @@
 
 static DRIVER_INIT( elim2 )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* configure security */
 	sega_security(70);
@@ -1332,7 +1329,7 @@
 
 static DRIVER_INIT( elim4 )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* configure security */
 	sega_security(76);
@@ -1350,7 +1347,7 @@
 
 static DRIVER_INIT( spacfury )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* configure security */
 	sega_security(64);
@@ -1366,7 +1363,7 @@
 
 static DRIVER_INIT( zektor )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	running_device *ay = machine->device("aysnd");
 
 	/* configure security */
@@ -1388,8 +1385,8 @@
 
 static DRIVER_INIT( tacscan )
 {
-	const address_space *pgmspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *pgmspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* configure security */
 	sega_security(76);
@@ -1407,8 +1404,8 @@
 
 static DRIVER_INIT( startrek )
 {
-	const address_space *pgmspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *pgmspace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	/* configure security */
 	sega_security(64);
diff -Nru src-old/mame/drivers/segahang.c src/mame/drivers/segahang.c
--- src-old/mame/drivers/segahang.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segahang.c	2010-08-19 07:19:38.000000000 -0700
@@ -285,7 +285,7 @@
 static WRITE8_DEVICE_HANDLER( sound_latch_w )
 {
 	segas1x_state *state = device->machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	soundlatch_w(space, offset, data);
 }
 
@@ -1866,12 +1866,12 @@
 
 static DRIVER_INIT( endurobl )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 	UINT16 *decrypt = auto_alloc_array(machine, UINT16, 0x40000/2);
 
 	hangon_generic_init(machine);
-	memory_set_decrypted_region(space, 0x000000, 0x03ffff, decrypt);
+	space->set_decrypted_region(0x000000, 0x03ffff, decrypt);
 
 	memcpy(decrypt + 0x00000/2, rom + 0x30000/2, 0x10000);
 	memcpy(decrypt + 0x10000/2, rom + 0x10000/2, 0x20000);
@@ -1880,12 +1880,12 @@
 
 static DRIVER_INIT( endurob2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 	UINT16 *decrypt = auto_alloc_array(machine, UINT16, 0x40000/2);
 
 	hangon_generic_init(machine);
-	memory_set_decrypted_region(space, 0x000000, 0x03ffff, decrypt);
+	space->set_decrypted_region(0x000000, 0x03ffff, decrypt);
 
 	memcpy(decrypt, rom, 0x30000);
 	/* missing data ROM */
diff -Nru src-old/mame/drivers/segamsys.c src/mame/drivers/segamsys.c
--- src-old/mame/drivers/segamsys.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/segamsys.c	2010-08-19 00:26:14.000000000 -0700
@@ -485,7 +485,7 @@
 	return retdata;
 }
 
-static void vdp_data_w(const address_space *space, UINT8 data, struct sms_vdp* chip)
+static void vdp_data_w(address_space *space, UINT8 data, struct sms_vdp* chip)
 {
 	/* data writes clear the pending flag */
 	chip->cmd_pend = 0;
@@ -549,7 +549,7 @@
 
 }
 
-static UINT8 vdp_ctrl_r(const address_space *space, struct sms_vdp *chip)
+static UINT8 vdp_ctrl_r(address_space *space, struct sms_vdp *chip)
 {
 	UINT8 retvalue;
 
@@ -613,7 +613,7 @@
 //  printf("VDP: setting register %01x to %02x\n",reg, chip->cmd_part1);
 }
 
-static void vdp_ctrl_w(const address_space *space, UINT8 data, struct sms_vdp *chip)
+static void vdp_ctrl_w(address_space *space, UINT8 data, struct sms_vdp *chip)
 {
 	if (chip->cmd_pend)
 	{ /* Part 2 of a command word write */
@@ -1480,7 +1480,7 @@
 
 void init_extra_gg_ports(running_machine* machine, const char* tag)
 {
-	const address_space *io = cputag_get_address_space(machine, tag, ADDRESS_SPACE_IO);
+	address_space *io = cputag_get_address_space(machine, tag, ADDRESS_SPACE_IO);
 	memory_install_read8_handler     (io, 0x00, 0x00, 0, 0, sms_ioport_gg00_r);
 }
 
@@ -1643,7 +1643,7 @@
 {
 	/* INIT THE PORTS *********************************************************************************************/
 
-	const address_space *io = cputag_get_address_space(machine, tag, ADDRESS_SPACE_IO);
+	address_space *io = cputag_get_address_space(machine, tag, ADDRESS_SPACE_IO);
 	running_device *sn = machine->device("snsnd");
 
 	memory_install_readwrite8_handler(io, 0x0000, 0xffff, 0, 0, z80_unmapped_port_r, z80_unmapped_port_w);
diff -Nru src-old/mame/drivers/segaorun.c src/mame/drivers/segaorun.c
--- src-old/mame/drivers/segaorun.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segaorun.c	2010-08-19 00:26:14.000000000 -0700
@@ -366,7 +366,7 @@
 static TIMER_CALLBACK( delayed_sound_data_w )
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	soundlatch_w(space, 0, param);
 	cpu_set_input_line(state->soundcpu, INPUT_LINE_NMI, ASSERT_LINE);
 }
diff -Nru src-old/mame/drivers/segas16a.c src/mame/drivers/segas16a.c
--- src-old/mame/drivers/segas16a.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segas16a.c	2010-08-19 01:27:05.000000000 -0700
@@ -597,7 +597,7 @@
 static void quartet_i8751_sim(running_machine *machine)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	/* signal a VBLANK to the main CPU */
 	cpu_set_input_line(state->maincpu, 4, HOLD_LINE);
@@ -858,14 +858,14 @@
 INLINE UINT8 maincpu_byte_r(running_machine *machine, offs_t offset)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	return memory_read_byte(cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM), offset);
+	return downcast<cpu_device *>(state->maincpu)->space(AS_PROGRAM)->read_byte(offset);
 }
 
 
 INLINE void maincpu_byte_w(running_machine *machine, offs_t offset, UINT8 data)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	memory_write_byte(cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM), offset, data);
+	downcast<cpu_device *>(state->maincpu)->space(AS_PROGRAM)->write_byte(offset, data);
 }
 
 
diff -Nru src-old/mame/drivers/segas16b.c src/mame/drivers/segas16b.c
--- src-old/mame/drivers/segas16b.c	2010-08-09 17:05:38.000000000 -0700
+++ src/mame/drivers/segas16b.c	2010-08-24 17:26:33.000000000 -0700
@@ -1026,7 +1026,7 @@
 
 	if (state->soundcpu != NULL)
 	{
-		const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+		address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 		soundlatch_w(space, 0, data & 0xff);
 		cpu_set_input_line(state->soundcpu, 0, HOLD_LINE);
 	}
@@ -1418,7 +1418,7 @@
 static void altbeast_common_i8751_sim(running_machine *machine, offs_t soundoffs, offs_t inputoffs)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT16 temp;
 
 	/* signal a VBLANK to the main CPU */
@@ -1458,7 +1458,7 @@
 static void ddux_i8751_sim(running_machine *machine)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT16 temp;
 
 	/* signal a VBLANK to the main CPU */
@@ -1496,7 +1496,7 @@
 static void goldnaxe_i8751_sim(running_machine *machine)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT16 temp;
 
 	/* signal a VBLANK to the main CPU */
@@ -1528,7 +1528,7 @@
 static void tturf_i8751_sim(running_machine *machine)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT16 temp;
 
 	/* signal a VBLANK to the main CPU */
@@ -1552,7 +1552,7 @@
 static void wb3_i8751_sim(running_machine *machine)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	UINT16 temp;
 
 	/* signal a VBLANK to the main CPU */
@@ -5996,6 +5996,7 @@
     Tough Turf, Sega System 16B
     CPU: 68000 + i8751 (317-0099)
     ROM Board: 171-5358
+    Sega ID# for ROM board: 834-6949
  */
 ROM_START( tturfu )
 	ROM_REGION( 0x40000, "maincpu", 0 ) /* 68000 code */
diff -Nru src-old/mame/drivers/segas18.c src/mame/drivers/segas18.c
--- src-old/mame/drivers/segas18.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segas18.c	2010-08-19 00:26:14.000000000 -0700
@@ -139,7 +139,7 @@
 static void sound_w(running_machine *machine, UINT8 data)
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	soundlatch_w(space, 0, data & 0xff);
 	cpu_set_input_line(state->soundcpu, INPUT_LINE_NMI, PULSE_LINE);
diff -Nru src-old/mame/drivers/segas24.c src/mame/drivers/segas24.c
--- src-old/mame/drivers/segas24.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/segas24.c	2010-08-19 00:26:14.000000000 -0700
@@ -696,7 +696,7 @@
 	prev_resetcontrol = resetcontrol;
 }
 
-static void resetcontrol_w(const address_space *space, UINT8 data)
+static void resetcontrol_w(address_space *space, UINT8 data)
 {
 	resetcontrol = data;
 	logerror("Reset control %02x ('%s':%x)\n", resetcontrol, space->cpu->tag(), cpu_get_pc(space->cpu));
diff -Nru src-old/mame/drivers/segas32.c src/mame/drivers/segas32.c
--- src-old/mame/drivers/segas32.c	2010-07-06 01:32:43.000000000 -0700
+++ src/mame/drivers/segas32.c	2010-08-21 11:40:01.000000000 -0700
@@ -489,7 +489,7 @@
 }
 
 
-static void int_control_w(const address_space *space, int offset, UINT8 data)
+static void int_control_w(address_space *space, int offset, UINT8 data)
 {
 	int duration;
 
@@ -628,7 +628,7 @@
  *
  *************************************/
 
-static UINT16 common_io_chip_r(const address_space *space, int which, offs_t offset, UINT16 mem_mask)
+static UINT16 common_io_chip_r(address_space *space, int which, offs_t offset, UINT16 mem_mask)
 {
 	static const char *const portnames[2][8] =
 			{
@@ -679,7 +679,7 @@
 }
 
 
-static void common_io_chip_w(const address_space *space, int which, offs_t offset, UINT16 data, UINT16 mem_mask)
+static void common_io_chip_w(address_space *space, int which, offs_t offset, UINT16 data, UINT16 mem_mask)
 {
 	UINT8 old;
 
@@ -1311,7 +1311,7 @@
  *************************************/
 
 static ADDRESS_MAP_START( ga2_v25_map, ADDRESS_SPACE_PROGRAM, 8 )
-	AM_RANGE(0x00000, 0x0ffff) AM_ROM
+	AM_RANGE(0x00000, 0x0ffff) AM_ROM AM_REGION("mcu", 0)
 	AM_RANGE(0x10000, 0x1ffff) AM_RAM AM_BASE(&ga2_dpram)
 	AM_RANGE(0xf0000, 0xfffff) AM_ROM AM_REGION("mcu", 0)
 ADDRESS_MAP_END
@@ -2834,7 +2834,7 @@
 	ROM_LOAD( "mpr14943",     0x300000, 0x100000, CRC(24d40333) SHA1(38faf8f3eac317a163e93bd2247fe98189b13d2d) )
 	ROM_LOAD( "mpr14942",     0x400000, 0x100000, CRC(a89b0e90) SHA1(e14c62418eb7f9a2deb2a6dcf635bedc1c73c253) )
 
-	ROM_REGION( 0x100000, "mcu", 0 ) /* Protection CPU */
+	ROM_REGION( 0x10000, "mcu", 0 ) /* Protection CPU */
 	ROM_LOAD( "epr14468", 0x00000, 0x10000, CRC(77634daa) SHA1(339169d164b9ed7dc3787b084d33effdc8e9efc1) )
 
 	ROM_REGION( 0x400000, "gfx1", 0 ) /* tiles */
@@ -4063,7 +4063,7 @@
 {
 	// pretend that slave is following master op, enables attract mode video with sound
 	if (ACCESSING_BITS_0_7)
-		memory_write_byte( space, 0x810049, data );
+		space->write_byte( 0x810049, data );
 }
 
 static DRIVER_INIT( f1en )
diff -Nru src-old/mame/drivers/segaxbd.c src/mame/drivers/segaxbd.c
--- src-old/mame/drivers/segaxbd.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segaxbd.c	2010-08-19 00:26:14.000000000 -0700
@@ -386,7 +386,7 @@
 static TIMER_CALLBACK( delayed_sound_data_w )
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	soundlatch_w(space, 0, param);
 	cpu_set_input_line(state->soundcpu, INPUT_LINE_NMI, ASSERT_LINE);
diff -Nru src-old/mame/drivers/segaybd.c src/mame/drivers/segaybd.c
--- src-old/mame/drivers/segaybd.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/segaybd.c	2010-08-19 00:26:14.000000000 -0700
@@ -236,7 +236,7 @@
 static TIMER_CALLBACK( delayed_sound_data_w )
 {
 	segas1x_state *state = machine->driver_data<segas1x_state>();
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	soundlatch_w(space, 0, param);
 	cpu_set_input_line(state->soundcpu, INPUT_LINE_NMI, ASSERT_LINE);
diff -Nru src-old/mame/drivers/seibuspi.c src/mame/drivers/seibuspi.c
--- src-old/mame/drivers/seibuspi.c	2010-07-12 13:23:22.000000000 -0700
+++ src/mame/drivers/seibuspi.c	2010-08-30 08:20:58.000000000 -0700
@@ -24,12 +24,6 @@
       SYS386 seems like a lower-cost version of single-board SPI.
       It has a 40MHz AMD 386 and a considerably weaker sound system (dual MSM6295).
 
-NOTES:
-
-    rjetus:
-    - If you get a blank screen on startup you need to press F2 and choose "Reset settings",
-      followed by "Exit". This will create a proper NVRAM
-
 TODO:
 - Alpha blending. Screen shot on www.system16.com show that during attract mode
   in Viper Phase 1 the "Viper" part of the logo (the red part) should be partially
@@ -765,7 +759,7 @@
 
 static UINT8 ejsakura_input_port = 0;
 
-static UINT8 z80_fifoout_pop(const address_space *space)
+static UINT8 z80_fifoout_pop(address_space *space)
 {
 	UINT8 r;
 	if (fifoout_wpos == fifoout_rpos)
@@ -786,7 +780,7 @@
 	return r;
 }
 
-static void z80_fifoout_push(const address_space *space, UINT8 data)
+static void z80_fifoout_push(address_space *space, UINT8 data)
 {
 	fifoout_data[fifoout_wpos++] = data;
 	if (fifoout_wpos == FIFO_SIZE)
@@ -801,7 +795,7 @@
 	fifoout_read_request = 1;
 }
 
-static UINT8 z80_fifoin_pop(const address_space *space)
+static UINT8 z80_fifoin_pop(address_space *space)
 {
 	UINT8 r;
 	if (fifoin_wpos == fifoin_rpos)
@@ -822,7 +816,7 @@
 	return r;
 }
 
-static void z80_fifoin_push(const address_space *space, UINT8 data)
+static void z80_fifoin_push(address_space *space, UINT8 data)
 {
 	fifoin_data[fifoin_wpos++] = data;
 	if(fifoin_wpos == FIFO_SIZE)
@@ -2277,7 +2271,7 @@
 
 	/* video hardware */
 	MDRV_SCREEN_ADD("screen", RASTER)
-	MDRV_SCREEN_REFRESH_RATE(54)
+	MDRV_SCREEN_REFRESH_RATE(57.59)
 	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
 	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
 	MDRV_SCREEN_SIZE(64*8, 32*8)
@@ -2800,9 +2794,9 @@
 	ROM_LOAD("gd_8.216",   0x200000, 0x080000, CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
 ROM_END
 
-ROM_START( rdftdi )
+ROM_START( rdftit )
 	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
-	ROM_LOAD32_BYTE("u211.bin", 0x000000, 0x80000, CRC(fc0e2885) SHA1(79621155d992d504e993bd3ee0d6ff3903bd5415) )
+	ROM_LOAD32_BYTE("seibu1",   0x000000, 0x80000, CRC(de0c3e3c) SHA1(b00225bad282e46b5825608f76eea6670bfe5527) )
 	ROM_LOAD32_BYTE("u212.bin", 0x000001, 0x80000, CRC(58ccb10c) SHA1(0cce4057bfada78121d9586574b98d46cdd7dd46) )
 	ROM_LOAD32_BYTE("u210.bin", 0x000002, 0x80000, CRC(47fc3c96) SHA1(7378f8caa847f89f235b5be6779118721076873b) )
 	ROM_LOAD32_BYTE("u29.bin",  0x000003, 0x80000, CRC(271bdd4b) SHA1(0a805568cbd6a9c18bdb755a41972ff6bba9e6eb) )
@@ -2830,9 +2824,9 @@
 	ROM_LOAD("gd_8.216",   0x200000, 0x080000, CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
 ROM_END
 
-ROM_START( rdftit )
+ROM_START( rdfta )
 	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
-	ROM_LOAD32_BYTE("seibu1",   0x000000, 0x80000, CRC(de0c3e3c) SHA1(b00225bad282e46b5825608f76eea6670bfe5527) )
+	ROM_LOAD32_BYTE("seibu1a",  0x000000, 0x80000, CRC(c3bb2e58) SHA1(399ac4b387ba38f5fdad5c4172b2d3baeafd8773) )
 	ROM_LOAD32_BYTE("u212.bin", 0x000001, 0x80000, CRC(58ccb10c) SHA1(0cce4057bfada78121d9586574b98d46cdd7dd46) )
 	ROM_LOAD32_BYTE("u210.bin", 0x000002, 0x80000, CRC(47fc3c96) SHA1(7378f8caa847f89f235b5be6779118721076873b) )
 	ROM_LOAD32_BYTE("u29.bin",  0x000003, 0x80000, CRC(271bdd4b) SHA1(0a805568cbd6a9c18bdb755a41972ff6bba9e6eb) )
@@ -2860,36 +2854,67 @@
 	ROM_LOAD("gd_8.216",   0x200000, 0x080000, CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
 ROM_END
 
-ROM_START( rdfta )
+ROM_START( rdftadi ) // Dream Island license
 	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
-	ROM_LOAD32_BYTE("seibu1a",  0x000000, 0x80000, CRC(c3bb2e58) SHA1(399ac4b387ba38f5fdad5c4172b2d3baeafd8773) )
-	ROM_LOAD32_BYTE("u212.bin", 0x000001, 0x80000, CRC(58ccb10c) SHA1(0cce4057bfada78121d9586574b98d46cdd7dd46) )
-	ROM_LOAD32_BYTE("u210.bin", 0x000002, 0x80000, CRC(47fc3c96) SHA1(7378f8caa847f89f235b5be6779118721076873b) )
-	ROM_LOAD32_BYTE("u29.bin",  0x000003, 0x80000, CRC(271bdd4b) SHA1(0a805568cbd6a9c18bdb755a41972ff6bba9e6eb) )
+	ROM_LOAD32_BYTE("seibu__1.u0211",       0x000000, 0x080000, CRC(fc0e2885) SHA1(79621155d992d504e993bd3ee0d6ff3903bd5415) )
+	ROM_LOAD32_BYTE("raiden-f_prg2.u0212",  0x000001, 0x080000, CRC(58ccb10c) SHA1(0cce4057bfada78121d9586574b98d46cdd7dd46) )
+	ROM_LOAD32_WORD("raiden-f_prg34.u0219", 0x000002, 0x100000, CRC(63f01d17) SHA1(74dbd0417b974583da87fc6c7a081b03fd4e16b8) )
+
+	ROM_REGION( 0x30000, "gfx1", 0)	/* text layer roms */ /* Do we need to specify an "endianess" so this works on all machines? */
+	ROM_LOAD24_WORD_SWAP("raiden-f__fix.u0425", 0x000000, 0x20000, BAD_DUMP CRC(cc7acfde) SHA1(1f3c40b4d2009e011e135c89aebf2b4bd05fa861) ) // Need to verify ROM
+	ROM_LOAD24_BYTE("seibu__7.u048",            0x000002, 0x10000, CRC(4d87e1ea) SHA1(3230e9b643fad773e61ab8ce09c0cd7d4d0558e3) ) // socket is silkscreened on pcb FIXP
 
-	ROM_REGION( 0x30000, "gfx1", 0)	/* text layer roms */
-	ROM_LOAD24_BYTE("gd_5.423", 0x000000, 0x10000, CRC(8f8d4e14) SHA1(06c803975767ae98f40ba7ac5764a5bc8baa3a30) )
-	ROM_LOAD24_BYTE("gd_6.424", 0x000001, 0x10000, CRC(6ac64968) SHA1(ec395205c24c4f864a1f805bb0d4641562d4faa9) )
-	ROM_LOAD24_BYTE("gd_7.48",  0x000002, 0x10000, CRC(4d87e1ea) SHA1(3230e9b643fad773e61ab8ce09c0cd7d4d0558e3) )
+	ROM_REGION( 0x600000, "gfx2", 0)	/* background layer roms */
+	ROM_LOAD24_WORD("gun_dogs__bg1-d.u0415", 0x000000, 0x200000, CRC(6a68054c) SHA1(5cbfc4ac90045f1401c2dda7a51936558c9de07e) ) // pads are silkscreened on pcb BG12
+	ROM_LOAD24_BYTE("gun_dogs__bg1-p.u0410", 0x000002, 0x100000, CRC(3400794a) SHA1(719808f7442bac612cefd7b7fffcd665e6337ad0) ) // pads are silkscreened on pcb BG12P
+	ROM_LOAD24_WORD("gun_dogs__bg2-d.u0424", 0x300000, 0x200000, CRC(61cd2991) SHA1(bb608e3948bf9ea35b5e1615d2ba6858d029dcbe) ) // pads are silkscreened on pcb BG3
+	ROM_LOAD24_BYTE("gun_dogs__bg2-p.u049",  0x300002, 0x100000, CRC(502d5799) SHA1(c3a0e1a4f5a7b35572ae1ff31315da4ed08aa2fe) ) // pads are silkscreened on pcb BG3P
+
+	ROM_REGION( 0xc00000, "gfx3", 0)	/* sprites */
+	ROM_LOAD("gun_dogs__obj-1.u0322", 0x000000, 0x400000, CRC(59d86c99) SHA1(d3c9241e7b51fe21f8351051b063f91dc69bf905) ) // pads are silkscreened on pcb OBJ1
+	ROM_LOAD("gun_dogs__obj-2.u0324", 0x400000, 0x400000, CRC(1ceb0b6f) SHA1(97225a9b3e7be18080aa52f6570af2cce8f25c06) ) // pads are silkscreened on pcb OBJ2
+	ROM_LOAD("gun_dogs__obj-3.u0323", 0x800000, 0x400000, CRC(36e93234) SHA1(51917a80b7da5c32a9434a1076fc2916d62e6a3e) ) // pads are silkscreened on pcb OBJ3
+
+	ROM_REGION(0x200000, "ymf", ROMREGION_ERASE00)
+
+	ROM_REGION(0x400000, "user2", ROMREGION_ERASE00)	/* sound roms */
+	ROM_LOAD("raiden-f__pcm2.u0217", 0x000000, 0x400000, NO_DUMP )//the real rom used here is actually a 0x400000 long rom located at u0217 which contains the combined data of the two smaller roms on the older cart pcb at 217 and 216; pads are silkscreened SOUND0
+	//u0222 (unpopulated) is silkscreend SOUND1 and would expect a 27040 similar to the old gd_8 rom.
+	ROM_LOAD("gun_dogs__pcm.217", 0x000000, 0x200000, BAD_DUMP CRC(31253ad7) SHA1(c81c8d50f8f287f5cbfaec77b30d969b01ce11a9) )
+	ROM_LOAD("gd_8.216",   0x200000, 0x080000, BAD_DUMP CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
+ROM_END
+
+ROM_START( rdftam ) // Metrotainment license
+	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
+	ROM_LOAD32_BYTE("seibu_1.u0211",        0x000000, 0x080000, CRC(156D8DB0) SHA1(93662B3EE494E37A56428A7AA3DAD7A957835950) ) // socket is silkscreened on pcb PRG0
+	ROM_LOAD32_BYTE("raiden-f_prg2.u0212",  0x000001, 0x080000, CRC(58ccb10c) SHA1(0cce4057bfada78121d9586574b98d46cdd7dd46) )
+	ROM_LOAD32_WORD("raiden-f_prg34.u0219", 0x000002, 0x100000, CRC(63f01d17) SHA1(74dbd0417b974583da87fc6c7a081b03fd4e16b8) )
+
+	ROM_REGION( 0x30000, "gfx1", 0)	/* text layer roms */ /* Do we need to specify an "endianess" so this works on all machines? */
+	ROM_LOAD24_WORD_SWAP("raiden-f__fix.u0425", 0x000000, 0x20000, BAD_DUMP CRC(cc7acfde) SHA1(1f3c40b4d2009e011e135c89aebf2b4bd05fa861) ) // Need to verify ROM
+	ROM_LOAD24_BYTE("seibu__7.u048",            0x000002, 0x10000, CRC(4d87e1ea) SHA1(3230e9b643fad773e61ab8ce09c0cd7d4d0558e3) ) // socket is silkscreened on pcb FIXP
 
 	ROM_REGION( 0x600000, "gfx2", 0)	/* background layer roms */
-	ROM_LOAD24_WORD("gd_bg1-d.415", 0x000000, 0x200000, CRC(6a68054c) SHA1(5cbfc4ac90045f1401c2dda7a51936558c9de07e) )
-	ROM_LOAD24_BYTE("gd_bg1-p.410", 0x000002, 0x100000, CRC(3400794a) SHA1(719808f7442bac612cefd7b7fffcd665e6337ad0) )
-	ROM_LOAD24_WORD("gd_bg2-d.416", 0x300000, 0x200000, CRC(61cd2991) SHA1(bb608e3948bf9ea35b5e1615d2ba6858d029dcbe) )
-	ROM_LOAD24_BYTE("gd_bg2-p.49",  0x300002, 0x100000, CRC(502d5799) SHA1(c3a0e1a4f5a7b35572ae1ff31315da4ed08aa2fe) )
+	ROM_LOAD24_WORD("gun_dogs__bg1-d.u0415", 0x000000, 0x200000, CRC(6a68054c) SHA1(5cbfc4ac90045f1401c2dda7a51936558c9de07e) ) // pads are silkscreened on pcb BG12
+	ROM_LOAD24_BYTE("gun_dogs__bg1-p.u0410", 0x000002, 0x100000, CRC(3400794a) SHA1(719808f7442bac612cefd7b7fffcd665e6337ad0) ) // pads are silkscreened on pcb BG12P
+	ROM_LOAD24_WORD("gun_dogs__bg2-d.u0424", 0x300000, 0x200000, CRC(61cd2991) SHA1(bb608e3948bf9ea35b5e1615d2ba6858d029dcbe) ) // pads are silkscreened on pcb BG3
+	ROM_LOAD24_BYTE("gun_dogs__bg2-p.u049",  0x300002, 0x100000, CRC(502d5799) SHA1(c3a0e1a4f5a7b35572ae1ff31315da4ed08aa2fe) ) // pads are silkscreened on pcb BG3P
 
 	ROM_REGION( 0xc00000, "gfx3", 0)	/* sprites */
-	ROM_LOAD("gd_obj-1.322", 0x000000, 0x400000, CRC(59d86c99) SHA1(d3c9241e7b51fe21f8351051b063f91dc69bf905) )
-	ROM_LOAD("gd_obj-2.324", 0x400000, 0x400000, CRC(1ceb0b6f) SHA1(97225a9b3e7be18080aa52f6570af2cce8f25c06) )
-	ROM_LOAD("gd_obj-3.323", 0x800000, 0x400000, CRC(36e93234) SHA1(51917a80b7da5c32a9434a1076fc2916d62e6a3e) )
+	ROM_LOAD("gun_dogs__obj-1.u0322", 0x000000, 0x400000, CRC(59d86c99) SHA1(d3c9241e7b51fe21f8351051b063f91dc69bf905) ) // pads are silkscreened on pcb OBJ1
+	ROM_LOAD("gun_dogs__obj-2.u0324", 0x400000, 0x400000, CRC(1ceb0b6f) SHA1(97225a9b3e7be18080aa52f6570af2cce8f25c06) ) // pads are silkscreened on pcb OBJ2
+	ROM_LOAD("gun_dogs__obj-3.u0323", 0x800000, 0x400000, CRC(36e93234) SHA1(51917a80b7da5c32a9434a1076fc2916d62e6a3e) ) // pads are silkscreened on pcb OBJ3
 
 	ROM_REGION(0x200000, "ymf", ROMREGION_ERASE00)
 
-	ROM_REGION(0x280000, "user2", ROMREGION_ERASE00)	/* sound roms */
-	ROM_LOAD("gd_pcm.217", 0x000000, 0x200000, CRC(31253ad7) SHA1(c81c8d50f8f287f5cbfaec77b30d969b01ce11a9) )
-	ROM_LOAD("gd_8.216",   0x200000, 0x080000, CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
+	ROM_REGION(0x400000, "user2", ROMREGION_ERASE00)	/* sound roms */
+	ROM_LOAD("raiden-f__pcm2.u0217", 0x000000, 0x400000, NO_DUMP )//the real rom used here is actually a 0x400000 long rom located at u0217 which contains the combined data of the two smaller roms on the older cart pcb at 217 and 216; pads are silkscreened SOUND0
+	//u0222 (unpopulated) is silkscreend SOUND1 and would expect a 27040 similar to the old gd_8 rom.
+	ROM_LOAD("gun_dogs__pcm.217", 0x000000, 0x200000, BAD_DUMP CRC(31253ad7) SHA1(c81c8d50f8f287f5cbfaec77b30d969b01ce11a9) )
+	ROM_LOAD("gd_8.216",   0x200000, 0x080000, BAD_DUMP CRC(f88cb6e4) SHA1(fb35b41307b490d5d08e4b8a70f8ff4ce2ca8105) )
 ROM_END
 
+
 ROM_START( rdft2us )	/* Single board version SXX2F */
 	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
 	ROM_LOAD32_BYTE("prg0.u0259", 0x000000, 0x80000, CRC(ff3eeec1) SHA1(88c1741e4936db9a5b13e562061b0f1cc6fa6b36) )
@@ -3056,37 +3081,38 @@
 	ROM_LOAD("sound1.u0222", 0x200000, 0x080000, CRC(b7bd3703) SHA1(6427a7e6de10d6743d6e64b984a1d1c647f5643a) )
 ROM_END
 
-ROM_START( rdft2a ) /* SPI Cart, Asia (Metrotainment license) */
-	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
-	ROM_LOAD32_BYTE("prg0.met", 0x000000, 0x80000, CRC(046b3f0e) SHA1(033898f658d6007f891828835734422d4af36321) )
-	ROM_LOAD32_BYTE("prg1.bin", 0x000001, 0x80000, CRC(cab55d88) SHA1(246e13880d34b6c7c3f4ab5e18fa8a0547c03d9d) )
-	ROM_LOAD32_BYTE("prg2.bin", 0x000002, 0x80000, CRC(83758b0e) SHA1(63adb2d09e7bd7dba47a55b3b579d543dfb553e3) )
-	ROM_LOAD32_BYTE("prg3.bin", 0x000003, 0x80000, CRC(084fb5e4) SHA1(588bfe091662b88f02f528181a2f1d9c67c7b280) )
-
-	ROM_REGION( 0x30000, "gfx1", 0)
-	ROM_LOAD24_BYTE("fix0.u0524", 0x000001, 0x10000, CRC(6fdf4cf6) SHA1(7e9d4a49e829dfdc373c0f5acfbe8c7a91ac115b) )
-	ROM_LOAD24_BYTE("fix1.u0518", 0x000000, 0x10000, CRC(69b7899b) SHA1(d3cacd4ef4d2c95d803403101beb9d4be75fae61) )
-	ROM_LOAD24_BYTE("fixp.u0514", 0x000002, 0x10000, CRC(99a5fece) SHA1(44ae95d650ed6e00202d3438f5f91a5e52e319cb) )
-
-	ROM_REGION( 0xc00000, "gfx2", 0)	/* background layer roms */
-	ROM_LOAD24_WORD("bg-1d.u0535", 0x000000, 0x400000, CRC(6143f576) SHA1(c034923d0663d9ef24357a03098b8cb81dbab9f8) )
-	ROM_LOAD24_BYTE("bg-1p.u0537", 0x000002, 0x200000, CRC(55e64ef7) SHA1(aae991268948d07342ee8ba1b3761bd180aab8ec) )
-	ROM_LOAD24_WORD("bg-2d.u0536", 0x600000, 0x400000, CRC(c607a444) SHA1(dc1aa96a42e9394ca6036359670a4ec6f830c96d) )
-	ROM_LOAD24_BYTE("bg-2p.u0538", 0x600002, 0x200000, CRC(f0830248) SHA1(6075df96b49e70d2243fef691e096119e7a4d044) )
-
-	ROM_REGION( 0x1200000, "gfx3", 0)	/* sprites */
-	ROM_LOAD("obj3.u0434",  0x0000000, 0x400000, CRC(e08f42dc) SHA1(5188d71d4355eaf43ea8893b4cfc4fe80cc24f41) )
-	ROM_LOAD("obj3b.u0433", 0x0400000, 0x200000, CRC(1b6a523c) SHA1(99a420dbc8e22e7832ccda7cec9fa661a2a2687a) )
-	ROM_LOAD("obj2.u0431",  0x0600000, 0x400000, CRC(7aeadd8e) SHA1(47103c0579240c5b1add4d0b164eaf76f5fa97f0) )
-	ROM_LOAD("obj2b.u0432", 0x0a00000, 0x200000, CRC(5d790a5d) SHA1(1ed5d4ad4c9a7e505ce35dcc90d184c26ce891dc) )
-	ROM_LOAD("obj1.u0429",  0x0c00000, 0x400000, CRC(c2c50f02) SHA1(b81397b5800c6d49f58b7ac7ff6eac56da3c5257) )
-	ROM_LOAD("obj1b.u0430", 0x1000000, 0x200000, CRC(5259321f) SHA1(3c70c1147e49f81371d0f60f7108d9718d56faf4) )
+ROM_START( rdft2a ) /* SPI Cart, Asia (Metrotainment license); SPI PCB is marked "(C)1997 SXX2C ROM SUB8" */
+	// The SUB8 board is also capable of having two 23C8100 roms at U0223 and U0219 for PRG instead of the four roms below.
+	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program, all are 27C040 */
+	ROM_LOAD32_BYTE("seibu__1.u0211", 0x000000, 0x80000, CRC(046b3f0e) SHA1(033898f658d6007f891828835734422d4af36321) ) // socket is silkscreened on pcb PRG1
+	ROM_LOAD32_BYTE("seibu__2.u0212", 0x000001, 0x80000, CRC(cab55d88) SHA1(246e13880d34b6c7c3f4ab5e18fa8a0547c03d9d) ) // socket is silkscreened on pcb PRG2
+	ROM_LOAD32_BYTE("seibu__3.u0221", 0x000002, 0x80000, CRC(83758b0e) SHA1(63adb2d09e7bd7dba47a55b3b579d543dfb553e3) ) // socket is silkscreened on pcb PRG3
+	ROM_LOAD32_BYTE("seibu__4.u0220", 0x000003, 0x80000, CRC(084fb5e4) SHA1(588bfe091662b88f02f528181a2f1d9c67c7b280) ) // socket is silkscreened on pcb PRG4
+
+	ROM_REGION( 0x30000, "gfx1", 0)	/* all are 27C512 */
+	ROM_LOAD24_BYTE("seibu__5.u0524", 0x000001, 0x10000, CRC(6fdf4cf6) SHA1(7e9d4a49e829dfdc373c0f5acfbe8c7a91ac115b) ) // socket is silkscreened on pcb FIX0
+	ROM_LOAD24_BYTE("seibu__6.u0518", 0x000000, 0x10000, CRC(69b7899b) SHA1(d3cacd4ef4d2c95d803403101beb9d4be75fae61) ) // socket is silkscreened on pcb FIX1
+	ROM_LOAD24_BYTE("seibu__7.u0514", 0x000002, 0x10000, CRC(99a5fece) SHA1(44ae95d650ed6e00202d3438f5f91a5e52e319cb) ) // socket is silkscreened on pcb FIXP
+
+	ROM_REGION( 0xc00000, "gfx2", 0)	/* background layer roms - half are MX semiconductor MX23C3210MC, half are some sort of 23C1610 equivalent with no visible manufacturer name */
+	ROM_LOAD24_WORD("raiden-f2bg-1d.u0535", 0x000000, 0x400000, CRC(6143f576) SHA1(c034923d0663d9ef24357a03098b8cb81dbab9f8) ) // pads are silkscreened on pcb BG12
+	ROM_LOAD24_BYTE("raiden-f2__bg-1p.u0537", 0x000002, 0x200000, CRC(55e64ef7) SHA1(aae991268948d07342ee8ba1b3761bd180aab8ec) ) // pads are silkscreened on pcb BG12P
+	ROM_LOAD24_WORD("raiden-f2bg-2d.u0536", 0x600000, 0x400000, CRC(c607a444) SHA1(dc1aa96a42e9394ca6036359670a4ec6f830c96d) ) // pads are silkscreened on pcb BG3
+	ROM_LOAD24_BYTE("raiden-f2__bg-2p.u0538", 0x600002, 0x200000, CRC(f0830248) SHA1(6075df96b49e70d2243fef691e096119e7a4d044) ) // pads are silkscreened on pcb BG3P
+
+	ROM_REGION( 0x1200000, "gfx3", 0)	/* sprites - all are paired MX semconductor MX23C3210TC and MX23C1610TC mask roms */
+	ROM_LOAD("raiden-f2obj-3.u0434",  0x0000000, 0x400000, CRC(e08f42dc) SHA1(5188d71d4355eaf43ea8893b4cfc4fe80cc24f41) ) // pads are silkscreened on pcb OBJ3
+	ROM_LOAD("raiden-f2obj-6.u0433", 0x0400000, 0x200000, CRC(1b6a523c) SHA1(99a420dbc8e22e7832ccda7cec9fa661a2a2687a) ) // pads are silkscreened on pcb OBJ3B
+	ROM_LOAD("raiden-f2obj-2.u0431",  0x0600000, 0x400000, CRC(7aeadd8e) SHA1(47103c0579240c5b1add4d0b164eaf76f5fa97f0) ) // pads are silkscreened on pcb OBJ2
+	ROM_LOAD("raiden-f2obj-5.u0432", 0x0a00000, 0x200000, CRC(5d790a5d) SHA1(1ed5d4ad4c9a7e505ce35dcc90d184c26ce891dc) ) // pads are silkscreened on pcb OBJ2B
+	ROM_LOAD("raiden-f2obj-1.u0429",  0x0c00000, 0x400000, CRC(c2c50f02) SHA1(b81397b5800c6d49f58b7ac7ff6eac56da3c5257) ) // pads are silkscreened on pcb OBJ1
+	ROM_LOAD("raiden-f2obj-4.u0430", 0x1000000, 0x200000, CRC(5259321f) SHA1(3c70c1147e49f81371d0f60f7108d9718d56faf4) ) // pads are silkscreened on pcb OBJ1B
 
 	ROM_REGION(0x200000, "ymf", ROMREGION_ERASE00)
 
-	ROM_REGION(0x280000, "user2", ROMREGION_ERASE00)	/* sound roms */
-	ROM_LOAD("pcm.u0217",    0x000000, 0x200000, CRC(2edc30b5) SHA1(c25d690d633657fc3687636b9070f36bd305ae06) )
-	ROM_LOAD("sound1.u0222", 0x200000, 0x080000, CRC(b7bd3703) SHA1(6427a7e6de10d6743d6e64b984a1d1c647f5643a) )
+	ROM_REGION(0x280000, "user2", ROMREGION_ERASE00)	/* sound roms - sound0 is some sort of 23C1610 equivalent with no visible manufacturer name, sound1 is a 27C040 */
+	ROM_LOAD("raiden-f2__pcm.u0217",    0x000000, 0x200000, CRC(2edc30b5) SHA1(c25d690d633657fc3687636b9070f36bd305ae06) ) // pads are silkscreened on pcb SOUND0
+	ROM_LOAD("seibu__8.u0222", 0x200000, 0x080000, CRC(b7bd3703) SHA1(6427a7e6de10d6743d6e64b984a1d1c647f5643a) ) // socket is silkscreened on pcb SOUND1
 ROM_END
 
 ROM_START( rdft2a2 ) /* SPI Cart, Asia (Dream Island license) */
@@ -3276,7 +3302,7 @@
 	ROM_LOAD("sound1.u0222", 0x200000, 0x080000, CRC(d4fc3da1) SHA1(a03bd97e36a21d27a834b9691b27a7eb7ac51ff2) )
 ROM_END
 
-ROM_START( rfjetus )	/* Single board version SXX2G */
+ROM_START( rfjets )	/* Single board version SXX2G */
 	ROM_REGION32_LE(0x200000, "user1", 0)	/* i386 program */
 	ROM_LOAD32_BYTE("rfj-06.u0259", 0x000000, 0x80000, CRC(c835aa7a) SHA1(291eada97ceb907dfea15688ce6055e63b3aa675) ) /* PRG0 */
 	ROM_LOAD32_BYTE("rfj-07.u0258", 0x000001, 0x80000, CRC(3b6ca1ca) SHA1(9db019c0ddecfb58e2be5c345d78352f700035bf) ) /* PRG1 */
@@ -3305,6 +3331,9 @@
 	ROM_REGION(0x280000, "ymf", ROMREGION_ERASE00)	/* sound roms */
 	ROM_LOAD("pcm-d.u0103",  0x000000, 0x200000, CRC(8ee3ff45) SHA1(2801b23495866c91c8f8bebd37d5fcae7a625838) )
 	ROM_LOAD("rfj-04.u0107", 0x200000, 0x080000, CRC(c050da03) SHA1(1002dac51a3a4932c4f0074c1f3d97a597d98755) ) /* SOUND1 */
+
+	ROM_REGION16_BE( 0x80, "eeprom", 0 )
+	ROM_LOAD16_WORD( "93c46-rfjets.bin", 0x0000, 0x0080, CRC(8fe8063b) SHA1(afb0141580e1b2bd149092a9cc9e8b4072b1ef10) )
 ROM_END
 
 
@@ -3551,13 +3580,14 @@
 GAME( 1996, rdftu,     rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden Fighters (US)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1996, rdftau,    rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu", "Raiden Fighters (Australia)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1996, rdftj,     rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu", "Raiden Fighters (Japan set 2)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
-GAME( 1996, rdftdi,    rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu (Dream Island license)", "Raiden Fighters (Dream Island Co. license)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
+GAME( 1996, rdftadi,   rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu (Dream Island license)", "Raiden Fighters (Asia, Dream Island Co., LTD. license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
+GAME( 1996, rdftam,    rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu (Metrotainment license)", "Raiden Fighters (Asia, Metrotainment Network license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1996, rdftit,    rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu", "Raiden Fighters (Italy)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1996, rdfta,     rdft,    spi,      spi_3button, rdft,   ROT270, "Seibu Kaihatsu", "Raiden Fighters (Austria)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 
 GAME( 1997, rdft2,     0,       spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu (Tuning license)", "Raiden Fighters 2",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
-GAME( 1997, rdft2a2,   rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu (Dream Island license)", "Raiden Fighters 2 (Asia, Dream Island license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
-GAME( 1997, rdft2a,    rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu (Metrotainment license)", "Raiden Fighters 2 (Asia, Metrotainment license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
+GAME( 1997, rdft2a2,   rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu (Dream Island license)", "Raiden Fighters 2 (Asia, Dream Island Co., LTD. license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
+GAME( 1997, rdft2a,    rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu (Metrotainment license)", "Raiden Fighters 2 (Asia, Metrotainment Network license, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1997, rdft2j,    rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu", "Raiden Fighters 2 (Japan, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1997, rdft2j2,   rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu", "Raiden Fighters 2 (Japan set 2, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
 GAME( 1997, rdft2t,    rdft2,   spi,      spi_2button, rdft2,  ROT270, "Seibu Kaihatsu", "Raiden Fighters 2 (Taiwan, SPI)",  GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND )
@@ -3574,7 +3604,7 @@
 GAME( 1997, rdft2us,   rdft2,   sxx2f,    spi_2button, rdft2us,  ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden Fighters 2.1 (US, Single Board)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND ) // title screen shows '2.1'
 
 /* SXX2G */
-GAME( 1999, rfjetus,   rfjet,   sxx2g,    spi_2button, rfjet,    ROT270, "Seibu Kaihatsu (Fabtek license)", "Raiden Fighters Jet (US, Single Board)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND  ) // has 1998-99 copyright + planes unlocked
+GAME( 1999, rfjets,    rfjet,   sxx2g,    spi_2button, rfjet,    ROT270, "Seibu Kaihatsu", "Raiden Fighters Jet (Single Board)", GAME_IMPERFECT_GRAPHICS|GAME_IMPERFECT_SOUND  ) // has 1998-99 copyright + planes unlocked
 
 /* SYS386 */
 GAME( 2000, rdft22kc,  rdft2,   seibu386, seibu386_2button, rdft22kc, ROT270, "Seibu Kaihatsu", "Raiden Fighters 2 - 2000 (China)", GAME_IMPERFECT_GRAPHICS )
diff -Nru src-old/mame/drivers/seta.c src/mame/drivers/seta.c
--- src-old/mame/drivers/seta.c	2010-08-04 08:58:29.000000000 -0700
+++ src/mame/drivers/seta.c	2010-08-21 19:58:01.000000000 -0700
@@ -3020,7 +3020,7 @@
 
 static MACHINE_RESET(calibr50)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	sub_bankswitch_w(space, 0, 0);
 }
 
@@ -9662,17 +9662,17 @@
 	ROM_LOAD( "93uta08.69", 0x000000, 0x100000, CRC(3d50bbcd) SHA1(e9b78d08466e1f9b42f11999bb53b6deceb81a12) )
 ROM_END
 
-ROM_START( neobattl )
+ROM_START( neobattl )	// 1CC74: "SD GUNDAM v0.00. 1992/11/04 10:04:33"
 	ROM_REGION( 0x100000, "maincpu", 0 )		/* 68000 Code */
-	ROM_LOAD16_BYTE( "bp923001.u45", 0x000000, 0x020000, CRC(0d0aeb73) SHA1(5ca631d5d68e53029f379d9877a056997c6c6afa) )	// 1CC74: "SD GUNDAM v0.00. 1992/11/04 10:04:33"
-	ROM_LOAD16_BYTE( "bp923002.u46", 0x000001, 0x020000, CRC(9731fbbc) SHA1(196c913fb67496f9da2943ad1e69edf89cb65fdf) )
+	ROM_LOAD16_BYTE( "bp923001.u45", 0x000000, 0x020000, CRC(0d0aeb73) SHA1(5ca631d5d68e53029f379d9877a056997c6c6afa) ) /* Alt label X1-001 which is also a Seta custom chip number */
+	ROM_LOAD16_BYTE( "bp923002.u46", 0x000001, 0x020000, CRC(9731fbbc) SHA1(196c913fb67496f9da2943ad1e69edf89cb65fdf) ) /* Alt label X1-002A which is also a Seta custom chip number */
 
 	ROM_REGION( 0x100000, "gfx1", 0 )	/* Sprites */
-	ROM_LOAD( "bp923003.u15", 0x00000, 0x80000, CRC(91ca98a1) SHA1(b02b362e3a6118f52d9e1a262ca11aecef887b00) )
-	ROM_LOAD( "bp923004.u9",  0x80000, 0x80000, CRC(15c678e3) SHA1(8c0fa41a1f4e7b4e1c90faaeec7f6c910cc3ad0b) )
+	ROM_LOAD( "bp923-003.u15", 0x00000, 0x80000, CRC(91ca98a1) SHA1(b02b362e3a6118f52d9e1a262ca11aecef887b00) )
+	ROM_LOAD( "bp923-004.u9",  0x80000, 0x80000, CRC(15c678e3) SHA1(8c0fa41a1f4e7b4e1c90faaeec7f6c910cc3ad0b) )
 
 	ROM_REGION( 0x100000, "x1snd", 0 )	/* Samples */
-	ROM_LOAD( "bp923005.u4", 0x000000, 0x100000, CRC(7c0e37be) SHA1(5d5779de948f986971a82db2a5a4302044c3257a) )
+	ROM_LOAD( "bp923-005.u4", 0x000000, 0x100000, CRC(7c0e37be) SHA1(5d5779de948f986971a82db2a5a4302044c3257a) )
 ROM_END
 
 ROM_START( pairlove )
diff -Nru src-old/mame/drivers/seta2.c src/mame/drivers/seta2.c
--- src-old/mame/drivers/seta2.c	2010-08-04 08:58:29.000000000 -0700
+++ src/mame/drivers/seta2.c	2010-08-19 01:27:05.000000000 -0700
@@ -593,7 +593,7 @@
 	AM_RANGE(0xc50000, 0xc5ffff) AM_RAM								// cleared
 	AM_RANGE(0xc60000, 0xc6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)	// Video Registers
 	AM_RANGE(0xe00010, 0xe0001f) AM_WRITE(seta2_sound_bank_w)		// Samples Banks
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)	// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)	// TMP68301 Registers
 ADDRESS_MAP_END
 
 /***************************************************************************
@@ -632,7 +632,7 @@
 	AM_RANGE(0xc60000, 0xc6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)	// Video Registers
 	AM_RANGE(0xe00010, 0xe0001f) AM_WRITE(seta2_sound_bank_w)		// Samples Banks
 	AM_RANGE(0xfffd0a, 0xfffd0b) AM_DEVREADWRITE("eeprom", gundamex_eeprom_r,gundamex_eeprom_w)	// parallel data register
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)	// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)	// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -694,7 +694,7 @@
 	AM_RANGE(0xc00000, 0xc3ffff) AM_RAM AM_BASE_SIZE_MEMBER(seta2_state, spriteram, spriteram_size)	// Sprites
 	AM_RANGE(0xc40000, 0xc4ffff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0xc60000, 0xc6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)	// Video Registers
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)	// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)	// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -717,7 +717,7 @@
 	AM_RANGE(0xc00000, 0xc3ffff) AM_RAM AM_BASE_SIZE_MEMBER(seta2_state, spriteram, spriteram_size)		// Sprites
 	AM_RANGE(0xc40000, 0xc4ffff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0xc60000, 0xc6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)				// Video Registers
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)		// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)		// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -740,7 +740,7 @@
 	AM_RANGE(0xd00000, 0xd3ffff) AM_RAM AM_BASE_SIZE_MEMBER(seta2_state, spriteram, spriteram_size)		// Sprites
 	AM_RANGE(0xd40000, 0xd4ffff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0xd60000, 0xd6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)			// Video Registers
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)		// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)		// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -752,7 +752,7 @@
     The offset to use is stored in RAM at address 0x20BA16 */
 static READ16_HANDLER( pzlbowl_protection_r )
 {
-	UINT32 address = (memory_read_word(space, 0x20ba16) << 16) | memory_read_word(space, 0x20ba18);
+	UINT32 address = (space->read_word(0x20ba16) << 16) | space->read_word(0x20ba18);
 	return memory_region(space->machine, "maincpu")[address - 2];
 }
 
@@ -785,7 +785,7 @@
 	AM_RANGE(0x840000, 0x84ffff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0x860000, 0x86003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)				// Video Registers
 	AM_RANGE(0x900000, 0x903fff) AM_DEVREADWRITE("x1snd", seta_sound_word_r,seta_sound_word_w)	// Sound
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)		// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)		// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -811,7 +811,7 @@
 	AM_RANGE(0xb40000, 0xb4ffff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)	// Palette
 	AM_RANGE(0xb60000, 0xb6003f) AM_WRITE(seta2_vregs_w) AM_BASE_MEMBER(seta2_state, vregs)
 	AM_RANGE(0xa00000, 0xa03fff) AM_DEVREADWRITE("x1snd", seta_sound_word_r,seta_sound_word_w)	// Sound
-	AM_RANGE(0xfffc00, 0xffffff) AM_RAM_WRITE(tmp68301_regs_w) AM_BASE(&tmp68301_regs)		// TMP68301 Registers
+	AM_RANGE(0xfffc00, 0xffffff) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)		// TMP68301 Registers
 ADDRESS_MAP_END
 
 
@@ -857,7 +857,7 @@
 	AM_RANGE( 0x900000, 0x903fff ) AM_DEVREADWRITE( "x1snd", seta_sound_word_r, seta_sound_word_w	)	// Sound
 
 	AM_RANGE( 0xfffd0a, 0xfffd0b ) AM_READ_PORT("DSW2")				// parallel data register (DSW 2)
-	AM_RANGE( 0xfffc00, 0xffffff ) AM_RAM_WRITE( tmp68301_regs_w) AM_BASE(&tmp68301_regs )	// TMP68301 Registers
+	AM_RANGE( 0xfffc00, 0xffffff ) AM_READWRITE(tmp68301_regs_r, tmp68301_regs_w)	// TMP68301 Registers
 ADDRESS_MAP_END
 
 
diff -Nru src-old/mame/drivers/sf.c src/mame/drivers/sf.c
--- src-old/mame/drivers/sf.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/sf.c	2010-08-19 01:27:05.000000000 -0700
@@ -54,10 +54,10 @@
 /* The protection of the Japanese (and alt US) version */
 /* I'd love to see someone dump the 68705 / i8751 roms */
 
-static void write_dword( const address_space *space, offs_t offset, UINT32 data )
+static void write_dword( address_space *space, offs_t offset, UINT32 data )
 {
-	memory_write_word(space, offset, data >> 16);
-	memory_write_word(space, offset + 2, data);
+	space->write_word(offset, data >> 16);
+	space->write_word(offset + 2, data);
 }
 
 static WRITE16_HANDLER( protection_w )
@@ -71,10 +71,10 @@
 	int map;
 
 	map = maplist
-		[memory_read_byte(space, 0xffc006)]
-		[(memory_read_byte(space, 0xffc003) << 1) + (memory_read_word(space, 0xffc004) >> 8)];
+		[space->read_byte(0xffc006)]
+		[(space->read_byte(0xffc003) << 1) + (space->read_word(0xffc004) >> 8)];
 
-	switch (memory_read_byte(space, 0xffc684))
+	switch (space->read_byte(0xffc684))
 	{
 	case 1:
 		{
@@ -111,10 +111,10 @@
 			int d1 = delta1[map] + 0xc0;
 			int d2 = delta2[map];
 
-			memory_write_word(space, 0xffc680, d1);
-			memory_write_word(space, 0xffc682, d2);
-			memory_write_word(space, 0xffc00c, 0xc0);
-			memory_write_word(space, 0xffc00e, 0);
+			space->write_word(0xffc680, d1);
+			space->write_word(0xffc682, d2);
+			space->write_word(0xffc00c, 0xc0);
+			space->write_word(0xffc00e, 0);
 
 			sf_fg_scroll_w(space, 0, d1, 0xffff);
 			sf_bg_scroll_w(space, 0, d2, 0xffff);
@@ -122,13 +122,13 @@
 		}
 	case 4:
 		{
-			int pos = memory_read_byte(space, 0xffc010);
+			int pos = space->read_byte(0xffc010);
 			pos = (pos + 1) & 3;
-			memory_write_byte(space, 0xffc010, pos);
+			space->write_byte(0xffc010, pos);
 			if(!pos)
 			{
-				int d1 = memory_read_word(space, 0xffc682);
-				int off = memory_read_word(space, 0xffc00e);
+				int d1 = space->read_word(0xffc682);
+				int off = space->read_word(0xffc00e);
 				if (off!=512)
 				{
 					off++;
@@ -139,8 +139,8 @@
 					off = 0;
 					d1 -= 512;
 				}
-				memory_write_word(space, 0xffc682, d1);
-				memory_write_word(space, 0xffc00e, off);
+				space->write_word(0xffc682, d1);
+				space->write_word(0xffc00e, off);
 				sf_bg_scroll_w(space, 0, d1, 0xffff);
 			}
 			break;
@@ -148,7 +148,7 @@
 	default:
 		{
 			logerror("Write protection at %06x (%04x)\n", cpu_get_pc(space->cpu), data & 0xffff);
-			logerror("*** Unknown protection %d\n", memory_read_byte(space, 0xffc684));
+			logerror("*** Unknown protection %d\n", space->read_byte(0xffc684));
 			break;
 		}
 	}
diff -Nru src-old/mame/drivers/shaolins.c src/mame/drivers/shaolins.c
--- src-old/mame/drivers/shaolins.c	2010-05-25 17:12:11.000000000 -0700
+++ src/mame/drivers/shaolins.c	2010-08-19 15:57:51.000000000 -0700
@@ -232,6 +232,7 @@
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_DRIVER_END
 
+#if 0 // a bootleg board was found with downgraded sound hardware, but is otherwise the same
 static MACHINE_DRIVER_START( shaolinb )
 	MDRV_IMPORT_FROM(shaolins)
 
@@ -241,6 +242,7 @@
 	MDRV_SOUND_REPLACE("sn2", SN76489, MASTER_CLOCK/6)  /* only type verified on pcb */
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_DRIVER_END
+#endif
 
 /***************************************************************************
 
@@ -293,7 +295,7 @@
 ROM_END
 
 /*
-    Shao-lin's Road (Bootleg)
+    Shao-lin's Road (Bootleg) - has also been found on an original board
 
     Main Board:    VWXYZ
     Daughterboard: QSTU (Replaces 3 custom Konami chips)
@@ -337,8 +339,8 @@
 	ROM_LOAD( "7.j1", 0x2000, 0x4000, CRC(d9a7cff6) SHA1(47244426b9a674326c5303347112aa9d33bcf1df) ) /* 27128 */
 
 	ROM_REGION( 0x8000, "gfx2", 0 ) /* All roms are 27128 */
-	ROM_LOAD( "1.l8", 0x0000, 0x4000, CRC(a79959b2) SHA1(9c58975c55f7be32add0dccb259d9680410fa9bc) )
-	ROM_LOAD( "2.m8", 0x4000, 0x4000, CRC(560521c7) SHA1(f8a50c66364995041e29ed7be2e4ea1ad16aa735) )
+	ROM_LOAD( "2.m8", 0x0000, 0x4000, CRC(560521c7) SHA1(f8a50c66364995041e29ed7be2e4ea1ad16aa735) )
+	ROM_LOAD( "1.l8", 0x4000, 0x4000, CRC(a79959b2) SHA1(9c58975c55f7be32add0dccb259d9680410fa9bc) )
 
 	ROM_REGION( 0x0500, "proms", 0 ) /* All proms are N82S129N */
 	ROM_LOAD( "3.k1", 0x0000, 0x0100, CRC(b09db4b4) SHA1(d21176cdc7def760da109083eb52e5b6a515021f) ) /* palette red component */
@@ -349,7 +351,7 @@
 ROM_END
 
 
-/*    YEAR, NAME,     PARENT, MACHINE,  INPUT,    INIT, MONITOR, COMPANY,  FULLNAME,                    FLAGS */
-GAME( 1985, kicker,   0,      shaolins, shaolins, 0,    ROT90,  "Konami",  "Kicker",                    0 )
-GAME( 1985, shaolins, kicker, shaolins, shaolins, 0,    ROT90,  "Konami",  "Shao-lin's Road",           0 )
-GAME( 1985, shaolinb, kicker, shaolinb, shaolins, 0,    ROT90,  "bootleg", "Shao-lin's Road (bootleg)", GAME_IMPERFECT_COLORS )
+/*    YEAR, NAME,     PARENT, MACHINE,  INPUT,    INIT, MONITOR, COMPANY,  FULLNAME,                  FLAGS */
+GAME( 1985, kicker,   0,      shaolins, shaolins, 0,    ROT90,  "Konami",  "Kicker",                  0 )
+GAME( 1985, shaolins, kicker, shaolins, shaolins, 0,    ROT90,  "Konami",  "Shao-lin's Road (set 1)", 0 )
+GAME( 1985, shaolinb, kicker, shaolins, shaolins, 0,    ROT90,  "Konami",  "Shao-lin's Road (set 2)", 0 )
diff -Nru src-old/mame/drivers/shootout.c src/mame/drivers/shootout.c
--- src-old/mame/drivers/shootout.c	2010-05-23 06:06:09.000000000 -0700
+++ src/mame/drivers/shootout.c	2010-08-19 07:19:38.000000000 -0700
@@ -413,13 +413,13 @@
 
 static DRIVER_INIT( shootout )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int length = memory_region_length(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, length - 0x8000);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int A;
 
-	memory_set_decrypted_region(space, 0x8000, 0xffff, decrypt);
+	space->set_decrypted_region(0x8000, 0xffff, decrypt);
 
 	for (A = 0x8000;A < length;A++)
 		decrypt[A-0x8000] = (rom[A] & 0x9f) | ((rom[A] & 0x40) >> 1) | ((rom[A] & 0x20) << 1);
diff -Nru src-old/mame/drivers/skeetsht.c src/mame/drivers/skeetsht.c
--- src-old/mame/drivers/skeetsht.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/skeetsht.c	2010-08-15 17:41:11.000000000 -0700
@@ -47,9 +47,6 @@
 
 	state->ay = machine->device("aysnd");
 	state->tms = machine->device("tms");
-
-	/* Setup the Bt476 VGA RAMDAC palette chip */
-	tlc34076_reset(6);
 }
 
 
@@ -66,7 +63,7 @@
 static void skeetsht_scanline_update(screen_device &screen, bitmap_t *bitmap, int scanline, const tms34010_display_params *params)
 {
 	skeetsht_state *state = screen.machine->driver_data<skeetsht_state>();
-	const rgb_t *const pens = tlc34076_get_pens();
+	const rgb_t *const pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	UINT16 *vram = &state->tms_vram[(params->rowaddr << 8) & 0x3ff00];
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
 	int coladdr = params->coladdr;
@@ -87,7 +84,7 @@
 	if (offset & 8)
 		offset = (offset & ~8) | 4;
 
-	return tlc34076_r(space, offset);
+	return tlc34076_r(space->machine->device("tlc34076"), offset);
 }
 
 static WRITE16_HANDLER( ramdac_w )
@@ -97,7 +94,7 @@
 	if (offset & 8)
 		offset = (offset & ~8) | 4;
 
-	tlc34076_w(space, offset, data);
+	tlc34076_w(space->machine->device("tlc34076"), offset, data);
 }
 
 
@@ -243,6 +240,7 @@
 };
 
 
+
 /*************************************
  *
  *  Machine driver
@@ -264,6 +262,8 @@
 
 	MDRV_MACHINE_RESET(skeetsht)
 
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
 	MDRV_SCREEN_RAW_PARAMS(48000000 / 8, 156*4, 0, 100*4, 328, 0, 300) // FIXME
diff -Nru src-old/mame/drivers/skimaxx.c src/mame/drivers/skimaxx.c
--- src-old/mame/drivers/skimaxx.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/skimaxx.c	2010-08-19 00:26:14.000000000 -0700
@@ -150,12 +150,12 @@
  *************************************/
 
 // TODO: Might not be used
-static void skimaxx_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void skimaxx_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &fg_buffer[TOWORD(address)], 512 * sizeof(UINT16));
 }
 
-static void skimaxx_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void skimaxx_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&fg_buffer[TOWORD(address)], shiftreg, 512 * sizeof(UINT16));
 }
diff -Nru src-old/mame/drivers/slapfght.c src/mame/drivers/slapfght.c
--- src-old/mame/drivers/slapfght.c	2010-07-05 11:19:45.000000000 -0700
+++ src/mame/drivers/slapfght.c	2010-08-19 00:26:14.000000000 -0700
@@ -739,7 +739,7 @@
 
 static VIDEO_EOF( perfrman )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram_w(space, 0, 0);
 }
 
diff -Nru src-old/mame/drivers/snk.c src/mame/drivers/snk.c
--- src-old/mame/drivers/snk.c	2010-05-28 18:47:40.000000000 -0700
+++ src/mame/drivers/snk.c	2010-08-26 20:55:49.000000000 -0700
@@ -268,12 +268,6 @@
 #include "sound/8950intf.h"
 
 
-static int countryc_trackball;
-
-static int marvins_sound_busy_flag;
-// FIXME this should be initialised on machine reset
-static int sound_status;
-
 /*********************************************************************/
 // Interrupt handlers common to all SNK triple Z80 games
 
@@ -316,20 +310,26 @@
 
 static WRITE8_HANDLER( marvins_soundlatch_w )
 {
-	marvins_sound_busy_flag = 1;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->marvins_sound_busy_flag = 1;
 	soundlatch_w(space, offset, data);
 	cputag_set_input_line(space->machine, "audiocpu", 0, HOLD_LINE);
 }
 
 static READ8_HANDLER( marvins_soundlatch_r )
 {
-	marvins_sound_busy_flag = 0;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->marvins_sound_busy_flag = 0;
 	return soundlatch_r(space, 0);
 }
 
 static CUSTOM_INPUT( marvins_sound_busy )
 {
-	return marvins_sound_busy_flag;
+	snk_state *state = field->port->machine->driver_data<snk_state>();
+
+	return state->marvins_sound_busy_flag;
 }
 
 static READ8_HANDLER( marvins_sound_nmi_ack_r )
@@ -342,22 +342,24 @@
 
 static TIMER_CALLBACK( sgladiat_sndirq_update_callback )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	switch(param)
 	{
 		case CMDIRQ_BUSY_ASSERT:
-			sound_status |= 8|4;
+			state->sound_status |= 8|4;
 			break;
 
 		case BUSY_CLEAR:
-			sound_status &= ~4;
+			state->sound_status &= ~4;
 			break;
 
 		case CMDIRQ_CLEAR:
-			sound_status &= ~8;
+			state->sound_status &= ~8;
 			break;
 	}
 
-	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_NMI, (sound_status & 0x8) ? ASSERT_LINE : CLEAR_LINE);
+	cputag_set_input_line(machine, "audiocpu", INPUT_LINE_NMI, (state->sound_status & 0x8) ? ASSERT_LINE : CLEAR_LINE);
 }
 
 
@@ -411,38 +413,40 @@
 
 static TIMER_CALLBACK( sndirq_update_callback )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	switch(param)
 	{
 		case YM1IRQ_ASSERT:
-			sound_status |= 1;
+			state->sound_status |= 1;
 			break;
 
 		case YM1IRQ_CLEAR:
-			sound_status &= ~1;
+			state->sound_status &= ~1;
 			break;
 
 		case YM2IRQ_ASSERT:
-			sound_status |= 2;
+			state->sound_status |= 2;
 			break;
 
 		case YM2IRQ_CLEAR:
-			sound_status &= ~2;
+			state->sound_status &= ~2;
 			break;
 
 		case CMDIRQ_BUSY_ASSERT:
-			sound_status |= 8|4;
+			state->sound_status |= 8|4;
 			break;
 
 		case BUSY_CLEAR:
-			sound_status &= ~4;
+			state->sound_status &= ~4;
 			break;
 
 		case CMDIRQ_CLEAR:
-			sound_status &= ~8;
+			state->sound_status &= ~8;
 			break;
 	}
 
-	cputag_set_input_line(machine, "audiocpu", 0, (sound_status & 0xb) ? ASSERT_LINE : CLEAR_LINE);
+	cputag_set_input_line(machine, "audiocpu", 0, (state->sound_status & 0xb) ? ASSERT_LINE : CLEAR_LINE);
 }
 
 
@@ -490,14 +494,18 @@
 
 static CUSTOM_INPUT( snk_sound_busy )
 {
-	return (sound_status & 4) ? 1 : 0;
+	snk_state *state = field->port->machine->driver_data<snk_state>();
+
+	return (state->sound_status & 4) ? 1 : 0;
 }
 
 
 
 static READ8_HANDLER( snk_sound_status_r )
 {
-	return sound_status;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	return state->sound_status;
 }
 
 static WRITE8_HANDLER( snk_sound_status_w )
@@ -578,7 +586,8 @@
 
 static int hardflags_check(running_machine *machine, int num)
 {
-	const UINT8 *sr = &machine->generic.spriteram.u8[0x800 + 4*num];
+	snk_state *state = machine->driver_data<snk_state>();
+	const UINT8 *sr = &state->spriteram[0x800 + 4*num];
 	int x = sr[2] + ((sr[3] & 0x80) << 1);
 	int y = sr[0] + ((sr[3] & 0x10) << 4);
 
@@ -671,7 +680,8 @@
 
 static int turbofront_check(running_machine *machine, int small, int num)
 {
-	const UINT8 *sr = &machine->generic.spriteram.u8[0x800*small + 4*num];
+	snk_state *state = machine->driver_data<snk_state>();
+	const UINT8 *sr = &state->spriteram[0x800*small + 4*num];
 	int x = sr[2] + ((sr[3] & 0x80) << 1);
 	int y = sr[0] + ((sr[3] & 0x10) << 4);
 
@@ -730,19 +740,18 @@
 
 static CUSTOM_INPUT( gwar_rotary )
 {
-	static int last_value[2] = {0, 0};
-	static int cp_count[2] = {0, 0};
+	snk_state *state = field->port->machine->driver_data<snk_state>();
 	static const char *const ports[] = { "P1ROT", "P2ROT" };
 	int which = (int)(FPTR)param;
 	int value = input_port_read(field->port->machine, ports[which]);
 
-	if ((last_value[which] == 0x5 && value == 0x6) || (last_value[which] == 0x6 && value == 0x5))
+	if ((state->last_value[which] == 0x5 && value == 0x6) || (state->last_value[which] == 0x6 && value == 0x5))
 	{
-		if (!cp_count[which])
+		if (!state->cp_count[which])
 			value = 0xf;
-		cp_count[which] = (cp_count[which] + 1) & 0x07;
+		state->cp_count[which] = (state->cp_count[which] + 1) & 0x07;
 	}
-	last_value[which] = value;
+	state->last_value[which] = value;
 
 	return value;
 }
@@ -791,17 +800,23 @@
 
 static WRITE8_HANDLER( countryc_trackball_w )
 {
-	countryc_trackball = data & 1;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->countryc_trackball = data & 1;
 }
 
 static CUSTOM_INPUT( countryc_trackball_x )
 {
-	return input_port_read(field->port->machine, countryc_trackball ? "TRACKBALLX2" : "TRACKBALLX1");
+	snk_state *state = field->port->machine->driver_data<snk_state>();
+
+	return input_port_read(field->port->machine, state->countryc_trackball ? "TRACKBALLX2" : "TRACKBALLX1");
 }
 
 static CUSTOM_INPUT( countryc_trackball_y )
 {
-	return input_port_read(field->port->machine, countryc_trackball ? "TRACKBALLY2" : "TRACKBALLY1");
+	snk_state *state = field->port->machine->driver_data<snk_state>();
+
+	return input_port_read(field->port->machine, state->countryc_trackball ? "TRACKBALLY2" : "TRACKBALLY1");
 }
 
 
@@ -842,12 +857,12 @@
 	AM_RANGE(0x8500, 0x8500) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8600, 0x8600) AM_WRITE(marvins_flipscreen_w)
 	AM_RANGE(0x8700, 0x8700) AM_READWRITE(snk_cpuB_nmi_trigger_r, snk_cpuA_nmi_ack_w)
-	AM_RANGE(0xc000, 0xcfff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_fg_videoram)
+	AM_RANGE(0xc000, 0xcfff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, fg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share3")
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share4") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM AM_SHARE("share5")
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 	AM_RANGE(0xf800, 0xf800) AM_WRITE(snk_sp16_scrolly_w)
 	AM_RANGE(0xf900, 0xf900) AM_WRITE(snk_sp16_scrollx_w)
 	AM_RANGE(0xfa00, 0xfa00) AM_WRITE(snk_fg_scrolly_w)
@@ -889,13 +904,13 @@
 	AM_RANGE(0x8500, 0x8500) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8600, 0x8600) AM_MIRROR(0xff) AM_WRITE(marvins_flipscreen_w)
 	AM_RANGE(0x8700, 0x8700) AM_READWRITE(snk_cpuB_nmi_trigger_r, snk_cpuA_nmi_ack_w)
-	AM_RANGE(0xc000, 0xc7ff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xc000, 0xc7ff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
 	AM_RANGE(0xc800, 0xc800) AM_MIRROR(0xff) AM_WRITE(marvins_palette_bank_w)
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share3")
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share4") AM_BASE(&snk_fg_videoram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, fg_videoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM AM_SHARE("share5")
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 	AM_RANGE(0xf800, 0xf800) AM_MIRROR(0xff) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xf900, 0xf900) AM_MIRROR(0xff) AM_WRITE(snk_bg_scrollx_w)
 	AM_RANGE(0xfa00, 0xfa00) AM_MIRROR(0xff) AM_WRITE(snk_sprite_split_point_w)
@@ -936,13 +951,13 @@
 	AM_RANGE(0x8500, 0x8500) AM_READ_PORT("DSW2")
 	AM_RANGE(0x8600, 0x8600) AM_MIRROR(0xff) AM_WRITE(marvins_flipscreen_w)
 	AM_RANGE(0x8700, 0x8700) AM_READWRITE(snk_cpuB_nmi_trigger_r, snk_cpuA_nmi_ack_w)
-	AM_RANGE(0xc000, 0xc7ff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share4")  AM_BASE(&snk_fg_videoram)
+	AM_RANGE(0xc000, 0xc7ff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(marvins_fg_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, fg_videoram)
 	AM_RANGE(0xc800, 0xc800) AM_MIRROR(0xff) AM_WRITE(marvins_palette_bank_w)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share5")
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2")AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM AM_SHARE("share3")
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE(&snk_tx_videoram)
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share6") AM_BASE_MEMBER(snk_state, tx_videoram)
 	AM_RANGE(0xf800, 0xf800) AM_WRITE(snk_sp16_scrolly_w)
 	AM_RANGE(0xf900, 0xf900) AM_WRITE(snk_sp16_scrollx_w)
 	AM_RANGE(0xfa00, 0xfa00) AM_WRITE(snk_fg_scrolly_w)
@@ -989,9 +1004,9 @@
 	AM_RANGE(0xd500, 0xd500) AM_WRITE(snk_sp16_scrollx_w)
 	AM_RANGE(0xd600, 0xd600) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xd700, 0xd700) AM_WRITE(snk_bg_scrollx_w)
-	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
-	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xe000, 0xefff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 	AM_RANGE(0xffff, 0xffff) AM_WRITENOP	// simply a program patch to not write to two not existing video registers?
 ADDRESS_MAP_END
 
@@ -1020,10 +1035,10 @@
 	AM_RANGE(0xd500, 0xd500) AM_WRITE(snk_sp16_scrollx_w)
 	AM_RANGE(0xd600, 0xd600) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xd700, 0xd700) AM_WRITE(snk_bg_scrollx_w)
-	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xe800, 0xefff) AM_RAM
-	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xf000, 0xf7ff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( sgladiat_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1057,9 +1072,9 @@
 	AM_RANGE(0xd500, 0xd500) AM_WRITE(snk_sp16_scrollx_w)
 	AM_RANGE(0xd600, 0xd600) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xd700, 0xd700) AM_WRITE(snk_bg_scrollx_w)
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_BASE_GENERIC(spriteram) AM_SHARE("share1")	// + work ram
-	AM_RANGE(0xe800, 0xf7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_BASE_MEMBER(snk_state, spriteram) AM_SHARE("share1")	// + work ram
+	AM_RANGE(0xe800, 0xf7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( hal21_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1088,9 +1103,9 @@
 	AM_RANGE(0xce00, 0xce00) AM_WRITENOP	// always 05?
 	AM_RANGE(0xcf00, 0xcf00) AM_WRITE(aso_bg_bank_w)	// tile and palette bank
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share1")
-	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("share2") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xe800, 0xf7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share3") AM_BASE(&snk_bg_videoram)
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xe000, 0xe7ff) AM_RAM AM_SHARE("share2") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xe800, 0xf7ff) AM_RAM_WRITE(marvins_bg_videoram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, bg_videoram)
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( aso_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1121,9 +1136,9 @@
 	AM_RANGE(0xcb00, 0xcb00) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xcc00, 0xcc00) AM_WRITE(snk_bg_scrollx_w)
 	AM_RANGE(0xcf00, 0xcf00) AM_WRITENOP	// fitegolf/countryc only. Either 0 or 1. Video related?
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM AM_SHARE("share1") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xd800, 0xf7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM AM_SHARE("share1") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xd800, 0xf7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( tnk3_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1167,9 +1182,9 @@
 	AM_RANGE(0xcea0, 0xcea0) AM_READ(hardflags6_r)
 	AM_RANGE(0xcee0, 0xcee0) AM_READ(hardflags7_r)
 	// note the mirror. ikari and victroad use d800, ikarijp uses d000
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_MIRROR(0x0800) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_MIRROR(0x0800) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( ikari_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1230,10 +1245,10 @@
 	AM_RANGE(0xccd0, 0xccd0) AM_READ(turbocheck32_2_r)
 	AM_RANGE(0xcce0, 0xcce0) AM_READ(turbocheck32_3_r)
 	AM_RANGE(0xccf0, 0xccf0) AM_READ(turbocheck32_4_r)
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( bermudat_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1276,10 +1291,10 @@
 	AM_RANGE(0xca00, 0xca00) AM_WRITENOP	// always 0?
 	AM_RANGE(0xca40, 0xca40) AM_WRITENOP	// always 0?
 	AM_RANGE(0xcac0, 0xcac0) AM_WRITE(snk_sprite_split_point_w)
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share3") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( gwar_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1303,10 +1318,10 @@
 	AM_RANGE(0xc500, 0xc500) AM_READ_PORT("DSW1")
 	AM_RANGE(0xc600, 0xc600) AM_READ_PORT("DSW2")
 	AM_RANGE(0xc700, 0xc700) AM_READWRITE(snk_cpuB_nmi_trigger_r, snk_cpuA_nmi_ack_w)
-	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share1") AM_BASE(&snk_tx_videoram)	// + work RAM
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share2") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share1") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share2") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share3")
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share4") AM_BASE_GENERIC(spriteram)	// + work ram
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share4") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
 	AM_RANGE(0xf800, 0xf800) AM_WRITE(snk_bg_scrolly_w)
 	AM_RANGE(0xf840, 0xf840) AM_WRITE(snk_bg_scrollx_w)
 	AM_RANGE(0xf880, 0xf880) AM_WRITE(gwara_videoattrs_w)	// flip screen, scroll msb
@@ -1325,7 +1340,7 @@
 	AM_RANGE(0xc800, 0xcfff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share1")
 	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share2")
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share3")
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share4") AM_BASE_GENERIC(spriteram)	// + work ram
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM AM_SHARE("share4") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
 	AM_RANGE(0xf8c0, 0xf8c0) AM_WRITE(gwar_tx_bank_w)	// char and palette bank
 ADDRESS_MAP_END
 
@@ -1354,10 +1369,10 @@
 	AM_RANGE(0xc900, 0xc900) AM_WRITE(tdfever_sp_scroll_msb_w)
 	AM_RANGE(0xc980, 0xc980) AM_WRITE(snk_sp32_scrolly_w)
 	AM_RANGE(0xc9c0, 0xc9c0) AM_WRITE(snk_sp32_scrollx_w)
-	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE(&snk_bg_videoram)
+	AM_RANGE(0xd000, 0xd7ff) AM_RAM_WRITE(snk_bg_videoram_w) AM_SHARE("share1") AM_BASE_MEMBER(snk_state, bg_videoram)
 	AM_RANGE(0xd800, 0xdfff) AM_RAM AM_SHARE("share2")
-	AM_RANGE(0xe000, 0xf7ff) AM_RAM_WRITE(tdfever_spriteram_w) AM_SHARE("share3") AM_BASE_GENERIC(spriteram)	// + work ram
-	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE(&snk_tx_videoram)	// + work RAM
+	AM_RANGE(0xe000, 0xf7ff) AM_RAM_WRITE(tdfever_spriteram_w) AM_SHARE("share3") AM_BASE_MEMBER(snk_state, spriteram)	// + work ram
+	AM_RANGE(0xf800, 0xffff) AM_RAM_WRITE(snk_tx_videoram_w) AM_SHARE("share4") AM_BASE_MEMBER(snk_state, tx_videoram)	// + work RAM
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( tdfever_cpuB_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -3612,6 +3627,8 @@
 
 static MACHINE_DRIVER_START( marvins )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, 3360000)	/* 3.36 MHz */
 	MDRV_CPU_PROGRAM_MAP(marvins_cpuA_map)
@@ -3686,6 +3703,8 @@
 
 static MACHINE_DRIVER_START( jcross )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, 3350000) /* NOT verified */
 	MDRV_CPU_PROGRAM_MAP(jcross_cpuA_map)
@@ -3771,6 +3790,8 @@
 
 static MACHINE_DRIVER_START( tnk3 )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, XTAL_13_4MHz/4) /* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(tnk3_cpuA_map)
@@ -3862,6 +3883,8 @@
 
 static MACHINE_DRIVER_START( ikari )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, XTAL_13_4MHz/4) /* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(ikari_cpuA_map)
@@ -3922,6 +3945,8 @@
 
 static MACHINE_DRIVER_START( bermudat )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, XTAL_8MHz/2) /* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(bermudat_cpuA_map)
@@ -4036,6 +4061,8 @@
 
 static MACHINE_DRIVER_START( tdfever )
 
+	MDRV_DRIVER_DATA( snk_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", Z80, 4000000)
 	MDRV_CPU_PROGRAM_MAP(tdfever_cpuA_map)
diff -Nru src-old/mame/drivers/snk6502.c src/mame/drivers/snk6502.c
--- src-old/mame/drivers/snk6502.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/snk6502.c	2010-08-26 20:55:49.000000000 -0700
@@ -283,16 +283,18 @@
 
 
 /* binary counter (1.4MHz update) */
-static UINT8 sasuke_counter;
-
 static TIMER_DEVICE_CALLBACK( sasuke_update_counter )
 {
-	sasuke_counter += 0x10;
+	snk6502_state *state = timer.machine->driver_data<snk6502_state>();
+
+	state->sasuke_counter += 0x10;
 }
 
 static void sasuke_start_counter(running_machine *machine)
 {
-	sasuke_counter = 0;
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+
+	state->sasuke_counter = 0;
 }
 
 
@@ -304,12 +306,14 @@
 
 static CUSTOM_INPUT( snk6502_music0_r )
 {
-	return (snk6502_music0_playing() ? 0x01 : 0x00);
+	return (snk6502_music0_playing(field->port->machine) ? 0x01 : 0x00);
 }
 
 static CUSTOM_INPUT( sasuke_count_r )
 {
-	return (sasuke_counter >> 4);
+	snk6502_state *state = field->port->machine->driver_data<snk6502_state>();
+
+	return (state->sasuke_counter >> 4);
 }
 
 
@@ -321,10 +325,10 @@
 
 static ADDRESS_MAP_START( sasuke_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x03ff) AM_RAM
-	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE(&snk6502_videoram2)
-	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE(&snk6502_videoram)
-	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE(&snk6502_colorram)
-	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE(&snk6502_charram)
+	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE_MEMBER(snk6502_state, videoram2)
+	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE_MEMBER(snk6502_state, videoram)
+	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE_MEMBER(snk6502_state, colorram)
+	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE_MEMBER(snk6502_state, charram)
 	AM_RANGE(0x3000, 0x3000) AM_DEVWRITE("crtc", mc6845_address_w)
 	AM_RANGE(0x3001, 0x3001) AM_DEVWRITE("crtc", mc6845_register_w)
 	AM_RANGE(0x4000, 0x8fff) AM_ROM
@@ -340,10 +344,10 @@
 
 static ADDRESS_MAP_START( satansat_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x03ff) AM_RAM
-	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE(&snk6502_videoram2)
-	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE(&snk6502_videoram)
-	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE(&snk6502_colorram)
-	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE(&snk6502_charram)
+	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE_MEMBER(snk6502_state, videoram2)
+	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE_MEMBER(snk6502_state, videoram)
+	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE_MEMBER(snk6502_state, colorram)
+	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE_MEMBER(snk6502_state, charram)
 	AM_RANGE(0x3000, 0x3000) AM_DEVWRITE("crtc", mc6845_address_w)
 	AM_RANGE(0x3001, 0x3001) AM_DEVWRITE("crtc", mc6845_register_w)
 	AM_RANGE(0x4000, 0x97ff) AM_ROM
@@ -359,10 +363,10 @@
 
 static ADDRESS_MAP_START( vanguard_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x03ff) AM_RAM
-	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE(&snk6502_videoram2)
-	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE(&snk6502_videoram)
-	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE(&snk6502_colorram)
-	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE(&snk6502_charram)
+	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE_MEMBER(snk6502_state, videoram2)
+	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE_MEMBER(snk6502_state, videoram)
+	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE_MEMBER(snk6502_state, colorram)
+	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE_MEMBER(snk6502_state, charram)
 	AM_RANGE(0x3000, 0x3000) AM_DEVWRITE("crtc", mc6845_address_w)
 	AM_RANGE(0x3001, 0x3001) AM_DEVWRITE("crtc", mc6845_register_w)
 	AM_RANGE(0x3100, 0x3102) AM_WRITE(vanguard_sound_w)
@@ -380,10 +384,10 @@
 
 static ADDRESS_MAP_START( fantasy_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x03ff) AM_RAM
-	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE(&snk6502_videoram2)
-	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE(&snk6502_videoram)
-	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE(&snk6502_colorram)
-	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE(&snk6502_charram)
+	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE_MEMBER(snk6502_state, videoram2)
+	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE_MEMBER(snk6502_state, videoram)
+	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE_MEMBER(snk6502_state, colorram)
+	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE_MEMBER(snk6502_state, charram)
 	AM_RANGE(0x2000, 0x2000) AM_DEVWRITE("crtc", mc6845_address_w)
 	AM_RANGE(0x2001, 0x2001) AM_DEVWRITE("crtc", mc6845_register_w)
 	AM_RANGE(0x2100, 0x2103) AM_WRITE(fantasy_sound_w)
@@ -400,10 +404,10 @@
 
 static ADDRESS_MAP_START( pballoon_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x03ff) AM_RAM
-	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE(&snk6502_videoram2)
-	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE(&snk6502_videoram)
-	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE(&snk6502_colorram)
-	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE(&snk6502_charram)
+	AM_RANGE(0x0400, 0x07ff) AM_RAM_WRITE(snk6502_videoram2_w) AM_BASE_MEMBER(snk6502_state, videoram2)
+	AM_RANGE(0x0800, 0x0bff) AM_RAM_WRITE(snk6502_videoram_w) AM_BASE_MEMBER(snk6502_state, videoram)
+	AM_RANGE(0x0c00, 0x0fff) AM_RAM_WRITE(snk6502_colorram_w) AM_BASE_MEMBER(snk6502_state, colorram)
+	AM_RANGE(0x1000, 0x1fff) AM_RAM_WRITE(snk6502_charram_w) AM_BASE_MEMBER(snk6502_state, charram)
 	AM_RANGE(0x3000, 0x9fff) AM_ROM
 	AM_RANGE(0xb000, 0xb000) AM_DEVWRITE("crtc", mc6845_address_w)
 	AM_RANGE(0xb001, 0xb001) AM_DEVWRITE("crtc", mc6845_register_w)
@@ -780,12 +784,12 @@
 
 static MACHINE_RESET( sasuke )
 {
-	//snk6502_set_music_clock(M_LN2 * (RES_K(1) + RES_K(10) * 2) * CAP_U(1));
+	//snk6502_set_music_clock(machine, M_LN2 * (RES_K(1) + RES_K(10) * 2) * CAP_U(1));
 	// adjusted
-	snk6502_set_music_clock(1 / 72.1);
+	snk6502_set_music_clock(machine, 1 / 72.1);
 
 	// adjusted
-	snk6502_set_music_freq(38000);
+	snk6502_set_music_freq(machine, 38000);
 
 	sasuke_start_counter(machine);
 }
@@ -793,7 +797,7 @@
 static MACHINE_RESET( satansat )
 {
 	// same as sasuke
-	snk6502_set_music_freq(38000);
+	snk6502_set_music_freq(machine, 38000);
 
 	sasuke_start_counter(machine);
 }
@@ -801,13 +805,13 @@
 static MACHINE_RESET( vanguard )
 {
 	// 41.6 Hz update (measured)
-	snk6502_set_music_clock(1 / 41.6);
+	snk6502_set_music_clock(machine, 1 / 41.6);
 }
 
 static MACHINE_RESET( pballoon )
 {
 	// 40.3 Hz update (measured)
-	snk6502_set_music_clock(1 / 40.3);
+	snk6502_set_music_clock(machine, 1 / 40.3);
 }
 
 
@@ -818,6 +822,9 @@
  *************************************/
 
 static MACHINE_DRIVER_START( sasuke )
+
+	MDRV_DRIVER_DATA( snk6502_state )
+
 	// basic machine hardware
 	MDRV_CPU_ADD("maincpu", M6502, MASTER_CLOCK / 16) // 700 kHz
 	MDRV_CPU_PROGRAM_MAP(sasuke_map)
@@ -893,6 +900,9 @@
 MACHINE_DRIVER_END
 
 static MACHINE_DRIVER_START( vanguard )
+
+	MDRV_DRIVER_DATA( snk6502_state )
+
 	// basic machine hardware
 	//MDRV_CPU_ADD("maincpu", M6502, MASTER_CLOCK / 8)   // 1.4 MHz
 	MDRV_CPU_ADD("maincpu", M6502, 930000)		// adjusted
@@ -976,9 +986,7 @@
 
 	MDRV_MACHINE_RESET(pballoon)
 
-	// video hardware
-	MDRV_SCREEN_MODIFY("screen")
-	MDRV_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
+	MDRV_VIDEO_START( pballoon )
 MACHINE_DRIVER_END
 
 
@@ -1311,6 +1319,33 @@
 	ROM_LOAD( "sk7_ic53.bin", 0x1000, 0x0800, CRC(a4c505cd) SHA1(47eea7e7ffa3dc8b35dc050ac1a1d77d6a5c4ece) )
 ROM_END
 
+
+ROM_START( pballoonr )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "sk7_ic12.bin",        0x3000, 0x1000, CRC(dfe2ae05) SHA1(21c98bef9d4d5fcb65ce5e9b20cde2259840459e) )
+	ROM_LOAD( "rock-ola_skpb1.ic7",  0x4000, 0x1000, CRC(dfd802e8) SHA1(2014295c678d0534585e27d9b5c7ac525113cd0c) )
+	ROM_LOAD( "rock-ola_skpb1.ic8",  0x5000, 0x1000, CRC(c433c062) SHA1(63df947c56f51a623b378d2a8a5b2cd05c23c414) )
+	ROM_LOAD( "rock-ola_skpb1.ic9",  0x6000, 0x1000, CRC(f85b9c37) SHA1(905eb162436a0a46688df9343296c140480d00cb) )
+	ROM_LOAD( "rock-ola_skpb1.ic10", 0x7000, 0x1000, CRC(8020e52d) SHA1(fbe2a27560904225b4406171c1cdbae9941887bd) )
+	ROM_LOAD( "sk7_ic14.bin",        0x8000, 0x1000, CRC(6a8817a5) SHA1(4cf8eda68d21b1fad0f12eedaeb88b256bba44da) )
+	ROM_RELOAD(                      0xf000, 0x1000 )  /* for the reset and interrupt vectors */
+	ROM_LOAD( "sk7_ic15.bin",        0x9000, 0x1000, CRC(1f78d814) SHA1(7e618971f1bbf8859284531e94989c43c3285b4a) )
+
+	ROM_REGION( 0x2000, "gfx1", 0 )
+	ROM_LOAD( "sk8_ic50.bin", 0x0000, 0x1000, CRC(560df07f) SHA1(e57945de829d22d39390a649eddaf78c989af679) )
+	ROM_LOAD( "sk8_ic51.bin", 0x1000, 0x1000, CRC(d415de51) SHA1(257cf939efec8adee87baf827315c69fde90da4c) )
+
+	ROM_REGION( 0x0040, "proms", 0 )
+	ROM_LOAD( "sk8_ic7.bin",  0x0000, 0x0020, CRC(ef6c82a0) SHA1(95b522d6389f25bf5fa2fca5f3f826ef43b2885b) ) /* foreground colors */
+	ROM_LOAD( "sk8_ic6.bin",  0x0020, 0x0020, CRC(eabc6a00) SHA1(942af5e22e49e578c6a24651476e3b60d40e2076) ) /* background colors */
+
+	ROM_REGION( 0x1800, "snk6502", 0 )	/* sound ROMs */
+	ROM_LOAD( "sk7_ic51.bin", 0x0000, 0x0800, CRC(0345f8b7) SHA1(c00992dc7222cc53d9fdff4ab47a7abdf90c5116) )
+	ROM_LOAD( "sk7_ic52.bin", 0x0800, 0x0800, CRC(5d6d68ea) SHA1(d3e03720eff5c85c1c2fb1d4bf960f45a99dc86a) )
+	ROM_LOAD( "sk7_ic53.bin", 0x1000, 0x0800, CRC(a4c505cd) SHA1(47eea7e7ffa3dc8b35dc050ac1a1d77d6a5c4ece) )
+ROM_END
+
+
 ROM_START( nibbler )
 	ROM_REGION( 0x10000, "maincpu", 0 )
 	ROM_LOAD( "g-0960-52.ic12", 0x3000, 0x1000, CRC(ac6a802b) SHA1(ac1072e30994f13097663dc24d9d1dc35a95d874) )
@@ -1437,6 +1472,7 @@
 GAME( 1981, fantasyu, fantasy,  fantasy,  fantasyu, 0, ROT90, "SNK (Rock-Ola license)", "Fantasy (US)", GAME_IMPERFECT_SOUND )
 GAME( 1981, fantasyj, fantasy,  fantasy,  fantasyu, 0, ROT90, "SNK", "Fantasy (Japan)", GAME_IMPERFECT_SOUND )
 GAME( 1982, pballoon, 0,        pballoon, pballoon, 0, ROT90, "SNK", "Pioneer Balloon", 0 )
+GAME( 1982, pballoonr,pballoon, pballoon, pballoon, 0, ROT90, "SNK (Rock-Ola license)", "Pioneer Balloon (Rock-Ola license)", 0 )
 GAME( 1982, nibbler,  0,        nibbler,  nibbler,  0, ROT90, "Rock-Ola", "Nibbler (set 1)", 0 )
 GAME( 1982, nibblera, nibbler,  nibbler,  nibblera, 0, ROT90, "Rock-Ola", "Nibbler (set 2)", 0 )
 GAME( 1982, nibblerb, nibbler,  nibbler,  nibblerb, 0, ROT90, "Rock-Ola", "Nibbler (set 3)", 0 )
diff -Nru src-old/mame/drivers/snk68.c src/mame/drivers/snk68.c
--- src-old/mame/drivers/snk68.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/drivers/snk68.c	2010-08-26 20:55:49.000000000 -0700
@@ -45,34 +45,22 @@
 #include "cpu/z80/z80.h"
 #include "sound/3812intf.h"
 #include "sound/upd7759.h"
-
-extern UINT16* pow_fg_videoram;
-
-VIDEO_START( pow );
-VIDEO_START( searchar );
-VIDEO_UPDATE( pow );
-WRITE16_HANDLER( pow_paletteram16_word_w );
-WRITE16_HANDLER( pow_flipscreen16_w );
-WRITE16_HANDLER( searchar_flipscreen16_w );
-READ16_HANDLER( pow_spriteram_r );
-WRITE16_HANDLER( pow_spriteram_w );
-READ16_HANDLER( pow_fg_videoram_r );
-WRITE16_HANDLER( pow_fg_videoram_w );
-WRITE16_HANDLER( searchar_fg_videoram_w );
-
-static int invert_controls;
-static int sound_status;
+#include "includes/snk68.h"
 
 /******************************************************************************/
 
 static READ16_HANDLER( sound_status_r )
 {
-	return (sound_status << 8);
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
+	return (state->sound_status << 8);
 }
 
 static WRITE8_HANDLER( sound_status_w )
 {
-	sound_status = data;
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
+	state->sound_status = data;
 }
 
 static READ16_HANDLER( control_1_r )
@@ -103,8 +91,10 @@
 
 static READ16_HANDLER( protcontrols_r )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
 	static const char *const portnames[] = { "P1", "P2", "SYSTEM" };
-	return input_port_read(space->machine, portnames[offset]) ^ invert_controls;
+
+	return input_port_read(space->machine, portnames[offset]) ^ state->invert_controls;
 }
 
 static WRITE16_HANDLER( protection_w )
@@ -112,7 +102,10 @@
 	/* top byte is used, meaning unknown */
 	/* bottom byte is protection in ikari 3 and streetsm */
 	if (ACCESSING_BITS_0_7)
-		invert_controls = ((data & 0xff) == 0x07) ? 0xff : 0x00;
+	{
+		snk68_state *state = space->machine->driver_data<snk68_state>();
+		state->invert_controls = ((data & 0xff) == 0x07) ? 0xff : 0x00;
+	}
 }
 
 static WRITE16_HANDLER( sound_w )
@@ -138,9 +131,9 @@
 	AM_RANGE(0x0f0000, 0x0f0001) AM_READ_PORT("DSW1")
 	AM_RANGE(0x0f0008, 0x0f0009) AM_READ_PORT("DSW2")
 //  AM_RANGE(0x0f0008, 0x0f0009) AM_WRITENOP    /* ?? */
-	AM_RANGE(0x100000, 0x100fff) AM_READWRITE(pow_fg_videoram_r, pow_fg_videoram_w) AM_MIRROR(0x1000) AM_BASE(&pow_fg_videoram)	// 8-bit
-	AM_RANGE(0x200000, 0x207fff) AM_READWRITE(pow_spriteram_r, pow_spriteram_w) AM_BASE_GENERIC(spriteram)	// only partially populated
-	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(pow_paletteram16_word_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x100000, 0x100fff) AM_READWRITE(pow_fg_videoram_r, pow_fg_videoram_w) AM_MIRROR(0x1000) AM_BASE_MEMBER(snk68_state, pow_fg_videoram)	// 8-bit
+	AM_RANGE(0x200000, 0x207fff) AM_READWRITE(pow_spriteram_r, pow_spriteram_w) AM_BASE_MEMBER(snk68_state, spriteram)	// only partially populated
+	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(pow_paletteram16_word_w) AM_BASE_MEMBER(snk68_state, paletteram)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( searchar_map, ADDRESS_SPACE_PROGRAM, 16 )
@@ -159,10 +152,10 @@
 	AM_RANGE(0x0f0000, 0x0f0001) AM_READ_PORT("DSW1")
 	AM_RANGE(0x0f0008, 0x0f0009) AM_READ_PORT("DSW2")
 	AM_RANGE(0x0f8000, 0x0f8001) AM_READ(sound_status_r)
-	AM_RANGE(0x100000, 0x107fff) AM_READWRITE(pow_spriteram_r, pow_spriteram_w) AM_BASE_GENERIC(spriteram)	// only partially populated
-	AM_RANGE(0x200000, 0x200fff) AM_RAM_WRITE(searchar_fg_videoram_w) AM_MIRROR(0x1000) AM_BASE(&pow_fg_videoram) /* Mirror is used by Ikari 3 */
+	AM_RANGE(0x100000, 0x107fff) AM_READWRITE(pow_spriteram_r, pow_spriteram_w) AM_BASE_MEMBER(snk68_state, spriteram)	// only partially populated
+	AM_RANGE(0x200000, 0x200fff) AM_RAM_WRITE(searchar_fg_videoram_w) AM_MIRROR(0x1000) AM_BASE_MEMBER(snk68_state, pow_fg_videoram) /* Mirror is used by Ikari 3 */
 	AM_RANGE(0x300000, 0x33ffff) AM_ROMBANK("bank1") /* Extra code bank */
-	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(pow_paletteram16_word_w) AM_BASE_GENERIC(paletteram)
+	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(pow_paletteram16_word_w) AM_BASE_MEMBER(snk68_state, paletteram)
 ADDRESS_MAP_END
 
 /******************************************************************************/
@@ -599,6 +592,8 @@
 
 static MACHINE_DRIVER_START( pow )
 
+	MDRV_DRIVER_DATA( snk68_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_18MHz/2) /* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(pow_map)
diff -Nru src-old/mame/drivers/sothello.c src/mame/drivers/sothello.c
--- src-old/mame/drivers/sothello.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/sothello.c	2010-08-19 00:26:14.000000000 -0700
@@ -185,7 +185,7 @@
 
 /* sub 6809 */
 
-static void unlock_shared_ram(const address_space *space)
+static void unlock_shared_ram(address_space *space)
 {
     if(!space->machine->device<cpu_device>("sub")->suspended(SUSPEND_REASON_HALT))
     {
diff -Nru src-old/mame/drivers/spacefb.c src/mame/drivers/spacefb.c
--- src-old/mame/drivers/spacefb.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/spacefb.c	2010-08-19 00:26:14.000000000 -0700
@@ -174,7 +174,7 @@
 
 static MACHINE_RESET( spacefb )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	/* the 3 output ports are cleared on reset */
 	spacefb_port_0_w(space, 0, 0);
 	spacefb_port_1_w(space, 0, 0);
diff -Nru src-old/mame/drivers/speglsht.c src/mame/drivers/speglsht.c
--- src-old/mame/drivers/speglsht.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/speglsht.c	2010-08-26 09:31:58.000000000 -0700
@@ -307,7 +307,7 @@
 	&st0016_charram
 };
 
-static const r3000_cpu_core config =
+static const r3000_cpu_core r3000_config =
 {
 	0,
 	4096,	/* code cache size */
@@ -328,7 +328,7 @@
 	MDRV_CPU_VBLANK_INT("screen", irq0_line_hold)
 
 	MDRV_CPU_ADD("sub", R3000LE, 25000000)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r3000_config)
 	MDRV_CPU_PROGRAM_MAP(speglsht_mem)
 	MDRV_CPU_VBLANK_INT("screen", irq4_line_assert)
 
diff -Nru src-old/mame/drivers/spiders.c src/mame/drivers/spiders.c
--- src-old/mame/drivers/spiders.c	2010-07-16 04:59:31.000000000 -0700
+++ src/mame/drivers/spiders.c	2010-08-23 03:03:39.000000000 -0700
@@ -387,7 +387,7 @@
 }
 
 
-static const ttl74123_config ic60_intf =
+static const ttl74123_interface ic60_intf =
 {
 	TTL74123_GROUNDED,	/* the hook up type */
 	RES_K(22),			/* resistor connected to RCext */
diff -Nru src-old/mame/drivers/srmp5.c src/mame/drivers/srmp5.c
--- src-old/mame/drivers/srmp5.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/srmp5.c	2010-08-26 09:31:58.000000000 -0700
@@ -521,7 +521,7 @@
 	&st0016_charram
 };
 
-static const r3000_cpu_core config =
+static const r3000_cpu_core r3000_config =
 {
 	1,	/* 1 if we have an FPU, 0 otherwise */
 	4096,	/* code cache size */
@@ -568,7 +568,7 @@
 	MDRV_CPU_VBLANK_INT("screen", irq0_line_hold)
 
 	MDRV_CPU_ADD("sub", R3000LE, 25000000)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r3000_config)
 	MDRV_CPU_PROGRAM_MAP(srmp5_mem)
 	MDRV_CPU_VBLANK_INT("screen", irq4_line_assert)
 
diff -Nru src-old/mame/drivers/srumbler.c src/mame/drivers/srumbler.c
--- src-old/mame/drivers/srumbler.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/srumbler.c	2010-08-19 00:26:14.000000000 -0700
@@ -57,7 +57,7 @@
 
 static MACHINE_RESET( srumbler )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	/* initialize banked ROM pointers */
 	srumbler_bankswitch_w(space,0,0);
 }
diff -Nru src-old/mame/drivers/sshangha.c src/mame/drivers/sshangha.c
--- src-old/mame/drivers/sshangha.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/sshangha.c	2010-08-19 00:26:14.000000000 -0700
@@ -128,7 +128,7 @@
 
 static MACHINE_RESET( sshangha )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	/* Such thing is needed as there is no code to turn the screen
        to normal orientation when the game is reset.
        I'm using the value that forces the screen to be in normal
diff -Nru src-old/mame/drivers/starwars.c src/mame/drivers/starwars.c
--- src-old/mame/drivers/starwars.c	2010-06-03 08:23:47.000000000 -0700
+++ src/mame/drivers/starwars.c	2010-08-19 00:26:14.000000000 -0700
@@ -57,7 +57,7 @@
 	/* ESB-specific */
 	if (starwars_is_esb)
 	{
-		const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 		/* reset the slapstic */
 		slapstic_reset();
@@ -93,7 +93,7 @@
  *
  *************************************/
 
-static void esb_slapstic_tweak(const address_space *space, offs_t offset)
+static void esb_slapstic_tweak(address_space *space, offs_t offset)
 {
 	int new_bank = slapstic_tweak(space, offset);
 
@@ -127,12 +127,12 @@
  *
  *************************************/
 
-static DIRECT_UPDATE_HANDLER( esb_setdirect )
+DIRECT_UPDATE_HANDLER( esb_setdirect )
 {
 	/* if we are in the slapstic region, process it */
 	if ((address & 0xe000) == 0x8000)
 	{
-		offs_t pc = cpu_get_pc(space->cpu);
+		offs_t pc = cpu_get_pc(&direct.space().device());
 
 		/* filter out duplicates; we get these because the handler gets called for
            multiple reasons:
@@ -143,7 +143,7 @@
 		{
 			slapstic_last_pc = pc;
 			slapstic_last_address = address;
-			esb_slapstic_tweak(space, address & 0x1fff);
+			esb_slapstic_tweak(&direct.space(), address & 0x1fff);
 		}
 		return ~0;
 	}
@@ -159,7 +159,7 @@
  *************************************/
 
 static ADDRESS_MAP_START( main_map, ADDRESS_SPACE_PROGRAM, 8 )
-	AM_RANGE(0x0000, 0x2fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0)
+	AM_RANGE(0x0000, 0x2fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0)
 	AM_RANGE(0x3000, 0x3fff) AM_ROM								/* vector_rom */
 	AM_RANGE(0x4300, 0x431f) AM_READ_PORT("IN0")
 	AM_RANGE(0x4320, 0x433f) AM_READ_PORT("IN1")
@@ -527,7 +527,8 @@
 	slapstic_base = &rom[0x08000];
 
 	/* install an opcode base handler */
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), esb_setdirect);
+	address_space *space = machine->device<m6809_device>("maincpu")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(esb_setdirect, *machine));
 
 	/* install read/write handlers for it */
 	memory_install_readwrite8_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x8000, 0x9fff, 0, 0, esb_slapstic_r, esb_slapstic_w);
diff -Nru src-old/mame/drivers/statriv2.c src/mame/drivers/statriv2.c
--- src-old/mame/drivers/statriv2.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/statriv2.c	2010-08-19 00:26:14.000000000 -0700
@@ -1102,7 +1102,7 @@
 
 static DRIVER_INIT( laserdisc )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	memory_install_readwrite8_handler(iospace, 0x28, 0x2b, 0, 0, laserdisc_io_r, laserdisc_io_w);
 }
 
diff -Nru src-old/mame/drivers/stv.c src/mame/drivers/stv.c
--- src-old/mame/drivers/stv.c	2010-07-07 14:01:36.000000000 -0700
+++ src/mame/drivers/stv.c	2010-08-19 01:27:05.000000000 -0700
@@ -239,12 +239,12 @@
 	UINT8 abus;
 }stv_irq;
 
-static void dma_direct_lv0(const address_space *space);	/*DMA level 0 direct transfer function*/
-static void dma_direct_lv1(const address_space *space);   /*DMA level 1 direct transfer function*/
-static void dma_direct_lv2(const address_space *space);   /*DMA level 2 direct transfer function*/
-static void dma_indirect_lv0(const address_space *space); /*DMA level 0 indirect transfer function*/
-static void dma_indirect_lv1(const address_space *space); /*DMA level 1 indirect transfer function*/
-static void dma_indirect_lv2(const address_space *space); /*DMA level 2 indirect transfer function*/
+static void dma_direct_lv0(address_space *space);	/*DMA level 0 direct transfer function*/
+static void dma_direct_lv1(address_space *space);   /*DMA level 1 direct transfer function*/
+static void dma_direct_lv2(address_space *space);   /*DMA level 2 direct transfer function*/
+static void dma_indirect_lv0(address_space *space); /*DMA level 0 indirect transfer function*/
+static void dma_indirect_lv1(address_space *space); /*DMA level 1 indirect transfer function*/
+static void dma_indirect_lv2(address_space *space); /*DMA level 2 indirect transfer function*/
 
 
 int minit_boost,sinit_boost;
@@ -463,7 +463,7 @@
 	/*Order is surely wrong but whatever...*/
 }
 
-static UINT8 stv_SMPC_r8 (const address_space *space, int offset)
+static UINT8 stv_SMPC_r8 (address_space *space, int offset)
 {
 	int return_data;
 
@@ -490,7 +490,7 @@
 	return return_data;
 }
 
-static void stv_SMPC_w8 (const address_space *space, int offset, UINT8 data)
+static void stv_SMPC_w8 (address_space *space, int offset, UINT8 data)
 {
 	system_time systime;
 
@@ -1432,7 +1432,7 @@
 	D2MV_0;
 }
 
-static void dma_direct_lv0(const address_space *space)
+static void dma_direct_lv0(address_space *space)
 {
 	static UINT32 tmp_src,tmp_dst,tmp_size;
 	if(LOG_SCU) logerror("DMA lv 0 transfer START\n"
@@ -1506,18 +1506,18 @@
 	for (; scu_size_0 > 0; scu_size_0-=scu_dst_add_0)
 	{
 		if(scu_dst_add_0 == 2)
-			memory_write_word(space,scu_dst_0,memory_read_word(space,scu_src_0));
+			space->write_word(scu_dst_0,space->read_word(scu_src_0));
 		else if(scu_dst_add_0 == 8)
 		{
-			memory_write_word(space,scu_dst_0,memory_read_word(space,scu_src_0));
-			memory_write_word(space,scu_dst_0+2,memory_read_word(space,scu_src_0));
-			memory_write_word(space,scu_dst_0+4,memory_read_word(space,scu_src_0+2));
-			memory_write_word(space,scu_dst_0+6,memory_read_word(space,scu_src_0+2));
+			space->write_word(scu_dst_0,space->read_word(scu_src_0));
+			space->write_word(scu_dst_0+2,space->read_word(scu_src_0));
+			space->write_word(scu_dst_0+4,space->read_word(scu_src_0+2));
+			space->write_word(scu_dst_0+6,space->read_word(scu_src_0+2));
 		}
 		else
 		{
-			memory_write_word(space,scu_dst_0,memory_read_word(space,scu_src_0));
-			memory_write_word(space,scu_dst_0+2,memory_read_word(space,scu_src_0+2));
+			space->write_word(scu_dst_0,space->read_word(scu_src_0));
+			space->write_word(scu_dst_0+2,space->read_word(scu_src_0+2));
 		}
 
 		scu_dst_0+=scu_dst_add_0;
@@ -1541,7 +1541,7 @@
 	}
 }
 
-static void dma_direct_lv1(const address_space *space)
+static void dma_direct_lv1(address_space *space)
 {
 	static UINT32 tmp_src,tmp_dst,tmp_size;
 	if(LOG_SCU) logerror("DMA lv 1 transfer START\n"
@@ -1615,11 +1615,11 @@
 	for (; scu_size_1 > 0; scu_size_1-=scu_dst_add_1)
 	{
 		if(scu_dst_add_1 == 2)
-			memory_write_word(space,scu_dst_1,memory_read_word(space,scu_src_1));
+			space->write_word(scu_dst_1,space->read_word(scu_src_1));
 		else
 		{
-			memory_write_word(space,scu_dst_1,memory_read_word(space,scu_src_1));
-			memory_write_word(space,scu_dst_1+2,memory_read_word(space,scu_src_1+2));
+			space->write_word(scu_dst_1,space->read_word(scu_src_1));
+			space->write_word(scu_dst_1+2,space->read_word(scu_src_1+2));
 		}
 
 		scu_dst_1+=scu_dst_add_1;
@@ -1642,7 +1642,7 @@
 	}
 }
 
-static void dma_direct_lv2(const address_space *space)
+static void dma_direct_lv2(address_space *space)
 {
 	static UINT32 tmp_src,tmp_dst,tmp_size;
 	if(LOG_SCU) logerror("DMA lv 2 transfer START\n"
@@ -1716,11 +1716,11 @@
 	for (; scu_size_2 > 0; scu_size_2-=scu_dst_add_2)
 	{
 		if(scu_dst_add_2 == 2)
-			memory_write_word(space,scu_dst_2,memory_read_word(space,scu_src_2));
+			space->write_word(scu_dst_2,space->read_word(scu_src_2));
 		else
 		{
-			memory_write_word(space,scu_dst_2,memory_read_word(space,scu_src_2));
-			memory_write_word(space,scu_dst_2+2,memory_read_word(space,scu_src_2+2));
+			space->write_word(scu_dst_2,space->read_word(scu_src_2));
+			space->write_word(scu_dst_2+2,space->read_word(scu_src_2+2));
 		}
 
 		scu_dst_2+=scu_dst_add_2;
@@ -1743,7 +1743,7 @@
 	}
 }
 
-static void dma_indirect_lv0(const address_space *space)
+static void dma_indirect_lv0(address_space *space)
 {
 	/*Helper to get out of the cycle*/
 	UINT8 job_done = 0;
@@ -1760,9 +1760,9 @@
 		tmp_src = scu_index_0;
 
 		/*Thanks for Runik of Saturnin for pointing this out...*/
-		scu_size_0 = memory_read_dword(space,scu_index_0);
-		scu_src_0 =  memory_read_dword(space,scu_index_0+8);
-		scu_dst_0 =  memory_read_dword(space,scu_index_0+4);
+		scu_size_0 = space->read_dword(scu_index_0);
+		scu_src_0 =  space->read_dword(scu_index_0+8);
+		scu_dst_0 =  space->read_dword(scu_index_0+4);
 
 		/*Indirect Mode end factor*/
 		if(scu_src_0 & 0x80000000)
@@ -1786,7 +1786,7 @@
 		for (; scu_size_0 > 0; scu_size_0-=scu_dst_add_0)
 		{
 			if(scu_dst_add_0 == 2)
-				memory_write_word(space,scu_dst_0,memory_read_word(space,scu_src_0));
+				space->write_word(scu_dst_0,space->read_word(scu_src_0));
 			else
 			{
 				/* some games, eg columns97 are a bit weird, I'm not sure this is correct
@@ -1794,15 +1794,15 @@
                   can't access 2 byte boundaries, and the end of the sprite list never gets marked,
                   the length of the transfer is also set to a 2 byte boundary, maybe the add values
                   should be different, I don't know */
-				memory_write_word(space,scu_dst_0,memory_read_word(space,scu_src_0));
-				memory_write_word(space,scu_dst_0+2,memory_read_word(space,scu_src_0+2));
+				space->write_word(scu_dst_0,space->read_word(scu_src_0));
+				space->write_word(scu_dst_0+2,space->read_word(scu_src_0+2));
 			}
 			scu_dst_0+=scu_dst_add_0;
 			scu_src_0+=scu_src_add_0;
 		}
 
-		//if(DRUP(0))   memory_write_dword(space,tmp_src+8,scu_src_0|job_done ? 0x80000000 : 0);
-		//if(DWUP(0)) memory_write_dword(space,tmp_src+4,scu_dst_0);
+		//if(DRUP(0))   space->write_dword(tmp_src+8,scu_src_0|job_done ? 0x80000000 : 0);
+		//if(DWUP(0)) space->write_dword(tmp_src+4,scu_dst_0);
 
 		scu_index_0 = tmp_src+0xc;
 
@@ -1811,7 +1811,7 @@
 	timer_set(space->machine, ATTOTIME_IN_USEC(300), NULL, 0, dma_lv0_ended);
 }
 
-static void dma_indirect_lv1(const address_space *space)
+static void dma_indirect_lv1(address_space *space)
 {
 	/*Helper to get out of the cycle*/
 	UINT8 job_done = 0;
@@ -1827,9 +1827,9 @@
 	do{
 		tmp_src = scu_index_1;
 
-		scu_size_1 = memory_read_dword(space,scu_index_1);
-		scu_src_1 =  memory_read_dword(space,scu_index_1+8);
-		scu_dst_1 =  memory_read_dword(space,scu_index_1+4);
+		scu_size_1 = space->read_dword(scu_index_1);
+		scu_src_1 =  space->read_dword(scu_index_1+8);
+		scu_dst_1 =  space->read_dword(scu_index_1+4);
 
 		/*Indirect Mode end factor*/
 		if(scu_src_1 & 0x80000000)
@@ -1855,7 +1855,7 @@
 		{
 
 			if(scu_dst_add_1 == 2)
-				memory_write_word(space,scu_dst_1,memory_read_word(space,scu_src_1));
+				space->write_word(scu_dst_1,space->read_word(scu_src_1));
 			else
 			{
 				/* some games, eg columns97 are a bit weird, I'm not sure this is correct
@@ -1863,15 +1863,15 @@
                   can't access 2 byte boundaries, and the end of the sprite list never gets marked,
                   the length of the transfer is also set to a 2 byte boundary, maybe the add values
                   should be different, I don't know */
-				memory_write_word(space,scu_dst_1,memory_read_word(space,scu_src_1));
-				memory_write_word(space,scu_dst_1+2,memory_read_word(space,scu_src_1+2));
+				space->write_word(scu_dst_1,space->read_word(scu_src_1));
+				space->write_word(scu_dst_1+2,space->read_word(scu_src_1+2));
 			}
 			scu_dst_1+=scu_dst_add_1;
 			scu_src_1+=scu_src_add_1;
 		}
 
-		//if(DRUP(1))   memory_write_dword(space,tmp_src+8,scu_src_1|job_done ? 0x80000000 : 0);
-		//if(DWUP(1)) memory_write_dword(space,tmp_src+4,scu_dst_1);
+		//if(DRUP(1))   space->write_dword(tmp_src+8,scu_src_1|job_done ? 0x80000000 : 0);
+		//if(DWUP(1)) space->write_dword(tmp_src+4,scu_dst_1);
 
 		scu_index_1 = tmp_src+0xc;
 
@@ -1880,7 +1880,7 @@
 	timer_set(space->machine, ATTOTIME_IN_USEC(300), NULL, 0, dma_lv1_ended);
 }
 
-static void dma_indirect_lv2(const address_space *space)
+static void dma_indirect_lv2(address_space *space)
 {
 	/*Helper to get out of the cycle*/
 	UINT8 job_done = 0;
@@ -1896,9 +1896,9 @@
 	do{
 		tmp_src = scu_index_2;
 
-		scu_size_2 = memory_read_dword(space,scu_index_2);
-		scu_src_2 =  memory_read_dword(space,scu_index_2+8);
-		scu_dst_2 =  memory_read_dword(space,scu_index_2+4);
+		scu_size_2 = space->read_dword(scu_index_2);
+		scu_src_2 =  space->read_dword(scu_index_2+8);
+		scu_dst_2 =  space->read_dword(scu_index_2+4);
 
 		/*Indirect Mode end factor*/
 		if(scu_src_2 & 0x80000000)
@@ -1922,7 +1922,7 @@
 		for (; scu_size_2 > 0; scu_size_2-=scu_dst_add_2)
 		{
 			if(scu_dst_add_2 == 2)
-				memory_write_word(space,scu_dst_2,memory_read_word(space,scu_src_2));
+				space->write_word(scu_dst_2,space->read_word(scu_src_2));
 			else
 			{
 				/* some games, eg columns97 are a bit weird, I'm not sure this is correct
@@ -1930,16 +1930,16 @@
                   can't access 2 byte boundaries, and the end of the sprite list never gets marked,
                   the length of the transfer is also set to a 2 byte boundary, maybe the add values
                   should be different, I don't know */
-				memory_write_word(space,scu_dst_2,memory_read_word(space,scu_src_2));
-				memory_write_word(space,scu_dst_2+2,memory_read_word(space,scu_src_2+2));
+				space->write_word(scu_dst_2,space->read_word(scu_src_2));
+				space->write_word(scu_dst_2+2,space->read_word(scu_src_2+2));
 			}
 
 			scu_dst_2+=scu_dst_add_2;
 			scu_src_2+=scu_src_add_2;
 		}
 
-		//if(DRUP(2))   memory_write_dword(space,tmp_src+8,scu_src_2|job_done ? 0x80000000 : 0);
-		//if(DWUP(2)) memory_write_dword(space,tmp_src+4,scu_dst_2);
+		//if(DRUP(2))   space->write_dword(tmp_src+8,scu_src_2|job_done ? 0x80000000 : 0);
+		//if(DWUP(2)) space->write_dword(tmp_src+4,scu_dst_2);
 
 		scu_index_2 = tmp_src+0xc;
 
diff -Nru src-old/mame/drivers/suna16.c src/mame/drivers/suna16.c
--- src-old/mame/drivers/suna16.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/drivers/suna16.c	2010-08-19 00:26:14.000000000 -0700
@@ -358,7 +358,7 @@
 
 static MACHINE_RESET(uballoon)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	uballoon_pcm_1_bankswitch_w(space, 0, 0);
 }
 
diff -Nru src-old/mame/drivers/suna8.c src/mame/drivers/suna8.c
--- src-old/mame/drivers/suna8.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/suna8.c	2010-08-19 07:19:38.000000000 -0700
@@ -82,8 +82,8 @@
 /* Non encrypted bootleg */
 static DRIVER_INIT( hardhedb )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x48000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x48000);
 	memory_configure_bank(machine, "bank1", 0, 16, memory_region(machine, "maincpu") + 0x10000, 0x4000);
 }
 
@@ -95,13 +95,13 @@
 
 static UINT8 *brickzn_decrypt(running_machine *machine)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8	*RAM	=	memory_region(machine, "maincpu");
 	size_t	size	=	memory_region_length(machine, "maincpu");
 	UINT8   *decrypt = auto_alloc_array(machine, UINT8, size);
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	/* Opcodes and data */
 	for (i = 0; i < 0x50000; i++)
@@ -205,14 +205,14 @@
 
 static DRIVER_INIT( hardhea2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8	*RAM	=	memory_region(machine, "maincpu");
 	size_t	size	=	memory_region_length(machine, "maincpu");
 	UINT8   *decrypt =	auto_alloc_array(machine, UINT8, size);
 	UINT8 x;
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	/* Address lines scrambling */
 	memcpy(decrypt, RAM, size);
@@ -292,14 +292,14 @@
 
 static DRIVER_INIT( starfigh )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8	*RAM	=	memory_region(machine, "maincpu");
 	size_t	size	=	memory_region_length(machine, "maincpu");
 	UINT8   *decrypt =	auto_alloc_array(machine, UINT8, size);
 	UINT8 x;
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	/* Address lines scrambling */
 	memcpy(decrypt, RAM, size);
@@ -360,14 +360,14 @@
 
 static DRIVER_INIT( sparkman )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8	*RAM	=	memory_region(machine, "maincpu");
 	size_t	size	=	memory_region_length(machine, "maincpu");
 	UINT8   *decrypt =	auto_alloc_array(machine, UINT8, size);
 	UINT8 x;
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	/* Address lines scrambling */
 	memcpy(decrypt, RAM, size);
@@ -573,7 +573,7 @@
 {
 	/* check code at 0x2ce2 (in sranger), protection is so dire that I can't even exactly
        estabilish if what I'm doing can be considered or not a kludge... -AS */
-	memory_write_byte(space,0xcd99,0xff);
+	space->write_byte(0xcd99,0xff);
 }
 
 static ADDRESS_MAP_START( rranger_map, ADDRESS_SPACE_PROGRAM, 8 )
@@ -1665,7 +1665,7 @@
 
 static MACHINE_RESET( hardhea2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	hardhea2_rambank_0_w(space,0,0);
 }
 
diff -Nru src-old/mame/drivers/supertnk.c src/mame/drivers/supertnk.c
--- src-old/mame/drivers/supertnk.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/supertnk.c	2010-08-19 00:26:14.000000000 -0700
@@ -286,7 +286,7 @@
 
 static MACHINE_RESET( supertnk )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	supertnk_bankswitch_0_w(space, 0, 0);
 	supertnk_bankswitch_1_w(space, 0, 0);
 
diff -Nru src-old/mame/drivers/suprnova.c src/mame/drivers/suprnova.c
--- src-old/mame/drivers/suprnova.c	2010-07-08 07:10:23.000000000 -0700
+++ src/mame/drivers/suprnova.c	2010-08-19 01:27:05.000000000 -0700
@@ -876,7 +876,7 @@
 static READ32_HANDLER( bios_skip_r )
 {
 #if BIOS_SKIP
-	if ((cpu_get_pc(space->cpu)==0x6f8) || (cpu_get_pc(space->cpu)==0x6fa)) memory_write_byte(space, 0x06000029,1);
+	if ((cpu_get_pc(space->cpu)==0x6f8) || (cpu_get_pc(space->cpu)==0x6fa)) space->write_byte(0x06000029,1);
 #endif
 	return skns_main_ram[0x00028/4];
 }
diff -Nru src-old/mame/drivers/system1.c src/mame/drivers/system1.c
--- src-old/mame/drivers/system1.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/system1.c	2010-08-19 07:19:38.000000000 -0700
@@ -555,11 +555,11 @@
 	switch ((mcu_control >> 3) & 3)
 	{
 		case 0:
-			memory_write_byte(cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM), offset, data);
+			space->machine->device<z80_device>("maincpu")->space(AS_PROGRAM)->write_byte(offset, data);
 			break;
 
 		case 2:
-			memory_write_byte(cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_IO), offset, data);
+			space->machine->device<z80_device>("maincpu")->space(AS_IO)->write_byte(offset, data);
 			break;
 
 		default:
@@ -575,13 +575,13 @@
 	switch ((mcu_control >> 3) & 3)
 	{
 		case 0:
-			return memory_read_byte(cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM), offset);
+			return space->machine->device<z80_device>("maincpu")->space(AS_PROGRAM)->read_byte(offset);
 
 		case 1:
 			return memory_region(space->machine, "maincpu")[offset + 0x10000];
 
 		case 2:
-			return memory_read_byte(cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_IO), offset);
+			return space->machine->device<z80_device>("maincpu")->space(AS_IO)->read_byte(offset);
 
 		default:
 			logerror("%03X: MCU movx read mode %02X offset %04X\n",
@@ -4600,8 +4600,8 @@
 
 static DRIVER_INIT( nob )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 
 	DRIVER_INIT_CALL(bank44);
 
@@ -4632,7 +4632,7 @@
 //  ROM[0x10000 + 0 * 0x8000 + 0x3347] = 0x18;  // 'jr' instead of 'jr z'
 
 	/* Patch to get sound in later levels(the program enters into a tight loop)*/
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	UINT8 *ROM2 = memory_region(machine, "soundcpu");
 
 	ROM2[0x02f9] = 0x28;//'jr z' instead of 'jr'
@@ -4648,16 +4648,16 @@
 
 static DRIVER_INIT( bootleg )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x10000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x10000);
 	DRIVER_INIT_CALL(bank00);
 }
 
 
 static DRIVER_INIT( bootsys2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x20000);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	space->set_decrypted_region(0x0000, 0x7fff, memory_region(machine, "maincpu") + 0x20000);
 	memory_configure_bank_decrypted(machine, "bank1", 0, 4, memory_region(machine, "maincpu") + 0x30000, 0x4000);
 	DRIVER_INIT_CALL(bank0c);
 }
@@ -4676,7 +4676,7 @@
 
 static DRIVER_INIT( shtngmst )
 {
-	const address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
+	address_space *iospace = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_IO);
 	memory_install_read_port(iospace, 0x12, 0x12, 0x00, 0x00, "TRIGGER");
 	memory_install_read_port(iospace, 0x18, 0x18, 0x00, 0x03, "18");
 	memory_install_read_port(iospace, 0x1c, 0x1c, 0x00, 0x02, "GUNX");
diff -Nru src-old/mame/drivers/system16.c src/mame/drivers/system16.c
--- src-old/mame/drivers/system16.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/system16.c	2010-08-19 07:19:38.000000000 -0700
@@ -3356,7 +3356,7 @@
 	int i;
 	UINT8 *ROM = memory_region(machine, "maincpu");
 	UINT8 *KEY = memory_region(machine, "decryption");
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 data[0x1000];
 
 	// the decryption key is in a rom (part of an MSDOS executable...)
@@ -3375,7 +3375,7 @@
 		state->decrypted_region[i] = ROM[i] ^ data[(i & 0xfff) ^ 1];
 	}
 
-	memory_set_decrypted_region(space, 0x00000, 0xbffff, state->decrypted_region);
+	space->set_decrypted_region(0x00000, 0xbffff, state->decrypted_region);
 
 	DRIVER_INIT_CALL(common);
 
diff -Nru src-old/mame/drivers/taito_l.c src/mame/drivers/taito_l.c
--- src-old/mame/drivers/taito_l.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/taito_l.c	2010-08-26 08:21:19.000000000 -0700
@@ -456,7 +456,7 @@
 	return state->cur_rambank[offset];
 }
 
-static void bank_w(const address_space *space, offs_t offset, UINT8 data, int banknum )
+static void bank_w(address_space *space, offs_t offset, UINT8 data, int banknum )
 {
 	taitol_state *state = space->machine->driver_data<taitol_state>();
 
@@ -2323,6 +2323,7 @@
 	MDRV_TC0140SYT_ADD("tc0140syt", taitol_tc0140syt_intf)
 MACHINE_DRIVER_END
 
+#ifdef UNUSED_CODE
 static MACHINE_DRIVER_START( lagirl )
 
 	/* basic machine hardware */
@@ -2336,6 +2337,7 @@
 
 	MDRV_MACHINE_RESET(cachat)
 MACHINE_DRIVER_END
+#endif
 
 
 ROM_START( raimais )
diff -Nru src-old/mame/drivers/taito_x.c src/mame/drivers/taito_x.c
--- src-old/mame/drivers/taito_x.c	2010-06-13 19:43:25.000000000 -0700
+++ src/mame/drivers/taito_x.c	2010-08-13 01:28:37.000000000 -0700
@@ -395,16 +395,18 @@
 
 /**************************************************************************/
 
-static INT32 banknum;
-
 static void reset_sound_region(running_machine *machine)
 {
-	memory_set_bankptr(machine,  "bank2", memory_region(machine, "audiocpu") + (banknum * 0x4000) + 0x10000 );
+	seta_state *state = machine->driver_data<seta_state>();
+
+	memory_set_bankptr(machine,  "bank2", memory_region(machine, "audiocpu") + (state->taitox_banknum * 0x4000) + 0x10000 );
 }
 
 static WRITE8_HANDLER( sound_bankswitch_w )
 {
-	banknum = (data - 1) & 3;
+	seta_state *state = space->machine->driver_data<seta_state>();
+
+	state->taitox_banknum = (data - 1) & 3;
 	reset_sound_region(space->machine);
 }
 
@@ -423,8 +425,8 @@
 	AM_RANGE(0x900802, 0x900803) AM_READWRITE(cchip1_ctrl_r, cchip1_ctrl_w)
 	AM_RANGE(0x900c00, 0x900c01) AM_WRITE(cchip1_bank_w)
 	AM_RANGE(0xb00000, 0xb00fff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_GENERIC(spriteram	)	// Sprites Y
-	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_GENERIC(spriteram2	)	// Sprites Code + X + Attr
+	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram)	// Sprites Y
+	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram2)	// Sprites Code + X + Attr
 	AM_RANGE(0xf00000, 0xf03fff) AM_RAM			/* Main RAM */
 ADDRESS_MAP_END
 
@@ -437,8 +439,8 @@
 	AM_RANGE(0x800002, 0x800003) AM_DEVREADWRITE8("tc0140syt", tc0140syt_comm_r, tc0140syt_comm_w, 0x00ff)
 	AM_RANGE(0x900000, 0x90000f) AM_READWRITE(daisenpu_input_r, daisenpu_input_w)
 	AM_RANGE(0xb00000, 0xb00fff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_GENERIC(spriteram	)	// Sprites Y
-	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_GENERIC(spriteram2	)	// Sprites Code + X + Attr
+	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram)	// Sprites Y
+	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram2)	// Sprites Code + X + Attr
 	AM_RANGE(0xf00000, 0xf03fff) AM_RAM			/* Main RAM */
 ADDRESS_MAP_END
 
@@ -451,8 +453,8 @@
 	AM_RANGE(0x800002, 0x800003) AM_DEVREADWRITE8("tc0140syt", tc0140syt_comm_r, tc0140syt_comm_w, 0x00ff)
 	AM_RANGE(0x900000, 0x90000f) AM_READWRITE(daisenpu_input_r, daisenpu_input_w)
 	AM_RANGE(0xb00000, 0xb00fff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_GENERIC(spriteram)	// Sprites Y
-	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_GENERIC(spriteram2	)	// Sprites Code + X + Attr
+	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram)	// Sprites Y
+	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram2)	// Sprites Code + X + Attr
 	AM_RANGE(0xf00000, 0xf03fff) AM_RAM			/* Main RAM */
 ADDRESS_MAP_END
 
@@ -465,8 +467,8 @@
 	AM_RANGE(0x800002, 0x800003) AM_DEVREADWRITE8("tc0140syt", tc0140syt_comm_r, tc0140syt_comm_w, 0x00ff)
 	AM_RANGE(0x900000, 0x90000f) AM_READWRITE(daisenpu_input_r, daisenpu_input_w)
 	AM_RANGE(0xb00000, 0xb00fff) AM_RAM_WRITE(paletteram16_xRRRRRGGGGGBBBBB_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_GENERIC(spriteram	)	// Sprites Y
-	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_GENERIC(spriteram2	)	// Sprites Code + X + Attr
+	AM_RANGE(0xd00000, 0xd007ff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram)	// Sprites Y
+	AM_RANGE(0xe00000, 0xe03fff) AM_RAM AM_BASE_MEMBER(seta_state, spriteram2)	// Sprites Code + X + Attr
 	AM_RANGE(0xf00000, 0xf03fff) AM_RAM			/* Main RAM */
 ADDRESS_MAP_END
 
@@ -892,8 +894,10 @@
 
 static MACHINE_START( taitox )
 {
-	banknum = -1;
-	state_save_register_global(machine, banknum);
+	seta_state *state = machine->driver_data<seta_state>();
+
+	state->taitox_banknum = -1;
+	state_save_register_global(machine, state->taitox_banknum);
 	state_save_register_postload(machine, taitox_postload, NULL);
 }
 
@@ -907,6 +911,8 @@
 
 static MACHINE_DRIVER_START( superman )
 
+	MDRV_DRIVER_DATA( seta_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_16MHz/2)	/* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(superman_map)
@@ -949,6 +955,8 @@
 
 static MACHINE_DRIVER_START( daisenpu )
 
+	MDRV_DRIVER_DATA( seta_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_16MHz/2)	/* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(daisenpu_map)
@@ -988,6 +996,8 @@
 
 static MACHINE_DRIVER_START( gigandes )
 
+	MDRV_DRIVER_DATA( seta_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, 8000000)	/* 8 MHz? */
 	MDRV_CPU_PROGRAM_MAP(gigandes_map)
@@ -1029,6 +1039,8 @@
 
 static MACHINE_DRIVER_START( ballbros )
 
+	MDRV_DRIVER_DATA( seta_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, 8000000)	/* 8 MHz? */
 	MDRV_CPU_PROGRAM_MAP(ballbros_map)
diff -Nru src-old/mame/drivers/taitogn.c src/mame/drivers/taitogn.c
--- src-old/mame/drivers/taitogn.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/taitogn.c	2010-08-19 00:26:14.000000000 -0700
@@ -513,7 +513,7 @@
 
 static void install_handlers(running_machine *machine, int mode)
 {
-	const address_space *a = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *a = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	if(mode == 0) {
 		// Mode 0 has access to the subbios, the mn102 flash and the rf5c296 mem zone
 		memory_install_readwrite32_handler(a, 0x1f000000, 0x1f1fffff, 0, 0, flash_subbios_r, flash_subbios_w);
diff -Nru src-old/mame/drivers/taitojc.c src/mame/drivers/taitojc.c
--- src-old/mame/drivers/taitojc.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/taitojc.c	2010-08-19 00:26:14.000000000 -0700
@@ -479,7 +479,7 @@
 
 
 
-static UINT8 mcu_comm_reg_r(const address_space *space, int reg)
+static UINT8 mcu_comm_reg_r(address_space *space, int reg)
 {
 	taitojc_state *state = space->machine->driver_data<taitojc_state>();
 	UINT8 r = 0;
@@ -506,7 +506,7 @@
 	return r;
 }
 
-static void mcu_comm_reg_w(const address_space *space, int reg, UINT8 data)
+static void mcu_comm_reg_w(address_space *space, int reg, UINT8 data)
 {
 	taitojc_state *state = space->machine->driver_data<taitojc_state>();
 
diff -Nru src-old/mame/drivers/taitowlf.c src/mame/drivers/taitowlf.c
--- src-old/mame/drivers/taitowlf.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/taitowlf.c	2010-08-19 01:27:05.000000000 -0700
@@ -380,7 +380,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -389,7 +389,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 
diff -Nru src-old/mame/drivers/tcl.c src/mame/drivers/tcl.c
--- src-old/mame/drivers/tcl.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/tcl.c	2010-08-19 07:19:38.000000000 -0700
@@ -180,7 +180,7 @@
 {
 	/* only the first part is decrypted (and verified)*/
 
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *dest = memory_region(machine, "maincpu");
 	int len = memory_region_length(machine, "maincpu");
 	UINT8 *src = auto_alloc_array(machine, UINT8, len);
@@ -206,7 +206,7 @@
 	}
 	auto_free(machine, src);
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, dest+0x10000);
+	space->set_decrypted_region(0x0000, 0x7fff, dest+0x10000);
 }
 
 GAME( 1995, tcl,  0,       tcl,  tcl,  tcl, ROT0, "Uniwang", "Taiwan Chess Legend", GAME_NOT_WORKING )
diff -Nru src-old/mame/drivers/tecmo.c src/mame/drivers/tecmo.c
--- src-old/mame/drivers/tecmo.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/tecmo.c	2010-08-26 08:21:19.000000000 -0700
@@ -736,6 +736,7 @@
 	MDRV_CPU_PROGRAM_MAP(silkworm_map)
 MACHINE_DRIVER_END
 
+#ifdef UNUSED_CODE
 static MACHINE_DRIVER_START( backfirt )
 
 	/* basic machine hardware */
@@ -772,6 +773,7 @@
 	/* no MSM on this PCB */
 
 MACHINE_DRIVER_END
+#endif
 
 /***************************************************************************
 
diff -Nru src-old/mame/drivers/tempest.c src/mame/drivers/tempest.c
--- src-old/mame/drivers/tempest.c	2010-06-30 17:34:46.000000000 -0700
+++ src/mame/drivers/tempest.c	2010-08-13 01:54:21.000000000 -0700
@@ -386,11 +386,11 @@
 
 static ADDRESS_MAP_START( main_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x07ff) AM_RAM
-	AM_RANGE(0x0800, 0x080f) AM_WRITEONLY AM_BASE(&tempest_colorram)
+	AM_RANGE(0x0800, 0x080f) AM_WRITEONLY AM_BASE(&avgdvg_colorram)
 	AM_RANGE(0x0c00, 0x0c00) AM_READ_PORT("IN0")
 	AM_RANGE(0x0d00, 0x0d00) AM_READ_PORT("DSW1")
 	AM_RANGE(0x0e00, 0x0e00) AM_READ_PORT("DSW2")
-	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&vectorram) AM_SIZE(&vectorram_size) AM_REGION("maincpu", 0x2000)
+	AM_RANGE(0x2000, 0x2fff) AM_RAM AM_BASE(&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size) AM_REGION("maincpu", 0x2000)
 	AM_RANGE(0x3000, 0x3fff) AM_ROM
 	AM_RANGE(0x4000, 0x4000) AM_WRITE(tempest_coin_w)
 	AM_RANGE(0x4800, 0x4800) AM_WRITE(avgdvg_go_w)
diff -Nru src-old/mame/drivers/thunderj.c src/mame/drivers/thunderj.c
--- src-old/mame/drivers/thunderj.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/thunderj.c	2010-08-19 01:27:05.000000000 -0700
@@ -129,7 +129,7 @@
 	/* Use these lines to detect when things go south: */
 
 #if 0
-	if (memory_read_word(space, 0x163482) > 0xfff)
+	if (space->read_word(0x163482) > 0xfff)
 		mame_printf_debug("You're screwed!");
 #endif
 
diff -Nru src-old/mame/drivers/tiamc1.c src/mame/drivers/tiamc1.c
--- src-old/mame/drivers/tiamc1.c	2010-07-02 17:12:44.000000000 -0700
+++ src/mame/drivers/tiamc1.c	2010-08-19 00:26:14.000000000 -0700
@@ -120,7 +120,7 @@
 
 static MACHINE_RESET( tiamc1 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	tiamc1_bankswitch_w(space, 0, 0);
 }
 
diff -Nru src-old/mame/drivers/tickee.c src/mame/drivers/tickee.c
--- src-old/mame/drivers/tickee.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/tickee.c	2010-08-19 00:26:14.000000000 -0700
@@ -134,7 +134,7 @@
 {
 	UINT16 *src = &tickee_vram[(params->rowaddr << 8) & 0x3ff00];
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = params->coladdr << 1;
 	int x;
 
@@ -159,7 +159,7 @@
 {
 	UINT16 *src = &tickee_vram[(params->rowaddr << 8) & 0x3ff00];
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = params->coladdr << 1;
 	int x;
 
@@ -195,14 +195,12 @@
 {
 	beamxadd = 50;
 	beamyadd = 0;
-	tlc34076_reset(6);
 }
 
 static MACHINE_RESET( rapidfir )
 {
 	beamxadd = 0;
 	beamyadd = -5;
-	tlc34076_reset(6);
 }
 
 
@@ -226,14 +224,14 @@
 }
 
 
-static void rapidfir_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void rapidfir_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	if (address < 0x800000)
 		memcpy(shiftreg, &tickee_vram[TOWORD(address)], TOBYTE(0x2000));
 }
 
 
-static void rapidfir_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void rapidfir_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	if (address < 0x800000)
 		memcpy(&tickee_vram[TOWORD(address)], shiftreg, TOBYTE(0x2000));
@@ -355,7 +353,7 @@
 	AM_RANGE(0x00000000, 0x003fffff) AM_RAM AM_BASE(&tickee_vram)
 	AM_RANGE(0x02000000, 0x02ffffff) AM_ROM AM_REGION("user1", 0)
 	AM_RANGE(0x04000000, 0x04003fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
-	AM_RANGE(0x04100000, 0x041000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x04100000, 0x041000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0x04200000, 0x0420000f) AM_DEVREAD8("ym1", ay8910_r, 0x00ff)
 	AM_RANGE(0x04200000, 0x0420001f) AM_DEVWRITE8("ym1", ay8910_address_data_w, 0x00ff)
 	AM_RANGE(0x04200100, 0x0420010f) AM_DEVREAD8("ym2", ay8910_r, 0x00ff)
@@ -373,7 +371,7 @@
 	AM_RANGE(0x00000000, 0x003fffff) AM_RAM AM_BASE(&tickee_vram)
 	AM_RANGE(0x02000000, 0x02ffffff) AM_ROM AM_REGION("user1", 0)
 	AM_RANGE(0x04100000, 0x04103fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
-	AM_RANGE(0x04200000, 0x042000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x04200000, 0x042000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0x04300000, 0x0430000f) AM_DEVREAD8("ym1", ay8910_r, 0x00ff)
 	AM_RANGE(0x04300000, 0x0430001f) AM_DEVWRITE8("ym1", ay8910_address_data_w, 0x00ff)
 	AM_RANGE(0x04300100, 0x0430010f) AM_DEVREAD8("ym2", ay8910_r, 0x00ff)
@@ -389,7 +387,7 @@
 	AM_RANGE(0x00000000, 0x003fffff) AM_RAM AM_BASE(&tickee_vram)
 	AM_RANGE(0x02000000, 0x02ffffff) AM_ROM AM_REGION("user1", 0)
 	AM_RANGE(0x04000000, 0x04003fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
-	AM_RANGE(0x04100000, 0x041000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x04100000, 0x041000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0x04200000, 0x0420000f) AM_DEVREAD8("ym", ay8910_r, 0x00ff)
 	AM_RANGE(0x04200000, 0x0420000f) AM_DEVWRITE8("ym", ay8910_address_data_w, 0x00ff)
 	AM_RANGE(0x04200100, 0x0420010f) AM_DEVREADWRITE8("oki", okim6295_r, okim6295_w, 0x00ff)
@@ -418,7 +416,7 @@
 	AM_RANGE(0xfc000b00, 0xfc000b0f) AM_READ_PORT("DSW0")
 	AM_RANGE(0xfc000c00, 0xfc000c1f) AM_READ_PORT("DSW1")
 	AM_RANGE(0xfc000e00, 0xfc000e1f) AM_READ(watchdog_reset16_r)
-	AM_RANGE(0xfc100000, 0xfc1000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0xfc100000, 0xfc1000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0xfc200000, 0xfc207fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
 	AM_RANGE(0xfc300000, 0xfc30000f) AM_DEVREADWRITE8("oki", okim6295_r, okim6295_w, 0x00ff)
 	AM_RANGE(0xfc400010, 0xfc40001f) AM_READ(ff7f_r)
@@ -740,6 +738,8 @@
 	MDRV_TICKET_DISPENSER_ADD("ticket2", 100, TICKET_MOTOR_ACTIVE_LOW, TICKET_STATUS_ACTIVE_HIGH)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_START(tickee)
 	MDRV_VIDEO_UPDATE(tms340x0)
 
@@ -780,6 +780,8 @@
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_START(tickee)
 	MDRV_VIDEO_UPDATE(tms340x0)
 
@@ -805,11 +807,14 @@
 	MDRV_MACHINE_RESET(tickee)
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
-	/* video hardware */
-	MDRV_VIDEO_UPDATE(tms340x0)
 	MDRV_TICKET_DISPENSER_ADD("ticket1", 100, TICKET_MOTOR_ACTIVE_LOW, TICKET_STATUS_ACTIVE_HIGH)
 	MDRV_TICKET_DISPENSER_ADD("ticket2", 100, TICKET_MOTOR_ACTIVE_LOW, TICKET_STATUS_ACTIVE_HIGH)
 
+	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
+	MDRV_VIDEO_UPDATE(tms340x0)
+
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_RGB32)
 	MDRV_SCREEN_RAW_PARAMS(VIDEO_CLOCK/2, 444, 0, 320, 233, 0, 200)
diff -Nru src-old/mame/drivers/tigeroad.c src/mame/drivers/tigeroad.c
--- src-old/mame/drivers/tigeroad.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/drivers/tigeroad.c	2010-08-19 00:26:14.000000000 -0700
@@ -87,7 +87,7 @@
 0x0003, 0x0080, 0x0006, 0x0060, 0x0000, 0x00e0, 0x000a, 0x00c0, 0x0003, 0x0080, 0x0006, 0x0060, 0x0000, 0x00e0, 0x000a, 0x00c0,
 0x0003, 0x0080, 0x0006, 0x0060, 0x0000, 0x00e0, 0x000a, 0x00c0, 0x0003, 0x0080, 0x0006, 0x0060, 0x0000, 0x00e0, 0x000a, 0x00c0 };
 
-static void f1dream_protection_w(const address_space *space)
+static void f1dream_protection_w(address_space *space)
 {
 	int indx;
 	int value = 255;
diff -Nru src-old/mame/drivers/tmnt.c src/mame/drivers/tmnt.c
--- src-old/mame/drivers/tmnt.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/tmnt.c	2010-08-19 01:27:05.000000000 -0700
@@ -367,8 +367,8 @@
 static READ16_HANDLER( ssriders_protection_r )
 {
 	tmnt_state *state = space->machine->driver_data<tmnt_state>();
-	int data = memory_read_word(space, 0x105a0a);
-	int cmd = memory_read_word(space, 0x1058fc);
+	int data = space->read_word(0x105a0a);
+	int cmd = space->read_word(0x1058fc);
 
 	switch (cmd)
 	{
@@ -395,9 +395,9 @@
 
 		case 0x8abc:
 			/* collision table */
-			data = -memory_read_word(space, 0x105818);
+			data = -space->read_word(0x105818);
 			data = ((data / 8 - 4) & 0x1f) * 0x40;
-			data += ((memory_read_word(space, 0x105cb0) +
+			data += ((space->read_word(0x105cb0) +
 						256 * k052109_r(state->k052109, 0x1a01) + k052109_r(state->k052109, 0x1a00) - 6) / 8 + 12) & 0x3f;
 			return data;
 
@@ -424,7 +424,7 @@
 
 			for (i = 0; i < 128; i++)
 			{
-				if ((memory_read_word(space, 0x180006 + 128 * i) >> 8) == logical_pri)
+				if ((space->read_word(0x180006 + 128 * i) >> 8) == logical_pri)
 				{
 					k053245_word_w(state->k053245, 8 * i, hardware_pri, 0x00ff);
 					hardware_pri++;
@@ -806,7 +806,7 @@
 	return 0;
 }
 
-static void tmnt2_put_word( const address_space *space, UINT32 addr, UINT16 data )
+static void tmnt2_put_word( address_space *space, UINT32 addr, UINT16 data )
 {
 	tmnt_state *state = space->machine->driver_data<tmnt_state>();
 
@@ -967,9 +967,9 @@
 
 		CellVar >>= 1;
 
-		memory_write_word(space, dst + 0x00, 0x8000 | ((src[1] & 0xfc00) >> 2));	/* size, flip xy */
-		memory_write_word(space, dst + 0x04, src[0]);	/* code */
-		memory_write_word(space, dst + 0x18, (src[1] & 0x3ff) ^		/* color, mirror, priority */
+		space->write_word(dst + 0x00, 0x8000 | ((src[1] & 0xfc00) >> 2));	/* size, flip xy */
+		space->write_word(dst + 0x04, src[0]);	/* code */
+		space->write_word(dst + 0x18, (src[1] & 0x3ff) ^		/* color, mirror, priority */
 				(sunset_104000[CellVar + 0x00] & 0x0060));
 
 		/* base color modifier */
@@ -979,24 +979,24 @@
 		/* Also, the bosses don't blink when they are about to die - don't know */
 		/* if this is correct or not. */
 //      if (state->sunset_104000[CellVar + 0x15] & 0x001f)
-//          memory_write_word(dst + 0x18, (memory_read_word(space, dst + 0x18) & 0xffe0) |
+//          dst + 0x18->write_word((space->read_word(dst + 0x18) & 0xffe0) |
 //                  (state->sunset_104000[CellVar + 0x15] & 0x001f));
 
 		x = src[2];
 		if (state->sunset_104000[CellVar + 0x00] & 0x4000)
 		{
 			/* flip x */
-			memory_write_word(space, dst + 0x00, memory_read_word(space, dst + 0x00) ^ 0x1000);
+			space->write_word(dst + 0x00, space->read_word(dst + 0x00) ^ 0x1000);
 			x = -x;
 		}
 		x += state->sunset_104000[CellVar + 0x06];
-		memory_write_word(space, dst + 0x0c, x);
+		space->write_word(dst + 0x0c, x);
 		y = src[3];
 		y += state->sunset_104000[CellVar + 0x07];
 		/* don't do second offset for shadows */
 		if ((state->tmnt2_1c0800[0x08] & 0x00ff) != 0x01)
 			y += state->sunset_104000[CellVar + 0x08];
-		memory_write_word(space, dst + 0x08, y);
+		space->write_word(dst + 0x08, y);
 #if 0
 logerror("copy command %04x sprite %08x data %08x: %04x%04x %04x%04x  modifiers %08x:%04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x %04x%04x\n",
 	state->tmnt2_1c0800[0x05],
diff -Nru src-old/mame/drivers/toaplan1.c src/mame/drivers/toaplan1.c
--- src-old/mame/drivers/toaplan1.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/toaplan1.c	2010-08-27 14:32:06.000000000 -0700
@@ -353,7 +353,7 @@
 	AM_RANGE(0x000000, 0x00ffff) AM_ROM
 	AM_RANGE(0x040000, 0x07ffff) AM_ROM
 	AM_RANGE(0x080000, 0x083fff) AM_RAM
-	AM_RANGE(0x0c0000, 0x0c0fff) AM_RAM AM_BASE_SIZE_GENERIC(spriteram)
+	AM_RANGE(0x0c0000, 0x0c0fff) AM_RAM AM_BASE_SIZE_MEMBER(toaplan1_state, spriteram, spriteram_size)
 	AM_RANGE(0x100000, 0x100001) AM_WRITE(rallybik_bcu_flipscreen_w)
 	AM_RANGE(0x100002, 0x100003) AM_READWRITE(toaplan1_tileram_offs_r, toaplan1_tileram_offs_w)
 	AM_RANGE(0x100004, 0x100007) AM_READWRITE(rallybik_tileram16_r, toaplan1_tileram16_w)
@@ -362,8 +362,8 @@
 //  AM_RANGE(0x140000, 0x140001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x140002, 0x140003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x140008, 0x14000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x144000, 0x1447ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x146000, 0x1467ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x144000, 0x1447ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x146000, 0x1467ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x180000, 0x180fff) AM_READWRITE(toaplan1_shared_r, toaplan1_shared_w)
 	AM_RANGE(0x1c0000, 0x1c0003) AM_WRITE(toaplan1_tile_offsets_w)
 	AM_RANGE(0x1c8000, 0x1c8001) AM_WRITE(toaplan1_reset_sound)
@@ -384,8 +384,8 @@
 //  AM_RANGE(0x140000, 0x140001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x140002, 0x140003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x140008, 0x14000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x144000, 0x1447ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x146000, 0x1467ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x144000, 0x1447ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x146000, 0x1467ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x180000, 0x180fff) AM_READWRITE(toaplan1_shared_r, toaplan1_shared_w)
 	AM_RANGE(0x1c0000, 0x1c0003) AM_WRITE(toaplan1_tile_offsets_w)
 	AM_RANGE(0x1c0006, 0x1c0007) AM_WRITE(toaplan1_fcu_flipscreen_w)
@@ -399,8 +399,8 @@
 //  AM_RANGE(0x080000, 0x080001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x080002, 0x080003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x080008, 0x08000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x084000, 0x0847ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x086000, 0x0867ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x084000, 0x0847ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x086000, 0x0867ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x0c0000, 0x0c0fff) AM_READWRITE(toaplan1_shared_r, toaplan1_shared_w)
 	AM_RANGE(0x100000, 0x100001) AM_WRITE(toaplan1_bcu_flipscreen_w)
 	AM_RANGE(0x100002, 0x100003) AM_READWRITE(toaplan1_tileram_offs_r, toaplan1_tileram_offs_w)
@@ -425,8 +425,8 @@
 //  AM_RANGE(0x400000, 0x400001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x400002, 0x400003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x400008, 0x40000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x440000, 0x440fff) AM_READWRITE(toaplan1_shared_r, toaplan1_shared_w)
 	AM_RANGE(0x480000, 0x480001) AM_WRITE(toaplan1_bcu_flipscreen_w)
 	AM_RANGE(0x480002, 0x480003) AM_READWRITE(toaplan1_tileram_offs_r, toaplan1_tileram_offs_w)
@@ -444,8 +444,8 @@
 //  AM_RANGE(0x400000, 0x400001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x400002, 0x400003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x400008, 0x40000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x600000, 0x600fff) AM_READWRITE(toaplan1_shared_r, toaplan1_shared_w)
 	AM_RANGE(0x800000, 0x800001) AM_WRITE(toaplan1_bcu_flipscreen_w)
 	AM_RANGE(0x800002, 0x800003) AM_READWRITE(toaplan1_tileram_offs_r, toaplan1_tileram_offs_w)
@@ -472,8 +472,8 @@
 //  AM_RANGE(0x100000, 0x100001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x100002, 0x100003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x100008, 0x10000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x104000, 0x1047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x106000, 0x1067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x104000, 0x1047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x106000, 0x1067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x140000, 0x140001) AM_READ_PORT("P1")
 	AM_RANGE(0x140002, 0x140003) AM_READ_PORT("P2")
 	AM_RANGE(0x140004, 0x140005) AM_READ_PORT("DSWA")
@@ -509,8 +509,8 @@
 //  AM_RANGE(0x300000, 0x300001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x300002, 0x300003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x300008, 0x30000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x304000, 0x3047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x306000, 0x3067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x304000, 0x3047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x306000, 0x3067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x340000, 0x340003) AM_WRITE(toaplan1_tile_offsets_w)
 	AM_RANGE(0x340006, 0x340007) AM_WRITE(toaplan1_fcu_flipscreen_w)
 ADDRESS_MAP_END
@@ -527,8 +527,8 @@
 //  AM_RANGE(0x400000, 0x400001) AM_WRITE(?? video frame related ??)
 	AM_RANGE(0x400002, 0x400003) AM_WRITE(toaplan1_intenable_w)
 	AM_RANGE(0x400008, 0x40000f) AM_WRITE(toaplan1_bcu_control_w)
-	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE(&toaplan1_colorram1) AM_SIZE(&toaplan1_colorram1_size)
-	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE(&toaplan1_colorram2) AM_SIZE(&toaplan1_colorram2_size)
+	AM_RANGE(0x404000, 0x4047ff) AM_READWRITE(toaplan1_colorram1_r, toaplan1_colorram1_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram1, colorram1_size)
+	AM_RANGE(0x406000, 0x4067ff) AM_READWRITE(toaplan1_colorram2_r, toaplan1_colorram2_w) AM_BASE_SIZE_MEMBER(toaplan1_state, colorram2, colorram2_size)
 	AM_RANGE(0x440000, 0x440005) AM_READWRITE(vimana_mcu_r, vimana_mcu_w)  /* shared memory from 0x440000 to 0x44ffff ? */
 	AM_RANGE(0x440006, 0x440007) AM_READ_PORT("DSWA")
 	AM_RANGE(0x440008, 0x440009) AM_READ(vimana_system_port_r)   /* "SYSTEM" + coinage simulation */
@@ -548,7 +548,7 @@
 
 static ADDRESS_MAP_START( toaplan1_sound_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
-	AM_RANGE(0x8000, 0xffff) AM_RAM AM_BASE(&toaplan1_sharedram)
+	AM_RANGE(0x8000, 0xffff) AM_RAM AM_BASE_MEMBER(toaplan1_state, sharedram)
 ADDRESS_MAP_END
 
 static ADDRESS_MAP_START( rallybik_sound_io_map, ADDRESS_SPACE_IO, 8 )
@@ -1512,6 +1512,8 @@
 
 static MACHINE_DRIVER_START( rallybik )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(rallybik_main_map)
@@ -1526,7 +1528,7 @@
 	MDRV_MACHINE_RESET(toaplan1)
 
 	/* video hardware */
-	MDRV_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK | VIDEO_BUFFERS_SPRITERAM)
+	MDRV_VIDEO_ATTRIBUTES(VIDEO_UPDATE_BEFORE_VBLANK)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
 	MDRV_SCREEN_REFRESH_RATE(55.14)		/* verified on pcb */
@@ -1552,6 +1554,8 @@
 
 static MACHINE_DRIVER_START( truxton )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(truxton_main_map)
@@ -1592,6 +1596,8 @@
 
 static MACHINE_DRIVER_START( hellfire )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(hellfire_main_map)
@@ -1632,6 +1638,8 @@
 
 static MACHINE_DRIVER_START( zerowing )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(zerowing_main_map)
@@ -1672,6 +1680,8 @@
 
 static MACHINE_DRIVER_START( demonwld )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(demonwld_main_map)
@@ -1703,7 +1713,7 @@
 
 	MDRV_VIDEO_START(toaplan1)
 	MDRV_VIDEO_EOF(toaplan1)
-	MDRV_VIDEO_UPDATE(demonwld)
+	MDRV_VIDEO_UPDATE(toaplan1)
 
 	/* sound hardware */
 	MDRV_SPEAKER_STANDARD_MONO("mono")
@@ -1716,6 +1726,8 @@
 
 static MACHINE_DRIVER_START( samesame )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(samesame_main_map)
@@ -1754,6 +1766,8 @@
 
 static MACHINE_DRIVER_START( outzone )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)
 	MDRV_CPU_PROGRAM_MAP(outzone_main_map)
@@ -1794,6 +1808,8 @@
 
 static MACHINE_DRIVER_START( vimana )
 
+	MDRV_DRIVER_DATA( toaplan1_state )
+
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", M68000, XTAL_10MHz)	/* verified on pcb */
 	MDRV_CPU_PROGRAM_MAP(vimana_main_map)
diff -Nru src-old/mame/drivers/toaplan2.c src/mame/drivers/toaplan2.c
--- src-old/mame/drivers/toaplan2.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/drivers/toaplan2.c	2010-08-23 03:13:59.000000000 -0700
@@ -197,6 +197,7 @@
 Battle Garegga
 Mahou Daisakusen
 Battle Bakraid
+(emulated in video/gp9001.c)
 
 *********************************************************************
 
@@ -204,7 +205,7 @@
 
 Teki Paki                      Working, but no sound. Missing sound MCU dump. Chip is protected. It's a QFP80 Hitachi HD647180.
 Ghox                           Working, but no sound. Missing sound MCU dump. It's a QFP80 Hitachi HD647180.
-Dogyuun                        Working, but no sound. MCU type is likely a NEC V25+. Chip is a PLCC94 stamped 'TS-002-MACH'.
+Dogyuun                        Working, no sound. MCU type is likely a NEC V25+. Chip is a PLCC94 stamped 'TS-002-MACH'.
 Knuckle Bash                   Working, but sound FX only (missing music). MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-004-DASH'.
                                         Some PCBs use another version stamped 'NITRO' which is the same chip type.
 Truxton 2                      Working.
@@ -216,7 +217,7 @@
 Grind Stormer                  Working, but no sound. MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-007-SPY'.
 VFive                          Working, but no sound. MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-007-SPY'.
 Batsugun                       Working, but sound FX only (missing music) and wrong GFX priorities. MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-007-SPY'.
-Batsugun Sp'                   Working, but sound FX only (missing music) and wrong GFX priorities. MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-007-SPY'.
+Batsugun Sp'                  Working, but sound FX only (missing music) and wrong GFX priorities. MCU type is a NEC V25+. Chip is a PLCC94 stamped 'TS-007-SPY'.
 Snow Bros. 2                   Working.
 Mahou Daisakusen               Working.
 Shippu Mahou Daisakusen        Working.
@@ -261,35 +262,6 @@
 #include "includes/toaplan2.h"
 #include "rendlay.h"
 
-/**************** Machine stuff ******************/
-//#define USE_HD64x180          /* Define if CPU support is available */
-//#define USE_ENCRYPTED_V25S    /* Define to enable V25 even on games where it is encrypted */
-
-#define CPU_2_NONE		0x00
-#define CPU_2_Z80		0x5a
-#define CPU_2_HD647180	0xa5
-#define CPU_2_V25		0xff
-
-/************ Machine RAM related values ************/
-static UINT8 *toaplan2_shared_ram;
-static UINT8 *raizing_shared_ram;		/* Shared ram used in Shippumd and Mahoudai */
-static UINT16 *toaplan2_shared_ram16;	/* Really 8bit RAM connected to Z180 */
-#ifndef USE_ENCRYPTED_V25S
-static UINT16 *V25_shared_ram;			/* Really 8bit RAM connected to Z180 */
-#endif
-static UINT16 *fixeight_sec_cpu_mem;
-
-/********** Status related values **********/
-int toaplan2_sub_cpu = 0;
-static UINT16 mcu_data = 0;
-static UINT16 video_status;
-static INT8 old_p1_paddle_h;		/* For Ghox */
-static INT8 old_p2_paddle_h;
-static INT8 current_bank;			/* Z80 bank used in Battle Garegga and Batrider */
-static int raizing_sndirq_line;		/* IRQ4 for batrider, IRQ2 for bbakraid */
-static UINT16 raizing_Z80_busreq;
-static int bbakraid_unlimited_ver;
-
 static MACHINE_RESET(batsugun);
 static READ16_HANDLER( batsugun_share_r );
 static WRITE16_HANDLER( batsugun_share_w );
@@ -298,26 +270,23 @@
 static WRITE16_HANDLER( batsugun_share2_w );
 #endif
 
-
-
-
-
 /***************************************************************************
   Initialisation handlers
 ***************************************************************************/
 
-static running_device *sub_cpu = NULL;
-
 static void toaplan2_reset(running_device *device)
 {
-	if (sub_cpu != NULL)
-		cpu_set_input_line(sub_cpu, INPUT_LINE_RESET, PULSE_LINE);
-}
+	toaplan2_state *state = device->machine->driver_data<toaplan2_state>();
 
+	if (state->sub_cpu != NULL)
+		cpu_set_input_line(state->sub_cpu, INPUT_LINE_RESET, PULSE_LINE);
+}
 
 static MACHINE_RESET( toaplan2 )
 {
-	mcu_data = 0x00;
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->mcu_data = 0x00;
 
 	/*
       All games execute a RESET instruction on init, presumably to reset the sound CPU.
@@ -329,29 +298,36 @@
 
 static MACHINE_RESET( ghox )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
 	MACHINE_RESET_CALL(toaplan2);
-	old_p1_paddle_h = 0;
-	old_p2_paddle_h = 0;
+	state->old_p1_paddle_h = 0;
+	state->old_p2_paddle_h = 0;
 }
 
 static MACHINE_RESET( dogyuun )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
 	MACHINE_RESET_CALL(batsugun);
-	mcu_data = 0xffaa;
+	state->mcu_data = 0xffaa;
 }
 
 static MACHINE_RESET( vfive )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
 	MACHINE_RESET_CALL(batsugun);
-	mcu_data = 0xffaa;
+	state->mcu_data = 0xffaa;
 }
 
 static MACHINE_RESET( bgaregga )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	UINT8 *Z80 = (UINT8 *)memory_region(machine, "audiocpu");
 
 	// Set Z80 bank switch - default bank is 2
-	current_bank = 4;
+	state->current_bank = 4;
 	memory_configure_bank(machine, "bank1", 0, 16, Z80, 0x4000);
 	memory_set_bank(machine, "bank1", 4);
 
@@ -360,71 +336,83 @@
 
 static void register_state_save(running_machine *machine)
 {
-	state_save_register_global(machine, mcu_data);
-	state_save_register_global(machine, video_status);
-	state_save_register_global(machine, old_p1_paddle_h);
-	state_save_register_global(machine, old_p2_paddle_h);
-	state_save_register_global(machine, current_bank);
-	state_save_register_global(machine, raizing_Z80_busreq);
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state_save_register_global(machine, state->mcu_data);
+	state_save_register_global(machine, state->video_status);
+	state_save_register_global(machine, state->old_p1_paddle_h);
+	state_save_register_global(machine, state->old_p2_paddle_h);
+	state_save_register_global(machine, state->current_bank);
+	state_save_register_global(machine, state->z80_busreq);
 }
 
 static DRIVER_INIT( T2_Z80 )		/* init_t2_Z80(); */
 {
-	toaplan2_sub_cpu = CPU_2_Z80;
-	sub_cpu = machine->device("audiocpu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->sub_cpu_type = CPU_2_Z80;
+	state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( T2_Z180 )
 {
-	toaplan2_sub_cpu = CPU_2_HD647180;
-	sub_cpu = machine->device("mcu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->sub_cpu_type = CPU_2_HD647180;
+	state->sub_cpu = machine->device("mcu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( T2_V25 )
 {
-	toaplan2_sub_cpu = CPU_2_V25;
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->sub_cpu_type = CPU_2_V25;
 	if (machine->device("mcu") != NULL)
-		sub_cpu = machine->device("mcu");
+		state->sub_cpu = machine->device("mcu");
 	else if (machine->device("audiocpu") != NULL)
-		sub_cpu = machine->device("audiocpu");
+		state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( T2_noZ80 )
 {
-	toaplan2_sub_cpu = CPU_2_NONE;
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->sub_cpu_type = CPU_2_NONE;
+	state->sub_cpu = NULL;
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( fixeight )
 {
-	sub_cpu = machine->device("audiocpu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 
-	if (fixeight_sec_cpu_mem)
-	{
-		memory_install_ram(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x28f002, 0x28fbff, 0, 0, fixeight_sec_cpu_mem );
-	}
+	state->sub_cpu_type = CPU_2_V25;
+	state->sub_cpu = machine->device("audiocpu");
+
+	memory_install_ram(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x28f002, 0x28fbff, 0, 0, NULL);
 
-	toaplan2_sub_cpu = CPU_2_V25;
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( fixeighb )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	UINT16 *bgdata = (UINT16 *)memory_region(machine, "maincpu");
-	memory_set_bankptr(machine, "bank1", &bgdata[0x40000]); /* $80000 - $fffff */
 
-	toaplan2_sub_cpu = CPU_2_NONE;
+	memory_set_bankptr(machine, "bank1", &bgdata[0x40000]); /* $80000 - $fffff */
+	state->sub_cpu_type = CPU_2_NONE;
+	state->sub_cpu = NULL;
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( pipibibi )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	int A;
 	int oldword, newword;
-
 	UINT16 *pipibibi_68k_rom = (UINT16 *)(memory_region(machine, "maincpu"));
 
 	/* unscramble the 68K ROM data. */
@@ -498,34 +486,40 @@
 		pipibibi_68k_rom[A+3] = newword;
 	}
 
-	toaplan2_sub_cpu = CPU_2_Z80;
-	sub_cpu = machine->device("audiocpu");
+	state->sub_cpu_type = CPU_2_Z80;
+	state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( batrider )
 {
-	raizing_sndirq_line = 4;
-	toaplan2_sub_cpu = CPU_2_Z80;
-	sub_cpu = machine->device("audiocpu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->sndirq_line = 4;
+	state->sub_cpu_type = CPU_2_Z80;
+	state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( bbakraid )
 {
-	bbakraid_unlimited_ver = 0;
-	raizing_sndirq_line = 2;
-	toaplan2_sub_cpu = CPU_2_Z80;
-	sub_cpu = machine->device("audiocpu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->unlimited_ver = 0;
+	state->sndirq_line = 2;
+	state->sub_cpu_type = CPU_2_Z80;
+	state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
 static DRIVER_INIT( bbakradu )
 {
-	bbakraid_unlimited_ver = 1;
-	raizing_sndirq_line = 2;
-	toaplan2_sub_cpu = CPU_2_Z80;
-	sub_cpu = machine->device("audiocpu");
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->unlimited_ver = 1;
+	state->sndirq_line = 2;
+	state->sub_cpu_type = CPU_2_Z80;
+	state->sub_cpu = machine->device("audiocpu");
 	register_state_save(machine);
 }
 
@@ -560,26 +554,28 @@
 	/* +---------+---------+--------+---------------------------+ */
 	/*************** Control Signals are active low ***************/
 
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int hpos = space->machine->primary_screen->hpos();
 	int vpos = space->machine->primary_screen->vpos();
-	video_status = 0xff00;						/* Set signals inactive */
+
+	state->video_status = 0xff00;						/* Set signals inactive */
 
 	vpos = (vpos + 15) % 262;
 
 	if ((hpos > 325) && (hpos < 380))
-		video_status &= ~0x8000;
+		state->video_status &= ~0x8000;
 	if ((vpos >= 247) && (vpos <= 250))
-		video_status &= ~0x4000;
+		state->video_status &= ~0x4000;
 	if (vpos >= 245)
-		video_status &= ~0x0100;
+		state->video_status &= ~0x0100;
 	if (vpos < 256)
-		video_status |= (vpos & 0xff);
+		state->video_status |= (vpos & 0xff);
 	else
-		video_status |= 0xff;
+		state->video_status |= 0xff;
 
 //  logerror("VC: vpos=%04x hpos=%04x VBL=%04x\n",vpos,hpos,space->machine->primary_screen->vblank());
 
-	return video_status;
+	return state->video_status;
 }
 
 static WRITE8_HANDLER( toaplan2_coin_w )
@@ -623,12 +619,16 @@
 
 	if (ACCESSING_BITS_0_7)
 	{
+		#ifdef USE_ENCRYPTED_V25S
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+		#endif
+
 		toaplan2_coin_w(space, offset, data & 0x0f);
 
 		#ifdef USE_ENCRYPTED_V25S
 		/* only the ram-based V25 based games access the following bits */
-		//cpu_set_input_line(sub_cpu, INPUT_LINE_RESET, (data & 0x0020) ? CLEAR_LINE : ASSERT_LINE );
-		cpu_set_input_line(sub_cpu, INPUT_LINE_HALT,  (data & 0x0010) ? CLEAR_LINE : ASSERT_LINE);
+		//cpu_set_input_line(state->sub_cpu, INPUT_LINE_RESET, (data & 0x0020) ? CLEAR_LINE : ASSERT_LINE );
+		cpu_set_input_line(state->sub_cpu, INPUT_LINE_HALT,  (data & 0x0010) ? CLEAR_LINE : ASSERT_LINE);
 		#endif
 
 	}
@@ -644,10 +644,12 @@
 
 	if (ACCESSING_BITS_0_7)
 	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 		toaplan2_coin_w(space, offset, data & 0x0f);
 		/* only the ram-based V25 based games access the following bits */
-		//cpu_set_input_line(sub_cpu, INPUT_LINE_RESET, (data & 0x0020) ? CLEAR_LINE : ASSERT_LINE );
-		cpu_set_input_line(sub_cpu, INPUT_LINE_HALT,  (data & 0x0010) ? CLEAR_LINE : ASSERT_LINE);
+		//cpu_set_input_line(state->sub_cpu, INPUT_LINE_RESET, (data & 0x0020) ? CLEAR_LINE : ASSERT_LINE );
+		cpu_set_input_line(state->sub_cpu, INPUT_LINE_HALT,  (data & 0x0010) ? CLEAR_LINE : ASSERT_LINE);
 	}
 	if (ACCESSING_BITS_8_15 && (data & 0xff00) )
 	{
@@ -668,16 +670,20 @@
 	}
 }
 
-static READ16_HANDLER( toaplan2_shared_r )
+static READ16_HANDLER( z80_shared_r )
 {
-	return toaplan2_shared_ram[offset] & 0xff;
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->z80_shared_ram[offset] & 0xff;
 }
 
-static WRITE16_HANDLER( toaplan2_shared_w )
+static WRITE16_HANDLER( z80_shared_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		toaplan2_shared_ram[offset] = data & 0xff;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->z80_shared_ram[offset] = data & 0xff;
 	}
 }
 
@@ -688,65 +694,58 @@
 
 	if (ACCESSING_BITS_0_7)
 	{
-		if (toaplan2_sub_cpu == CPU_2_Z80)			/* Whoopee */
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		if (state->sub_cpu_type == CPU_2_Z80)			/* Whoopee */
 		{
-			toaplan2_shared_ram[0] = data & 0xff;
+			state->z80_shared_ram[0] = data & 0xff;
 		}
 		else										/* Teki Paki */
 		{
-			mcu_data = data & 0xff;
-			logerror("PC:%08x Writing command (%04x) to secondary CPU shared port\n",cpu_get_previouspc(space->cpu),mcu_data);
+			state->mcu_data = data & 0xff;
+			logerror("PC:%08x Writing command (%04x) to secondary CPU shared port\n", cpu_get_previouspc(space->cpu), state->mcu_data);
 		}
 	}
 }
 
 static CUSTOM_INPUT( c2map_r )
 {
+	toaplan2_state *state = field->port->machine->driver_data<toaplan2_state>();
+
 	/* For Teki Paki hardware */
 	/* bit 4 high signifies secondary CPU is ready */
 	/* bit 5 is tested low before V-Blank bit ??? */
-	switch (toaplan2_sub_cpu)
+	switch (state->sub_cpu_type)
 	{
-		case CPU_2_Z80:			mcu_data = toaplan2_shared_ram[0]; break; /* Whoopee */
-		case CPU_2_HD647180:	mcu_data = 0xff; break;					  /* Teki Paki */
-		default:				mcu_data = 0x00; break;
+		case CPU_2_Z80:			state->mcu_data = state->z80_shared_ram[0]; break; /* Whoopee */
+		case CPU_2_HD647180:	state->mcu_data = 0xff; break;					  /* Teki Paki */
+		default:				state->mcu_data = 0x00; break;
 	}
 
-	return (mcu_data == 0xff) ? 0x01 : 0x00;
-}
-
-static READ16_HANDLER( pipibibi_z80_status_r )
-{
-	return toaplan2_shared_ram[0] & 0xff;
-}
-
-static WRITE16_HANDLER( pipibibi_z80_task_w )
-{
-	if (ACCESSING_BITS_0_7)
-	{
-		toaplan2_shared_ram[0] = data & 0xff;
-	}
+	return (state->mcu_data == 0xff) ? 0x01 : 0x00;
 }
 
 static READ16_HANDLER( ghox_p1_h_analog_r )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	INT8 value, new_value;
 
 	new_value = input_port_read(space->machine, "PAD1");
-	if (new_value == old_p1_paddle_h) return 0;
-	value = new_value - old_p1_paddle_h;
-	old_p1_paddle_h = new_value;
+	if (new_value == state->old_p1_paddle_h) return 0;
+	value = new_value - state->old_p1_paddle_h;
+	state->old_p1_paddle_h = new_value;
 	return value;
 }
 
 static READ16_HANDLER( ghox_p2_h_analog_r )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	INT8 value, new_value;
 
 	new_value = input_port_read(space->machine, "PAD2");
-	if (new_value == old_p2_paddle_h) return 0;
-	value = new_value - old_p2_paddle_h;
-	old_p2_paddle_h = new_value;
+	if (new_value == state->old_p2_paddle_h) return 0;
+	value = new_value - state->old_p2_paddle_h;
+	state->old_p2_paddle_h = new_value;
 	return value;
 }
 
@@ -759,7 +758,10 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		mcu_data = data;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+		UINT16 *toaplan2_shared_ram16 = state->shared_ram16;
+
+		state->mcu_data = data;
 		if ((data >= 0xd0) && (data < 0xe0))
 		{
 			offset = ((data & 0x0f) * 2) + (0x38 / 2);
@@ -768,7 +770,7 @@
 		}
 		else
 		{
-			logerror("PC:%08x Writing %08x to HD647180 cpu shared ram status port\n",cpu_get_previouspc(space->cpu),mcu_data);
+			logerror("PC:%08x Writing %08x to HD647180 cpu shared ram status port\n", cpu_get_previouspc(space->cpu), state->mcu_data);
 		}
 		toaplan2_shared_ram16[0x56 / 2] = 0x004e;	/* Return a RTS instruction */
 		toaplan2_shared_ram16[0x58 / 2] = 0x0075;
@@ -811,14 +813,18 @@
        Offset $48 and $46 are accessed from around PC:06776
     */
 
-	return toaplan2_shared_ram16[offset] & 0xff;
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->shared_ram16[offset] & 0xff;
 }
 
 static WRITE16_HANDLER( ghox_shared_ram_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		toaplan2_shared_ram16[offset] = data & 0xff;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->shared_ram16[offset] = data & 0xff;
 	}
 }
 
@@ -829,13 +835,17 @@
     the 68000 and the V25+ CPU. The 68000 reads the status of the V25+
     via a location of the shared memory.
 */
-	return toaplan2_shared_ram16[offset] & 0xff;
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->shared_ram16[offset] & 0xff;
 }
 
 static WRITE16_HANDLER( shared_ram_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 		data &= 0xff;
 		switch (offset * 2)
 		{
@@ -844,14 +854,14 @@
 			case 0x9f0:
 			case 0xcf0:
 			case 0xcf8:
-			case 0xff8: toaplan2_shared_ram16[offset + 1] = data; /* Dogyuun */
-						toaplan2_shared_ram16[offset + 2] = data; /* FixEight */
+			case 0xff8: state->shared_ram16[offset + 1] = data; /* Dogyuun */
+						state->shared_ram16[offset + 2] = data; /* FixEight */
 						logerror("PC:%08x Writing (%04x) to shared RAM at %04x\n",cpu_get_previouspc(space->cpu),data,(offset*2));
 						if (data == 0x81) data = 0x0001;
 						break;
 			default:	break;
 		}
-		toaplan2_shared_ram16[offset] = data;
+		state->shared_ram16[offset] = data;
 	}
 }
 
@@ -860,13 +870,14 @@
 /*** Status port includes NEC V25+ CPU POST codes. ************
  *** This is actually a part of the 68000/V25+ Shared RAM */
 
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int response = 0xffff;
 
 	/* Provide successful POST responses */
-	if (mcu_data == 0xffaa)						/* Dogyuun */
+	if (state->mcu_data == 0xffaa)						/* Dogyuun */
 	{
 		response = 0xffaa;
-		mcu_data = 0xffff;
+		state->mcu_data = 0xffff;
 	}
 
 	logerror("PC:%06x reading status %08x from the NEC V25+ secondary CPU port\n",cpu_get_previouspc(space->cpu),response);
@@ -875,12 +886,14 @@
 
 static WRITE16_HANDLER( dogyuun_snd_cpu_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	if (ACCESSING_BITS_0_7)
 	{
-		mcu_data = data;
+		state->mcu_data = data;
 		dogyuun_okisnd_w(space->machine->device("oki"), data);
 	}
-	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n",cpu_get_previouspc(space->cpu),mcu_data);
+	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n", cpu_get_previouspc(space->cpu), state->mcu_data);
 }
 
 
@@ -889,21 +902,22 @@
 /*** Status port includes NEC V25+ CPU POST codes. ************
  *** This is actually a part of the 68000/V25+ Shared RAM */
 
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int response = 0xffff;
 
-	if ((mcu_data & 0xffff) == 0x0faa)
+	if ((state->mcu_data & 0xffff) == 0x0faa)
 	{
-		mcu_data = 0xffff;
+		state->mcu_data = 0xffff;
 		response = 0xffaa;
 	}
-	if ((mcu_data & 0xffff) == 0xff00)
+	if ((state->mcu_data & 0xffff) == 0xff00)
 	{
-		mcu_data = 0x0faa;
+		state->mcu_data = 0x0faa;
 		response = 0xffaa;		/* Second CPU passed POST response */
 	}
-	if ((mcu_data & 0xff00) == 0x0000)
+	if ((state->mcu_data & 0xff00) == 0x0000)
 	{
-		response = mcu_data;	/* Return the shared RAM data during POST */
+		response = state->mcu_data;	/* Return the shared RAM data during POST */
 	}
 	logerror("PC:%06x reading status %08x from the NEC V25+ secondary CPU port\n",cpu_get_previouspc(space->cpu),response);
 	return response;
@@ -911,14 +925,16 @@
 
 static WRITE16_HANDLER( fixeight_sec_cpu_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	if (ACCESSING_BITS_0_7)
 	{
-		if (mcu_data & 0xff00)
+		if (state->mcu_data & 0xff00)
 		{
-			mcu_data = (mcu_data & 0xff00) | (data & 0xff);
+			state->mcu_data = (state->mcu_data & 0xff00) | (data & 0xff);
 			fixeight_okisnd_w(space->machine->device("oki"), data);
 		}
-		else if (mcu_data == 0xff00)
+		else if (state->mcu_data == 0xff00)
 		{
 #if 0		/* check the 37B6 code */
 			/* copy nvram data to shared ram after post is complete */
@@ -930,50 +946,58 @@
 			/* game keeping service mode. It writes/reads the settings to/from */
 			/* these shared RAM locations. The secondary CPU reads/writes them */
 			/* from/to nvram to store the settings (a 93C45 EEPROM) */
-			//memory_install_ram(space, 0x28f002, 0x28fbff, 0, 0, fixeight_sec_cpu_mem);
+			//memory_install_ram(space, 0x28f002, 0x28fbff, 0, 0, NULL);
 			memory_install_read_port(space, 0x28f004, 0x28f005, 0, 0, "DSWA");	/* Dip Switch A - Wrong !!! */
 			memory_install_read_port(space, 0x28f006, 0x28f007, 0, 0, "DSWB");	/* Dip Switch B - Wrong !!! */
 			memory_install_read_port(space, 0x28f008, 0x28f009, 0, 0, "JMPR");	/* Territory Jumper block - Wrong !!! */
 
-			mcu_data = data;
+			state->mcu_data = data;
 		}
 		else
 		{
-			mcu_data = data;
+			state->mcu_data = data;
 		}
 	}
-	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n",cpu_get_previouspc(space->cpu),mcu_data);
+	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n", cpu_get_previouspc(space->cpu), state->mcu_data);
 }
 
 static WRITE16_HANDLER( vfive_snd_cpu_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	if (ACCESSING_BITS_0_7)
 	{
-		mcu_data = data;
+		state->mcu_data = data;
 	}
-	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n",cpu_get_previouspc(space->cpu),mcu_data);
+	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port\n", cpu_get_previouspc(space->cpu), state->mcu_data);
 }
 
 static WRITE16_HANDLER( batsugun_snd_cpu_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	if (ACCESSING_BITS_0_7)
 	{
-		mcu_data = data;
+		state->mcu_data = data;
 		batsugun_okisnd_w(space->machine->device("oki"), data);
 	}
-	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port %02x\n",cpu_get_previouspc(space->cpu),mcu_data,(offset*2));
+	logerror("PC:%06x Writing command (%04x) to the NEC V25+ secondary CPU port %02x\n", cpu_get_previouspc(space->cpu), state->mcu_data, (offset*2));
 }
 
 static READ16_HANDLER( V25_sharedram_r )
 {
-	return V25_shared_ram[offset] & 0xff;
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->V25_shared_ram[offset] & 0xff;
 }
 
 static WRITE16_HANDLER( V25_sharedram_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		V25_shared_ram[offset] = data & 0xff;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->V25_shared_ram[offset] = data & 0xff;
 	}
 }
 #endif
@@ -1025,27 +1049,14 @@
 ***************************************************************************/
 
 
-static READ16_HANDLER( raizing_shared_ram_r )
-{
-	return raizing_shared_ram[offset] & 0xff;
-}
-
-
-static WRITE16_HANDLER( raizing_shared_ram_w )
-{
-	if (ACCESSING_BITS_0_7)
-	{
-		raizing_shared_ram[offset] = data & 0xff;
-	}
-}
-
-
 static WRITE16_HANDLER( bgaregga_soundlatch_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 		soundlatch_w(space, offset, data & 0xff);
-		cpu_set_input_line(sub_cpu, 0, HOLD_LINE);
+		cpu_set_input_line(state->sub_cpu, 0, HOLD_LINE);
 	}
 }
 
@@ -1069,11 +1080,12 @@
 
 static WRITE8_HANDLER( bgaregga_bankswitch_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int bank = (data & 0x0f) - 10 + 4;
 
-	if (bank != current_bank)
+	if (bank != state->current_bank)
 	{
-		current_bank = bank;
+		state->current_bank = bank;
 		memory_set_bank(space->machine, "bank1", bank);
 	}
 }
@@ -1119,12 +1131,14 @@
 
 static WRITE8_HANDLER( batrider_bankswitch_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int bank = data & 0x0f;
+
 	bank = (bank > 1) ? bank + 2 : bank;
 
-	if (bank != current_bank)
+	if (bank != state->current_bank)
 	{
-		current_bank = bank;
+		state->current_bank = bank;
 		memory_set_bank(space->machine, "bank1", bank);
 	}
 }
@@ -1138,7 +1152,9 @@
        ROM code. Failure to return the correct status incurrs a Sound Error.
     */
 
-	return raizing_Z80_busreq;			/* Loop BUSRQ to BUSAK */
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->z80_busreq;			/* Loop BUSRQ to BUSAK */
 }
 
 
@@ -1146,7 +1162,9 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		raizing_Z80_busreq = (data & 0xff);
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->z80_busreq = (data & 0xff);
 	}
 }
 
@@ -1167,8 +1185,10 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 		soundlatch_w(space, offset, data & 0xff);
-		cpu_set_input_line(sub_cpu, INPUT_LINE_NMI, ASSERT_LINE);
+		cpu_set_input_line(state->sub_cpu, INPUT_LINE_NMI, ASSERT_LINE);
 	}
 }
 
@@ -1177,8 +1197,10 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 		soundlatch2_w(space, offset, data & 0xff);
-		cpu_set_input_line(sub_cpu, INPUT_LINE_NMI, ASSERT_LINE);
+		cpu_set_input_line(state->sub_cpu, INPUT_LINE_NMI, ASSERT_LINE);
 	}
 }
 
@@ -1192,22 +1214,28 @@
 
 static WRITE16_HANDLER( raizing_clear_sndirq_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	// not sure whether this is correct
 	// the 68K writes here during the sound IRQ handler, and nowhere else...
-	cputag_set_input_line(space->machine, "maincpu", raizing_sndirq_line, CLEAR_LINE);
+	cputag_set_input_line(space->machine, "maincpu", state->sndirq_line, CLEAR_LINE);
 }
 
 
 static WRITE8_HANDLER( raizing_sndirq_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	// if raizing_clear_sndirq_w() is correct, should this be ASSERT_LINE?
-	cputag_set_input_line(space->machine, "maincpu", raizing_sndirq_line, HOLD_LINE);
+	cputag_set_input_line(space->machine, "maincpu", state->sndirq_line, HOLD_LINE);
 }
 
 
 static WRITE8_HANDLER( raizing_clear_nmi_w )
 {
-	cpu_set_input_line(sub_cpu, INPUT_LINE_NMI, CLEAR_LINE);
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	cpu_set_input_line(state->sub_cpu, INPUT_LINE_NMI, CLEAR_LINE);
 }
 
 
@@ -1269,6 +1297,7 @@
 
 static READ16_HANDLER( bbakraid_nvram_r )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	eeprom_device *eeprom = space->machine->device<eeprom_device>("eeprom");
 
 	/* Bit 1 returns the status of BUSAK from the Z80.
@@ -1279,7 +1308,7 @@
 
 	int data;
 	data  = ((eeprom_read_bit(eeprom) & 0x01) << 4);
-	data |= ((raizing_Z80_busreq >> 4) & 0x01);	/* Loop BUSRQ to BUSAK */
+	data |= ((state->z80_busreq >> 4) & 0x01);	/* Loop BUSRQ to BUSAK */
 
 	return data;
 }
@@ -1287,13 +1316,15 @@
 
 static WRITE16_HANDLER( bbakraid_nvram_w )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	if (data & ~0x001f)
 		logerror("CPU #0 PC:%06X - Unknown EEPROM data being written %04X\n",cpu_get_pc(space->cpu),data);
 
 	if ( ACCESSING_BITS_0_7 )
 		input_port_write(space->machine, "EEPROMOUT", data, 0xff);
 
-	raizing_Z80_busreq = data & 0x10;	/* see bbakraid_nvram_r above */
+	state->z80_busreq = data & 0x10;	/* see bbakraid_nvram_r above */
 }
 
 
@@ -1341,7 +1372,7 @@
 	AM_RANGE(0x180010, 0x180011) AM_READ_PORT("SYS")
 	AM_RANGE(0x18000c, 0x18000d) AM_READ_PORT("IN1")
 	AM_RANGE(0x18000e, 0x18000f) AM_READ_PORT("IN2")
-	AM_RANGE(0x180500, 0x180fff) AM_READWRITE(ghox_shared_ram_r, ghox_shared_ram_w) AM_BASE(&toaplan2_shared_ram16)
+	AM_RANGE(0x180500, 0x180fff) AM_READWRITE(ghox_shared_ram_r, ghox_shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)
 	AM_RANGE(0x181000, 0x181001) AM_WRITE(toaplan2_coin_word_w)
 	AM_RANGE(0x18100c, 0x18100d) AM_READ_PORT("JMPR")
 ADDRESS_MAP_END
@@ -1355,17 +1386,17 @@
 	AM_RANGE(0x200018, 0x200019) AM_READ_PORT("SYS")
 	AM_RANGE(0x20001c, 0x20001d) AM_WRITE(toaplan2_v25_coin_word_w)
 #ifdef USE_ENCRYPTED_V25S
-//  AM_RANGE(0x21e000, 0x21fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)   /* $21f000 status port */
-//  AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
+	//AM_RANGE(0x21e000, 0x21fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)   /* $21f000 status port */
+	//AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
 	AM_RANGE(0x210000, 0x21efff) AM_READWRITE( batsugun_share2_r, batsugun_share2_w )
 	AM_RANGE(0x21f000, 0x21ffff) AM_READWRITE( batsugun_share_r, batsugun_share_w )
 #else
-	AM_RANGE(0x21e000, 0x21efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)
+	AM_RANGE(0x21e000, 0x21efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)
 	AM_RANGE(0x21f000, 0x21f001) AM_READWRITE(toaplan2_snd_cpu_r, dogyuun_snd_cpu_w)	/* V25+ status/command port */
 	AM_RANGE(0x21f004, 0x21f005) AM_READ_PORT("DSWA")
 	AM_RANGE(0x21f006, 0x21f007) AM_READ_PORT("DSWB")
 	AM_RANGE(0x21f008, 0x21f009) AM_READ_PORT("JMPR")
-	AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
+	AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
 #endif
 	/***** The following locations in 0x30000x are for video controller 1 ******/
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
@@ -1420,12 +1451,12 @@
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
 	AM_RANGE(0x200000, 0x20000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x300000, 0x300fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x400000, 0x401fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x402000, 0x4021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
+	AM_RANGE(0x400000, 0x401fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x402000, 0x4021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
 	AM_RANGE(0x402200, 0x402fff) AM_RAM
-	AM_RANGE(0x403000, 0x4031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x403000, 0x4031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x403200, 0x403fff) AM_RAM
-	AM_RANGE(0x500000, 0x50ffff) AM_READWRITE(toaplan2_tx_gfxram16_r, toaplan2_tx_gfxram16_w) AM_BASE(&toaplan2_tx_gfxram16)
+	AM_RANGE(0x500000, 0x50ffff) AM_READWRITE(toaplan2_tx_gfxram16_r, toaplan2_tx_gfxram16_w) AM_BASE_MEMBER(toaplan2_state, tx_gfxram16)
 	AM_RANGE(0x600000, 0x600001) AM_READ(video_count_r)
 	AM_RANGE(0x700000, 0x700001) AM_READ_PORT("DSWA")
 	AM_RANGE(0x700002, 0x700003) AM_READ_PORT("DSWB")
@@ -1445,7 +1476,7 @@
 	AM_RANGE(0x0c0000, 0x0c0fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x140000, 0x14000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 
-	AM_RANGE(0x190000, 0x190fff) AM_READWRITE(toaplan2_shared_r, toaplan2_shared_w)
+	AM_RANGE(0x190000, 0x190fff) AM_READWRITE(z80_shared_r, z80_shared_w)
 	AM_RANGE(0x19c01c, 0x19c01d) AM_WRITE(toaplan2_coin_word_w)		/* Coin count/lock */
 	AM_RANGE(0x19c020, 0x19c021) AM_READ_PORT("DSWA")
 	AM_RANGE(0x19c024, 0x19c025) AM_READ_PORT("DSWB")
@@ -1463,11 +1494,11 @@
 	AM_RANGE(0x083800, 0x087fff) AM_RAM				/* SpriteRAM (unused) */
 	AM_RANGE(0x0c0000, 0x0c0fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x120000, 0x120fff) AM_RAM				/* Copy of SpriteRAM ? */
-//  AM_RANGE(0x13f000, 0x13f001) AM_WRITENOP        /* ??? */
-	AM_RANGE(0x180000, 0x182fff) AM_DEVREADWRITE("gp9001vdp0", pipibibi_bootleg_videoram16_r, pipibibi_bootleg_videoram16_w )		/* TileRAM */
+	//AM_RANGE(0x13f000, 0x13f001) AM_WRITENOP        /* ??? */
+	AM_RANGE(0x180000, 0x182fff) AM_DEVREADWRITE("gp9001vdp0", pipibibi_bootleg_videoram16_r, pipibibi_bootleg_videoram16_w)		/* TileRAM */
 	AM_RANGE(0x188000, 0x18800f) AM_DEVWRITE("gp9001vdp0", pipibibi_bootleg_scroll_w)
-	AM_RANGE(0x190002, 0x190003) AM_READ(pipibibi_z80_status_r)	/* Z80 ready ? */
-	AM_RANGE(0x190010, 0x190011) AM_WRITE(pipibibi_z80_task_w)	/* Z80 task to perform */
+	AM_RANGE(0x190002, 0x190003) AM_READ(z80_shared_r)	/* Z80 ready ? */
+	AM_RANGE(0x190010, 0x190011) AM_WRITE(z80_shared_w)	/* Z80 task to perform */
 	AM_RANGE(0x19c01c, 0x19c01d) AM_WRITE(toaplan2_coin_word_w)	/* Coin count/lock */
 	AM_RANGE(0x19c020, 0x19c021) AM_READ_PORT("DSWA")
 	AM_RANGE(0x19c024, 0x19c025) AM_READ_PORT("DSWB")
@@ -1496,28 +1527,28 @@
 	AM_RANGE(0x200010, 0x200011) AM_READ_PORT("SYS")
 	AM_RANGE(0x20001c, 0x20001d) AM_WRITE(toaplan2_coin_word_w)	/* Coin count/lock */
 #ifdef USE_ENCRYPTED_V25S
-//  AM_RANGE(0x28e000, 0x28fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)   /* $28f000 status port */
-//  AM_RANGE(0x28fc00, 0x28ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
+	//AM_RANGE(0x28e000, 0x28fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)   /* $28f000 status port */
+	//AM_RANGE(0x28fc00, 0x28ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
 	AM_RANGE(0x280000, 0x28efff) AM_READWRITE( batsugun_share2_r, batsugun_share2_w )
 	AM_RANGE(0x28f000, 0x28ffff) AM_READWRITE( batsugun_share_r, batsugun_share_w )
 	AM_RANGE(0x700000, 0x700001) AM_WRITE(fixeight_subcpu_ctrl) // guess!!!
 #else
 	AM_RANGE(0x280000, 0x28dfff) AM_RAM							/* part of shared ram ? */
-	AM_RANGE(0x28e000, 0x28efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)
-	AM_RANGE(0x28f000, 0x28f001) AM_READWRITE(fixeight_sec_cpu_r, fixeight_sec_cpu_w) AM_BASE(&fixeight_sec_cpu_mem)	/* V25+ Command/Status port */
-//  AM_RANGE(0x28f002, 0x28f003) AM_READONLY             /* part of shared ram */
-//  AM_RANGE(0x28f004, 0x28f005) AM_READ_PORT("DSWA") /* Dip Switch A - Wrong !!! */
-//  AM_RANGE(0x28f006, 0x28f007) AM_READ_PORT("DSWB") /* Dip Switch B - Wrong !!! */
-//  AM_RANGE(0x28f008, 0x28f009) AM_READ_PORT("JMPR") /* Territory Jumper block - Wrong !!! */
-//  AM_RANGE(0x28f00a, 0x28fbff) AM_READONLY             /* part of shared ram */
-	AM_RANGE(0x28fc00, 0x28ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
+	AM_RANGE(0x28e000, 0x28efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)
+	AM_RANGE(0x28f000, 0x28f001) AM_READWRITE(fixeight_sec_cpu_r, fixeight_sec_cpu_w)	/* V25+ Command/Status port */
+	//AM_RANGE(0x28f002, 0x28f003) AM_READONLY             /* part of shared ram */
+	//AM_RANGE(0x28f004, 0x28f005) AM_READ_PORT("DSWA") /* Dip Switch A - Wrong !!! */
+	//AM_RANGE(0x28f006, 0x28f007) AM_READ_PORT("DSWB") /* Dip Switch B - Wrong !!! */
+	//AM_RANGE(0x28f008, 0x28f009) AM_READ_PORT("JMPR") /* Territory Jumper block - Wrong !!! */
+	//AM_RANGE(0x28f00a, 0x28fbff) AM_READONLY             /* part of shared ram */
+	AM_RANGE(0x28fc00, 0x28ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
 #endif
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
-	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
-	AM_RANGE(0x600000, 0x60ffff) AM_READWRITE(toaplan2_tx_gfxram16_r, toaplan2_tx_gfxram16_w) AM_BASE(&toaplan2_tx_gfxram16)
+	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
+	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
+	AM_RANGE(0x600000, 0x60ffff) AM_READWRITE(toaplan2_tx_gfxram16_r, toaplan2_tx_gfxram16_w) AM_BASE_MEMBER(toaplan2_state, tx_gfxram16)
 	AM_RANGE(0x800000, 0x800001) AM_READ(video_count_r)
 ADDRESS_MAP_END
 
@@ -1535,9 +1566,9 @@
 	AM_RANGE(0x20001c, 0x20001d) AM_READ_PORT("DSWA")
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
-	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
+	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x700000, 0x700001) AM_READ(video_count_r)
 	AM_RANGE(0x800000, 0x87ffff) AM_ROMBANK("bank1")
 ADDRESS_MAP_END
@@ -1552,17 +1583,17 @@
 	AM_RANGE(0x200018, 0x200019) AM_READ_PORT("SYS")
 	AM_RANGE(0x20001c, 0x20001d) AM_WRITE(toaplan2_v25_coin_word_w)	/* Coin count/lock */
 #ifdef USE_ENCRYPTED_V25S
-//  AM_RANGE(0x21e000, 0x21fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)   /* $21f000 status port */
-//  AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
+	//AM_RANGE(0x21e000, 0x21fbff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)   /* $21f000 status port */
+	//AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)    /* 16-bit on 68000 side, 8-bit on V25+ side */
 	AM_RANGE(0x210000, 0x21efff) AM_READWRITE( batsugun_share2_r, batsugun_share2_w )
 	AM_RANGE(0x21f000, 0x21ffff) AM_READWRITE( batsugun_share_r, batsugun_share_w )
 #else
-	AM_RANGE(0x21e000, 0x21efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE(&toaplan2_shared_ram16)
+	AM_RANGE(0x21e000, 0x21efff) AM_READWRITE(shared_ram_r, shared_ram_w) AM_BASE_MEMBER(toaplan2_state, shared_ram16)
 	AM_RANGE(0x21f000, 0x21f001) AM_READWRITE(toaplan2_snd_cpu_r, vfive_snd_cpu_w)	/* V25+ Command/Status port */
 	AM_RANGE(0x21f004, 0x21f005) AM_READ_PORT("DSWA")
 	AM_RANGE(0x21f006, 0x21f007) AM_READ_PORT("DSWB")
 	AM_RANGE(0x21f008, 0x21f009) AM_READ_PORT("JMPR")
-	AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE(&V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
+	AM_RANGE(0x21fc00, 0x21ffff) AM_READWRITE(V25_sharedram_r, V25_sharedram_w) AM_BASE_MEMBER(toaplan2_state, V25_shared_ram)	/* 16-bit on 68000 side, 8-bit on V25+ side */
 #endif
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
@@ -1570,28 +1601,29 @@
 ADDRESS_MAP_END
 
 
-static UINT8* batsugun_share;
-#ifdef USE_ENCRYPTED_V25S
-static UINT8* batsugun_share2;
-#endif
-
 static READ16_HANDLER( batsugun_share_r )
 {
-	return batsugun_share[offset] | batsugun_share[offset]<<8;
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 
+	return state->batsugun_share[offset] | state->batsugun_share[offset]<<8;
 }
 
 static WRITE16_HANDLER( batsugun_share_w )
 {
-	/*
-    if (ACCESSING_BITS_8_15)
-    {
-        batsugun_share[offset] = data >> 8;
-    }
-    */
+#if 0
+	if (ACCESSING_BITS_8_15)
+	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->batsugun_share[offset] = data >> 8;
+	}
+#endif
+
 	if (ACCESSING_BITS_0_7)
 	{
-		batsugun_share[offset] = data;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->batsugun_share[offset] = data;
 	}
 }
 
@@ -1599,21 +1631,27 @@
 /* To be removed... */
 static READ16_HANDLER( batsugun_share2_r )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	return batsugun_share2[offset] | batsugun_share2[offset]<<8;
 }
 
 static WRITE16_HANDLER( batsugun_share2_w )
 {
-	/*
-    if (ACCESSING_BITS_8_15)
-    {
-        batsugun_share2[offset] = data >> 8;
-    }
-    */
+#if 0
+	if (ACCESSING_BITS_8_15)
+	{
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->batsugun_share2[offset] = data >> 8;
+	}
+#endif
 
 	if (ACCESSING_BITS_0_7)
 	{
-		batsugun_share2[offset] = data;
+		toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+		state->batsugun_share2[offset] = data;
 	}
 }
 #endif
@@ -1668,7 +1706,7 @@
 static ADDRESS_MAP_START( mahoudai_68k_mem, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x07ffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
-	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(raizing_shared_ram_r, raizing_shared_ram_w)
+	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(z80_shared_r, z80_shared_w)
 	AM_RANGE(0x21c01c, 0x21c01d) AM_WRITE(toaplan2_coin_word_w)
 	AM_RANGE(0x21c020, 0x21c021) AM_READ_PORT("IN1")
 	AM_RANGE(0x21c024, 0x21c025) AM_READ_PORT("IN2")
@@ -1680,10 +1718,10 @@
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x401000, 0x4017ff) AM_RAM							/* Unused PaletteRAM */
-	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
+	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
 	AM_RANGE(0x502200, 0x502fff) AM_RAM
-	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x503200, 0x503fff) AM_RAM
 ADDRESS_MAP_END
 
@@ -1691,7 +1729,7 @@
 static ADDRESS_MAP_START( shippumd_68k_mem, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
-	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(raizing_shared_ram_r, raizing_shared_ram_w)
+	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(z80_shared_r, z80_shared_w)
 //  AM_RANGE(0x21c008, 0x21c009) AM_WRITENOP                    /* ??? */
 	AM_RANGE(0x21c01c, 0x21c01d) AM_WRITE(shippumd_coin_word_w)
 	AM_RANGE(0x21c020, 0x21c021) AM_READ_PORT("IN1")
@@ -1704,10 +1742,10 @@
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
 	AM_RANGE(0x401000, 0x4017ff) AM_RAM							/* Unused PaletteRAM */
-	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
+	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
 	AM_RANGE(0x502200, 0x502fff) AM_RAM
-	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x503200, 0x503fff) AM_RAM
 ADDRESS_MAP_END
 
@@ -1715,7 +1753,7 @@
 static ADDRESS_MAP_START( bgaregga_68k_mem, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x0fffff) AM_ROM
 	AM_RANGE(0x100000, 0x10ffff) AM_RAM
-	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(raizing_shared_ram_r, raizing_shared_ram_w)
+	AM_RANGE(0x218000, 0x21bfff) AM_READWRITE(z80_shared_r, z80_shared_w)
 	AM_RANGE(0x21c01c, 0x21c01d) AM_WRITE(toaplan2_coin_word_w)
 	AM_RANGE(0x21c020, 0x21c021) AM_READ_PORT("IN1")
 	AM_RANGE(0x21c024, 0x21c025) AM_READ_PORT("IN2")
@@ -1726,10 +1764,10 @@
 	AM_RANGE(0x21c03c, 0x21c03d) AM_READ(video_count_r)
 	AM_RANGE(0x300000, 0x30000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_r, gp9001_vdp_w)
 	AM_RANGE(0x400000, 0x400fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram)
-	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)
-	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
+	AM_RANGE(0x500000, 0x501fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)
+	AM_RANGE(0x502000, 0x5021ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
 	AM_RANGE(0x502200, 0x502fff) AM_RAM
-	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x503000, 0x5031ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x503200, 0x503fff) AM_RAM
 	AM_RANGE(0x600000, 0x600001) AM_WRITE(bgaregga_soundlatch_w)
 ADDRESS_MAP_END
@@ -1737,11 +1775,11 @@
 
 static ADDRESS_MAP_START( batrider_68k_mem, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x1fffff) AM_ROM
-	AM_RANGE(0x200000, 0x201fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)	/* Text VideoRAM */
-	AM_RANGE(0x202000, 0x202fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram) AM_SIZE(&batrider_paletteram16_size)
-	AM_RANGE(0x203000, 0x2031ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
-	AM_RANGE(0x203200, 0x2033ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
-	AM_RANGE(0x203400, 0x207fff) AM_READWRITE(raizing_tx_gfxram16_r, raizing_tx_gfxram16_w)	/* Main RAM actually */
+	AM_RANGE(0x200000, 0x201fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)	/* Text VideoRAM */
+	AM_RANGE(0x202000, 0x202fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram) AM_SIZE_MEMBER(toaplan2_state, paletteram16_size)
+	AM_RANGE(0x203000, 0x2031ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
+	AM_RANGE(0x203200, 0x2033ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
+	AM_RANGE(0x203400, 0x207fff) AM_READWRITE(raizing_tx_gfxram16_r, raizing_tx_gfxram16_w) /* Main RAM actually */
 	AM_RANGE(0x208000, 0x20ffff) AM_RAM
 	AM_RANGE(0x300000, 0x37ffff) AM_READ(raizing_z80rom_r)
 	AM_RANGE(0x400000, 0x40000d) AM_DEVREADWRITE("gp9001vdp0", gp9001_vdp_alt_r, gp9001_vdp_alt_w)
@@ -1765,10 +1803,10 @@
 
 static ADDRESS_MAP_START( bbakraid_68k_mem, ADDRESS_SPACE_PROGRAM, 16 )
 	AM_RANGE(0x000000, 0x1fffff) AM_ROM
-	AM_RANGE(0x200000, 0x201fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE(&toaplan2_txvideoram16) AM_SIZE(&toaplan2_tx_vram_size)	/* Text VideoRAM */
-	AM_RANGE(0x202000, 0x202fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram) AM_SIZE(&batrider_paletteram16_size)
-	AM_RANGE(0x203000, 0x2031ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE(&toaplan2_txvideoram16_offs) AM_SIZE(&toaplan2_tx_offs_vram_size)
-	AM_RANGE(0x203200, 0x2033ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE(&toaplan2_txscrollram16) AM_SIZE(&toaplan2_tx_scroll_vram_size)
+	AM_RANGE(0x200000, 0x201fff) AM_READWRITE(toaplan2_txvideoram16_r, toaplan2_txvideoram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16, tx_vram_size)	/* Text VideoRAM */
+	AM_RANGE(0x202000, 0x202fff) AM_RAM_WRITE(paletteram16_xBBBBBGGGGGRRRRR_word_w) AM_BASE_GENERIC(paletteram) AM_SIZE_MEMBER(toaplan2_state, paletteram16_size)
+	AM_RANGE(0x203000, 0x2031ff) AM_READWRITE(toaplan2_txvideoram16_offs_r, toaplan2_txvideoram16_offs_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txvideoram16_offs, tx_offs_vram_size)
+	AM_RANGE(0x203200, 0x2033ff) AM_READWRITE(toaplan2_txscrollram16_r, toaplan2_txscrollram16_w) AM_BASE_SIZE_MEMBER(toaplan2_state, txscrollram16, tx_scroll_vram_size)
 	AM_RANGE(0x203400, 0x207fff) AM_READWRITE(raizing_tx_gfxram16_r, raizing_tx_gfxram16_w)	/* Main RAM actually */
 	AM_RANGE(0x208000, 0x20ffff) AM_RAM
 	AM_RANGE(0x300000, 0x33ffff) AM_READ(raizing_z80rom_r)
@@ -1792,16 +1830,16 @@
 
 
 
-static ADDRESS_MAP_START( sound_z80_mem, ADDRESS_SPACE_PROGRAM, 8 )
+static ADDRESS_MAP_START( pipibibs_sound_z80_mem, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
-	AM_RANGE(0x8000, 0x87ff) AM_RAM AM_BASE(&toaplan2_shared_ram)
+	AM_RANGE(0x8000, 0x87ff) AM_RAM AM_BASE_MEMBER(toaplan2_state, z80_shared_ram)
 	AM_RANGE(0xe000, 0xe001) AM_DEVREADWRITE("ymsnd", ym3812_r, ym3812_w)
 ADDRESS_MAP_END
 
 
 static ADDRESS_MAP_START( raizing_sound_z80_mem, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0xbfff) AM_ROM
-	AM_RANGE(0xc000, 0xdfff) AM_RAM AM_BASE(&raizing_shared_ram)
+	AM_RANGE(0xc000, 0xdfff) AM_RAM AM_BASE_MEMBER(toaplan2_state, z80_shared_ram)
 	AM_RANGE(0xe000, 0xe001) AM_DEVREADWRITE("ymsnd", ym2151_r, ym2151_w)
 	AM_RANGE(0xe004, 0xe004) AM_DEVREADWRITE("oki", okim6295_r, okim6295_w)
 	AM_RANGE(0xe00e, 0xe00e) AM_WRITE(toaplan2_coin_w)
@@ -1811,7 +1849,7 @@
 static ADDRESS_MAP_START( bgaregga_sound_z80_mem, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	AM_RANGE(0x8000, 0xbfff) AM_ROMBANK("bank1")
-	AM_RANGE(0xc000, 0xdfff) AM_RAM AM_BASE(&raizing_shared_ram)
+	AM_RANGE(0xc000, 0xdfff) AM_RAM AM_BASE_MEMBER(toaplan2_state, z80_shared_ram)
 	AM_RANGE(0xe000, 0xe001) AM_DEVREADWRITE("ymsnd", ym2151_r, ym2151_w)
 	AM_RANGE(0xe004, 0xe004) AM_DEVREADWRITE("oki", okim6295_r, okim6295_w)
 	AM_RANGE(0xe006, 0xe006) AM_WRITE(raizing_okim6295_bankselect_0)
@@ -2325,7 +2363,7 @@
 
 static ADDRESS_MAP_START( V25_rambased_mem, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x00000, 0x00001) AM_DEVREADWRITE("ymsnd", ym2151_r, ym2151_w)
-	AM_RANGE(0x00000, 0x07fff) AM_RAM AM_SHARE("share6") AM_BASE(&batsugun_share)
+	AM_RANGE(0x00000, 0x07fff) AM_RAM AM_SHARE("share6") AM_BASE_MEMBER(toaplan2_state, batsugun_share)
 
 //  AM_RANGE(0x40000, 0x477ff) AM_RAM AM_SHARE("share7")
 	AM_RANGE(0x40e00, 0x40eff) AM_RAM //internal V25 RAM
@@ -3711,8 +3749,10 @@
 
 static void irqhandler(running_device *device, int linestate)
 {
-	if (sub_cpu != NULL)		// wouldn't tekipaki have problem without this? "mcu" is not generally added
-		cpu_set_input_line(sub_cpu, 0, linestate);
+	toaplan2_state *state = device->machine->driver_data<toaplan2_state>();
+
+	if (state->sub_cpu != NULL)		// wouldn't tekipaki have problem without this? "mcu" is not generally added
+		cpu_set_input_line(state->sub_cpu, 0, linestate);
 }
 
 static const ym3812_interface ym3812_config =
@@ -3936,7 +3976,9 @@
 static MACHINE_RESET(kbash)
 {
 #ifndef USE_ENCRYPTED_V25S
-	cpu_set_input_line(sub_cpu, INPUT_LINE_HALT, ASSERT_LINE);
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	cpu_set_input_line(state->sub_cpu, INPUT_LINE_HALT, ASSERT_LINE);
 #endif
 }
 
@@ -4082,8 +4124,8 @@
 	MDRV_CPU_PROGRAM_MAP(pipibibs_68k_mem)
 	MDRV_CPU_VBLANK_INT("screen", toaplan2_vblank_irq4)
 
-	MDRV_CPU_ADD("audiocpu", Z80,XTAL_27MHz/8)			/* verified on pcb */
-	MDRV_CPU_PROGRAM_MAP(sound_z80_mem)
+	MDRV_CPU_ADD("audiocpu", Z80, XTAL_27MHz/8)			/* verified on pcb */
+	MDRV_CPU_PROGRAM_MAP(pipibibs_sound_z80_mem)
 
 	MDRV_QUANTUM_TIME(HZ(600))
 
@@ -4171,7 +4213,7 @@
 	MDRV_CPU_VBLANK_INT("screen", toaplan2_vblank_irq4)
 
 	MDRV_CPU_ADD("audiocpu", Z80, XTAL_27MHz/8)			/* ??? 3.37MHz */
-	MDRV_CPU_PROGRAM_MAP(sound_z80_mem)
+	MDRV_CPU_PROGRAM_MAP(pipibibs_sound_z80_mem)
 
 	MDRV_QUANTUM_TIME(HZ(600))
 
@@ -4305,7 +4347,7 @@
 
 	MDRV_DEVICE_ADD_VDP0
 
-	MDRV_VIDEO_START(truxton2)
+	MDRV_VIDEO_START(fixeighb)
 	MDRV_VIDEO_EOF(toaplan2)
 	MDRV_VIDEO_UPDATE(truxton2)
 
@@ -4391,7 +4433,9 @@
 
 static MACHINE_RESET(batsugun)
 {
-	cpu_set_input_line(sub_cpu, INPUT_LINE_HALT, ASSERT_LINE);
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	cpu_set_input_line(state->sub_cpu, INPUT_LINE_HALT, ASSERT_LINE);
 }
 
 
@@ -5860,8 +5904,8 @@
 GAME( 1991, ghox,     0,        ghox,     ghox,     T2_Z180,  ROT270, "Toaplan", "Ghox (Spinner with Up/Down Axis)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1991, ghoxj,    ghox,     ghox,     ghox,     T2_Z180,  ROT270, "Toaplan", "Ghox (8-Way Joystick)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
 
-GAME( 1992, dogyuun,  0,        dogyuun,  dogyuun,  T2_V25,   ROT270, "Toaplan", "Dogyuun", GAME_NO_SOUND | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING )
-GAME( 1992, dogyuunk, dogyuun,  dogyuun,  dogyuunk, T2_V25,   ROT270, "Toaplan", "Dogyuun (Unite Trading license)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING )
+GAME( 1992, dogyuun,  0,        dogyuun,  dogyuun,  T2_V25,   ROT270, "Toaplan", "Dogyuun", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
+GAME( 1992, dogyuunk, dogyuun,  dogyuun,  dogyuunk, T2_V25,   ROT270, "Toaplan", "Dogyuun (Unite Trading license)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
 
 GAME( 1993, kbash,    0,        kbash,    kbash,    T2_V25,   ROT0,   "Toaplan", "Knuckle Bash", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
 
@@ -5881,9 +5925,9 @@
 GAME( 1992, grindstma,vfive,    vfive,    grindstm, T2_V25,   ROT270, "Toaplan", "Grind Stormer (older set)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
 GAME( 1993, vfive,    0,        vfive,    vfive,    T2_V25,   ROT270, "Toaplan", "V-Five (Japan)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE )
 
-GAME( 1993, batsugun,  0,        batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (set 1)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING ) // dual vdp mixing is broken ATM
-GAME( 1993, batsuguna, batsugun, batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (set 2)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING ) // dual vdp mixing is broken ATM
-GAME( 1993, batsugunsp,batsugun, batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (Special Ver.)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE | GAME_NOT_WORKING ) // dual vdp mixing is broken ATM
+GAME( 1993, batsugun,  0,        batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (set 1)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1993, batsuguna, batsugun, batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (set 2)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
+GAME( 1993, batsugunsp,batsugun, batsugun, batsugun, T2_V25,   ROT270, "Toaplan", "Batsugun (Special Ver.)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_SUPPORTS_SAVE )
 
 GAME( 1994, snowbro2, 0,        snowbro2, snowbro2, T2_noZ80, ROT0,   "Hanafram", "Snow Bros. 2 - With New Elves / Otenki Paradise", GAME_SUPPORTS_SAVE )
 
diff -Nru src-old/mame/drivers/toki.c src/mame/drivers/toki.c
--- src-old/mame/drivers/toki.c	2010-06-08 12:55:22.000000000 -0700
+++ src/mame/drivers/toki.c	2010-08-19 07:19:38.000000000 -0700
@@ -834,14 +834,14 @@
 
 	/* Decrypt data for z80 program */
 	{
-		const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 		UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x20000);
 		UINT8 *rom = memory_region(machine, "audiocpu");
 		int i;
 
 		memcpy(decrypt,rom,0x20000);
 
-		memory_set_decrypted_region(space, 0x0000, 0x1fff, decrypt);
+		space->set_decrypted_region(0x0000, 0x1fff, decrypt);
 
 		for (i = 0;i < 0x2000;i++)
 		{
diff -Nru src-old/mame/drivers/tomcat.c src/mame/drivers/tomcat.c
--- src-old/mame/drivers/tomcat.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/drivers/tomcat.c	2010-08-13 01:54:21.000000000 -0700
@@ -257,7 +257,7 @@
 	AM_RANGE(0x40e01a, 0x40e01b) AM_WRITE(tomcat_errh_w)
 	AM_RANGE(0x40e01c, 0x40e01d) AM_WRITE(tomcat_ackh_w)
 	AM_RANGE(0x40e01e, 0x40e01f) AM_WRITE(tomcat_txbuffh_w)
-	AM_RANGE(0x800000, 0x803fff) AM_RAM AM_BASE((UINT16**)&vectorram) AM_SIZE(&vectorram_size)
+	AM_RANGE(0x800000, 0x803fff) AM_RAM AM_BASE((UINT16**)&avgdvg_vectorram) AM_SIZE(&avgdvg_vectorram_size)
 	AM_RANGE(0xffa000, 0xffbfff) AM_READWRITE(tomcat_shared_ram_r, tomcat_shared_ram_w)
 	AM_RANGE(0xffc000, 0xffcfff) AM_RAM
 	AM_RANGE(0xffd000, 0xffdfff) AM_DEVREADWRITE8("m48t02", timekeeper_r, timekeeper_w, 0xff00)
diff -Nru src-old/mame/drivers/topshoot.c src/mame/drivers/topshoot.c
--- src-old/mame/drivers/topshoot.c	2010-07-21 22:24:06.000000000 -0700
+++ src/mame/drivers/topshoot.c	1969-12-31 16:00:00.000000000 -0800
@@ -1,174 +0,0 @@
-/*
-
- Sun Mixing board, looks like a hacked up Genesis clone.
-
- Driver by David Haywood
- Inputs by Mariusz Wojcieszek
-
- Top Shooter - (c)1995  - older board, look more like an actual hacked cart system, has an MCU
-
- Not Dumped
-
- Super Bubble Bobble (a bubble bobble rip-off from Sun Mixing, looks like it may be on this hardware)
-
- */
-
-/*
-
-TOP SHOOTER - Sun Mixing Co. Ltd. 1995
-
-To me it seems like an original cartridge-based arcade board
-hacked to use an external ROM board and a standard JAMMA
-connector, but of course, I can be wrong.
-
-
-   UPPER BOARD
-
-   _________________________________________________________
-   |            ___________  ___________  _____      __    |
-   | 74LS245P  |U14 Empty | |U12 ROM1  |  |IC1|      |B|   |
-   | 74LS245P  |__________| |__________|  |___|            |
-   | 74LS245P   ___________  ___________    _____________  |
- __|           |U13 Empty | |U11 ROM2  |   | AT89C51    |  |
- |_ J          |__________| |__________|   |____________|  |_
- |_ A           ______________________              _____  |_ J
- |_ M          | U10 MC68000P10       |             |OSC|  |_ P
- |_ M          | Motorola             |                    |_ 2
- |_ A          |______________________|            74HC00P |_
- |_  74LS245P   ______________________           ________  |
- |_            | U9 Empty             |          |HM6116L  |
- |_            |                      |          |_______| |_ J
- |_            |______________________|                    |_ P
- |_  74LS245P                           TD62oo3AP 74LS373P |_ 3
- |_                                            __________  |
- |_  74LS245P                                  |GALv20V8B| |
- |_                                    ______              |
- |_               _____                |DIPS|              |_ P
-   |             |U24  |                                   |_ 1
-   | 74LS245P                                              |
-   | TD62oo3AP                                             |
-   |                                                       |
-   |_            97              ____________         _____|
-     |_|_|_|_|_|_|_|_|_|_|_|_|_|_|           |_|_|_|_|
-
-
-  IC1 = Surface scracthed out, don't know what is it
-  U24 = Surface scratched out, seems like a PROM
- DIPS = Fixed as: 00001000
- ROMS = Toshiba TC574000AD
-
-  JP2, JP3 and P1 connects both boards, also another
-  on-board connector is used, see notes for the 68K socket
-  for the lower board.
-
-
-   LOWER BOARD
-
-   _________________________________________________________
-   |                                     ____ ____         |
-   |  ___                                | I| | I|         |
-   |  |I|                                | C| | C|         |
-   |  |C|                                | 3| | 2|         |
-   |  |1|                                |__| |__|         |
-   |  |3|                                                  |__
-   |   _                _________________________           __|
-   |  |_|               |||||||||||||||||||||||||           __|
-   |  IC14              ---------- SLOT ---------           __|
-   |               ______________________                   __|
-   |              |                      |                  __|
-   |  ___         | 68K (to upper board) |   _______        __|
-   |  |I|         |______________________|   |SE-94|        __|
-   |  |C|                                    |JDDB |      _|
-   |  |1|           _______                  |_____|      |
-   |  |2|           |SE-93|                    IC4        |
-   |                |JDDA |                               |
-   |                |_____|                ___________    |_
-   |                  IC8                  |Z8400A PS|     |
-   |                                       |_________|     |
-   |                  ______         _________  _________  |
-   |                  | OSC|         | IC11  |  | IC7   |  |
-   |            _____________        |_______|  |_______|  |
-   |    RST    |            |           CN5        CN6     |
-   |___________|            |______________________________|
-
-
-   IC3 = IC2 = Winbond W24257V
-   IC7  = 6264LD 9440
-   IC11 = SE-95 JDDC
-   IC12 = Sony CXA1634P
-   IC13 = Sony CXA1145P
-   IC14 = GL358 N16
-
-   RST is a reset button.
-
-   OSC = 53.693175 MHz
-
-   CN5 and CN6 are 9-pin connectors... serial ports?
-
-   There are two wires soldered directly to two connectors
-   of the slot, going to the upper board (via P1).
-
-   The whole upper board is plugged using the 68000 socket,
-   there is no 68K on the lower board.
-
-   There is an edge connector, but it isn't JAMMA.
-
-   "HK-986 (KINYO)" is written on the PCB, near the slot.
-
-*/
-
-#include "emu.h"
-#include "includes/megadriv.h"
-
-static INPUT_PORTS_START( topshoot ) /* Top Shooter Input Ports */
-	PORT_START("IN0")
-	PORT_BIT( 0x4f, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON2 ) PORT_NAME("Bet") PORT_IMPULSE(1)
-	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_BUTTON3 ) PORT_NAME("Start") PORT_IMPULSE(1)
-	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_BUTTON1 ) PORT_NAME("Fire") PORT_IMPULSE(1)
-
-	PORT_START("IN1")
-	PORT_BIT( 0xe7, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_SERVICE_NO_TOGGLE( 0x08, IP_ACTIVE_LOW )
-	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_BUTTON4 ) PORT_NAME("Test mode down") PORT_IMPULSE(1)
-
-	PORT_START("IN2")
-	PORT_BIT( 0xfd, IP_ACTIVE_LOW, IPT_UNKNOWN )
-	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN1 ) PORT_IMPULSE(1)
-
-	PORT_START("IN3")
-	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN2 ) PORT_IMPULSE(1)
-	PORT_BIT( 0xfe, IP_ACTIVE_LOW, IPT_UNKNOWN )
-
-INPUT_PORTS_END
-
-
-ROM_START( topshoot ) /* Top Shooter (c)1995 Sun Mixing */
-	ROM_REGION( 0x200000, "maincpu", 0 )
-	ROM_LOAD16_BYTE( "tc574000ad_u11_2.bin", 0x000000, 0x080000, CRC(b235c4d9) SHA1(fbb308a5f6e769f3277824cb6a3b50c308969ac2) )
-	ROM_LOAD16_BYTE( "tc574000ad_u12_1.bin", 0x000001, 0x080000, CRC(e826f6ad) SHA1(23ec8bb608f954d3b915f061e7076c0c63b8259e) )
-
-	// not hooked up yet
-	ROM_REGION( 0x1000, "mcu", 0 )
-	ROM_LOAD( "89c51.bin", 0x0000, 0x1000, CRC(595475c8) SHA1(8313819ba06cc92b54f88c1ca9f34be8d1ec94d0) )
-ROM_END
-
-static READ16_HANDLER(topshoot_200051_r)
-{
-	return -0x5b;
-}
-
-static DRIVER_INIT(topshoot)
-{
-	memory_install_read16_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200050, 0x200051, 0, 0, topshoot_200051_r );
-	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200042, 0x200043, 0, 0, "IN0");
-	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200044, 0x200045, 0, 0, "IN1");
-	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200046, 0x200047, 0, 0, "IN2");
-	memory_install_read_port(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), 0x200048, 0x200049, 0, 0, "IN3");
-
-	DRIVER_INIT_CALL(megadriv);
-}
-
-
-/* Sun Mixing Hardware, very close to actual Genesis */
-GAME( 1995, topshoot,  0,        md_bootleg, topshoot, topshoot, ROT0, "Sun Mixing", "Top Shooter", 0 )
diff -Nru src-old/mame/drivers/trackfld.c src/mame/drivers/trackfld.c
--- src-old/mame/drivers/trackfld.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/trackfld.c	2010-08-30 08:20:58.000000000 -0700
@@ -188,7 +188,7 @@
 #include "sound/dac.h"
 #include "sound/msm5205.h"
 #include "includes/trackfld.h"
-
+#include "includes/konamipt.h"
 
 #define MASTER_CLOCK          XTAL_18_432MHz
 #define SOUND_CLOCK           XTAL_14_31818MHz
@@ -290,6 +290,35 @@
 	AM_RANGE(0x6000, 0xffff) AM_ROM
 ADDRESS_MAP_END
 
+
+static ADDRESS_MAP_START( yieartf_map, ADDRESS_SPACE_PROGRAM, 8 )
+	AM_RANGE(0x1000, 0x1000) AM_MIRROR(0x007f) AM_WRITE(watchdog_reset_w)		/* AFE */
+	AM_RANGE(0x1080, 0x1080) AM_MIRROR(0x0078) AM_WRITE(trackfld_flipscreen_w)	/* FLIP */
+	AM_RANGE(0x1081, 0x1081) AM_MIRROR(0x0078) AM_WRITE(konami_sh_irqtrigger_w)	/* 26 */ /* cause interrupt on audio CPU */
+	AM_RANGE(0x1082, 0x1082) AM_MIRROR(0x0078) AM_WRITENOP						/* 25 */
+	AM_RANGE(0x1083, 0x1084) AM_MIRROR(0x0078) AM_WRITE(coin_w)					/* 24, 23 */
+	AM_RANGE(0x1085, 0x1085) AM_MIRROR(0x0078) AM_WRITENOP						/* CN3.2 */
+	AM_RANGE(0x1086, 0x1086) AM_MIRROR(0x0078) AM_WRITENOP						/* CN3.4 */
+	AM_RANGE(0x1087, 0x1087) AM_MIRROR(0x0078) AM_WRITE(interrupt_enable_w)		/* INT */
+//  AM_RANGE(0x1100, 0x1100) AM_MIRROR(0x007f) AM_WRITE(soundlatch_w)           /* 32 */
+	AM_RANGE(0x1200, 0x1200) AM_MIRROR(0x007f) AM_READ_PORT("DSW2")
+	AM_RANGE(0x1280, 0x1280) AM_MIRROR(0x007c) AM_READ_PORT("SYSTEM")
+	AM_RANGE(0x1281, 0x1281) AM_MIRROR(0x007c) AM_READ_PORT("IN0")
+	AM_RANGE(0x1282, 0x1282) AM_MIRROR(0x007c) AM_READ_PORT("IN1")
+	AM_RANGE(0x1283, 0x1283) AM_MIRROR(0x007c) AM_READ_PORT("DSW1")
+	AM_RANGE(0x1300, 0x1300) AM_MIRROR(0x007f) AM_READ_PORT("DSW3")
+	AM_RANGE(0x1800, 0x183f) AM_RAM AM_BASE_MEMBER(trackfld_state, spriteram2)
+	AM_RANGE(0x1840, 0x185f) AM_RAM AM_BASE_MEMBER(trackfld_state, scroll)
+	AM_RANGE(0x1860, 0x1bff) AM_RAM
+	AM_RANGE(0x1c00, 0x1c3f) AM_RAM AM_BASE_SIZE_MEMBER(trackfld_state, spriteram, spriteram_size)
+	AM_RANGE(0x1c40, 0x1c5f) AM_RAM AM_BASE_MEMBER(trackfld_state, scroll2)
+	AM_RANGE(0x1c60, 0x1fff) AM_RAM
+	AM_RANGE(0x2800, 0x2fff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
+	AM_RANGE(0x3000, 0x37ff) AM_RAM_WRITE(trackfld_videoram_w) AM_BASE_MEMBER(trackfld_state, videoram)
+	AM_RANGE(0x3800, 0x3fff) AM_RAM_WRITE(trackfld_colorram_w) AM_BASE_MEMBER(trackfld_state, colorram)
+	AM_RANGE(0x6000, 0xffff) AM_ROM
+ADDRESS_MAP_END
+
 static ADDRESS_MAP_START( reaktor_map, ADDRESS_SPACE_PROGRAM, 8 )
 	AM_RANGE(0x0000, 0x7fff) AM_ROM
 	/* all usual addresses +0x8000 */
@@ -809,6 +838,62 @@
 	PORT_DIPSETTING(      0x00, DEF_STR( On ) )
 INPUT_PORTS_END
 
+
+static INPUT_PORTS_START( yieartf )
+	PORT_START("SYSTEM")
+	PORT_BIT( 0x01, IP_ACTIVE_LOW, IPT_COIN1 )
+	PORT_BIT( 0x02, IP_ACTIVE_LOW, IPT_COIN2 )
+	PORT_BIT( 0x04, IP_ACTIVE_LOW, IPT_SERVICE1 )
+	PORT_BIT( 0x08, IP_ACTIVE_LOW, IPT_START1 )
+	PORT_BIT( 0x10, IP_ACTIVE_LOW, IPT_START2 )
+	PORT_BIT( 0x20, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNKNOWN )
+	PORT_BIT( 0x80, IP_ACTIVE_LOW, IPT_UNKNOWN )
+
+	PORT_START("IN0")
+	KONAMI8_MONO_B12_UNK
+
+	PORT_START("IN1")
+	KONAMI8_COCKTAIL_B12_UNK
+
+	PORT_START("DSW2")
+	PORT_DIPNAME( 0x03, 0x01, DEF_STR( Lives ) )
+	PORT_DIPSETTING(    0x03, "1" )
+	PORT_DIPSETTING(    0x02, "2" )
+	PORT_DIPSETTING(    0x01, "3" )
+	PORT_DIPSETTING(    0x00, "5" )
+	PORT_DIPNAME( 0x04, 0x00, DEF_STR( Cabinet ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Upright ) )
+	PORT_DIPSETTING(    0x04, DEF_STR( Cocktail ) )
+	PORT_DIPNAME( 0x08, 0x08, DEF_STR( Bonus_Life ) )
+	PORT_DIPSETTING(    0x08, "30000 80000" )
+	PORT_DIPSETTING(    0x00, "40000 90000" )
+	PORT_DIPNAME( 0x30, 0x10, DEF_STR( Difficulty ) )
+	PORT_DIPSETTING(    0x30, DEF_STR( Easy ) )
+	PORT_DIPSETTING(    0x10, DEF_STR( Normal ) )
+	PORT_DIPSETTING(    0x20, DEF_STR( Difficult ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Very_Difficult ) )
+	PORT_BIT( 0x40, IP_ACTIVE_LOW, IPT_UNUSED )
+	PORT_DIPNAME( 0x80, 0x00, DEF_STR( Demo_Sounds ) )
+	PORT_DIPSETTING(    0x80, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+
+	PORT_START("DSW3")
+	PORT_DIPNAME( 0x01, 0x01, DEF_STR( Flip_Screen ) )
+	PORT_DIPSETTING(    0x01, DEF_STR( Off ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( On ) )
+	PORT_DIPNAME( 0x02, 0x02, "Upright Controls" )
+	PORT_DIPSETTING(    0x02, DEF_STR( Single ) )
+	PORT_DIPSETTING(    0x00, DEF_STR( Dual ) )
+	PORT_SERVICE( 0x04, IP_ACTIVE_LOW )
+	PORT_BIT( 0xf8, IP_ACTIVE_LOW, IPT_UNUSED )
+
+	PORT_START("DSW1")
+	KONAMI_COINAGE(DEF_STR( Free_Play ), "Invalid")
+	/* "Invalid" = both coin slots disabled */
+INPUT_PORTS_END
+
+
 static const gfx_layout charlayout =
 {
 	8,8,
@@ -839,6 +924,7 @@
 GFXDECODE_END
 
 
+
 static void adpcm_vck_callback( running_device *device )
 {
 	trackfld_state *state = device->machine->driver_data<trackfld_state>();
@@ -952,6 +1038,53 @@
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
 MACHINE_DRIVER_END
 
+
+static MACHINE_DRIVER_START( yieartf )
+
+	/* driver data */
+	MDRV_DRIVER_DATA(trackfld_state)
+
+	/* basic machine hardware */
+	MDRV_CPU_ADD("maincpu", M6809, MASTER_CLOCK/6/2)	/* a guess for now */
+	MDRV_CPU_PROGRAM_MAP(yieartf_map)
+	MDRV_CPU_VBLANK_INT("screen", irq0_line_hold)
+
+//  z80 isn't used
+//  MDRV_CPU_ADD("audiocpu", Z80, SOUND_CLOCK/4)
+//  MDRV_CPU_PROGRAM_MAP(sound_map)
+
+	MDRV_MACHINE_START(trackfld)
+	MDRV_MACHINE_RESET(trackfld)
+	MDRV_NVRAM_HANDLER(generic_0fill)
+
+	/* video hardware */
+	MDRV_SCREEN_ADD("screen", RASTER)
+	MDRV_SCREEN_REFRESH_RATE(60)
+	MDRV_SCREEN_VBLANK_TIME(ATTOSECONDS_IN_USEC(0))
+	MDRV_SCREEN_FORMAT(BITMAP_FORMAT_INDEXED16)
+	MDRV_SCREEN_SIZE(32*8, 32*8)
+	MDRV_SCREEN_VISIBLE_AREA(0*8, 32*8-1, 2*8, 30*8-1)
+
+	MDRV_GFXDECODE(trackfld)
+	MDRV_PALETTE_LENGTH(16*16+16*16)
+
+	MDRV_PALETTE_INIT(trackfld)
+	MDRV_VIDEO_START(trackfld)
+	MDRV_VIDEO_UPDATE(trackfld)
+
+	/* sound hardware */
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+
+	MDRV_SOUND_ADD("dac", DAC, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.80)
+
+	MDRV_SOUND_ADD("snsnd", SN76496, SOUND_CLOCK/8)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+
+	MDRV_SOUND_ADD("vlm", VLM5030, VLM_CLOCK)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 1.0)
+MACHINE_DRIVER_END
+
 /* same as the original, but uses ADPCM instead of VLM5030 */
 /* also different memory handlers do handle that */
 static MACHINE_DRIVER_START( hyprolyb )
@@ -974,6 +1107,12 @@
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.50)
 MACHINE_DRIVER_END
 
+static MACHINE_DRIVER_START( atlantol )
+	MDRV_IMPORT_FROM(hyprolyb)
+
+	MDRV_VIDEO_START(atlantol)
+MACHINE_DRIVER_END
+
 
 static MACHINE_DRIVER_START( mastkin )
 
@@ -1362,6 +1501,34 @@
 	ROM_LOAD( "c9_d15.bin",   0x0000, 0x2000, CRC(f546a56b) SHA1(caee3d8546eb7a75ce2a578c6a1a630246aec6b8) )
 ROM_END
 
+ROM_START( yieartf )
+	ROM_REGION( 0x10000, "maincpu", 0 )
+	ROM_LOAD( "2.2a",      0x08000, 0x2000, CRC(349430e9) SHA1(0cd1ac9b949cc53679a67d47f1eae0daf2012550) )
+	ROM_LOAD( "3.3a",      0x0a000, 0x2000, CRC(17d8337b) SHA1(aa6b92ff42a5b5282170bd280f7c0bb5a38607ec) )
+	ROM_LOAD( "4.4a",      0x0c000, 0x2000, CRC(a89a2166) SHA1(e9e72ae9631d86ff884d1ab718b4884c38a5ae2d) )
+	ROM_LOAD( "5.5a",      0x0e000, 0x2000, CRC(ff1599eb) SHA1(6f345a1b230f5f8016b47034c74a87b29d16682b) )
+
+	ROM_REGION( 0x10000, "gfx1", 0 )
+	ROM_LOAD( "a.15c",    0x00000, 0x4000, CRC(45109b29) SHA1(0794935b490497b21b99045c90231b7bac151d42) )
+	ROM_LOAD( "b.16c",    0x04000, 0x4000, CRC(1d650790) SHA1(5f2a4983b20251c712358547a7c62c0331c6cb6f) )
+	ROM_LOAD( "c.17c",    0x08000, 0x4000, CRC(e6aa945b) SHA1(c5757d16c28f5966fd04675c0c640ef9b6b76ca5) )
+	ROM_LOAD( "d.18c",    0x0c000, 0x4000, CRC(cc187c22) SHA1(555ba18a9648681e5140b3fd84af16959ee5296d) )
+
+	ROM_REGION( 0x04000, "gfx2", 0 )
+	ROM_LOAD( "6.16h",      0x00000, 0x2000, CRC(05a23af3) SHA1(d588a5d31e106a3c5b1e37b1826863108b87f02d) )
+	ROM_LOAD( "7.15h",      0x02000, 0x2000, CRC(988154fa) SHA1(981273ef70ae6a947c24559750a8e7dc3d032444) )
+
+	ROM_REGION( 0x0220, "proms", 0 )
+	ROM_LOAD( "yiear.clr",    0x00000, 0x0020, CRC(c283d71f) SHA1(10cd39f4e951ba6ca5610081c8c1fcd9d68b34d2) )
+	ROM_LOAD( "prom1.b16",   0x0020, 0x0100, CRC(93dc32a0) SHA1(04e69d234e0ae93d90bbf2ef507f1cfd5cf3f87a) ) /* sprite lookup table */
+	ROM_LOAD( "prom2.e15",   0x0120, 0x0100,  CRC(e7e0f9e5) SHA1(008605db7a262fab8e569c1e19c707991027abfc) ) /* char lookup table */
+
+	ROM_REGION( 0x2000, "vlm", 0 )	/* 8k for the VLM5030 data */
+	ROM_LOAD( "01.snd",    0x00000, 0x2000, CRC(f75a1539) SHA1(f139f6cb41351eb81ee47d777db03012aa5fadb1) )
+ROM_END
+
+
+
 static DRIVER_INIT( trackfld )
 {
 	konami1_decode(machine, "maincpu");
@@ -1369,7 +1536,7 @@
 
 static DRIVER_INIT( atlantol )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt;
 	int A;
@@ -1381,7 +1548,7 @@
 	for (A = 0; A < 0x6000; A++)
 		decrypt[A] = rom[A];
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypt);
+	space->set_decrypted_region(0x0000, 0xffff, decrypt);
 
 	memory_install_write8_handler(space, 0x0800, 0x0800, 0, 0, atlantol_gfxbank_w);
 	memory_nop_write(space, 0x1000, 0x1000, 0, 0);
@@ -1441,9 +1608,10 @@
 GAME( 1983, trackfldc, trackfld, trackfld, trackfld, trackfld, ROT0,  "Konami (Centuri license)", "Track & Field (Centuri)", GAME_SUPPORTS_SAVE )
 GAME( 1983, hyprolym,  trackfld, trackfld, trackfld, trackfld, ROT0,  "Konami", "Hyper Olympic", GAME_SUPPORTS_SAVE )
 GAME( 1983, hyprolymb, trackfld, hyprolyb, trackfld, trackfld, ROT0,  "bootleg", "Hyper Olympic (bootleg)", GAME_IMPERFECT_SOUND | GAME_SUPPORTS_SAVE )
-GAME( 1996, atlantol,  trackfld, hyprolyb, atlantol, atlantol, ROT0,  "bootleg", "Atlant Olimpic", GAME_SUPPORTS_SAVE )
+GAME( 1996, atlantol,  trackfld, atlantol, atlantol, atlantol, ROT0,  "bootleg", "Atlant Olimpic", GAME_SUPPORTS_SAVE )
 GAME( 1988, mastkin,   0,        mastkin,  mastkin,  mastkin,  ROT0,  "Du Tech", "The Masters of Kin", GAME_WRONG_COLORS | GAME_SUPPORTS_SAVE )
 GAME( 1982, trackfldnz,trackfld, trackfld, trackfld, trackfld, ROT0,  "bootleg? (Goldberg Enterprizes Inc.)", "Track & Field (NZ bootleg?)", GAME_NOT_WORKING)
 GAME( 1985, wizzquiz,  0,        wizzquiz, wizzquiz, wizzquiz, ROT0,  "Zilec-Zenitone (Konami license)", "Wizz Quiz (Konami version)", GAME_SUPPORTS_SAVE )
 GAME( 1985, wizzquiza, wizzquiz, wizzquiz, wizzquiz, wizzquiz, ROT0,  "Zilec-Zenitone", "Wizz Quiz (version 4)", GAME_SUPPORTS_SAVE )
 GAME( 1987, reaktor,   0,        reaktor,  reaktor,  0,        ROT90, "Zilec", "Reaktor (Track & Field conversion)", GAME_SUPPORTS_SAVE )
+GAME( 1985, yieartf,   yiear,    yieartf,  yieartf, 0,         ROT0,  "Konami", "Yie Ar Kung-Fu (GX361 conversion)", GAME_NO_SOUND | GAME_SUPPORTS_SAVE ) // the conversion looks of bootleg quality, but the code is clearly a very different revision to either original hardware set...
diff -Nru src-old/mame/drivers/turrett.c src/mame/drivers/turrett.c
--- src-old/mame/drivers/turrett.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/turrett.c	2010-08-26 09:31:58.000000000 -0700
@@ -95,7 +95,7 @@
 INPUT_PORTS_END
 
 
-static const r3000_cpu_core config =
+static const r3000_cpu_core r3000_config =
 {
 	0,		/* 1 if we have an FPU, 0 otherwise */
 	2048,	/* code cache size */
@@ -107,7 +107,7 @@
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R3041BE, R3041_CLOCK)
 	MDRV_CPU_PROGRAM_MAP(cpu_map)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r3000_config)
 
 	/* video hardware */
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/twinkle.c src/mame/drivers/twinkle.c
--- src-old/mame/drivers/twinkle.c	2010-07-08 14:05:37.000000000 -0700
+++ src/mame/drivers/twinkle.c	2010-08-15 02:09:53.000000000 -0700
@@ -1132,7 +1132,7 @@
 
 /* 1999 - beatmania IIDX 2nd style */
 /* these use i2c for security */
-GAME( 2000, bmiidx3,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 3th style (GC992 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
+GAME( 2000, bmiidx3,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 3rd style (GC992 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 GAME( 2000, bmiidx4,  gq863,   twinkle, twinkle, twinkle, ROT0, "Konami", "beatmania IIDX 4th style (GCA03 JA)", GAME_IMPERFECT_SOUND | GAME_IMPERFECT_GRAPHICS | GAME_NOT_WORKING  )
 /* 2001 - beatmania IIDX 5th style */
 
diff -Nru src-old/mame/drivers/tx1.c src/mame/drivers/tx1.c
--- src-old/mame/drivers/tx1.c	2010-05-24 18:49:55.000000000 -0700
+++ src/mame/drivers/tx1.c	2010-08-19 01:27:05.000000000 -0700
@@ -100,14 +100,14 @@
 
 static READ16_HANDLER( z80_shared_r )
 {
-	const address_space *cpu2space = cputag_get_address_space(space->machine, "audio_cpu", ADDRESS_SPACE_PROGRAM);
-	return memory_read_byte(cpu2space, offset);
+	address_space *cpu2space = cputag_get_address_space(space->machine, "audio_cpu", ADDRESS_SPACE_PROGRAM);
+	return cpu2space->read_byte(offset);
 }
 
 static WRITE16_HANDLER( z80_shared_w )
 {
-	const address_space *cpu2space = cputag_get_address_space(space->machine, "audio_cpu", ADDRESS_SPACE_PROGRAM);
-	memory_write_byte(cpu2space, offset, data & 0xff);
+	address_space *cpu2space = cputag_get_address_space(space->machine, "audio_cpu", ADDRESS_SPACE_PROGRAM);
+	cpu2space->write_byte(offset, data & 0xff);
 }
 
 
diff -Nru src-old/mame/drivers/vamphalf.c src/mame/drivers/vamphalf.c
--- src-old/mame/drivers/vamphalf.c	2010-07-16 19:23:34.000000000 -0700
+++ src/mame/drivers/vamphalf.c	2010-08-19 00:26:14.000000000 -0700
@@ -1621,7 +1621,7 @@
 	ROM_COPY( "user2", 0x060000, 0x0e0000, 0x020000)
 ROM_END
 
-static int irq_active(const address_space *space)
+static int irq_active(address_space *space)
 {
 	UINT32 FCR = cpu_get_reg(space->cpu, 27);
 	if( !(FCR&(1<<29)) ) // int 2 (irq 4)
diff -Nru src-old/mame/drivers/vcombat.c src/mame/drivers/vcombat.c
--- src-old/mame/drivers/vcombat.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/vcombat.c	2010-08-18 23:57:51.000000000 -0700
@@ -102,7 +102,7 @@
 static VIDEO_UPDATE( vcombat )
 {
 	int y;
-	const rgb_t *const pens = tlc34076_get_pens();
+	const rgb_t *const pens = tlc34076_get_pens(screen->machine->device("tlc34076"));
 	running_device *aux = screen->machine->device("aux");
 
 	UINT16 *m68k_buf = m68k_framebuffer[(*framebuffer_ctrl & 0x20) ? 1 : 0];
@@ -335,7 +335,7 @@
 	//AM_RANGE(0x703000, 0x703001)      /* Headset rotation axis? */
 	//AM_RANGE(0x704000, 0x704001)      /* Headset rotation axis? */
 
-	AM_RANGE(0x706000, 0x70601f) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x706000, 0x70601f) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 ADDRESS_MAP_END
 
 
@@ -375,9 +375,6 @@
 
 static MACHINE_RESET( vcombat )
 {
-	/* Setup the Bt476 VGA RAMDAC palette chip */
-	tlc34076_reset(6);
-
 	i860_set_pin(machine->device("vid_0"), DEC_PIN_BUS_HOLD, 1);
 	i860_set_pin(machine->device("vid_1"), DEC_PIN_BUS_HOLD, 1);
 
@@ -386,30 +383,27 @@
 
 static MACHINE_RESET( shadfgtr )
 {
-	/* Setup the Bt476 VGA RAMDAC palette chip */
-	tlc34076_reset(6);
-
 	i860_set_pin(machine->device("vid_0"), DEC_PIN_BUS_HOLD, 1);
 
 	crtc_select = 0;
 }
 
 
-static DIRECT_UPDATE_HANDLER( vid_0_direct_handler )
+DIRECT_UPDATE_HANDLER( vcombat_vid_0_direct_handler )
 {
 	if (address >= 0xfffc0000 && address <= 0xffffffff)
 	{
-		direct->raw = direct->decrypted = ((UINT8*)vid_0_shared_RAM) - 0xfffc0000;
+		direct.explicit_configure(0xfffc0000, 0xffffffff, 0x3ffff, vid_0_shared_RAM);
 		return ~0;
 	}
 	return address;
 }
 
-static DIRECT_UPDATE_HANDLER( vid_1_direct_handler )
+DIRECT_UPDATE_HANDLER( vcombat_vid_1_direct_handler )
 {
 	if (address >= 0xfffc0000 && address <= 0xffffffff)
 	{
-		direct->raw = direct->decrypted = ((UINT8*)vid_1_shared_RAM) - 0xfffc0000;
+		direct.explicit_configure(0xfffc0000, 0xffffffff, 0x3ffff, vid_1_shared_RAM);
 		return ~0;
 	}
 	return address;
@@ -421,8 +415,11 @@
 	UINT8 *ROM = memory_region(machine, "maincpu");
 
 	/* The two i860s execute out of RAM */
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "vid_0", ADDRESS_SPACE_PROGRAM), vid_0_direct_handler);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "vid_1", ADDRESS_SPACE_PROGRAM), vid_1_direct_handler);
+	address_space *space = machine->device<i860_device>("vid_0")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(vcombat_vid_0_direct_handler, *machine));
+
+	space = machine->device<i860_device>("vid_1")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(vcombat_vid_1_direct_handler, *machine));
 
 	/* Allocate the 68000 framebuffers */
 	m68k_framebuffer[0] = auto_alloc_array(machine, UINT16, 0x8000);
@@ -465,7 +462,8 @@
 	i860_framebuffer[1][1] = NULL;
 
 	/* The i860 executes out of RAM */
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "vid_0", ADDRESS_SPACE_PROGRAM), vid_0_direct_handler);
+	address_space *space = machine->device<i860_device>("vid_0")->space(AS_PROGRAM);
+	space->set_direct_update_handler(direct_update_delegate_create_static(vcombat_vid_0_direct_handler, *machine));
 }
 
 
@@ -575,6 +573,8 @@
 	MDRV_QUANTUM_PERFECT_CPU("maincpu")
 #endif
 
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	/* Disabled for now as it can't handle multiple screens */
 //  MDRV_MC6845_ADD("crtc", MC6845, 6000000 / 16, mc6845_intf)
 	MDRV_DEFAULT_LAYOUT(layout_dualhsxs)
@@ -612,6 +612,8 @@
 	MDRV_NVRAM_HANDLER(generic_0fill)
 	MDRV_MACHINE_RESET(shadfgtr)
 
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_MC6845_ADD("crtc", MC6845, XTAL_20MHz / 4 / 16, mc6845_intf)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/vegas.c src/mame/drivers/vegas.c
--- src-old/mame/drivers/vegas.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/vegas.c	2010-08-26 09:31:58.000000000 -0700
@@ -1675,6 +1675,8 @@
 
 	/* now remap everything */
 	if (LOG_DYNAMIC) logerror("remap_dynamic_addresses:\n");
+	address_space *space = const_cast<address_space *>(machine->device<cpu_device>("maincpu")->space(AS_PROGRAM));
+	assert(space != NULL);
 	for (addr = 0; addr < dynamic_count; addr++)
 	{
 		if (LOG_DYNAMIC) logerror("  installing: %08X-%08X %s,%s\n", dynamic[addr].start, dynamic[addr].end, dynamic[addr].rdname, dynamic[addr].wrname);
@@ -1682,12 +1684,15 @@
 		if (dynamic[addr].mread == NOP_HANDLER)
 			memory_nop_read(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dynamic[addr].start, dynamic[addr].end, 0, 0);
 		else if (dynamic[addr].mread != NULL)
-			_memory_install_handler32(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].mread, dynamic[addr].rdname, NULL, NULL, 0);
+			space->install_legacy_handler(dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].mread, dynamic[addr].rdname);
 		if (dynamic[addr].mwrite != NULL)
-			_memory_install_handler32(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dynamic[addr].start, dynamic[addr].end, 0, 0, NULL, NULL, dynamic[addr].mwrite, dynamic[addr].wrname, 0);
+			space->install_legacy_handler(dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].mwrite, dynamic[addr].wrname);
 
 		if (dynamic[addr].dread != NULL || dynamic[addr].dwrite != NULL)
-			_memory_install_device_handler32(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), dynamic[addr].device, dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].dread, dynamic[addr].rdname, dynamic[addr].dwrite, dynamic[addr].wrname, 0);
+		{
+			space->install_legacy_handler(*dynamic[addr].device, dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].dread, dynamic[addr].rdname);
+			space->install_legacy_handler(*dynamic[addr].device, dynamic[addr].start, dynamic[addr].end, 0, 0, dynamic[addr].dwrite, dynamic[addr].wrname);
+		}
 	}
 
 	if (LOG_DYNAMIC)
@@ -2208,7 +2213,7 @@
  *
  *************************************/
 
-static const mips3_config config =
+static const mips3_config r5000_config =
 {
 	16384,			/* code cache size */
 	16384,			/* data cache size */
@@ -2219,7 +2224,7 @@
 
 	/* basic machine hardware */
 	MDRV_CPU_ADD("maincpu", R5000LE, SYSTEM_CLOCK*2)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(vegas_map_8mb)
 
 	MDRV_MACHINE_START(vegas)
@@ -2289,7 +2294,7 @@
 static MACHINE_DRIVER_START( vegasv3 )
 	MDRV_IMPORT_FROM(vegas32m)
 	MDRV_CPU_REPLACE("maincpu", RM7000LE, SYSTEM_CLOCK*2.5)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(vegas_map_8mb)
 
 	MDRV_DEVICE_REMOVE("voodoo")
@@ -2304,7 +2309,7 @@
 	MDRV_IMPORT_FROM(dcs2_audio_denver)
 
 	MDRV_CPU_REPLACE("maincpu", RM7000LE, SYSTEM_CLOCK*2.5)
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(vegas_map_32mb)
 
 	MDRV_DEVICE_REMOVE("voodoo")
diff -Nru src-old/mame/drivers/vendetta.c src/mame/drivers/vendetta.c
--- src-old/mame/drivers/vendetta.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/vendetta.c	2010-08-19 00:26:14.000000000 -0700
@@ -166,7 +166,7 @@
 static void vendetta_video_banking( running_machine *machine, int select )
 {
 	vendetta_state *state = machine->driver_data<vendetta_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if (select & 1)
 	{
diff -Nru src-old/mame/drivers/vp101.c src/mame/drivers/vp101.c
--- src-old/mame/drivers/vp101.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/drivers/vp101.c	2010-08-26 09:31:58.000000000 -0700
@@ -48,7 +48,7 @@
 static INPUT_PORTS_START( vp101 )
 INPUT_PORTS_END
 
-static const mips3_config config =
+static const mips3_config r5000_config =
 {
 	32768,				/* code cache size */
 	32768,				/* data cache size */
@@ -57,7 +57,7 @@
 
 static MACHINE_DRIVER_START( vp101 )
 	MDRV_CPU_ADD("maincpu", R5000LE, 300000000)	/* actually VR5500 with added NEC VR-series custom instructions */
-	MDRV_CPU_CONFIG(config)
+	MDRV_CPU_CONFIG(r5000_config)
 	MDRV_CPU_PROGRAM_MAP(main_map)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/wardner.c src/mame/drivers/wardner.c
--- src-old/mame/drivers/wardner.c	2010-05-22 15:13:02.000000000 -0700
+++ src/mame/drivers/wardner.c	2010-08-19 00:26:14.000000000 -0700
@@ -140,7 +140,7 @@
 	if (wardner_membank != data) {
 		int bankaddress = 0;
 
-		const address_space *mainspace;
+		address_space *mainspace;
 		UINT8 *RAM = memory_region(space->machine, "maincpu");
 
 		mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
@@ -178,7 +178,7 @@
 
 STATE_POSTLOAD( wardner_restore_bank )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	wardner_ramrom_bank_sw(space,0,1);	/* Dummy value to ensure restoration */
 	wardner_ramrom_bank_sw(space,0,wardner_membank);
diff -Nru src-old/mame/drivers/wecleman.c src/mame/drivers/wecleman.c
--- src-old/mame/drivers/wecleman.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/wecleman.c	2010-08-19 01:27:05.000000000 -0700
@@ -495,7 +495,7 @@
 			for ( ; size > 0 ; size--)
 			{
 				/* maybe slower than a memcpy but safer (and errors are logged) */
-				memory_write_word(space, dest, memory_read_word(space, src));
+				space->write_word(dest, space->read_word(src));
 				src += 2;
 				dest += 2;
 			}
@@ -508,23 +508,23 @@
 				int i, j, destptr;
 
 				/* Read offset of source from the list of blits */
-				i = src + memory_read_word(space, list+2);
+				i = src + space->read_word(list+2);
 				j = i + (size<<1);
 				destptr = dest;
 
 				for (; i<j; destptr+=2, i+=2)
-					memory_write_word(space, destptr, memory_read_word(space, i));
+					space->write_word(destptr, space->read_word(i));
 
 				destptr = dest + 14;
-				i = memory_read_word(space, list) + spr_color_offs;
-				memory_write_word(space, destptr, i);
+				i = space->read_word(list) + spr_color_offs;
+				space->write_word(destptr, i);
 
 				dest += 16;
 				list += 4;
 			}
 
 			/* hack for the blit to Sprites RAM - Sprite list end-marker */
-			memory_write_word(space, dest, 0xFFFF);
+			space->write_word(dest, 0xFFFF);
 		}
 	}
 }
diff -Nru src-old/mame/drivers/williams.c src/mame/drivers/williams.c
--- src-old/mame/drivers/williams.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/williams.c	2010-08-19 00:26:14.000000000 -0700
@@ -524,7 +524,7 @@
 ADDRESS_MAP_END
 
 
-void defender_install_io_space(const address_space *space)
+void defender_install_io_space(address_space *space)
 {
 	running_device *pia_0 = space->machine->device("pia_0");
 	running_device *pia_1 = space->machine->device("pia_1");
diff -Nru src-old/mame/drivers/wiz.c src/mame/drivers/wiz.c
--- src-old/mame/drivers/wiz.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/wiz.c	2010-08-19 07:19:38.000000000 -0700
@@ -1049,14 +1049,14 @@
 		{ 5,3,7, 0x80 },
 		{ 5,7,3, 0x28 }
 	};
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int size = memory_region_length(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, size);
 	int A;
 	const UINT8 *tbl;
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypt);
+	space->set_decrypted_region(0x0000, 0xffff, decrypt);
 
 	for (A = 0x0000;A < 0x10000;A++)
 	{
diff -Nru src-old/mame/drivers/wwfwfest.c src/mame/drivers/wwfwfest.c
--- src-old/mame/drivers/wwfwfest.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/drivers/wwfwfest.c	2010-08-19 00:26:14.000000000 -0700
@@ -381,7 +381,7 @@
 
 static VIDEO_EOF( wwfwfest )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space,0,0,0xffff);
 }
diff -Nru src-old/mame/drivers/xtheball.c src/mame/drivers/xtheball.c
--- src-old/mame/drivers/xtheball.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/drivers/xtheball.c	2010-08-19 00:26:14.000000000 -0700
@@ -27,19 +27,6 @@
 
 /*************************************
  *
- *  Machine init
- *
- *************************************/
-
-static MACHINE_RESET( xtheball )
-{
-	tlc34076_reset(6);
-}
-
-
-
-/*************************************
- *
  *  Video update
  *
  *************************************/
@@ -48,7 +35,7 @@
 {
 	UINT16 *srcbg = &vram_bg[(params->rowaddr << 8) & 0xff00];
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = params->coladdr;
 	int x;
 
@@ -93,7 +80,7 @@
  *
  *************************************/
 
-static void xtheball_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void xtheball_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	if (address >= 0x01000000 && address <= 0x010fffff)
 		memcpy(shiftreg, &vram_bg[TOWORD(address & 0xff000)], TOBYTE(0x1000));
@@ -104,7 +91,7 @@
 }
 
 
-static void xtheball_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+static void xtheball_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	if (address >= 0x01000000 && address <= 0x010fffff)
 		memcpy(&vram_bg[TOWORD(address & 0xff000)], shiftreg, TOBYTE(0x1000));
@@ -215,7 +202,7 @@
 	AM_RANGE(0x00000000, 0x0001ffff) AM_RAM AM_BASE_SIZE_GENERIC(nvram)
 	AM_RANGE(0x01000000, 0x010fffff) AM_RAM AM_BASE(&vram_bg)
 	AM_RANGE(0x02000000, 0x020fffff) AM_RAM AM_BASE(&vram_fg)
-	AM_RANGE(0x03000000, 0x030000ff) AM_READWRITE(tlc34076_lsb_r, tlc34076_lsb_w)
+	AM_RANGE(0x03000000, 0x030000ff) AM_DEVREADWRITE8("tlc34076", tlc34076_r, tlc34076_w, 0x00ff)
 	AM_RANGE(0x03040000, 0x030401ff) AM_WRITE(bit_controls_w)
 	AM_RANGE(0x03040080, 0x0304008f) AM_READ_PORT("DSW")
 	AM_RANGE(0x03040100, 0x0304010f) AM_READ(analogx_r)
@@ -338,14 +325,15 @@
 	MDRV_CPU_ADD("maincpu", TMS34010, 40000000)
 	MDRV_CPU_CONFIG(tms_config)
 	MDRV_CPU_PROGRAM_MAP(main_map)
-	MDRV_CPU_PERIODIC_INT(irq1_line_hold,15000)
+	MDRV_CPU_PERIODIC_INT(irq1_line_hold, 15000)
 
-	MDRV_MACHINE_RESET(xtheball)
 	MDRV_NVRAM_HANDLER(generic_1fill)
 
 	MDRV_TICKET_DISPENSER_ADD("ticket", 100, TICKET_MOTOR_ACTIVE_HIGH, TICKET_STATUS_ACTIVE_HIGH)
 
 	/* video hardware */
+	MDRV_TLC34076_ADD("tlc34076", TLC34076_6_BIT)
+
 	MDRV_VIDEO_UPDATE(tms340x0)
 
 	MDRV_SCREEN_ADD("screen", RASTER)
diff -Nru src-old/mame/drivers/yunsun16.c src/mame/drivers/yunsun16.c
--- src-old/mame/drivers/yunsun16.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/yunsun16.c	2010-08-16 12:47:33.000000000 -0700
@@ -624,8 +624,8 @@
 
 	MDRV_SOUND_ADD("ymsnd", YM3812, 4000000)
 	MDRV_SOUND_CONFIG(magicbub_ym3812_intf)
-	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.20)
-	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.20)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.80)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "rspeaker", 0.80)
 
 	MDRV_OKIM6295_ADD("oki", 1056000, OKIM6295_PIN7_HIGH)
 	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "lspeaker", 0.80)
diff -Nru src-old/mame/drivers/zac2650.c src/mame/drivers/zac2650.c
--- src-old/mame/drivers/zac2650.c	2010-05-22 13:51:23.000000000 -0700
+++ src/mame/drivers/zac2650.c	2010-08-12 13:04:59.000000000 -0700
@@ -10,6 +10,7 @@
 
 #include "emu.h"
 #include "cpu/s2650/s2650.h"
+#include "sound/s2636.h"
 
 #include "tinv2650.lh"
 
@@ -260,6 +261,10 @@
 	MDRV_VIDEO_UPDATE(tinvader)
 
 	/* sound hardware */
+	MDRV_SPEAKER_STANDARD_MONO("mono")
+
+	MDRV_SOUND_ADD("s2636snd", S2636, 0)
+	MDRV_SOUND_ROUTE(ALL_OUTPUTS, "mono", 0.25)
 MACHINE_DRIVER_END
 
 static WRITE8_HANDLER( tinvader_sound_w )
@@ -314,6 +319,6 @@
 ROM_END
 
 
-GAME( 1978, sia2650,  0,       tinvader, sinvader, 0, ROT270, "Zelco / Zaccaria", "Super Invader Attack", GAME_NO_SOUND )
-GAMEL(1978, tinv2650, sia2650, tinvader, tinvader, 0, ROT270, "Zelco / Zaccaria", "The Invaders",         GAME_NO_SOUND, layout_tinv2650 )
-GAME( 1979, dodgem,   0,       tinvader, dodgem,   0, ROT0,   "Zaccaria",         "Dodgem",               GAME_NO_SOUND )
+GAME( 1978, sia2650,  0,       tinvader, sinvader, 0, ROT270, "Zelco / Zaccaria", "Super Invader Attack", 0 )
+GAMEL(1978, tinv2650, sia2650, tinvader, tinvader, 0, ROT270, "Zelco / Zaccaria", "The Invaders",         0, layout_tinv2650 )
+GAME( 1979, dodgem,   0,       tinvader, dodgem,   0, ROT0,   "Zaccaria",         "Dodgem",               0 )
diff -Nru src-old/mame/drivers/zaxxon.c src/mame/drivers/zaxxon.c
--- src-old/mame/drivers/zaxxon.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/drivers/zaxxon.c	2010-08-19 07:19:38.000000000 -0700
@@ -1450,12 +1450,12 @@
 	};
 
 	int A;
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, cputag);
 	int size = memory_region_length(machine, cputag);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, size);
 
-	memory_set_decrypted_region(space, 0x0000, size - 1, decrypt);
+	space->set_decrypted_region(0x0000, size - 1, decrypt);
 
 	for (A = 0x0000; A < size; A++)
 	{
diff -Nru src-old/mame/includes/archimds.h src/mame/includes/archimds.h
--- src-old/mame/includes/archimds.h	2009-10-02 23:53:27.000000000 -0700
+++ src/mame/includes/archimds.h	2010-08-30 08:20:58.000000000 -0700
@@ -13,11 +13,11 @@
 #define ARCHIMEDES_IRQA_PRINTER_BUSY (0x01)
 #define ARCHIMEDES_IRQA_SERIAL_RING  (0x02)
 #define ARCHIMEDES_IRQA_PRINTER_ACK  (0x04)
-#define ARCHIMEDES_IRQA_VBL	       (0x08)
+#define ARCHIMEDES_IRQA_VBL	         (0x08)
 #define ARCHIMEDES_IRQA_RESET        (0x10)
 #define ARCHIMEDES_IRQA_TIMER0       (0x20)
 #define ARCHIMEDES_IRQA_TIMER1       (0x40)
-#define ARCHIMEDES_IRQA_ALWAYS       (0x80)
+#define ARCHIMEDES_IRQA_FORCE        (0x80)
 
 #define ARCHIMEDES_IRQB_PODULE_FIQ   (0x01)
 #define ARCHIMEDES_IRQB_SOUND_EMPTY  (0x02)
@@ -59,4 +59,71 @@
 extern READ32_HANDLER(archimedes_vidc_r);
 extern WRITE32_HANDLER(archimedes_vidc_w);
 
+extern UINT8 i2c_clk;
+extern INT16 memc_pages[0x2000];	// the logical RAM area is 32 megs, and the smallest page size is 4k
+extern UINT32 vidc_regs[256];
+extern UINT8 ioc_regs[0x80/4];
+extern UINT8 vidc_bpp_mode;
+extern UINT8 vidc_interlace;
+
+/* IOC registers */
+
+#define CONTROL			0x00/4
+#define KART			0x04/4 // Keyboard Asynchronous Receiver Transmitter
+
+#define IRQ_STATUS_A	0x10/4
+#define IRQ_REQUEST_A   0x14/4
+#define IRQ_MASK_A		0x18/4
+#define IRQ_STATUS_B	0x20/4
+#define IRQ_REQUEST_B   0x24/4
+#define IRQ_MASK_B		0x28/4
+
+#define FIQ_STATUS		0x30/4
+#define FIQ_REQUEST     0x34/4
+#define FIQ_MASK		0x38/4
+
+#define T0_LATCH_LO	0x40/4
+#define T0_LATCH_HI 0x44/4
+#define T0_GO		0x48/4
+#define T0_LATCH	0x4c/4
+
+#define T1_LATCH_LO	0x50/4
+#define T1_LATCH_HI 0x54/4
+#define T1_GO		0x58/4
+#define T1_LATCH	0x5c/4
+
+#define T2_LATCH_LO	0x60/4
+#define T2_LATCH_HI 0x64/4
+#define T2_GO		0x68/4
+#define T2_LATCH	0x6c/4
+
+#define T3_LATCH_LO	0x70/4
+#define T3_LATCH_HI 0x74/4
+#define T3_GO		0x78/4
+#define T3_LATCH	0x7c/4
+
+
+/*----------- defined in video/archimds.c -----------*/
+
+extern VIDEO_START( archimds_vidc );
+extern VIDEO_UPDATE( archimds_vidc );
+
+#define VIDC_HCR		0x80
+#define VIDC_HSWR		0x84
+#define VIDC_HBSR		0x88
+#define VIDC_HDSR		0x8c
+#define VIDC_HDER		0x90
+#define VIDC_HBER		0x94
+#define VIDC_HCSR		0x98
+#define VIDC_HIR		0x9c
+
+#define VIDC_VCR		0xa0
+#define VIDC_VSWR		0xa4
+#define VIDC_VBSR		0xa8
+#define VIDC_VDSR		0xac
+#define VIDC_VDER		0xb0
+#define VIDC_VBER		0xb4
+#define VIDC_VCSR		0xb8
+#define VIDC_VCER		0xbc
+
 #endif	// _ARCHIMEDES_H_
diff -Nru src-old/mame/includes/artmagic.h src/mame/includes/artmagic.h
--- src-old/mame/includes/artmagic.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/artmagic.h	2010-08-19 00:26:14.000000000 -0700
@@ -13,8 +13,8 @@
 
 VIDEO_START( artmagic );
 
-void artmagic_to_shiftreg(const address_space *space, offs_t address, UINT16 *data);
-void artmagic_from_shiftreg(const address_space *space, offs_t address, UINT16 *data);
+void artmagic_to_shiftreg(address_space *space, offs_t address, UINT16 *data);
+void artmagic_from_shiftreg(address_space *space, offs_t address, UINT16 *data);
 
 READ16_HANDLER( artmagic_blitter_r );
 WRITE16_HANDLER( artmagic_blitter_w );
diff -Nru src-old/mame/includes/atari.h src/mame/includes/atari.h
--- src-old/mame/includes/atari.h	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/includes/atari.h	2010-08-19 01:27:05.000000000 -0700
@@ -210,7 +210,7 @@
     UINT16  data[HWIDTH];       /* graphics data buffer (text through chargen) */
 }   VIDEO;
 
-typedef void (*atari_renderer_func)(const address_space *space, VIDEO *video);
+typedef void (*atari_renderer_func)(address_space *space, VIDEO *video);
 
 typedef struct {
 	atari_renderer_func	renderer;	/* current renderer */
@@ -259,11 +259,11 @@
 	UINT8   *uc_g3;				/* used colors for gfx GTIA 3 */
 }   ANTIC;
 
-#define RDANTIC(space)		memory_read_byte(space, antic.dpage+antic.doffs)
-#define RDVIDEO(space,o)	memory_read_byte(space, antic.vpage+((antic.voffs+(o))&VOFFS))
-#define RDCHGEN(space,o)	memory_read_byte(space, antic.chbase+(o))
-#define RDPMGFXS(space,o)	memory_read_byte(space, antic.pmbase_s+(o)+(antic.scanline>>1))
-#define RDPMGFXD(space,o)	memory_read_byte(space, antic.pmbase_d+(o)+antic.scanline)
+#define RDANTIC(space)		space->read_byte(antic.dpage+antic.doffs)
+#define RDVIDEO(space,o)	space->read_byte(antic.vpage+((antic.voffs+(o))&VOFFS))
+#define RDCHGEN(space,o)	space->read_byte(antic.chbase+(o))
+#define RDPMGFXS(space,o)	space->read_byte(antic.pmbase_s+(o)+(antic.scanline>>1))
+#define RDPMGFXD(space,o)	space->read_byte(antic.pmbase_d+(o)+antic.scanline)
 
 #define PREPARE()												\
 	UINT32 *dst = (UINT32 *)&antic.cclock[PMOFFSET]
@@ -534,7 +534,7 @@
  READ8_HANDLER ( atari_antic_r );
 WRITE8_HANDLER ( atari_antic_w );
 
-#define ANTIC_RENDERER(name) void name(const address_space *space, VIDEO *video)
+#define ANTIC_RENDERER(name) void name(address_space *space, VIDEO *video)
 
 ANTIC_RENDERER( antic_mode_0_xx );
 ANTIC_RENDERER( antic_mode_2_32 );
diff -Nru src-old/mame/includes/atarigt.h src/mame/includes/atarigt.h
--- src-old/mame/includes/atarigt.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/atarigt.h	2010-08-19 00:26:14.000000000 -0700
@@ -36,8 +36,8 @@
 
 	UINT32 *		mo_command;
 
-	void			(*protection_w)(const address_space *space, offs_t offset, UINT16 data);
-	void			(*protection_r)(const address_space *space, offs_t offset, UINT16 *data);
+	void			(*protection_w)(address_space *space, offs_t offset, UINT16 data);
+	void			(*protection_r)(address_space *space, offs_t offset, UINT16 *data);
 };
 
 
diff -Nru src-old/mame/includes/bbusters.h src/mame/includes/bbusters.h
--- src-old/mame/includes/bbusters.h	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/includes/bbusters.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,37 @@
+class bbusters_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, bbusters_state(machine)); }
+
+	bbusters_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	UINT16 *videoram;
+	UINT16 *ram;
+	UINT16 *eprom_data;
+	int sound_status;
+	int gun_select;
+
+	tilemap_t *fix_tilemap;
+	tilemap_t *pf1_tilemap;
+	tilemap_t *pf2_tilemap;
+	const UINT8 *scale_table_ptr;
+	UINT8 scale_line_count;
+
+	UINT16 *pf1_data;
+	UINT16 *pf2_data;
+	UINT16 *pf1_scroll_data;
+	UINT16 *pf2_scroll_data;
+};
+
+
+/*----------- defined in video/bbusters.c -----------*/
+
+VIDEO_START( bbuster );
+VIDEO_START( mechatt );
+VIDEO_UPDATE( bbuster );
+VIDEO_UPDATE( mechatt );
+
+WRITE16_HANDLER( bbusters_pf1_w );
+WRITE16_HANDLER( bbusters_pf2_w );
+WRITE16_HANDLER( bbusters_video_w );
diff -Nru src-old/mame/includes/beathead.h src/mame/includes/beathead.h
--- src-old/mame/includes/beathead.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/beathead.h	2010-08-30 08:20:58.000000000 -0700
@@ -5,6 +5,8 @@
 *************************************************************************/
 
 #include "machine/atarigen.h"
+#include "cpu/asap/asap.h"
+#include "audio/atarijsa.h"
 
 class beathead_state : public atarigen_state
 {
@@ -12,41 +14,65 @@
 	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, beathead_state(machine)); }
 
 	beathead_state(running_machine &machine)
-		: atarigen_state(machine) { }
+		: atarigen_state(machine),
+		  m_maincpu(*machine.device<asap_device>("maincpu")) { }
 
-	UINT32 *		vram_bulk_latch;
-	UINT32 *		palette_select;
+	virtual void machine_start();
+	virtual void machine_reset();
 
-	UINT32			finescroll;
-	offs_t			vram_latch_offset;
+	virtual void video_start();
+	virtual bool video_update(screen_device &screen, bitmap_t &bitmap, const rectangle &cliprect);
 
-	offs_t			hsyncram_offset;
-	offs_t			hsyncram_start;
-	UINT8			hsyncram[0x800];
-
-	UINT32 *		ram_base;
-	UINT32 *		rom_base;
-
-	double			hblank_offset;
-
-	UINT8			irq_line_state;
-	UINT8			irq_enable[3];
-	UINT8			irq_state[3];
-
-	UINT8			eeprom_enabled;
+	asap_device &	m_maincpu;
+
+	UINT32 *		m_videoram;
+	UINT32 *		m_paletteram;
+
+	UINT32 *		m_vram_bulk_latch;
+	UINT32 *		m_palette_select;
+
+	UINT32			m_finescroll;
+	offs_t			m_vram_latch_offset;
+
+	offs_t			m_hsyncram_offset;
+	offs_t			m_hsyncram_start;
+	UINT8			m_hsyncram[0x800];
+
+	UINT32 *		m_ram_base;
+	UINT32 *		m_rom_base;
+
+	double			m_hblank_offset;
+
+	UINT8			m_irq_line_state;
+	UINT8			m_irq_enable[3];
+	UINT8			m_irq_state[3];
+
+	UINT8			m_eeprom_enabled;
+
+	UINT32 *		m_speedup_data;
+	UINT32 *		m_movie_speedup_data;
+
+	// in drivers/beathead.c
+	void update_interrupts();
+	DECLARE_WRITE32_MEMBER( interrupt_control_w );
+	DECLARE_READ32_MEMBER( interrupt_control_r );
+	DECLARE_WRITE32_MEMBER( eeprom_data_w );
+	DECLARE_WRITE32_MEMBER( eeprom_enable_w );
+	DECLARE_READ32_MEMBER( input_2_r );
+	DECLARE_READ32_MEMBER( sound_data_r );
+	DECLARE_WRITE32_MEMBER( sound_data_w );
+	DECLARE_WRITE32_MEMBER( sound_reset_w );
+	DECLARE_WRITE32_MEMBER( coin_count_w );
+	DECLARE_READ32_MEMBER( speedup_r );
+	DECLARE_READ32_MEMBER( movie_speedup_r );
+
+	// in video/beathead.c
+	DECLARE_WRITE32_MEMBER( vram_transparent_w );
+	DECLARE_WRITE32_MEMBER( vram_bulk_w );
+	DECLARE_WRITE32_MEMBER( vram_latch_w );
+	DECLARE_WRITE32_MEMBER( vram_copy_w );
+	DECLARE_WRITE32_MEMBER( finescroll_w );
+	DECLARE_WRITE32_MEMBER( palette_w );
+	DECLARE_READ32_MEMBER( hsync_ram_r );
+	DECLARE_WRITE32_MEMBER( hsync_ram_w );
 };
-
-
-/*----------- defined in video/beathead.c -----------*/
-
-VIDEO_START( beathead );
-VIDEO_UPDATE( beathead );
-
-WRITE32_HANDLER( beathead_vram_transparent_w );
-WRITE32_HANDLER( beathead_vram_bulk_w );
-WRITE32_HANDLER( beathead_vram_latch_w );
-WRITE32_HANDLER( beathead_vram_copy_w );
-WRITE32_HANDLER( beathead_finescroll_w );
-WRITE32_HANDLER( beathead_palette_w );
-READ32_HANDLER( beathead_hsync_ram_r );
-WRITE32_HANDLER( beathead_hsync_ram_w );
diff -Nru src-old/mame/includes/btoads.h src/mame/includes/btoads.h
--- src-old/mame/includes/btoads.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/btoads.h	2010-08-19 00:26:14.000000000 -0700
@@ -34,7 +34,7 @@
 READ16_HANDLER( btoads_vram_fg_display_r );
 READ16_HANDLER( btoads_vram_fg_draw_r );
 
-void btoads_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
-void btoads_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
+void btoads_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
+void btoads_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
 
 void btoads_scanline_update(screen_device &screen, bitmap_t *bitmap, int scanline, const tms34010_display_params *params);
diff -Nru src-old/mame/includes/dooyong.h src/mame/includes/dooyong.h
--- src-old/mame/includes/dooyong.h	2008-11-08 14:09:42.000000000 -0800
+++ src/mame/includes/dooyong.h	2010-08-23 12:39:46.000000000 -0700
@@ -1,6 +1,7 @@
 /*----------- defined in video/dooyong.c -----------*/
 
 extern UINT8 *dooyong_txvideoram;
+extern UINT8 *paletteram_flytiger;
 
 WRITE8_HANDLER( dooyong_bgscroll8_w );
 WRITE8_HANDLER( dooyong_fgscroll8_w );
@@ -16,6 +17,7 @@
 WRITE8_HANDLER( lastday_ctrl_w );
 WRITE8_HANDLER( pollux_ctrl_w );
 WRITE8_HANDLER( primella_ctrl_w );
+WRITE8_HANDLER( paletteram_flytiger_w );
 WRITE8_HANDLER( flytiger_ctrl_w );
 WRITE16_HANDLER( rshark_ctrl_w );
 
diff -Nru src-old/mame/includes/eolithsp.h src/mame/includes/eolithsp.h
--- src-old/mame/includes/eolithsp.h	2008-12-11 02:40:22.000000000 -0800
+++ src/mame/includes/eolithsp.h	2010-08-19 00:26:14.000000000 -0700
@@ -1,6 +1,6 @@
 /*----------- defined in drivers/eolithsp.c -----------*/
 
-void eolith_speedup_read(const address_space *space);
+void eolith_speedup_read(address_space *space);
 void init_eolith_speedup(running_machine *machine);
 INTERRUPT_GEN( eolith_speedup );
 CUSTOM_INPUT( eolith_speedup_getvblank );
diff -Nru src-old/mame/includes/exterm.h src/mame/includes/exterm.h
--- src-old/mame/includes/exterm.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/exterm.h	2010-08-19 00:26:14.000000000 -0700
@@ -12,7 +12,7 @@
 PALETTE_INIT( exterm );
 void exterm_scanline_update(screen_device &screen, bitmap_t *bitmap, int scanline, const tms34010_display_params *params);
 
-void exterm_to_shiftreg_master(const address_space *space, UINT32 address, UINT16* shiftreg);
-void exterm_from_shiftreg_master(const address_space *space, UINT32 address, UINT16* shiftreg);
-void exterm_to_shiftreg_slave(const address_space *space, UINT32 address, UINT16* shiftreg);
-void exterm_from_shiftreg_slave(const address_space *space, UINT32 address, UINT16* shiftreg);
+void exterm_to_shiftreg_master(address_space *space, UINT32 address, UINT16* shiftreg);
+void exterm_from_shiftreg_master(address_space *space, UINT32 address, UINT16* shiftreg);
+void exterm_to_shiftreg_slave(address_space *space, UINT32 address, UINT16* shiftreg);
+void exterm_from_shiftreg_slave(address_space *space, UINT32 address, UINT16* shiftreg);
diff -Nru src-old/mame/includes/gaelcrpt.h src/mame/includes/gaelcrpt.h
--- src-old/mame/includes/gaelcrpt.h	2008-12-11 02:40:22.000000000 -0800
+++ src/mame/includes/gaelcrpt.h	2010-08-19 00:26:14.000000000 -0700
@@ -1,3 +1,3 @@
 /*----------- defined in machine/gaelcrpt.c -----------*/
 
-UINT16 gaelco_decrypt(const address_space *space, int offset, int data, int param1, int param2);
+UINT16 gaelco_decrypt(address_space *space, int offset, int data, int param1, int param2);
diff -Nru src-old/mame/includes/galaxian.h src/mame/includes/galaxian.h
--- src-old/mame/includes/galaxian.h	2010-06-17 07:04:37.000000000 -0700
+++ src/mame/includes/galaxian.h	2010-08-26 08:21:19.000000000 -0700
@@ -56,7 +56,7 @@
 
 WRITE8_HANDLER( galaxian_gfxbank_w );
 
-TIMER_CALLBACK( galaxian_stars_blink_timer );
+TIMER_DEVICE_CALLBACK( galaxian_stars_blink_timer );
 
 /* video extension callbacks */
 typedef void (*galaxian_extend_tile_info_func)(UINT16 *code, UINT8 *color, UINT8 attrib, UINT8 x);
diff -Nru src-old/mame/includes/harddriv.h src/mame/includes/harddriv.h
--- src-old/mame/includes/harddriv.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/harddriv.h	2010-08-19 06:30:03.000000000 -0700
@@ -75,10 +75,6 @@
 	UINT16 *				gsp_paletteram_hi;
 	size_t					gsp_vram_size;
 
-	/* driver state */
-	UINT32 *				rddsp32_speedup;
-	offs_t					rddsp32_speedup_pc;
-
 	/* machine state */
 	UINT8					irq_state;
 	UINT8					gsp_irq_state;
@@ -338,8 +334,8 @@
 /*----------- defined in video/harddriv.c -----------*/
 
 VIDEO_START( harddriv );
-void hdgsp_write_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
-void hdgsp_read_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
+void hdgsp_write_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
+void hdgsp_read_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
 
 READ16_HANDLER( hdgsp_control_lo_r );
 WRITE16_HANDLER( hdgsp_control_lo_w );
diff -Nru src-old/mame/includes/hng64.h src/mame/includes/hng64.h
--- src-old/mame/includes/hng64.h	2009-12-16 22:05:10.000000000 -0800
+++ src/mame/includes/hng64.h	2010-08-26 20:55:49.000000000 -0700
@@ -3,9 +3,106 @@
 #define RACING_MCU 3
 #define SAMSHO_MCU 4
 
-/*----------- defined in drivers/hng64.c -----------*/
+class hng64_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, hng64_state(machine)); }
 
-extern int hng64_mcu_type;
+	hng64_state(running_machine &machine)
+		: driver_data_t(machine) { }
 
+	int mcu_type;
+	UINT32 *mainram;
+	UINT32 *cart;
+	UINT32 *rombase;
+
+	UINT32 *dualport;
+	UINT16 *soundram;
+	UINT32 *sysregs;
+
+	/* Communications stuff */
+	UINT32 *com_ram;
+	UINT8  *com_op_base;
+	UINT8  *com_mmu_mem;
+	UINT8  *com_virtual_mem;
+	UINT32 com_shared_a;
+	UINT32 com_shared_b;
+
+	INT32 dma_start;
+	INT32 dma_dst;
+	INT32 dma_len;
+
+	UINT32 mcu_fake_time;
+	UINT16 mcu_en;
+
+	UINT32 activeBuffer;
+	UINT32 no_machine_error_code;
+	int interrupt_level_request;
+
+	UINT32 unk_vreg_toggle;
+	UINT32 p1_trig;
+
+	/* 3D stuff */
+	UINT32 *_3d_1;
+	UINT32 *_3d_2;
+	UINT32 *dl;
+	//UINT32 *q2;
+
+	UINT32 *spriteram;
+	UINT32 *videoregs;
+	UINT32 *spriteregs;
+	UINT32 *videoram;
+	UINT32 *tcram;
+	UINT32 *_3dregs;
+	UINT8 screen_dis;
+
+	tilemap_t *tilemap0_8x8;
+	tilemap_t *tilemap1_8x8;
+	tilemap_t *tilemap2_8x8;
+	tilemap_t *tilemap3_8x8;
+
+	tilemap_t *tilemap0_16x16;
+	tilemap_t *tilemap1_16x16;
+	tilemap_t *tilemap2_16x16;
+	tilemap_t *tilemap3_16x16;
+
+	tilemap_t *tilemap0_16x16_alt;
+	tilemap_t *tilemap1_16x16_alt;
+	tilemap_t *tilemap2_16x16_alt;
+	tilemap_t *tilemap3_16x16_alt;
+
+	UINT8 additive_tilemap_debug;
+
+	// 3d display buffers
+	// (Temporarily global - someday they will live with the proper bit-depth in the memory map)
+	float *depthBuffer3d;
+	UINT32 *colorBuffer3d;
+
+	UINT32 old_animmask;
+	UINT32 old_animbits;
+	UINT16 old_tileflags0;
+	UINT16 old_tileflags1;
+	UINT16 old_tileflags2;
+	UINT16 old_tileflags3;
+
+	UINT32 dls[2][0x81];
+
+	// 3d State
+	int paletteState3d;
+	float projectionMatrix[16];
+	float modelViewMatrix[16];
+	float cameraMatrix[16];
+
+	float lightStrength;
+	float lightVector[3];
+
+};
+
+
+/*----------- defined in video/hng64.c -----------*/
+
+WRITE32_HANDLER( hng64_videoram_w );
 void hng64_command3d(running_machine* machine, const UINT16* packet);
 
+VIDEO_START( hng64 );
+VIDEO_UPDATE( hng64 );
diff -Nru src-old/mame/includes/jpmimpct.h src/mame/includes/jpmimpct.h
--- src-old/mame/includes/jpmimpct.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/jpmimpct.h	2010-08-19 00:26:14.000000000 -0700
@@ -11,8 +11,8 @@
 READ16_HANDLER( jpmimpct_bt477_r );
 WRITE16_HANDLER( jpmimpct_bt477_w );
 
-void jpmimpct_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
-void jpmimpct_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
+void jpmimpct_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
+void jpmimpct_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
 void jpmimpct_scanline_update(screen_device &screen, bitmap_t *bitmap, int scanline, const tms34010_display_params *params);
 
 VIDEO_START( jpmimpct );
diff -Nru src-old/mame/includes/karnov.h src/mame/includes/karnov.h
--- src-old/mame/includes/karnov.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/karnov.h	2010-08-23 08:56:38.000000000 -0700
@@ -39,8 +39,8 @@
 	KARNOV = 0,
 	KARNOVJ,
 	CHELNOV,
+	CHELNOVU,
 	CHELNOVJ,
-	CHELNOVW,
 	WNDRPLNT
 };
 
diff -Nru src-old/mame/includes/mainsnk.h src/mame/includes/mainsnk.h
--- src-old/mame/includes/mainsnk.h	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/includes/mainsnk.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,26 @@
+class mainsnk_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, mainsnk_state(machine)); }
+
+	mainsnk_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	tilemap_t *tx_tilemap;
+	tilemap_t *bg_tilemap;
+	UINT8 *spriteram;
+	UINT8 *fgram;
+	UINT8 *bgram;
+
+	int sound_cpu_busy;
+	UINT32 bg_tile_offset;
+};
+
+
+/*----------- defined in video/mainsnk.c -----------*/
+
+WRITE8_HANDLER(mainsnk_c600_w);
+WRITE8_HANDLER(mainsnk_fgram_w);
+WRITE8_HANDLER(mainsnk_bgram_w);
+VIDEO_START(mainsnk);
+VIDEO_UPDATE(mainsnk);
diff -Nru src-old/mame/includes/midtunit.h src/mame/includes/midtunit.h
--- src-old/mame/includes/midtunit.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/midtunit.h	2010-08-19 00:26:14.000000000 -0700
@@ -47,8 +47,8 @@
 READ16_HANDLER( midtunit_vram_data_r );
 READ16_HANDLER( midtunit_vram_color_r );
 
-void midtunit_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
-void midtunit_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
+void midtunit_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
+void midtunit_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
 
 WRITE16_HANDLER( midtunit_control_w );
 WRITE16_HANDLER( midwunit_control_w );
diff -Nru src-old/mame/includes/midyunit.h src/mame/includes/midyunit.h
--- src-old/mame/includes/midyunit.h	2010-07-21 08:57:43.000000000 -0700
+++ src/mame/includes/midyunit.h	2010-08-19 00:26:14.000000000 -0700
@@ -54,8 +54,8 @@
 WRITE16_HANDLER( midyunit_vram_w );
 READ16_HANDLER( midyunit_vram_r );
 
-void midyunit_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
-void midyunit_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg);
+void midyunit_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
+void midyunit_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg);
 
 WRITE16_HANDLER( midyunit_control_w );
 WRITE16_HANDLER( midyunit_paletteram_w );
diff -Nru src-old/mame/includes/model3.h src/mame/includes/model3.h
--- src-old/mame/includes/model3.h	2010-01-07 23:05:29.000000000 -0800
+++ src/mame/includes/model3.h	2010-08-19 00:26:14.000000000 -0700
@@ -36,8 +36,8 @@
 WRITE64_HANDLER(real3d_display_list_w);
 WRITE64_HANDLER(real3d_polygon_ram_w);
 void real3d_display_list_end(running_machine *machine);
-void real3d_display_list1_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
-void real3d_display_list2_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
-void real3d_vrom_texture_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
-void real3d_texture_fifo_dma(const address_space *space, UINT32 src, int length, int byteswap);
-void real3d_polygon_ram_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
+void real3d_display_list1_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
+void real3d_display_list2_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
+void real3d_vrom_texture_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
+void real3d_texture_fifo_dma(address_space *space, UINT32 src, int length, int byteswap);
+void real3d_polygon_ram_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap);
diff -Nru src-old/mame/includes/neogeo.h src/mame/includes/neogeo.h
--- src-old/mame/includes/neogeo.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/neogeo.h	2010-08-19 00:26:14.000000000 -0700
@@ -116,10 +116,10 @@
 /*----------- defined in drivers/neogeo.c -----------*/
 
 void neogeo_set_display_position_interrupt_control(running_machine *machine, UINT16 data);
-void neogeo_set_display_counter_msb(const address_space *space, UINT16 data);
-void neogeo_set_display_counter_lsb(const address_space *space, UINT16 data);
+void neogeo_set_display_counter_msb(address_space *space, UINT16 data);
+void neogeo_set_display_counter_lsb(address_space *space, UINT16 data);
 void neogeo_acknowledge_interrupt(running_machine *machine, UINT16 data);
-void neogeo_set_main_cpu_bank_address(const address_space *space, UINT32 bank_address);
+void neogeo_set_main_cpu_bank_address(address_space *space, UINT32 bank_address);
 READ16_HANDLER( neogeo_unmapped_r );
 
 
diff -Nru src-old/mame/includes/ojankohs.h src/mame/includes/ojankohs.h
--- src-old/mame/includes/ojankohs.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/ojankohs.h	2010-08-19 00:26:14.000000000 -0700
@@ -57,5 +57,5 @@
 VIDEO_UPDATE( ojankohs );
 VIDEO_UPDATE( ojankoc );
 
-void ojankoc_flipscreen(const address_space *space, int data);
+void ojankoc_flipscreen(address_space *space, int data);
 
diff -Nru src-old/mame/includes/plygonet.h src/mame/includes/plygonet.h
--- src-old/mame/includes/plygonet.h	2010-08-08 00:07:15.000000000 -0700
+++ src/mame/includes/plygonet.h	2010-08-18 23:57:51.000000000 -0700
@@ -18,7 +18,7 @@
 	UINT16* dsp56k_bank04_ram;
 	int cur_sound_region;
 
-	direct_update_func dsp56k_update_handler;
+	direct_update_delegate dsp56k_update_handler;
 
 	/* TTL text plane stuff */
 	int ttl_gfx_index;
diff -Nru src-old/mame/includes/prehisle.h src/mame/includes/prehisle.h
--- src-old/mame/includes/prehisle.h	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/includes/prehisle.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,29 @@
+class prehisle_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, prehisle_state(machine)); }
+
+	prehisle_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+
+	UINT16 *spriteram;
+	UINT16 *videoram;
+	UINT16 *bg_videoram16;
+	UINT16 invert_controls;
+
+	tilemap_t *bg2_tilemap;
+	tilemap_t *bg_tilemap;
+	tilemap_t *fg_tilemap;
+};
+
+
+/*----------- defined in video/prehisle.c -----------*/
+
+WRITE16_HANDLER( prehisle_bg_videoram16_w );
+WRITE16_HANDLER( prehisle_fg_videoram16_w );
+WRITE16_HANDLER( prehisle_control16_w );
+READ16_HANDLER( prehisle_control16_r );
+
+VIDEO_START( prehisle );
+VIDEO_UPDATE( prehisle );
diff -Nru src-old/mame/includes/segag80v.h src/mame/includes/segag80v.h
--- src-old/mame/includes/segag80v.h	2009-02-11 12:48:39.000000000 -0800
+++ src/mame/includes/segag80v.h	2010-08-13 01:54:21.000000000 -0700
@@ -17,5 +17,8 @@
 
 /*----------- defined in video/segag80v.c -----------*/
 
-VIDEO_START( sega );
-VIDEO_UPDATE( sega );
+extern UINT8 *segag80v_vectorram;
+extern size_t segag80v_vectorram_size;
+
+VIDEO_START( segag80v );
+VIDEO_UPDATE( segag80v );
diff -Nru src-old/mame/includes/segas24.h src/mame/includes/segas24.h
--- src-old/mame/includes/segas24.h	2009-10-20 22:20:23.000000000 -0700
+++ src/mame/includes/segas24.h	2010-08-19 00:26:14.000000000 -0700
@@ -9,7 +9,7 @@
 
 void system24temp_sys16_io_set_callbacks(UINT8 (*io_r)(running_machine *machine, int port),
 							void  (*io_w)(running_machine *machine, int port, UINT8 data),
-							void  (*cnt_w)(const address_space *space, UINT8 data),
+							void  (*cnt_w)(address_space *space, UINT8 data),
 							read16_space_func iod_r,
 							write16_space_func iod_w);
 READ16_HANDLER ( system24temp_sys16_io_r );
diff -Nru src-old/mame/includes/seta.h src/mame/includes/seta.h
--- src-old/mame/includes/seta.h	2010-08-04 08:58:29.000000000 -0700
+++ src/mame/includes/seta.h	2010-08-13 01:28:37.000000000 -0700
@@ -51,6 +51,7 @@
 	tilemap_t *tilemap_3;	// Layer 1
 	int tilemaps_flip;
 	int samples_bank;
+	int taitox_banknum;
 
 	uPD71054_state uPD71054;
 	const game_offset *global_offsets;
diff -Nru src-old/mame/includes/slapstic.h src/mame/includes/slapstic.h
--- src-old/mame/includes/slapstic.h	2008-11-23 17:00:18.000000000 -0800
+++ src/mame/includes/slapstic.h	2010-08-19 00:26:14.000000000 -0700
@@ -15,4 +15,4 @@
 void slapstic_reset(void);
 
 int slapstic_bank(void);
-int slapstic_tweak(const address_space *space, offs_t offset);
+int slapstic_tweak(address_space *space, offs_t offset);
diff -Nru src-old/mame/includes/snk.h src/mame/includes/snk.h
--- src-old/mame/includes/snk.h	2009-10-02 23:53:27.000000000 -0700
+++ src/mame/includes/snk.h	2010-08-26 20:55:49.000000000 -0700
@@ -4,6 +4,43 @@
 
 *************************************************************************/
 
+class snk_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, snk_state(machine)); }
+
+	snk_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	int countryc_trackball;
+	int last_value[2];
+	int cp_count[2];
+
+	int marvins_sound_busy_flag;
+	// FIXME this should be initialised on machine reset
+	int sound_status;
+
+	UINT8 *spriteram;
+	UINT8 *tx_videoram;
+	UINT8 *fg_videoram;
+	UINT8 *bg_videoram;
+
+	tilemap_t *tx_tilemap;
+	tilemap_t *fg_tilemap;
+	tilemap_t *bg_tilemap;
+	int fg_scrollx, fg_scrolly, bg_scrollx, bg_scrolly;
+	int sp16_scrollx, sp16_scrolly, sp32_scrollx, sp32_scrolly;
+	UINT8 sprite_split_point;
+	int num_sprites, yscroll_mask;
+	UINT32 bg_tile_offset;
+	UINT32 tx_tile_offset;
+	int is_psychos;
+
+	UINT8 drawmode_table[16];
+	UINT8 empty_tile[16*16];
+};
+
+
 /*----------- defined in video/snk.c -----------*/
 
 extern PALETTE_INIT( tnk3 );
@@ -55,9 +92,6 @@
 extern WRITE8_HANDLER( tdfever_sp_scroll_msb_w );
 extern WRITE8_HANDLER( tdfever_spriteram_w );
 
-extern UINT8 *snk_tx_videoram;
-extern UINT8 *snk_fg_videoram;
-extern UINT8 *snk_bg_videoram;
 extern WRITE8_HANDLER( snk_tx_videoram_w );
 extern WRITE8_HANDLER( snk_bg_videoram_w );
 extern WRITE8_HANDLER( marvins_fg_videoram_w );
diff -Nru src-old/mame/includes/snk6502.h src/mame/includes/snk6502.h
--- src-old/mame/includes/snk6502.h	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/includes/snk6502.h	2010-08-26 20:55:49.000000000 -0700
@@ -10,6 +10,30 @@
 #include "sound/sn76477.h"
 
 
+class snk6502_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, snk6502_state(machine)); }
+
+	snk6502_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	UINT8 sasuke_counter;
+
+	UINT8 *videoram;
+	UINT8 *colorram;
+	UINT8 *videoram2;
+	UINT8 *charram;
+
+	int charbank;
+	int backcolor;
+	tilemap_t *bg_tilemap;
+	tilemap_t *fg_tilemap;
+
+	rgb_t palette[64];
+};
+
+
 /*----------- defined in audio/snk6502.c -----------*/
 
 extern const samples_interface sasuke_samples_interface;
@@ -32,20 +56,15 @@
 
 DECLARE_LEGACY_SOUND_DEVICE(SNK6502, snk6502_sound);
 
-void snk6502_set_music_clock(double clock_time);
-void snk6502_set_music_freq(int freq);
-int snk6502_music0_playing(void);
+void snk6502_set_music_clock(running_machine *machine, double clock_time);
+void snk6502_set_music_freq(running_machine *machine, int freq);
+int snk6502_music0_playing(running_machine *machine);
 
 DISCRETE_SOUND_EXTERN( fantasy );
 
 
 /*----------- defined in video/snk6502.c -----------*/
 
-extern UINT8 *snk6502_videoram;
-extern UINT8 *snk6502_colorram;
-extern UINT8 *snk6502_videoram2;
-extern UINT8 *snk6502_charram;
-
 WRITE8_HANDLER( snk6502_videoram_w );
 WRITE8_HANDLER( snk6502_videoram2_w );
 WRITE8_HANDLER( snk6502_colorram_w );
@@ -57,6 +76,7 @@
 PALETTE_INIT( snk6502 );
 VIDEO_START( snk6502 );
 VIDEO_UPDATE( snk6502 );
+VIDEO_START( pballoon );
 
 WRITE8_HANDLER( satansat_b002_w );
 WRITE8_HANDLER( satansat_backcolor_w );
diff -Nru src-old/mame/includes/snk68.h src/mame/includes/snk68.h
--- src-old/mame/includes/snk68.h	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/includes/snk68.h	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,35 @@
+class snk68_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, snk68_state(machine)); }
+
+	snk68_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	int invert_controls;
+	int sound_status;
+
+	UINT16* pow_fg_videoram;
+
+	UINT16 *spriteram;
+	UINT16 *paletteram;
+	int sprite_flip_axis;
+	tilemap_t *fg_tilemap;
+	int flipscreen;
+	UINT32 fg_tile_offset;
+};
+
+
+/*----------- defined in video/snk68.c -----------*/
+
+VIDEO_START( pow );
+VIDEO_START( searchar );
+VIDEO_UPDATE( pow );
+WRITE16_HANDLER( pow_paletteram16_word_w );
+WRITE16_HANDLER( pow_flipscreen16_w );
+WRITE16_HANDLER( searchar_flipscreen16_w );
+READ16_HANDLER( pow_spriteram_r );
+WRITE16_HANDLER( pow_spriteram_w );
+READ16_HANDLER( pow_fg_videoram_r );
+WRITE16_HANDLER( pow_fg_videoram_w );
+WRITE16_HANDLER( searchar_fg_videoram_w );
diff -Nru src-old/mame/includes/toaplan1.h src/mame/includes/toaplan1.h
--- src-old/mame/includes/toaplan1.h	2010-03-10 08:14:45.000000000 -0800
+++ src/mame/includes/toaplan1.h	2010-08-30 08:20:58.000000000 -0700
@@ -4,6 +4,88 @@
 ****************************************************************************/
 
 
+class toaplan1_state : public driver_data_t
+{
+public:
+	static driver_data_t *alloc(running_machine &machine) { return auto_alloc_clear(&machine, toaplan1_state(machine)); }
+
+	toaplan1_state(running_machine &machine)
+		: driver_data_t(machine) { }
+
+	int unk_reset_port;
+	UINT16 *colorram1;
+	UINT16 *colorram2;
+	size_t colorram1_size;
+	size_t colorram2_size;
+
+	UINT8 *sharedram;
+
+	int coin_count; /* coin count increments on startup ? , so dont count it */
+	int intenable;
+
+	/* Demon world */
+	int dsp_on;
+	int dsp_BIO;
+	int dsp_execute;
+	UINT32 dsp_addr_w;
+	UINT32 main_ram_seg;
+
+	UINT8 vimana_coins[2];
+	UINT8 vimana_credits;
+	UINT8 vimana_latch;
+
+	UINT16 *pf4_tilevram16;	/*  ||  Drawn in this order */
+	UINT16 *pf3_tilevram16;	/*  ||  */
+	UINT16 *pf2_tilevram16;	/* \||/ */
+	UINT16 *pf1_tilevram16;	/*  \/  */
+
+	size_t spriteram_size;
+	UINT16 *spriteram;
+	UINT16 *buffered_spriteram;
+	UINT16 *spritesizeram16;
+	UINT16 *buffered_spritesizeram16;
+
+	INT32 bcu_flipscreen;		/* Tile   controller flip flag */
+	INT32 fcu_flipscreen;		/* Sprite controller flip flag */
+
+	INT32 pf_voffs;
+	INT32 spriteram_offs;
+
+	INT32 pf1_scrollx;
+	INT32 pf1_scrolly;
+	INT32 pf2_scrollx;
+	INT32 pf2_scrolly;
+	INT32 pf3_scrollx;
+	INT32 pf3_scrolly;
+	INT32 pf4_scrollx;
+	INT32 pf4_scrolly;
+	INT32 scrollx_offs1;
+	INT32 scrollx_offs2;
+	INT32 scrollx_offs3;
+	INT32 scrollx_offs4;
+	INT32 scrolly_offs;
+
+
+#ifdef MAME_DEBUG
+	int display_pf1;
+	int display_pf2;
+	int display_pf3;
+	int display_pf4;
+	int displog;
+#endif
+
+	INT32 tiles_offsetx;
+	INT32 tiles_offsety;
+
+	int reset;		/* Hack! See toaplan1_bcu_control below */
+
+	tilemap_t *pf1_tilemap, *pf2_tilemap, *pf3_tilemap, *pf4_tilemap;
+
+	// an empty tile, so that we can safely disable tiles
+	UINT8        empty_tile[8*8];
+};
+
+
 /*----------- defined in machine/toaplan1.c -----------*/
 
 INTERRUPT_GEN( toaplan1_interrupt );
@@ -31,15 +113,9 @@
 MACHINE_RESET( vimana );
 MACHINE_RESET( zerowing );	/* hack for ZeroWing/OutZone. See video */
 
-extern void toaplan1_driver_savestate(running_machine *machine);
-extern void demonwld_driver_savestate(running_machine *machine);
-extern void vimana_driver_savestate(running_machine *machine);
-
-
-extern int toaplan1_unk_reset_port;
-
-extern UINT8 *toaplan1_sharedram;
-
+void toaplan1_driver_savestate(running_machine *machine);
+void demonwld_driver_savestate(running_machine *machine);
+void vimana_driver_savestate(running_machine *machine);
 
 
 /*----------- defined in video/toaplan1.c -----------*/
@@ -78,9 +154,3 @@
 VIDEO_UPDATE( rallybik );
 VIDEO_UPDATE( toaplan1 );
 VIDEO_UPDATE( demonwld );
-
-
-extern UINT16 *toaplan1_colorram1;
-extern UINT16 *toaplan1_colorram2;
-extern size_t toaplan1_colorram1_size;
-extern size_t toaplan1_colorram2_size;
diff -Nru src-old/mame/includes/toaplan2.h src/mame/includes/toaplan2.h
--- src-old/mame/includes/toaplan2.h	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/includes/toaplan2.h	2010-08-23 03:13:59.000000000 -0700
@@ -1,7 +1,17 @@
+/**************** Machine stuff ******************/
+//#define USE_HD64x180          /* Define if CPU support is available */
+//#define USE_ENCRYPTED_V25S    /* Define to enable V25 even on games where it is encrypted */
+
+/* sub cpu */
+#define CPU_2_NONE		0x00
+#define CPU_2_Z80		0x5a
+#define CPU_2_HD647180	0xa5
+#define CPU_2_V25		0xff
+
 /* vdp related */
 
 // mixing debug, render each VDP to it's own screen - be sure to recompile both driver and video after changing
-#define DUAL_SCREEN_VDPS
+//#define DUAL_SCREEN_VDPS
 
 #include "video/gp9001.h"
 
@@ -20,6 +30,48 @@
 
 	gp9001vdp_device* vdp0;
 	gp9001vdp_device* vdp1;
+
+	UINT8 *z80_shared_ram;
+	UINT16 *shared_ram16;	/* Really 8bit RAM connected to Z180 */
+
+#ifndef USE_ENCRYPTED_V25S
+	UINT16 *V25_shared_ram;			/* Really 8bit RAM connected to Z180 */
+#endif
+	UINT8* batsugun_share;
+#ifdef USE_ENCRYPTED_V25S
+	UINT8* batsugun_share2;
+#endif
+
+	int sub_cpu_type;
+	running_device *sub_cpu;
+
+	UINT16 mcu_data;
+	UINT16 video_status;
+	INT8 old_p1_paddle_h;		/* For Ghox */
+	INT8 old_p2_paddle_h;
+	INT8 current_bank;			/* Z80 bank used in Battle Garegga and Batrider */
+
+	int sndirq_line;		/* IRQ4 for batrider, IRQ2 for bbakraid */
+	UINT16 z80_busreq;
+	int unlimited_ver;
+
+	UINT16 *txvideoram16;
+	UINT16 *txvideoram16_offs;
+	UINT16 *txscrollram16;
+	UINT16 *tx_gfxram16;
+
+	size_t tx_vram_size;
+	size_t tx_offs_vram_size;
+	size_t tx_scroll_vram_size;
+	size_t paletteram16_size;
+
+	bitmap_t* custom_priority_bitmap;
+	bitmap_t* secondary_render_bitmap;
+
+	tilemap_t *tx_tilemap;	/* Tilemap for extra-text-layer */
+	UINT8 tx_flip;
+	int display_tx;
+	int displog;
 };
 
 
@@ -30,22 +82,9 @@
 void fixeight_okisnd_w(running_device *device, int data);
 void batsugun_okisnd_w(running_device *device, int data);
 
-/*----------- defined in drivers/toaplan2.c -----------*/
-
-extern int toaplan2_sub_cpu;
 
 /*----------- defined in video/toaplan2.c -----------*/
 
-extern UINT16 *toaplan2_txvideoram16;
-extern UINT16 *toaplan2_txvideoram16_offs;
-extern UINT16 *toaplan2_txscrollram16;
-extern UINT16 *toaplan2_tx_gfxram16;
-
-extern  size_t toaplan2_tx_vram_size;
-extern  size_t toaplan2_tx_offs_vram_size;
-extern  size_t toaplan2_tx_scroll_vram_size;
-extern  size_t batrider_paletteram16_size;
-
 VIDEO_EOF( toaplan2 );
 VIDEO_START( toaplan2 );
 VIDEO_START( truxton2 );
diff -Nru src-old/mame/includes/trackfld.h src/mame/includes/trackfld.h
--- src-old/mame/includes/trackfld.h	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/includes/trackfld.h	2010-08-30 08:20:58.000000000 -0700
@@ -32,7 +32,7 @@
 	tilemap_t  *bg_tilemap;
 	int      bg_bank, sprite_bank1, sprite_bank2;	// trackfld
 	int      old_gfx_bank;					// needed by atlantol
-
+	int		 sprites_gfx_banked;
 
 	/* sound-related */
 	int      SN76496_latch;
@@ -81,7 +81,7 @@
 PALETTE_INIT( trackfld );
 VIDEO_START( trackfld );
 VIDEO_UPDATE( trackfld );
-
+VIDEO_START( atlantol );
 
 /*----------- defined in video/hyperspt.c -----------*/
 
@@ -94,7 +94,6 @@
 VIDEO_UPDATE( hyperspt );
 VIDEO_START( roadf );
 
-
 /*----------- defined in video/sbasketb.c -----------*/
 
 WRITE8_HANDLER( sbasketb_videoram_w );
diff -Nru src-old/mame/includes/williams.h src/mame/includes/williams.h
--- src-old/mame/includes/williams.h	2009-12-22 00:10:15.000000000 -0800
+++ src/mame/includes/williams.h	2010-08-19 00:26:14.000000000 -0700
@@ -9,7 +9,7 @@
 
 /*----------- defined in drivers/williams.c -----------*/
 
-void defender_install_io_space(const address_space *space);
+void defender_install_io_space(address_space *space);
 
 
 /*----------- defined in machine/williams.c -----------*/
diff -Nru src-old/mame/machine/amiga.c src/mame/machine/amiga.c
--- src-old/mame/machine/amiga.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/machine/amiga.c	2010-08-19 01:27:05.000000000 -0700
@@ -293,7 +293,7 @@
 
 static void amiga_m68k_reset(running_device *device)
 {
-	const address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
 
 	logerror("Executed RESET at PC=%06x\n", cpu_get_pc(space->cpu));
 
@@ -306,7 +306,7 @@
 	/* set the overlay bit */
 	if ( IS_AGA(amiga_intf) )
 	{
-		memory_write_byte( space, 0xbfa001, 1 );
+		space->write_byte( 0xbfa001, 1 );
 	}
 	else
 	{
@@ -973,7 +973,7 @@
  *
  *************************************/
 
-static void blitter_setup(const address_space *space)
+static void blitter_setup(address_space *space)
 {
 	int ticks, width, height, blittime;
 
@@ -1535,7 +1535,7 @@
 
 void amiga_serial_in_w(running_machine *machine, UINT16 data)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int mask = (CUSTOM_REG(REG_SERPER) & 0x8000) ? 0x1ff : 0xff;
 
 	/* copy the data to the low 8 bits of SERDATR and set RBF */
diff -Nru src-old/mame/machine/archimds.c src/mame/machine/archimds.c
--- src-old/mame/machine/archimds.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/archimds.c	2010-08-30 08:20:58.000000000 -0700
@@ -30,6 +30,8 @@
 #include "cpu/arm/arm.h"
 #include "sound/dac.h"
 #include "includes/archimds.h"
+#include "machine/i2cmem.h"
+#include "debugger.h"
 
 #ifdef MESS
 #include "machine/wd17xx.h"
@@ -37,22 +39,33 @@
 
 static const int page_sizes[4] = { 4096, 8192, 16384, 32768 };
 
+#define IOC_LOG 0
+
 UINT32 *archimedes_memc_physmem;
 static UINT32 memc_pagesize;
 static int memc_latchrom;
-static INT16 memc_pages[(32*1024*1024)/(4096)];	// the logical RAM area is 32 megs, and the smallest page size is 4k
-static UINT32 vidc_regs[256];
-static UINT8 ioc_regs[0x80/4];
 static UINT32 ioc_timercnt[4], ioc_timerout[4];
+static UINT32 vidc_vidstart, vidc_vidend, vidc_vidinit,vidc_vidcur;
 static UINT32 vidc_sndstart, vidc_sndend, vidc_sndcur;
+static UINT8 video_dma_on,audio_dma_on;
+UINT8 i2c_clk;
+INT16 memc_pages[0x2000];	// the logical RAM area is 32 megs, and the smallest page size is 4k
+UINT32 vidc_regs[256];
+UINT8 ioc_regs[0x80/4];
+UINT8 vidc_bpp_mode;
+UINT8 vidc_interlace;
+static UINT8 vidc_pixel_clk;
+static const UINT32 pixel_rate[4] = { 8000000, 12000000, 16000000, 24000000};
+static UINT8 vidc_stereo_reg[8];
 
-static emu_timer *vbl_timer, *timer[4], *snd_timer;
+static emu_timer *timer[4], *snd_timer, *vid_timer;
+emu_timer  *vbl_timer;
 
 void archimedes_request_irq_a(running_machine *machine, int mask)
 {
-	ioc_regs[4] |= mask;
+	ioc_regs[IRQ_STATUS_A] |= mask;
 
-	if (ioc_regs[6] & mask)
+	if (ioc_regs[IRQ_MASK_A] & mask)
 	{
 		cputag_set_input_line(machine, "maincpu", ARM_IRQ_LINE, ASSERT_LINE);
 	}
@@ -60,37 +73,37 @@
 
 void archimedes_request_irq_b(running_machine *machine, int mask)
 {
-	ioc_regs[8] |= mask;
+	ioc_regs[IRQ_STATUS_B] |= mask;
 
-	if (ioc_regs[10] & mask)
+	if (ioc_regs[IRQ_MASK_B] & mask)
 	{
-		cputag_set_input_line(machine, "maincpu", ARM_IRQ_LINE, PULSE_LINE);
+		generic_pulse_irq_line(machine->device("maincpu"), ARM_IRQ_LINE);
 	}
 }
 
 void archimedes_request_fiq(running_machine *machine, int mask)
 {
-	ioc_regs[12] |= mask;
+	ioc_regs[FIQ_STATUS] |= mask;
 
-	if (ioc_regs[14] & mask)
+	if (ioc_regs[FIQ_MASK] & mask)
 	{
-		cputag_set_input_line(machine, "maincpu", ARM_FIRQ_LINE, PULSE_LINE);
+		generic_pulse_irq_line(machine->device("maincpu"), ARM_FIRQ_LINE);
 	}
 }
 
 void archimedes_clear_irq_a(running_machine *machine, int mask)
 {
-	ioc_regs[4] &= ~mask;
+	ioc_regs[IRQ_STATUS_A] &= ~mask;
 }
 
 void archimedes_clear_irq_b(running_machine *machine, int mask)
 {
-	ioc_regs[8] &= ~mask;
+	ioc_regs[IRQ_STATUS_B] &= ~mask;
 }
 
 void archimedes_clear_fiq(running_machine *machine, int mask)
 {
-	ioc_regs[12] &= ~mask;
+	ioc_regs[FIQ_STATUS] &= ~mask;
 }
 
 static TIMER_CALLBACK( vidc_vblank )
@@ -101,13 +114,58 @@
 	timer_adjust_oneshot(vbl_timer, machine->primary_screen->time_until_pos(vidc_regs[0xb4]), 0);
 }
 
-static TIMER_CALLBACK( a310_audio_tick )
+/* video DMA */
+/* TODO: what type of DMA this is, burst or cycle steal? Docs doesn't explain it (4 usec is the DRAM refresh). */
+static TIMER_CALLBACK( vidc_video_tick )
 {
-	vidc_sndcur++;
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	static UINT8 *vram = memory_region(machine,"vram");
+	UINT32 size;
+
+	size = vidc_vidend-vidc_vidstart+0x10;
 
-	if (vidc_sndcur >= vidc_sndend)
+	for(vidc_vidcur = 0;vidc_vidcur < size;vidc_vidcur++)
+		vram[vidc_vidcur] = (space->read_byte(vidc_vidstart+vidc_vidcur+vidc_vidinit));
+
+	if(video_dma_on)
+		timer_adjust_oneshot(vid_timer, space->machine->primary_screen->time_until_pos(vidc_regs[0xb4]), 0);
+	else
+		timer_adjust_oneshot(vid_timer, attotime_never, 0);
+}
+
+/* audio DMA */
+static TIMER_CALLBACK( vidc_audio_tick )
+{
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	UINT8 ulaw_comp;
+	INT16 res;
+	UINT8 ch;
+	static const char *const dac_port[8] = { "dac0", "dac1", "dac2", "dac3", "dac4", "dac5", "dac6", "dac7" };
+
+	for(ch=0;ch<8;ch++)
 	{
+		ulaw_comp = (space->read_byte(vidc_sndstart+vidc_sndcur + ch));
+
+		res=1<<((ulaw_comp>>5)+4);
+    	res+=(((ulaw_comp>>1)&0xF)<<(ulaw_comp>>5));
+    	if (ulaw_comp&1) res=-res;
+
+		dac_signed_data_16_w(space->machine->device(dac_port[ch & 7]), res);
+	}
+
+	vidc_sndcur+=8;
+
+	if (vidc_sndcur >= (vidc_sndend-vidc_sndstart)+0x10)
+	{
+		vidc_sndcur = 0;
 		archimedes_request_irq_b(machine, ARCHIMEDES_IRQB_SOUND_EMPTY);
+
+		if(!audio_dma_on)
+		{
+			timer_adjust_oneshot(snd_timer, attotime_never, 0);
+			for(ch=0;ch<8;ch++)
+				dac_signed_data_16_w(space->machine->device(dac_port[ch & 7]), 0x8000);
+		}
 	}
 }
 
@@ -115,11 +173,20 @@
 {
 	double freq;
 
-	if(ioc_timercnt[tmr] != 0) // FIXME: dmdtouch does a divide by zero?
+	switch(tmr)
 	{
-		freq = 2000000.0 / (double)ioc_timercnt[tmr];
-	//  logerror("IOC: starting timer %d, %d ticks, freq %f Hz\n", tmr, ioc_timercnt[tmr], freq);
-		timer_adjust_oneshot(timer[tmr], ATTOTIME_IN_HZ(freq), tmr);
+		case 0:
+		case 1:
+			timer_adjust_oneshot(timer[tmr], ATTOTIME_IN_USEC(ioc_timercnt[tmr]/8), tmr); // TODO: ARM timings are quite off there, it should be latch and not latch/8
+			break;
+		case 2:
+			freq = 1000000.0 / (double)(ioc_timercnt[tmr]+1);
+			timer_adjust_oneshot(timer[tmr], ATTOTIME_IN_HZ(freq), tmr);
+			break;
+		case 3:
+			freq = 1000000.0 / (double)((ioc_timercnt[tmr]+1)*16);
+			timer_adjust_oneshot(timer[tmr], ATTOTIME_IN_HZ(freq), tmr);
+			break;
 	}
 }
 
@@ -153,6 +220,11 @@
 	{
 		memc_pages[i] = -1;		// indicate unmapped
 	}
+
+	ioc_regs[IRQ_STATUS_A] = 0x10 | 0x80; //set up POR (Power On Reset) and Force IRQ at start-up
+	ioc_regs[IRQ_STATUS_B] = 0x02; //set up IL[1] On
+	ioc_regs[FIQ_STATUS] = 0x80;   //set up Force FIQ
+	ioc_regs[CONTROL] = 0xff;
 }
 
 void archimedes_init(running_machine *machine)
@@ -171,7 +243,8 @@
 	timer_adjust_oneshot(timer[2], attotime_never, 0);
 	timer_adjust_oneshot(timer[3], attotime_never, 0);
 
-	snd_timer = timer_alloc(machine, a310_audio_tick, NULL);
+	vid_timer = timer_alloc(machine, vidc_video_tick, NULL);
+	snd_timer = timer_alloc(machine, vidc_audio_tick, NULL);
 	timer_adjust_oneshot(snd_timer, attotime_never, 0);
 }
 
@@ -202,7 +275,8 @@
 		}
 		else
 		{
-			logerror("ARCHIMEDES_MEMC: Reading unmapped page, what do we do?\n");
+			//printf("ARCHIMEDES_MEMC: Reading unmapped page %02x\n",page);
+			return 0xdeadbeef;
 		}
 	}
 
@@ -232,12 +306,13 @@
 		}
 		else
 		{
-			logerror("ARCHIMEDES_MEMC: Writing unmapped page, what do we do?\n");
+			//printf("ARCHIMEDES_MEMC: Writing unmapped page %02x, what do we do?\n",page);
 		}
 	}
 }
 
-static DIRECT_UPDATE_HANDLER( a310_setopbase )
+#if 0
+DIRECT_UPDATE_HANDLER( a310_setopbase )
 {
 	// if we're not in logical memory, MAME can do the right thing
 	if (address > 0x1ffffff)
@@ -248,27 +323,24 @@
 	// if the boot ROM is mapped in, do some trickery to make it show up
 	if (memc_latchrom)
 	{
-		direct->bytemask = 0x1fffff;
-		direct->bytestart = 0;
-		direct->byteend = 0x1fffff;
-		direct->raw = direct->decrypted = memory_region(space->machine, "maincpu");
+		direct.explicit_configure(0x000000, 0x1fffff, 0x1fffff, *direct.space().m_machine.region("maincpu"));
 	}
 	else	// executing from logical memory
 	{
-		UINT32 page = address / page_sizes[memc_pagesize];
+		offs_t pagesize = page_sizes[memc_pagesize];
+		UINT32 page = address / pagesize;
 
-		direct->bytemask = page_sizes[memc_pagesize]-1;
-		direct->bytestart = page * page_sizes[memc_pagesize];
-		direct->byteend = direct->bytestart + direct->bytemask;
-		direct->raw = direct->decrypted = (UINT8 *)&archimedes_memc_physmem[(memc_pages[page] * page_sizes[memc_pagesize])>>2];
+		direct.explicit_configure(page * pagesize, page * pagesize - 1, pagesize - 1, &archimedes_memc_physmem[(memc_pages[page] * pagesize)>>2]);
 	}
 
 	return ~0;
 }
+#endif
 
 void archimedes_driver_init(running_machine *machine)
 {
-	memory_set_direct_update_handler( cputag_get_address_space( machine, "maincpu", ADDRESS_SPACE_PROGRAM ), a310_setopbase);
+//  address_space *space = machine->device<arm_device>("maincpu")->space(AS_PROGRAM);
+//  space->set_direct_update_handler(direct_update_delegate_create_static(a310_setopbase, *machine));
 }
 
 static const char *const ioc_regnames[] =
@@ -314,182 +386,320 @@
 	ioc_timerout[tmr] = ioc_timercnt[tmr] - (UINT32)time;
 }
 
-READ32_HANDLER(archimedes_ioc_r)
+/* TODO: should be a 8-bit handler */
+static READ32_HANDLER( ioc_ctrl_r )
 {
-	#ifdef MESS
-	running_device *fdc = (running_device *)space->machine->device("wd1772");
-	#endif
-	if (offset >= 0x80000 && offset < 0xc0000)
+	if(IOC_LOG)
+	logerror("IOC: R %s = %02x (PC=%x) %02x\n", ioc_regnames[offset&0x1f], ioc_regs[offset&0x1f], cpu_get_pc( space->cpu ),offset & 0x1f);
+
+	switch (offset & 0x1f)
 	{
-		switch (offset & 0x1f)
+		case CONTROL:
 		{
-			case 1:	// keyboard read
-				archimedes_request_irq_b(space->machine, ARCHIMEDES_IRQB_KBD_XMIT_EMPTY);
-				break;
+			UINT8 i2c_data;
+			static UINT8 flyback; //internal name for vblank here
+			int vert_pos;
 
-			case 16:	// timer 0 read
-				return ioc_timerout[0]&0xff;
-			case 17:
-				return (ioc_timerout[0]>>8)&0xff;
-			case 20:	// timer 1 read
-				return ioc_timerout[1]&0xff;
-			case 21:
-				return (ioc_timerout[1]>>8)&0xff;
-			case 24:	// timer 2 read
-				return ioc_timerout[2]&0xff;
-			case 25:
-				return (ioc_timerout[2]>>8)&0xff;
-			case 28:	// timer 3 read
-				return ioc_timerout[3]&0xff;
-			case 29:
-				return (ioc_timerout[3]>>8)&0xff;
+			vert_pos = space->machine->primary_screen->vpos();
+			flyback = (vert_pos <= vidc_regs[VIDC_VDSR] || vert_pos >= vidc_regs[VIDC_VDER]) ? 0x80 : 0x00;
+
+			i2c_data = (i2cmem_sda_read(space->machine->device("i2cmem")) & 1);
+
+			return (flyback) | (ioc_regs[CONTROL] & 0x7c) | (i2c_clk<<1) | i2c_data;
 		}
 
-		logerror("IOC: R %s = %02x (PC=%x)\n", ioc_regnames[offset&0x1f], ioc_regs[offset&0x1f], cpu_get_pc( space->cpu ));
-		return ioc_regs[offset&0x1f];
-	}
-	#ifdef MESS
-	else if (offset >= 0xc4000 && offset <= 0xc4010)
-	{
-		logerror("17XX: R @ addr %x mask %08x\n", offset*4, mem_mask);
-		return wd17xx_data_r(fdc, offset&0xf);
-	}
-	#endif
-	else
-	{
-		logerror("IOC: R @ %x (mask %08x)\n", (offset*4)+0x3000000, mem_mask);
-	}
+		case KART:	// keyboard read
+			archimedes_request_irq_b(space->machine, ARCHIMEDES_IRQB_KBD_XMIT_EMPTY);
+			break;
 
+		case IRQ_STATUS_A:
+			return (ioc_regs[IRQ_STATUS_A] & 0x7f) | 0x80; // Force IRQ is always '1'
 
-	return 0;
+		case IRQ_REQUEST_A:
+			return (ioc_regs[IRQ_STATUS_A] & ioc_regs[IRQ_MASK_A]);
+
+		case IRQ_MASK_A:
+			return (ioc_regs[IRQ_MASK_A]);
+
+		case IRQ_STATUS_B:
+			return (ioc_regs[IRQ_STATUS_B]);
+
+		case IRQ_REQUEST_B:
+			return (ioc_regs[IRQ_STATUS_B] & ioc_regs[IRQ_MASK_B]);
+
+		case IRQ_MASK_B:
+			return (ioc_regs[IRQ_MASK_B]);
+
+		case FIQ_STATUS:
+			return (ioc_regs[FIQ_STATUS] & 0x7f) | 0x80; // Force FIQ is always '1'
+
+		case FIQ_REQUEST:
+			return (ioc_regs[FIQ_STATUS] & ioc_regs[FIQ_MASK]);
+
+		case FIQ_MASK:
+			return (ioc_regs[FIQ_MASK]);
+
+		case T0_LATCH_LO: return ioc_timerout[0]&0xff;
+		case T0_LATCH_HI: return (ioc_timerout[0]>>8)&0xff;
+
+		case T1_LATCH_LO: return ioc_timerout[1]&0xff;
+		case T1_LATCH_HI: return (ioc_timerout[1]>>8)&0xff;
+
+		case T2_LATCH_LO: return ioc_timerout[2]&0xff;
+		case T2_LATCH_HI: return (ioc_timerout[2]>>8)&0xff;
+
+		case T3_LATCH_LO: return ioc_timerout[3]&0xff;
+		case T3_LATCH_HI: return (ioc_timerout[3]>>8)&0xff;
+		default:
+			if(!IOC_LOG)
+				logerror("IOC: R %s = %02x (PC=%x) %02x\n", ioc_regnames[offset&0x1f], ioc_regs[offset&0x1f], cpu_get_pc( space->cpu ),offset & 0x1f);
+			break;
+	}
+
+	return ioc_regs[offset&0x1f];
 }
 
-WRITE32_HANDLER(archimedes_ioc_w)
+/* TODO: should be a 8-bit handler */
+static WRITE32_HANDLER( ioc_ctrl_w )
 {
-	#ifdef MESS
-	running_device *fdc = (running_device *)space->machine->device("wd1772");
-	#endif
+	if(IOC_LOG)
+	logerror("IOC: W %02x @ reg %s (PC=%x)\n", data&0xff, ioc_regnames[offset&0x1f], cpu_get_pc( space->cpu ));
 
-	if (offset >= 0x80000 && offset < 0xc0000)
+	switch (offset&0x1f)
 	{
-//      logerror("IOC: W %02x @ reg %s (PC=%x)\n", data&0xff, ioc_regnames[offset&0x1f], cpu_get_pc( space->cpu ));
+		case CONTROL:	// I2C bus control
+			//logerror("IOC I2C: CLK %d DAT %d\n", (data>>1)&1, data&1);
+			i2cmem_sda_write(space->machine->device("i2cmem"), data & 0x01);
+			i2cmem_scl_write(space->machine->device("i2cmem"), (data & 0x02) >> 1);
+			i2c_clk = (data & 2) >> 1;
+			break;
 
-		switch (offset&0x1f)
-		{
-			case 0:	// I2C bus control
-				logerror("IOC I2C: CLK %d DAT %d\n", (data>>1)&1, data&1);
-				break;
+		case KART:
+			#if 0
+			if(data == 0x0d)
+				printf("\n");
+			else
+				printf("%c",data);
+			#endif
+			break;
 
-			case 5: 	// IRQ clear A
-				ioc_regs[4] &= ~(data&0xff);
+		case IRQ_MASK_A:
+			ioc_regs[IRQ_MASK_A] = data & 0xff;
 
-				// if that did it, clear the IRQ
-				if (ioc_regs[4] == 0)
-				{
-					cputag_set_input_line(space->machine, "maincpu", ARM_IRQ_LINE, CLEAR_LINE);
-				}
-				break;
+			if(data & 0x80) //force an IRQ
+				archimedes_request_irq_a(space->machine,ARCHIMEDES_IRQA_FORCE);
 
-			case 16:
-			case 17:
-				ioc_regs[offset&0x1f] = data & 0xff;
-				break;
+			if(data & 0x08) //set up the VBLANK timer
+				timer_adjust_oneshot(vbl_timer, space->machine->primary_screen->time_until_pos(vidc_regs[0xb4]), 0);
 
-			case 20:
-			case 21:
-				ioc_regs[offset&0x1f] = data & 0xff;
-				break;
+			break;
 
-			case 24:
-			case 25:
-				ioc_regs[offset&0x1f] = data & 0xff;
-				break;
+		case FIQ_MASK:
+			ioc_regs[FIQ_MASK] = data & 0xff;
 
-			case 28:
-			case 29:
-				ioc_regs[offset&0x1f] = data & 0xff;
-				break;
+			if(data & 0x80) //force a FIRQ
+				archimedes_request_fiq(space->machine,ARCHIMEDES_FIQ_FORCE);
 
-			case 19:	// Timer 0 latch
-				latch_timer_cnt(0);
-				break;
+			break;
 
-			case 23:	// Timer 1 latch
-				latch_timer_cnt(1);
-				break;
+		case IRQ_REQUEST_A: 	// IRQ clear A
+			ioc_regs[IRQ_STATUS_A] &= ~(data&0xff);
 
-			case 27:	// Timer 2 latch
-				latch_timer_cnt(2);
-				break;
+			// if that did it, clear the IRQ
+			//if (ioc_regs[IRQ_STATUS_A] == 0)
+			{
+				//printf("IRQ clear A\n");
+				cputag_set_input_line(space->machine, "maincpu", ARM_IRQ_LINE, CLEAR_LINE);
+			}
+			break;
 
-			case 31:	// Timer 3 latch
-				latch_timer_cnt(3);
-				break;
+		case T0_LATCH_LO:
+		case T0_LATCH_HI:
+			ioc_regs[offset&0x1f] = data & 0xff;
+			break;
 
-			case 18:	// Timer 0 start
-				ioc_timercnt[0] = ioc_regs[17]<<8 | ioc_regs[16];
-				a310_set_timer(0);
-				break;
+		case T1_LATCH_LO:
+		case T1_LATCH_HI:
+			ioc_regs[offset&0x1f] = data & 0xff;
+			break;
 
-			case 22:	// Timer 1 start
-				ioc_timercnt[1] = ioc_regs[21]<<8 | ioc_regs[20];
-				a310_set_timer(1);
-				break;
+		case T2_LATCH_LO:
+		case T2_LATCH_HI:
+			ioc_regs[offset&0x1f] = data & 0xff;
+			break;
 
-			case 26:	// Timer 2 start
-				ioc_timercnt[2] = ioc_regs[25]<<8 | ioc_regs[24];
-				a310_set_timer(2);
-				break;
+		case T3_LATCH_LO:
+		case T3_LATCH_HI:
+			ioc_regs[offset&0x1f] = data & 0xff;
+			break;
 
-			case 30:	// Timer 3 start
-				ioc_timercnt[3] = ioc_regs[29]<<8 | ioc_regs[28];
-				a310_set_timer(3);
-				break;
+		case T0_LATCH:	// Timer 0 latch
+			latch_timer_cnt(0);
+			break;
 
-			default:
-				ioc_regs[offset&0x1f] = data & 0xff;
-				break;
-		}
+		case T1_LATCH:	// Timer 1 latch
+			latch_timer_cnt(1);
+			break;
+
+		case T2_LATCH:	// Timer 2 latch
+			latch_timer_cnt(2);
+			break;
+
+		case T3_LATCH:	// Timer 3 latch
+			latch_timer_cnt(3);
+			break;
+
+		case T0_GO:	// Timer 0 start
+			ioc_timercnt[0] = ioc_regs[T0_LATCH_HI]<<8 | ioc_regs[T0_LATCH_LO];
+			a310_set_timer(0);
+			break;
+
+		case T1_GO:	// Timer 1 start
+			ioc_timercnt[1] = ioc_regs[T1_LATCH_HI]<<8 | ioc_regs[T1_LATCH_LO];
+			a310_set_timer(1);
+			break;
+
+		case T2_GO:	// Timer 2 start
+			ioc_timercnt[2] = ioc_regs[T2_LATCH_HI]<<8 | ioc_regs[T2_LATCH_LO];
+			a310_set_timer(2);
+			break;
+
+		case T3_GO:	// Timer 3 start
+			ioc_timercnt[3] = ioc_regs[T3_LATCH_HI]<<8 | ioc_regs[T3_LATCH_LO];
+			a310_set_timer(3);
+			break;
+
+		default:
+			if(!IOC_LOG)
+				logerror("IOC: W %02x @ reg %s (PC=%x)\n", data&0xff, ioc_regnames[offset&0x1f], cpu_get_pc( space->cpu ));
+
+			ioc_regs[offset&0x1f] = data & 0xff;
+			break;
 	}
+}
+
+READ32_HANDLER(archimedes_ioc_r)
+{
+	UINT32 ioc_addr;
 	#ifdef MESS
-	else if (offset >= 0xc4000 && offset <= 0xc4010)
-	{
-		logerror("17XX: %x to addr %x mask %08x\n", data, offset*4, mem_mask);
-		wd17xx_data_w(fdc, offset&0xf, data&0xff);
-	}
-	else if (offset == 0xd40006)
+	running_device *fdc = (running_device *)space->machine->device("wd1772");
+	#endif
+
+	ioc_addr = offset*4;
+
+	switch((ioc_addr & 0x300000) >> 20)
 	{
-		// latch A
-		if (data & 1)
-		{
-			wd17xx_set_drive(fdc,0);
-		}
-		if (data & 2)
-		{
-			wd17xx_set_drive(fdc,1);
-		}
-		if (data & 4)
-		{
-			wd17xx_set_drive(fdc,2);
-		}
-		if (data & 8)
+		/*82c711*/
+		case 0:
+			logerror("82c711 read at address %08x\n",ioc_addr);
+			return 0;
+		case 2:
+		case 3:
 		{
-			wd17xx_set_drive(fdc,3);
-		}
+			switch((ioc_addr & 0x70000) >> 16)
+			{
+				case 0: return ioc_ctrl_r(space,offset,mem_mask);
+				case 1:
+					#ifdef MESS
+						logerror("17XX: R @ addr %x mask %08x\n", offset*4, mem_mask);
+						return wd17xx_data_r(fdc, offset&0xf);
+					#else
+						logerror("Read from FDC device?\n");
+						return 0;
+					#endif
+				case 2:
+					logerror("IOC: Econet Read %08x\n",ioc_addr);
+					return 0xffff;
+				case 3:
+					logerror("IOC: Serial Read\n");
+					return 0xffff;
+				case 4:
+					logerror("IOC: Internal Podule Read\n");
+					return 0xffff;
+				case 5:
+					switch(ioc_addr & 0xfffc)
+					{
+						#ifdef MESS
+						case 0x50: return 0; //fdc type, new model returns 5 here
+						#endif
+					}
 
-		wd17xx_set_side(fdc,(data & 0x10)>>4);
+					logerror("IOC: Internal Latches Read %08x\n",ioc_addr);
 
+					return 0xffff;
+			}
+		}
 	}
-	else if (offset == 0xd40010)
-	{
-		// latch B
-		wd17xx_dden_w(fdc, BIT(data, 1));
-	}
+
+	logerror("IOC: Unknown read at %08x\n",ioc_addr);
+
+	return 0;
+}
+
+WRITE32_HANDLER(archimedes_ioc_w)
+{
+	UINT32 ioc_addr;
+	#ifdef MESS
+	running_device *fdc = (running_device *)space->machine->device("wd1772");
 	#endif
-	else
+
+	ioc_addr = offset*4;
+
+	switch((ioc_addr & 0x300000) >> 20)
 	{
-		logerror("I/O: W %x @ %x (mask %08x)\n", data, (offset*4)+0x3000000, mem_mask);
+		/*82c711*/
+		case 0:
+			logerror("82c711 write %08x to address %08x\n",data,ioc_addr);
+			return;
+		case 2:
+		case 3:
+		{
+			switch((ioc_addr & 0x70000) >> 16)
+			{
+				case 0: ioc_ctrl_w(space,offset,data,mem_mask); return;
+				case 1:
+					#ifdef MESS
+						logerror("17XX: %x to addr %x mask %08x\n", data, offset*4, mem_mask);
+						wd17xx_data_w(fdc, offset&0xf, data&0xff);
+					#else
+						logerror("Write to FDC device?\n");
+					#endif
+						return;
+				case 2:
+					logerror("IOC: Econet Write %02x at %08x\n",data,ioc_addr);
+					return;
+				case 3:
+					logerror("IOC: Serial Write %02x (%c) at %08x\n",data,data,ioc_addr);
+					return;
+				case 4:
+					logerror("IOC: Internal Podule Write\n");
+					return;
+				case 5:
+					switch(ioc_addr & 0xfffc)
+					{
+						#ifdef MESS
+						case 0x18: // latch B
+							wd17xx_dden_w(fdc, BIT(data, 1));
+							return;
+
+						case 0x40: // latch A
+							if (data & 1) { wd17xx_set_drive(fdc,0); }
+							if (data & 2) {	wd17xx_set_drive(fdc,1); }
+							if (data & 4) { wd17xx_set_drive(fdc,2); }
+							if (data & 8) {	wd17xx_set_drive(fdc,3); }
+
+							wd17xx_set_side(fdc,(data & 0x10)>>4);
+							//bit 5 is motor on
+							return;
+						#endif
+					}
+					break;
+			}
+		}
 	}
+
+
+	logerror("(PC=%08x) I/O: W %x @ %x (mask %08x)\n", cpu_get_pc(space->cpu), data, (offset*4)+0x3000000, mem_mask);
 }
 
 READ32_HANDLER(archimedes_vidc_r)
@@ -497,11 +707,50 @@
 	return 0;
 }
 
+static void vidc_dynamic_res_change(running_machine *machine)
+{
+	/* sanity checks - first pass */
+	/*
+        total cycles + border end
+    */
+	if(vidc_regs[VIDC_HCR] && vidc_regs[VIDC_HBER] &&
+	   vidc_regs[VIDC_VCR] && vidc_regs[VIDC_VBER])
+	{
+		/* sanity checks - second pass */
+		/*
+        total cycles >= border end >= border start
+        */
+		if((vidc_regs[VIDC_HCR] >= vidc_regs[VIDC_HBER]) &&
+		   (vidc_regs[VIDC_HBER] >= vidc_regs[VIDC_HBSR]) &&
+		   (vidc_regs[VIDC_VCR] >= vidc_regs[VIDC_VBER]) &&
+		   (vidc_regs[VIDC_VBER] >= vidc_regs[VIDC_VBSR]))
+		{
+			rectangle visarea;
+			attoseconds_t refresh;
+
+			visarea.min_x = 0;
+			visarea.min_y = 0;
+			visarea.max_x = vidc_regs[VIDC_HBER] - vidc_regs[VIDC_HBSR] - 1;
+			visarea.max_y = vidc_regs[VIDC_VBER] - vidc_regs[VIDC_VBSR];
+
+			logerror("Configuring: htotal %d vtotal %d border %d x %d display %d x %d\n",
+				vidc_regs[VIDC_HCR], vidc_regs[VIDC_VCR],
+				visarea.max_x, visarea.max_y,
+				vidc_regs[VIDC_HDER]-vidc_regs[VIDC_HDSR],vidc_regs[VIDC_VDER]-vidc_regs[VIDC_VDSR]+1);
+
+			/* FIXME: pixel clock */
+			refresh = HZ_TO_ATTOSECONDS(pixel_rate[vidc_pixel_clk]*2) * vidc_regs[VIDC_HCR] * vidc_regs[VIDC_VCR];
+
+			machine->primary_screen->configure(vidc_regs[VIDC_HCR], vidc_regs[VIDC_VCR], visarea, refresh);
+		}
+	}
+}
+
 WRITE32_HANDLER(archimedes_vidc_w)
 {
 	UINT32 reg = data>>24;
 	UINT32 val = data & 0xffffff;
-	#ifdef DEBUG
+	//#ifdef DEBUG
 	static const char *const vrnames[] =
 	{
 		"horizontal total",
@@ -521,34 +770,85 @@
 		"vertical cursor start",
 		"vertical cursor end",
 	};
-	#endif
+	//#endif
+
 
-	if (reg >= 0x80 && reg <= 0xbc)
+	// 0x00 - 0x3c Video Palette Logical Colors (16 colors)
+	// 0x40 Border Color
+	// 0x44 - 0x4c Cursor Palette Logical Colors
+	if (reg >= 0x00 && reg <= 0x4c)
 	{
-		#ifdef DEBUG
-		logerror("VIDC: %s = %d\n", vrnames[(reg-0x80)/4], val>>12);
-		#endif
+		int r,g,b;
+
+		//i = (val & 0x1000) >> 12; //supremacy bit
+		b = (val & 0x0f00) >> 8;
+		g = (val & 0x00f0) >> 4;
+		r = (val & 0x000f) >> 0;
+
+		if(reg == 0x40 && val & 0xfff)
+			logerror("WARNING: border color write here (PC=%08x)!\n",cpu_get_pc(space->cpu));
+
+		palette_set_color_rgb(space->machine, reg >> 2, pal4bit(r), pal4bit(g), pal4bit(b) );
 
-		if ((reg == 0xb0) & ((val>>12) != 0))
+		/* handle 8bpp colors here */
+		if(reg <= 0x3c)
 		{
-			rectangle visarea;
+			int i;
 
-			visarea.min_x = 0;
-			visarea.min_y = 0;
-			visarea.max_x = vidc_regs[0x94] - vidc_regs[0x88];
-			visarea.max_y = vidc_regs[0xb4] - vidc_regs[0xa8];
+			for(i=0;i<0x100;i+=0x10)
+			{
+				b = ((val & 0x700) >> 8) | ((i & 0x80) >> 4);
+				g = ((val & 0x030) >> 4) | ((i & 0x20) >> 3) | ((i & 0x40) >> 3);
+				r = ((val & 0x007) >> 0) | ((i & 0x10) >> 1);
 
-			logerror("Configuring: htotal %d vtotal %d vis %d,%d\n",
-				vidc_regs[0x80], vidc_regs[0xa0],
-				visarea.max_x, visarea.max_y);
+				palette_set_color_rgb(space->machine, (reg >> 2) + 0x100 + i, pal4bit(r), pal4bit(g), pal4bit(b) );
+			}
+		}
 
-			space->machine->primary_screen->configure(vidc_regs[0x80], vidc_regs[0xa0], visarea, space->machine->primary_screen->frame_period().attoseconds);
+	}
+	else if (reg >= 0x60 && reg <= 0x7c)
+	{
+		vidc_stereo_reg[(reg >> 2) & 7] = val & 0x07;
 
-			// slightly hacky: fire off a VBL right now.  the BIOS doesn't wait long enough otherwise.
-			timer_adjust_oneshot(vbl_timer, attotime_zero, 0);
+//      popmessage("%02x %02x %02x %02x %02x %02x %02x %02x",vidc_stereo_reg[0],vidc_stereo_reg[1],vidc_stereo_reg[2],vidc_stereo_reg[3]
+//      ,vidc_stereo_reg[4],vidc_stereo_reg[5],vidc_stereo_reg[6],vidc_stereo_reg[7]);
+	}
+	else if (reg >= 0x80 && reg <= 0xbc)
+	{
+		switch(reg)
+		{
+			case VIDC_HCR:  vidc_regs[VIDC_HCR] =  ((val >> 14)<<1)+1;	break;
+//          case VIDC_HSWR: vidc_regs[VIDC_HSWR] = (val >> 14)+1;   break;
+			case VIDC_HBSR: vidc_regs[VIDC_HBSR] = ((val >> 14)<<1)+1;	break;
+			case VIDC_HDSR: vidc_regs[VIDC_HDSR] = (val >> 14); 	break;
+			case VIDC_HDER: vidc_regs[VIDC_HDER] = (val >> 14); 	break;
+			case VIDC_HBER: vidc_regs[VIDC_HBER] = ((val >> 14)<<1)+1;	break;
+//          #define VIDC_HCSR       0x98
+//          #define VIDC_HIR        0x9c
+
+			case VIDC_VCR:  vidc_regs[VIDC_VCR] = ((val >> 14)<<1)+1;	break;
+//          #define VIDC_VSWR       0xa4
+			case VIDC_VBSR: vidc_regs[VIDC_VBSR] = (val >> 14)+1;	break;
+			case VIDC_VDSR: vidc_regs[VIDC_VDSR] = (val >> 14)+1;	break;
+			case VIDC_VDER: vidc_regs[VIDC_VDER] = (val >> 14)+1;	break;
+			case VIDC_VBER: vidc_regs[VIDC_VBER] = (val >> 14)+1;	break;
+//          #define VIDC_VCSR       0xb8
+//          #define VIDC_VCER       0xbc
 		}
 
-		vidc_regs[reg] = val>>12;
+
+		//#ifdef DEBUG
+		logerror("VIDC: %s = %d\n", vrnames[(reg-0x80)/4], vidc_regs[reg]);
+		//#endif
+
+		vidc_dynamic_res_change(space->machine);
+	}
+	else if(reg == 0xe0)
+	{
+		vidc_bpp_mode = ((val & 0x0c) >> 2);
+		vidc_interlace = ((val & 0x40) >> 6);
+		vidc_pixel_clk = (val & 0x03);
+		vidc_dynamic_res_change(space->machine);
 	}
 	else
 	{
@@ -569,36 +869,63 @@
 	{
 		switch ((data >> 17) & 7)
 		{
+			case 0: /* video init */
+				vidc_vidinit = ((data>>2)&0x7fff)*16;
+				//logerror("MEMC: VIDINIT %08x\n",vidc_vidinit);
+				break;
+
+			case 1: /* video start */
+				vidc_vidstart = 0x2000000 | (((data>>2)&0x7fff)*16);
+				//logerror("MEMC: VIDSTART %08x\n",vidc_vidstart);
+				break;
+
+			case 2: /* video end */
+				vidc_vidend = 0x2000000 | (((data>>2)&0x7fff)*16);
+				//logerror("MEMC: VIDEND %08x\n",vidc_vidend);
+				break;
+
 			case 4:	/* sound start */
-				vidc_sndstart = ((data>>2)&0x7fff)*16;
+				//logerror("MEMC: SNDSTART %08x\n",data);
+				vidc_sndstart = 0x2000000 | ((data>>2)&0x7fff)*16;
+				ioc_regs[IRQ_STATUS_B] &= ~ARCHIMEDES_IRQB_SOUND_EMPTY;
 				break;
 
 			case 5: /* sound end */
-				vidc_sndend = ((data>>2)&0x7fff)*16;
+				//logerror("MEMC: SNDEND %08x\n",data);
+				vidc_sndend = 0x2000000 | ((data>>2)&0x7fff)*16;
+				break;
+
+			case 6:
+				vidc_sndcur = 0;
+				archimedes_request_irq_b(space->machine, ARCHIMEDES_IRQB_SOUND_EMPTY);
 				break;
 
 			case 7:	/* Control */
 				memc_pagesize = ((data>>2) & 3);
 
-				logerror("MEMC: %x to Control (page size %d, %s, %s)\n", data & 0x1ffc, page_sizes[memc_pagesize], ((data>>10)&1) ? "Video DMA on" : "Video DMA off", ((data>>11)&1) ? "Sound DMA on" : "Sound DMA off");
+				logerror("(PC = %08x) MEMC: %x to Control (page size %d, %s, %s)\n", cpu_get_pc(space->cpu), data & 0x1ffc, page_sizes[memc_pagesize], ((data>>10)&1) ? "Video DMA on" : "Video DMA off", ((data>>11)&1) ? "Sound DMA on" : "Sound DMA off");
+
+				video_dma_on = ((data>>10)&1);
+				audio_dma_on = ((data>>11)&1);
+
+				if ((data>>10)&1)
+				{
+					vidc_vidcur = 0;
+					timer_adjust_oneshot(vid_timer, space->machine->primary_screen->time_until_pos(vidc_regs[0xb4]), 0);
+				}
 
 				if ((data>>11)&1)
 				{
 					double sndhz;
 
-					sndhz = 250000.0 / (double)((vidc_regs[0xc0]&0xff)+2);
-
-					logerror("MEMC: Starting audio DMA at %f Hz, buffer from %x to %x\n", sndhz, vidc_sndstart, vidc_sndend);
+					/* FIXME: is the frequency correct? */
+					sndhz = (250000.0 / 2) / (double)((vidc_regs[0xc0]&0xff)+2);
 
-					vidc_sndcur = vidc_sndstart;
+					printf("MEMC: Starting audio DMA at %f Hz, buffer from %x to %x\n", sndhz, vidc_sndstart, vidc_sndend);
 
-					timer_adjust_periodic(snd_timer, ATTOTIME_IN_HZ(sndhz), 0, ATTOTIME_IN_HZ(sndhz));
-				}
-				else
-				{
-					timer_adjust_oneshot(snd_timer, attotime_never, 0);
-					dac_signed_data_w(space->machine->device("dac"), 0x80);
+					timer_adjust_periodic(snd_timer, attotime_zero, 0, ATTOTIME_IN_HZ(sndhz));
 				}
+
 				break;
 
 			default:
@@ -613,7 +940,7 @@
 }
 
 /*
-      22 2222 1111 1111 1100 0000 0000
+          22 2222 1111 1111 1100 0000 0000
           54 3210 9876 5432 1098 7654 3210
 4k  page: 11 1LLL LLLL LLLL LLAA MPPP PPPP
 8k  page: 11 1LLL LLLL LLLM LLAA MPPP PPPP
@@ -649,45 +976,38 @@
 	{
 		case 0:
 			phys = data & 0x7f;
-			log = (data & 0xc00)>>10;
-			log <<= 23;
-			log |= (data & 0x7ff000);
+			log = ((data & 0x7ff000)>>12) | ((data & 0xc00)<<1);
 			memc = (data & 0x80) ? 1 : 0;
 			break;
 
 		case 1:
-			phys = ((data & 0x7f) >> 1) | (data & 1) ? 0x40 : 0;
-			log = (data & 0xc00)>>10;
-			log <<= 23;
-			log |= (data & 0x7fe000);
+			phys = ((data & 0x7f) >> 1) | ((data & 1) << 6);
+			log = ((data & 0x7fe000)>>13) | (data & 0xc00);
 			memc = ((data & 0x80) ? 1 : 0) | ((data & 0x1000) ? 2 : 0);
 			break;
 
 		case 2:
 			phys = ((data & 0x7f) >> 2) | ((data & 3) << 5);
-			log = (data & 0xc00)>>10;
-			log <<= 23;
-			log |= (data & 0x7fc000);
+			log = ((data & 0x7fc000)>>14) | ((data & 0xc00)>>1);
 			memc = ((data & 0x80) ? 1 : 0) | ((data & 0x1000) ? 2 : 0);
 			break;
 
 		case 3:
-			phys = ((data & 0x7f) >> 3) | (data & 1)<<4 | (data & 2) << 5 | (data & 4)<<3;
-			log = (data & 0xc00)>>10;
-			log <<= 23;
-			log |= (data & 0x7f8000);
+			phys = ((data & 0x7f) >> 3) | ((data & 1)<<4) | ((data & 2) << 5) | ((data & 4)<<3);
+			log = ((data & 0x7f8000)>>15) | ((data & 0xc00)>>2);
 			memc = ((data & 0x80) ? 1 : 0) | ((data & 0x1000) ? 2 : 0);
+			//printf("Mapping %08X to %08X\n",0x2000000+(phys*32768),(((data >> 15)&0xff)|((data >> 2)&0x300)));
 			break;
 	}
 
-	log >>= (12 + memc_pagesize);
+//  log >>= (12 + memc_pagesize);
 
 	// always make sure ROM mode is disconnected when this occurs
 	memc_latchrom = 0;
 
 	// now go ahead and set the mapping in the page table
-	memc_pages[log] = phys * memc;
+	memc_pages[log] = phys + (memc*0x80);
 
-//  printf("MEMC_PAGE(%d): W %08x: log %x to phys %x, MEMC %d, perms %d\n", memc_pagesize, data, log, phys, memc, perms);
+	printf("PC=%08x = MEMC_PAGE(%d): W %08x: log %x to phys %x, MEMC %d, perms %d\n", cpu_get_pc(space->cpu),memc_pagesize, data, log, phys, memc, perms);
 }
 
diff -Nru src-old/mame/machine/asic65.c src/mame/machine/asic65.c
--- src-old/mame/machine/asic65.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/machine/asic65.c	2010-08-19 00:26:14.000000000 -0700
@@ -144,7 +144,7 @@
 
 void asic65_reset(running_machine *machine, int state)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* rom-based means reset and clear states */
 	if (asic65.cpu != NULL)
diff -Nru src-old/mame/machine/atari.c src/mame/machine/atari.c
--- src-old/mame/machine/atari.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/atari.c	2010-08-19 00:26:14.000000000 -0700
@@ -314,13 +314,13 @@
 }
 
 
-static UINT8 console_read(const address_space *space)
+static UINT8 console_read(address_space *space)
 {
 	return input_port_read(space->machine, "console");
 }
 
 
-static void console_write(const address_space *space, UINT8 data)
+static void console_write(address_space *space, UINT8 data)
 {
 	running_device *dac = space->machine->device("dac");
 	if (data & 0x08)
diff -Nru src-old/mame/machine/atarigen.c src/mame/machine/atarigen.c
--- src-old/mame/machine/atarigen.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/atarigen.c	2010-08-19 00:26:14.000000000 -0700
@@ -491,9 +491,9 @@
 }
 
 
-static DIRECT_UPDATE_HANDLER( atarigen_slapstic_setdirect )
+DIRECT_UPDATE_HANDLER( atarigen_slapstic_setdirect )
 {
-	atarigen_state *state = space->machine->driver_data<atarigen_state>();
+	atarigen_state *state = machine->driver_data<atarigen_state>();
 
 	/* if we jump to an address in the slapstic region, tweak the slapstic
        at that address and return ~0; this will cause us to be called on
@@ -501,12 +501,12 @@
 	address &= ~state->slapstic_mirror;
 	if (address >= state->slapstic_base && address < state->slapstic_base + 0x8000)
 	{
-		offs_t pc = cpu_get_previouspc(space->cpu);
+		offs_t pc = cpu_get_previouspc(&direct.space().device());
 		if (pc != state->slapstic_last_pc || address != state->slapstic_last_address)
 		{
 			state->slapstic_last_pc = pc;
 			state->slapstic_last_address = address;
-			atarigen_slapstic_r(space, (address >> 1) & 0x3fff, 0xffff);
+			atarigen_slapstic_r(&direct.space(), (address >> 1) & 0x3fff, 0xffff);
 		}
 		return ~0;
 	}
@@ -548,7 +548,9 @@
 		/* install an opcode base handler if we are a 68000 or variant */
 		state->slapstic_base = base;
 		state->slapstic_mirror = mirror;
-		memory_set_direct_update_handler(cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM), atarigen_slapstic_setdirect);
+
+		address_space *space = downcast<cpu_device *>(device)->space(AS_PROGRAM);
+		space->set_direct_update_handler(direct_update_delegate_create_static(atarigen_slapstic_setdirect, *device->machine));
 	}
 }
 
@@ -800,7 +802,7 @@
 static TIMER_CALLBACK( delayed_sound_reset )
 {
 	atarigen_state *state = machine->driver_data<atarigen_state>();
-	const address_space *space = cpu_get_address_space(state->sound_cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->sound_cpu, ADDRESS_SPACE_PROGRAM);
 
 	/* unhalt and reset the sound CPU */
 	if (param == 0)
diff -Nru src-old/mame/machine/bagman.c src/mame/machine/bagman.c
--- src-old/mame/machine/bagman.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/bagman.c	2010-08-19 00:26:14.000000000 -0700
@@ -219,7 +219,7 @@
 
 MACHINE_RESET( bagman )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	bagman_pal16r6_w(space, 0, 1);	/*pin 2*/
 	bagman_pal16r6_w(space, 1, 1);	/*pin 3*/
 	bagman_pal16r6_w(space, 2, 1);	/*pin 4*/
diff -Nru src-old/mame/machine/balsente.c src/mame/machine/balsente.c
--- src-old/mame/machine/balsente.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/balsente.c	2010-08-19 00:26:14.000000000 -0700
@@ -132,7 +132,7 @@
 
 MACHINE_RESET( balsente )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	balsente_state *state = machine->driver_data<balsente_state>();
 	int numbanks;
 
diff -Nru src-old/mame/machine/cclimber.c src/mame/machine/cclimber.c
--- src-old/mame/machine/cclimber.c	2010-02-03 16:16:00.000000000 -0800
+++ src/mame/machine/cclimber.c	2010-08-19 07:19:38.000000000 -0700
@@ -6,12 +6,12 @@
 
 static void cclimber_decode(running_machine *machine, const UINT8 convtable[8][16])
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x10000);
 	int A;
 
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypt);
+	space->set_decrypted_region(0x0000, 0xffff, decrypt);
 
 	for (A = 0x0000;A < 0x10000;A++)
 	{
diff -Nru src-old/mame/machine/cps2crpt.c src/mame/machine/cps2crpt.c
--- src-old/mame/machine/cps2crpt.c	2010-07-12 13:47:35.000000000 -0700
+++ src/mame/machine/cps2crpt.c	2010-08-19 07:19:38.000000000 -0700
@@ -632,7 +632,7 @@
 
 static void cps2_decrypt(running_machine *machine, const UINT32 *master_key, UINT32 upper_limit)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 	int length = memory_region_length(machine, "maincpu");
 	UINT16 *dec = auto_alloc_array(machine, UINT16, length/2);
@@ -720,7 +720,7 @@
 		}
 	}
 
-	memory_set_decrypted_region(space, 0x000000, length - 1, dec);
+	space->set_decrypted_region(0x000000, length - 1, dec);
 	m68k_set_encrypted_opcode_range(machine->device("maincpu"), 0, length);
 }
 
diff -Nru src-old/mame/machine/cubocd32.c src/mame/machine/cubocd32.c
--- src-old/mame/machine/cubocd32.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/cubocd32.c	2010-08-19 01:27:05.000000000 -0700
@@ -469,7 +469,7 @@
 	timer_adjust_oneshot( akiko.dma_timer, ATTOTIME_IN_USEC( CD_SECTOR_TIME / akiko.cdrom_speed ), 0 );
 }
 
-static void akiko_setup_response( const address_space *space, int len, UINT8 *r1 )
+static void akiko_setup_response( address_space *space, int len, UINT8 *r1 )
 {
 	int		resp_addr = akiko.cdrom_address[1];
 	UINT8	resp_csum = 0xff;
@@ -488,7 +488,7 @@
 
 	for( i = 0; i < len; i++ )
 	{
-		memory_write_byte( space, resp_addr + ((akiko.cdrom_cmd_resp + i) & 0xff), resp_buffer[i] );
+		space->write_byte( resp_addr + ((akiko.cdrom_cmd_resp + i) & 0xff), resp_buffer[i] );
 	}
 
 	akiko.cdrom_cmd_resp = (akiko.cdrom_cmd_resp+len) & 0xff;
@@ -516,7 +516,7 @@
 
 	if ( param == 0x05 )
 	{
-		const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 		if (LOG_AKIKO_CD) logerror( "AKIKO: Completing Command %d\n", param );
 
 		resp[0] = 0x06;
@@ -538,7 +538,7 @@
 	}
 }
 
-static void akiko_update_cdrom(const address_space *space)
+static void akiko_update_cdrom(address_space *space)
 {
 	UINT8	resp[32], cmdbuf[32];
 
@@ -548,7 +548,7 @@
 	while ( akiko.cdrom_cmd_start != akiko.cdrom_cmd_end )
 	{
 		UINT32	cmd_addr = akiko.cdrom_address[1] + 0x200 + akiko.cdrom_cmd_start;
-		int		cmd = memory_read_byte( space, cmd_addr );
+		int		cmd = space->read_byte( cmd_addr );
 
 		memset( resp, 0, sizeof( resp ) );
 		resp[0] = cmd;
@@ -590,7 +590,7 @@
 
 			for( i = 0; i < 13; i++ )
 			{
-				cmdbuf[i] = memory_read_byte( space, cmd_addr );
+				cmdbuf[i] = space->read_byte( cmd_addr );
 				cmd_addr &= 0xffffff00;
 				cmd_addr += ( akiko.cdrom_cmd_start + i + 1 ) & 0xff;
 			}
diff -Nru src-old/mame/machine/cx4fn.c src/mame/machine/cx4fn.c
--- src-old/mame/machine/cx4fn.c	2009-10-02 23:53:27.000000000 -0700
+++ src/mame/machine/cx4fn.c	2010-08-19 01:27:05.000000000 -0700
@@ -101,45 +101,46 @@
 	UINT8 Color;
 	INT32 i;
 
+	address_space *space = machine->device<cpu_device>("maincpu")->space(AS_PROGRAM);
 	for(i = cx4.ram[0x0295]; i > 0; i--, line += 5)
 	{
-		if(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line) == 0xff &&
-		   memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line + 1) == 0xff)
+		if(space->read_byte(line) == 0xff &&
+		   space->read_byte(line + 1) == 0xff)
 		{
 			INT32 tmp = line - 5;
-			while(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tmp + 2) == 0xff &&
-				  memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tmp + 3) == 0xff &&
+			while(space->read_byte(tmp + 2) == 0xff &&
+				  space->read_byte(tmp + 3) == 0xff &&
 				  (tmp + 2) >= 0)
 			{
 				tmp -= 5;
 			}
 			point1 = (CX4_read(0x1f82) << 16) |
-					 (memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tmp + 2) << 8) |
-					  memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), tmp + 3);
+					 (space->read_byte(tmp + 2) << 8) |
+					  space->read_byte(tmp + 3);
 		}
 		else
 		{
 			point1 = (CX4_read(0x1f82) << 16) |
-					 (memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line) << 8) |
-					  memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line + 1);
+					 (space->read_byte(line) << 8) |
+					  space->read_byte(line + 1);
 		}
 		point2 = (CX4_read(0x1f82) << 16) |
-				 (memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line + 2) << 8) |
-				  memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line + 3);
+				 (space->read_byte(line + 2) << 8) |
+				  space->read_byte(line + 3);
 
-		X1=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 0) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 1);
-		Y1=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 2) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 3);
-		Z1=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 4) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point1 + 5);
-		X2=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 0) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 1);
-		Y2=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 2) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 3);
-		Z2=(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 4) << 8) |
-			memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), point2 + 5);
-		Color = memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), line + 4);
+		X1=(space->read_byte(point1 + 0) << 8) |
+			space->read_byte(point1 + 1);
+		Y1=(space->read_byte(point1 + 2) << 8) |
+			space->read_byte(point1 + 3);
+		Z1=(space->read_byte(point1 + 4) << 8) |
+			space->read_byte(point1 + 5);
+		X2=(space->read_byte(point2 + 0) << 8) |
+			space->read_byte(point2 + 1);
+		Y2=(space->read_byte(point2 + 2) << 8) |
+			space->read_byte(point2 + 3);
+		Z2=(space->read_byte(point2 + 4) << 8) |
+			space->read_byte(point2 + 5);
+		Color = space->read_byte(line + 4);
 		CX4_C4DrawLine(X1, Y1, Z1, X2, Y2, Z2, Color);
 	}
 }
diff -Nru src-old/mame/machine/cx4oam.c src/mame/machine/cx4oam.c
--- src-old/mame/machine/cx4oam.c	2009-10-02 23:53:27.000000000 -0700
+++ src/mame/machine/cx4oam.c	2010-08-19 01:27:05.000000000 -0700
@@ -44,6 +44,7 @@
 	offset = (cx4.ram[0x626] & 3) * 2;
 	srcptr = 0x220;
 
+	address_space *space = machine->device<cpu_device>("maincpu")->space(AS_PROGRAM);
 	for(i = cx4.ram[0x620]; i > 0 && sprcount > 0; i--, srcptr += 16)
 	{
 		UINT32 spraddr = CX4_readl(srcptr + 7);
@@ -53,38 +54,38 @@
 		sprname = cx4.ram[srcptr + 5];
 		sprattr = cx4.ram[srcptr + 4] | cx4.ram[srcptr + 6];
 
-		if(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr))
+		if(space->read_byte(spraddr))
 		{
 			INT16 x, y;
 			INT32 sprcnt;
-			for(sprcnt = memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr++); sprcnt > 0 && sprcount > 0; sprcnt--, spraddr += 4)
+			for(sprcnt = space->read_byte(spraddr++); sprcnt > 0 && sprcount > 0; sprcnt--, spraddr += 4)
 			{
-				x = (INT8)memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr + 1);
+				x = (INT8)space->read_byte(spraddr + 1);
 				if(sprattr & 0x40)
 				{
-					x = -x - ((memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr) & 0x20) ? 16 : 8);
+					x = -x - ((space->read_byte(spraddr) & 0x20) ? 16 : 8);
 				}
 				x += sprx;
 				if(x >= -16 && x <= 272)
 				{
-					y = (INT8)memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr + 2);
+					y = (INT8)space->read_byte(spraddr + 2);
 					if(sprattr & 0x80)
 					{
-						y = -y - ((memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr) & 0x20) ? 16 : 8);
+						y = -y - ((space->read_byte(spraddr) & 0x20) ? 16 : 8);
 					}
 					y += spry;
 					if(y >= -16 && y <= 224)
 					{
 						cx4.ram[oamptr    ] = (UINT8)x;
 						cx4.ram[oamptr + 1] = (UINT8)y;
-						cx4.ram[oamptr + 2] = sprname + memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr + 3);
-						cx4.ram[oamptr + 3] = sprattr ^ (memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr) & 0xc0);
+						cx4.ram[oamptr + 2] = sprname + space->read_byte(spraddr + 3);
+						cx4.ram[oamptr + 3] = sprattr ^ (space->read_byte(spraddr) & 0xc0);
 						cx4.ram[oamptr2] &= ~(3 << offset);
 						if(x & 0x100)
 						{
 							cx4.ram[oamptr2] |= 1 << offset;
 						}
-						if(memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), spraddr) & 0x20)
+						if(space->read_byte(spraddr) & 0x20)
 						{
 							cx4.ram[oamptr2] |= 2 << offset;
 						}
diff -Nru src-old/mame/machine/dc.c src/mame/machine/dc.c
--- src-old/mame/machine/dc.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/dc.c	2010-08-19 01:27:05.000000000 -0700
@@ -229,7 +229,7 @@
 	dc_update_interrupt_status(machine);
 }
 
-static void wave_dma_execute(const address_space *space)
+static void wave_dma_execute(address_space *space)
 {
 	UINT32 src,dst,size;
 	dst = wave_dma.aica_addr;
@@ -243,7 +243,7 @@
 	{
 		for(;size<wave_dma.size;size+=4)
 		{
-			memory_write_dword_64le(space,dst,memory_read_dword(space,src));
+			space->write_dword(dst,space->read_dword(src));
 			src+=4;
 			dst+=4;
 		}
@@ -252,7 +252,7 @@
 	{
 		for(;size<wave_dma.size;size+=4)
 		{
-			memory_write_dword_64le(space,src,memory_read_dword(space,dst));
+			space->write_dword(src,space->read_dword(dst));
 			src+=4;
 			dst+=4;
 		}
@@ -268,7 +268,7 @@
 	timer_set(space->machine, ATTOTIME_IN_USEC(300), NULL, 0, aica_dma_irq);
 }
 
-static void pvr_dma_execute(const address_space *space)
+static void pvr_dma_execute(address_space *space)
 {
 	UINT32 src,dst,size;
 	dst = pvr_dma.pvr_addr;
@@ -287,7 +287,7 @@
 	{
 		for(;size<pvr_dma.size;size+=4)
 		{
-			memory_write_dword_64le(space,dst,memory_read_dword(space,src));
+			space->write_dword(dst,space->read_dword(src));
 			src+=4;
 			dst+=4;
 		}
@@ -296,7 +296,7 @@
 	{
 		for(;size<pvr_dma.size;size+=4)
 		{
-			memory_write_dword_64le(space,src,memory_read_dword(space,dst));
+			space->write_dword(src,space->read_dword(dst));
 			src+=4;
 			dst+=4;
 		}
@@ -416,7 +416,7 @@
 	{
 		if((dc_sysctrl_regs[SB_G2DTNRM] & dc_sysctrl_regs[SB_ISTNRM]) || (dc_sysctrl_regs[SB_G2DTEXT] & dc_sysctrl_regs[SB_ISTEXT]))
 		{
-			const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+			address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 			printf("Wave DMA HW trigger\n");
 			wave_dma_execute(space);
@@ -428,7 +428,7 @@
 	{
 		if((dc_sysctrl_regs[SB_PDTNRM] & dc_sysctrl_regs[SB_ISTNRM]) || (dc_sysctrl_regs[SB_PDTEXT] & dc_sysctrl_regs[SB_ISTEXT]))
 		{
-			const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+			address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 			printf("PVR-DMA HW trigger\n");
 			pvr_dma_execute(space);
diff -Nru src-old/mame/machine/deco102.c src/mame/machine/deco102.c
--- src-old/mame/machine/deco102.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/deco102.c	2010-08-19 07:19:38.000000000 -0700
@@ -50,7 +50,7 @@
 void deco102_decrypt_cpu(running_machine *machine, const char *cputag, int address_xor, int data_select_xor, int opcode_select_xor)
 {
 	int i;
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, cputag);
 	int size = memory_region_length(machine, cputag);
 	UINT16 *opcodes = auto_alloc_array(machine, UINT16, size / 2);
@@ -58,7 +58,7 @@
 
 	memcpy(buf, rom, size);
 
-	memory_set_decrypted_region(space, 0, size - 1, opcodes);
+	space->set_decrypted_region(0, size - 1, opcodes);
 	m68k_set_encrypted_opcode_range(machine->device(cputag), 0, size);
 
 	for (i = 0; i < size / 2; i++)
diff -Nru src-old/mame/machine/fd1089.c src/mame/machine/fd1089.c
--- src-old/mame/machine/fd1089.c	2010-07-18 06:21:33.000000000 -0700
+++ src/mame/machine/fd1089.c	2010-08-19 07:19:38.000000000 -0700
@@ -404,14 +404,14 @@
 
 static void sys16_decrypt(running_machine *machine, const UINT8 *key,int cputype)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 *rom = (UINT16 *)memory_region(machine, "maincpu");
 	int size = memory_region_length(machine, "maincpu");
 	int A;
 	decrypted = auto_alloc_array(machine, UINT16, size/2);
 
 	machine->add_notifier(MACHINE_NOTIFY_EXIT, clear_decrypted);
-	memory_set_decrypted_region(space, 0x000000, size - 1, decrypted);
+	space->set_decrypted_region(0x000000, size - 1, decrypted);
 
 	for (A = 0;A < size;A+=2)
 	{
diff -Nru src-old/mame/machine/fddebug.c src/mame/machine/fddebug.c
--- src-old/mame/machine/fddebug.c	2010-07-05 17:52:36.000000000 -0700
+++ src/mame/machine/fddebug.c	2010-08-19 09:10:19.000000000 -0700
@@ -277,7 +277,7 @@
 static void execute_fdclist(running_machine *machine, int ref, int params, const char **param);
 static void execute_fdcsearch(running_machine *machine, int ref, int params, const char **param);
 
-static fd1094_possibility *try_all_possibilities(const address_space *space, int basepc, int offset, int length, UINT8 *instrbuffer, UINT8 *keybuffer, fd1094_possibility *possdata);
+static fd1094_possibility *try_all_possibilities(address_space *space, int basepc, int offset, int length, UINT8 *instrbuffer, UINT8 *keybuffer, fd1094_possibility *possdata);
 static void tag_possibility(running_machine *machine, fd1094_possibility *possdata, UINT8 status);
 
 static void perform_constrained_search(running_machine *machine);
@@ -287,8 +287,8 @@
 static UINT32 reconstruct_base_seed(int keybaseaddr, UINT32 startseed);
 
 static void build_optable(running_machine *machine);
-static int validate_ea(const address_space *space, UINT32 pc, UINT8 modereg, const UINT8 *parambase, UINT32 flags);
-static int validate_opcode(const address_space *space, UINT32 pc, const UINT8 *opdata, int maxwords);
+static int validate_ea(address_space *space, UINT32 pc, UINT8 modereg, const UINT8 *parambase, UINT32 flags);
+static int validate_opcode(address_space *space, UINT32 pc, const UINT8 *opdata, int maxwords);
 
 
 
@@ -429,14 +429,14 @@
     0=no, 1=yes, 2=unlikely
 -----------------------------------------------*/
 
-INLINE int pc_is_valid(const address_space *space, UINT32 pc, UINT32 flags)
+INLINE int pc_is_valid(address_space *space, UINT32 pc, UINT32 flags)
 {
 	/* if we're odd or out of range, fail */
 	if ((pc & 1) == 1)
 		return 0;
 	if (pc & 0xff000000)
 		return 0;
-	if (memory_decrypted_read_ptr(space, pc) == NULL)
+	if (space->direct().read_decrypted_ptr(pc) == NULL)
 		return 0;
 	return 1;
 }
@@ -447,7 +447,7 @@
     valid? 0=no, 1=yes, 2=unlikely
 -----------------------------------------------*/
 
-INLINE int addr_is_valid(const address_space *space, UINT32 addr, UINT32 flags)
+INLINE int addr_is_valid(address_space *space, UINT32 addr, UINT32 flags)
 {
 	/* if this a JMP, the address is a PC */
 	if (flags & OF_JMP)
@@ -460,7 +460,7 @@
 		return 0;
 
 	/* if we're invalid, fail */
-	if (strcmp(memory_get_handler_string(space, 0, addr), "segaic16_memory_mapper_lsb_r") == 0)
+	if (strcmp(const_cast<address_space *>(space)->get_handler_string(ROW_READ, addr), "segaic16_memory_mapper_lsb_r") == 0)
 		return 2;
 
 	return 1;
@@ -1052,7 +1052,7 @@
 
 static void execute_fdsearch(running_machine *machine, int ref, int params, const char **param)
 {
-	const address_space *space = cpu_get_address_space(debug_cpu_get_visible_cpu(machine), ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(debug_cpu_get_visible_cpu(machine), ADDRESS_SPACE_PROGRAM);
 	int pc = cpu_get_pc(space->cpu);
 	int length, first = TRUE;
 	UINT8 instrdata[2];
@@ -1178,7 +1178,7 @@
 
 static void execute_fddasm(running_machine *machine, int ref, int params, const char **param)
 {
-	const address_space *space = cpu_get_address_space(debug_cpu_get_visible_cpu(machine), ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(debug_cpu_get_visible_cpu(machine), ADDRESS_SPACE_PROGRAM);
 	int origstate = fd1094_set_state(keyregion, -1);
 	const char *filename;
 	int skipped = FALSE;
@@ -1385,7 +1385,7 @@
     length
 -----------------------------------------------*/
 
-static fd1094_possibility *try_all_possibilities(const address_space *space, int basepc, int offset, int length, UINT8 *instrbuffer, UINT8 *keybuffer, fd1094_possibility *possdata)
+static fd1094_possibility *try_all_possibilities(address_space *space, int basepc, int offset, int length, UINT8 *instrbuffer, UINT8 *keybuffer, fd1094_possibility *possdata)
 {
 	UINT8 keymask, keystat;
 	UINT16 possvalue[4];
@@ -2226,7 +2226,7 @@
     valid or not, and return the length
 -----------------------------------------------*/
 
-static int validate_ea(const address_space *space, UINT32 pc, UINT8 modereg, const UINT8 *parambase, UINT32 flags)
+static int validate_ea(address_space *space, UINT32 pc, UINT8 modereg, const UINT8 *parambase, UINT32 flags)
 {
 	UINT32 addr;
 	int valid;
@@ -2296,7 +2296,7 @@
     the length specified
 -----------------------------------------------*/
 
-static int validate_opcode(const address_space *space, UINT32 pc, const UINT8 *opdata, int maxwords)
+static int validate_opcode(address_space *space, UINT32 pc, const UINT8 *opdata, int maxwords)
 {
 	UINT32 immvalue = 0;
 	int iffy = FALSE;
diff -Nru src-old/mame/machine/gaelcrpt.c src/mame/machine/gaelcrpt.c
--- src-old/mame/machine/gaelcrpt.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/gaelcrpt.c	2010-08-19 00:26:14.000000000 -0700
@@ -120,7 +120,7 @@
 
 
 
-UINT16 gaelco_decrypt(const address_space *space, int offset, int data, int param1, int param2)
+UINT16 gaelco_decrypt(address_space *space, int offset, int data, int param1, int param2)
 {
 	static int lastpc, lastoffset, lastencword, lastdecword;
 
diff -Nru src-old/mame/machine/galaxold.c src/mame/machine/galaxold.c
--- src-old/mame/machine/galaxold.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/galaxold.c	2010-08-19 07:19:38.000000000 -0700
@@ -319,11 +319,11 @@
 DRIVER_INIT( moonqsr )
 {
 	offs_t i;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	for (i = 0;i < 0x8000;i++)
 		decrypt[i] = decode_mooncrst(rom[i],i);
@@ -397,7 +397,7 @@
 
 DRIVER_INIT( 4in1 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	offs_t i, len = memory_region_length(machine, "maincpu");
 	UINT8 *RAM = memory_region(machine, "maincpu");
 
diff -Nru src-old/mame/machine/harddriv.c src/mame/machine/harddriv.c
--- src-old/mame/machine/harddriv.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/harddriv.c	2010-08-19 01:27:05.000000000 -0700
@@ -689,7 +689,7 @@
 }
 
 
-INLINE void stmsp_sync_w(const address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask, int which)
+INLINE void stmsp_sync_w(address_space *space, offs_t offset, UINT16 data, UINT16 mem_mask, int which)
 {
 	harddriv_state *state = space->machine->driver_data<harddriv_state>();
 	UINT16 newdata = state->stmsp_sync[which][offset];
@@ -1164,7 +1164,7 @@
 
 		while (count68k > 0 && state->adsp_data_memory[0x16e6] > 0)
 		{
-			memory_write_word(space, destaddr, state->ds3_gdata);
+			space->write_word(destaddr, state->ds3_gdata);
 			{
 				state->adsp_data_memory[0x16e6]--;
 				state->ds3_gdata = state->adsp_pgm_memory[i6] >> 8;
diff -Nru src-old/mame/machine/irobot.c src/mame/machine/irobot.c
--- src-old/mame/machine/irobot.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/machine/irobot.c	2010-08-21 15:25:58.000000000 -0700
@@ -588,7 +588,7 @@
 	UINT32 SP = 0;
 	UINT32 icount = 0;
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	while ((prevop->flags & (FL_DPSEL | FL_carry)) != (FL_DPSEL | FL_carry))
 	{
@@ -841,7 +841,7 @@
 				irmb_latch = Y;
 		}
 	}
-	profiler_mark_end();
+	g_profiler.stop();
 
 	logerror("%d instructions for Mathbox \n", icount);
 
diff -Nru src-old/mame/machine/kabuki.c src/mame/machine/kabuki.c
--- src-old/mame/machine/kabuki.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/kabuki.c	2010-08-19 07:19:38.000000000 -0700
@@ -161,13 +161,13 @@
 
 static void mitchell_decode(running_machine *machine, int swap_key1,int swap_key2,int addr_key,int xor_key)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, memory_region_length(machine, "maincpu"));
 	int numbanks = (memory_region_length(machine, "maincpu") - 0x10000) / 0x4000;
 	int i;
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 	kabuki_decode(rom,decrypt,rom,0x0000,0x8000, swap_key1,swap_key2,addr_key,xor_key);
 
 	rom += 0x10000;
@@ -202,11 +202,11 @@
 
 static void cps1_decode(running_machine *machine,int swap_key1,int swap_key2,int addr_key,int xor_key)
 {
-	const address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *decrypt = auto_alloc_array(machine, UINT8, 0x8000);
 	UINT8 *rom = memory_region(machine, "audiocpu");
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 	kabuki_decode(rom,decrypt,rom,0x0000,0x8000, swap_key1,swap_key2,addr_key,xor_key);
 }
 
diff -Nru src-old/mame/machine/kaneko16.c src/mame/machine/kaneko16.c
--- src-old/mame/machine/kaneko16.c	2010-06-15 13:16:27.000000000 -0700
+++ src/mame/machine/kaneko16.c	2010-08-19 01:27:05.000000000 -0700
@@ -1714,7 +1714,7 @@
 
 
 
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8* rom = memory_region(machine,"cpu1");
 	UINT8 numregions;
 	UINT16 length;
@@ -1814,11 +1814,11 @@
 					//printf("save to eeprom\n");
 
 					{
-						const address_space *eeprom_space = space->machine->device<eeprom_device>("eeprom")->space();
+						address_space *eeprom_space = space->machine->device<eeprom_device>("eeprom")->space();
 
 						for (i=0;i<0x80;i++)
 						{
-							memory_write_byte(eeprom_space, i, memory_read_byte(space, calc3_eeprom_addr+0x200000+i));
+							eeprom_space->write_byte(i, space->read_byte(calc3_eeprom_addr+0x200000+i));
 						}
 
 					}
@@ -1918,7 +1918,7 @@
 					{
 						if (space)
 						{
-							memory_write_byte(space, dstoffset+i, dat);
+							space->write_byte(dstoffset+i, dat);
 						}
 
 						// debug, used to output tables at the start
@@ -1992,7 +1992,7 @@
 					{
 						if (space)
 						{
-							memory_write_byte(space, dstoffset+i, dat);
+							space->write_byte(dstoffset+i, dat);
 						}
 
 						// debug, used to output tables at the start
@@ -2107,11 +2107,11 @@
 {
 	UINT16 mcu_command;
 	int i;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if ( calc3_mcu_status != (1|2|4|8) )	return;
 
-	if (calc3_dsw_addr) memory_write_byte(space, calc3_dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
+	if (calc3_dsw_addr) space->write_byte(calc3_dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
 
 
 	//calc3_mcu_status = 0;
@@ -2152,7 +2152,7 @@
 			printf("Calc 3 Init Command - %04x ROM Checksum Address\n",  cakc3_checkumaddress);
 			printf("Calc 3 Init Command - %08x Data Write Address\n",  calc3_writeaddress);
 #endif
-	//      memory_write_byte(space, calc3_dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
+	//      space->write_byte(calc3_dsw_addr+0x200000, ( ~input_port_read(machine, "DSW1"))&0xff); // // DSW // dsw actually updates in realtime - mcu reads+writes it every frame
 
 			kaneko16_mcu_ram[cakc3_checkumaddress / 2] = calc3_mcu_crc;				// MCU Rom Checksum!
 
@@ -2164,11 +2164,11 @@
             */
 
 			{
-				const address_space *eeprom_space = space->machine->device<eeprom_device>("eeprom")->space();
+				address_space *eeprom_space = space->machine->device<eeprom_device>("eeprom")->space();
 
 				for (i=0;i<0x80;i++)
 				{
-					memory_write_byte(space, calc3_eeprom_addr+0x200000+i, memory_read_byte(eeprom_space, i));
+					space->write_byte(calc3_eeprom_addr+0x200000+i, eeprom_space->read_byte(i));
 				}
 
 			}
@@ -2207,12 +2207,12 @@
 						printf("writing back address %08x to %08x %08x\n", calc3_writeaddress_current, commandaddr,write);
 #endif
 
-						memory_write_byte(space,write+0x200000, data_header[0]);
-						memory_write_byte(space,write+0x200001, data_header[1]);
+						space->write_byte(write+0x200000, data_header[0]);
+						space->write_byte(write+0x200001, data_header[1]);
 
 						write=commandaddr+(char)commandunk;
-						memory_write_word(space,write+0x200000, (calc3_writeaddress_current>>16)&0xffff);
-						memory_write_word(space,write+0x200002,  (calc3_writeaddress_current&0xffff));
+						space->write_word(write+0x200000, (calc3_writeaddress_current>>16)&0xffff);
+						space->write_word(write+0x200002,  (calc3_writeaddress_current&0xffff));
 
 						calc3_writeaddress_current += ((length+3)&(~1));
 					}
diff -Nru src-old/mame/machine/konami1.c src/mame/machine/konami1.c
--- src-old/mame/machine/konami1.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/konami1.c	2010-08-19 07:19:38.000000000 -0700
@@ -42,13 +42,13 @@
 
 UINT8 *konami1_decode(running_machine *machine, const char *cpu)
 {
-	const address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
 	const UINT8 *rom = memory_region(machine, cpu);
 	int size = memory_region_length(machine, cpu);
 	int A;
 
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, size);
-	memory_set_decrypted_region(space, 0x0000, 0xffff, decrypted);
+	space->set_decrypted_region(0x0000, 0xffff, decrypted);
 
 	for (A = 0;A < size;A++)
 	{
diff -Nru src-old/mame/machine/konamigx.c src/mame/machine/konamigx.c
--- src-old/mame/machine/konamigx.c	2010-06-17 07:04:37.000000000 -0700
+++ src/mame/machine/konamigx.c	2010-08-19 01:27:05.000000000 -0700
@@ -45,7 +45,7 @@
 
 				lim = adr+bsize*count;
 				for(i=adr; i<lim; i+=2)
-					memory_write_word(space, i, prot_data[0x1a/2]);
+					space->write_word(i, prot_data[0x1a/2]);
 			break;
 
 			// WARNING: The following cases are speculation based with questionable accuracy!(AAT)
@@ -76,41 +76,41 @@
 				// let's hope GCC will inline the mem24bew calls
 				for (src=adr; src<srcend; src+=bsize)
 				{
-					cx1 = (short)memory_read_word(space, src);
-					sx1 = (short)memory_read_word(space, src + 2);
-					wx1 = (short)memory_read_word(space, src + 4);
-
-					cy1 = (short)memory_read_word(space, src + 6);
-					sy1 = (short)memory_read_word(space, src + 8);
-					wy1 = (short)memory_read_word(space, src +10);
-
-					cz1 = (short)memory_read_word(space, src +12);
-					sz1 = (short)memory_read_word(space, src +14);
-					wz1 = (short)memory_read_word(space, src +16);
+					cx1 = (short)space->read_word(src);
+					sx1 = (short)space->read_word(src + 2);
+					wx1 = (short)space->read_word(src + 4);
+
+					cy1 = (short)space->read_word(src + 6);
+					sy1 = (short)space->read_word(src + 8);
+					wy1 = (short)space->read_word(src +10);
+
+					cz1 = (short)space->read_word(src +12);
+					sz1 = (short)space->read_word(src +14);
+					wz1 = (short)space->read_word(src +16);
 
 					count = i = src + skip;
 					tgt = src + bsize;
 
-					for (; count<tgt; count++) memory_write_byte(space, count, 0);
+					for (; count<tgt; count++) space->write_byte(count, 0);
 
 					for (; tgt<tgtend; i++, tgt+=bsize)
 					{
-						c2 = (short)memory_read_word(space, tgt);
-						s2 = (short)memory_read_word(space, tgt + 2);
-						w2 = (short)memory_read_word(space, tgt + 4);
+						c2 = (short)space->read_word(tgt);
+						s2 = (short)space->read_word(tgt + 2);
+						w2 = (short)space->read_word(tgt + 4);
 						if (abs((cx1+sx1)-(c2+s2))>=wx1+w2) continue; // X rejection
 
-						c2 = (short)memory_read_word(space, tgt + 6);
-						s2 = (short)memory_read_word(space, tgt + 8);
-						w2 = (short)memory_read_word(space, tgt +10);
+						c2 = (short)space->read_word(tgt + 6);
+						s2 = (short)space->read_word(tgt + 8);
+						w2 = (short)space->read_word(tgt +10);
 						if (abs((cy1+sy1)-(c2+s2))>=wy1+w2) continue; // Y rejection
 
-						c2 = (short)memory_read_word(space, tgt +12);
-						s2 = (short)memory_read_word(space, tgt +14);
-						w2 = (short)memory_read_word(space, tgt +16);
+						c2 = (short)space->read_word(tgt +12);
+						s2 = (short)space->read_word(tgt +14);
+						w2 = (short)space->read_word(tgt +16);
 						if (abs((cz1+sz1)-(c2+s2))>=wz1+w2) continue; // Z rejection
 
-						memory_write_byte(space, i, 0x80); // collision confirmed
+						space->write_byte(i, 0x80); // collision confirmed
 					}
 				}
 			break;
@@ -184,13 +184,13 @@
 				if (element_size == 1)
 				for (i=src_count; i; i--)
 				{
-					memory_write_byte(space, dst_addr, memory_read_byte(space, src_addr));
+					space->write_byte(dst_addr, space->read_byte(src_addr));
 					src_addr += src_skip;
 					dst_addr += dst_skip;
 				}
 				else for (i=src_count; i; i--)
 				{
-					memory_write_word(space, dst_addr, memory_read_word(space, src_addr));
+					space->write_word(dst_addr, space->read_word(src_addr));
 					src_addr += src_skip;
 					dst_addr += dst_skip;
 				}
@@ -215,15 +215,15 @@
 
 				for (i=mod_count; i; i--)
 				{
-					mod_val  = memory_read_word(space, mod_addr);
+					mod_val  = space->read_word(mod_addr);
 					mod_addr += mod_skip;
 
-					mod_data = memory_read_word(space, src_addr);
+					mod_data = space->read_word(src_addr);
 					src_addr += src_skip;
 
 					mod_data += mod_val;
 
-					memory_write_word(space, dst_addr, mod_data);
+					space->write_word(dst_addr, mod_data);
 					dst_addr += dst_skip;
 				}
 			break;
@@ -468,14 +468,14 @@
 		if(mode == 0x93)
 			for(i1=0; i1 <= sz2; i1++)
 				for(i2=0; i2 < db; i2+=4) {
-					memory_write_dword(space, da, memory_read_dword(space, sa) ^ x);
+					space->write_dword(da, space->read_dword(sa) ^ x);
 					da += 4;
 					sa += 4;
 				}
 		else if(mode == 0x8f)
 			for(i1=0; i1 <= sz2; i1++)
 				for(i2=0; i2 < db; i2+=4) {
-					memory_write_dword(space, da, x);
+					space->write_dword(da, x);
 					da += 4;
 				}
 	}
diff -Nru src-old/mame/machine/konppc.c src/mame/machine/konppc.c
--- src-old/mame/machine/konppc.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/konppc.c	2010-08-19 00:26:14.000000000 -0700
@@ -212,7 +212,7 @@
 	return dsp_comm_ppc[board][offset];
 }
 
-static void dsp_comm_sharc_w(const address_space *space, int board, int offset, UINT32 data)
+static void dsp_comm_sharc_w(address_space *space, int board, int offset, UINT32 data)
 {
 	if (offset >= 2)
 	{
@@ -351,7 +351,7 @@
 
 /*****************************************************************************/
 
-static UINT32 nwk_fifo_r(const address_space *space, int board)
+static UINT32 nwk_fifo_r(address_space *space, int board)
 {
 	const char *dsptag = (board == 0) ? "dsp" : "dsp2";
 	running_device *device = space->machine->device(dsptag);
diff -Nru src-old/mame/machine/mc8123.c src/mame/machine/mc8123.c
--- src-old/mame/machine/mc8123.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/mc8123.c	2010-08-19 07:19:38.000000000 -0700
@@ -377,7 +377,7 @@
 
 void mc8123_decrypt_rom(running_machine *machine, const char *cpu, const char *keyrgn, const char *bankname, int numbanks)
 {
-	const address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cpu, ADDRESS_SPACE_PROGRAM);
 	int fixed_length = numbanks == 1 ? 0xc000 : 0x8000;
 	UINT8 *decrypted1 = auto_alloc_array(machine, UINT8, fixed_length);
 	UINT8 *decrypted2 = numbanks > 1 ? auto_alloc_array(machine, UINT8, 0x4000 * numbanks) : 0;
@@ -385,7 +385,7 @@
 	UINT8 *key = memory_region(machine, keyrgn);
 	int A, bank;
 
-	memory_set_decrypted_region(space, 0x0000, fixed_length-1, decrypted1);
+	space->set_decrypted_region(0x0000, fixed_length-1, decrypted1);
 
 	for (A = 0x0000;A < fixed_length;A++)
 	{
diff -Nru src-old/mame/machine/mcr.c src/mame/machine/mcr.c
--- src-old/mame/machine/mcr.c	2010-07-16 05:01:50.000000000 -0700
+++ src/mame/machine/mcr.c	2010-08-19 00:26:14.000000000 -0700
@@ -592,7 +592,7 @@
 
 WRITE_LINE_DEVICE_HANDLER( zwackery_ca2_w )
 {
-	const address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	csdeluxe_data_w(space, 0, (state << 4) | zwackery_sound_data);
 }
 
diff -Nru src-old/mame/machine/mhavoc.c src/mame/machine/mhavoc.c
--- src-old/mame/machine/mhavoc.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/mhavoc.c	2010-08-19 00:26:14.000000000 -0700
@@ -5,7 +5,6 @@
 ***************************************************************************/
 
 #include "emu.h"
-#include "video/avgdvg.h"
 #include "sound/tms5220.h"
 #include "cpu/m6502/m6502.h"
 #include "includes/mhavoc.h"
@@ -101,7 +100,7 @@
 
 MACHINE_RESET( mhavoc )
 {
-	const address_space *space = cputag_get_address_space(machine, "alpha", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "alpha", ADDRESS_SPACE_PROGRAM);
 	has_gamma_cpu = (machine->device("gamma") != NULL);
 
 	memory_configure_bank(machine, "bank1", 0, 1, mhavoc_zram0, 0);
diff -Nru src-old/mame/machine/micro3d.c src/mame/machine/micro3d.c
--- src-old/mame/machine/micro3d.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/micro3d.c	2010-08-19 01:27:05.000000000 -0700
@@ -746,7 +746,7 @@
 DRIVER_INIT( micro3d )
 {
 	micro3d_state *state = machine->driver_data<micro3d_state>();
-	const address_space *space = cputag_get_address_space(machine, "drmath", ADDRESS_SPACE_DATA);
+	address_space *space = cputag_get_address_space(machine, "drmath", ADDRESS_SPACE_DATA);
 
 	i8051_set_serial_tx_callback(machine->device("audiocpu"), data_from_i8031);
 	i8051_set_serial_rx_callback(machine->device("audiocpu"), data_to_i8031);
@@ -755,7 +755,7 @@
 
 	/* The Am29000 program seems to rely on RAM from 0x00470000 onwards being
     non-zero on a reset, otherwise the 3D object data doesn't get uploaded! */
-	memory_write_dword(space, 0x00470000, 0xa5a5a5a5);
+	space->write_dword(0x00470000, 0xa5a5a5a5);
 
 	state->mc68901.timer_a = timer_alloc(machine, mfp_timer_a_cb, NULL);
 
@@ -767,7 +767,7 @@
 
 DRIVER_INIT( botssa )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Required to pass the hardware version check */
 	memory_install_read16_handler(space, 0x140000, 0x140001, 0, 0, botssa_140000_r );
diff -Nru src-old/mame/machine/midwayic.c src/mame/machine/midwayic.c
--- src-old/mame/machine/midwayic.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/midwayic.c	2010-08-19 00:26:14.000000000 -0700
@@ -205,7 +205,7 @@
 }
 
 
-UINT8 midway_serial_pic_r(const address_space *space)
+UINT8 midway_serial_pic_r(address_space *space)
 {
 	logerror("%s:security R = %04X\n", cpuexec_describe_context(space->machine), serial.buffer);
 	serial.status = 1;
@@ -213,7 +213,7 @@
 }
 
 
-void midway_serial_pic_w(const address_space *space, UINT8 data)
+void midway_serial_pic_w(address_space *space, UINT8 data)
 {
 	logerror("%s:security W = %04X\n", cpuexec_describe_context(space->machine), data);
 
@@ -293,7 +293,7 @@
 }
 
 
-UINT8 midway_serial_pic2_status_r(const address_space *space)
+UINT8 midway_serial_pic2_status_r(address_space *space)
 {
 	UINT8 result = 0;
 
@@ -312,7 +312,7 @@
 }
 
 
-UINT8 midway_serial_pic2_r(const address_space *space)
+UINT8 midway_serial_pic2_r(address_space *space)
 {
 	UINT8 result = 0;
 
@@ -332,7 +332,7 @@
 }
 
 
-void midway_serial_pic2_w(const address_space *space, UINT8 data)
+void midway_serial_pic2_w(address_space *space, UINT8 data)
 {
 	running_machine *machine = space->machine;
 	static FILE *nvramlog;
diff -Nru src-old/mame/machine/midwayic.h src/mame/machine/midwayic.h
--- src-old/mame/machine/midwayic.h	2008-12-19 12:40:22.000000000 -0800
+++ src/mame/machine/midwayic.h	2010-08-19 00:26:14.000000000 -0700
@@ -9,16 +9,16 @@
 void midway_serial_pic_init(running_machine *machine, int upper);
 void midway_serial_pic_reset_w(int state);
 UINT8 midway_serial_pic_status_r(void);
-UINT8 midway_serial_pic_r(const address_space *space);
-void midway_serial_pic_w(const address_space *space, UINT8 data);
+UINT8 midway_serial_pic_r(address_space *space);
+void midway_serial_pic_w(address_space *space, UINT8 data);
 
 
 /* 2nd generation Midway serial/NVRAM/RTC PIC */
 void midway_serial_pic2_init(running_machine *machine, int upper, int yearoffs);
 void midway_serial_pic2_set_default_nvram(const UINT8 *nvram);
-UINT8 midway_serial_pic2_status_r(const address_space *space);
-UINT8 midway_serial_pic2_r(const address_space *space);
-void midway_serial_pic2_w(const address_space *space, UINT8 data);
+UINT8 midway_serial_pic2_status_r(address_space *space);
+UINT8 midway_serial_pic2_r(address_space *space);
+void midway_serial_pic2_w(address_space *space, UINT8 data);
 NVRAM_HANDLER( midway_serial_pic2 );
 
 
diff -Nru src-old/mame/machine/midyunit.c src/mame/machine/midyunit.c
--- src-old/mame/machine/midyunit.c	2010-08-11 11:41:46.000000000 -0700
+++ src/mame/machine/midyunit.c	2010-08-19 01:27:05.000000000 -0700
@@ -95,7 +95,7 @@
 		{
 			if (data == 0x500)
 			{
-				prot_result = memory_read_word(space, TOBYTE(0x10a4390)) << 4;
+				prot_result = space->read_word(TOBYTE(0x10a4390)) << 4;
 				logerror("  desired result = %04X\n", prot_result);
 			}
 		}
diff -Nru src-old/mame/machine/model1.c src/mame/machine/model1.c
--- src-old/mame/machine/model1.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/model1.c	2010-08-19 00:26:14.000000000 -0700
@@ -42,7 +42,7 @@
 static UINT32 *ram_data;
 static float tgp_vr_base[4];
 
-static UINT32 fifoout_pop(const address_space *space)
+static UINT32 fifoout_pop(address_space *space)
 {
 	UINT32 v;
 	if(fifoout_wpos == fifoout_rpos) {
@@ -88,7 +88,7 @@
 	return v;
 }
 
-static void fifoin_push(const address_space *space, UINT32 data)
+static void fifoin_push(address_space *space, UINT32 data)
 {
 	//  logerror("TGP FIFOIN write %08x (%x)\n", data, cpu_get_pc(space->cpu));
 	fifoin_data[fifoin_wpos++] = data;
@@ -2010,7 +2010,7 @@
 	return 1;
 }
 
-static void copro_fifoin_push(const address_space *space, UINT32 data)
+static void copro_fifoin_push(address_space *space, UINT32 data)
 {
 	if (copro_fifoin_num == FIFO_SIZE)
 	{
@@ -2028,7 +2028,7 @@
 	copro_fifoin_num++;
 }
 
-static UINT32 copro_fifoout_pop(const address_space *space)
+static UINT32 copro_fifoout_pop(address_space *space)
 {
 	UINT32 r;
 
diff -Nru src-old/mame/machine/n64.c src/mame/machine/n64.c
--- src-old/mame/machine/n64.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/n64.c	2010-08-21 15:25:58.000000000 -0700
@@ -764,9 +764,9 @@
 
 		case 0x04/4:		// DP_END_REG
 			state->m_rdp.SetEndReg(data);
-			profiler_mark_start(PROFILER_USER1);
+			g_profiler.start(PROFILER_USER1);
 			state->m_rdp.ProcessList();
-			profiler_mark_end();
+			g_profiler.stop();
 			break;
 
 		case 0x0c/4:		// DP_STATUS_REG
@@ -1303,8 +1303,8 @@
 			{
 				for (i=0; i < dma_length; i++)
 				{
-					UINT8 b = memory_read_byte(space, pi_dram_addr);
-					memory_write_byte(space, pi_cart_addr & 0x1fffffff, b);
+					UINT8 b = space->read_byte(pi_dram_addr);
+					space->write_byte(pi_cart_addr & 0x1fffffff, b);
 					pi_cart_addr += 1;
 					pi_dram_addr += 1;
 				}
@@ -1331,13 +1331,13 @@
 			{
 				for (i=0; i < dma_length; i++)
 				{
-					/*UINT32 d = memory_read_dword(space, pi_cart_addr);
-                    memory_write_dword(space, pi_dram_addr, d);
+					/*UINT32 d = space->read_dword(pi_cart_addr);
+                    space->write_dword(pi_dram_addr, d);
                     pi_cart_addr += 4;
                     pi_dram_addr += 4;*/
 
-					UINT8 b = memory_read_byte(space, pi_cart_addr);
-					memory_write_byte(space, pi_dram_addr & 0x1fffffff, b);
+					UINT8 b = space->read_byte(pi_cart_addr);
+					space->write_byte(pi_dram_addr & 0x1fffffff, b);
 					pi_cart_addr += 1;
 					pi_dram_addr += 1;
 				}
@@ -1347,8 +1347,8 @@
 			if (pi_first_dma)
 			{
 				// TODO: CIC-6105 has different address...
-				memory_write_dword(space, 0x00000318, 0x400000);
-				memory_write_dword(space, 0x000003f0, 0x800000);
+				space->write_dword(0x00000318, 0x400000);
+				space->write_dword(0x000003f0, 0x800000);
 				pi_first_dma = 0;
 			}
 
@@ -1965,7 +1965,7 @@
 READ32_HANDLER( n64_pif_ram_r )
 {
     /*mame_printf_debug( "pif_ram_r: %08X, %08X = %08X\n", offset << 2, mem_mask, ( ( pif_ram[offset*4+0] << 24 ) | ( pif_ram[offset*4+1] << 16 ) | ( pif_ram[offset*4+2] <<  8 ) | ( pif_ram[offset*4+3] <<  0 ) ) & mem_mask );*/
-    if(!space->debugger_access)
+    if(!space->debugger_access())
     {
     	if( offset == ( 0x24 / 4 ) )
     	{
diff -Nru src-old/mame/machine/namcos1.c src/mame/machine/namcos1.c
--- src-old/mame/machine/namcos1.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/namcos1.c	2010-08-19 00:26:14.000000000 -0700
@@ -678,7 +678,7 @@
 		"bank9", "bank10", "bank11", "bank12", "bank13", "bank14", "bank15", "bank16"
 	};
 	static const char *const cputags[] = { "maincpu", "sub" };
-	const address_space *space = cputag_get_address_space(machine, cputags[(banknum >> 3) & 1], ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputags[(banknum >> 3) & 1], ADDRESS_SPACE_PROGRAM);
 	int bankstart = (banknum & 7) * 0x2000;
 
 	/* for BANK handlers , memory direct and OP-code base */
diff -Nru src-old/mame/machine/namcos2.c src/mame/machine/namcos2.c
--- src-old/mame/machine/namcos2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/namcos2.c	2010-08-19 00:26:14.000000000 -0700
@@ -110,7 +110,7 @@
 
 MACHINE_RESET( namcos2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	mFinalLapProtCount = 0;
 	namcos2_mcu_analog_ctrl = 0;
 	namcos2_mcu_analog_data = 0xaa;
@@ -486,7 +486,7 @@
 }
 
 static UINT16
-ReadWriteC148( const address_space *space, offs_t offset, UINT16 data, int bWrite )
+ReadWriteC148( address_space *space, offs_t offset, UINT16 data, int bWrite )
 {
 	offs_t addr = ((offset * 2) + 0x1c0000) & 0x1fe000;
 	running_device *altcpu = NULL;
diff -Nru src-old/mame/machine/neoboot.c src/mame/machine/neoboot.c
--- src-old/mame/machine/neoboot.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/neoboot.c	2010-08-19 00:26:14.000000000 -0700
@@ -139,7 +139,7 @@
 
 static UINT16 kof10thExtraRAMB[0x01000];
 
-static void kof10thBankswitch(const address_space *space, UINT16 nBank)
+static void kof10thBankswitch(address_space *space, UINT16 nBank)
 {
 	UINT32 bank = 0x100000 + ((nBank & 7) << 20);
 	if (bank >= 0x700000)
diff -Nru src-old/mame/machine/neoprot.c src/mame/machine/neoprot.c
--- src-old/mame/machine/neoprot.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/neoprot.c	2010-08-19 00:26:14.000000000 -0700
@@ -500,7 +500,7 @@
 }
 
 
-static void pvc_write_bankswitch( const address_space *space )
+static void pvc_write_bankswitch( address_space *space )
 {
 	neogeo_state *state = space->machine->driver_data<neogeo_state>();
 	UINT32 bankaddress;
diff -Nru src-old/mame/machine/pcshare.c src/mame/machine/pcshare.c
--- src-old/mame/machine/pcshare.c	2010-06-05 13:42:53.000000000 -0700
+++ src/mame/machine/pcshare.c	2010-08-19 01:27:05.000000000 -0700
@@ -163,7 +163,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	return memory_read_byte(space, page_offset + offset);
+	return space->read_byte(page_offset + offset);
 }
 
 
@@ -172,7 +172,7 @@
 	offs_t page_offset = (((offs_t) dma_offset[0][dma_channel]) << 16)
 		& 0xFF0000;
 
-	memory_write_byte(space, page_offset + offset, data);
+	space->write_byte(page_offset + offset, data);
 }
 
 static READ8_HANDLER(dma_page_select_r)
diff -Nru src-old/mame/machine/pitnrun.c src/mame/machine/pitnrun.c
--- src-old/mame/machine/pitnrun.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/pitnrun.c	2010-08-19 01:27:05.000000000 -0700
@@ -106,7 +106,7 @@
 
 WRITE8_HANDLER( pitnrun_68705_portB_w )
 {
-	const address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	if (~data & 0x02)
 	{
 		/* 68705 is going to read data from the Z80 */
@@ -121,11 +121,11 @@
 	}
 	if (~data & 0x10)
 	{
-		memory_write_byte(cpu0space, address, portA_out);
+		cpu0space->write_byte(address, portA_out);
 	}
 	if (~data & 0x20)
 	{
-		portA_in = memory_read_byte(cpu0space, address);
+		portA_in = cpu0space->read_byte(address);
 	}
 	if (~data & 0x40)
 	{
diff -Nru src-old/mame/machine/s16fd.c src/mame/machine/s16fd.c
--- src-old/mame/machine/s16fd.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/s16fd.c	2010-08-19 07:19:38.000000000 -0700
@@ -45,7 +45,7 @@
 	if (fd1094_set_decrypted != NULL)
 		(*fd1094_set_decrypted)(machine, (UINT8 *)fd1094_userregion);
 	else
-		memory_set_decrypted_region(cputag_get_address_space(machine, fd1094_cputag, ADDRESS_SPACE_PROGRAM), 0, fd1094_cpuregionsize - 1, fd1094_userregion);
+		machine->device<cpu_device>(fd1094_cputag)->space(AS_PROGRAM)->set_decrypted_region(0, fd1094_cpuregionsize - 1, fd1094_userregion);
 }
 
 /* this function checks the cache to see if the current state is cached,
diff -Nru src-old/mame/machine/s24fd.c src/mame/machine/s24fd.c
--- src-old/mame/machine/s24fd.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/s24fd.c	2010-08-19 07:19:38.000000000 -0700
@@ -55,7 +55,7 @@
 		{
 			/* copy cached state */
 			s24_fd1094_userregion = s24_fd1094_cacheregion[i];
-			memory_set_decrypted_region(cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM), 0, s24_fd1094_cpuregionsize - 1, s24_fd1094_userregion);
+			machine->device<cpu_device>("sub")->space(AS_PROGRAM)->set_decrypted_region(0, s24_fd1094_cpuregionsize - 1, s24_fd1094_userregion);
 			m68k_set_encrypted_opcode_range(machine->device("sub"), 0, s24_fd1094_cpuregionsize);
 
 			return;
@@ -76,7 +76,7 @@
 
 	/* copy newly decrypted data to user region */
 	s24_fd1094_userregion = s24_fd1094_cacheregion[fd1094_current_cacheposition];
-	memory_set_decrypted_region(cputag_get_address_space(machine, "sub", ADDRESS_SPACE_PROGRAM), 0, s24_fd1094_cpuregionsize - 1, s24_fd1094_userregion);
+	machine->device<cpu_device>("sub")->space(AS_PROGRAM)->set_decrypted_region(0, s24_fd1094_cpuregionsize - 1, s24_fd1094_userregion);
 	m68k_set_encrypted_opcode_range(machine->device("sub"), 0, s24_fd1094_cpuregionsize);
 
 	fd1094_current_cacheposition++;
diff -Nru src-old/mame/machine/scramble.c src/mame/machine/scramble.c
--- src-old/mame/machine/scramble.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/scramble.c	2010-08-19 01:27:05.000000000 -0700
@@ -140,12 +140,12 @@
 
 READ8_HANDLER( hunchbks_mirror_r )
 {
-	return memory_read_byte(space, 0x1000+offset);
+	return space->read_byte(0x1000+offset);
 }
 
 WRITE8_HANDLER( hunchbks_mirror_w )
 {
-	memory_write_byte(space, 0x1000+offset,data);
+	space->write_byte(0x1000+offset,data);
 }
 
 const ppi8255_interface scramble_ppi_0_intf =
diff -Nru src-old/mame/machine/scudsp.c src/mame/machine/scudsp.c
--- src-old/mame/machine/scudsp.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/scudsp.c	2010-08-19 01:27:05.000000000 -0700
@@ -312,7 +312,7 @@
 	return 0;
 }
 
-void dsp_prg_ctrl(const address_space *space, UINT32 data)
+void dsp_prg_ctrl(address_space *space, UINT32 data)
 {
 	if(LEF) dsp_reg.pc = (data & 0xff);
 	if(EXF) dsp_execute_program(space);
@@ -590,7 +590,7 @@
 }
 
 
-static void dsp_dma( const address_space *space )
+static void dsp_dma( address_space *space )
 {
 	UINT8 hold = (opcode &  0x4000) >> 14;
 	UINT32 add = (opcode & 0x38000) >> 15;
@@ -649,7 +649,7 @@
 
 			if ( source >= 0x06000000 && source <= 0x060fffff )
 			{
-				data = memory_read_dword(space, source );
+				data = space->read_dword(source );
 			}
 			else
 			{
@@ -687,7 +687,7 @@
 #endif
 		for ( counter = 0; counter < transfer_cnt; counter++ )
 		{
-			memory_write_dword(space, dest, dsp_get_mem_source_dma( dsp_mem, counter ) );
+			space->write_dword(dest, dsp_get_mem_source_dma( dsp_mem, counter ) );
 			dest += add;
 		}
 
@@ -786,7 +786,7 @@
 }
 #endif
 
-void dsp_execute_program(const address_space *dmaspace)
+void dsp_execute_program(address_space *dmaspace)
 {
 	UINT32 cycles_run = 0;
 	UINT8 cont = 1;
diff -Nru src-old/mame/machine/scudsp.h src/mame/machine/scudsp.h
--- src-old/mame/machine/scudsp.h	2008-11-23 15:32:24.000000000 -0800
+++ src/mame/machine/scudsp.h	2010-08-19 00:26:14.000000000 -0700
@@ -1,9 +1,9 @@
 /*SCU DSP stuff*/
 
-extern void dsp_prg_ctrl(const address_space *space, UINT32 data);
+extern void dsp_prg_ctrl(address_space *space, UINT32 data);
 extern void dsp_prg_data(UINT32 data);
 extern void dsp_ram_addr_ctrl(UINT32 data);
 extern void dsp_ram_addr_w(UINT32 data);
 extern UINT32 dsp_ram_addr_r(void);
-extern void dsp_execute_program(const address_space *dmaspace);
+extern void dsp_execute_program(address_space *dmaspace);
 
diff -Nru src-old/mame/machine/segacrp2.c src/mame/machine/segacrp2.c
--- src-old/mame/machine/segacrp2.c	2010-07-06 01:16:08.000000000 -0700
+++ src/mame/machine/segacrp2.c	2010-08-19 07:19:38.000000000 -0700
@@ -60,11 +60,11 @@
 	};
 
 
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, cputag);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0x8000);
 
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypted);
 
 
 	for (A = 0x0000;A < 0x8000;A++)
diff -Nru src-old/mame/machine/segacrpt.c src/mame/machine/segacrpt.c
--- src-old/mame/machine/segacrpt.c	2010-07-05 12:38:55.000000000 -0700
+++ src/mame/machine/segacrpt.c	2010-08-19 07:19:38.000000000 -0700
@@ -217,13 +217,13 @@
 {
 	int A;
 
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	int length = memory_region_length(machine, cputag);
 	int cryptlen = MIN(length, 0x8000);
 	UINT8 *rom = memory_region(machine, cputag);
 	UINT8 *decrypted = auto_alloc_array(machine, UINT8, 0xc000);
 
-	memory_set_decrypted_region(space, 0x0000, cryptlen - 1, decrypted);
+	space->set_decrypted_region(0x0000, cryptlen - 1, decrypted);
 
 	for (A = 0x0000;A < cryptlen;A++)
 	{
@@ -439,7 +439,7 @@
 
 	int A;
 
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, regiontag);
 	int bankstart;
 	decrypted = auto_alloc_array(machine, UINT8, 0x6000*3);
@@ -473,7 +473,7 @@
 
 	memory_configure_bank(machine, "bank1",0,3, memory_region(machine, regiontag),0x6000);
 	memory_configure_bank_decrypted(machine, "bank1",0,3,decrypted,0x6000);
-	memory_set_decrypted_region(space, 0x0000, 0x5fff, decrypted);
+	space->set_decrypted_region(0x0000, 0x5fff, decrypted);
 	memory_set_bank(space->machine, "bank1", 0);
 }
 
@@ -797,7 +797,7 @@
 
 	int A;
 
-	const address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, cputag, ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, cputag);
 	decrypted = auto_alloc_array(machine, UINT8, 0x9000);
 
@@ -832,7 +832,7 @@
 
 	memory_configure_bank(machine, "bank1",0,8, memory_region(machine, cputag)+0x7000,0x0400);
 	memory_configure_bank_decrypted(machine, "bank1",0,8,decrypted+0x7000,0x0400);
-	memory_set_decrypted_region(space, 0x0000, 0x6bff, decrypted);
+	space->set_decrypted_region(0x0000, 0x6bff, decrypted);
 	memory_set_bank(space->machine, "bank1", 0);
 }
 
diff -Nru src-old/mame/machine/segaic16.c src/mame/machine/segaic16.c
--- src-old/mame/machine/segaic16.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/machine/segaic16.c	2010-08-21 11:30:19.000000000 -0700
@@ -83,7 +83,7 @@
 
 	/* read original encrypted memory at that address */
 	recurse = 1;
-	result = memory_read_word_16be(space, cpu_get_pc(space->cpu));
+	result = space->read_word(cpu_get_pc(space->cpu));
 	recurse = 0;
 	return result;
 }
@@ -163,7 +163,7 @@
 }
 
 
-static void memory_mapper_w(const address_space *space, struct memory_mapper_chip *chip, offs_t offset, UINT8 data)
+static void memory_mapper_w(address_space *space, struct memory_mapper_chip *chip, offs_t offset, UINT8 data)
 {
 	UINT8 oldval;
 
@@ -212,16 +212,16 @@
 			/*   02 - read data into latches 00,01 from 2 * (address in 07,08,09) */
 			if (data == 0x01)
 			{
-				const address_space *targetspace = cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM);
+				address_space *targetspace = cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM);
 				offs_t addr = (chip->regs[0x0a] << 17) | (chip->regs[0x0b] << 9) | (chip->regs[0x0c] << 1);
-				memory_write_word(targetspace, addr, (chip->regs[0x00] << 8) | chip->regs[0x01]);
+				targetspace->write_word(addr, (chip->regs[0x00] << 8) | chip->regs[0x01]);
 			}
 			else if (data == 0x02)
 			{
-				const address_space *targetspace = cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM);
+				address_space *targetspace = cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM);
 				offs_t addr = (chip->regs[0x07] << 17) | (chip->regs[0x08] << 9) | (chip->regs[0x09] << 1);
 				UINT16 result;
-				result = memory_read_word(targetspace, addr);
+				result = targetspace->read_word(addr);
 				chip->regs[0x00] = result >> 8;
 				chip->regs[0x01] = result;
 			}
@@ -295,11 +295,12 @@
 static void update_memory_mapping(running_machine *machine, struct memory_mapper_chip *chip, int decrypt)
 {
 	int rgnum;
+	address_space *space = cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM);
 
 	if (LOG_MEMORY_MAP) mame_printf_debug("----\nRemapping:\n");
 
 	/* first reset everything back to the beginning */
-	memory_install_readwrite16_handler(cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM), 0x000000, 0xffffff, 0, 0, segaic16_memory_mapper_lsb_r, segaic16_memory_mapper_lsb_w);
+	memory_install_readwrite16_handler(space, 0x000000, 0xffffff, 0, 0, segaic16_memory_mapper_lsb_r, segaic16_memory_mapper_lsb_w);
 
 	/* loop over the regions */
 	for (rgnum = 0; chip->map[rgnum].regbase != 0; rgnum++)
@@ -328,13 +329,18 @@
 
 		/* map it */
 		if (read != NULL)
-			memory_install_read16_handler(cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM), region_start, region_end, 0, region_mirror, read);
+			memory_install_read16_handler(space, region_start, region_end, 0, region_mirror, read);
 		else if (readbank != NULL)
-			memory_install_read_bank(cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM), region_start, region_end, 0, region_mirror, readbank);
+			memory_install_read_bank(space, region_start, region_end, 0, region_mirror, readbank);
+		else
+			memory_install_read16_handler(space, region_start, region_end, 0, region_mirror, segaic16_open_bus_r);
+
 		if (write != NULL)
-			memory_install_write16_handler(cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM), region_start, region_end, 0, region_mirror, write);
+			memory_install_write16_handler(space, region_start, region_end, 0, region_mirror, write);
 		else if (writebank != NULL)
-			memory_install_write_bank(cpu_get_address_space(chip->cpu, ADDRESS_SPACE_PROGRAM), region_start, region_end, 0, region_mirror, writebank);
+			memory_install_write_bank(space, region_start, region_end, 0, region_mirror, writebank);
+		else
+			memory_unmap_write(space, region_start, region_end, 0, region_mirror);
 
 		/* set the bank pointer */
 		if (readbank != NULL)
diff -Nru src-old/mame/machine/segas24.c src/mame/machine/segas24.c
--- src-old/mame/machine/segas24.c	2010-03-08 10:06:27.000000000 -0800
+++ src/mame/machine/segas24.c	2010-08-19 00:26:14.000000000 -0700
@@ -27,14 +27,14 @@
 
 static UINT8  (*system24temp_sys16_io_io_r)(running_machine *machine, int port);
 static void   (*system24temp_sys16_io_io_w)(running_machine *machine, int port, UINT8 data);
-static void   (*system24temp_sys16_io_cnt_w)(const address_space *space, UINT8 data);
+static void   (*system24temp_sys16_io_cnt_w)(address_space *space, UINT8 data);
 static READ16_HANDLER ((*system24temp_sys16_io_iod_r));
 static WRITE16_HANDLER((*system24temp_sys16_io_iod_w));
 static UINT8 system24temp_sys16_io_cnt, system24temp_sys16_io_dir;
 
 void system24temp_sys16_io_set_callbacks(UINT8 (*io_r)(running_machine *machine, int port),
 							  void  (*io_w)(running_machine *machine, int port, UINT8 data),
-							  void  (*cnt_w)(const address_space *space, UINT8 data),
+							  void  (*cnt_w)(address_space *space, UINT8 data),
 							  read16_space_func iod_r,
 							  write16_space_func iod_w)
 {
diff -Nru src-old/mame/machine/segas32.c src/mame/machine/segas32.c
--- src-old/mame/machine/segas32.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/machine/segas32.c	2010-08-21 11:40:01.000000000 -0700
@@ -36,13 +36,14 @@
 static void nec_v25_cpu_decrypt(running_machine *machine)
 {
 	int i;
-	const address_space *space = cputag_get_address_space(machine, "mcu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "mcu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "mcu");
-	UINT8* decrypted = auto_alloc_array(machine, UINT8, 0x100000);
+	UINT8* decrypted = auto_alloc_array(machine, UINT8, 0x10000);
 	UINT8* temp = auto_alloc_array(machine, UINT8, 0x100000);
 
 	// set CPU3 opcode base
-	memory_set_decrypted_region(space, 0x00000, 0xfffff, decrypted);
+	space->set_decrypted_region(0x00000, 0x0ffff, decrypted);
+	space->set_decrypted_region(0xf0000, 0xfffff, decrypted);
 
 	// make copy of ROM so original can be overwritten
 	memcpy(temp, rom, 0x10000);
@@ -58,9 +59,6 @@
 		decrypted[i] = ga2_v25_opcode_table[ temp[j] ];
 	}
 
-	memcpy(rom+0xf0000, rom, 0x10000);
-	memcpy(decrypted+0xf0000, decrypted, 0x10000);
-
 	auto_free(machine, temp);
 }
 
@@ -228,17 +226,17 @@
 
 void darkedge_fd1149_vblank(running_device *device)
 {
-	const address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(device, ADDRESS_SPACE_PROGRAM);
 
-	memory_write_word(space, 0x20f072, 0);
-	memory_write_word(space, 0x20f082, 0);
+	space->write_word(0x20f072, 0);
+	space->write_word(0x20f082, 0);
 
-	if( memory_read_byte(space, 0x20a12c) != 0 )
+	if( space->read_byte(0x20a12c) != 0 )
 	{
-		memory_write_byte(space, 0x20a12c, memory_read_byte(space, 0x20a12c)-1 );
+		space->write_byte(0x20a12c, space->read_byte(0x20a12c)-1 );
 
-		if( memory_read_byte(space, 0x20a12c) == 0 )
-			memory_write_byte(space, 0x20a12e, 1);
+		if( space->read_byte(0x20a12c) == 0 )
+			space->write_byte(0x20a12e, 1);
 	}
 }
 
@@ -267,7 +265,7 @@
 
 WRITE16_HANDLER( dbzvrvs_protection_w )
 {
-	memory_write_word( space, 0x2080c8, memory_read_word( space, 0x200044 ) );
+	space->write_word( 0x2080c8, space->read_word( 0x200044 ) );
 }
 
 
@@ -331,12 +329,12 @@
 		// Map team browser selection to opponent browser selection
 		// using same lookup table that V60 uses for sound sample mapping.
 		case 0:
-			memory_write_byte( space, 0x20f708, memory_read_word( space, 0x7bbc0 + data*2 ) );
+			space->write_byte( 0x20f708, space->read_word( 0x7bbc0 + data*2 ) );
 			break;
 
 		// move on to team browser
 		case 4/2:
-			memory_write_byte( space, 0x200016, data & 0xff );
+			space->write_byte( 0x200016, data & 0xff );
 			break;
 
 		default:
diff -Nru src-old/mame/machine/seicop.c src/mame/machine/seicop.c
--- src-old/mame/machine/seicop.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/machine/seicop.c	2010-08-19 01:27:05.000000000 -0700
@@ -1505,16 +1505,16 @@
 /*      -the second value should be end of calculation (in other words,check everything between the two values) */
 #define PLAYER 0
 #define ENEMY 1
-static void protection_move_jsr(const address_space *space,UINT32 work_ram,UINT8 k)
+static void protection_move_jsr(address_space *space,UINT32 work_ram,UINT8 k)
 {
 	static UINT32 move_data,x_data,y_data;
 	/*Read the movement data to execute*/
-	move_data = ((memory_read_word(space, work_ram+0x34)<<16) & 0xffff0000) |
-	             (memory_read_word(space, work_ram+0x36) & 0xffff);
+	move_data = ((space->read_word(work_ram+0x34)<<16) & 0xffff0000) |
+	             (space->read_word(work_ram+0x36) & 0xffff);
 
 	/*Read the x/y axis of the sprite to change*/
-	x_data = (memory_read_word(space, work_ram+0x8));
-	y_data = (memory_read_word(space, work_ram+0x4));
+	x_data = (space->read_word(work_ram+0x8));
+	y_data = (space->read_word(work_ram+0x4));
 	/*it's bit sensitive AFAIK*/
 	/*move_data hi-word on player
       $17 = walk floor
@@ -1556,22 +1556,22 @@
 			break;
 	}
 	/*Write the new values to the sprite x/y data*/
-	memory_write_word(space, work_ram+0x8,x_data);
-	memory_write_word(space, work_ram+0x4,y_data);
+	space->write_word(work_ram+0x8,x_data);
+	space->write_word(work_ram+0x4,y_data);
 }
 
 
 static UINT16 hit_check;
 
-static void protection_hit_jsr(const address_space *space,UINT32 work_ram1,UINT32 work_ram2)
+static void protection_hit_jsr(address_space *space,UINT32 work_ram1,UINT32 work_ram2)
 {
 	int x1,y1,x2,y2/*,hit1,hit2*/;
-	x1 = (memory_read_word(space, work_ram1+0x8));
-	y1 = (memory_read_word(space, work_ram1+0x4));
-	//hit1 = (memory_read_word(space, work_ram1-));//this sprite is attacking
-	x2 = (memory_read_word(space, work_ram2+0x8));
-	y2 = (memory_read_word(space, work_ram2+0x4));
-	//hit2 = (memory_read_word(space));
+	x1 = (space->read_word(work_ram1+0x8));
+	y1 = (space->read_word(work_ram1+0x4));
+	//hit1 = (space->read_word(work_ram1-));//this sprite is attacking
+	x2 = (space->read_word(work_ram2+0x8));
+	y2 = (space->read_word(work_ram2+0x4));
+	//hit2 = (space));
 
 	popmessage("%08x:x=%04x y=%04x %08x:x=%04x y=%04x",work_ram1,x1,y1,work_ram2,x2,y2);
 
@@ -1585,46 +1585,46 @@
 }
 
 /*directional movement protection*/
-static void moveprot_jsr(const address_space *space)
+static void moveprot_jsr(address_space *space)
 {
 	static INT16 x_axis,y_axis;
 	static UINT16 move_data,distance,move_type;
-	move_data = memory_read_word(space, cop_register[0]+0x36);
-	x_axis = memory_read_word(space, cop_register[0]+0x08);
-	y_axis = memory_read_word(space, cop_register[0]+0x04);
+	move_data = space->read_word(cop_register[0]+0x36);
+	x_axis = space->read_word(cop_register[0]+0x08);
+	y_axis = space->read_word(cop_register[0]+0x04);
 
 	distance = (move_data & 0xf);
 	move_type = (move_data & 0xf0)>>4;
 	switch(move_type)
 	{
 		case 0x0f://right
-			memory_write_word(space, cop_register[0]+0x08,x_axis+distance);
-			//memory_write_word(space, 0x110004,);
+			space->write_word(cop_register[0]+0x08,x_axis+distance);
+			//space->write_word(0x110004,);
 			break;
 		case 0x0b://up
-			memory_write_word(space, cop_register[0]+0x04,y_axis-distance);
+			space->write_word(cop_register[0]+0x04,y_axis-distance);
 			break;
 		case 0x07://left
-			memory_write_word(space, cop_register[0]+0x08,x_axis-distance);
+			space->write_word(cop_register[0]+0x08,x_axis-distance);
 			break;
 		case 0x03://down
-			memory_write_word(space, cop_register[0]+0x04,y_axis+distance);
+			space->write_word(cop_register[0]+0x04,y_axis+distance);
 			break;
 		case 0x0d://up-right
-			memory_write_word(space, cop_register[0]+0x08,x_axis+distance);
-			memory_write_word(space, cop_register[0]+0x04,y_axis-distance);
+			space->write_word(cop_register[0]+0x08,x_axis+distance);
+			space->write_word(cop_register[0]+0x04,y_axis-distance);
 			break;
 		case 0x09://up-left
-			memory_write_word(space, cop_register[0]+0x04,y_axis-distance);
-			memory_write_word(space, cop_register[0]+0x08,x_axis-distance);
+			space->write_word(cop_register[0]+0x04,y_axis-distance);
+			space->write_word(cop_register[0]+0x08,x_axis-distance);
 			break;
 		case 0x01://down-right
-			memory_write_word(space, cop_register[0]+0x04,y_axis+distance);
-			memory_write_word(space, cop_register[0]+0x08,x_axis+distance);
+			space->write_word(cop_register[0]+0x04,y_axis+distance);
+			space->write_word(cop_register[0]+0x08,x_axis+distance);
 			break;
 		case 0x05://down-left
-			memory_write_word(space, cop_register[0]+0x04,y_axis+distance);
-			memory_write_word(space, cop_register[0]+0x08,x_axis-distance);
+			space->write_word(cop_register[0]+0x04,y_axis+distance);
+			space->write_word(cop_register[0]+0x08,x_axis-distance);
 			break;
 		default:
 			logerror("Warning: \"0x205\" command called with move_type parameter = %02x\n",move_type);
@@ -1632,11 +1632,11 @@
 			//down-right
 			//down-left
 	}
-	//memory_write_word(space, 0x110008,x_axis+tmp);
-	//memory_write_word(space, 0x110004,y_axis+tmp);
+	//space->write_word(0x110008,x_axis+tmp);
+	//space->write_word(0x110004,y_axis+tmp);
 
-	//memory_write_word(space, 0x110008,x_axis);
-	//memory_write_word(space, 0x110004,y_axis);
+	//space->write_word(0x110008,x_axis);
+	//space->write_word(0x110004,y_axis);
 }
 
 /*
@@ -1651,13 +1651,13 @@
 
 */
 /*sprite "look" protection*/
-static void move2prot_jsr(const address_space *space)
+static void move2prot_jsr(address_space *space)
 {
 	static INT16 x_pl,y_pl,x_en,y_en,res;
-	x_pl = memory_read_word(space, cop_register[1]+0x8);
-	y_pl = memory_read_word(space, cop_register[1]+0x4);
-	x_en = memory_read_word(space, cop_register[0]+0x8);
-	y_en = memory_read_word(space, cop_register[0]+0x4);
+	x_pl = space->read_word(cop_register[1]+0x8);
+	y_pl = space->read_word(cop_register[1]+0x4);
+	x_en = space->read_word(cop_register[0]+0x8);
+	y_en = space->read_word(cop_register[0]+0x4);
 
 	res = 0;
 	if(x_en > x_pl)
@@ -1669,37 +1669,37 @@
 	//if(y_en > y_pl)
 	//  res|=0x40;
 
-	memory_write_word(space, cop_register[0]+0x36,res);
+	space->write_word(cop_register[0]+0x36,res);
 }
 
 #ifdef UNUSED_FUNCTION
 /*"To point" movement protection*/
-static void move3x_prot_jsr(const address_space *space)
+static void move3x_prot_jsr(address_space *space)
 {
 	static INT16 x_pl,x_en,x_dis;
-	x_pl = memory_read_word(space, cop_register[1]+0x8);
-	x_en = memory_read_word(space, cop_register[0]+0x8);
-	x_dis = ((memory_read_word(space, cop_register[0]+0x34) & 0xf0) >> 4);
+	x_pl = space->read_word(cop_register[1]+0x8);
+	x_en = space->read_word(cop_register[0]+0x8);
+	x_dis = ((space->read_word(cop_register[0]+0x34) & 0xf0) >> 4);
 
 	if(x_en > x_pl)
 		x_dis^=0xffff;
 
-	memory_write_word(space, cop_register[0]+0x36,-0x40);/*enable command*/
-	memory_write_word(space, cop_register[0]+0x14,x_dis);
+	space->write_word(cop_register[0]+0x36,-0x40);/*enable command*/
+	space->write_word(cop_register[0]+0x14,x_dis);
 }
 
-static void move3y_prot_jsr(const address_space *space)
+static void move3y_prot_jsr(address_space *space)
 {
 	static INT16 y_pl,y_en,y_dis;
-	y_pl = memory_read_word(space, cop_register[1]+0x4);
-	y_en = memory_read_word(space, cop_register[0]+0x4);
-	y_dis = (memory_read_word(space, cop_register[0]+0x34) & 0xf);
+	y_pl = space->read_word(cop_register[1]+0x4);
+	y_en = space->read_word(cop_register[0]+0x4);
+	y_dis = (space->read_word(cop_register[0]+0x34) & 0xf);
 
 	if(y_en > y_pl)
 		y_dis^=0xffff;
 
-	memory_write_word(space, cop_register[0]+0x36,-0x80);/*enable command*/
-	memory_write_word(space, cop_register[0]+0x10,y_dis);
+	space->write_word(cop_register[0]+0x36,-0x80);/*enable command*/
+	space->write_word(cop_register[0]+0x10,y_dis);
 }
 #endif
 
@@ -1804,7 +1804,7 @@
 
 static UINT16 s_i;
 
-static void dma_transfer(const address_space *space)
+static void dma_transfer(address_space *space)
 {
 	static UINT16 rel_xy;
 	static UINT16 abs_x,abs_y;
@@ -1813,20 +1813,20 @@
 	//for(s_i = dma_size;s_i > 0;s_i--)
 	{
 		/*Sprite Color*/
-		param = memory_read_word(space, 0x100400) & 0x3f;
+		param = space->read_word(0x100400) & 0x3f;
 		/*Write the entire parameters [offs+0]*/
-		memory_write_word(space, cop_register[5]+4,memory_read_word(space, dma_src) + param);
+		space->write_word(cop_register[5]+4,space->read_word(dma_src) + param);
 		/*Sprite Priority (guess)*/
-		//param = ((memory_read_word(space, 0x100400) & 0x40) ? 0x4000 : 0);
+		//param = ((space->read_word(0x100400) & 0x40) ? 0x4000 : 0);
 		/*Write the sprite number [offs+1]*/
-		memory_write_word(space, cop_register[5]+6,memory_read_word(space, dma_src+2));
+		space->write_word(cop_register[5]+6,space->read_word(dma_src+2));
 		/*Sprite Relative x/y coords*/
-		rel_xy = memory_read_word(space, dma_src+4); /*???*/
+		rel_xy = space->read_word(dma_src+4); /*???*/
 		/*temporary hardwired,it should point to 0x4c0/0x4a0*/
-		abs_x = (memory_read_word(space, 0x110008) - memory_read_word(space, 0x10048e));
-		abs_y = (memory_read_word(space, 0x110004) - memory_read_word(space, 0x10048c));
-		memory_write_word(space, cop_register[5]+8,((rel_xy & 0x7f) + (abs_x) - ((rel_xy & 0x80) ? 0x80 : 0)) & 0x1ff);
-		memory_write_word(space, cop_register[5]+10,(((rel_xy & 0x7f00) >> 8) + (abs_y) + (0x10) - ((rel_xy & 0x8000) ? 0x80 : 0)) & 0x1ff);
+		abs_x = (space->read_word(0x110008) - space->read_word(0x10048e));
+		abs_y = (space->read_word(0x110004) - space->read_word(0x10048c));
+		space->write_word(cop_register[5]+8,((rel_xy & 0x7f) + (abs_x) - ((rel_xy & 0x80) ? 0x80 : 0)) & 0x1ff);
+		space->write_word(cop_register[5]+10,(((rel_xy & 0x7f00) >> 8) + (abs_y) + (0x10) - ((rel_xy & 0x8000) ? 0x80 : 0)) & 0x1ff);
 		cop_register[5]+=8;
 		dma_src+=6;
 	}
@@ -1834,7 +1834,7 @@
 
 
 /*
-    switch(memory_read_word(space, cop_register[2]))
+    switch(space->read_word(cop_register[2]))
     {
         case 0xb4: xparam = 0x0c/2; break;
         case 0xb8: xparam = 0x10/2; break;
@@ -1861,23 +1861,23 @@
 	return num;
 }
 
-static UINT16 hit_check_jsr(const address_space *space)
+static UINT16 hit_check_jsr(address_space *space)
 {
 	static INT16 xsrc,xdst,ysrc,ydst,xparam,yparam;
-	xsrc = (memory_read_word(space, 0x110008));
-	ysrc = (memory_read_word(space, 0x110004));
-	xdst = (memory_read_word(space, 0x110048));
-	ydst = (memory_read_word(space, 0x110044));
+	xsrc = (space->read_word(0x110008));
+	ysrc = (space->read_word(0x110004));
+	xdst = (space->read_word(0x110048));
+	ydst = (space->read_word(0x110044));
 
 	/*Here we check the destination sprite width*/
 	/*0x4a4/0x4c4*/
-	xparam = check_calc(memory_read_word(space, cop_register[2]));
+	xparam = check_calc(space->read_word(cop_register[2]));
 	/*Here we check the destination sprite height*/
 	/*0x4a6/0x4c6*/
-	yparam = check_calc(memory_read_word(space, cop_register[3]));
+	yparam = check_calc(space->read_word(cop_register[3]));
 
 	if(!xparam || !yparam)
-		popmessage("SRC:%04x %04x DST:%04x %04x V:%08x %08x",xsrc,ysrc,xdst,ydst,memory_read_word(space, cop_register[2]),memory_read_word(space, cop_register[3]));
+		popmessage("SRC:%04x %04x DST:%04x %04x V:%08x %08x",xsrc,ysrc,xdst,ydst,space->read_word(cop_register[2]),space->read_word(cop_register[3]));
 	if(xdst >= (xsrc-xparam) && ydst >= (ysrc-yparam) &&
 	   xdst <= (xsrc+xparam) && ydst <= (ysrc+yparam))
 		return 0;//sprites collide
@@ -1897,17 +1897,17 @@
 /*Heated Barrel*/
 /*command 0x8100 will check for the direction of the sprite*/
 /*command 0x8900 will check the "point" movement*/
-static void cop2_move3_prot(const address_space *space)
+static void cop2_move3_prot(address_space *space)
 {
 	static INT16 x_pl,x_en;
 	static INT16 y_pl,y_en;
 	static INT16 x_dis,y_dis;
 	static INT16 dir,dis;
-	x_pl = memory_read_word(space, cop_register[1]+0x8);
-	x_en = memory_read_word(space, cop_register[0]+0x8);
-	dis = ((memory_read_word(space, cop_register[0]+0x34) & 0xf0) >> 4);
-	y_pl = memory_read_word(space, cop_register[1]+0x4);
-	y_en = memory_read_word(space, cop_register[0]+0x4);
+	x_pl = space->read_word(cop_register[1]+0x8);
+	x_en = space->read_word(cop_register[0]+0x8);
+	dis = ((space->read_word(cop_register[0]+0x34) & 0xf0) >> 4);
+	y_pl = space->read_word(cop_register[1]+0x4);
+	y_en = space->read_word(cop_register[0]+0x4);
 
 	/*
     xxxx ---- select the direction of the enemy sprite
@@ -1946,7 +1946,7 @@
 			dir = DOWN;
 	}
 
-	memory_write_word(space, cop_register[0]+0x36,dir);
+	space->write_word(cop_register[0]+0x36,dir);
 
 	/*TODO*/
 	x_dis = (x_pl-x_en);
@@ -1970,12 +1970,12 @@
 	//if(x_en > x_pl)
 	//  x_dis^=0xffff;
 
-	memory_write_word(space, cop_register[0]+0x10,y_dis);
-	memory_write_word(space, cop_register[0]+0x14,x_dis);
+	space->write_word(cop_register[0]+0x10,y_dis);
+	space->write_word(cop_register[0]+0x14,x_dis);
 }
 
 /**/
-static UINT16 cop2_hit_prot(const address_space *space)
+static UINT16 cop2_hit_prot(address_space *space)
 {
 	static INT16 xsrc,xdst;
 	static INT16 ysrc,ydst;
@@ -1983,13 +1983,13 @@
 	static INT16 param1,param2;
 	static INT16 val;
 
-	param1 = memory_read_word(space, cop_register[2]);
-	param2 = memory_read_word(space, cop_register[3]);
+	param1 = space->read_word(cop_register[2]);
+	param2 = space->read_word(cop_register[3]);
 
-	xsrc = memory_read_word(space, cop_register[0]+0x8) + memory_read_word(space, cop_register[0]+0x14);
-	ysrc = memory_read_word(space, cop_register[0]+0x4) + memory_read_word(space, cop_register[0]+0x10);
-	xdst = memory_read_word(space, cop_register[1]+0x8) + memory_read_word(space, cop_register[1]+0x14);
-	ydst = memory_read_word(space, cop_register[1]+0x4) + memory_read_word(space, cop_register[1]+0x10);
+	xsrc = space->read_word(cop_register[0]+0x8) + space->read_word(cop_register[0]+0x14);
+	ysrc = space->read_word(cop_register[0]+0x4) + space->read_word(cop_register[0]+0x10);
+	xdst = space->read_word(cop_register[1]+0x8) + space->read_word(cop_register[1]+0x14);
+	ydst = space->read_word(cop_register[1]+0x4) + space->read_word(cop_register[1]+0x10);
 
 //  xp = (param1 & 0x00f0) >> 4;
 //  yp = (param1 & 0x0f00) >> 8;
@@ -2014,14 +2014,14 @@
 		return 3;
 }
 
-static void cop2_move2_prot(const address_space *space)
+static void cop2_move2_prot(address_space *space)
 {
 	static INT16 xsrc,ysrc;
 	static INT16 param2;
 
-	xsrc = memory_read_word(space, cop_register[0]+0x14);
-	ysrc = memory_read_word(space, cop_register[0]+0x10);
-	param2 = memory_read_word(space, cop_register[3]);
+	xsrc = space->read_word(cop_register[0]+0x14);
+	ysrc = space->read_word(cop_register[0]+0x10);
+	param2 = space->read_word(cop_register[3]);
 
 	switch(param2)
 	{
@@ -2035,8 +2035,8 @@
 		case 0x18:  ysrc++; xsrc++; break; //down-right
 	}
 
-	memory_write_word(space, cop_register[0]+0x14,xsrc);
-	memory_write_word(space, cop_register[0]+0x10,ysrc);
+	space->write_word(cop_register[0]+0x14,xsrc);
+	space->write_word(cop_register[0]+0x10,ysrc);
 }
 
 
@@ -2246,14 +2246,14 @@
 
 INLINE UINT32 r32(offs_t address)
 {
-	return	(memory_read_word(space, address + 0) << 0) |
-			(memory_read_word(space, address + 2) << 16);
+	return	(space->read_word(address + 0) << 0) |
+			(space->read_word(address + 2) << 16);
 }
 
 INLINE void w32(offs_t address, UINT32 data)
 {
-	memory_write_word(space, address + 0, data >> 0);
-	memory_write_word(space, address + 2, data >> 16);
+	space->write_word(address + 0, data >> 0);
+	space->write_word(address + 2, data >> 16);
 }
 
 
@@ -2325,7 +2325,7 @@
 				int count = (cop_ram_r(cop, 0x47a) + 1) << 5;
 				COP_LOG(("%05X:COP RAM clear from %05X to %05X\n", cpu_get_pc(space->cpu), addr, addr + count));
 				while (count--)
-					memory_write_byte(space, addr++, 0);
+					space->write_byte(addr++, 0);
 			}
 			else
 			{
@@ -2578,7 +2578,7 @@
 
 				for (i=address;i<address+length;i+=2)
 				{
-					memory_write_word(space, i, 0x0000);
+					space->write_word(i, 0x0000);
 				}
 			}
 			break;
@@ -2763,30 +2763,30 @@
 				case 0x8100:
 				{
 					UINT32 src = cop_register[0];
-					memory_write_word(space, src+0x36,0xffc0);
+					space->write_word(src+0x36,0xffc0);
 					break;
 				}
 				case 0x8900:
 				{
 					UINT32 src = cop_register[0];
-					memory_write_word(space, src+0x36,0xff80);
+					space->write_word(src+0x36,0xff80);
 					break;
 				}
 				/*Right*/
 				case 0x0205:
 				{
 					UINT32 src = cop_register[0];
-					INT16 y = memory_read_word(space, src+0x4);
-					INT16 x = memory_read_word(space, src+0x8);
-					INT16 y_rel = memory_read_word(space, src+0x10);
-					INT16 x_rel = memory_read_word(space, src+0x14);
-					memory_write_word(space, src+0x4,(y+y_rel));
-					memory_write_word(space, src+0x8,(x+x_rel));
+					INT16 y = space->read_word(src+0x4);
+					INT16 x = space->read_word(src+0x8);
+					INT16 y_rel = space->read_word(src+0x10);
+					INT16 x_rel = space->read_word(src+0x14);
+					space->write_word(src+0x4,(y+y_rel));
+					space->write_word(src+0x8,(x+x_rel));
 					/*logerror("%08x %08x %08x %08x %08x\n",cop_register[0],
-                                                   memory_read_word(space, cop_reg[0]+0x4),
-                                                   memory_read_word(space, cop_reg[0]+0x8),
-                                                   memory_read_word(space, cop_reg[0]+0x10),
-                                                   memory_read_word(space, cop_reg[0]+0x14));*/
+                                                   space->read_word(cop_reg[0]+0x4),
+                                                   space->read_word(cop_reg[0]+0x8),
+                                                   space->read_word(cop_reg[0]+0x10),
+                                                   space->read_word(cop_reg[0]+0x14));*/
 					break;
 				}
 				/*???*/
@@ -2794,10 +2794,10 @@
 				{
 					//UINT32 dst = cop_register[0];
 					//UINT32 dst = cop_register[1];
-					//memory_write_word(space, dst,  mame_rand(space->machine)/*memory_read_word(space, src)*/);
-					//memory_write_word(space, dst+2,mame_rand(space->machine)/*memory_read_word(space, src+2)*/);
-					//memory_write_word(space, dst+4,mame_rand(space->machine)/*memory_read_word(space, src+4)*/);
-					//memory_write_word(space, dst+6,mame_rand(space->machine)/*memory_read_word(space, src+6)*/);
+					//space->write_word(dst,  mame_rand(space->machine)/*space->read_word(src)*/);
+					//space->write_word(dst+2,mame_rand(space->machine)/*space->read_word(src+2)*/);
+					//space->write_word(dst+4,mame_rand(space->machine)/*space->read_word(src+4)*/);
+					//space->write_word(dst+6,mame_rand(space->machine)/*space->read_word(src+6)*/);
 					//logerror("%04x\n",cop_register[0]);
 					break;
 				}
@@ -3038,8 +3038,8 @@
 					dma_src+=4;
 					//cop_register[5]+=4;
 					s_i = dma_size;
-					//cop_register[5]+=((memory_read_word(space, 0x110000) & 0x000f) * 8);
-					//memory_write_word(space, 0x1004c8,cop_register[5] & 0xffff);
+					//cop_register[5]+=((space->read_word(0x110000) & 0x000f) * 8);
+					//space->write_word(0x1004c8,cop_register[5] & 0xffff);
 					//dma_status = 1;
 					break;
 				}
@@ -3237,8 +3237,8 @@
 			{
 				static UINT16 xy_data[2];
 				static UINT8 k;
-				xy_data[0] = memory_read_word(space, cop_register[2]);
-				xy_data[1] = memory_read_word(space, cop_register[3]);
+				xy_data[0] = space->read_word(cop_register[2]);
+				xy_data[1] = space->read_word(cop_register[3]);
 				k = (cop_mcu_ram[offset] == 0x0205) ? ENEMY : PLAYER;
 				protection_move_jsr(space,cop_register[0],k);
 				//protection_move_jsr(space,cop_register[1]); //???
diff -Nru src-old/mame/machine/slapstic.c src/mame/machine/slapstic.c
--- src-old/mame/machine/slapstic.c	2010-07-02 17:12:44.000000000 -0700
+++ src/mame/machine/slapstic.c	2010-08-19 09:10:19.000000000 -0700
@@ -864,7 +864,7 @@
  *
  *************************************/
 
-static int alt2_kludge(const address_space *space, offs_t offset)
+static int alt2_kludge(address_space *space, offs_t offset)
 {
 	/* Of the 3 alternate addresses, only the middle one needs to actually hit
        in the slapstic region; the first and third ones can be anywhere in the
@@ -879,7 +879,7 @@
 		if (MATCHES_MASK_VALUE(cpu_get_pc(space->cpu) >> 1, slapstic.alt1))
 		{
 			/* now look for a move.w (An),(An) or cmpm.w (An)+,(An)+ */
-			UINT16 opcode = memory_decrypted_read_word(space, cpu_get_previouspc(space->cpu) & 0xffffff);
+			UINT16 opcode = space->direct().read_decrypted_word(cpu_get_previouspc(space->cpu) & 0xffffff);
 			if ((opcode & 0xf1f8) == 0x3090 || (opcode & 0xf1f8) == 0xb148)
 			{
 				/* fetch the value of the register for the second operand, and see */
@@ -911,7 +911,7 @@
  *
  *************************************/
 
-int slapstic_tweak(const address_space *space, offs_t offset)
+int slapstic_tweak(address_space *space, offs_t offset)
 {
 	/* reset is universal */
 	if (offset == 0x0000)
diff -Nru src-old/mame/machine/snes.c src/mame/machine/snes.c
--- src-old/mame/machine/snes.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/snes.c	2010-08-19 01:27:05.000000000 -0700
@@ -26,9 +26,9 @@
 /* -- Globals -- */
 UINT8  *snes_ram = NULL;		/* 65816 ram */
 
-static void snes_dma(const address_space *space, UINT8 channels);
-static void snes_hdma_init(const address_space *space);
-static void snes_hdma(const address_space *space);
+static void snes_dma(address_space *space, UINT8 channels);
+static void snes_hdma_init(address_space *space);
+static void snes_hdma(address_space *space);
 
 static READ8_HANDLER(snes_io_dma_r);
 static WRITE8_HANDLER(snes_io_dma_w);
@@ -88,12 +88,12 @@
 {
 	snes_state *state = machine->driver_data<snes_state>();
 	// make sure we're in the 65816's context since we're messing with the OAM and stuff
-	const address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 
 	if (!(snes_ppu.screen_disabled)) //Reset OAM address, byuu says it happens at H=10
 	{
-		memory_write_byte(space, OAMADDL, snes_ppu.oam.saved_address_low); /* Reset oam address */
-		memory_write_byte(space, OAMADDH, snes_ppu.oam.saved_address_high);
+		space->write_byte(OAMADDL, snes_ppu.oam.saved_address_low); /* Reset oam address */
+		space->write_byte(OAMADDH, snes_ppu.oam.saved_address_high);
 		snes_ppu.oam.first_sprite = snes_ppu.oam.priority_rotation ? (snes_ppu.oam.address >> 1) & 127 : 0;
 	}
 }
@@ -101,14 +101,14 @@
 static TIMER_CALLBACK( snes_reset_hdma )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	snes_hdma_init(cpu0space);
 }
 
 static TIMER_CALLBACK( snes_update_io )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	state->io_read(cpu0space->machine);
 	snes_ram[HVBJOY] &= 0xfe;		/* Clear busy bit */
 
@@ -186,7 +186,7 @@
 	// hdma reset happens at scanline 0, H=~6
 	if (snes_ppu.beam.current_vert == 0)
 	{
-		const address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+		address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 		snes_hdma_init(cpu0space);
 	}
 
@@ -210,7 +210,7 @@
 static TIMER_CALLBACK( snes_hblank_tick )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
+	address_space *cpu0space = cpu_get_address_space(state->maincpu, ADDRESS_SPACE_PROGRAM);
 	int nextscan;
 
 	snes_ppu.beam.current_vert = machine->primary_screen->vpos();
@@ -296,7 +296,7 @@
 		return 0xff;
 
 	recurse = 1;
-	result = memory_read_byte_8le(space, cpu_get_pc(space->cpu) - 1); //LAST opcode that's fetched on the bus
+	result = space->read_byte(cpu_get_pc(space->cpu) - 1); //LAST opcode that's fetched on the bus
 	recurse = 0;
 	return result;
 }
@@ -476,7 +476,7 @@
 	switch (offset)
 	{
 		case WMDATA:	/* Data to read from WRAM */
-			value = memory_read_byte(space, 0x7e0000 + state->wram_address++);
+			value = space->read_byte(0x7e0000 + state->wram_address++);
 			state->wram_address &= 0x1ffff;
 			return value;
 		case OLDJOY1:	/* Data for old NES controllers (JOYSER1) */
@@ -625,7 +625,7 @@
 	switch (offset)
 	{
 		case WMDATA:	/* Data to write to WRAM */
-			memory_write_byte(space, 0x7e0000 + state->wram_address++, data );
+			space->write_byte(0x7e0000 + state->wram_address++, data );
 			state->wram_address &= 0x1ffff;
 			return;
 		case WMADDL:	/* Address to read/write to wram (low) */
@@ -914,7 +914,7 @@
 	UINT16 address = offset & 0xffff;
 
 	if (address < 0x2000)											/* Mirror of Low RAM */
-		value = memory_read_byte(space, 0x7e0000 + address);
+		value = space->read_byte(0x7e0000 + address);
 	else if (address < 0x6000)										/* I/O */
 	{
 		if (state->cart[0].mode == SNES_MODE_BSX && address >= 0x5000)
@@ -957,7 +957,7 @@
 	else
 		value = snes_ram[offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x00_0x3f_cycles(space->machine, offset));
 
 	return value;
@@ -971,7 +971,7 @@
 	UINT16 address = offset & 0xffff;
 
 	if (address < 0x2000)											/* Mirror of Low RAM */
-		value = memory_read_byte(space, 0x7e0000 + address);
+		value = space->read_byte(0x7e0000 + address);
 	else if (address < 0x6000)										/* I/O */
 	{
 		if (state->cart[0].mode == SNES_MODE_BSX && address >= 0x5000)
@@ -1020,7 +1020,7 @@
 	else
 		value = snes_ram[0x300000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x00_0x3f_cycles(space->machine, offset));
 
 	return value;
@@ -1061,7 +1061,7 @@
 	else											/* Mode 21 & 25 + SuperFX games */
 		value = snes_ram[0x400000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -8);
 
 	return value;
@@ -1099,7 +1099,7 @@
 	else if (state->cart[0].mode & 0x0a)					/* Mode 21 & 25 */
 		value = snes_ram[0x600000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -8);
 
 	return value;
@@ -1135,7 +1135,7 @@
 	else
 		value = snes_ram[0x700000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -8);
 
 	return value;
@@ -1149,17 +1149,17 @@
 	UINT16 address = offset & 0xffff;
 
 	if (state->has_addon_chip == HAS_SUPERFX)
-		value = memory_read_byte(space, offset);
+		value = space->read_byte(offset);
 	else if (address < 0x8000)
 	{
 		if (state->cart[0].mode != SNES_MODE_25)
-			value = memory_read_byte(space, offset);
+			value = space->read_byte(offset);
 		else if ((state->has_addon_chip == HAS_CX4) && (address >= 0x6000))
 			value = CX4_read(address - 0x6000);
 		else							/* Mode 25 has SRAM not mirrored from lower banks */
 		{
 			if (address < 0x6000)
-				value = memory_read_byte(space, offset);
+				value = space->read_byte(offset);
 			else if ((offset >= 0x300000) && (state->cart[0].sram > 0))
 			{
 //              int mask = state->cart[0].sram - 1; /* Limit SRAM size to what's actually present */
@@ -1183,7 +1183,7 @@
 	else
 		value = snes_ram[0x800000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x80_0xbf_cycles(space->machine, offset));
 
 	return value;
@@ -1229,14 +1229,14 @@
 	else if ((state->cart[0].mode & 5) && !(state->has_addon_chip == HAS_SUPERFX))		/* Mode 20 & 22 */
 	{
 		if (address < 0x8000)
-			value = memory_read_byte(space, 0x400000 + offset);
+			value = space->read_byte(0x400000 + offset);
 		else
 			value = snes_ram[0xc00000 + offset];
 	}
 	else								/* Mode 21 & 25 + SuperFX Games */
 		value = snes_ram[0xc00000 + offset];
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -((snes_ram[MEMSEL] & 1) ? 6 : 8));
 
 	return value;
@@ -1250,7 +1250,7 @@
 	UINT16 address = offset & 0xffff;
 
 	if (address < 0x2000)							/* Mirror of Low RAM */
-		memory_write_byte(space, 0x7e0000 + address, data);
+		space->write_byte(0x7e0000 + address, data);
 	else if (address < 0x6000)						/* I/O */
 	{
 		if (state->cart[0].mode == SNES_MODE_BSX && address >= 0x5000)
@@ -1290,7 +1290,7 @@
 	else
 		logerror( "(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset );
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x00_0x3f_cycles(space->machine, offset));
 }
 
@@ -1301,7 +1301,7 @@
 	UINT16 address = offset & 0xffff;
 
 	if (address < 0x2000)							/* Mirror of Low RAM */
-		memory_write_byte(space, 0x7e0000 + address, data);
+		space->write_byte(0x7e0000 + address, data);
 	else if (address < 0x6000)						/* I/O */
 	{
 		if (state->cart[0].mode == SNES_MODE_BSX && address >= 0x5000)
@@ -1347,7 +1347,7 @@
 	else
 		logerror("(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset + 0x300000);
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x00_0x3f_cycles(space->machine, offset));
 }
 
@@ -1373,7 +1373,7 @@
 	else if (state->cart[0].mode & 0x0a)
 		logerror("(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset + 0x600000);
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -8);
 }
 
@@ -1398,7 +1398,7 @@
 	else if (state->cart[0].mode & 0x0a)
 		logerror("(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset + 0x700000);
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -8);
 }
 
@@ -1410,17 +1410,17 @@
 	UINT16 address = offset & 0xffff;
 
 	if (state->has_addon_chip == HAS_SUPERFX)
-		memory_write_byte(space, offset, data);
+		space->write_byte(offset, data);
 	else if (address < 0x8000)
 	{
 		if ((state->has_addon_chip == HAS_CX4) && (address >= 0x6000))
 			CX4_write(space->machine, address - 0x6000, data);
 		else if (state->cart[0].mode != SNES_MODE_25)
-			memory_write_byte(space, offset, data);
+			space->write_byte(offset, data);
 		else	/* Mode 25 has SRAM not mirrored from lower banks */
 		{
 			if (address < 0x6000)
-				memory_write_byte(space, offset, data);
+				space->write_byte(offset, data);
 			else if ((offset >= 0x300000) && (state->cart[0].sram > 0))
 			{
 //              int mask = state->cart[0].sram - 1; /* Limit SRAM size to what's actually present */
@@ -1446,7 +1446,7 @@
 	else
 		logerror("(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset + 0x800000);
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -snes_bank_0x80_0xbf_cycles(space->machine, offset));
 }
 
@@ -1486,7 +1486,7 @@
 	else if (state->cart[0].mode & 0x0a)
 		logerror("(PC=%06x) Attempt to write to ROM address: %X\n",cpu_get_pc(space->cpu),offset + 0xc00000);
 
-	if(!space->debugger_access)
+	if(!space->debugger_access())
 		cpu_adjust_icount(space->cpu, -((snes_ram[MEMSEL] & 1) ? 6 : 8));
 }
 
@@ -1604,14 +1604,14 @@
 static void snes_init_ram( running_machine *machine )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *cpu0space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *cpu0space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* Init work RAM - 0x55 isn't exactly right but it's close */
 	/* make sure it happens to the 65816 (CPU 0) */
 	for (i = 0; i < (128*1024); i++)
 	{
-		memory_write_byte(cpu0space, 0x7e0000 + i, 0x55);
+		cpu0space->write_byte(0x7e0000 + i, 0x55);
 	}
 
 	/* Inititialize registers/variables */
@@ -1677,15 +1677,15 @@
 }
 
 
-static DIRECT_UPDATE_HANDLER( spc_direct )
+DIRECT_UPDATE_HANDLER( snes_spc_direct )
 {
-	direct->raw = direct->decrypted = spc_get_ram(space->machine->device("spc700"));
+	direct.explicit_configure(0x0000, 0xffff, 0xffff, spc_get_ram(machine->device("spc700")));
 	return ~0;
 }
 
-static DIRECT_UPDATE_HANDLER( snes_direct )
+DIRECT_UPDATE_HANDLER( snes_direct )
 {
-	direct->raw = direct->decrypted = snes_ram;
+	direct.explicit_configure(0x0000, 0xffff, 0xffff, snes_ram);
 	return ~0;
 }
 
@@ -1694,14 +1694,14 @@
 	snes_state *state = machine->driver_data<snes_state>();
 	int i;
 
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), snes_direct);
-	memory_set_direct_update_handler(cputag_get_address_space(machine, "soundcpu", ADDRESS_SPACE_PROGRAM), spc_direct);
-
 	state->maincpu = machine->device<_5a22_device>("maincpu");
 	state->soundcpu = machine->device<spc700_device>("soundcpu");
 	state->spc700 = machine->device<snes_sound_sound_device>("spc700");
 	state->superfx = machine->device<cpu_device>("superfx");
 
+	state->maincpu->space(AS_PROGRAM)->set_direct_update_handler(direct_update_delegate_create_static(snes_direct, *machine));
+	state->soundcpu->space(AS_PROGRAM)->set_direct_update_handler(direct_update_delegate_create_static(snes_spc_direct, *machine));
+
 	// power-on sets these registers like this
 	snes_ram[WRIO] = 0xff;
 	snes_ram[WRMPYA] = 0xff;
@@ -1836,7 +1836,7 @@
 DRIVER_INIT( snes )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 total_blocks, read_blocks;
 	UINT8 *rom;
 
@@ -1902,7 +1902,7 @@
 DRIVER_INIT( snes_hirom )
 {
 	snes_state *state = machine->driver_data<snes_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT16 total_blocks, read_blocks;
 	UINT8  *rom;
 
@@ -1976,15 +1976,15 @@
 	return 1;
 }
 
-INLINE UINT8 snes_abus_read( const address_space *space, UINT32 abus )
+INLINE UINT8 snes_abus_read( address_space *space, UINT32 abus )
 {
 	if (!dma_abus_valid(abus))
 		return 0;
 
-	return memory_read_byte(space, abus);
+	return space->read_byte(abus);
 }
 
-INLINE void snes_dma_transfer( const address_space *space, UINT8 dma, UINT32 abus, UINT16 bbus )
+INLINE void snes_dma_transfer( address_space *space, UINT8 dma, UINT32 abus, UINT16 bbus )
 {
 	snes_state *state = space->machine->driver_data<snes_state>();
 
@@ -1997,7 +1997,7 @@
 		{
 			//illegal WRAM->WRAM transfer (bus conflict)
 			//no read occurs; write does occur
-			memory_write_byte(space, abus, 0x00);
+			space->write_byte(abus, 0x00);
 			return;
 		}
 		else
@@ -2005,7 +2005,7 @@
 			if (!dma_abus_valid(abus))
 				return;
 
-			memory_write_byte(space, abus, memory_read_byte(space, bbus));
+			space->write_byte(abus, space->read_byte(bbus));
 			return;
 		}
 	}
@@ -2020,7 +2020,7 @@
 		}
 		else
 		{
-			memory_write_byte(space, bbus, snes_abus_read(space, abus));
+			space->write_byte(bbus, snes_abus_read(space, abus));
 			return;
 		}
 	}
@@ -2055,7 +2055,7 @@
 	return 1;
 }
 
-static void snes_hdma_update( const address_space *space, int dma )
+static void snes_hdma_update( address_space *space, int dma )
 {
 	snes_state *state = space->machine->driver_data<snes_state>();
 	UINT32 abus = snes_get_hdma_addr(space->machine, dma);
@@ -2086,7 +2086,7 @@
 	state->dma_channel[dma].do_transfer = 1;
 }
 
-static void snes_hdma_init( const address_space *space )
+static void snes_hdma_init( address_space *space )
 {
 	snes_state *state = space->machine->driver_data<snes_state>();
 	int i;
@@ -2102,7 +2102,7 @@
 	}
 }
 
-static void snes_hdma( const address_space *space )
+static void snes_hdma( address_space *space )
 {
 	snes_state *state = space->machine->driver_data<snes_state>();
 	UINT16 bbus;
@@ -2186,7 +2186,7 @@
 	}
 }
 
-static void snes_dma( const address_space *space, UINT8 channels )
+static void snes_dma( address_space *space, UINT8 channels )
 {
 	snes_state *state = space->machine->driver_data<snes_state>();
 	int i;
diff -Nru src-old/mame/machine/snes7110.c src/mame/machine/snes7110.c
--- src-old/mame/machine/snes7110.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/snes7110.c	2010-08-19 00:26:14.000000000 -0700
@@ -767,7 +767,7 @@
 }
 
 static void spc7110_mmio_write(running_machine *machine, UINT32 addr, UINT8 data);
-static UINT8 spc7110_mmio_read(const address_space *space, UINT32 addr);
+static UINT8 spc7110_mmio_read(address_space *space, UINT32 addr);
 static void spc7110_update_time(running_machine *machine, UINT8 offset);
 
 enum RTC_State
@@ -1066,7 +1066,7 @@
 	}
 }
 
-static UINT8 spc7110_mmio_read(const address_space *space, UINT32 addr)
+static UINT8 spc7110_mmio_read(address_space *space, UINT32 addr)
 {
 	running_machine *machine = space->machine;
 	UINT8 *ROM = memory_region(machine, "cart");
@@ -1639,7 +1639,7 @@
 	}
 }
 
-static UINT8 spc7110_bank7_read(const address_space *space, UINT32 offset)
+static UINT8 spc7110_bank7_read(address_space *space, UINT32 offset)
 {
 	UINT8 *ROM = memory_region(space->machine, "cart");
 	UINT32 addr = offset & 0x0fffff;
diff -Nru src-old/mame/machine/snescx4.c src/mame/machine/snescx4.c
--- src-old/mame/machine/snescx4.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/snescx4.c	2010-08-19 01:27:05.000000000 -0700
@@ -108,9 +108,10 @@
 	count = (cx4.reg[0x43]) | (cx4.reg[0x44] << 8);
 	dest  = (cx4.reg[0x45]) | (cx4.reg[0x46] << 8);
 
+	address_space *space = machine->device<cpu_device>("maincpu")->space(AS_PROGRAM);
 	for(i=0;i<count;i++)
 	{
-		CX4_write(machine, dest++, memory_read_byte(cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM), src++));
+		CX4_write(machine, dest++, space->read_byte(src++));
 	}
 }
 
diff -Nru src-old/mame/machine/snesrtc.c src/mame/machine/snesrtc.c
--- src-old/mame/machine/snesrtc.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/machine/snesrtc.c	2010-08-19 00:26:14.000000000 -0700
@@ -109,7 +109,7 @@
 	return (sum + 1) % 7; // 1900-01-01 was a Monday
 }
 
-static UINT8 srtc_read( const address_space *space, UINT16 addr )
+static UINT8 srtc_read( address_space *space, UINT16 addr )
 {
 	addr &= 0xffff;
 
diff -Nru src-old/mame/machine/snessdd1.c src/mame/machine/snessdd1.c
--- src-old/mame/machine/snessdd1.c	2010-04-07 10:51:09.000000000 -0700
+++ src/mame/machine/snessdd1.c	2010-08-19 00:26:14.000000000 -0700
@@ -569,7 +569,7 @@
 	snes_sdd1.buffer.ready = 0;
 }
 
-static UINT8 sdd1_mmio_read(const address_space *space, UINT32 addr)
+static UINT8 sdd1_mmio_read(address_space *space, UINT32 addr)
 {
 	addr &= 0xffff;
 
@@ -593,7 +593,7 @@
 	return snes_open_bus_r(space, 0);
 }
 
-static void sdd1_mmio_write(const address_space *space, UINT32 addr, UINT8 data)
+static void sdd1_mmio_write(address_space *space, UINT32 addr, UINT8 data)
 {
 	addr &= 0xffff;
 
diff -Nru src-old/mame/machine/starwars.c src/mame/machine/starwars.c
--- src-old/mame/machine/starwars.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/starwars.c	2010-08-13 01:54:21.000000000 -0700
@@ -10,7 +10,6 @@
 #include "emu.h"
 #include "includes/starwars.h"
 #include "machine/x2212.h"
-#include "video/avgdvg.h"
 
 
 /* Control select values for ADC_R */
diff -Nru src-old/mame/machine/stfight.c src/mame/machine/stfight.c
--- src-old/mame/machine/stfight.c	2010-01-18 02:34:43.000000000 -0800
+++ src/mame/machine/stfight.c	2010-08-19 07:19:38.000000000 -0700
@@ -49,12 +49,12 @@
 
 DRIVER_INIT( empcity )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	UINT8 *rom = memory_region(machine, "maincpu");
 	int A;
 
 	decrypt = auto_alloc_array(machine, UINT8, 0x8000);
-	memory_set_decrypted_region(space, 0x0000, 0x7fff, decrypt);
+	space->set_decrypted_region(0x0000, 0x7fff, decrypt);
 
 	for (A = 0;A < 0x8000;A++)
 	{
@@ -93,7 +93,7 @@
 
 MACHINE_RESET( stfight )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	adpcm_data_offs = adpcm_data_end = 0;
 	toggle = 0;
 	fm_data = 0;
diff -Nru src-old/mame/machine/tait8741.c src/mame/machine/tait8741.c
--- src-old/mame/machine/tait8741.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/tait8741.c	2010-08-19 00:26:14.000000000 -0700
@@ -122,7 +122,7 @@
 }
 
 /* 8741 update */
-static void taito8741_update(const address_space *space, int num)
+static void taito8741_update(address_space *space, int num)
 {
 	I8741 *st,*sst;
 	int next = num;
@@ -273,7 +273,7 @@
 }
 
 /* read status port */
-static int I8741_status_r(const address_space *space, int num)
+static int I8741_status_r(address_space *space, int num)
 {
 	I8741 *st = &taito8741[num];
 	taito8741_update(space, num);
@@ -282,7 +282,7 @@
 }
 
 /* read data port */
-static int I8741_data_r(const address_space *space, int num)
+static int I8741_data_r(address_space *space, int num)
 {
 	I8741 *st = &taito8741[num];
 	int ret = st->toData;
@@ -302,7 +302,7 @@
 }
 
 /* Write data port */
-static void I8741_data_w(const address_space *space, int num, int data)
+static void I8741_data_w(address_space *space, int num, int data)
 {
 	I8741 *st = &taito8741[num];
 	LOG(("%s:8741-%d DATA Write %02x\n",cpuexec_describe_context(space->machine),num,data));
@@ -313,7 +313,7 @@
 }
 
 /* Write command port */
-static void I8741_command_w(const address_space *space, int num, int data)
+static void I8741_command_w(address_space *space, int num, int data)
 {
 	I8741 *st = &taito8741[num];
 	LOG(("%s:8741-%d CMD Write %02x\n",cpuexec_describe_context(space->machine),num,data));
@@ -444,7 +444,7 @@
 	}
 }
 
-static void josvolly_8741_w(const address_space *space, int num, int offset, int data)
+static void josvolly_8741_w(address_space *space, int num, int offset, int data)
 {
 	JV8741 *mcu = &i8741[num];
 
@@ -507,7 +507,7 @@
 	josvolly_8741_do(space->machine, num);
 }
 
-static INT8 josvolly_8741_r(const address_space *space,int num,int offset)
+static INT8 josvolly_8741_r(address_space *space,int num,int offset)
 {
 	JV8741 *mcu = &i8741[num];
 	int ret;
@@ -548,7 +548,7 @@
 	cyclemb_mcu.rst = 1;
 }
 
-static void cyclemb_8741_w(const address_space *space, int num, int offset, int data)
+static void cyclemb_8741_w(address_space *space, int num, int offset, int data)
 {
 	if(offset == 1) //command port
 	{
@@ -590,7 +590,7 @@
 	}
 }
 
-static INT8 cyclemb_8741_r(const address_space *space,int num,int offset)
+static INT8 cyclemb_8741_r(address_space *space,int num,int offset)
 {
 	if(offset == 1) //status port
 	{
diff -Nru src-old/mame/machine/taitosj.c src/mame/machine/taitosj.c
--- src-old/mame/machine/taitosj.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/taitosj.c	2010-08-19 01:27:05.000000000 -0700
@@ -44,7 +44,7 @@
 
 MACHINE_RESET( taitosj )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	/* set the default ROM bank (many games only have one bank and */
 	/* never write to the bank selector register) */
 	taitosj_bankswitch_w(space, 0, 0);
@@ -216,18 +216,18 @@
 	}
 	if (~data & 0x10)
 	{
-		const address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 		LOG(("%04x: 68705 write %02x to address %04x\n",cpu_get_pc(space->cpu), portA_out, address));
 
-		memory_write_byte(cpu0space, address, portA_out);
+		cpu0space->write_byte(address, portA_out);
 
 		/* increase low 8 bits of latched address for burst writes */
 		address = (address & 0xff00) | ((address + 1) & 0xff);
 	}
 	if (~data & 0x20)
 	{
-		const address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-		portA_in = memory_read_byte(cpu0space, address);
+		address_space *cpu0space = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		portA_in = cpu0space->read_byte(address);
 		LOG(("%04x: 68705 read %02x from address %04x\n", cpu_get_pc(space->cpu), portA_in, address));
 	}
 	if (~data & 0x40)
diff -Nru src-old/mame/machine/tatsumi.c src/mame/machine/tatsumi.c
--- src-old/mame/machine/tatsumi.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/machine/tatsumi.c	2010-08-19 01:27:05.000000000 -0700
@@ -74,7 +74,7 @@
 
 READ16_HANDLER( apache3_v30_v20_r )
 {
-	const address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Each V20 byte maps to a V30 word */
 	if ((tatsumi_control_word & 0xe0) == 0xe0)
@@ -85,12 +85,12 @@
 		offset += 0x00000; // main ram
 	else
 		logerror("%08x: unmapped read z80 rom %08x\n", cpu_get_pc(space->cpu), offset);
-	return 0xff00 | memory_read_byte(targetspace, offset);
+	return 0xff00 | targetspace->read_byte(offset);
 }
 
 WRITE16_HANDLER( apache3_v30_v20_w )
 {
-	const address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	if ((tatsumi_control_word & 0xe0) != 0x80)
 		logerror("%08x: write unmapped v30 rom %08x\n", cpu_get_pc(space->cpu), offset);
@@ -98,7 +98,7 @@
 	/* Only 8 bits of the V30 data bus are connected - ignore writes to the other half */
 	if (ACCESSING_BITS_0_7)
 	{
-		memory_write_byte(targetspace, offset, data & 0xff);
+		targetspace->write_byte(offset, data & 0xff);
 	}
 }
 
@@ -150,18 +150,18 @@
 
 READ16_HANDLER( roundup_v30_z80_r )
 {
-	const address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Each Z80 byte maps to a V30 word */
 	if (tatsumi_control_word & 0x20)
 		offset += 0x8000; /* Upper half */
 
-	return 0xff00 | memory_read_byte(targetspace, offset);
+	return 0xff00 | targetspace->read_byte(offset);
 }
 
 WRITE16_HANDLER( roundup_v30_z80_w )
 {
-	const address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *targetspace = cputag_get_address_space(space->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Only 8 bits of the V30 data bus are connected - ignore writes to the other half */
 	if (ACCESSING_BITS_0_7)
@@ -169,7 +169,7 @@
 		if (tatsumi_control_word & 0x20)
 			offset += 0x8000; /* Upper half of Z80 address space */
 
-		memory_write_byte(targetspace, offset, data & 0xff);
+		targetspace->write_byte(offset, data & 0xff);
 	}
 }
 
@@ -345,7 +345,7 @@
 // self-test in Tatsumi games.  Needs fixed, but hack it here for now.
 READ8_DEVICE_HANDLER(tatsumi_hack_ym2151_r)
 {
-	const address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	int r=ym2151_status_port_r(device,0);
 
 	if (cpu_get_pc(space->cpu)==0x2aca || cpu_get_pc(space->cpu)==0x29fe
@@ -359,7 +359,7 @@
 // Mame really should emulate the OKI status reads even with Mame sound off.
 READ8_DEVICE_HANDLER(tatsumi_hack_oki_r)
 {
-	const address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(device->machine, "audiocpu", ADDRESS_SPACE_PROGRAM);
 	int r=okim6295_r(device,0);
 
 	if (cpu_get_pc(space->cpu)==0x2b70 || cpu_get_pc(space->cpu)==0x2bb5
diff -Nru src-old/mame/machine/tnzs.c src/mame/machine/tnzs.c
--- src-old/mame/machine/tnzs.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/machine/tnzs.c	2010-08-19 00:26:14.000000000 -0700
@@ -667,7 +667,7 @@
 static STATE_POSTLOAD( tnzs_postload )
 {
 	tnzs_state *state = machine->driver_data<tnzs_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	memory_set_bank(machine, "bank1", state->bank1);
 	memory_set_bank(machine, "bank2", state->bank2);
diff -Nru src-old/mame/machine/toaplan1.c src/mame/machine/toaplan1.c
--- src-old/mame/machine/toaplan1.c	2010-07-02 17:12:44.000000000 -0700
+++ src/mame/machine/toaplan1.c	2010-08-23 03:13:59.000000000 -0700
@@ -22,32 +22,28 @@
 	TOAPLAN1_REGION_OTHER
 };
 
-static UINT8 toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER+1][2][4];
-static UINT8 toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER+1][2][4];
-
-
-static int toaplan1_coin_count; /* coin count increments on startup ? , so dont count it */
-static int toaplan1_intenable;
-
-static int demonwld_dsp_on;
-static int demonwld_dsp_BIO;
-static int dsp_execute;                 /* Demon world */
-static UINT32 dsp_addr_w, main_ram_seg; /* Demon world */
-
-static UINT8 vimana_coins[2];
-static UINT8 vimana_credits;
-static UINT8 vimana_latch;
-
-
-int toaplan1_unk_reset_port;
-
-UINT8 *toaplan1_sharedram;
+static const UINT8 toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER+1][2][4] =
+{
+	{ { 1, 1, 2, 2 }, { 1, 1, 2, 2 } },	/* TOAPLAN1_REGION_JAPAN */
+	{ { 1, 1, 2, 2 }, { 1, 1, 2, 2 } },	/* TOAPLAN1_REGION_US */
+	{ { 1, 2, 3, 4 }, { 1, 1, 1, 1 } },	/* TOAPLAN1_REGION_WORLD */
+	{ { 1, 1, 1, 1 }, { 1, 1, 1, 1 } }	/* TOAPLAN1_REGION_OTHER */
+};
 
+static const UINT8 toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER+1][2][4] =
+{
+	{ { 1, 2, 1, 3 }, { 1, 2, 1, 3 } },	/* TOAPLAN1_REGION_JAPAN */
+	{ { 1, 2, 1, 3 }, { 1, 2, 1, 3 } },	/* TOAPLAN1_REGION_US */
+	{ { 1, 1, 1, 1 }, { 2, 3, 4, 6 } },	/* TOAPLAN1_REGION_WORLD */
+	{ { 1, 1, 1, 1 }, { 1, 1, 1, 1 } },	/* TOAPLAN1_REGION_OTHER */
+};
 
 
 INTERRUPT_GEN( toaplan1_interrupt )
 {
-	if (toaplan1_intenable)
+	toaplan1_state *state = device->machine->driver_data<toaplan1_state>();
+
+	if (state->intenable)
 		cpu_set_input_line(device, 4, HOLD_LINE);
 }
 
@@ -55,13 +51,16 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		toaplan1_intenable = data & 0xff;
+		toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+		state->intenable = data & 0xff;
 	}
 }
 
 
 WRITE16_HANDLER( demonwld_dsp_addrsel_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	/* This sets the main CPU RAM address the DSP should */
 	/*  read/write, via the DSP IO port 0 */
 	/* Top three bits of data need to be shifted left 9 places */
@@ -70,41 +69,44 @@
 	/* Lower thirteen bits of this data is shifted left one position */
 	/*  to move it to an even address word boundary */
 
-	main_ram_seg = ((data & 0xe000) << 9);
-	dsp_addr_w   = ((data & 0x1fff) << 1);
-	logerror("DSP PC:%04x IO write %04x (%08x) at port 0\n",cpu_get_previouspc(space->cpu),data,main_ram_seg + dsp_addr_w);
+	state->main_ram_seg = ((data & 0xe000) << 9);
+	state->dsp_addr_w   = ((data & 0x1fff) << 1);
+	logerror("DSP PC:%04x IO write %04x (%08x) at port 0\n", cpu_get_previouspc(space->cpu), data, state->main_ram_seg + state->dsp_addr_w);
 }
 
 READ16_HANDLER( demonwld_dsp_r )
 {
 	/* DSP can read data from main CPU RAM via DSP IO port 1 */
 
-	const address_space *mainspace;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+	address_space *mainspace;
 	UINT16 input_data = 0;
-	switch (main_ram_seg) {
+
+	switch (state->main_ram_seg) {
 		case 0xc00000:	mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						input_data = memory_read_word(mainspace, main_ram_seg + dsp_addr_w);
+						input_data = mainspace->read_word(state->main_ram_seg + state->dsp_addr_w);
 						break;
-		default:		logerror("DSP PC:%04x Warning !!! IO reading from %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w);
+		default:		logerror("DSP PC:%04x Warning !!! IO reading from %08x (port 1)\n", cpu_get_previouspc(space->cpu), state->main_ram_seg + state->dsp_addr_w);
 	}
-	logerror("DSP PC:%04x IO read %04x at %08x (port 1)\n",cpu_get_previouspc(space->cpu),input_data,main_ram_seg + dsp_addr_w);
+	logerror("DSP PC:%04x IO read %04x at %08x (port 1)\n", cpu_get_previouspc(space->cpu), input_data, state->main_ram_seg + state->dsp_addr_w);
 	return input_data;
 }
 
 WRITE16_HANDLER( demonwld_dsp_w )
 {
-	const address_space *mainspace;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+	address_space *mainspace;
 
 	/* Data written to main CPU RAM via DSP IO port 1 */
-	dsp_execute = 0;
-	switch (main_ram_seg) {
-		case 0xc00000:	if ((dsp_addr_w < 3) && (data == 0)) dsp_execute = 1;
+	state->dsp_execute = 0;
+	switch (state->main_ram_seg) {
+		case 0xc00000:	if ((state->dsp_addr_w < 3) && (data == 0)) state->dsp_execute = 1;
 						mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						memory_write_word(mainspace, main_ram_seg + dsp_addr_w, data);
+						mainspace->write_word(state->main_ram_seg + state->dsp_addr_w, data);
 						break;
-		default:		logerror("DSP PC:%04x Warning !!! IO writing to %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w);
+		default:		logerror("DSP PC:%04x Warning !!! IO writing to %08x (port 1)\n", cpu_get_previouspc(space->cpu), state->main_ram_seg + state->dsp_addr_w);
 	}
-	logerror("DSP PC:%04x IO write %04x at %08x (port 1)\n",cpu_get_previouspc(space->cpu),data,main_ram_seg + dsp_addr_w);
+	logerror("DSP PC:%04x IO write %04x at %08x (port 1)\n", cpu_get_previouspc(space->cpu), data, state->main_ram_seg + state->dsp_addr_w);
 }
 
 WRITE16_HANDLER( demonwld_dsp_bio_w )
@@ -114,29 +116,36 @@
 	/*              Actually only DSP data bit 15 controls this */
 	/* data 0x0000  means set DSP BIO line active and disable */
 	/*              communication to main processor*/
-	logerror("DSP PC:%04x IO write %04x at port 3\n",cpu_get_previouspc(space->cpu),data);
+
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	logerror("DSP PC:%04x IO write %04x at port 3\n", cpu_get_previouspc(space->cpu), data);
 	if (data & 0x8000) {
-		demonwld_dsp_BIO = CLEAR_LINE;
+		state->dsp_BIO = CLEAR_LINE;
 	}
 	if (data == 0) {
-		if (dsp_execute) {
+		if (state->dsp_execute) {
 			logerror("Turning 68000 on\n");
 			cputag_set_input_line(space->machine, "maincpu", INPUT_LINE_HALT, CLEAR_LINE);
-			dsp_execute = 0;
+			state->dsp_execute = 0;
 		}
-		demonwld_dsp_BIO = ASSERT_LINE;
+		state->dsp_BIO = ASSERT_LINE;
 	}
 }
 
 READ16_HANDLER ( demonwld_BIO_r )
 {
-	return demonwld_dsp_BIO;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->dsp_BIO;
 }
 
 
 static void demonwld_dsp(running_machine *machine, int enable)
 {
-	demonwld_dsp_on = enable;
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state->dsp_on = enable;
 	if (enable)
 	{
 		logerror("Turning DSP on and 68000 off\n");
@@ -151,9 +160,11 @@
 		cputag_set_input_line(machine, "dsp", INPUT_LINE_HALT, ASSERT_LINE);
 	}
 }
+
 static STATE_POSTLOAD( demonwld_restore_dsp )
 {
-	demonwld_dsp(machine, demonwld_dsp_on);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+	demonwld_dsp(machine, state->dsp_on);
 }
 
 WRITE16_HANDLER( demonwld_dsp_ctrl_w )
@@ -187,37 +198,41 @@
 
 READ16_HANDLER ( vimana_system_port_r )
 {
-	int data, p, r, d, slot, reg, dsw;
+	static const UINT8 vimana_region[16] =
+	{
+		TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_US   , TOAPLAN1_REGION_WORLD, TOAPLAN1_REGION_JAPAN,
+		TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_US   ,
+		TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER,
+		TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_JAPAN
+	};
 
-    UINT8 vimana_region[16] = { TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_US   , TOAPLAN1_REGION_WORLD, TOAPLAN1_REGION_JAPAN,
-    							TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_US   ,
-    							TOAPLAN1_REGION_JAPAN, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER,
-    							TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_OTHER, TOAPLAN1_REGION_JAPAN };
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+	int data, p, r, d, slot, reg, dsw;
 
 	slot = -1;
 	d = input_port_read(space->machine, "DSWA");
 	r = input_port_read(space->machine, "TJUMP");
 	p = input_port_read(space->machine, "SYSTEM");
-	vimana_latch ^= p;
-	data = (vimana_latch & p);
+	state->vimana_latch ^= p;
+	data = (state->vimana_latch & p);
 
 	/* simulate the mcu keeping track of credits based on region and coinage settings */
 	/* latch so it doesn't add more than one coin per keypress */
 	if (d & 0x04)   /* "test mode" ON */
 	{
-		vimana_coins[0] = vimana_coins[1] = 0;
-		vimana_credits = 0;
+		state->vimana_coins[0] = state->vimana_coins[1] = 0;
+		state->vimana_credits = 0;
 	}
 	else            /* "test mode" OFF */
 	{
 		if (data & 0x02)      /* TILT */
 		{
-			vimana_coins[0] = vimana_coins[1] = 0;
-			vimana_credits = 0;
+			state->vimana_coins[0] = state->vimana_coins[1] = 0;
+			state->vimana_credits = 0;
 		}
 		if (data & 0x01)      /* SERVICE1 */
 		{
-			vimana_credits++ ;
+			state->vimana_credits++ ;
 		}
 		if (data & 0x08)      /* COIN1 */
 		{
@@ -232,23 +247,23 @@
 		{
 			reg = vimana_region[r];
 			dsw = (d & 0xf0) >> (4 + 2 * slot);
-			vimana_coins[slot]++;
-			if (vimana_coins[slot] >= toaplan1_coins_for_credit[reg][slot][dsw])
+			state->vimana_coins[slot]++;
+			if (state->vimana_coins[slot] >= toaplan1_coins_for_credit[reg][slot][dsw])
 			{
-				vimana_credits += toaplan1_credits_for_coin[reg][slot][dsw];
-				vimana_coins[slot] -= toaplan1_coins_for_credit[reg][slot][dsw];
+				state->vimana_credits += toaplan1_credits_for_coin[reg][slot][dsw];
+				state->vimana_coins[slot] -= toaplan1_coins_for_credit[reg][slot][dsw];
 			}
 			coin_counter_w(space->machine, slot, 1);
 			coin_counter_w(space->machine, slot, 0);
 		}
 
-		if (vimana_credits >= 9)
-			vimana_credits = 9;
+		if (state->vimana_credits >= 9)
+			state->vimana_credits = 9;
 	}
 
-	coin_lockout_global_w(space->machine, (vimana_credits >= 9));
+	coin_lockout_global_w(space->machine, (state->vimana_credits >= 9));
 
-	vimana_latch = p;
+	state->vimana_latch = p;
 
 	return p & 0xffff;
 }
@@ -260,7 +275,12 @@
 	{
 		case 0:  data = 0xff; break;
 		case 1:  data = 0x00; break;
-		case 2:  data = vimana_credits; break;
+		case 2:
+		{
+			toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+			data = state->vimana_credits;
+			break;
+		}
 	}
 	return data & 0xff;
 }
@@ -271,25 +291,29 @@
 	{
 		case 0:	break;
 		case 1:	break;
-		case 2:	if (ACCESSING_BITS_0_7)
-				{
-					vimana_credits = data & 0xff;
-					coin_lockout_global_w(space->machine, (vimana_credits >= 9));
-				}
-				break;
+		case 2:
+			if (ACCESSING_BITS_0_7)
+			{
+				toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+				state->vimana_credits = data & 0xff;
+				coin_lockout_global_w(space->machine, (state->vimana_credits >= 9));
+			}
+			break;
 	}
 }
 
 READ16_HANDLER( toaplan1_shared_r )
 {
-	return toaplan1_sharedram[offset] & 0xff;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+	return state->sharedram[offset] & 0xff;
 }
 
 WRITE16_HANDLER( toaplan1_shared_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		toaplan1_sharedram[offset] = data & 0xff;
+		toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+		state->sharedram[offset] = data & 0xff;
 	}
 }
 
@@ -311,15 +335,17 @@
 
 WRITE8_HANDLER( rallybik_coin_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	switch (data) {
-		case 0x08: if (toaplan1_coin_count) { coin_counter_w(space->machine, 0,1); coin_counter_w(space->machine, 0,0); } break;
-		case 0x09: if (toaplan1_coin_count) { coin_counter_w(space->machine, 2,1); coin_counter_w(space->machine, 2,0); } break;
-		case 0x0a: if (toaplan1_coin_count) { coin_counter_w(space->machine, 1,1); coin_counter_w(space->machine, 1,0); } break;
-		case 0x0b: if (toaplan1_coin_count) { coin_counter_w(space->machine, 3,1); coin_counter_w(space->machine, 3,0); } break;
-		case 0x0c: coin_lockout_w(space->machine, 0,1); coin_lockout_w(space->machine, 2,1); break;
-		case 0x0d: coin_lockout_w(space->machine, 0,0); coin_lockout_w(space->machine, 2,0); break;
-		case 0x0e: coin_lockout_w(space->machine, 1,1); coin_lockout_w(space->machine, 3,1); break;
-		case 0x0f: coin_lockout_w(space->machine, 1,0); coin_lockout_w(space->machine, 3,0); toaplan1_coin_count=1; break;
+		case 0x08: if (state->coin_count) { coin_counter_w(space->machine, 0, 1); coin_counter_w(space->machine, 0, 0); } break;
+		case 0x09: if (state->coin_count) { coin_counter_w(space->machine, 2, 1); coin_counter_w(space->machine, 2, 0); } break;
+		case 0x0a: if (state->coin_count) { coin_counter_w(space->machine, 1, 1); coin_counter_w(space->machine, 1, 0); } break;
+		case 0x0b: if (state->coin_count) { coin_counter_w(space->machine, 3, 1); coin_counter_w(space->machine, 3, 0); } break;
+		case 0x0c: coin_lockout_w(space->machine, 0, 1); coin_lockout_w(space->machine, 2, 1); break;
+		case 0x0d: coin_lockout_w(space->machine, 0, 0); coin_lockout_w(space->machine, 2, 0); break;
+		case 0x0e: coin_lockout_w(space->machine, 1, 1); coin_lockout_w(space->machine, 3, 1); break;
+		case 0x0f: coin_lockout_w(space->machine, 1, 0); coin_lockout_w(space->machine, 3, 0); state->coin_count=1; break;
 		default:   logerror("PC:%04x  Writing unknown data (%04x) to coin count/lockout port\n",cpu_get_previouspc(space->cpu),data); break;
 	}
 }
@@ -367,95 +393,71 @@
 }
 
 
-static void toaplan1_init_coinage_tables(running_machine *machine)
-{
-	/* Japan */
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][0][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][0][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][0][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][0][1] = 2;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][0][2] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][0][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][0][3] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][0][3] = 3;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][1][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][1][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][1][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][1][1] = 2;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][1][2] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][1][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_JAPAN][1][3] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_JAPAN][1][3] = 3;
-	/* US = Japan */
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][0][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][0][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][0][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][0][1] = 2;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][0][2] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][0][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][0][3] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][0][3] = 3;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][1][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][1][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][1][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][1][1] = 2;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][1][2] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][1][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_US   ][1][3] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_US   ][1][3] = 3;
-	/* World */
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][0][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][0][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][0][1] = 2; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][0][1] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][0][2] = 3; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][0][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][0][3] = 4; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][0][3] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][1][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][1][0] = 2;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][1][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][1][1] = 3;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][1][2] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][1][2] = 4;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_WORLD][1][3] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_WORLD][1][3] = 6;
-	/* Other - as it is an unknown or invalid setting, I set everything to 1C_1C */
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][0][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][0][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][0][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][0][1] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][0][2] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][0][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][0][3] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][0][3] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][1][0] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][1][0] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][1][1] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][1][1] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][1][2] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][1][2] = 1;
-	toaplan1_coins_for_credit[TOAPLAN1_REGION_OTHER][1][3] = 1; toaplan1_credits_for_coin[TOAPLAN1_REGION_OTHER][1][3] = 1;
-}
-
 MACHINE_RESET( toaplan1 )
 {
-	toaplan1_intenable = 0;
-	toaplan1_coin_count = 0;
-	toaplan1_unk_reset_port = 0;
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state->intenable = 0;
+	state->coin_count = 0;
+	state->unk_reset_port = 0;
 	coin_lockout_global_w(machine, 0);
 }
+
 void toaplan1_driver_savestate(running_machine *machine)
 {
-	state_save_register_global(machine, toaplan1_intenable);
-	state_save_register_global(machine, toaplan1_coin_count);
-	state_save_register_global(machine, toaplan1_unk_reset_port);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state_save_register_global(machine, state->intenable);
+	state_save_register_global(machine, state->coin_count);
+	state_save_register_global(machine, state->unk_reset_port);
 }
 
 MACHINE_RESET( zerowing )	/* Hack for ZeroWing and OutZone. See the video driver */
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	MACHINE_RESET_CALL(toaplan1);
-	toaplan1_unk_reset_port = 1;
+	state->unk_reset_port = 1;
 }
 
 MACHINE_RESET( demonwld )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	MACHINE_RESET_CALL(toaplan1);
-	dsp_addr_w = 0;
-	main_ram_seg = 0;
-	dsp_execute = 0;
+	state->dsp_addr_w = 0;
+	state->main_ram_seg = 0;
+	state->dsp_execute = 0;
 }
+
 void demonwld_driver_savestate(running_machine *machine)
 {
-	state_save_register_global(machine, demonwld_dsp_on);
-	state_save_register_global(machine, dsp_addr_w);
-	state_save_register_global(machine, main_ram_seg);
-	state_save_register_global(machine, demonwld_dsp_BIO);
-	state_save_register_global(machine, dsp_execute);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state_save_register_global(machine, state->dsp_on);
+	state_save_register_global(machine, state->dsp_addr_w);
+	state_save_register_global(machine, state->main_ram_seg);
+	state_save_register_global(machine, state->dsp_BIO);
+	state_save_register_global(machine, state->dsp_execute);
 	state_save_register_postload(machine, demonwld_restore_dsp, NULL);
 }
 
 MACHINE_RESET( vimana )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	MACHINE_RESET_CALL(toaplan1);
-	toaplan1_init_coinage_tables(machine);
-	vimana_coins[0] = vimana_coins[1] = 0;
-	vimana_credits = 0;
-	vimana_latch = 0;
+	state->vimana_coins[0] = state->vimana_coins[1] = 0;
+	state->vimana_credits = 0;
+	state->vimana_latch = 0;
 }
+
 void vimana_driver_savestate(running_machine *machine)
 {
-	state_save_register_global(machine, vimana_coins[0]);
-	state_save_register_global(machine, vimana_coins[1]);
-	state_save_register_global(machine, vimana_credits);
-	state_save_register_global(machine, vimana_latch);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state_save_register_global(machine, state->vimana_coins[0]);
+	state_save_register_global(machine, state->vimana_coins[1]);
+	state_save_register_global(machine, state->vimana_credits);
+	state_save_register_global(machine, state->vimana_latch);
 }
diff -Nru src-old/mame/machine/twincobr.c src/mame/machine/twincobr.c
--- src-old/mame/machine/twincobr.c	2010-03-13 05:40:27.000000000 -0800
+++ src/mame/machine/twincobr.c	2010-08-19 01:27:05.000000000 -0700
@@ -67,13 +67,13 @@
 {
 	/* DSP can read data from main CPU RAM via DSP IO port 1 */
 
-	const address_space *mainspace;
+	address_space *mainspace;
 	UINT16 input_data = 0;
 	switch (main_ram_seg) {
 		case 0x30000:
 		case 0x40000:
 		case 0x50000:	mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						input_data = memory_read_word(mainspace, main_ram_seg + dsp_addr_w);
+						input_data = mainspace->read_word(main_ram_seg + dsp_addr_w);
 						break;
 		default:		logerror("DSP PC:%04x Warning !!! IO reading from %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w); break;
 	}
@@ -83,7 +83,7 @@
 
 WRITE16_HANDLER( twincobr_dsp_w )
 {
-	const address_space *mainspace;
+	address_space *mainspace;
 
 	/* Data written to main CPU RAM via DSP IO port 1 */
 	dsp_execute = 0;
@@ -91,7 +91,7 @@
 		case 0x30000:	if ((dsp_addr_w < 3) && (data == 0)) dsp_execute = 1;
 		case 0x40000:
 		case 0x50000:	mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						memory_write_word(mainspace, main_ram_seg + dsp_addr_w, data);
+						mainspace->write_word(main_ram_seg + dsp_addr_w, data);
 						break;
 		default:		logerror("DSP PC:%04x Warning !!! IO writing to %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w); break;
 	}
@@ -117,14 +117,14 @@
 {
 	/* DSP can read data from main CPU RAM via DSP IO port 1 */
 
-	const address_space *mainspace;
+	address_space *mainspace;
 	UINT16 input_data = 0;
 	switch (main_ram_seg) {
 		case 0x7000:
 		case 0x8000:
 		case 0xa000:	mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						input_data =  memory_read_byte(mainspace, main_ram_seg + (dsp_addr_w + 0))
-								   | (memory_read_byte(mainspace, main_ram_seg + (dsp_addr_w + 1)) << 8);
+						input_data =  mainspace->read_byte(main_ram_seg + (dsp_addr_w + 0))
+								   | (mainspace->read_byte(main_ram_seg + (dsp_addr_w + 1)) << 8);
 						break;
 		default:		logerror("DSP PC:%04x Warning !!! IO reading from %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w); break;
 	}
@@ -134,7 +134,7 @@
 
 WRITE16_HANDLER( wardner_dsp_w )
 {
-	const address_space *mainspace;
+	address_space *mainspace;
 
 	/* Data written to main CPU RAM via DSP IO port 1 */
 	dsp_execute = 0;
@@ -142,8 +142,8 @@
 		case 0x7000:	if ((dsp_addr_w < 3) && (data == 0)) dsp_execute = 1;
 		case 0x8000:
 		case 0xa000:	mainspace = cputag_get_address_space(space->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-						memory_write_byte(mainspace, main_ram_seg + (dsp_addr_w + 0), (data & 0xff));
-						memory_write_byte(mainspace, main_ram_seg + (dsp_addr_w + 1), ((data >> 8) & 0xff));
+						mainspace->write_byte(main_ram_seg + (dsp_addr_w + 0), (data & 0xff));
+						mainspace->write_byte(main_ram_seg + (dsp_addr_w + 1), ((data >> 8) & 0xff));
 						break;
 		default:		logerror("DSP PC:%04x Warning !!! IO writing to %08x (port 1)\n",cpu_get_previouspc(space->cpu),main_ram_seg + dsp_addr_w); break;
 	}
@@ -271,7 +271,7 @@
 }
 
 
-static void toaplan0_coin_dsp_w(const address_space *space, int offset, int data)
+static void toaplan0_coin_dsp_w(address_space *space, int offset, int data)
 {
 	if (data > 1)
 		LOG(("%s:Writing %08x to %08x.\n",cpuexec_describe_context(space->machine),data,toaplan_port_type[toaplan_main_cpu] - offset));
diff -Nru src-old/mame/machine/vsnes.c src/mame/machine/vsnes.c
--- src-old/mame/machine/vsnes.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/machine/vsnes.c	2010-08-19 00:26:14.000000000 -0700
@@ -201,7 +201,7 @@
 
 MACHINE_START( vsnes )
 {
-	const address_space *ppu1_space = cpu_get_address_space(machine->device("ppu1"), ADDRESS_SPACE_PROGRAM);
+	address_space *ppu1_space = cpu_get_address_space(machine->device("ppu1"), ADDRESS_SPACE_PROGRAM);
 	int i;
 
 	/* establish nametable ram */
diff -Nru src-old/mame/machine/williams.c src/mame/machine/williams.c
--- src-old/mame/machine/williams.c	2010-07-16 04:59:31.000000000 -0700
+++ src/mame/machine/williams.c	2010-08-19 00:26:14.000000000 -0700
@@ -441,7 +441,7 @@
 
 static STATE_POSTLOAD( williams2_postload )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	williams2_bank_select_w(space, 0, vram_bank);
 }
 
@@ -460,7 +460,7 @@
 
 MACHINE_RESET( williams2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* make sure our banking is reset */
 	williams2_bank_select_w(space, 0, 0);
@@ -725,7 +725,7 @@
 
 static STATE_POSTLOAD( defender_postload )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	defender_bank_select_w(space, 0, vram_bank);
 }
 
@@ -743,7 +743,7 @@
 
 MACHINE_RESET( defender )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	MACHINE_RESET_CALL(williams_common);
 
diff -Nru src-old/mame/mame.mak src/mame/mame.mak
--- src-old/mame/mame.mak	2010-08-11 12:12:32.000000000 -0700
+++ src/mame/mame.mak	2010-08-24 18:11:26.000000000 -0700
@@ -57,6 +57,7 @@
 CPUS += TMS340X0
 CPUS += TMS9900
 CPUS += Z8000
+#CPUS += Z8001
 CPUS += TMS32010
 CPUS += TMS32025
 CPUS += TMS32031
@@ -222,6 +223,7 @@
 SOUNDS += CDP1864
 SOUNDS += ZSG2
 SOUNDS += MOS656X
+SOUNDS += S2636
 
 #-------------------------------------------------
 # this is the list of driver libraries that
@@ -374,6 +376,7 @@
 	$(DRIVERS)/aristmk4.o \
 	$(DRIVERS)/aristmk5.o \
 	$(MACHINE)/archimds.o \
+	$(VIDEO)/archimds.o \
 
 $(MAMEOBJ)/atari.a: \
 	$(DRIVERS)/atarigx2.o $(VIDEO)/atarigx2.o \
@@ -1112,12 +1115,12 @@
 	$(DRIVERS)/deniam.o $(VIDEO)/deniam.o \
 	$(DRIVERS)/dotrikun.o \
 	$(VIDEO)/genesis.o \
-	$(DRIVERS)/genesisb.o \
 	$(DRIVERS)/gpworld.o \
 	$(DRIVERS)/hikaru.o \
 	$(DRIVERS)/hshavoc.o \
 	$(DRIVERS)/kopunch.o $(VIDEO)/kopunch.o \
 	$(DRIVERS)/megadriv.o \
+	$(DRIVERS)/megadrvb.o \
 	$(DRIVERS)/megaplay.o \
 	$(DRIVERS)/megatech.o \
 	$(DRIVERS)/model1.o $(MACHINE)/model1.o $(VIDEO)/model1.o \
@@ -1148,7 +1151,6 @@
 	$(DRIVERS)/system1.o $(VIDEO)/system1.o \
 	$(DRIVERS)/system16.o $(VIDEO)/system16.o \
 	$(DRIVERS)/timetrv.o \
-	$(DRIVERS)/topshoot.o \
 	$(DRIVERS)/turbo.o $(AUDIO)/turbo.o $(VIDEO)/turbo.o \
 	$(DRIVERS)/vicdual.o $(AUDIO)/vicdual.o $(VIDEO)/vicdual.o \
 	$(DRIVERS)/zaxxon.o $(AUDIO)/zaxxon.o $(VIDEO)/zaxxon.o \
@@ -1547,6 +1549,7 @@
 	$(DRIVERS)/hitpoker.o \
 	$(DRIVERS)/homedata.o $(VIDEO)/homedata.o \
 	$(DRIVERS)/hotblock.o \
+	$(DRIVERS)/hotstuff.o \
 	$(DRIVERS)/ilpag.o \
 	$(DRIVERS)/imolagp.o \
 	$(DRIVERS)/intrscti.o \
@@ -1620,6 +1623,7 @@
 	$(DRIVERS)/re900.o \
 	$(DRIVERS)/rgum.o \
 	$(DRIVERS)/roul.o \
+	$(DRIVERS)/savquest.o \
 	$(DRIVERS)/sfbonus.o \
 	$(DRIVERS)/shangkid.o $(VIDEO)/shangkid.o \
 	$(DRIVERS)/skeetsht.o \
diff -Nru src-old/mame/mamedriv.c src/mame/mamedriv.c
--- src-old/mame/mamedriv.c	2010-08-10 19:01:20.000000000 -0700
+++ src/mame/mamedriv.c	2010-08-27 13:18:24.000000000 -0700
@@ -449,6 +449,7 @@
 	DRIVER( jngolady )	/* (c) 1984 */
 	DRIVER( cntrygrl )	/* (c) 1984 Royal Denshi */
 	DRIVER( cntrygrla ) /* (c) 1984 */
+	DRIVER( roylcrdn )	/* (c) 1985 */
 	DRIVER( fruitbun )	/* (c) 1984 */
 	DRIVER( luckygrl )	/* (c) 1984 Wing? */
 	DRIVER( nightgal )	/* (c) 1984 */
@@ -1068,6 +1069,8 @@
 	DRIVER( dkongjo )	/* (c) 1981 Nintendo */
 	DRIVER( dkongjo1 )	/* (c) 1981 Nintendo */
 	DRIVER( dkongf )	/* hack from Jeff's Romhack */
+	DRIVER( dkongx )	/* hack */
+	DRIVER( dkongx11 )	/* hack */
 	DRIVER( dkongjr )	/* (c) 1982 Nintendo of America */
 	DRIVER( dkongjrj )	/* (c) 1982 Nintendo */
 	DRIVER( dkongjnrj )	/* (c) 1982 Nintendo */
@@ -2494,6 +2497,7 @@
 	DRIVER( srdmissn )	/* (c) 1986 Taito Corporation */
 	DRIVER( fx )		/* bootleg */
 	DRIVER( legend )	/* no copyright notice [1986 Sega/Coreland] (Arcade TV Game List - P.104, Left, 14 from top) */
+	DRIVER( legendb )	/* no copyright notice [1986 Sega/Coreland] (Arcade TV Game List - P.104, Left, 14 from top) */
 	DRIVER( airwolf )	/* (c) 1987 Kyugo */
 	DRIVER( airwolfa )	/* (c) 1987 Kyugo */
 	DRIVER( skywolf )	/* bootleg */
@@ -2723,6 +2727,7 @@
 	DRIVER( kod )		/* 11/07/1991 (c) 1991 (World) */
 	DRIVER( kodu )		/* 10/09/1991 (c) 1991 (US)    */
 	DRIVER( kodj )		/* 05/08/1991 (c) 1991 (Japan) */
+	DRIVER( kodja )		/* 05/08/1991 (c) 1991 (Japan) */
 	DRIVER( kodb )		/* bootleg */
 	DRIVER( captcomm )	/* 02/12/1991 (c) 1991 (World) */
 	DRIVER( captcommr1 )	/* 14/10/1991 (c) 1991 (World) */
@@ -2733,8 +2738,10 @@
 	DRIVER( knights )	/* 27/11/1991 (c) 1991 (World) */
 	DRIVER( knightsu )	/* 27/11/1991 (c) 1991 (US)    */
 	DRIVER( knightsj )	/* 27/11/1991 (c) 1991 (Japan) */
+	DRIVER( knightsja )	/* 27/11/1991 (c) 1991 (Japan) */
 	DRIVER( knightsb )	/* bootleg */
-	DRIVER( sf2ce )		/* 13/03/1992 (c) 1992 (World) */
+	DRIVER( sf2ce )		/* 13/05/1992 (c) 1992 (World) */
+	DRIVER( sf2ceea )	/* 13/03/1992 (c) 1992 (World) */
 	DRIVER( sf2ceua )	/* 13/03/1992 (c) 1992 (US)    */
 	DRIVER( sf2ceub )	/* 13/05/1992 (c) 1992 (US)    */
 	DRIVER( sf2ceuc )	/* 03/08/1992 (c) 1992 (US)    */
@@ -3035,6 +3042,7 @@
 	/* CPS2 'Phoenix' bootlegs */
 	DRIVER( ssf2ud )
 	DRIVER( ddtodd )
+	DRIVER( ecofghtrd )
 	DRIVER( avspd )
 	DRIVER( dstlku1d )
 	DRIVER( ringdstd )
@@ -3044,6 +3052,8 @@
 	DRIVER( mshud )
 	DRIVER( 19xxd )
 	DRIVER( sfz2ad )
+	DRIVER( sfz2jd )
+	DRIVER( spf2td )
 	DRIVER( spf2xjd )
 	DRIVER( ddsomud )
 	DRIVER( megamn2d )
@@ -3053,9 +3063,12 @@
 	DRIVER( vsavd )
 	DRIVER( mvscud )
 	DRIVER( sfa3ud )
-	DRIVER( gwingjd )
+	DRIVER( gigawingd )
+	DRIVER( gigawingjd )
 	DRIVER( 1944d )
-	DRIVER( progerjd )
+	DRIVER( progearud )
+	DRIVER( progearjd )
+	DRIVER( progearjbl )
 	DRIVER( hsf2d )
 	DRIVER( ssf2tbd )
 	DRIVER( ssf2xjd )
@@ -3063,8 +3076,14 @@
 	DRIVER( armwar1d )
 	DRIVER( dimahoud )
 	DRIVER( mmatrixd )
+	DRIVER( vhunt2d )
+	DRIVER( vsav2d )
+	DRIVER( csclub1d )
+	DRIVER( cybotsud )
+	DRIVER( mshvsfu1d )
+	DRIVER( sfz3jr2d )
 
-	/* Capcom CPS3 games */
+	 /* Capcom CPS3 games */
 	DRIVER( sfiii )		/* 04/02/1997 (c) 1997 Capcom */
 	DRIVER( sfiiij )	/* 04/02/1997 (c) 1997 Capcom */
 	DRIVER( sfiii2 )	/* 30/09/1997 (c) 1997 Capcom */
@@ -4651,7 +4670,7 @@
 	DRIVER( wsbbgd )	/* 2001.06 Super Major League */
 	DRIVER( spkrbtl )	/* 2001.07 Spikers Battle */
 	DRIVER( gunsur2 )	/* 2001.07 Gun Survivor 2: Bio Hazard Code Veronica */
-						/* 2001.07 Dokidoki Idol Star Seeker */
+	DRIVER( starseek )	/* 2001.07 Dokidoki Idol Star Seeker */
 	DRIVER( cvs2gd )	/* 2001.08 Capcom vs. SNK 2 */
 	DRIVER( gundmxgd )	/* 2001.09 Kidou Senshi Gundam Renpou vs. Zeon DX */
 						/* 2001.09 Alien Front */
@@ -5412,6 +5431,7 @@
 	DRIVER( roadf2 )	/* GX461 (c) 1984 */
 	DRIVER( yiear )		/* GX407 (c) 1985 */
 	DRIVER( yiear2 )	/* GX407 (c) 1985 */
+	DRIVER( yieartf )	/* GX361 (c) 1985 */
 	DRIVER( kicker )	/* GX477 (c) 1985 */
 	DRIVER( shaolins )	/* GX477 (c) 1985 */
 	DRIVER( shaolinb )	/* bootleg */
@@ -6362,9 +6382,10 @@
 	DRIVER( vanguardc )	/* (c) 1981 SNK + Centuri */
 	DRIVER( vanguardj )	/* (c) 1981 SNK */
 	DRIVER( fantasy )	/* (c) 1981 SNK */
-	DRIVER( fantasyu )	/* (c) 1981 Rock-ola */
+	DRIVER( fantasyu )	/* (c) 1981 Rock-Ola */
 	DRIVER( fantasyj )	/* (c) 1981 SNK */
 	DRIVER( pballoon )	/* (c) 1982 SNK */
+	DRIVER( pballoonr )	/* (c) 1982 SNK (Rock-Ola license) */
 	DRIVER( nibbler )	/* (c) 1982 Rock-ola */
 	DRIVER( nibblera )	/* (c) 1982 Rock-ola */
 	DRIVER( nibblerb )	/* (c) 1982 Rock-ola */
@@ -6478,7 +6499,7 @@
 	DRIVER( kotm )		/* 0016 (c) 1991 SNK */
 	DRIVER( kotmh )		/* 0016 (c) 1991 SNK */
 	DRIVER( sengoku )	/* 0017 (c) 1991 SNK */
-	DRIVER( sengokh )	/* 0017 (c) 1991 SNK */
+	DRIVER( sengokuh )	/* 0017 (c) 1991 SNK */
 	DRIVER( burningf )	/* 0018 (c) 1991 SNK */
 	DRIVER( burningfh )	/* 0018 (c) 1991 SNK */
 	DRIVER( lbowling )	/* 0019 (c) 1990 SNK */
@@ -6531,7 +6552,7 @@
 	DRIVER( aof2a )		/* 0056 (c) 1994 SNK */
 	DRIVER( wh2 )		/* 0057 (c) 1993 ADK */
 	DRIVER( fatfursp )	/* 0058 (c) 1993 SNK */
-	DRIVER( fatfursa )	/* 0058 (c) 1993 SNK */
+	DRIVER( fatfurspa )	/* 0058 (c) 1993 SNK */
 	DRIVER( savagere )	/* 0059 (c) 1995 SNK */
 	DRIVER( fightfev )	/* 0060 (c) 1994 Viccom */
 	DRIVER( fightfeva )	/* 0060 (c) 1994 Viccom */
@@ -6540,7 +6561,6 @@
 	DRIVER( samsho2 )	/* 0063 (c) 1994 SNK */
 	DRIVER( samsho2k )	/* 0063 (c) 1994 SNK (Korean hack) */
 	DRIVER( wh2j )		/* 0064 (c) 1994 ADK / SNK */
-	DRIVER( wh2jh )		/* 0064 (c) 1994 ADK / SNK */
 	DRIVER( wjammers )	/* 0065 (c) 1994 Data East Corporation */
 	DRIVER( karnovr )	/* 0066 (c) 1994 Data East Corporation */
 	DRIVER( gururin )	/* 0067 (c) 1994 Face */
@@ -6633,7 +6653,7 @@
 	DRIVER( irrmaze )	/* 0236 (c) 1997 SNK / Saurus */
 	DRIVER( popbounc )	/* 0237 (c) 1997 Video System Co. */
 	DRIVER( shocktro )	/* 0238 (c) 1997 Saurus */
-	DRIVER( shocktra )	/* 0238 (c) 1997 Saurus */
+	DRIVER( shocktroa )	/* 0238 (c) 1997 Saurus */
 	DRIVER( blazstar )	/* 0239 (c) 1998 Yumekobo */
 	DRIVER( rbff2 )		/* 0240 (c) 1998 SNK */
 	DRIVER( rbff2h )	/* 0240 (c) 1998 SNK */
@@ -6653,7 +6673,7 @@
 	DRIVER( ctomaday )	/* 0249 (c) 1999 Visco */
 	DRIVER( mslugx )	/* 0250 (c) 1999 SNK */
 	DRIVER( kof99 )		/* 0251 (c) 1999 SNK */
-	DRIVER( kof99a )	/* 0251 (c) 1999 SNK */
+	DRIVER( kof99h )	/* 0251 (c) 1999 SNK */
 	DRIVER( kof99e )	/* 0251 (c) 1999 SNK */
 	DRIVER( kof99k )	/* 0152 (c) 1999 SNK */
 	DRIVER( kof99p )	/* 0251 (c) 1999 SNK */
@@ -6786,7 +6806,7 @@
 	DRIVER( skyadvntu )	/* Alpha-68K96V  'SA' (c) 1989 SNK of America licensed from Alpha */
 	DRIVER( skyadvntj )	/* Alpha-68K96V  'SA' (c) 1989 Alpha Denshi Co. */
 	DRIVER( gangwars )	/* Alpha-68K96V       (c) 1989 Alpha Denshi Co. */
-	DRIVER( gangwarsb )	/* Alpha-68K96V bootleg */
+	DRIVER( gangwarsu )	/* Alpha-68K96V       (c) 1989 Alpha Denshi Co. */
 	DRIVER( sbasebal )	/* Alpha-68K96V       (c) 1989 SNK of America licensed from Alpha */
 	DRIVER( tnextspc )	/* A8003 'NS' (c) 1989 */
 	DRIVER( tnextspcj )	/* A8003 'NS' (c) 1989 */
@@ -7352,7 +7372,8 @@
 	DRIVER( rdftu )		/* (c) 1996 Seibu Kaihatsu (Fabtek license) */
 	DRIVER( rdftau )	/* (c) 1996 Seibu Kaihatsu */
 	DRIVER( rdftj )		/* (c) 1996 Seibu Kaihatsu */
-	DRIVER( rdftdi )	/* (c) 1996 Seibu Kaihatsu (Dream Island license) */
+	DRIVER( rdftadi )	/* (c) 1996 Seibu Kaihatsu (Dream Island license) */
+	DRIVER( rdftam )	/* (c) 1996 Seibu Kaihatsu (Metrotainment license) */
 	DRIVER( rdftit )	/* (c) 1996 Seibu Kaihatsu */
 	DRIVER( rdfta )		/* (c) 1996 Seibu Kaihatsu */
 
@@ -7370,7 +7391,7 @@
 	DRIVER( rfjetu )	/* (c) 1998 Seibu Kaihatsu (Fabtek license) */
 	DRIVER( rfjeta )	/* (c) 1998 Seibu Kaihatsu (Dream Island license) */
 	DRIVER( rfjetj )	/* (c) 1998 Seibu Kaihatsu */
-	DRIVER( rfjetus )	/* (c) 1998 Seibu Kaihatsu (Fabtek license) */
+	DRIVER( rfjets )	/* (c) 1998 Seibu Kaihatsu */
 	DRIVER( rfjet2kc )	/* (c) 2000 Seibu Kaihatsu */
 
 	DRIVER( ejsakura )	/* (c) 1999 Seibu Kaihatsu */
@@ -8972,7 +8993,8 @@
 	DRIVER( sextriv2 )	/* (c) 1985 Kinky Kit and Game Co. */
 	DRIVER( geimulti )	/* (c) 1992 Grayhound Electronics */
 	DRIVER( sprtauth )	/* (c) 1982 Classic Games */
-	DRIVER( suprpokr )
+	DRIVER( suprpokr )  /* (c) 1986 Grayhound Electronics */
+	DRIVER( suprpkr1 )  /* (c) 1986 Grayhound Electronics */
 	DRIVER( dribling )	/* (c) 1983 Model Racing */
 	DRIVER( driblingo )	/* (c) 1983 Olympia */
 	DRIVER( ace )		/* [1976 Allied Leisure] */
@@ -9485,9 +9507,11 @@
 	DRIVER( comg230 )	/* (c) 1984 Cal Omega Inc. */
 	DRIVER( comg236 )	/* (c) 1984 Cal Omega Inc. */
 	DRIVER( comg239 )	/* (c) 1985 Cal Omega / Casino Electronics Inc. */
+	DRIVER( comg240 )	/* (c) 1985 Cal Omega / Casino Electronics Inc. */
 	DRIVER( comg246 )	/* (c) 1985 Cal Omega Inc. */
 	DRIVER( comg272a )	/* (c) 1985 Cal Omega Inc. */
 	DRIVER( comg272b )	/* (c) 1985 Cal Omega Inc. */
+	DRIVER( comg5108 )	/* (c) 1985 Cal Omega Inc. */
 	DRIVER( comg903d )	/* (c) 198? Cal Omega Inc. */
 	DRIVER( comg905d )	/* (c) 198? Cal Omega Inc. */
 	DRIVER( elgrande )	/* (c) 1982 Tuni Electro Service / E.T. Marketing */
@@ -9712,6 +9736,7 @@
 	DRIVER( caswin )	/* (c) 1985 */
 
 	/* Aristocrat Mk4 hardware */
+	DRIVER( 3bagflvt )	/* (c) 1994 */
 	DRIVER( 3bagflnz )	/* (c) 1994 */
 	DRIVER( blkrhino )	/* (c) 1996 */
 	DRIVER( coralr2 )	/* (c) 2002 */
@@ -9729,6 +9754,8 @@
 	DRIVER( ffortune )	/* (c) 1998 */
 
 	/* Aristocrat Mk5 hardware */
+	DRIVER( aristmk5 )	/* (c) 1995 */
+
 	DRIVER( swthrt2v )	/* (c) 1995 */
 	DRIVER( enchfrst )	/* (c) 1995 */
 	DRIVER( dolphntr )	/* (c) 1996 */
@@ -10302,4 +10329,13 @@
 	/* Blitz System Inc. */
 	DRIVER( megadpkr )	/* (c) 1990 Blitz System Inc */
 
+	/* Video Fun Games Ltd. */
+	DRIVER( genie )		/* (c) 198? Video Fun Games Ltd. */
+
+	/* Olympic Video Gaming */
+	DRIVER( hotstuff )
+
+	/* Interactive Light */
+	DRIVER( savquest )
+
 #endif	/* DRIVER_RECURSIVE */
diff -Nru src-old/mame/video/archimds.c src/mame/video/archimds.c
--- src-old/mame/video/archimds.c	1969-12-31 16:00:00.000000000 -0800
+++ src/mame/video/archimds.c	2010-08-30 08:20:58.000000000 -0700
@@ -0,0 +1,129 @@
+/***************************************************************************
+
+    Acorn Archimedes VIDC (VIDeo Controller) emulation
+
+***************************************************************************/
+
+#include "emu.h"
+#include "includes/archimds.h"
+
+VIDEO_START( archimds_vidc )
+{
+}
+
+VIDEO_UPDATE( archimds_vidc )
+{
+	int xstart,ystart,xend,yend;
+	int res_x,res_y;
+	int xsize,ysize;
+	int calc_dxs = 0,calc_dxe = 0;
+	const UINT8 x_step[4] = { 5, 7, 11, 19 };
+
+	/* border color */
+	bitmap_fill(bitmap, cliprect, screen->machine->pens[0x10]);
+
+	/* define X display area thru BPP mode register */
+	calc_dxs = (vidc_regs[VIDC_HDSR]*2)+x_step[vidc_bpp_mode & 3];
+	calc_dxe = (vidc_regs[VIDC_HDER]*2)+x_step[vidc_bpp_mode & 3];
+
+	/* now calculate display clip rectangle start/end areas */
+	xstart = (calc_dxs)-vidc_regs[VIDC_HBSR];
+	ystart = (vidc_regs[VIDC_VDSR])-vidc_regs[VIDC_VBSR];
+	xend = (calc_dxe)+xstart;
+	yend = vidc_regs[VIDC_VDER]+ystart;
+
+	/* disable the screen if display params are invalid */
+	if(xstart > xend || ystart > yend)
+		return 0;
+
+	xsize = calc_dxe-calc_dxs;
+	ysize = vidc_regs[VIDC_VDER]-vidc_regs[VIDC_VDSR];
+
+	{
+		int count;
+		int x,y,xi;
+		UINT8 pen;
+		static UINT8 *vram = memory_region(screen->machine,"vram");
+
+		count = (0);
+
+		switch(vidc_bpp_mode)
+		{
+			case 0: //1 bpp
+			{
+				for(y=0;y<ysize;y++)
+				{
+					for(x=0;x<xsize;x+=8)
+					{
+						pen = vram[count];
+
+						for(xi=0;xi<8;xi++)
+						{
+							res_x = x+xi+xstart;
+							res_y = (y+ystart)*(vidc_interlace+1);
+
+							if(vidc_interlace)
+							{
+								if ((res_x) >= 0 &&
+									(res_y) >= 0 &&
+									(res_x) <= screen->visible_area().max_x && (res_y) <= screen->visible_area().max_y && (res_x) <= xend && (res_y) <= yend)
+									*BITMAP_ADDR32(bitmap, res_y, res_x) = screen->machine->pens[(pen>>(xi))&0x1];
+								if ((res_x) >= 0 &&
+									(res_y) >= 0 &&
+									(res_x) <= screen->visible_area().max_x && (res_y+1) <= screen->visible_area().max_y && (res_x) <= xend && (res_y+1) <= yend)
+									*BITMAP_ADDR32(bitmap, res_y+1, res_x) = screen->machine->pens[(pen>>(xi))&0x1];
+							}
+							else
+							{
+								if ((res_x) >= 0 &&
+									(res_y) >= 0 &&
+									(res_x) <= screen->visible_area().max_x && (res_y) <= screen->visible_area().max_y && (res_x) <= xend && (res_y) <= yend)
+									*BITMAP_ADDR32(bitmap, res_y, res_x) = screen->machine->pens[(pen>>(xi))&0x1];
+							}
+						}
+
+						count++;
+					}
+				}
+			}
+			break;
+			case 3: //8 bpp
+			{
+				for(y=0;y<ysize;y++)
+				{
+					for(x=0;x<xsize;x++)
+					{
+						pen = vram[count];
+
+						res_x = x+xstart;
+						res_y = (y+ystart)*(vidc_interlace+1);
+
+						if(vidc_interlace)
+						{
+							if ((res_x) >= 0 &&
+								(res_y) >= 0 &&
+								(res_x) <= screen->visible_area().max_x && (res_y) <= screen->visible_area().max_y && (res_x) <= xend && (res_y) <= yend)
+								*BITMAP_ADDR32(bitmap, res_y, res_x) = screen->machine->pens[(pen&0xff)+0x100];
+							if ((res_x) >= 0 &&
+								(res_y) >= 0 &&
+								(res_x) <= screen->visible_area().max_x && (res_y+1) <= screen->visible_area().max_y && (res_x) <= xend && (res_y+1) <= yend)
+								*BITMAP_ADDR32(bitmap, res_y+1, res_x) = screen->machine->pens[(pen&0xff)+0x100];
+						}
+						else
+						{
+							if ((res_x) >= 0 &&
+								(res_y) >= 0 &&
+								(res_x) <= screen->visible_area().max_x && (res_y) <= screen->visible_area().max_y && (res_x) <= xend && (res_y) <= yend)
+								*BITMAP_ADDR32(bitmap, res_y, res_x) = screen->machine->pens[(pen&0xff)+0x100];
+						}
+
+						count++;
+					}
+				}
+			}
+			break;
+		}
+	}
+
+	return 0;
+}
diff -Nru src-old/mame/video/armedf.c src/mame/video/armedf.c
--- src-old/mame/video/armedf.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/armedf.c	2010-08-19 00:26:14.000000000 -0700
@@ -368,7 +368,7 @@
 
 VIDEO_EOF( armedf )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 }
diff -Nru src-old/mame/video/artmagic.c src/mame/video/artmagic.c
--- src-old/mame/video/artmagic.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/artmagic.c	2010-08-21 15:25:58.000000000 -0700
@@ -61,7 +61,6 @@
 	blitter_base = (UINT16 *)memory_region(machine, "gfx1");
 	blitter_mask = memory_region_length(machine, "gfx1")/2 - 1;
 
-	tlc34076_state_save(machine);
 	state_save_register_global_array(machine, artmagic_xor);
 	state_save_register_global(machine, artmagic_is_stoneball);
 	state_save_register_global_array(machine, blitter_data);
@@ -76,7 +75,7 @@
  *
  *************************************/
 
-void artmagic_to_shiftreg(const address_space *space, offs_t address, UINT16 *data)
+void artmagic_to_shiftreg(address_space *space, offs_t address, UINT16 *data)
 {
 	UINT16 *vram = address_to_vram(&address);
 	if (vram)
@@ -84,7 +83,7 @@
 }
 
 
-void artmagic_from_shiftreg(const address_space *space, offs_t address, UINT16 *data)
+void artmagic_from_shiftreg(address_space *space, offs_t address, UINT16 *data)
 {
 	UINT16 *vram = address_to_vram(&address);
 	if (vram)
@@ -201,7 +200,7 @@
 }
 #endif
 
-	profiler_mark_start(PROFILER_VIDEO);
+	g_profiler.start(PROFILER_VIDEO);
 
 	last = 0;
 	sy = y;
@@ -306,7 +305,7 @@
 		offset += w/4;
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 
 #if (!INSTANT_BLIT)
 	blitter_busy_until = attotime_add(timer_get_time(machine), ATTOTIME_IN_NSEC(w*h*20));
@@ -356,7 +355,7 @@
 	offs_t offset = (params->rowaddr << 12) & 0x7ff000;
 	UINT16 *vram = address_to_vram(&offset);
 	UINT32 *dest = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = params->coladdr << 1;
 	int x;
 
diff -Nru src-old/mame/video/astrocde.c src/mame/video/astrocde.c
--- src-old/mame/video/astrocde.c	2010-08-11 12:38:51.000000000 -0700
+++ src/mame/video/astrocde.c	2010-08-19 01:27:05.000000000 -0700
@@ -727,7 +727,7 @@
 	/* OR/XOR */
 	if (funcgen_control & 0x30)
 	{
-		UINT8 olddata = memory_read_byte(space, 0x4000 + offset);
+		UINT8 olddata = space->read_byte(0x4000 + offset);
 
 		/* compute any intercepts */
 		funcgen_intercept &= 0x0f;
@@ -748,7 +748,7 @@
 	}
 
 	/* write the result */
-	memory_write_byte(space, 0x4000 + offset, data);
+	space->write_byte(0x4000 + offset, data);
 }
 
 
@@ -788,7 +788,7 @@
 }
 
 
-static void execute_blit(const address_space *space)
+static void execute_blit(address_space *space)
 {
 	/*
         pattern_source = counter set U7/U16/U25/U34
@@ -842,7 +842,7 @@
 			if (curwidth == 0 && (pattern_mode & 0x08) != 0)
 				busdata = 0;
 			else
-				busdata = memory_read_byte(space, busaddr);
+				busdata = space->read_byte(busaddr);
 
 			/* increment the appropriate address */
 			if ((pattern_mode & 0x01) == 0)
@@ -854,7 +854,7 @@
 
 			/* address is selected between source/dest based on mode.d0 */
 			busaddr = ((pattern_mode & 0x01) != 0) ? pattern_source : pattern_dest;
-			memory_write_byte(space, busaddr, busdata);
+			space->write_byte(busaddr, busdata);
 
 			/* increment the appropriate address */
 			if ((pattern_mode & 0x01) == 0)
diff -Nru src-old/mame/video/atari.c src/mame/video/atari.c
--- src-old/mame/video/atari.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/atari.c	2010-08-19 00:26:14.000000000 -0700
@@ -1174,7 +1174,7 @@
  *****************************************************************************/
 static TIMER_CALLBACK( antic_scanline_render )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	VIDEO *video = antic.video[antic.scanline];
 	LOG(("           @cycle #%3d render mode $%X lines to go #%d\n", cycle(machine), (antic.cmd & 0x0f), antic.modelines));
@@ -1244,7 +1244,7 @@
      **************************************************************/
     if( new_cmd & ANTIC_LMS )
     {
-    	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+    	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 		int addr = RDANTIC(space);
         antic.doffs = (antic.doffs + 1) & DOFFS;
         addr += 256 * RDANTIC(space);
@@ -1269,7 +1269,7 @@
  *****************************************************************************/
 static void antic_scanline_dma(running_machine *machine, int param)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	LOG(("           @cycle #%3d DMA fetch\n", cycle(machine)));
 	if (antic.scanline == VBL_END)
 		antic.r.nmist &= ~VBL_NMI;
diff -Nru src-old/mame/video/atarisy1.c src/mame/video/atarisy1.c
--- src-old/mame/video/atarisy1.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/atarisy1.c	2010-08-19 00:26:14.000000000 -0700
@@ -386,7 +386,7 @@
 
 TIMER_DEVICE_CALLBACK( atarisy1_int3off_callback )
 {
-	const address_space *space = cputag_get_address_space(timer.machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(timer.machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* clear the state */
 	atarigen_scanline_int_ack_w(space, 0, 0, 0xffff);
diff -Nru src-old/mame/video/avgdvg.c src/mame/video/avgdvg.c
--- src-old/mame/video/avgdvg.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/avgdvg.c	2010-08-13 01:54:21.000000000 -0700
@@ -22,11 +22,10 @@
  *
  *************************************/
 
-UINT8 *tempest_colorram;
-UINT8 *mhavoc_colorram;
-UINT16 *quantum_colorram;
+UINT8 *avgdvg_vectorram;
+size_t avgdvg_vectorram_size;
 
-UINT16 *quantum_vectorram;
+UINT8 *avgdvg_colorram;
 
 
 
@@ -229,7 +228,7 @@
 	/*
      * DVG uses low bit of state for address
      */
-	vg->data = vectorram[(vg->pc << 1) | (vg->state_latch & 1)];
+	vg->data = avgdvg_vectorram[(vg->pc << 1) | (vg->state_latch & 1)];
 }
 
 static UINT8 dvg_state_addr(vgdata *vg)
@@ -464,17 +463,17 @@
 
 static void avg_data(vgdata *vg)
 {
-	vg->data = vectorram[vg->pc ^ 1];
+	vg->data = avgdvg_vectorram[vg->pc ^ 1];
 }
 
 static void starwars_data(vgdata *vg)
 {
-	vg->data = vectorram[vg->pc];
+	vg->data = avgdvg_vectorram[vg->pc];
 }
 
 static void quantum_data(vgdata *vg)
 {
-	vg->data = quantum_vectorram[vg->pc >> 1];
+	vg->data = ((UINT16 *)avgdvg_vectorram)[vg->pc >> 1];
 }
 
 static void mhavoc_data(vgdata *vg)
@@ -488,7 +487,7 @@
 	}
 	else
 	{
-		vg->data = vectorram[vg->pc ^ 1];
+		vg->data = avgdvg_vectorram[vg->pc ^ 1];
 	}
 }
 
@@ -962,7 +961,7 @@
 
 	if ((vg->op & 5) == 0)
 	{
-		data = tempest_colorram[vg->color];
+		data = avgdvg_colorram[vg->color];
 		bit3 = (~data >> 3) & 1;
 		bit2 = (~data >> 2) & 1;
 		bit1 = (~data >> 1) & 1;
@@ -1015,7 +1014,7 @@
 			{
 				vg->xpos += dx/2;
 				vg->ypos -= dy/2;
-				data = mhavoc_colorram[0xf +
+				data = avgdvg_colorram[0xf +
 									   (((vg->spkl_shift & 1) << 3)
 										| (vg->spkl_shift & 4)
 										| ((vg->spkl_shift & 0x10) >> 3)
@@ -1043,7 +1042,7 @@
 		{
 			vg->xpos += (dx * cycles) >> 4;
 			vg->ypos -= (dy * cycles) >> 4;
-			data = mhavoc_colorram[vg->color];
+			data = avgdvg_colorram[vg->color];
 
 			bit3 = (~data >> 3) & 1;
 			bit2 = (~data >> 2) & 1;
@@ -1094,7 +1093,7 @@
 
 	if ((vg->op & 5) == 0)
 	{
-		data = quantum_colorram[vg->color];
+		data = ((UINT16 *)avgdvg_colorram)[vg->color];
 		bit3 = (~data >> 3) & 1;
 		bit2 = (~data >> 2) & 1;
 		bit1 = (~data >> 1) & 1;
@@ -1485,7 +1484,7 @@
 
 	state_save_register_item(machine, "AVG", NULL, 0, flip_x);
 	state_save_register_item(machine, "AVG", NULL, 0, flip_y);
-
+	state_save_register_item_pointer(machine, "AVG", NULL, 0, avgdvg_vectorram, avgdvg_vectorram_size);
 }
 
 static VIDEO_START( avg_common )
@@ -1536,8 +1535,6 @@
 
 	register_state (machine);
 
-	state_save_register_item_pointer(machine, "AVG", NULL, 0, vectorram, vectorram_size);
-
 	VIDEO_START_CALL(vector);
 }
 
@@ -1545,8 +1542,6 @@
 {
 	vgc = &avg_default;
 	VIDEO_START_CALL(avg_common);
-
-	state_save_register_item_pointer(machine, "AVG", NULL, 0, vectorram, vectorram_size);
 }
 
 VIDEO_START( avg_starwars )
@@ -1559,24 +1554,18 @@
 {
 	vgc = &avg_tempest;
 	VIDEO_START_CALL(avg_common);
-
-	state_save_register_item_pointer(machine, "AVG", NULL, 0, vectorram, vectorram_size);
 }
 
 VIDEO_START( avg_mhavoc )
 {
 	vgc = &avg_mhavoc;
 	VIDEO_START_CALL(avg_common);
-
-	state_save_register_item_pointer(machine, "AVG", NULL, 0, vectorram, vectorram_size);
 }
 
 VIDEO_START( avg_bzone )
 {
 	vgc = &avg_bzone;
 	VIDEO_START_CALL(avg_common);
-
-	state_save_register_item_pointer(machine, "AVG", NULL, 0, vectorram, vectorram_size);
 }
 
 VIDEO_START( avg_quantum )
diff -Nru src-old/mame/video/avgdvg.h src/mame/video/avgdvg.h
--- src-old/mame/video/avgdvg.h	2009-02-10 15:19:15.000000000 -0800
+++ src/mame/video/avgdvg.h	2010-08-13 01:54:21.000000000 -0700
@@ -1,10 +1,9 @@
 #ifndef __AVGDVG__
 #define __AVGDVG__
 
-extern UINT8 *tempest_colorram;
-extern UINT8 *mhavoc_colorram;
-extern UINT16 *quantum_colorram;
-extern UINT16 *quantum_vectorram;
+extern UINT8 *avgdvg_vectorram;
+extern size_t avgdvg_vectorram_size;
+extern UINT8 *avgdvg_colorram;
 
 CUSTOM_INPUT( avgdvg_done_r );
 WRITE8_HANDLER( avgdvg_go_w );
diff -Nru src-old/mame/video/bbusters.c src/mame/video/bbusters.c
--- src-old/mame/video/bbusters.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/bbusters.c	2010-08-26 20:55:49.000000000 -0700
@@ -22,71 +22,83 @@
 ***************************************************************************/
 
 #include "emu.h"
+#include "includes/bbusters.h"
 
-static tilemap_t *fix_tilemap,*pf1_tilemap,*pf2_tilemap;
-static const UINT8 *scale_table_ptr;
-static UINT8 scale_line_count;
-
-UINT16 *bbusters_pf1_data,*bbusters_pf2_data,*bbusters_pf1_scroll_data,*bbusters_pf2_scroll_data;
 
 /******************************************************************************/
 
 static TILE_GET_INFO( get_bbusters_tile_info )
 {
-	UINT16 tile=machine->generic.videoram.u16[tile_index];
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+	UINT16 tile = state->videoram[tile_index];
+
 	SET_TILE_INFO(0,tile&0xfff,tile>>12,0);
 }
 
 static TILE_GET_INFO( get_pf1_tile_info )
 {
-	UINT16 tile=bbusters_pf1_data[tile_index];
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+	UINT16 tile = state->pf1_data[tile_index];
+
 	SET_TILE_INFO(3,tile&0xfff,tile>>12,0);
 }
 
 static TILE_GET_INFO( get_pf2_tile_info )
 {
-	UINT16 tile=bbusters_pf2_data[tile_index];
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+	UINT16 tile = state->pf2_data[tile_index];
+
 	SET_TILE_INFO(4,tile&0xfff,tile>>12,0);
 }
 
 WRITE16_HANDLER( bbusters_video_w )
 {
-	COMBINE_DATA(&space->machine->generic.videoram.u16[offset]);
-	tilemap_mark_tile_dirty(fix_tilemap,offset);
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
+
+	COMBINE_DATA(&state->videoram[offset]);
+	tilemap_mark_tile_dirty(state->fix_tilemap, offset);
 }
 
 WRITE16_HANDLER( bbusters_pf1_w )
 {
-	COMBINE_DATA(&bbusters_pf1_data[offset]);
-	tilemap_mark_tile_dirty(pf1_tilemap,offset);
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
+
+	COMBINE_DATA(&state->pf1_data[offset]);
+	tilemap_mark_tile_dirty(state->pf1_tilemap, offset);
 }
 
 WRITE16_HANDLER( bbusters_pf2_w )
 {
-	COMBINE_DATA(&bbusters_pf2_data[offset]);
-	tilemap_mark_tile_dirty(pf2_tilemap,offset);
+	bbusters_state *state = space->machine->driver_data<bbusters_state>();
+
+	COMBINE_DATA(&state->pf2_data[offset]);
+	tilemap_mark_tile_dirty(state->pf2_tilemap, offset);
 }
 
 /******************************************************************************/
 
 VIDEO_START( bbuster )
 {
-	fix_tilemap = tilemap_create(machine, get_bbusters_tile_info,tilemap_scan_rows,8,8,32,32);
-	pf1_tilemap = tilemap_create(machine, get_pf1_tile_info,tilemap_scan_cols,16,16,128,32);
-	pf2_tilemap = tilemap_create(machine, get_pf2_tile_info,tilemap_scan_cols,16,16,128,32);
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+
+	state->fix_tilemap = tilemap_create(machine, get_bbusters_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	state->pf1_tilemap = tilemap_create(machine, get_pf1_tile_info, tilemap_scan_cols, 16, 16, 128, 32);
+	state->pf2_tilemap = tilemap_create(machine, get_pf2_tile_info, tilemap_scan_cols, 16, 16, 128, 32);
 
-	tilemap_set_transparent_pen(pf1_tilemap, 15);
-	tilemap_set_transparent_pen(fix_tilemap, 15);
+	tilemap_set_transparent_pen(state->pf1_tilemap, 15);
+	tilemap_set_transparent_pen(state->fix_tilemap, 15);
 }
 
 VIDEO_START( mechatt )
 {
-	fix_tilemap = tilemap_create(machine, get_bbusters_tile_info,tilemap_scan_rows,8,8,32,32);
-	pf1_tilemap = tilemap_create(machine, get_pf1_tile_info,tilemap_scan_cols,16,16,256,32);
-	pf2_tilemap = tilemap_create(machine, get_pf2_tile_info,tilemap_scan_cols,16,16,256,32);
+	bbusters_state *state = machine->driver_data<bbusters_state>();
+
+	state->fix_tilemap = tilemap_create(machine, get_bbusters_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	state->pf1_tilemap = tilemap_create(machine, get_pf1_tile_info, tilemap_scan_cols, 16, 16, 256, 32);
+	state->pf2_tilemap = tilemap_create(machine, get_pf2_tile_info, tilemap_scan_cols, 16, 16, 256, 32);
 
-	tilemap_set_transparent_pen(pf1_tilemap, 15);
-	tilemap_set_transparent_pen(fix_tilemap, 15);
+	tilemap_set_transparent_pen(state->pf1_tilemap, 15);
+	tilemap_set_transparent_pen(state->fix_tilemap, 15);
 }
 
 /******************************************************************************/
@@ -146,19 +158,20 @@
 
 static void bbusters_draw_block(running_machine *machine, bitmap_t *dest,int x,int y,int size,int flipx,int flipy,UINT32 sprite,int color,int bank,int block)
 {
+	bbusters_state *state = machine->driver_data<bbusters_state>();
 	gfx_element *gfx = machine->gfx[bank];
 	pen_t pen_base = gfx->color_base + gfx->color_granularity * (color % gfx->total_colors);
-	UINT32 xinc=(scale_line_count * 0x10000 ) / size;
+	UINT32 xinc=(state->scale_line_count * 0x10000 ) / size;
 	UINT8 pixel;
 	int x_index;
 	int dy=y;
-	int sx,ex=scale_line_count;
+	int sx, ex = state->scale_line_count;
 
-	while (scale_line_count) {
+	while (state->scale_line_count) {
 
 		if (dy>=16 && dy<240) {
 			UINT16 *destline = BITMAP_ADDR16(dest, dy, 0);
-			UINT8 srcline=*scale_table_ptr;
+			UINT8 srcline=*state->scale_table_ptr;
 			const UINT8 *srcptr=0;
 
 			if (!flipy)
@@ -185,13 +198,14 @@
 		}
 
 		dy++;
-		scale_table_ptr--;
-		scale_line_count--;
+		state->scale_table_ptr--;
+		state->scale_line_count--;
 	}
 }
 
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const UINT16 *source, int bank, int colval, int colmask)
 {
+	bbusters_state *state = machine->driver_data<bbusters_state>();
 	const UINT8 *scale_table=memory_region(machine, "user1");
 	int offs;
 
@@ -237,26 +251,26 @@
 		switch ((source[offs+0]>>8)&0x3) {
 			case 0:
 				scale=source[offs+0]&0x7;
-				scale_table_ptr=scale_table+0x387f+(0x80*scale);
-				scale_line_count=0x10-scale;
+				state->scale_table_ptr = scale_table+0x387f+(0x80*scale);
+				state->scale_line_count = 0x10-scale;
 				bbusters_draw_block(machine,bitmap,x,y,16,fx,fy,sprite,colour,bank,block);
 				break;
 			case 1: /* 2 x 2 */
 				scale=source[offs+0]&0xf;
-				scale_table_ptr=scale_table+0x707f+(0x80*scale);
-				scale_line_count=0x20-scale;
+				state->scale_table_ptr = scale_table+0x707f+(0x80*scale);
+				state->scale_line_count = 0x20-scale;
 				bbusters_draw_block(machine,bitmap,x,y,32,fx,fy,sprite,colour,bank,block);
 				break;
 			case 2: /* 64 by 64 block (2 x 2) x 2 */
 				scale=source[offs+0]&0x1f;
-				scale_table_ptr=scale_table+0xa07f+(0x80*scale);
-				scale_line_count=0x40-scale;
+				state->scale_table_ptr = scale_table+0xa07f+(0x80*scale);
+				state->scale_line_count = 0x40-scale;
 				bbusters_draw_block(machine,bitmap,x,y,64,fx,fy,sprite,colour,bank,block);
 				break;
 			case 3: /* 2 x 2 x 2 x 2 */
 				scale=source[offs+0]&0x3f;
-				scale_table_ptr=scale_table+0xc07f+(0x80*scale);
-				scale_line_count=0x80-scale;
+				state->scale_table_ptr = scale_table+0xc07f+(0x80*scale);
+				state->scale_line_count = 0x80-scale;
 				bbusters_draw_block(machine,bitmap,x,y,128,fx,fy,sprite,colour,bank,block);
 				break;
 		}
@@ -267,30 +281,34 @@
 
 VIDEO_UPDATE( bbuster )
 {
-	tilemap_set_scrollx( pf1_tilemap,0, bbusters_pf1_scroll_data[0] );
-	tilemap_set_scrolly( pf1_tilemap,0, bbusters_pf1_scroll_data[1] );
-	tilemap_set_scrollx( pf2_tilemap,0, bbusters_pf2_scroll_data[0] );
-	tilemap_set_scrolly( pf2_tilemap,0, bbusters_pf2_scroll_data[1] );
-
-	tilemap_draw(bitmap,cliprect,pf2_tilemap,0,0);
-//  draw_sprites(screen->machine,bitmap,screen->machine->generic.buffered_spriteram2.u16,2,0x8,0x8);
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,0,0);
-	draw_sprites(screen->machine,bitmap,screen->machine->generic.buffered_spriteram2.u16,2,0,0);
-	draw_sprites(screen->machine,bitmap,screen->machine->generic.buffered_spriteram.u16,1,0,0);
-	tilemap_draw(bitmap,cliprect,fix_tilemap,0,0);
+	bbusters_state *state = screen->machine->driver_data<bbusters_state>();
+
+	tilemap_set_scrollx(state->pf1_tilemap, 0, state->pf1_scroll_data[0]);
+	tilemap_set_scrolly(state->pf1_tilemap, 0, state->pf1_scroll_data[1]);
+	tilemap_set_scrollx(state->pf2_tilemap, 0, state->pf2_scroll_data[0]);
+	tilemap_set_scrolly(state->pf2_tilemap, 0, state->pf2_scroll_data[1]);
+
+	tilemap_draw(bitmap, cliprect, state->pf2_tilemap, 0, 0);
+	//draw_sprites(screen->machine, bitmap, screen->machine->generic.buffered_spriteram2.u16, 2, 0x8, 0x8);
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, 0, 0);
+	draw_sprites(screen->machine, bitmap, screen->machine->generic.buffered_spriteram2.u16, 2, 0, 0);
+	draw_sprites(screen->machine, bitmap, screen->machine->generic.buffered_spriteram.u16, 1, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->fix_tilemap, 0, 0);
 	return 0;
 }
 
 VIDEO_UPDATE( mechatt )
 {
-	tilemap_set_scrollx( pf1_tilemap,0, bbusters_pf1_scroll_data[0] );
-	tilemap_set_scrolly( pf1_tilemap,0, bbusters_pf1_scroll_data[1] );
-	tilemap_set_scrollx( pf2_tilemap,0, bbusters_pf2_scroll_data[0] );
-	tilemap_set_scrolly( pf2_tilemap,0, bbusters_pf2_scroll_data[1] );
-
-	tilemap_draw(bitmap,cliprect,pf2_tilemap,0,0);
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,0,0);
-	draw_sprites(screen->machine,bitmap,screen->machine->generic.buffered_spriteram.u16,1,0,0);
-	tilemap_draw(bitmap,cliprect,fix_tilemap,0,0);
+	bbusters_state *state = screen->machine->driver_data<bbusters_state>();
+
+	tilemap_set_scrollx(state->pf1_tilemap, 0, state->pf1_scroll_data[0]);
+	tilemap_set_scrolly(state->pf1_tilemap, 0, state->pf1_scroll_data[1]);
+	tilemap_set_scrollx(state->pf2_tilemap, 0, state->pf2_scroll_data[0]);
+	tilemap_set_scrolly(state->pf2_tilemap, 0, state->pf2_scroll_data[1]);
+
+	tilemap_draw(bitmap, cliprect, state->pf2_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, 0, 0);
+	draw_sprites(screen->machine, bitmap, screen->machine->generic.buffered_spriteram.u16, 1, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->fix_tilemap, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/beathead.c src/mame/video/beathead.c
--- src-old/mame/video/beathead.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/beathead.c	2010-08-21 16:13:26.000000000 -0700
@@ -15,14 +15,13 @@
  *
  *************************************/
 
-VIDEO_START( beathead )
+void beathead_state::video_start()
 {
-	beathead_state *state = machine->driver_data<beathead_state>();
-	state_save_register_global(machine, state->finescroll);
-	state_save_register_global(machine, state->vram_latch_offset);
-	state_save_register_global(machine, state->hsyncram_offset);
-	state_save_register_global(machine, state->hsyncram_start);
-	state_save_register_global_array(machine, state->hsyncram);
+	state_save_register_global(&m_machine, m_finescroll);
+	state_save_register_global(&m_machine, m_vram_latch_offset);
+	state_save_register_global(&m_machine, m_hsyncram_offset);
+	state_save_register_global(&m_machine, m_hsyncram_start);
+	state_save_register_global_array(&m_machine, m_hsyncram);
 }
 
 
@@ -33,21 +32,19 @@
  *
  *************************************/
 
-WRITE32_HANDLER( beathead_vram_transparent_w )
+WRITE32_MEMBER( beathead_state::vram_transparent_w )
 {
 	/* writes to this area appear to handle transparency */
 	if (!(data & 0x000000ff)) mem_mask &= ~0x000000ff;
 	if (!(data & 0x0000ff00)) mem_mask &= ~0x0000ff00;
 	if (!(data & 0x00ff0000)) mem_mask &= ~0x00ff0000;
 	if (!(data & 0xff000000)) mem_mask &= ~0xff000000;
-	COMBINE_DATA(&space->machine->generic.videoram.u32[offset]);
+	COMBINE_DATA(&m_videoram[offset]);
 }
 
 
-WRITE32_HANDLER( beathead_vram_bulk_w )
+WRITE32_MEMBER( beathead_state::vram_bulk_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
 	/* it appears that writes to this area pass in a mask for 4 words in VRAM */
 	/* allowing them to be filled from a preset latch */
 	offset &= ~3;
@@ -55,29 +52,24 @@
 
 	/* for now, just handle the bulk fill case; the others we'll catch later */
 	if (data == 0x0f0f0f0f)
-		space->machine->generic.videoram.u32[offset+0] =
-		space->machine->generic.videoram.u32[offset+1] =
-		space->machine->generic.videoram.u32[offset+2] =
-		space->machine->generic.videoram.u32[offset+3] = *state->vram_bulk_latch;
+		m_videoram[offset+0] = m_videoram[offset+1] = m_videoram[offset+2] = m_videoram[offset+3] = *m_vram_bulk_latch;
 	else
 		logerror("Detected bulk VRAM write with mask %08x\n", data);
 }
 
 
-WRITE32_HANDLER( beathead_vram_latch_w )
+WRITE32_MEMBER( beathead_state::vram_latch_w )
 {
 	/* latch the address */
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-	state->vram_latch_offset = (4 * offset) & 0x7ffff;
+	m_vram_latch_offset = (4 * offset) & 0x7ffff;
 }
 
 
-WRITE32_HANDLER( beathead_vram_copy_w )
+WRITE32_MEMBER( beathead_state::vram_copy_w )
 {
 	/* copy from VRAM to VRAM, for 1024 bytes */
-	beathead_state *state = space->machine->driver_data<beathead_state>();
 	offs_t dest_offset = (4 * offset) & 0x7ffff;
-	memcpy(&space->machine->generic.videoram.u32[dest_offset / 4], &space->machine->generic.videoram.u32[state->vram_latch_offset / 4], 0x400);
+	memcpy(&m_videoram[dest_offset / 4], &m_videoram[m_vram_latch_offset / 4], 0x400);
 }
 
 
@@ -88,17 +80,16 @@
  *
  *************************************/
 
-WRITE32_HANDLER( beathead_finescroll_w )
+WRITE32_MEMBER( beathead_state::finescroll_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-	UINT32 oldword = state->finescroll;
-	UINT32 newword = COMBINE_DATA(&state->finescroll);
+	UINT32 oldword = m_finescroll;
+	UINT32 newword = COMBINE_DATA(&m_finescroll);
 
 	/* if VBLANK is going off on a scanline other than the last, suspend time */
-	if ((oldword & 8) && !(newword & 8) && space->machine->primary_screen->vpos() != 261)
+	if ((oldword & 8) && !(newword & 8) && space.machine->primary_screen->vpos() != 261)
 	{
-		logerror("Suspending time! (scanline = %d)\n", space->machine->primary_screen->vpos());
-		cputag_set_input_line(space->machine, "maincpu", INPUT_LINE_HALT, ASSERT_LINE);
+		logerror("Suspending time! (scanline = %d)\n", space.machine->primary_screen->vpos());
+		cputag_set_input_line(space.machine, "maincpu", INPUT_LINE_HALT, ASSERT_LINE);
 	}
 }
 
@@ -110,13 +101,13 @@
  *
  *************************************/
 
-WRITE32_HANDLER( beathead_palette_w )
+WRITE32_MEMBER( beathead_state::palette_w )
 {
-	int newword = COMBINE_DATA(&space->machine->generic.paletteram.u32[offset]);
+	int newword = COMBINE_DATA(&m_paletteram[offset]);
 	int r = ((newword >> 9) & 0x3e) | ((newword >> 15) & 0x01);
 	int g = ((newword >> 4) & 0x3e) | ((newword >> 15) & 0x01);
 	int b = ((newword << 1) & 0x3e) | ((newword >> 15) & 0x01);
-	palette_set_color_rgb(space->machine, offset, pal6bit(r), pal6bit(g), pal6bit(b));
+	palette_set_color_rgb(space.machine, offset, pal6bit(r), pal6bit(g), pal6bit(b));
 }
 
 
@@ -127,36 +118,32 @@
  *
  *************************************/
 
-READ32_HANDLER( beathead_hsync_ram_r )
+READ32_MEMBER( beathead_state::hsync_ram_r )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
 	/* offset 0 is probably write-only */
 	if (offset == 0)
-		logerror("%08X:Unexpected HSYNC RAM read at offset 0\n", cpu_get_previouspc(space->cpu));
+		logerror("%08X:Unexpected HSYNC RAM read at offset 0\n", cpu_get_previouspc(space.cpu));
 
 	/* offset 1 reads the data */
 	else
-		return state->hsyncram[state->hsyncram_offset];
+		return m_hsyncram[m_hsyncram_offset];
 
 	return 0;
 }
 
-WRITE32_HANDLER( beathead_hsync_ram_w )
+WRITE32_MEMBER( beathead_state::hsync_ram_w )
 {
-	beathead_state *state = space->machine->driver_data<beathead_state>();
-
 	/* offset 0 selects the address, and can specify the start address */
 	if (offset == 0)
 	{
-		COMBINE_DATA(&state->hsyncram_offset);
-		if (state->hsyncram_offset & 0x800)
-			state->hsyncram_start = state->hsyncram_offset & 0x7ff;
+		COMBINE_DATA(&m_hsyncram_offset);
+		if (m_hsyncram_offset & 0x800)
+			m_hsyncram_start = m_hsyncram_offset & 0x7ff;
 	}
 
 	/* offset 1 writes the data */
 	else
-		COMBINE_DATA(&state->hsyncram[state->hsyncram_offset]);
+		COMBINE_DATA(&m_hsyncram[m_hsyncram_offset]);
 }
 
 
@@ -167,36 +154,35 @@
  *
  *************************************/
 
-VIDEO_UPDATE( beathead )
+bool beathead_state::video_update(screen_device &screen, bitmap_t &bitmap, const rectangle &cliprect)
 {
-	beathead_state *state = screen->machine->driver_data<beathead_state>();
-	UINT8 *videoram = screen->machine->generic.videoram.u8;
+	UINT8 *videoram = reinterpret_cast<UINT8 *>(m_videoram);
 	int x, y;
 
 	/* generate the final screen */
-	for (y = cliprect->min_y; y <= cliprect->max_y; y++)
+	for (y = cliprect.min_y; y <= cliprect.max_y; y++)
 	{
-		pen_t pen_base = (*state->palette_select & 0x7f) * 256;
+		pen_t pen_base = (*m_palette_select & 0x7f) * 256;
 		UINT16 scanline[336];
 
 		/* blanking */
-		if (state->finescroll & 8)
-			for (x = cliprect->min_x; x <= cliprect->max_x; x++)
+		if (m_finescroll & 8)
+			for (x = cliprect.min_x; x <= cliprect.max_x; x++)
 				scanline[x] = pen_base;
 
 		/* non-blanking */
 		else
 		{
-			offs_t scanline_offset = state->vram_latch_offset + (state->finescroll & 3);
-			offs_t src = scanline_offset + cliprect->min_x;
+			offs_t scanline_offset = m_vram_latch_offset + (m_finescroll & 3);
+			offs_t src = scanline_offset + cliprect.min_x;
 
 			/* unswizzle the scanline first */
-			for (x = cliprect->min_x; x <= cliprect->max_x; x++)
+			for (x = cliprect.min_x; x <= cliprect.max_x; x++)
 				scanline[x] = pen_base | videoram[BYTE4_XOR_LE(src++)];
 		}
 
 		/* then draw it */
-		draw_scanline16(bitmap, cliprect->min_x, y, cliprect->max_x - cliprect->min_x + 1, &scanline[cliprect->min_x], NULL);
+		draw_scanline16(&bitmap, cliprect.min_x, y, cliprect.max_x - cliprect.min_x + 1, &scanline[cliprect.min_x], NULL);
 	}
 	return 0;
 }
diff -Nru src-old/mame/video/bionicc.c src/mame/video/bionicc.c
--- src-old/mame/video/bionicc.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/bionicc.c	2010-08-19 00:26:14.000000000 -0700
@@ -262,7 +262,7 @@
 
 VIDEO_EOF( bionicc )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 }
diff -Nru src-old/mame/video/blktiger.c src/mame/video/blktiger.c
--- src-old/mame/video/blktiger.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/blktiger.c	2010-08-19 00:26:14.000000000 -0700
@@ -247,7 +247,7 @@
 
 VIDEO_EOF( blktiger )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/blstroid.c src/mame/video/blstroid.c
--- src-old/mame/video/blstroid.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/blstroid.c	2010-08-19 00:26:14.000000000 -0700
@@ -90,7 +90,7 @@
 
 static TIMER_CALLBACK( irq_off )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* clear the interrupt */
 	atarigen_scanline_int_ack_w(space, 0, 0, 0xffff);
diff -Nru src-old/mame/video/btoads.c src/mame/video/btoads.c
--- src-old/mame/video/btoads.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/btoads.c	2010-08-19 00:26:14.000000000 -0700
@@ -150,13 +150,13 @@
 
 WRITE16_HANDLER( btoads_paletteram_w )
 {
-	tlc34076_lsb_w(space, offset/2, data, mem_mask);
+	tlc34076_w(space->machine->device("tlc34076"), offset/2, data);
 }
 
 
 READ16_HANDLER( btoads_paletteram_r )
 {
-	return tlc34076_lsb_r(space, offset/2, mem_mask);
+	return tlc34076_r(space->machine->device("tlc34076"), offset/2);
 }
 
 
@@ -284,7 +284,7 @@
  *
  *************************************/
 
-void btoads_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void btoads_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	address &= ~0x40000000;
 
@@ -311,7 +311,7 @@
 }
 
 
-void btoads_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void btoads_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	address &= ~0x40000000;
 
@@ -350,7 +350,7 @@
 	UINT16 *bg1_base = &btoads_vram_bg1[(fulladdr + (yscroll1 << 10)) & 0x3fc00];
 	UINT8 *spr_base = &vram_fg_display[fulladdr & 0x3fc00];
 	UINT32 *dst = BITMAP_ADDR32(bitmap, scanline, 0);
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen.machine->device("tlc34076"));
 	int coladdr = fulladdr & 0x3ff;
 	int x;
 
diff -Nru src-old/mame/video/buggychl.c src/mame/video/buggychl.c
--- src-old/mame/video/buggychl.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/buggychl.c	2010-08-21 15:25:58.000000000 -0700
@@ -170,7 +170,7 @@
 	int offs;
 	const UINT8 *gfx;
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	gfx = memory_region(machine, "gfx2");
 	for (offs = 0; offs < state->spriteram_size; offs += 4)
@@ -232,7 +232,7 @@
 		}
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
diff -Nru src-old/mame/video/cischeat.c src/mame/video/cischeat.c
--- src-old/mame/video/cischeat.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/cischeat.c	2010-08-19 00:26:14.000000000 -0700
@@ -1336,7 +1336,7 @@
 	if (msk != 0) megasys1_active_layers &= msk;
 #if 1
 	{
-		const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 		popmessage("Cmd: %04X Pos:%04X Lim:%04X Inp:%04X",
 							scudhamm_motor_command,
diff -Nru src-old/mame/video/combatsc.c src/mame/video/combatsc.c
--- src-old/mame/video/combatsc.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/combatsc.c	2010-08-28 07:29:44.000000000 -0700
@@ -517,10 +517,10 @@
 
 static void bootleg_draw_sprites( running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, const UINT8 *source, int circuit )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	const gfx_element *gfx = machine->gfx[circuit + 2];
 
-	int limit = circuit ? (memory_read_byte(space, 0xc2) * 256 + memory_read_byte(space, 0xc3)) : (memory_read_byte(space, 0xc0) * 256 + memory_read_byte(space, 0xc1));
+	int limit = circuit ? (space->read_byte(0xc2) * 256 + space->read_byte(0xc3)) : (space->read_byte(0xc0) * 256 + space->read_byte(0xc1));
 	const UINT8 *finish;
 
 	source += 0x1000;
@@ -552,10 +552,10 @@
 //          if(state->vreg == 0x23 && (attributes & 0x02)) color += 1*16;
 //          if(state->vreg == 0x66 ) color += 2*16;
 
-			drawgfx_transpen( bitmap, cliprect, gfx,
-				number, color,
-				attributes & 0x10,0, /* flip */
-				x,y, 15 );
+			drawgfx_transpen(	bitmap, cliprect, gfx,
+							number, color,
+							attributes & 0x10,0, /* flip */
+							x, y, 15 );
 		}
 		source -= 8;
 	}
@@ -573,23 +573,21 @@
 		tilemap_set_scrollx(state->bg_tilemap[0], i, state->io_ram[0x040 + i] + 5);
 		tilemap_set_scrollx(state->bg_tilemap[1], i, state->io_ram[0x060 + i] + 3);
 	}
-	tilemap_set_scrolly(state->bg_tilemap[0], 0, state->io_ram[0x000]);
-	tilemap_set_scrolly(state->bg_tilemap[1], 0, state->io_ram[0x020]);
+	tilemap_set_scrolly(state->bg_tilemap[0], 0, state->io_ram[0x000] + 1);
+	tilemap_set_scrolly(state->bg_tilemap[1], 0, state->io_ram[0x020] + 1);
 
 	if (state->priority == 0)
 	{
-		tilemap_draw(bitmap, cliprect, state->bg_tilemap[1], TILEMAP_DRAW_OPAQUE,0);
-		bootleg_draw_sprites(screen->machine, bitmap,cliprect, state->page[1], 1);
-
+		tilemap_draw(bitmap, cliprect, state->bg_tilemap[1], TILEMAP_DRAW_OPAQUE, 0);
+		bootleg_draw_sprites(screen->machine, bitmap,cliprect, state->page[0], 0);
 		tilemap_draw(bitmap, cliprect, state->bg_tilemap[0], 0 ,0);
-		bootleg_draw_sprites(screen->machine, bitmap, cliprect, state->page[0], 0);
+		bootleg_draw_sprites(screen->machine, bitmap,cliprect, state->page[1], 1);
 	}
 	else
 	{
 		tilemap_draw(bitmap, cliprect, state->bg_tilemap[0], TILEMAP_DRAW_OPAQUE, 0);
 		bootleg_draw_sprites(screen->machine, bitmap,cliprect, state->page[0], 0);
-
-		tilemap_draw(bitmap,cliprect, state->bg_tilemap[1], 0, 0);
+		tilemap_draw(bitmap, cliprect, state->bg_tilemap[1], 0, 0);
 		bootleg_draw_sprites(screen->machine, bitmap,cliprect, state->page[1], 1);
 	}
 
diff -Nru src-old/mame/video/commando.c src/mame/video/commando.c
--- src-old/mame/video/commando.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/commando.c	2010-08-19 00:26:14.000000000 -0700
@@ -147,7 +147,7 @@
 
 VIDEO_EOF( commando )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/cps1.c src/mame/video/cps1.c
--- src-old/mame/video/cps1.c	2010-08-11 17:54:08.000000000 -0700
+++ src/mame/video/cps1.c	2010-08-24 17:26:33.000000000 -0700
@@ -21,7 +21,7 @@
 
 NAME                                                     Year  B-board #       B-board PALs      C-board #            CPS-B #          C-board PALs
 -------------------------------------------------------  ----  ---------  ---------------------  -----------  -----------------------  ------------
-Forgotten Worlds (World)                                 1988  88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
+Forgotten Worlds (World, B-Board 88621B-2)               1988  88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
 Forgotten Worlds (USA, B-Board 88621B-2)                       88621B-2   LW621            LWIO  None         CPS-B-01  DL-0411-10001  N/A
 Forgotten Worlds (USA, B-Board 88618B-?)                       88618B-?   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
 Lost Worlds (Japan Old Ver.)                                   88618B-2   LWCHR            LWIO  None         CPS-B-01  DL-0411-10001  N/A
@@ -71,7 +71,7 @@
 Magic Sword: Heroic Fantasy (World 900623)               1990  89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
 Magic Sword: Heroic Fantasy (World 900725)                     89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
 Magic Sword: Heroic Fantasy (USA 900725)                       89624B-3   MS24B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
-Magic Sword (Japan 900623)                                     89625B-1   MS22B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
+Magic Sword: Heroic Fantasy (Japan 900623)                     89625B-1   MS22B            IOB1  88622-C-5    CPS-B-13  DL-0411-10008  None
 
 Carrier Air Wing (World 901009)                          1990  89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
 Carrier Air Wing (World 901012)                                89624B-3   CA24B            IOB1  88622-C-5    CPS-B-16  DL-0411-10011  None
@@ -83,7 +83,7 @@
 
 Street Fighter II: The World Warrior (World 910214)      1991  90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
 Street Fighter II: The World Warrior (World 910522)            90629B-3   STF29            IOB1  90632C-1     CPS-B-11  DL-0411-10004  C632
-Street Fighter II: The World Warrior (USA 910206)              90629B-?   STF29            IOB1  ?            CPS-B-17  DL-0411-10012  C632
+Street Fighter II: The World Warrior (USA 910206)              90629B-2   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
 Street Fighter II: The World Warrior (USA 910214)              90629B-3   STF29            IOB1  90632C-1     CPS-B-17  DL-0411-10012  C632
 Street Fighter II: The World Warrior (USA 910228)              90629B-3   STF29            IOB2  90632C-1     CPS-B-18  DL-0411-10013  C632B
 Street Fighter II: The World Warrior (USA 910318)              90629B-?   STF29            IOB1  ?            CPS-B-05  DL-0411-10006  C632
@@ -100,7 +100,8 @@
 
 The King of Dragons* (World 910711)                      1991  90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 The King of Dragons* (USA 910910)                              90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-The King of Dragons* (Japan 910805)                            90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (Japan 910805, B-Board 89625B-1)          89625B-1   KD22B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+The King of Dragons* (Japan 910805, B-Board 90629B-3)          90629B-3   KD29B            IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 
 Captain Commando* (World 911014)                         1991  91635B-2   CC63B    CCPRG   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 Captain Commando* (World 911202)                               91635B-2   CC63B    CCPRG1  IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632B   IOC1
@@ -110,9 +111,11 @@
 
 Knights of the Round* (World 911127)                     1991  91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 Knights of the Round* (USA 911127)                             91635B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
-Knights of the Round* (Japan 911127)                           91634B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Knights of the Round* (Japan 911127, B-Board 89625B-1)         89625B-1   KR22B            LWIO  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
+Knights of the Round* (Japan 911127, B-Board 91634B-2)         91634B-2   KR63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 
 Street Fighter II': Champion Edition (World 920313)      1992  91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
+Street Fighter II': Champion Edition (World 920513)            91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
 Street Fighter II': Champion Edition (USA 920313)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
 Street Fighter II': Champion Edition (USA 920513)              91635B-2   S9263B   BPRG1   IOB1  92631C-6     CPS-B-21  DL-0921-10014  C632    IOC1
 Street Fighter II': Champion Edition (USA 920803)              91635B-?   S9263B   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014  C632    IOC1
@@ -126,7 +129,7 @@
 Varth: Operation Thunderstorm* (Japan 920714)                  88622B-3   VA22B            LWIO  92641C-1     CPS-B-21  DL-0921-10014          IOC1
 
 Quiz & Dragons: Capcom Quiz Game* (USA 920701)           1992  89625B-1   QD22B            IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
-Quiz & Dragons: Capcom Quiz Game* (Japan 940921)         1994  ?          ?                IOB1  ?            CPS-B-21  DL-0921-10014
+Quiz & Dragons: Capcom Quiz Game* (Japan 940921)         1994  91634B-2   QD63B    BPRG1   IOB1  90631C-5     CPS-B-21  DL-0921-10014  C632    IOC1
 
 Warriors of Fate* (World 921002)                         1992  91635B-?   TK263B   BPRG1   IOB1  ?            CPS-B-21  DL-0921-10014
 Warriors of Fate* (USA 921031)                                 91635B-2   TK263B   BPRG1   IOB1  92641C-1     CPS-B-21  DL-0921-10014          IOC1
@@ -1153,8 +1156,8 @@
 };
 
 
-#define mapper_qadj	{ 0x8000, 0, 0, 0 }, mapper_qadj_table
-static const struct gfx_range mapper_qadj_table[] =
+#define mapper_QD63B	{ 0x8000, 0, 0, 0 }, mapper_QD63B_table
+static const struct gfx_range mapper_QD63B_table[] =
 {
 	/* type                              start   end     bank */
 	{ GFXTYPE_SCROLL1,                   0x0000, 0x07ff, 0 },
@@ -1250,160 +1253,163 @@
 
 static const struct CPS1config cps1_config_table[]=
 {
-	/* name        CPSB          gfx mapper   in2  in3  out2   kludge */
-	{"forgottn",   CPS_B_01,     mapper_LW621 },
-	{"forgottnu",  CPS_B_01,     mapper_LW621 },
-	{"forgottnua", CPS_B_01,     mapper_LWCHR },
-	{"lostwrld",   CPS_B_01,     mapper_LWCHR },
-	{"lostwrldo",  CPS_B_01,     mapper_LWCHR },
-	{"ghouls",     CPS_B_01,     mapper_DM620 },
-	{"ghoulsu",    CPS_B_01,     mapper_DM620 },
-	{"daimakai",   CPS_B_01,     mapper_DM22A },	// equivalent to DM620
-	{"daimakair",  CPS_B_21_DEF, mapper_DAM63B },	// equivalent to DM620, also CPS_B_21_DEF is equivalent to CPS_B_01
-	{"strider",    CPS_B_01,     mapper_ST24M1 },
-	{"striderua",  CPS_B_01,     mapper_ST24M1 },	// wrong, this set uses ST24B2, still non dumped
-	{"striderj",   CPS_B_01,     mapper_ST22B },	// equivalent to ST24M1
-	{"striderjr",  CPS_B_21_DEF, mapper_ST24M1 },	// wrong, this set uses STH63B, still non dumped
-	{"dynwar",     CPS_B_02,     mapper_TK22B },	// wrong, this set uses TK24B1, dumped but equations still not added
-	{"dynwara",    CPS_B_02,     mapper_TK22B },
-	{"dynwarj",    CPS_B_02,     mapper_TK22B },
-	{"willow",     CPS_B_03,     mapper_WL24B },
-	{"willowj",    CPS_B_03,     mapper_WL24B },	// wrong, this set uses WL22B, still non dumped
-	{"willowje",   CPS_B_03,     mapper_WL24B },
-	{"ffight",     CPS_B_04,     mapper_S224B },
-	{"ffightu",    CPS_B_04,     mapper_S224B },
-	{"ffightua",   CPS_B_01,     mapper_S224B },
-	{"ffightub",   CPS_B_05,     mapper_S224B },
-	{"ffightj",    CPS_B_04,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
-	{"ffightj1",   CPS_B_01,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
-	{"ffightj2",   CPS_B_02,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
-	{"ffightjh",   CPS_B_01,     mapper_S224B },	// wrong, ffightjh hack doesn't even use the S222B PAL, since replaced with a GAL.
-	{"1941",       CPS_B_05,     mapper_YI24B },
-	{"1941j",      CPS_B_05,     mapper_YI24B },	// PAL used could be YI22B
-	{"unsquad",    CPS_B_11,     mapper_AR24B },
-	{"area88",     CPS_B_11,     mapper_AR22B },	// equivalent to AR24B
-	{"area88r",    CPS_B_21_DEF, mapper_AR22B },	// wrong, this set uses ARA63B, still non dumped
-	{"mercs",      CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
-	{"mercsu",     CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
-	{"mercsua",    CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
-	{"mercsj",     CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },	// wrong, this set uses O222B, still non dumped
-	{"msword",     CPS_B_13,     mapper_MS24B },
-	{"mswordr1",   CPS_B_13,     mapper_MS24B },
-	{"mswordu",    CPS_B_13,     mapper_MS24B },
-	{"mswordj",    CPS_B_13,     mapper_MS24B },	// wrong, this set uses MS22B, still non dumped
-	{"mtwins",     CPS_B_14,     mapper_CK24B },
-	{"chikij",     CPS_B_14,     mapper_CK24B },	// PAL used could be CK22B
-	{"nemo",       CPS_B_15,     mapper_NM24B },
-	{"nemoj",      CPS_B_15,     mapper_NM24B },	// wrong, this set uses NM22B, still non dumped
-	{"cawing",     CPS_B_16,     mapper_CA24B },
-	{"cawingr1",   CPS_B_16,     mapper_CA24B },
-	{"cawingu",    CPS_B_16,     mapper_CA24B },
-	{"cawingj",    CPS_B_16,     mapper_CA22B },	// equivalent to CA24B
-	{"sf2",        CPS_B_11,     mapper_STF29,  0x36 },
-	{"sf2eb",      CPS_B_17,     mapper_STF29,  0x36 },
-	{"sf2ebbl",    CPS_B_17,     mapper_STF29,  0x36, 0, 0, 1  },
-	{"sf2ua",      CPS_B_17,     mapper_STF29,  0x36 },
-	{"sf2ub",      CPS_B_17,     mapper_STF29,  0x36 },
-	{"sf2ud",      CPS_B_05,     mapper_STF29,  0x36 },
-	{"sf2ue",      CPS_B_18,     mapper_STF29,  0x3c },
-	{"sf2uf",      CPS_B_15,     mapper_STF29,  0x36 },
-	{"sf2ui",      CPS_B_14,     mapper_STF29,  0x36 },
-	{"sf2uk",      CPS_B_17,     mapper_STF29,  0x36 },	// check CPS_B
-	{"sf2j",       CPS_B_13,     mapper_STF29,  0x36 },
-	{"sf2ja",      CPS_B_17,     mapper_STF29,  0x36 },
-	{"sf2jc",      CPS_B_12,     mapper_STF29,  0x36 },
-	{"sf2qp1",     CPS_B_17,     mapper_STF29,  0x36 },
-	{"sf2thndr",   CPS_B_17,     mapper_STF29,  0x36 },
+	/* name         CPSB          gfx mapper   in2  in3  out2   kludge */
+	{"forgottn",    CPS_B_01,     mapper_LW621 },
+	{"forgottnu",   CPS_B_01,     mapper_LW621 },
+	{"forgottnua",  CPS_B_01,     mapper_LWCHR },
+	{"lostwrld",    CPS_B_01,     mapper_LWCHR },
+	{"lostwrldo",   CPS_B_01,     mapper_LWCHR },
+	{"ghouls",      CPS_B_01,     mapper_DM620 },
+	{"ghoulsu",     CPS_B_01,     mapper_DM620 },
+	{"daimakai",    CPS_B_01,     mapper_DM22A },	// equivalent to DM620
+	{"daimakair",   CPS_B_21_DEF, mapper_DAM63B },	// equivalent to DM620, also CPS_B_21_DEF is equivalent to CPS_B_01
+	{"strider",     CPS_B_01,     mapper_ST24M1 },
+	{"striderua",   CPS_B_01,     mapper_ST24M1 },	// wrong, this set uses ST24B2, still non dumped
+	{"striderj",    CPS_B_01,     mapper_ST22B },	// equivalent to ST24M1
+	{"striderjr",   CPS_B_21_DEF, mapper_ST24M1 },	// wrong, this set uses STH63B, still non dumped
+	{"dynwar",      CPS_B_02,     mapper_TK22B },	// wrong, this set uses TK24B1, dumped but equations still not added
+	{"dynwara",     CPS_B_02,     mapper_TK22B },
+	{"dynwarj",     CPS_B_02,     mapper_TK22B },
+	{"willow",      CPS_B_03,     mapper_WL24B },
+	{"willowj",     CPS_B_03,     mapper_WL24B },	// wrong, this set uses WL22B, still non dumped
+	{"willowje",    CPS_B_03,     mapper_WL24B },
+	{"ffight",      CPS_B_04,     mapper_S224B },
+	{"ffightu",     CPS_B_04,     mapper_S224B },
+	{"ffightua",    CPS_B_01,     mapper_S224B },
+	{"ffightub",    CPS_B_05,     mapper_S224B },
+	{"ffightj",     CPS_B_04,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
+	{"ffightj1",    CPS_B_01,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
+	{"ffightj2",    CPS_B_02,     mapper_S224B },	// wrong, this set uses S222B, still non dumped
+	{"ffightjh",    CPS_B_01,     mapper_S224B },	// wrong, ffightjh hack doesn't even use the S222B PAL, since replaced with a GAL.
+	{"1941",        CPS_B_05,     mapper_YI24B },
+	{"1941j",       CPS_B_05,     mapper_YI24B },	// PAL used could be YI22B
+	{"unsquad",     CPS_B_11,     mapper_AR24B },
+	{"area88",      CPS_B_11,     mapper_AR22B },	// equivalent to AR24B
+	{"area88r",     CPS_B_21_DEF, mapper_AR22B },	// wrong, this set uses ARA63B, still non dumped
+	{"mercs",       CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
+	{"mercsu",      CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
+	{"mercsua",     CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },
+	{"mercsj",      CPS_B_12,     mapper_O224B,  0x36, 0, 0x34 },	// wrong, this set uses O222B, still non dumped
+	{"msword",      CPS_B_13,     mapper_MS24B },
+	{"mswordr1",    CPS_B_13,     mapper_MS24B },
+	{"mswordu",     CPS_B_13,     mapper_MS24B },
+	{"mswordj",     CPS_B_13,     mapper_MS24B },	// wrong, this set uses MS22B, still non dumped
+	{"mtwins",      CPS_B_14,     mapper_CK24B },
+	{"chikij",      CPS_B_14,     mapper_CK24B },	// PAL used could be CK22B
+	{"nemo",        CPS_B_15,     mapper_NM24B },
+	{"nemoj",       CPS_B_15,     mapper_NM24B },	// wrong, this set uses NM22B, still non dumped
+	{"cawing",      CPS_B_16,     mapper_CA24B },
+	{"cawingr1",    CPS_B_16,     mapper_CA24B },
+	{"cawingu",     CPS_B_16,     mapper_CA24B },
+	{"cawingj",     CPS_B_16,     mapper_CA22B },	// equivalent to CA24B
+	{"sf2",         CPS_B_11,     mapper_STF29,  0x36 },
+	{"sf2eb",       CPS_B_17,     mapper_STF29,  0x36 },
+	{"sf2ebbl",     CPS_B_17,     mapper_STF29,  0x36, 0, 0, 1  },
+	{"sf2ua",       CPS_B_17,     mapper_STF29,  0x36 },
+	{"sf2ub",       CPS_B_17,     mapper_STF29,  0x36 },
+	{"sf2ud",       CPS_B_05,     mapper_STF29,  0x36 },
+	{"sf2ue",       CPS_B_18,     mapper_STF29,  0x3c },
+	{"sf2uf",       CPS_B_15,     mapper_STF29,  0x36 },
+	{"sf2ui",       CPS_B_14,     mapper_STF29,  0x36 },
+	{"sf2uk",       CPS_B_17,     mapper_STF29,  0x36 },	// check CPS_B
+	{"sf2j",        CPS_B_13,     mapper_STF29,  0x36 },
+	{"sf2ja",       CPS_B_17,     mapper_STF29,  0x36 },
+	{"sf2jc",       CPS_B_12,     mapper_STF29,  0x36 },
+	{"sf2qp1",      CPS_B_17,     mapper_STF29,  0x36 },
+	{"sf2thndr",    CPS_B_17,     mapper_STF29,  0x36 },
 
 	/* from here onwards the CPS-B board has suicide battery and multiply protection */
 
-	{"3wonders",   CPS_B_21_BT1, mapper_RT24B },
-	{"3wondersu",  CPS_B_21_BT1, mapper_RT24B },
-	{"wonder3",    CPS_B_21_BT1, mapper_RT22B },	// equivalent to RT24B
-	{"3wondersh",  CPS_B_02    , mapper_RT24B },	/* Not 100% sure of the CPS B-ID */
-	{"kod",        CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
-	{"kodu",       CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
-	{"kodj",       CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
-	{"kodb",       CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },	/* bootleg, doesn't use multiply protection */
-	{"captcomm",   CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"captcommr1", CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"captcommu",  CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"captcommj",  CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"captcommjr1",CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"captcommb",  CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
-	{"knights",    CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
-	{"knightsu",   CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
-	{"knightsj",   CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
-	{"knightsb",   CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },	// wrong, knightsb bootleg doesn't use the KR63B PAL
-	{"sf2ce",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2ceua",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2ceub",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2ceuc",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2cej",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2rb",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2rb2",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2rb3",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2red",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2v004",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2acc",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2accp2",   CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2dkot2",   CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2m1",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2m2",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2m3",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2m4",      HACK_B_1,     mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2m5",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2m6",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2m7",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2yyc",     CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2koryu",   CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"sf2mdt",     CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
-	{"varth",      CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */	// wrong, this set uses VA24B, still non dumped
-	{"varthr1",    CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */	// wrong, this set uses VA24B, still non dumped
-	{"varthu",     CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */
-	{"varthj",     CPS_B_21_BT5, mapper_VA22B },	/* CPSB test has been patched out (72=0001) register is also written to, possibly leftover from development */
-	{"cworld2j",   CPS_B_21_BT6, mapper_Q522B,  0x36, 0, 0x34 },	/* (ports 36, 34 probably leftover input code from another game) */
-	{"wof",        CPS_B_21_DEF, mapper_TK263B },
-	{"wofa",       CPS_B_21_DEF, mapper_TK263B },
-	{"wofu",       CPS_B_21_QS1, mapper_TK263B },
-	{"wofj",       CPS_B_21_QS1, mapper_TK263B },
-	{"wofhfh",     CPS_B_21_DEF, mapper_TK263B, 0x36 },	/* Chinese bootleg */
-	{"dino",       CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
-	{"dinou",      CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
-	{"dinoj",      CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
-	{"dinopic",    CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
-	{"dinopic2",   CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
-	{"dinohunt",   CPS_B_21_DEF, mapper_CD63B },	/* Chinese bootleg */
-	{"punisher",   CPS_B_21_QS3, mapper_PS63B },
-	{"punisheru",  CPS_B_21_QS3, mapper_PS63B },
-	{"punisherj",  CPS_B_21_QS3, mapper_PS63B },
-	{"punipic",    CPS_B_21_QS3, mapper_PS63B },
-	{"punipic2",   CPS_B_21_QS3, mapper_PS63B },
-	{"punipic3",   CPS_B_21_QS3, mapper_PS63B },
-	{"punisherbz", CPS_B_21_DEF, mapper_PS63B },	/* Chinese bootleg */
-	{"slammast",   CPS_B_21_QS4, mapper_MB63B },
-	{"slammastu",  CPS_B_21_QS4, mapper_MB63B },
-	{"mbomberj",   CPS_B_21_QS4, mapper_MB63B },
-	{"mbombrd",    CPS_B_21_QS5, mapper_MB63B },
-	{"mbombrdj",   CPS_B_21_QS5, mapper_MB63B },
-	{"sf2hf",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2hfu",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"sf2hfj",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
-	{"qad",        CPS_B_21_BT7, mapper_QD22B,  0x36 },	/* TODO: layer enable (port 36 probably leftover input code from another game) */
-	{"qadj",       CPS_B_21_DEF, mapper_qadj,   0x36, 0x38, 0x34 },	/* (ports 36, 38, 34 probably leftover input code from another game) */
-	{"qtono2j",    CPS_B_21_DEF, mapper_qtono2j,0x36, 0x38, 0x34 },	/* (ports 36, 38, 34 probably leftover input code from another game) */
-	{"megaman",    CPS_B_21_DEF, mapper_RCM63B },
-	{"rockmanj",   CPS_B_21_DEF, mapper_RCM63B },
-	{"pnickj",     CPS_B_21_DEF, mapper_PKB10B },
-	{"pang3",      CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
-	{"pang3n",     CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
-	{"pang3j",     CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
+	{"3wonders",    CPS_B_21_BT1, mapper_RT24B },
+	{"3wondersu",   CPS_B_21_BT1, mapper_RT24B },
+	{"wonder3",     CPS_B_21_BT1, mapper_RT22B },	// equivalent to RT24B
+	{"3wondersh",   CPS_B_02    , mapper_RT24B },	/* Not 100% sure of the CPS B-ID */
+	{"kod",         CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
+	{"kodu",        CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
+	{"kodj",        CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },
+	{"kodja",       CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },	// wrong, this set uses KD22B, still non dumped
+	{"kodb",        CPS_B_21_BT2, mapper_KD29B,  0x36, 0, 0x34 },	/* bootleg, doesn't use multiply protection */
+	{"captcomm",    CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"captcommr1",  CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"captcommu",   CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"captcommj",   CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"captcommjr1", CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"captcommb",   CPS_B_21_BT3, mapper_CC63B,  0x36, 0x38, 0x34 },
+	{"knights",     CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
+	{"knightsu",    CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
+	{"knightsj",    CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },
+	{"knightsja",   CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },	// wrong, this set uses KR22B, still non dumped
+	{"knightsb",    CPS_B_21_BT4, mapper_KR63B,  0x36, 0, 0x34 },	// wrong, knightsb bootleg doesn't use the KR63B PAL
+	{"sf2ce",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2ceea",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2ceua",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2ceub",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2ceuc",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2cej",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2rb",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2rb2",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2rb3",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2red",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2v004",     CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2acc",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2accp2",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2dkot2",    CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2m1",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2m2",       CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2m3",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2m4",       HACK_B_1,     mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2m5",       CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2m6",       CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2m7",       CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2yyc",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2koryu",    CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"sf2mdt",      CPS_B_21_DEF, mapper_S9263B, 0x36, 0, 0, 1 },
+	{"varth",       CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */	// wrong, this set uses VA24B, still non dumped
+	{"varthr1",     CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */	// wrong, this set uses VA24B, still non dumped
+	{"varthu",      CPS_B_04,     mapper_VA63B },	/* CPSB test has been patched out (60=0008) register is also written to, possibly leftover from development */
+	{"varthj",      CPS_B_21_BT5, mapper_VA22B },	/* CPSB test has been patched out (72=0001) register is also written to, possibly leftover from development */
+	{"cworld2j",    CPS_B_21_BT6, mapper_Q522B,  0x36, 0, 0x34 },	/* (ports 36, 34 probably leftover input code from another game) */
+	{"wof",         CPS_B_21_DEF, mapper_TK263B },
+	{"wofa",        CPS_B_21_DEF, mapper_TK263B },
+	{"wofu",        CPS_B_21_QS1, mapper_TK263B },
+	{"wofj",        CPS_B_21_QS1, mapper_TK263B },
+	{"wofhfh",      CPS_B_21_DEF, mapper_TK263B, 0x36 },	/* Chinese bootleg */
+	{"dino",        CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
+	{"dinou",       CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
+	{"dinoj",       CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
+	{"dinopic",     CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
+	{"dinopic2",    CPS_B_21_QS2, mapper_CD63B },	/* layer enable never used */
+	{"dinohunt",    CPS_B_21_DEF, mapper_CD63B },	/* Chinese bootleg */
+	{"punisher",    CPS_B_21_QS3, mapper_PS63B },
+	{"punisheru",   CPS_B_21_QS3, mapper_PS63B },
+	{"punisherj",   CPS_B_21_QS3, mapper_PS63B },
+	{"punipic",     CPS_B_21_QS3, mapper_PS63B },
+	{"punipic2",    CPS_B_21_QS3, mapper_PS63B },
+	{"punipic3",    CPS_B_21_QS3, mapper_PS63B },
+	{"punisherbz",  CPS_B_21_DEF, mapper_PS63B },	/* Chinese bootleg */
+	{"slammast",    CPS_B_21_QS4, mapper_MB63B },
+	{"slammastu",   CPS_B_21_QS4, mapper_MB63B },
+	{"mbomberj",    CPS_B_21_QS4, mapper_MB63B },
+	{"mbombrd",     CPS_B_21_QS5, mapper_MB63B },
+	{"mbombrdj",    CPS_B_21_QS5, mapper_MB63B },
+	{"sf2hf",       CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2hfu",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"sf2hfj",      CPS_B_21_DEF, mapper_S9263B, 0x36 },
+	{"qad",         CPS_B_21_BT7, mapper_QD22B,  0x36 },	/* TODO: layer enable (port 36 probably leftover input code from another game) */
+	{"qadj",        CPS_B_21_DEF, mapper_QD63B,  0x36, 0x38, 0x34 },	/* (ports 36, 38, 34 probably leftover input code from another game) */
+	{"qtono2j",     CPS_B_21_DEF, mapper_qtono2j,0x36, 0x38, 0x34 },	/* (ports 36, 38, 34 probably leftover input code from another game) */
+	{"megaman",     CPS_B_21_DEF, mapper_RCM63B },
+	{"rockmanj",    CPS_B_21_DEF, mapper_RCM63B },
+	{"pnickj",      CPS_B_21_DEF, mapper_PKB10B },
+	{"pang3",       CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
+	{"pang3n",      CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
+	{"pang3j",      CPS_B_21_DEF, mapper_pang3 },	/* EEPROM port is among the CPS registers (handled by DRIVER_INIT) */	// should use one of these three CP1B1F,CP1B8K,CP1B9KA still not dumped
 	#ifdef MESS
-	{"sfzch",      CPS_B_21_DEF, mapper_sfzch },	// not an arcade game and no more in MAME, should not be removed?
+	{"sfzch",       CPS_B_21_DEF, mapper_sfzch },	/* Actually a CPS1 based home consol game, so it's not supported in MAME, but used in MESS */
 	#endif
 
     /* CPS2 games */
-	{"cps2",       CPS_B_21_DEF, mapper_cps2 },
+	{"cps2",        CPS_B_21_DEF, mapper_cps2 },
 
 	{0}		/* End of table */
 };
@@ -2414,7 +2420,7 @@
 
 								DRAWSPRITE(
 //                                      code + nxs + 0x10 * nys,
-										(code & ~0xf) + ((code + nxs) & 0xf) + 0x10 * nys,	// fix 00406: qadj: When playing as the ninja, there is one broekn frame in his animation loop when walking.
+										(code & ~0xf) + ((code + nxs) & 0xf) + 0x10 * nys,	// fix 00406: qadj: When playing as the ninja, there is one broken frame in his animation loop when walking.
 										(col & 0x1f),
 										0,0,
 										sx,sy);
diff -Nru src-old/mame/video/crshrace.c src/mame/video/crshrace.c
--- src-old/mame/video/crshrace.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/crshrace.c	2010-08-19 00:26:14.000000000 -0700
@@ -219,7 +219,7 @@
 
 VIDEO_EOF( crshrace )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 	buffer_spriteram16_2_w(space, 0, 0, 0xffff);
diff -Nru src-old/mame/video/dc.c src/mame/video/dc.c
--- src-old/mame/video/dc.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/dc.c	2010-08-21 15:25:58.000000000 -0700
@@ -130,7 +130,7 @@
 static int dilatechose[64];
 static float wbuffer[480][640];
 static UINT32 debug_dip_status;
-static void pvr_accumulationbuffer_to_framebuffer(const address_space *space, int x,int y);
+static void pvr_accumulationbuffer_to_framebuffer(address_space *space, int x,int y);
 
 UINT64 *dc_framebuffer_ram; // '32-bit access area'
 UINT64 *dc_texture_ram; // '64-bit access area'
@@ -1075,7 +1075,7 @@
 		}
 		break;
 	case STARTRENDER:
-		profiler_mark_start(PROFILER_USER1);
+		g_profiler.start(PROFILER_USER1);
 		#if DEBUG_PVRTA
 		mame_printf_verbose("Start Render Received:\n");
 		mame_printf_verbose("  Region Array at %08x\n",pvrta_regs[REGION_BASE]);
@@ -1123,15 +1123,15 @@
 				{
 					UINT32 st[6];
 
-					st[0]=memory_read_dword(space,(0x05000000+offsetra));
-					st[1]=memory_read_dword(space,(0x05000004+offsetra)); // Opaque List Pointer
-					st[2]=memory_read_dword(space,(0x05000008+offsetra)); // Opaque Modifier Volume List Pointer
-					st[3]=memory_read_dword(space,(0x0500000c+offsetra)); // Translucent List Pointer
-					st[4]=memory_read_dword(space,(0x05000010+offsetra)); // Translucent Modifier Volume List Pointer
+					st[0]=space->read_dword((0x05000000+offsetra));
+					st[1]=space->read_dword((0x05000004+offsetra)); // Opaque List Pointer
+					st[2]=space->read_dword((0x05000008+offsetra)); // Opaque Modifier Volume List Pointer
+					st[3]=space->read_dword((0x0500000c+offsetra)); // Translucent List Pointer
+					st[4]=space->read_dword((0x05000010+offsetra)); // Translucent Modifier Volume List Pointer
 
 					if (sizera == 6)
 					{
-						st[5] = memory_read_dword(space,(0x05000014+offsetra)); // Punch Through List Pointer
+						st[5] = space->read_dword((0x05000014+offsetra)); // Punch Through List Pointer
 						offsetra+=0x18;
 					}
 					else
@@ -1237,7 +1237,7 @@
 			state_ta.grab[state_ta.grabsel].verts_size=0;
 			state_ta.grab[state_ta.grabsel].strips_size=0;
 
-			profiler_mark_end();
+			g_profiler.stop();
 		}
 		break;
 //#define TA_YUV_TEX_BASE       ((0x005f8148-0x005f8000)/4)
@@ -1963,7 +1963,7 @@
 
 static void render_to_accumulation_buffer(running_machine *machine,bitmap_t *bitmap,const rectangle *cliprect)
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	int cs,rs,ns;
 	UINT32 c;
 #if 0
@@ -1980,7 +1980,7 @@
 
 	rs=state_ta.renderselect;
 	c=pvrta_regs[ISP_BACKGND_T];
-	c=memory_read_dword(space,0x05000000+((c&0xfffff8)>>1)+(3+3)*4);
+	c=space->read_dword(0x05000000+((c&0xfffff8)>>1)+(3+3)*4);
 	bitmap_fill(bitmap,cliprect,c);
 
 
@@ -2033,7 +2033,7 @@
 
 */
 
-static void pvr_accumulationbuffer_to_framebuffer(const address_space *space, int x,int y)
+static void pvr_accumulationbuffer_to_framebuffer(address_space *space, int x,int y)
 {
 	// the accumulation buffer is always 8888
 	//
@@ -2073,7 +2073,7 @@
 					                ((((data & 0x0000fc00) >> 10)) << 5)  |
 									((((data & 0x00f80000) >> 19)) << 11);
 
-					memory_write_word(space,realwriteoffs+xcnt*2, newdat);
+					space->write_word(realwriteoffs+xcnt*2, newdat);
 				}
 			}
 		}
@@ -2101,7 +2101,7 @@
 									((((data & 0x00f80000) >> 19)) << 10);
 					// alpha?
 
-					memory_write_word(space,realwriteoffs+xcnt*2, newdat);
+					space->write_word(realwriteoffs+xcnt*2, newdat);
 				}
 			}
 		}
@@ -2125,7 +2125,7 @@
 					                ((((data & 0x0000fc00) >> 10)) << 5)  |
 									((((data & 0x00f80000) >> 19)) << 11);
 
-					memory_write_word(space,realwriteoffs+xcnt*2, newdat);
+					space->write_word(realwriteoffs+xcnt*2, newdat);
 				}
 			}
 		}
@@ -2152,7 +2152,7 @@
 					                ((((data & 0x0000fc00) >> 10)) << 5)  |
 									((((data & 0x00f80000) >> 19)) << 11);
 
-					memory_write_word(space,realwriteoffs+xcnt*2, newdat);
+					space->write_word(realwriteoffs+xcnt*2, newdat);
 				}
 			}
 		}
diff -Nru src-old/mame/video/dogfgt.c src/mame/video/dogfgt.c
--- src-old/mame/video/dogfgt.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/dogfgt.c	2010-08-19 00:26:14.000000000 -0700
@@ -224,7 +224,7 @@
 
 	if (state->lastflip != flip_screen_get(screen->machine) || state->lastpixcolor != state->pixcolor)
 	{
-		const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 		state->lastflip = flip_screen_get(screen->machine);
 		state->lastpixcolor = state->pixcolor;
diff -Nru src-old/mame/video/dooyong.c src/mame/video/dooyong.c
--- src-old/mame/video/dooyong.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/dooyong.c	2010-08-30 08:20:58.000000000 -0700
@@ -1,10 +1,11 @@
 #include "emu.h"
 #include "includes/dooyong.h"
 
-
+UINT8 *paletteram_flytiger;
 UINT8 *dooyong_txvideoram;
 
 static UINT8 sprites_disabled;		/* Used by lastday/lastdaya */
+static UINT8 flytiger_palette_bank;		/* Used by flytiger */
 static UINT8 flytiger_pri;			/* Used by flytiger */
 static UINT8 tx_pri;				/* Used by sadari/gundl94/primella */
 static UINT16 rshark_pri;			/* Used by rshark/superx/popbingo */
@@ -176,18 +177,33 @@
 //  logerror("%04x: bankswitch = %02x\n",cpu_get_pc(space->cpu),data&0xe0);
 }
 
+WRITE8_HANDLER( paletteram_flytiger_w )
+{
+	if (flytiger_palette_bank)
+	{
+		UINT16 value;
+		paletteram_flytiger[offset] = data;
+		value = paletteram_flytiger[offset & ~1] | (paletteram_flytiger[offset | 1] << 8);
+		palette_set_color_rgb(space->machine, offset/2, pal5bit(value >> 10), pal5bit(value >> 5), pal5bit(value >> 0));
+	}
+}
+
 WRITE8_HANDLER( flytiger_ctrl_w )
 {
 	/* bit 0 is flip screen */
 	flip_screen_set(space->machine, data & 0x01);
 
-	/* bits 1, 2, 3 used but unknown */
+	/* bits 1, 2 used but unknown */
+
+	/* bit 3 fg palette banking: trash protection? */
+	flytiger_palette_bank = data & 0x08;
 
 	/* bit 4 changes tilemaps priority */
 	flytiger_pri = data & 0x10;
 }
 
 WRITE16_HANDLER( rshark_ctrl_w )
+
 {
 	if (ACCESSING_BITS_0_7)
 	{
@@ -302,9 +318,7 @@
 		lastday_get_tile_info(machine, tileinfo, tile_index, fg2_tilerom, fg2scroll8, fg2_gfx);
 }
 
-/* flytiger uses some palette banking technique or something, but we
-   don't know what it is.  For now, this is the same as the code used
-   for the other layers (hence the really strange colour). */
+/* flytiger uses some palette banking technique or something maybe a trash protection */
 
 static TILE_GET_INFO( flytiger_get_fg_tile_info )
 {
@@ -313,7 +327,7 @@
 	int offs = (tile_index + (fgscroll8[1] << 6)) * 2;
 	int attr = tilerom[offs];
 	int code = tilerom[offs + 1] | ((attr & 0x01) << 8) | ((attr & 0x80) << 2);
-	int color = (attr & 0x78) >> 3; //TODO: missing 4th bit or palette bank
+	int color = (attr & 0x78) >> 3;
 	int flags = ((attr & 0x02) ? TILE_FLIPX : 0) | ((attr & 0x04) ? TILE_FLIPY : 0);
 
 	SET_TILE_INFO(fg_gfx, code, color, flags);
@@ -907,14 +921,14 @@
 
 VIDEO_EOF( dooyong )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
 
 VIDEO_EOF( rshark )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 }
diff -Nru src-old/mame/video/dynduke.c src/mame/video/dynduke.c
--- src-old/mame/video/dynduke.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/dynduke.c	2010-08-19 00:26:14.000000000 -0700
@@ -244,7 +244,7 @@
 
 VIDEO_EOF( dynduke )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff); // Could be a memory location instead
 }
diff -Nru src-old/mame/video/exedexes.c src/mame/video/exedexes.c
--- src-old/mame/video/exedexes.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/exedexes.c	2010-08-19 00:26:14.000000000 -0700
@@ -247,7 +247,7 @@
 
 VIDEO_EOF( exedexes )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/exterm.c src/mame/video/exterm.c
--- src-old/mame/video/exterm.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/exterm.c	2010-08-19 00:26:14.000000000 -0700
@@ -36,25 +36,25 @@
  *
  *************************************/
 
-void exterm_to_shiftreg_master(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void exterm_to_shiftreg_master(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &exterm_master_videoram[TOWORD(address)], 256 * sizeof(UINT16));
 }
 
 
-void exterm_from_shiftreg_master(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void exterm_from_shiftreg_master(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&exterm_master_videoram[TOWORD(address)], shiftreg, 256 * sizeof(UINT16));
 }
 
 
-void exterm_to_shiftreg_slave(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void exterm_to_shiftreg_slave(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &exterm_slave_videoram[TOWORD(address)], 256 * 2 * sizeof(UINT8));
 }
 
 
-void exterm_from_shiftreg_slave(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void exterm_from_shiftreg_slave(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&exterm_slave_videoram[TOWORD(address)], shiftreg, 256 * 2 * sizeof(UINT8));
 }
diff -Nru src-old/mame/video/gaelco2.c src/mame/video/gaelco2.c
--- src-old/mame/video/gaelco2.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/gaelco2.c	2010-08-19 00:26:14.000000000 -0700
@@ -509,7 +509,7 @@
 
 VIDEO_EOF( gaelco2 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* sprites are one frame ahead */
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
diff -Nru src-old/mame/video/galaxian.c src/mame/video/galaxian.c
--- src-old/mame/video/galaxian.c	2010-06-17 07:04:37.000000000 -0700
+++ src/mame/video/galaxian.c	2010-08-26 08:21:19.000000000 -0700
@@ -879,7 +879,7 @@
  *
  *************************************/
 
-TIMER_CALLBACK( galaxian_stars_blink_timer )
+TIMER_DEVICE_CALLBACK( galaxian_stars_blink_timer )
 {
 	stars_blink_state++;
 }
diff -Nru src-old/mame/video/genesis.c src/mame/video/genesis.c
--- src-old/mame/video/genesis.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/genesis.c	2010-08-19 01:27:05.000000000 -0700
@@ -43,10 +43,10 @@
 static int  vdp_data_r(running_machine *machine);
 static void vdp_data_w(running_machine *machine, int data);
 static int  vdp_control_r(running_machine *machine);
-static void vdp_control_w(const address_space *space, int data);
+static void vdp_control_w(address_space *space, int data);
 static void vdp_register_w(running_machine *machine, int data, int vblank);
-static void vdp_control_dma(const address_space *space, int data);
-static void vdp_dma_68k(const address_space *space);
+static void vdp_control_dma(address_space *space, int data);
+static void vdp_dma_68k(address_space *space);
 static void vdp_dma_fill(int);
 static void vdp_dma_copy(void);
 
@@ -490,7 +490,7 @@
 }
 
 
-static void vdp_control_w(const address_space *space, int data)
+static void vdp_control_w(address_space *space, int data)
 {
 	/* case 1: we're not expecting the 2nd half of a command */
 	if (!vdp_cmdpart)
@@ -629,7 +629,7 @@
 }
 
 
-static void vdp_control_dma(const address_space *space, int data)
+static void vdp_control_dma(address_space *space, int data)
 {
 	if ((vdp_code & 0x20) && (genesis_vdp_regs[1] & 0x10))
 	{
@@ -661,7 +661,7 @@
 
 ******************************************************************************/
 
-static void vdp_dma_68k(const address_space *space)
+static void vdp_dma_68k(address_space *space)
 {
 	int length = genesis_vdp_regs[19] | (genesis_vdp_regs[20] << 8);
 	int source = (genesis_vdp_regs[21] << 1) | (genesis_vdp_regs[22] << 9) | ((genesis_vdp_regs[23] & 0x7f) << 17);
@@ -674,7 +674,7 @@
 	/* handle the DMA */
 	for (count = 0; count < length; count++)
 	{
-		vdp_data_w(space->machine, memory_read_word(space, source));
+		vdp_data_w(space->machine, space->read_word(source));
 		source += 2;
 	}
 }
diff -Nru src-old/mame/video/gng.c src/mame/video/gng.c
--- src-old/mame/video/gng.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/gng.c	2010-08-19 00:26:14.000000000 -0700
@@ -152,7 +152,7 @@
 
 VIDEO_EOF( gng )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/gp9001.c src/mame/video/gp9001.c
--- src-old/mame/video/gp9001.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/video/gp9001.c	2010-08-26 08:21:19.000000000 -0700
@@ -128,9 +128,6 @@
 #include "emu.h"
 #include "gp9001.h"
 
-bitmap_t* gp9001_custom_priority_bitmap;
-int gp9001_displog = 0;
-
 static WRITE16_DEVICE_HANDLER( gp9001_bg_tilemap_w )
 {
 	gp9001vdp_device *vdp = (gp9001vdp_device*)device;
@@ -182,28 +179,11 @@
 	COMBINE_DATA(&vdp->spriteram16_new[offset]);
 }
 
-/* how to create a generic map which uses the CURRENT device? we have to create specific ones below at the moment */
 static ADDRESS_MAP_START( gp9001vdp_map, 0, 16 )
-//  AM_RANGE(0x0000, 0x0fff) AM_DEVREADWRITE( this, gp9001_bg_tilemap_r, gp9001_bg_tilemap_w)
-//  AM_RANGE(0x1000, 0x1fff) AM_DEVREADWRITE( this, gp9001_fg_tilemap_r, gp9001_fg_tilemap_w)
-//  AM_RANGE(0x2000, 0x2fff) AM_DEVREADWRITE( this, gp9001_top_tilemap_r, gp9001_top_tilemap_w)
-//  AM_RANGE(0x3000, 0x37ff) AM_DEVREADWRITE( this, gp9001_spram_r, gp9001_spram_w)
-//  AM_RANGE(0x3800, 0x3fff) AM_RAM // sprite mirror?
-ADDRESS_MAP_END
-
-ADDRESS_MAP_START( gp9001vdp0_map, 0, 16 )
-	AM_RANGE(0x0000, 0x0fff) AM_DEVREADWRITE("gp9001vdp0", gp9001_bg_tilemap_r, gp9001_bg_tilemap_w)
-	AM_RANGE(0x1000, 0x1fff) AM_DEVREADWRITE("gp9001vdp0", gp9001_fg_tilemap_r, gp9001_fg_tilemap_w)
-	AM_RANGE(0x2000, 0x2fff) AM_DEVREADWRITE("gp9001vdp0", gp9001_top_tilemap_r, gp9001_top_tilemap_w)
-	AM_RANGE(0x3000, 0x37ff) AM_DEVREADWRITE("gp9001vdp0", gp9001_spram_r, gp9001_spram_w)
-	AM_RANGE(0x3800, 0x3fff) AM_RAM // sprite mirror?
-ADDRESS_MAP_END
-
-ADDRESS_MAP_START( gp9001vdp1_map, 0, 16 )
-	AM_RANGE(0x0000, 0x0fff) AM_DEVREADWRITE("gp9001vdp1", gp9001_bg_tilemap_r, gp9001_bg_tilemap_w)
-	AM_RANGE(0x1000, 0x1fff) AM_DEVREADWRITE("gp9001vdp1", gp9001_fg_tilemap_r, gp9001_fg_tilemap_w)
-	AM_RANGE(0x2000, 0x2fff) AM_DEVREADWRITE("gp9001vdp1", gp9001_top_tilemap_r, gp9001_top_tilemap_w)
-	AM_RANGE(0x3000, 0x37ff) AM_DEVREADWRITE("gp9001vdp1", gp9001_spram_r, gp9001_spram_w)
+	AM_RANGE(0x0000, 0x0fff) AM_DEVREADWRITE(DEVICE_SELF, gp9001_bg_tilemap_r, gp9001_bg_tilemap_w)
+	AM_RANGE(0x1000, 0x1fff) AM_DEVREADWRITE(DEVICE_SELF, gp9001_fg_tilemap_r, gp9001_fg_tilemap_w)
+	AM_RANGE(0x2000, 0x2fff) AM_DEVREADWRITE(DEVICE_SELF, gp9001_top_tilemap_r, gp9001_top_tilemap_w)
+	AM_RANGE(0x3000, 0x37ff) AM_DEVREADWRITE(DEVICE_SELF, gp9001_spram_r, gp9001_spram_w)
 	AM_RANGE(0x3800, 0x3fff) AM_RAM // sprite mirror?
 ADDRESS_MAP_END
 
@@ -225,9 +205,10 @@
 	return auto_alloc(&machine, gp9001vdp_device(machine, *this));
 }
 
-void gp9001vdp_device_config::device_config_complete()
+void gp9001vdp_device_config::static_set_gfx_region(device_config *device, int gfxregion)
 {
-	m_gfxregion = m_inline_data[0];
+	gp9001vdp_device_config *vdp = downcast<gp9001vdp_device_config *>(device);
+	vdp->m_gfxregion = gfxregion;
 }
 
 bool gp9001vdp_device_config::device_validity_check(const game_driver &driver) const
@@ -266,13 +247,6 @@
 	{
 		tile_number = ( vdp->gp9001_gfxrom_bank[(tile_number >> 13) & 7] << 13 ) | ( tile_number & 0x1fff );
 	}
-	else
-	{
-		if (tile_number>vdp->tile_limit)
-		{
-			tile_number = 0;
-		}
-	}
 
 	color = attrib & 0x0fff; // 0x0f00 priority, 0x007f colour
 	SET_TILE_INFO_DEVICE(
@@ -300,11 +274,6 @@
 	{
 		tile_number = ( vdp->gp9001_gfxrom_bank[(tile_number >> 13) & 7] << 13 ) | ( tile_number & 0x1fff );
 	}
-	else
-	{
-		if (tile_number>vdp->tile_limit) tile_number = 0;
-	}
-
 
 	color = attrib & 0x0fff; // 0x0f00 priority, 0x007f colour
 	SET_TILE_INFO_DEVICE(
@@ -328,10 +297,6 @@
 	{
 		tile_number = ( vdp->gp9001_gfxrom_bank[(tile_number >> 13) & 7] << 13 ) | ( tile_number & 0x1fff );
 	}
-	else
-	{
-		if (tile_number>vdp->tile_limit) tile_number = 0;
-	}
 
 	color = attrib & 0x0fff; // 0x0f00 priority, 0x007f colour
 	SET_TILE_INFO_DEVICE(
@@ -342,17 +307,17 @@
 	//tileinfo->category = (attrib & 0x0f00) >> 8;
 }
 
-static void create_tilemaps(gp9001vdp_device* vdp, int region)
+void gp9001vdp_device::create_tilemaps(int region)
 {
-	vdp->tile_region = region;
+	tile_region = region;
 
-	vdp->top_tilemap = tilemap_create_device(vdp, get_top0_tile_info,tilemap_scan_rows,16,16,32,32);
-	vdp->fg_tilemap = tilemap_create_device(vdp, get_fg0_tile_info,tilemap_scan_rows,16,16,32,32);
-	vdp->bg_tilemap = tilemap_create_device(vdp, get_bg0_tile_info,tilemap_scan_rows,16,16,32,32);
+	top_tilemap = tilemap_create_device(this, get_top0_tile_info,tilemap_scan_rows,16,16,32,32);
+	fg_tilemap = tilemap_create_device(this, get_fg0_tile_info,tilemap_scan_rows,16,16,32,32);
+	bg_tilemap = tilemap_create_device(this, get_bg0_tile_info,tilemap_scan_rows,16,16,32,32);
 
-	tilemap_set_transparent_pen(vdp->top_tilemap,0);
-	tilemap_set_transparent_pen(vdp->fg_tilemap,0);
-	tilemap_set_transparent_pen(vdp->bg_tilemap,0);
+	tilemap_set_transparent_pen(top_tilemap,0);
+	tilemap_set_transparent_pen(fg_tilemap,0);
+	tilemap_set_transparent_pen(bg_tilemap,0);
 }
 
 
@@ -367,7 +332,7 @@
 
 	spriteram16_n = spriteram16_now;
 
-	create_tilemaps(this, m_gfxregion);
+	create_tilemaps(m_gfxregion);
 
 	state_save_register_device_item_pointer(this, 0, spriteram16_new, GP9001_SPRITERAM_SIZE/2);
 	state_save_register_device_item_pointer(this, 0, spriteram16_now, GP9001_SPRITERAM_SIZE/2);
@@ -419,8 +384,6 @@
 	top_flip = 0;
 	sprite_flip = 0;
 
-	tile_limit = 0xffff;
-
 	/* debug */
 	display_bg = 1;
 	display_fg = 1;
@@ -438,7 +401,7 @@
 {
 	int offs = vdp->gp9001_voffs;
 	vdp->gp9001_voffs++;
-	return memory_read_word_16be(vdp->space(), offs*2);
+	return vdp->space()->read_word(offs*2);
 }
 
 
@@ -446,7 +409,7 @@
 {
 	int offs = vdp->gp9001_voffs;
 	vdp->gp9001_voffs++;
-	memory_write_word_masked_16be(vdp->space(), offs*2, data, mem_mask);
+	vdp->space()->write_word(offs*2, data, mem_mask);
 }
 
 WRITE16_DEVICE_HANDLER( gp9001_devvoffs_w )
@@ -475,8 +438,10 @@
 	return ((device->machine->primary_screen->vpos() + 15) % 262) >= 245;
 }
 
-static void t2_scroll_reg_select_w(gp9001vdp_device *vdp, offs_t offset, UINT16 data, UINT16 mem_mask)
+WRITE16_DEVICE_HANDLER( gp9001_scroll_reg_select_w )
 {
+	gp9001vdp_device *vdp = (gp9001vdp_device *)device;
+
 	if (ACCESSING_BITS_0_7)
 	{
 		vdp->gp9001_scroll_reg = data & 0x8f;
@@ -489,12 +454,6 @@
 	}
 }
 
-WRITE16_DEVICE_HANDLER( gp9001_scroll_reg_select_w )
-{
-	gp9001vdp_device *vdp = (gp9001vdp_device *)device;
-	t2_scroll_reg_select_w(vdp, offset, data, mem_mask);
-}
-
 static void gp9001_scroll_reg_data_w(gp9001vdp_device *vdp, offs_t offset, UINT16 data, UINT16 mem_mask)
 {
 
@@ -1032,10 +991,10 @@
 
 	if ( input_code_pressed_once(machine, KEYCODE_E) )
 	{
-		gp9001_displog += 1;
-		gp9001_displog &= 1;
+		*vdp->displog += 1;
+		*vdp->displog &= 1;
 	}
-	if (gp9001_displog)
+	if (*vdp->displog)
 	{
 		logerror("Scrolls   BG-X  BG-Y   FG-X  FG-Y   TOP-X  TOP-Y   Sprite-X  Sprite-Y\n");
 
@@ -1213,7 +1172,7 @@
 								{
 									UINT8 pix = srcdata[count];
 									UINT16* dstptr = BITMAP_ADDR16(bitmap,drawyy,drawxx);
-									UINT8* dstpri = BITMAP_ADDR8(gp9001_custom_priority_bitmap, drawyy, drawxx);
+									UINT8* dstpri = BITMAP_ADDR8(this->custom_priority_bitmap, drawyy, drawxx);
 
 									if (priority >= dstpri[0])
 									{
@@ -1265,7 +1224,7 @@
 
 		srcptr = BITMAP_ADDR16(tmb, realy, 0);
 		dstptr = BITMAP_ADDR16(bitmap, y, 0);
-		dstpriptr = BITMAP_ADDR8(gp9001_custom_priority_bitmap, y, 0);
+		dstpriptr = BITMAP_ADDR8(this->custom_priority_bitmap, y, 0);
 
 		for (x=0;x<width;x++)
 		{
@@ -1294,7 +1253,7 @@
 
 
 static const UINT8 gp9001_primap1[16] =  { 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c };
-//UINT8 gp9001_sprprimap1[16] =  { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
+//static const UINT8 gp9001_sprprimap1[16] =  { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
 static const UINT8 gp9001_sprprimap1[16] =  { 0x00, 0x04, 0x08, 0x0c, 0x10, 0x14, 0x18, 0x1c, 0x20, 0x24, 0x28, 0x2c, 0x30, 0x34, 0x38, 0x3c };
 
 static const UINT8 batsugun_prienable0[16]={ 1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1 };
diff -Nru src-old/mame/video/gp9001.h src/mame/video/gp9001.h
--- src-old/mame/video/gp9001.h	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/video/gp9001.h	2010-08-26 08:21:19.000000000 -0700
@@ -1,7 +1,5 @@
 /* GP9001 Video Controller */
 
-extern bitmap_t* gp9001_custom_priority_bitmap;
-
 class gp9001vdp_device_config : public device_config,
 								 public device_config_memory_interface
 {
@@ -10,13 +8,12 @@
 public:
 	static device_config *static_alloc_device_config(const machine_config &mconfig, const char *tag, const device_config *owner, UINT32 clock);
 	virtual device_t *alloc_device(running_machine &machine) const;
+	static void static_set_gfx_region(device_config *device, int gfxregion);
 protected:
-	virtual void device_config_complete();
 	virtual bool device_validity_check(const game_driver &driver) const;
 	virtual const address_space_config *memory_space_config(int spacenum = 0) const;
 	address_space_config		m_space_config;
 	UINT8						m_gfxregion;
-
 };
 
 class gp9001vdp_device : public device_t,
@@ -49,7 +46,6 @@
 	UINT8 top_flip;
 	UINT8 sprite_flip;
 
-	UINT16 tile_limit; // prevent bad tile in Batsugun, might be something like the CPS1 tile addressing limits?
 	int	   tile_region; // we also use this to figure out which vdp we're using in some debug logging features
 	tilemap_t *top_tilemap, *fg_tilemap, *bg_tilemap;
 
@@ -71,11 +67,15 @@
 	void gp9001_draw_custom_tilemap(running_machine* machine, bitmap_t* bitmap, tilemap_t* tilemap, const UINT8* priremap, const UINT8* pri_enable );
 	void gp9001_render_vdp(running_machine* machine, bitmap_t* bitmap, const rectangle* cliprect);
 	void gp9001_video_eof(void);
+	void create_tilemaps(int region);
 
 	// offset kludges, needed by fixeight bootleg
 	int extra_xoffset[4];
 	int extra_yoffset[4];
 
+	bitmap_t *custom_priority_bitmap;
+	int *displog;
+
 protected:
 	virtual void device_start();
 	virtual void device_reset();
@@ -96,18 +96,17 @@
 
 ADDRESS_MAP_EXTERN( gp9001vdp0_map, 16 );
 ADDRESS_MAP_EXTERN( gp9001vdp1_map, 16 );
-extern int gp9001_displog;
 
 
 /* vdp map 0, gfx region 0 */
 #define MDRV_DEVICE_ADD_VDP0 \
 	MDRV_DEVICE_ADD("gp9001vdp0", gp9001vdp_, 0) \
-	MDRV_DEVICE_ADDRESS_MAP(0, gp9001vdp0_map) MDRV_DEVICE_INLINE_DATA16(0, 0) \
+	gp9001vdp_device_config::static_set_gfx_region(device, 0); \
 
 /* vdp map 1, gfx region 2 */
 #define MDRV_DEVICE_ADD_VDP1 \
 	MDRV_DEVICE_ADD("gp9001vdp1", gp9001vdp_, 0) \
-	MDRV_DEVICE_ADDRESS_MAP(0, gp9001vdp1_map) MDRV_DEVICE_INLINE_DATA16(0, 2) \
+	gp9001vdp_device_config::static_set_gfx_region(device, 2); \
 
 
 // access to VDP
diff -Nru src-old/mame/video/gtia.c src/mame/video/gtia.c
--- src-old/mame/video/gtia.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/video/gtia.c	2010-08-19 00:26:14.000000000 -0700
@@ -154,7 +154,7 @@
 static void gtia_reset(running_machine &machine)
 {
 	int i;
-	const address_space *space = cputag_get_address_space(&machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(&machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* reset the GTIA read/write/helper registers */
 	for (i = 0; i < 32; i++)
diff -Nru src-old/mame/video/gtia.h src/mame/video/gtia.h
--- src-old/mame/video/gtia.h	2008-12-19 12:40:22.000000000 -0800
+++ src/mame/video/gtia.h	2010-08-19 00:26:14.000000000 -0700
@@ -16,8 +16,8 @@
 typedef struct _gtia_interface gtia_interface;
 struct _gtia_interface
 {
-	UINT8 (*console_read)(const address_space *space);
-	void (*console_write)(const address_space *space, UINT8 data);
+	UINT8 (*console_read)(address_space *space);
+	void (*console_write)(address_space *space, UINT8 data);
 };
 
 
diff -Nru src-old/mame/video/harddriv.c src/mame/video/harddriv.c
--- src-old/mame/video/harddriv.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/harddriv.c	2010-08-19 00:26:14.000000000 -0700
@@ -96,7 +96,7 @@
  *
  *************************************/
 
-void hdgsp_write_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void hdgsp_write_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	harddriv_state *state = space->machine->driver_data<harddriv_state>();
 
@@ -124,7 +124,7 @@
 }
 
 
-void hdgsp_read_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void hdgsp_read_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	harddriv_state *state = space->machine->driver_data<harddriv_state>();
 
diff -Nru src-old/mame/video/hng64.c src/mame/video/hng64.c
--- src-old/mame/video/hng64.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/video/hng64.c	2010-08-26 20:55:49.000000000 -0700
@@ -1,96 +1,66 @@
 #include "emu.h"
-#include "includes/hng64.h"
-
 #include "drawgfxm.h"
+#include "includes/hng64.h"
 
 #define MAKE_MAME_REEEEAAALLLL_SLOW 0
 
-static UINT8 additive_tilemap_debug;
 
-UINT32* hng64_videoram;
-static tilemap_t *hng64_tilemap0_8x8;
-static tilemap_t *hng64_tilemap1_8x8;
-static tilemap_t *hng64_tilemap2_8x8;
-static tilemap_t *hng64_tilemap3_8x8;
-
-static tilemap_t *hng64_tilemap0_16x16;
-static tilemap_t *hng64_tilemap1_16x16;
-static tilemap_t *hng64_tilemap2_16x16;
-static tilemap_t *hng64_tilemap3_16x16;
-
-static tilemap_t *hng64_tilemap0_16x16_alt;
-static tilemap_t *hng64_tilemap1_16x16_alt;
-static tilemap_t *hng64_tilemap2_16x16_alt;
-static tilemap_t *hng64_tilemap3_16x16_alt;
-
-UINT32 *hng64_spriteram;
-UINT32 *hng64_videoregs;
-UINT32 *hng64_spriteregs;
-UINT32 *hng64_3dregs;
-UINT32 *hng64_tcram;
-
-UINT8 hng64_screen_dis;
-
-// 3d display buffers
-// (Temporarily global - someday they will live with the proper bit-depth in the memory map)
-static float* depthBuffer3d;
-static UINT32* colorBuffer3d;
 static void clear3d(running_machine *machine);	// TODO: Inline
 
 
-static void hng64_mark_all_tiles_dirty( int tilemap )
+static void hng64_mark_all_tiles_dirty( hng64_state *state, int tilemap )
 {
 	if (tilemap == 0)
 	{
-		tilemap_mark_all_tiles_dirty (hng64_tilemap0_8x8);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap0_16x16);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap0_16x16_alt);
+		tilemap_mark_all_tiles_dirty (state->tilemap0_8x8);
+		tilemap_mark_all_tiles_dirty (state->tilemap0_16x16);
+		tilemap_mark_all_tiles_dirty (state->tilemap0_16x16_alt);
 	}
 	else if (tilemap == 1)
 	{
-		tilemap_mark_all_tiles_dirty (hng64_tilemap1_8x8);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap1_16x16);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap1_16x16_alt);
+		tilemap_mark_all_tiles_dirty (state->tilemap1_8x8);
+		tilemap_mark_all_tiles_dirty (state->tilemap1_16x16);
+		tilemap_mark_all_tiles_dirty (state->tilemap1_16x16_alt);
 	}
 	else if (tilemap == 2)
 	{
-		tilemap_mark_all_tiles_dirty (hng64_tilemap2_8x8);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap2_16x16);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap2_16x16_alt);
+		tilemap_mark_all_tiles_dirty (state->tilemap2_8x8);
+		tilemap_mark_all_tiles_dirty (state->tilemap2_16x16);
+		tilemap_mark_all_tiles_dirty (state->tilemap2_16x16_alt);
 	}
 	else if (tilemap == 3)
 	{
-		tilemap_mark_all_tiles_dirty (hng64_tilemap3_8x8);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap3_16x16);
-		tilemap_mark_all_tiles_dirty (hng64_tilemap3_16x16_alt);
+		tilemap_mark_all_tiles_dirty (state->tilemap3_8x8);
+		tilemap_mark_all_tiles_dirty (state->tilemap3_16x16);
+		tilemap_mark_all_tiles_dirty (state->tilemap3_16x16_alt);
 	}
 }
 
-static void hng64_mark_tile_dirty( int tilemap, int tile_index )
+static void hng64_mark_tile_dirty( hng64_state *state, int tilemap, int tile_index )
 {
 	if (tilemap == 0)
 	{
-		tilemap_mark_tile_dirty(hng64_tilemap0_8x8,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap0_16x16,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap0_16x16_alt,tile_index);
+		tilemap_mark_tile_dirty(state->tilemap0_8x8, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap0_16x16, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap0_16x16_alt, tile_index);
 	}
 	else if (tilemap == 1)
 	{
-		tilemap_mark_tile_dirty(hng64_tilemap1_8x8,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap1_16x16,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap1_16x16_alt,tile_index);
+		tilemap_mark_tile_dirty(state->tilemap1_8x8, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap1_16x16, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap1_16x16_alt, tile_index);
 	}
 	else if (tilemap == 2)
 	{
-		tilemap_mark_tile_dirty(hng64_tilemap2_8x8,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap2_16x16,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap2_16x16_alt,tile_index);
+		tilemap_mark_tile_dirty(state->tilemap2_8x8, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap2_16x16, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap2_16x16_alt, tile_index);
 	}
 	else if (tilemap == 3)
 	{
-		tilemap_mark_tile_dirty(hng64_tilemap3_8x8,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap3_16x16,tile_index);
-		tilemap_mark_tile_dirty(hng64_tilemap3_16x16_alt,tile_index);
+		tilemap_mark_tile_dirty(state->tilemap3_8x8, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap3_16x16, tile_index);
+		tilemap_mark_tile_dirty(state->tilemap3_16x16_alt, tile_index);
 	}
 }
 
@@ -239,18 +209,20 @@
 
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
 	const gfx_element *gfx;
-	UINT32 *source = hng64_spriteram;
-	UINT32 *finish = hng64_spriteram + 0xc000/4;
+	UINT32 *source = state->spriteram;
+	UINT32 *finish = state->spriteram + 0xc000/4;
 
 	// global offsets in sprite regs
-	int	spriteoffsx = (hng64_spriteregs[1]>>0)&0xffff;
-	int spriteoffsy = (hng64_spriteregs[1]>>16)&0xffff;
-
-//  for (int iii = 0; iii < 0x0f; iii++)
-//      mame_printf_debug("%.8x ", hng64_videoregs[iii]);
+	int spriteoffsx = (state->spriteregs[1]>>0)&0xffff;
+	int spriteoffsy = (state->spriteregs[1]>>16)&0xffff;
 
-//  mame_printf_debug("\n");
+#if 0
+	for (int iii = 0; iii < 0x0f; iii++)
+		mame_printf_debug("%.8x ", state->videoregs[iii]);
+	mame_printf_debug("\n");
+#endif
 
 	while( source<finish )
 	{
@@ -301,17 +273,18 @@
 			continue;
 		}
 
-
-//      if (!(source[4] == 0x00000000 || source[4] == 0x000000aa))
-//          mame_printf_debug("unknown : %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x \n", source[0], source[1], source[2], source[3],
-//                                                                         source[4], source[5], source[6], source[7]);
+#if 0
+		if (!(source[4] == 0x00000000 || source[4] == 0x000000aa))
+			mame_printf_debug("unknown : %.8x %.8x %.8x %.8x %.8x %.8x %.8x %.8x \n", source[0], source[1], source[2], source[3],
+				source[4], source[5], source[6], source[7]);
+#endif
 
 		/* Calculate the zoom */
 		{
 			int zoom_factor;
 
 			/* FIXME: regular zoom mode has precision bugs, can be easily seen in Samurai Shodown 64 intro */
-			zoom_factor = (hng64_spriteregs[0] & 0x08000000) ? 0x1000 : 0x100;
+			zoom_factor = (state->spriteregs[0] & 0x08000000) ? 0x1000 : 0x100;
 			if(!zoomx) zoomx=zoom_factor;
 			if(!zoomy) zoomy=zoom_factor;
 
@@ -326,7 +299,7 @@
 			zoomy += (int)((foomY - floor(foomY)) * (float)0x10000);
 		}
 
-		if (hng64_spriteregs[0] & 0x00800000) //bpp switch
+		if (state->spriteregs[0] & 0x00800000) //bpp switch
 		{
 			gfx= machine->gfx[4];
 		}
@@ -358,12 +331,13 @@
 			yinc=(int)(16.0f*foomY);
 		}
 
-
-//      if (((source[2] & 0xffff0000) >> 16) == 0x0001)
-//      {
-//          popmessage("T %.8x %.8x %.8x %.8x %.8x", source[0], source[1], source[2], source[3], source[4]);
-//          // popmessage("T %.8x %.8x %.8x %.8x %.8x", source[0], source[1], source[2], source[3], source[4]);
-//      }
+#if 0
+		if (((source[2] & 0xffff0000) >> 16) == 0x0001)
+		{
+			popmessage("T %.8x %.8x %.8x %.8x %.8x", source[0], source[1], source[2], source[3], source[4]);
+			//popmessage("T %.8x %.8x %.8x %.8x %.8x", source[0], source[1], source[2], source[3], source[4]);
+		}
+#endif
 
 		for(ydrw=0;ydrw<=chainy;ydrw++)
 		{
@@ -391,7 +365,7 @@
 					tileno=(source[4]&0x0007ffff);
 					pal =(source[3]&0x00ff0000)>>16;
 
-					if (hng64_spriteregs[0] & 0x00800000) //bpp switch
+					if (state->spriteregs[0] & 0x00800000) //bpp switch
 					{
 						gfx= machine->gfx[4];
 					}
@@ -457,8 +431,10 @@
  */
 
 /* this is broken for the 'How to Play' screen in Buriki after attract, disabled for now */
-static void transition_control(bitmap_t *bitmap, const rectangle *cliprect)
+static void transition_control(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+	UINT32 *hng64_tcram = state->tcram;
 	int i, j;
 
 //  float colorScaleR, colorScaleG, colorScaleB;
@@ -489,32 +465,32 @@
 				finG = (INT32)RGB_GREEN(*thePixel);
 				finB = (INT32)RGB_BLUE(*thePixel);
 
-				/*
-                // Apply the darkening pass (0x07)...
-                colorScaleR = 1.0f - (float)( hng64_tcram[0x00000007] & 0xff)        / 255.0f;
-                colorScaleG = 1.0f - (float)((hng64_tcram[0x00000007] >> 8)  & 0xff) / 255.0f;
-                colorScaleB = 1.0f - (float)((hng64_tcram[0x00000007] >> 16) & 0xff) / 255.0f;
-
-                finR = ((float)RGB_RED(*thePixel)   * colorScaleR);
-                finG = ((float)RGB_GREEN(*thePixel) * colorScaleG);
-                finB = ((float)RGB_BLUE(*thePixel)  * colorScaleB);
-
-
-                // Apply the lightening pass (0x0a)...
-                colorScaleR = 1.0f + (float)( hng64_tcram[0x0000000a] & 0xff)        / 255.0f;
-                colorScaleG = 1.0f + (float)((hng64_tcram[0x0000000a] >> 8)  & 0xff) / 255.0f;
-                colorScaleB = 1.0f + (float)((hng64_tcram[0x0000000a] >> 16) & 0xff) / 255.0f;
-
-                finR *= colorScaleR;
-                finG *= colorScaleG;
-                finB *= colorScaleB;
-
-
-                // Clamp
-                if (finR > 255.0f) finR = 255.0f;
-                if (finG > 255.0f) finG = 255.0f;
-                if (finB > 255.0f) finB = 255.0f;
-                */
+#if 0
+				// Apply the darkening pass (0x07)...
+				colorScaleR = 1.0f - (float)( hng64_tcram[0x00000007] & 0xff)        / 255.0f;
+				colorScaleG = 1.0f - (float)((hng64_tcram[0x00000007] >> 8)  & 0xff) / 255.0f;
+				colorScaleB = 1.0f - (float)((hng64_tcram[0x00000007] >> 16) & 0xff) / 255.0f;
+
+				finR = ((float)RGB_RED(*thePixel)   * colorScaleR);
+				finG = ((float)RGB_GREEN(*thePixel) * colorScaleG);
+				finB = ((float)RGB_BLUE(*thePixel)  * colorScaleB);
+
+
+				// Apply the lightening pass (0x0a)...
+				colorScaleR = 1.0f + (float)( hng64_tcram[0x0000000a] & 0xff)        / 255.0f;
+				colorScaleG = 1.0f + (float)((hng64_tcram[0x0000000a] >> 8)  & 0xff) / 255.0f;
+				colorScaleB = 1.0f + (float)((hng64_tcram[0x0000000a] >> 16) & 0xff) / 255.0f;
+
+				finR *= colorScaleR;
+				finG *= colorScaleG;
+				finB *= colorScaleB;
+
+
+				// Clamp
+				if (finR > 255.0f) finR = 255.0f;
+				if (finG > 255.0f) finG = 255.0f;
+				if (finB > 255.0f) finB = 255.0f;
+#endif
 
 
 				// Subtractive fading
@@ -553,17 +529,18 @@
 // pppppppp ff--atttt tttttttt tttttttt
 #define HNG64_GET_TILE_INFO                                                    \
 {                                                                              \
-	UINT16 tilemapinfo = (hng64_videoregs[reg]>>shift)&0xffff;                 \
+	hng64_state *state = machine->driver_data<hng64_state>();                 \
+	UINT16 tilemapinfo = (state->videoregs[reg]>>shift)&0xffff;                 \
 	int tileno,pal, flip;                                                      \
                                                                                \
-	tileno = hng64_videoram[tile_index+(offset/4)];                            \
+	tileno = state->videoram[tile_index+(offset/4)];                            \
                                                                                \
 	pal = (tileno&0xff000000)>>24;                                             \
 	flip =(tileno&0x00c00000)>>22;                                             \
                                                                                \
 	if (tileno&0x200000)                                                       \
 	{                                                                          \
-		tileno = (tileno & hng64_videoregs[0x0b]) | hng64_videoregs[0x0c];     \
+		tileno = (tileno & state->videoregs[0x0b]) | state->videoregs[0x0c];     \
 	}                                                                          \
                                                                                \
 	tileno &= 0x1fffff;                                                        \
@@ -676,26 +653,28 @@
 
 WRITE32_HANDLER( hng64_videoram_w )
 {
+	hng64_state *state = space->machine->driver_data<hng64_state>();
 	int realoff;
-	COMBINE_DATA(&hng64_videoram[offset]);
+
+	COMBINE_DATA(&state->videoram[offset]);
 
 	realoff = offset*4;
 
 	if ((realoff>=0) && (realoff<0x10000))
 	{
-		hng64_mark_tile_dirty(0,offset&0x3fff);
+		hng64_mark_tile_dirty(state, 0, offset&0x3fff);
 	}
 	else if ((realoff>=0x10000) && (realoff<0x20000))
 	{
-		hng64_mark_tile_dirty(1,offset&0x3fff);
+		hng64_mark_tile_dirty(state, 1, offset&0x3fff);
 	}
 	else if ((realoff>=0x20000) && (realoff<0x30000))
 	{
-		hng64_mark_tile_dirty(2,offset&0x3fff);
+		hng64_mark_tile_dirty(state, 2, offset&0x3fff);
 	}
 	else if ((realoff>=0x30000) && (realoff<0x40000))
 	{
-		hng64_mark_tile_dirty(3,offset&0x3fff);
+		hng64_mark_tile_dirty(state, 3, offset&0x3fff);
 	}
 
 //  if ((realoff>=0x40000)) mame_printf_debug("offsw %08x %08x\n",realoff,data);
@@ -1004,7 +983,7 @@
 	//if (!tmap->enable)
 	//  return;
 
-profiler_mark_start(PROFILER_TILEMAP_DRAW_ROZ);
+g_profiler.start(PROFILER_TILEMAP_DRAW_ROZ);
 	/* configure the blit parameters */
 	hng64_configure_blit_parameters(&blit, tmap, dest, cliprect, flags, priority, priority_mask, drawformat);
 
@@ -1013,7 +992,7 @@
 
 	/* then do the roz copy */
 	hng64_tilemap_draw_roz_core(machine, tmap, &blit, startx, starty, incxx, incxy, incyx, incyy, wraparound);
-profiler_mark_end();
+g_profiler.stop();
 }
 
 
@@ -1028,6 +1007,9 @@
 
 static void hng64_drawtilemap(running_machine* machine, bitmap_t *bitmap, const rectangle *cliprect, int tm )
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+	UINT32 *hng64_videoregs = state->videoregs;
+	UINT32 *hng64_videoram = state->videoram;
 	tilemap_t* tilemap = 0;
 	UINT32 scrollbase = 0;
 	UINT32 tileregs = 0;
@@ -1038,7 +1020,7 @@
 
 	int global_dimensions = (global_tileregs&0x03000000)>>24;
 
-	if ( (additive_tilemap_debug&(1 << tm)))
+	if ( (state->additive_tilemap_debug&(1 << tm)))
 		debug_blend_enabled = 1;
 
 	if ((global_dimensions != 0) && (global_dimensions != 3))
@@ -1051,13 +1033,13 @@
 
 		if (global_dimensions==0)
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap0_16x16;
-			else tilemap = hng64_tilemap0_8x8;
+			if (tileregs&0x0200)	tilemap = state->tilemap0_16x16;
+			else tilemap = state->tilemap0_8x8;
 		}
 		else
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap0_16x16_alt;
-			else tilemap = hng64_tilemap0_8x8; // _alt
+			if (tileregs&0x0200)	tilemap = state->tilemap0_16x16_alt;
+			else tilemap = state->tilemap0_8x8; // _alt
 		}
 	}
 	else if (tm==1)
@@ -1067,13 +1049,13 @@
 
 		if (global_dimensions==0)
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap1_16x16;
-			else tilemap = hng64_tilemap1_8x8;
+			if (tileregs&0x0200)	tilemap = state->tilemap1_16x16;
+			else tilemap = state->tilemap1_8x8;
 		}
 		else
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap1_16x16_alt;
-			else tilemap = hng64_tilemap1_8x8; // _alt
+			if (tileregs&0x0200)	tilemap = state->tilemap1_16x16_alt;
+			else tilemap = state->tilemap1_8x8; // _alt
 		}
 	}
 	else if (tm==2)
@@ -1083,13 +1065,13 @@
 
 		if (global_dimensions==0)
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap2_16x16;
-			else tilemap = hng64_tilemap2_8x8;
+			if (tileregs&0x0200)	tilemap = state->tilemap2_16x16;
+			else tilemap = state->tilemap2_8x8;
 		}
 		else
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap2_16x16_alt;
-			else tilemap = hng64_tilemap2_8x8; // _alt
+			if (tileregs&0x0200)	tilemap = state->tilemap2_16x16_alt;
+			else tilemap = state->tilemap2_8x8; // _alt
 		}
 	}
 	else if (tm==3)
@@ -1099,13 +1081,13 @@
 
 		if (global_dimensions==0)
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap3_16x16;
-			else tilemap = hng64_tilemap3_8x8;
+			if (tileregs&0x0200)	tilemap = state->tilemap3_16x16;
+			else tilemap = state->tilemap3_8x8;
 		}
 		else
 		{
-			if (tileregs&0x0200)	tilemap = hng64_tilemap3_16x16_alt;
-			else tilemap = hng64_tilemap3_8x8; // _alt
+			if (tileregs&0x0200)	tilemap = state->tilemap3_16x16_alt;
+			else tilemap = state->tilemap3_8x8; // _alt
 		}
 	}
 
@@ -1462,17 +1444,14 @@
 
 
 
-static UINT32 old_animmask = -1;
-static UINT32 old_animbits = -1;
-static UINT16 old_tileflags0 = -1;
-static UINT16 old_tileflags1 = -1;
-static UINT16 old_tileflags2 = -1;
-static UINT16 old_tileflags3 = -1;
-
 #define IMPORTANT_DIRTY_TILEFLAG_MASK (0x0600)
 
 VIDEO_UPDATE( hng64 )
 {
+	hng64_state *state = screen->machine->driver_data<hng64_state>();
+	UINT32 *hng64_videoregs = state->videoregs;
+	UINT32 *hng64_videoram = state->videoram;
+	UINT32 *hng64_tcram = state->tcram;
 	UINT32 animmask;
 	UINT32 animbits;
 	UINT16 tileflags0, tileflags1;
@@ -1484,15 +1463,15 @@
 	// but it could be useful
 	if ( input_code_pressed_once(screen->machine, KEYCODE_L) )
 	{
-		const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-		memory_write_byte(space, 0x2f27c8, 0x2);
+		address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		space->write_byte(0x2f27c8, 0x2);
 	}
 #endif
 
 	bitmap_fill(bitmap, 0, hng64_tcram[0x50/4] & 0x10000 ? get_black_pen(screen->machine) : screen->machine->pens[0]); //FIXME: Is the register correct? check with HW tests
 	bitmap_fill(screen->machine->priority_bitmap, cliprect, 0x00);
 
-	if(hng64_screen_dis)
+	if (state->screen_dis)
 		return 0;
 
 	animmask = hng64_videoregs[0x0b];
@@ -1503,62 +1482,62 @@
 	tileflags3 = hng64_videoregs[0x03]&0xffff;
 
 	/* if the auto-animation mask or bits have changed search for tiles using them and mark as dirty */
-	if ((old_animmask != animmask) || (old_animbits != animbits))
+	if ((state->old_animmask != animmask) || (state->old_animbits != animbits))
 	{
 		int tile_index;
 		for (tile_index=0;tile_index<128*128;tile_index++)
 		{
 			if (hng64_videoram[tile_index+(0x00000/4)]&0x200000)
 			{
-				hng64_mark_tile_dirty(0,tile_index);
+				hng64_mark_tile_dirty(state, 0, tile_index);
 			}
 			if (hng64_videoram[tile_index+(0x10000/4)]&0x200000)
 			{
-				hng64_mark_tile_dirty(1,tile_index);
+				hng64_mark_tile_dirty(state, 1, tile_index);
 			}
 			if (hng64_videoram[tile_index+(0x20000/4)]&0x200000)
 			{
-				hng64_mark_tile_dirty(2,tile_index);
+				hng64_mark_tile_dirty(state, 2, tile_index);
 			}
 			if (hng64_videoram[tile_index+(0x30000/4)]&0x200000)
 			{
-				hng64_mark_tile_dirty(3,tile_index);
+				hng64_mark_tile_dirty(state, 3, tile_index);
 			}
 		}
 
-		old_animmask = animmask;
-		old_animbits = animbits;
+		state->old_animmask = animmask;
+		state->old_animbits = animbits;
 	}
 
-	if ((old_tileflags0&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags0&IMPORTANT_DIRTY_TILEFLAG_MASK))
+	if ((state->old_tileflags0&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags0&IMPORTANT_DIRTY_TILEFLAG_MASK))
 	{
-		hng64_mark_all_tiles_dirty (0);
-		old_tileflags0 = tileflags0;
+		hng64_mark_all_tiles_dirty(state, 0);
+		state->old_tileflags0 = tileflags0;
 	}
 
-	if ((old_tileflags1&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags1&IMPORTANT_DIRTY_TILEFLAG_MASK))
+	if ((state->old_tileflags1&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags1&IMPORTANT_DIRTY_TILEFLAG_MASK))
 	{
-		hng64_mark_all_tiles_dirty (1);
-		old_tileflags1 = tileflags1;
+		hng64_mark_all_tiles_dirty(state, 1);
+		state->old_tileflags1 = tileflags1;
 	}
 
-	if ((old_tileflags2&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags2&IMPORTANT_DIRTY_TILEFLAG_MASK))
+	if ((state->old_tileflags2&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags2&IMPORTANT_DIRTY_TILEFLAG_MASK))
 	{
-		hng64_mark_all_tiles_dirty (2);
-		old_tileflags2 = tileflags2;
+		hng64_mark_all_tiles_dirty(state, 2);
+		state->old_tileflags2 = tileflags2;
 	}
 
-	if ((old_tileflags3&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags3&IMPORTANT_DIRTY_TILEFLAG_MASK))
+	if ((state->old_tileflags3&IMPORTANT_DIRTY_TILEFLAG_MASK)!=(tileflags3&IMPORTANT_DIRTY_TILEFLAG_MASK))
 	{
-		hng64_mark_all_tiles_dirty (3);
-		old_tileflags3 = tileflags3;
+		hng64_mark_all_tiles_dirty(state, 3);
+		state->old_tileflags3 = tileflags3;
 	}
 
 	// mark all frames as dirty if for some reason we don't trust the above code
-	//hng64_mark_all_tiles_dirty (0);
-	//hng64_mark_all_tiles_dirty (1);
-	//hng64_mark_all_tiles_dirty (2);
-	//hng64_mark_all_tiles_dirty (3);
+	//hng64_mark_all_tiles_dirty(state, 0);
+	//hng64_mark_all_tiles_dirty(state, 1);
+	//hng64_mark_all_tiles_dirty(state, 2);
+	//hng64_mark_all_tiles_dirty(state, 3);
 
 	hng64_drawtilemap(screen->machine,bitmap,cliprect, 3);
 	hng64_drawtilemap(screen->machine,bitmap,cliprect, 2);
@@ -1574,7 +1553,7 @@
 		// Blit the color buffer into the primary bitmap
 		for (y = cliprect->min_y; y <= cliprect->max_y; y++)
 		{
-			UINT32 *src = &colorBuffer3d[y * (cliprect->max_x-cliprect->min_x)];
+			UINT32 *src = &state->colorBuffer3d[y * (cliprect->max_x-cliprect->min_x)];
 			UINT32 *dst = BITMAP_ADDR32(bitmap, y, cliprect->min_x);
 
 			for (x = cliprect->min_x; x <= cliprect->max_x; x++)
@@ -1591,10 +1570,10 @@
 	}
 
 	if(0)
-		transition_control(bitmap, cliprect);
+		transition_control(screen->machine, bitmap, cliprect);
 
 	if (0)
-		popmessage("%08x %08x %08x %08x %08x", hng64_spriteregs[0], hng64_spriteregs[1], hng64_spriteregs[2], hng64_spriteregs[3], hng64_spriteregs[4]);
+		popmessage("%08x %08x %08x %08x %08x", state->spriteregs[0], state->spriteregs[1], state->spriteregs[2], state->spriteregs[3], state->spriteregs[4]);
 
 	if (0)
 	popmessage("%08x %08x TR(%04x %04x %04x %04x) SB(%04x %04x %04x %04x) %08x %08x %08x %08x %08x AA(%08x %08x) %08x %08x",
@@ -1620,9 +1599,9 @@
 
 	if (0)
 	popmessage("3D: %08x %08x %08x %08x : %08x %08x %08x %08x : %08x %08x %08x %08x",
-		hng64_3dregs[0x00/4],hng64_3dregs[0x04/4],hng64_3dregs[0x08/4],hng64_3dregs[0x0c/4],
-		hng64_3dregs[0x10/4],hng64_3dregs[0x14/4],hng64_3dregs[0x18/4],hng64_3dregs[0x1c/4],
-		hng64_3dregs[0x20/4],hng64_3dregs[0x24/4],hng64_3dregs[0x28/4],hng64_3dregs[0x2c/4]);
+		state->_3dregs[0x00/4], state->_3dregs[0x04/4], state->_3dregs[0x08/4], state->_3dregs[0x0c/4],
+		state->_3dregs[0x10/4], state->_3dregs[0x14/4], state->_3dregs[0x18/4], state->_3dregs[0x1c/4],
+		state->_3dregs[0x20/4], state->_3dregs[0x24/4], state->_3dregs[0x28/4], state->_3dregs[0x2c/4]);
 
 	if (0)
 		popmessage("TC: %08x %08x %08x %08x : %08x %08x %08x %08x : %08x %08x %08x %08x : %08x %08x %08x %08x : %08x %08x %08x %08x : %08x %08x %08x %08x",
@@ -1653,23 +1632,23 @@
 
 	if ( input_code_pressed_once(screen->machine, KEYCODE_T) )
 	{
-		additive_tilemap_debug ^= 1;
-		popmessage("blend changed %02x", additive_tilemap_debug);
+		state->additive_tilemap_debug ^= 1;
+		popmessage("blend changed %02x", state->additive_tilemap_debug);
 	}
 	if ( input_code_pressed_once(screen->machine, KEYCODE_Y) )
 	{
-		additive_tilemap_debug ^= 2;
-		popmessage("blend changed %02x", additive_tilemap_debug);
+		state->additive_tilemap_debug ^= 2;
+		popmessage("blend changed %02x", state->additive_tilemap_debug);
 	}
 	if ( input_code_pressed_once(screen->machine, KEYCODE_U) )
 	{
-		additive_tilemap_debug ^= 4;
-		popmessage("blend changed %02x", additive_tilemap_debug);
+		state->additive_tilemap_debug ^= 4;
+		popmessage("blend changed %02x", state->additive_tilemap_debug);
 	}
 	if ( input_code_pressed_once(screen->machine, KEYCODE_I) )
 	{
-		additive_tilemap_debug ^= 8;
-		popmessage("blend changed %02x", additive_tilemap_debug);
+		state->additive_tilemap_debug ^= 8;
+		popmessage("blend changed %02x", state->additive_tilemap_debug);
 	}
 
 	return 0;
@@ -1677,63 +1656,60 @@
 
 VIDEO_START( hng64 )
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
 	const rectangle &visarea = machine->primary_screen->visible_area();
 
-	hng64_tilemap0_8x8       = tilemap_create(machine, get_hng64_tile0_8x8_info,   tilemap_scan_rows,  8,   8, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap0_16x16     = tilemap_create(machine, get_hng64_tile0_16x16_info, tilemap_scan_rows,  16, 16, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap0_16x16_alt = tilemap_create(machine, get_hng64_tile0_16x16_info, tilemap_scan_rows,  16, 16, 256,64); /* 128x128x4 = 0x10000 */
-
-	hng64_tilemap1_8x8       = tilemap_create(machine, get_hng64_tile1_8x8_info,   tilemap_scan_rows,  8,   8, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap1_16x16     = tilemap_create(machine, get_hng64_tile1_16x16_info, tilemap_scan_rows,  16, 16, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap1_16x16_alt = tilemap_create(machine, get_hng64_tile1_16x16_info, tilemap_scan_rows,  16, 16, 256,64); /* 128x128x4 = 0x10000 */
-
-	hng64_tilemap2_8x8       = tilemap_create(machine, get_hng64_tile2_8x8_info,   tilemap_scan_rows,  8,   8, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap2_16x16     = tilemap_create(machine, get_hng64_tile2_16x16_info, tilemap_scan_rows,  16, 16, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap2_16x16_alt = tilemap_create(machine, get_hng64_tile2_16x16_info, tilemap_scan_rows,  16, 16, 256,64); /* 128x128x4 = 0x10000 */
-
-	hng64_tilemap3_8x8       = tilemap_create(machine, get_hng64_tile3_8x8_info,   tilemap_scan_rows,  8,   8, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap3_16x16     = tilemap_create(machine, get_hng64_tile3_16x16_info, tilemap_scan_rows,  16, 16, 128,128); /* 128x128x4 = 0x10000 */
-	hng64_tilemap3_16x16_alt = tilemap_create(machine, get_hng64_tile3_16x16_info, tilemap_scan_rows,  16, 16, 256,64); /* 128x128x4 = 0x10000 */
-
-
-	tilemap_set_transparent_pen(hng64_tilemap0_8x8,0);
-	tilemap_set_transparent_pen(hng64_tilemap0_16x16,0);
-	tilemap_set_transparent_pen(hng64_tilemap0_16x16_alt,0);
-
-	tilemap_set_transparent_pen(hng64_tilemap1_8x8,0);
-	tilemap_set_transparent_pen(hng64_tilemap1_16x16,0);
-	tilemap_set_transparent_pen(hng64_tilemap1_16x16_alt,0);
-
-	tilemap_set_transparent_pen(hng64_tilemap2_8x8,0);
-	tilemap_set_transparent_pen(hng64_tilemap2_16x16,0);
-	tilemap_set_transparent_pen(hng64_tilemap2_16x16_alt,0);
-
-	tilemap_set_transparent_pen(hng64_tilemap3_8x8,0);
-	tilemap_set_transparent_pen(hng64_tilemap3_16x16,0);
-	tilemap_set_transparent_pen(hng64_tilemap3_16x16_alt,0);
+	state->old_animmask = -1;
+	state->old_animbits = -1;
+	state->old_tileflags0 = -1;
+	state->old_tileflags1 = -1;
+	state->old_tileflags2 = -1;
+	state->old_tileflags3 = -1;
+
+	state->tilemap0_8x8       = tilemap_create(machine, get_hng64_tile0_8x8_info,   tilemap_scan_rows,  8,   8, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap0_16x16     = tilemap_create(machine, get_hng64_tile0_16x16_info, tilemap_scan_rows,  16, 16, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap0_16x16_alt = tilemap_create(machine, get_hng64_tile0_16x16_info, tilemap_scan_rows,  16, 16, 256,  64); /* 128x128x4 = 0x10000 */
+
+	state->tilemap1_8x8       = tilemap_create(machine, get_hng64_tile1_8x8_info,   tilemap_scan_rows,  8,   8, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap1_16x16     = tilemap_create(machine, get_hng64_tile1_16x16_info, tilemap_scan_rows,  16, 16, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap1_16x16_alt = tilemap_create(machine, get_hng64_tile1_16x16_info, tilemap_scan_rows,  16, 16, 256,  64); /* 128x128x4 = 0x10000 */
+
+	state->tilemap2_8x8       = tilemap_create(machine, get_hng64_tile2_8x8_info,   tilemap_scan_rows,  8,   8, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap2_16x16     = tilemap_create(machine, get_hng64_tile2_16x16_info, tilemap_scan_rows,  16, 16, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap2_16x16_alt = tilemap_create(machine, get_hng64_tile2_16x16_info, tilemap_scan_rows,  16, 16, 256,  64); /* 128x128x4 = 0x10000 */
+
+	state->tilemap3_8x8       = tilemap_create(machine, get_hng64_tile3_8x8_info,   tilemap_scan_rows,  8,   8, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap3_16x16     = tilemap_create(machine, get_hng64_tile3_16x16_info, tilemap_scan_rows,  16, 16, 128, 128); /* 128x128x4 = 0x10000 */
+	state->tilemap3_16x16_alt = tilemap_create(machine, get_hng64_tile3_16x16_info, tilemap_scan_rows,  16, 16, 256,  64); /* 128x128x4 = 0x10000 */
+
+	tilemap_set_transparent_pen(state->tilemap0_8x8, 0);
+	tilemap_set_transparent_pen(state->tilemap0_16x16, 0);
+	tilemap_set_transparent_pen(state->tilemap0_16x16_alt, 0);
+
+	tilemap_set_transparent_pen(state->tilemap1_8x8, 0);
+	tilemap_set_transparent_pen(state->tilemap1_16x16, 0);
+	tilemap_set_transparent_pen(state->tilemap1_16x16_alt, 0);
+
+	tilemap_set_transparent_pen(state->tilemap2_8x8, 0);
+	tilemap_set_transparent_pen(state->tilemap2_16x16, 0);
+	tilemap_set_transparent_pen(state->tilemap2_16x16_alt, 0);
+
+	tilemap_set_transparent_pen(state->tilemap3_8x8, 0);
+	tilemap_set_transparent_pen(state->tilemap3_16x16, 0);
+	tilemap_set_transparent_pen(state->tilemap3_16x16_alt, 0);
 
 	// Debug switch, turn on / off additive blending on a per-tilemap basis
-	additive_tilemap_debug = 0;
+	state->additive_tilemap_debug = 0;
 
 	// 3d Buffer Allocation
-	depthBuffer3d = auto_alloc_array(machine, float,  (visarea.max_x)*(visarea.max_y));
-	colorBuffer3d = auto_alloc_array(machine, UINT32, (visarea.max_x)*(visarea.max_y));
+	state->depthBuffer3d = auto_alloc_array(machine, float,  (visarea.max_x)*(visarea.max_y));
+	state->colorBuffer3d = auto_alloc_array(machine, UINT32, (visarea.max_x)*(visarea.max_y));
 }
 
 
 ///////////////
 // 3d Engine //
 ///////////////
-static UINT32 hng64_dls[2][0x81];
-
-// 3d State
-static int paletteState3d = 0x00;
-static float projectionMatrix[16];
-static float modelViewMatrix[16];
-static float cameraMatrix[16];
-
-static float lightStrength;
-static float lightVector[3];
 
 struct polyVert
 {
@@ -1816,8 +1792,10 @@
 
 // Operation 0001
 // Camera transformation.
-static void setCameraTransformation(const UINT16* packet)
+static void setCameraTransformation(hng64_state *state, const UINT16* packet)
 {
+	float *cameraMatrix = state->cameraMatrix;
+
 	/*//////////////
     // PACKET FORMAT
     // [0]  - 0001 ... ID
@@ -1861,8 +1839,10 @@
 
 // Operation 0010
 // Lighting information
-static void setLighting(const UINT16* packet)
+static void setLighting(hng64_state *state, const UINT16* packet)
 {
+	float *lightVector = state->lightVector;
+
 	/*//////////////
     // PACKET FORMAT
     // [0]  - 0010 ... ID
@@ -1885,15 +1865,15 @@
 	if (packet[1] != 0x0000) printf("ZOMG!  packet[1] in setLighting function is non-zero!\n");
 	if (packet[2] != 0x0000) printf("ZOMG!  packet[2] in setLighting function is non-zero!\n");
 
-    lightVector[0] = uToF(packet[3]);
-    lightVector[1] = uToF(packet[4]);
-    lightVector[2] = uToF(packet[5]);
-    lightStrength = uToF(packet[9]);
+	lightVector[0] = uToF(packet[3]);
+	lightVector[1] = uToF(packet[4]);
+	lightVector[2] = uToF(packet[5]);
+	state->lightStrength = uToF(packet[9]);
 }
 
 // Operation 0011
 // Palette / Model flags?
-static void set3dFlags(const UINT16* packet)
+static void set3dFlags(hng64_state *state, const UINT16* packet)
 {
 	/*//////////////
     // PACKET FORMAT
@@ -1914,13 +1894,15 @@
     // [14] - ???? ... ? ''  ''
     // [15] - ???? ... ? ''  ''
     ////////////*/
-	paletteState3d = (packet[8] & 0xff00) >> 8;
+	state->paletteState3d = (packet[8] & 0xff00) >> 8;
 }
 
 // Operation 0012
 // Projection Matrix.
-static void setCameraProjectionMatrix(const UINT16* packet)
+static void setCameraProjectionMatrix(hng64_state *state, const UINT16* packet)
 {
+	float *projectionMatrix = state->projectionMatrix;
+
 	/*//////////////
     // PACKET FORMAT
     // [0]  - 0012 ... ID
@@ -2011,6 +1993,8 @@
     // [14] - xxxx ... Transformation matrix
     // [15] - xxxx ... Transformation matrix
     ////////////*/
+
+	hng64_state *state = machine->driver_data<hng64_state>();
 	UINT32 size[4];
 	UINT32 address[4];
 	UINT32 megaOffset;
@@ -2091,16 +2075,16 @@
 		return;
 	}
 
-/*
-    // Debug - ajg
-    printf("%08x : ", threeDOffset*3*2);
-    for (int k = 0; k < 7*3; k++)
-    {
-        printf("%04x ", threeDPointer[k]);
-        if ((k % 3) == 2) printf(" ");
-    }
-    printf("\n");
-*/
+#if 0
+	// Debug - ajg
+	printf("%08x : ", threeDOffset*3*2);
+	for (int k = 0; k < 7*3; k++)
+	{
+		printf("%04x ", threeDPointer[k]);
+		if ((k % 3) == 2) printf(" ");
+	}
+	printf("\n");
+#endif
 
 	// There are 4 hunks per address.
 	address[0] = threeDPointer[0];
@@ -2209,7 +2193,7 @@
 			/* FIXME: This isn't correct.
                       Buriki & Xrally need this line.  Roads Edge needs it removed.
                       So instead we're looking for a bit that is on for XRally & Buriki, but noone else. */
-			if (hng64_3dregs[0x00/4] & 0x2000)
+			if (state->_3dregs[0x00/4] & 0x2000)
 			{
 				if (strcmp(machine->basename(), "roadedge"))
 					polys[*numPolys].palOffset += 0x800;
@@ -2225,9 +2209,9 @@
 			// Apply the dynamic palette offset if its flag is set, otherwise stick with the fixed one
 			if ((packet[1] & 0x0100))
 			{
-				explicitPaletteValue1 = paletteState3d * 0x80;
+				explicitPaletteValue1 = state->paletteState3d * 0x80;
 				explicitPaletteValue2 = 0;      // This is probably hiding somewhere in operation 0011
-            }
+			}
 
 			polys[*numPolys].palOffset += (explicitPaletteValue1 + explicitPaletteValue2);
 
@@ -2387,15 +2371,17 @@
 
 				// TODO: I'm not reading 3 necessary words here (maybe face normal) !!!
 
-				/* DEBUG
-                printf("0x?6 : %08x (%d/%d)\n", address[k]*3*2, l, size[k]-1);
-                for (int m = 0; m < 13; m++)
-                    printf("%04x ", chunkOffset[m]);
-                printf("\n");
-                for (int m = 0; m < 13; m++)
-                    printf("%3.4f ", uToF(chunkOffset[m]));
-                printf("\n\n");
-                */
+#if 0
+				// DEBUG
+				printf("0x?6 : %08x (%d/%d)\n", address[k]*3*2, l, size[k]-1);
+				for (int m = 0; m < 13; m++)
+					printf("%04x ", chunkOffset[m]);
+				printf("\n");
+
+				for (int m = 0; m < 13; m++)
+					printf("%3.4f ", uToF(chunkOffset[m]));
+				printf("\n\n");
+#endif
 
 				chunkLength = 12;
 				break;
@@ -2417,31 +2403,31 @@
 			////////////////////////////////////
 			// Perform the world transformations...
 			// !! Can eliminate this step with a matrix stack (maybe necessary?) !!
-			setIdentity(modelViewMatrix);
-			if (hng64_mcu_type != SAMSHO_MCU)
+			setIdentity(state->modelViewMatrix);
+			if (state->mcu_type != SAMSHO_MCU)
 			{
 				// The sams64 games transform the geometry in front of a stationary camera.
 				// This is fine in sams64_2, since it never calls the 'camera transformation' function
 				// (thus using the identity matrix for this transform), but sams64 calls the
 				// camera transformation function with rotation values.
 				// It remains to be seen what those might do...
-				matmul4(modelViewMatrix, modelViewMatrix, cameraMatrix);
+				matmul4(state->modelViewMatrix, state->modelViewMatrix, state->cameraMatrix);
 			}
-			matmul4(modelViewMatrix, modelViewMatrix, objectMatrix);
+			matmul4(state->modelViewMatrix, state->modelViewMatrix, objectMatrix);
 
 			// LIGHTING
-			if (packet[1] & 0x0008 && lightStrength > 0.0f)
+			if (packet[1] & 0x0008 && state->lightStrength > 0.0f)
 			{
 				for (int v = 0; v < 3; v++)
 				{
 					float transformedNormal[4];
 					vecmatmul4(transformedNormal, objectMatrix, polys[*numPolys].vert[v].normal);
 					normalize(transformedNormal);
-					normalize(lightVector);
+					normalize(state->lightVector);
 
-					float intensity = vecDotProduct(transformedNormal, lightVector) * -1.0f;
+					float intensity = vecDotProduct(transformedNormal, state->lightVector) * -1.0f;
 					intensity = (intensity <= 0.0f) ? (0.0f) : (intensity);
-					intensity *= lightStrength * 128.0f;    // Turns 0x0100 into 1.0
+					intensity *= state->lightStrength * 128.0f;    // Turns 0x0100 into 1.0
 					intensity *= 128.0;                     // Maps intensity to the range [0.0, 2.0]
 					if (intensity >= 255.0f) intensity = 255.0f;
 
@@ -2464,27 +2450,27 @@
 
 			// BACKFACE CULL //
 			// EMPIRICAL EVIDENCE SEEMS TO SHOW THE HNG64 HARDWARE DOES NOT BACKFACE CULL //
-			/*
-            float cullRay[4];
-            float cullNorm[4];
-
-            // Cast a ray out of the camera towards the polygon's point in eyespace.
-            vecmatmul4(cullRay, modelViewMatrix, polys[*numPolys].vert[0].worldCoords);
-            normalize(cullRay);
-            // Dot product that with the normal to see if you're negative...
-            vecmatmul4(cullNorm, modelViewMatrix, polys[*numPolys].faceNormal);
-
-            float result = vecDotProduct(cullRay, cullNorm);
-
-            if (result < 0.0f)
-                polys[*numPolys].visible = 1;
-            else
-                polys[*numPolys].visible = 0;
-            */
+#if 0
+			float cullRay[4];
+			float cullNorm[4];
+
+			// Cast a ray out of the camera towards the polygon's point in eyespace.
+			vecmatmul4(cullRay, modelViewMatrix, polys[*numPolys].vert[0].worldCoords);
+			normalize(cullRay);
+			// Dot product that with the normal to see if you're negative...
+			vecmatmul4(cullNorm, modelViewMatrix, polys[*numPolys].faceNormal);
+
+			float result = vecDotProduct(cullRay, cullNorm);
+
+			if (result < 0.0f)
+				polys[*numPolys].visible = 1;
+			else
+				polys[*numPolys].visible = 0;
+#endif
 
 
 			// BEHIND-THE-CAMERA CULL //
-			vecmatmul4(cullRay, modelViewMatrix, polys[*numPolys].vert[0].worldCoords);
+			vecmatmul4(cullRay, state->modelViewMatrix, polys[*numPolys].vert[0].worldCoords);
 			if (cullRay[2] > 0.0f)				// Camera is pointing down -Z
 			{
 				polys[*numPolys].visible = 0;
@@ -2497,8 +2483,8 @@
 				for (int m = 0; m < polys[*numPolys].n; m++)
 				{
 					// Transform and project the vertex into pre-divided homogeneous coordinates...
-					vecmatmul4(eyeCoords, modelViewMatrix, polys[*numPolys].vert[m].worldCoords);
-					vecmatmul4(polys[*numPolys].vert[m].clipCoords, projectionMatrix, eyeCoords);
+					vecmatmul4(eyeCoords, state->modelViewMatrix, polys[*numPolys].vert[m].worldCoords);
+					vecmatmul4(polys[*numPolys].vert[m].clipCoords, state->projectionMatrix, eyeCoords);
 				}
 
 				if (polys[*numPolys].visible)
@@ -2540,6 +2526,8 @@
 
 void hng64_command3d(running_machine* machine, const UINT16* packet)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
+
 	/* A temporary place to put some polygons.  This will optimize away if the compiler's any good. */
 	int numPolys = 0;
 	struct polygon* polys = auto_alloc_array(machine, struct polygon, 1024*5);
@@ -2551,28 +2539,28 @@
 		break;
 
 	case 0x0001:	// Camera transformation.
-		setCameraTransformation(packet);
+		setCameraTransformation(state, packet);
 		break;
 
 	case 0x0010:	// Lighting information.
 		//if (packet[9]) printPacket(packet, 1);
-		setLighting(packet);
+		setLighting(state, packet);
 		break;
 
 	case 0x0011:	// Palette / Model flags?
 		//printPacket(packet, 1); printf("\n");
-		set3dFlags(packet);
+		set3dFlags(state, packet);
 		break;
 
 	case 0x0012:	// Projection Matrix
 		//printPacket(packet, 1);
-		setCameraProjectionMatrix(packet);
+		setCameraProjectionMatrix(state, packet);
 		break;
 
 	case 0x0100:
 	case 0x0101:	// Geometry with full transformations
 		// HACK.  Masks out a piece of geo bbust2's drawShaded() crashes on.
-		if (packet[2] == 0x0003 && packet[3] == 0x8f37 && hng64_mcu_type == SHOOT_MCU)
+		if (packet[2] == 0x0003 && packet[3] == 0x8f37 && state->mcu_type == SHOOT_MCU)
 			break;
 
 		recoverPolygonBlock(machine, packet, polys, &numPolys);
@@ -2633,6 +2621,7 @@
 
 static void clear3d(running_machine *machine)
 {
+	hng64_state *state = machine->driver_data<hng64_state>();
 	int i;
 
 	const rectangle &visarea = machine->primary_screen->visible_area();
@@ -2640,21 +2629,21 @@
 	// Clear each of the display list buffers after drawing - todo: kill!
 	for (i = 0; i < 0x81; i++)
 	{
-		hng64_dls[0][i] = 0;
-		hng64_dls[1][i] = 0;
+		state->dls[0][i] = 0;
+		state->dls[1][i] = 0;
 	}
 
 	// Reset the buffers...
 	for (i = 0; i < (visarea.max_x)*(visarea.max_y); i++)
 	{
-		depthBuffer3d[i] = 100.0f;
-		colorBuffer3d[i] = MAKE_ARGB(0,0,0,0);
+		state->depthBuffer3d[i] = 100.0f;
+		state->colorBuffer3d[i] = MAKE_ARGB(0, 0, 0, 0);
 	}
 
 	// Set some matrices to the identity...
-	setIdentity(projectionMatrix);
-	setIdentity(modelViewMatrix);
-	setIdentity(cameraMatrix);
+	setIdentity(state->projectionMatrix);
+	setIdentity(state->modelViewMatrix);
+	setIdentity(state->cameraMatrix);
 }
 
 /* 3D/framebuffer video registers
@@ -2678,9 +2667,9 @@
 /* 4x4 matrix multiplication */
 static void matmul4(float *product, const float *a, const float *b )
 {
-   int i;
-   for (i = 0; i < 4; i++)
-   {
+	int i;
+	for (i = 0; i < 4; i++)
+	{
 		const float ai0 = a[0  + i];
 		const float ai1 = a[4  + i];
 		const float ai2 = a[8  + i];
@@ -2690,7 +2679,7 @@
 		product[4  + i] = ai0 * b[4 ] + ai1 * b[5 ] + ai2 * b[6 ] + ai3 * b[7 ];
 		product[8  + i] = ai0 * b[8 ] + ai1 * b[9 ] + ai2 * b[10] + ai3 * b[11];
 		product[12 + i] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
-   }
+	}
 }
 
 /* vector by 4x4 matrix multiply */
@@ -2730,12 +2719,12 @@
 	retVal = (float)((INT16)input) / 32768.0f;
 	return retVal;
 
-/*
-    if ((INT16)input < 0)
-        retVal = (float)((INT16)input) / 32768.0f;
-    else
-        retVal = (float)((INT16)input) / 32767.0f;
-*/
+#if 0
+	if ((INT16)input < 0)
+		retVal = (float)((INT16)input) / 32768.0f;
+	else
+		retVal = (float)((INT16)input) / 32767.0f;
+#endif
 }
 
 static void normalize(float* x)
@@ -2985,14 +2974,14 @@
 	}
 
 	// SHOWS THE CLIPPING //
-	/*
-    for (int j = 1; j < p->n-1; j++)
-    {
-        drawline2d(p->vert[0].clipCoords[0],   p->vert[0].clipCoords[1],   p->vert[j].clipCoords[0],   p->vert[j].clipCoords[1],   255, bitmap);
-        drawline2d(p->vert[j].clipCoords[0],   p->vert[j].clipCoords[1],   p->vert[j+1].clipCoords[0], p->vert[j+1].clipCoords[1], 255, bitmap);
-        drawline2d(p->vert[j+1].clipCoords[0], p->vert[j+1].clipCoords[1], p->vert[0].clipCoords[0],   p->vert[0].clipCoords[1],   255, bitmap);
-    }
-    */
+#if 0
+	for (int j = 1; j < p->n-1; j++)
+	{
+		drawline2d(p->vert[0].clipCoords[0],   p->vert[0].clipCoords[1],   p->vert[j].clipCoords[0],   p->vert[j].clipCoords[1],   255, bitmap);
+		drawline2d(p->vert[j].clipCoords[0],   p->vert[j].clipCoords[1],   p->vert[j+1].clipCoords[0], p->vert[j+1].clipCoords[1], 255, bitmap);
+		drawline2d(p->vert[j+1].clipCoords[0], p->vert[j+1].clipCoords[1], p->vert[0].clipCoords[0],   p->vert[0].clipCoords[1],   255, bitmap);
+	}
+#endif
 }
 #endif
 
@@ -3028,8 +3017,9 @@
 										  float g_start, float g_delta, float b_start, float b_delta,
 										  float s_start, float s_delta, float t_start, float t_delta)
 {
-	float*  db = &(depthBuffer3d[(y * machine->primary_screen->visible_area().max_x) + x_start]);
-	UINT32* cb = &(colorBuffer3d[(y * machine->primary_screen->visible_area().max_x) + x_start]);
+	hng64_state *state = machine->driver_data<hng64_state>();
+	float*  db = &(state->depthBuffer3d[(y * machine->primary_screen->visible_area().max_x) + x_start]);
+	UINT32* cb = &(state->colorBuffer3d[(y * machine->primary_screen->visible_area().max_x) + x_start]);
 
 	UINT8 paletteEntry = 0;
 	float t_coord, s_coord;
diff -Nru src-old/mame/video/homedata.c src/mame/video/homedata.c
--- src-old/mame/video/homedata.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/homedata.c	2010-08-19 00:26:14.000000000 -0700
@@ -32,7 +32,7 @@
 
 ***************************************************************************/
 
-static void mrokumei_handleblit( const address_space *space, int rom_base )
+static void mrokumei_handleblit( address_space *space, int rom_base )
 {
 	homedata_state *state = space->machine->driver_data<homedata_state>();
 	int i;
@@ -119,7 +119,7 @@
 	cpu_set_input_line(state->maincpu, M6809_FIRQ_LINE, HOLD_LINE);
 }
 
-static void reikaids_handleblit( const address_space *space, int rom_base )
+static void reikaids_handleblit( address_space *space, int rom_base )
 {
 	homedata_state *state = space->machine->driver_data<homedata_state>();
 	int i;
@@ -217,7 +217,7 @@
 	cpu_set_input_line(state->maincpu, M6809_FIRQ_LINE, HOLD_LINE);
 }
 
-static void pteacher_handleblit( const address_space *space, int rom_base )
+static void pteacher_handleblit( address_space *space, int rom_base )
 {
 	homedata_state *state = space->machine->driver_data<homedata_state>();
 	int i;
diff -Nru src-old/mame/video/itech32.c src/mame/video/itech32.c
--- src-old/mame/video/itech32.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/itech32.c	2010-08-21 15:25:58.000000000 -0700
@@ -1202,7 +1202,7 @@
 	{
 		/* command 1: blit raw data */
 		case 1:
-			profiler_mark_start(PROFILER_USER1);
+			g_profiler.start(PROFILER_USER1);
 			if (BLIT_LOGGING) logblit(machine, "Blit Raw");
 
 			if (is_drivedge)
@@ -1215,18 +1215,18 @@
 				if (enable_latch[1]) draw_raw(videoplane[1], color_latch[1]);
 			}
 
-			profiler_mark_end();
+			g_profiler.stop();
 			break;
 
 		/* command 2: blit RLE-compressed data */
 		case 2:
-			profiler_mark_start(PROFILER_USER2);
+			g_profiler.start(PROFILER_USER2);
 			if (BLIT_LOGGING) logblit(machine, "Blit RLE");
 
 			if (enable_latch[0]) draw_rle(videoplane[0], color_latch[0]);
 			if (enable_latch[1]) draw_rle(videoplane[1], color_latch[1]);
 
-			profiler_mark_end();
+			g_profiler.stop();
 			break;
 
 		/* command 3: set up raw data transfer */
@@ -1248,7 +1248,7 @@
 
 		/* command 6: perform shift register copy */
 		case 6:
-			profiler_mark_start(PROFILER_USER3);
+			g_profiler.start(PROFILER_USER3);
 			if (BLIT_LOGGING) logblit(machine, "ShiftReg");
 
 			if (is_drivedge)
@@ -1261,7 +1261,7 @@
 				if (enable_latch[1]) shiftreg_clear(videoplane[1], NULL);
 			}
 
-			profiler_mark_end();
+			g_profiler.stop();
 			break;
 
 		default:
diff -Nru src-old/mame/video/itech8.c src/mame/video/itech8.c
--- src-old/mame/video/itech8.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/itech8.c	2010-08-19 00:26:14.000000000 -0700
@@ -216,7 +216,7 @@
 
 WRITE8_HANDLER( itech8_palette_w )
 {
-	tlc34076_w(space, offset/2, data);
+	tlc34076_w(space->machine->device("tlc34076"), offset/2, data);
 }
 
 
@@ -308,7 +308,7 @@
  *
  *************************************/
 
-static void perform_blit(const address_space *space)
+static void perform_blit(address_space *space)
 {
 	offs_t addr = tms_state.regs[TMS34061_XYADDRESS] | ((tms_state.regs[TMS34061_XYOFFSET] & 0x300) << 8);
 	UINT8 shift = (BLITTER_FLAGS & BLITFLAG_SHIFT) ? 4 : 0;
@@ -625,7 +625,7 @@
 {
 	UINT32 page_offset;
 	int x, y;
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen->machine->device("tlc34076"));
 
 	/* first get the current display state */
 	tms34061_get_display_state(&tms_state);
@@ -708,7 +708,7 @@
 {
 	UINT32 page_offset;
 	int x, y;
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen->machine->device("tlc34076"));
 
 	/* first get the current display state */
 	tms34061_get_display_state(&tms_state);
@@ -739,7 +739,7 @@
 {
 	UINT32 page_offset;
 	int x, y;
-	const rgb_t *pens = tlc34076_get_pens();
+	const rgb_t *pens = tlc34076_get_pens(screen->machine->device("tlc34076"));
 
 	/* first get the current display state */
 	tms34061_get_display_state(&tms_state);
diff -Nru src-old/mame/video/jaguar.c src/mame/video/jaguar.c
--- src-old/mame/video/jaguar.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/video/jaguar.c	2010-08-21 15:25:58.000000000 -0700
@@ -493,8 +493,8 @@
 
 static UINT8 *get_jaguar_memory(running_machine *machine, UINT32 offset)
 {
-	const address_space *space = cputag_get_address_space(machine, "gpu", ADDRESS_SPACE_PROGRAM);
-	return (UINT8 *)memory_get_read_ptr(space, offset);
+	address_space *space = cputag_get_address_space(machine, "gpu", ADDRESS_SPACE_PROGRAM);
+	return (UINT8 *)space->get_read_ptr(offset);
 }
 
 
@@ -511,7 +511,7 @@
 	UINT32 a1flags = blitter_regs[A1_FLAGS] & STATIC_FLAGS_MASK;
 	UINT32 a2flags = blitter_regs[A2_FLAGS] & STATIC_FLAGS_MASK;
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	if (a1flags == a2flags)
 	{
@@ -600,7 +600,7 @@
 }
 
 	generic_blitter(machine, blitter_regs[B_CMD], blitter_regs[A1_FLAGS], blitter_regs[A2_FLAGS]);
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 static TIMER_CALLBACK( blitter_done )
@@ -673,7 +673,12 @@
 	return gpu_regs[offset];
 }
 
-#if 0
+/*
+FIXME: this should be 1, but then MAME performance will be s*** with this (i.e. it drops the performance from 400% to 6% on an i5 machine).
+But the PIT irq is definitely needed by some games (for example Pitfall refuses to enter into gameplay without this enabled).
+*/
+#define PIT_MULT_DBG_HACK 64
+
 static TIMER_CALLBACK( jaguar_pit )
 {
 	attotime sample_period;
@@ -682,16 +687,16 @@
 
 	if (gpu_regs[PIT0])
 	{
-		sample_period = ATTOTIME_IN_NSEC(machine->device("gpu")->unscaled_clock() / (1+gpu_regs[PIT0]) / (1+gpu_regs[PIT1]));
-//      timer_set(machine, sample_period, NULL, 0, jaguar_pit);
+		sample_period = ATTOTIME_IN_NSEC(((machine->device("gpu")->unscaled_clock()*PIT_MULT_DBG_HACK) / (1+gpu_regs[PIT0])) / (1+gpu_regs[PIT1]));
+		timer_set(machine, sample_period, NULL, 0, jaguar_pit);
 	}
 }
-#endif
+
 
 WRITE16_HANDLER( jaguar_tom_regs_w )
 {
 	UINT32 reg_store = gpu_regs[offset];
-//  attotime sample_period;
+	attotime sample_period;
 	if (offset < GPU_REGS)
 	{
 		COMBINE_DATA(&gpu_regs[offset]);
@@ -705,18 +710,13 @@
 				break;
 			case PIT0:
 			case PIT1:
-				if(gpu_regs[PIT0] && reg_store != gpu_regs[offset])
-					printf("Warning: PIT irq used\n");
-				break;
-#if 0
-			case PIT1:
-				if (gpu_regs[PIT0])
+				if (gpu_regs[PIT0] && gpu_regs[PIT0] != 0xffff) //FIXME: avoid too much small timers for now
 				{
-					sample_period = ATTOTIME_IN_NSEC(space->machine->device("gpu")->unscaled_clock() / (1+gpu_regs[PIT0]) / (1+gpu_regs[PIT1]));
+					sample_period = ATTOTIME_IN_NSEC(((space->machine->device("gpu")->unscaled_clock()*PIT_MULT_DBG_HACK) / (1+gpu_regs[PIT0])) / (1+gpu_regs[PIT1]));
 					timer_set(space->machine, sample_period, NULL, 0, jaguar_pit);
 				}
 				break;
-#endif
+
 			case INT1:
 				cpu_irq_state &= ~(gpu_regs[INT1] >> 8);
 				update_cpu_irq(space->machine);
diff -Nru src-old/mame/video/jpmimpct.c src/mame/video/jpmimpct.c
--- src-old/mame/video/jpmimpct.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/jpmimpct.c	2010-08-19 00:26:14.000000000 -0700
@@ -98,12 +98,12 @@
  *
  *************************************/
 
-void jpmimpct_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void jpmimpct_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &jpmimpct_vram[TOWORD(address)], 512 * sizeof(UINT16));
 }
 
-void jpmimpct_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void jpmimpct_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&jpmimpct_vram[TOWORD(address)], shiftreg, 512 * sizeof(UINT16));
 }
diff -Nru src-old/mame/video/lastduel.c src/mame/video/lastduel.c
--- src-old/mame/video/lastduel.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/lastduel.c	2010-08-19 00:26:14.000000000 -0700
@@ -308,7 +308,7 @@
 
 VIDEO_EOF( lastduel )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Spriteram is always 1 frame ahead, suggesting buffering.  I can't find
         a register to control this so I assume it happens automatically
diff -Nru src-old/mame/video/leland.c src/mame/video/leland.c
--- src-old/mame/video/leland.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/leland.c	2010-08-19 00:26:14.000000000 -0700
@@ -169,7 +169,7 @@
  *
  *************************************/
 
-static int leland_vram_port_r(const address_space *space, int offset, int num)
+static int leland_vram_port_r(address_space *space, int offset, int num)
 {
 	struct vram_state_data *state = vram_state + num;
 	int addr = state->addr;
@@ -216,7 +216,7 @@
  *
  *************************************/
 
-static void leland_vram_port_w(const address_space *space, int offset, int data, int num)
+static void leland_vram_port_w(address_space *space, int offset, int data, int num)
 {
 	struct vram_state_data *state = vram_state + num;
 	int addr = state->addr;
@@ -306,7 +306,7 @@
 
 static TIMER_CALLBACK( leland_delayed_mvram_w )
 {
-	const address_space *space = cputag_get_address_space(machine, "master", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "master", ADDRESS_SPACE_PROGRAM);
 
 	int num = (param >> 16) & 1;
 	int offset = (param >> 8) & 0xff;
diff -Nru src-old/mame/video/lwings.c src/mame/video/lwings.c
--- src-old/mame/video/lwings.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/lwings.c	2010-08-19 00:26:14.000000000 -0700
@@ -293,7 +293,7 @@
 
 VIDEO_EOF( lwings )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/mainsnk.c src/mame/video/mainsnk.c
--- src-old/mame/video/mainsnk.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/mainsnk.c	2010-08-26 20:55:49.000000000 -0700
@@ -1,12 +1,5 @@
 #include "emu.h"
-
-static tilemap_t *tx_tilemap;
-static tilemap_t *bg_tilemap;
-UINT8 *mainsnk_fgram;
-UINT8 *mainsnk_bgram;
-
-
-static UINT32 bg_tile_offset;
+#include "includes/mainsnk.h"
 
 
 static TILEMAP_MAPPER( marvins_tx_scan_cols )
@@ -22,7 +15,9 @@
 
 static TILE_GET_INFO( get_tx_tile_info )
 {
-	int code = mainsnk_fgram[tile_index];
+	mainsnk_state *state = machine->driver_data<mainsnk_state>();
+	int code = state->fgram[tile_index];
+
 	SET_TILE_INFO(0,
 			code,
 			0,
@@ -31,11 +26,12 @@
 
 static TILE_GET_INFO( get_bg_tile_info )
 {
-	int code = (mainsnk_bgram[tile_index]);
+	mainsnk_state *state = machine->driver_data<mainsnk_state>();
+	int code = (state->bgram[tile_index]);
 
 	SET_TILE_INFO(
 			0,
-			bg_tile_offset + code,
+			state->bg_tile_offset + code,
 			0,
 			0);
 }
@@ -43,58 +39,67 @@
 
 VIDEO_START(mainsnk)
 {
-	tx_tilemap = tilemap_create(machine, get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
-	bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_cols,    8, 8, 32, 32);
+	mainsnk_state *state = machine->driver_data<mainsnk_state>();
 
-	tilemap_set_transparent_pen(tx_tilemap,15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	state->tx_tilemap = tilemap_create(machine, get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
+	state->bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_cols,    8, 8, 32, 32);
 
-	tilemap_set_scrolldx(bg_tilemap, 16, 16);
-	tilemap_set_scrolldy(bg_tilemap,  8,  8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
+
+	tilemap_set_scrolldx(state->bg_tilemap, 16, 16);
+	tilemap_set_scrolldy(state->bg_tilemap,  8,  8);
 }
 
 
 WRITE8_HANDLER(mainsnk_c600_w)
 {
+	mainsnk_state *state = space->machine->driver_data<mainsnk_state>();
 	int bank;
+	int total_elements = space->machine->gfx[0]->total_elements;
 
 	flip_screen_set(space->machine, ~data & 0x80);
 
-	tilemap_set_palette_offset(bg_tilemap, (data & 0x07) << 4);
-	tilemap_set_palette_offset(tx_tilemap, (data & 0x07) << 4);
+	tilemap_set_palette_offset(state->bg_tilemap, (data & 0x07) << 4);
+	tilemap_set_palette_offset(state->tx_tilemap, (data & 0x07) << 4);
 
 	bank = 0;
-	if (space->machine->gfx[0]->total_elements == 0x400)	// mainsnk
+	if (total_elements == 0x400)	// mainsnk
 		bank = ((data & 0x30) >> 4);
-	else if (space->machine->gfx[0]->total_elements == 0x800)	// canvas
+	else if (total_elements == 0x800)	// canvas
 		bank = ((data & 0x40) >> 6) | ((data & 0x30) >> 3);
 
-	if (bg_tile_offset != (bank << 8))
+	if (state->bg_tile_offset != (bank << 8))
 	{
-		bg_tile_offset = bank << 8;
-		tilemap_mark_all_tiles_dirty(bg_tilemap);
+		state->bg_tile_offset = bank << 8;
+		tilemap_mark_all_tiles_dirty(state->bg_tilemap);
 	}
 }
 
 WRITE8_HANDLER( mainsnk_fgram_w )
 {
-	mainsnk_fgram[offset] = data;
-	tilemap_mark_tile_dirty(tx_tilemap,offset);
+	mainsnk_state *state = space->machine->driver_data<mainsnk_state>();
+
+	state->fgram[offset] = data;
+	tilemap_mark_tile_dirty(state->tx_tilemap, offset);
 }
 
 WRITE8_HANDLER( mainsnk_bgram_w )
 {
-	mainsnk_bgram[offset] = data;
-	tilemap_mark_tile_dirty(bg_tilemap,offset);
+	mainsnk_state *state = space->machine->driver_data<mainsnk_state>();
+
+	state->bgram[offset] = data;
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset);
 }
 
 
 
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, int scrollx, int scrolly )
 {
+	mainsnk_state *state = machine->driver_data<mainsnk_state>();
 	const gfx_element *gfx = machine->gfx[1];
 	const UINT8 *source, *finish;
-	source =  machine->generic.spriteram.u8;
+	source =  state->spriteram;
 	finish =  source + 25*4;
 
 	while( source<finish )
@@ -134,9 +139,11 @@
 
 VIDEO_UPDATE(mainsnk)
 {
-	tilemap_draw(bitmap,cliprect,bg_tilemap,0,0);
-	draw_sprites(screen->machine,bitmap,cliprect, 0,0 );
-	tilemap_draw(bitmap,cliprect,tx_tilemap,0,0);
+	mainsnk_state *state = screen->machine->driver_data<mainsnk_state>();
+
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
+	draw_sprites(screen->machine, bitmap, cliprect, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 
 	return 0;
 }
diff -Nru src-old/mame/video/mcatadv.c src/mame/video/mcatadv.c
--- src-old/mame/video/mcatadv.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/mcatadv.c	2010-08-21 15:25:58.000000000 -0700
@@ -241,12 +241,12 @@
 				mcatadv_draw_tilemap_part(state->scroll2, state->videoram2, i, state->tilemap2, bitmap, cliprect);
 	}
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 #ifdef MAME_DEBUG
 	if (!input_code_pressed(screen->machine, KEYCODE_E))
 #endif
 		draw_sprites (screen->machine, bitmap, cliprect);
-	profiler_mark_end();
+	g_profiler.stop();
 	return 0;
 }
 
diff -Nru src-old/mame/video/midtunit.c src/mame/video/midtunit.c
--- src-old/mame/video/midtunit.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/midtunit.c	2010-08-21 15:25:58.000000000 -0700
@@ -220,13 +220,13 @@
  *
  *************************************/
 
-void midtunit_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void midtunit_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &local_videoram[address >> 3], 2 * 512 * sizeof(UINT16));
 }
 
 
-void midtunit_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void midtunit_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&local_videoram[address >> 3], shiftreg, 2 * 512 * sizeof(UINT16));
 }
@@ -687,7 +687,7 @@
 	if (!(command & 0x8000))
 		return;
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	/* determine bpp */
 	bpp = (command >> 12) & 7;
@@ -795,7 +795,7 @@
 skipdma:
 	timer_set(space->machine, ATTOTIME_IN_NSEC(41 * pixels), NULL, 0, dma_callback);
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
diff -Nru src-old/mame/video/midyunit.c src/mame/video/midyunit.c
--- src-old/mame/video/midyunit.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/midyunit.c	2010-08-21 15:25:58.000000000 -0700
@@ -200,13 +200,13 @@
  *
  *************************************/
 
-void midyunit_to_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void midyunit_to_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(shiftreg, &local_videoram[address >> 3], 2 * 512 * sizeof(UINT16));
 }
 
 
-void midyunit_from_shiftreg(const address_space *space, UINT32 address, UINT16 *shiftreg)
+void midyunit_from_shiftreg(address_space *space, UINT32 address, UINT16 *shiftreg)
 {
 	memcpy(&local_videoram[address >> 3], shiftreg, 2 * 512 * sizeof(UINT16));
 }
@@ -469,7 +469,7 @@
 	}
 }
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	/* fill in the basic data */
 	dma_state.rowbytes = (INT16)dma_register[DMA_ROWBYTES];
@@ -541,7 +541,7 @@
 	/* signal we're done */
 	timer_set(space->machine, ATTOTIME_IN_NSEC(41 * dma_state.width * dma_state.height), NULL, 0, dma_callback);
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
diff -Nru src-old/mame/video/model3.c src/mame/video/model3.c
--- src-old/mame/video/model3.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/video/model3.c	2010-08-19 01:27:05.000000000 -0700
@@ -814,64 +814,64 @@
 //  real3d_display_list = 1;
 }
 
-void real3d_display_list1_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
+void real3d_display_list1_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
 {
 	int i;
 	int d = (dst & 0xffffff) / 4;
 	for(i=0; i < length; i+=4) {
 		UINT32 w;
 		if (byteswap) {
-			w = BYTE_REVERSE32(memory_read_dword(space, src));
+			w = BYTE_REVERSE32(space->read_dword(src));
 		} else {
-			w = memory_read_dword(space, src);
+			w = space->read_dword(src);
 		}
 		display_list_ram[d++] = w;
 		src += 4;
 	}
 }
 
-void real3d_display_list2_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
+void real3d_display_list2_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
 {
 	int i;
 	int d = (dst & 0xffffff) / 4;
 	for(i=0; i < length; i+=4) {
 		UINT32 w;
 		if (byteswap) {
-			w = BYTE_REVERSE32(memory_read_dword(space, src));
+			w = BYTE_REVERSE32(space->read_dword(src));
 		} else {
-			w = memory_read_dword(space, src);
+			w = space->read_dword(src);
 		}
 		culling_ram[d++] = w;
 		src += 4;
 	}
 }
 
-void real3d_vrom_texture_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
+void real3d_vrom_texture_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
 {
 	if((dst & 0xff) == 0) {
 
 		UINT32 address, header;
 
 		if (byteswap) {
-			address = BYTE_REVERSE32(memory_read_dword(space, (src+0)));
-			header = BYTE_REVERSE32(memory_read_dword(space, (src+4)));
+			address = BYTE_REVERSE32(space->read_dword((src+0)));
+			header = BYTE_REVERSE32(space->read_dword((src+4)));
 		} else {
-			address = memory_read_dword(space, (src+0));
-			header = memory_read_dword(space, (src+4));
+			address = space->read_dword((src+0));
+			header = space->read_dword((src+4));
 		}
 		real3d_upload_texture(space->machine, header, (UINT32*)&model3_vrom[address]);
 	}
 }
 
-void real3d_texture_fifo_dma(const address_space *space, UINT32 src, int length, int byteswap)
+void real3d_texture_fifo_dma(address_space *space, UINT32 src, int length, int byteswap)
 {
 	int i;
 	for(i=0; i < length; i+=4) {
 		UINT32 w;
 		if (byteswap) {
-			w = BYTE_REVERSE32(memory_read_dword(space, src));
+			w = BYTE_REVERSE32(space->read_dword(src));
 		} else {
-			w = memory_read_dword(space, src);
+			w = space->read_dword(src);
 		}
 		texture_fifo[texture_fifo_pos] = w;
 		texture_fifo_pos++;
@@ -879,16 +879,16 @@
 	}
 }
 
-void real3d_polygon_ram_dma(const address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
+void real3d_polygon_ram_dma(address_space *space, UINT32 src, UINT32 dst, int length, int byteswap)
 {
 	int i;
 	int d = (dst & 0xffffff) / 4;
 	for(i=0; i < length; i+=4) {
 		UINT32 w;
 		if (byteswap) {
-			w = BYTE_REVERSE32(memory_read_dword(space, src));
+			w = BYTE_REVERSE32(space->read_dword(src));
 		} else {
-			w = memory_read_dword(space, src);
+			w = space->read_dword(src);
 		}
 		polygon_ram[d++] = w;
 		src += 4;
diff -Nru src-old/mame/video/namcos22.c src/mame/video/namcos22.c
--- src-old/mame/video/namcos22.c	2010-06-29 20:46:21.000000000 -0700
+++ src/mame/video/namcos22.c	2010-08-19 01:27:05.000000000 -0700
@@ -172,7 +172,7 @@
 } /* Clamp256 */
 
 #ifdef MAME_DEBUG
-static void Dump( const address_space *space, FILE *f, unsigned addr1, unsigned addr2, const char *name );
+static void Dump( address_space *space, FILE *f, unsigned addr1, unsigned addr2, const char *name );
 #endif
 
 static struct
@@ -2273,7 +2273,7 @@
       FILE *f = fopen( "dump.txt", "wb" );
       if( f )
       {
-         const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+         address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
          {
             int i,bank;
@@ -2323,7 +2323,7 @@
       FILE *f = fopen( "dump.txt", "wb" );
       if( f )
       {
-         const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+         address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 //         Dump(space, f,0x90000000, 0x90000003, "led?" );
 //         Dump(space, f,0x90010000, 0x90017fff, "cz_ram");
@@ -2395,7 +2395,7 @@
 
 #ifdef MAME_DEBUG
 static void
-Dump( const address_space *space, FILE *f, unsigned addr1, unsigned addr2, const char *name )
+Dump( address_space *space, FILE *f, unsigned addr1, unsigned addr2, const char *name )
 {
    unsigned addr;
    fprintf( f, "%s:\n", name );
@@ -2406,7 +2406,7 @@
       int i;
       for( i=0; i<16; i++ )
       {
-         data[i] = memory_read_byte(space, addr+i );
+         data[i] = space->read_byte(addr+i );
          if( data[i] )
          {
             bHasNonZero = 1;
diff -Nru src-old/mame/video/ojankohs.c src/mame/video/ojankohs.c
--- src-old/mame/video/ojankohs.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/ojankohs.c	2010-08-19 00:26:14.000000000 -0700
@@ -192,7 +192,7 @@
 
 ******************************************************************************/
 
-void ojankoc_flipscreen( const address_space *space, int data )
+void ojankoc_flipscreen( address_space *space, int data )
 {
 	ojankohs_state *state = space->machine->driver_data<ojankohs_state>();
 	int x, y;
@@ -332,7 +332,7 @@
 
 	if (state->screen_refresh)
 	{
-		const address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(screen->machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 		/* redraw bitmap */
 		for (offs = 0; offs < 0x8000; offs++)
diff -Nru src-old/mame/video/popeye.c src/mame/video/popeye.c
--- src-old/mame/video/popeye.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/popeye.c	2010-08-19 00:26:14.000000000 -0700
@@ -281,7 +281,7 @@
 static void draw_background(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect)
 {
 	int offs;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if (lastflip != flip_screen_get(machine))
 	{
diff -Nru src-old/mame/video/ppu2c0x.c src/mame/video/ppu2c0x.c
--- src-old/mame/video/ppu2c0x.c	2010-08-01 14:04:03.000000000 -0700
+++ src/mame/video/ppu2c0x.c	2010-08-30 08:20:58.000000000 -0700
@@ -76,7 +76,7 @@
 typedef struct _ppu2c0x_state  ppu2c0x_state;
 struct _ppu2c0x_state
 {
-	const address_space 		*space;					/* memory space */
+	address_space		*space;					/* memory space */
 	bitmap_t                    *bitmap;			/* target bitmap */
 	UINT8                       *spriteram;			/* sprite ram */
 	pen_t                       *colortable;			/* color table modified at run time */
@@ -426,14 +426,14 @@
 		pos = ((index1 & 0x380) >> 4) | ((index1 & 0x1f) >> 2);
 		page = (index1 & 0x0c00) >> 10;
 		address = 0x3c0 + pos;
-		color_byte = memory_read_byte(ppu2c0x->space, (((page * 0x400) + address) & 0xfff) + 0x2000);
+		color_byte = ppu2c0x->space->read_byte((((page * 0x400) + address) & 0xfff) + 0x2000);
 
 		/* figure out which bits in the color table to use */
 		color_bits = ((index1 & 0x40) >> 4) + (index1 & 0x02);
 
 		// page2 is the output of the nametable read (this section is the FIRST read per tile!)
 		address = index1 & 0x3ff;
-		page2 = memory_read_byte(ppu2c0x->space, index1);
+		page2 = ppu2c0x->space->read_byte(index1);
 
 		// 27/12/2002
 		if (ppu_latch)
@@ -451,8 +451,8 @@
 			// plus something that accounts for y
 			address += scroll_y_fine;
 
-			plane1 = memory_read_byte(ppu2c0x->space, (address & 0x1fff));
-			plane2 = memory_read_byte(ppu2c0x->space, (address + 8) & 0x1fff);
+			plane1 = ppu2c0x->space->read_byte((address & 0x1fff));
+			plane2 = ppu2c0x->space->read_byte((address + 8) & 0x1fff);
 
 			/* render the pixel */
 			for (i = 0; i < 8; i++)
@@ -598,8 +598,8 @@
 		if (size == 8)
 			index1 += ((sprite_page == 0) ? 0 : 0x1000);
 
-		plane1 = memory_read_byte(ppu2c0x->space, (index1 + sprite_line + 0) & 0x1fff);
-		plane2 = memory_read_byte(ppu2c0x->space, (index1 + sprite_line + 8) & 0x1fff);
+		plane1 = ppu2c0x->space->read_byte((index1 + sprite_line + 0) & 0x1fff);
+		plane2 = ppu2c0x->space->read_byte((index1 + sprite_line + 8) & 0x1fff);
 
 		/* if there are more than 8 sprites on this line, set the flag */
 		if (sprite_count == 8)
@@ -717,7 +717,7 @@
 	int *ppu_regs = &ppu2c0x->regs[0];
 
 	/* lets see how long it takes */
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	/* clear the line priority for this scanline */
 	memset(line_priority, 0, VISIBLE_SCREEN_WIDTH);
@@ -751,7 +751,7 @@
 	draw_sprites(device, line_priority);
 
 	/* done updating, whew */
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 static void update_scanline( running_device *device )
@@ -996,14 +996,14 @@
 
 			if (ppu2c0x->videomem_addr >= 0x3f00)
 			{
-				ppu2c0x->data_latch = memory_read_byte(ppu2c0x->space, ppu2c0x->videomem_addr);
+				ppu2c0x->data_latch = ppu2c0x->space->read_byte(ppu2c0x->videomem_addr);
 				// buffer the mirrored NT data
-				ppu2c0x->buffered_data = memory_read_byte(ppu2c0x->space, ppu2c0x->videomem_addr & 0x2fff);
+				ppu2c0x->buffered_data = ppu2c0x->space->read_byte(ppu2c0x->videomem_addr & 0x2fff);
 			}
 			else
 			{
 				ppu2c0x->data_latch = ppu2c0x->buffered_data;
-				ppu2c0x->buffered_data = memory_read_byte(ppu2c0x->space, ppu2c0x->videomem_addr);
+				ppu2c0x->buffered_data = ppu2c0x->space->read_byte(ppu2c0x->videomem_addr);
 			}
 
 			ppu2c0x->videomem_addr += ppu2c0x->add;
@@ -1153,12 +1153,12 @@
 				if (tempAddr < 0x2000)
 				{
 					/* store the data */
-					memory_write_byte(ppu2c0x->space, tempAddr, data);
+					ppu2c0x->space->write_byte(tempAddr, data);
 				}
 
 				else
 				{
-					memory_write_byte(ppu2c0x->space, tempAddr, data);
+					ppu2c0x->space->write_byte(tempAddr, data);
 				}
 				/* increment the address */
 				ppu2c0x->videomem_addr += ppu2c0x->add;
@@ -1179,15 +1179,15 @@
  *
  *************************************/
 
-void ppu2c0x_spriteram_dma( const address_space *space, running_device *device, const UINT8 page )
+void ppu2c0x_spriteram_dma( address_space *space, running_device *device, const UINT8 page )
 {
 	int i;
 	int address = page << 8;
 
 	for (i = 0; i < SPRITERAM_SIZE; i++)
 	{
-		UINT8 spriteData = memory_read_byte(space, address + i);
-		memory_write_byte(space, 0x2004, spriteData);
+		UINT8 spriteData = space->read_byte(address + i);
+		space->write_byte(0x2004, spriteData);
 	}
 
 	// should last 513 CPU cycles.
diff -Nru src-old/mame/video/ppu2c0x.h src/mame/video/ppu2c0x.h
--- src-old/mame/video/ppu2c0x.h	2010-06-27 05:13:52.000000000 -0700
+++ src/mame/video/ppu2c0x.h	2010-08-19 00:26:14.000000000 -0700
@@ -108,7 +108,7 @@
 void ppu2c0x_init_palette(running_machine *machine, int first_entry ) ATTR_NONNULL(1);
 void ppu2c0x_init_palette_rgb(running_machine *machine, int first_entry ) ATTR_NONNULL(1);
 
-void ppu2c0x_spriteram_dma(const address_space *space, running_device *device, const UINT8 page ) ATTR_NONNULL(1);
+void ppu2c0x_spriteram_dma(address_space *space, running_device *device, const UINT8 page ) ATTR_NONNULL(1);
 void ppu2c0x_render( running_device *device, bitmap_t *bitmap, int flipx, int flipy, int sx, int sy ) ATTR_NONNULL(1);
 int ppu2c0x_get_pixel( running_device *device, int x, int y ) ATTR_NONNULL(1);
 int ppu2c0x_get_colorbase( running_device *device ) ATTR_NONNULL(1);
diff -Nru src-old/mame/video/prehisle.c src/mame/video/prehisle.c
--- src-old/mame/video/prehisle.c	2010-05-29 06:25:38.000000000 -0700
+++ src/mame/video/prehisle.c	2010-08-26 20:55:49.000000000 -0700
@@ -7,34 +7,34 @@
 ***************************************************************************/
 
 #include "emu.h"
-
-
-UINT16 *prehisle_bg_videoram16;
-
-static UINT16 invert_controls;
-
-static tilemap_t *bg2_tilemap, *bg_tilemap, *fg_tilemap;
+#include "includes/prehisle.h"
 
 
 WRITE16_HANDLER( prehisle_bg_videoram16_w )
 {
-	COMBINE_DATA(&prehisle_bg_videoram16[offset]);
-	tilemap_mark_tile_dirty(bg_tilemap, offset);
+	prehisle_state *state = space->machine->driver_data<prehisle_state>();
+
+	COMBINE_DATA(&state->bg_videoram16[offset]);
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset);
 }
 
 WRITE16_HANDLER( prehisle_fg_videoram16_w )
 {
-	COMBINE_DATA(&space->machine->generic.videoram.u16[offset]);
-	tilemap_mark_tile_dirty(fg_tilemap, offset);
+	prehisle_state *state = space->machine->driver_data<prehisle_state>();
+
+	COMBINE_DATA(&state->videoram[offset]);
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset);
 }
 
 READ16_HANDLER( prehisle_control16_r )
 {
+	prehisle_state *state = space->machine->driver_data<prehisle_state>();
+
 	switch (offset)
 	{
 	case 0x08: return input_port_read(space->machine, "P2");						// Player 2
 	case 0x10: return input_port_read(space->machine, "COIN");						// Coins, Tilt, Service
-	case 0x20: return input_port_read(space->machine, "P1") ^ invert_controls;		// Player 1
+	case 0x20: return input_port_read(space->machine, "P1") ^ state->invert_controls;		// Player 1
 	case 0x21: return input_port_read(space->machine, "DSW0");						// DIPs
 	case 0x22: return input_port_read(space->machine, "DSW1");						// DIPs + VBLANK
 	default: return 0;
@@ -43,17 +43,18 @@
 
 WRITE16_HANDLER( prehisle_control16_w )
 {
+	prehisle_state *state = space->machine->driver_data<prehisle_state>();
 	int scroll = 0;
 
 	COMBINE_DATA(&scroll);
 
 	switch (offset)
 	{
-	case 0x00: tilemap_set_scrolly(bg_tilemap, 0, scroll); break;
-	case 0x08: tilemap_set_scrollx(bg_tilemap, 0, scroll); break;
-	case 0x10: tilemap_set_scrolly(bg2_tilemap, 0, scroll); break;
-	case 0x18: tilemap_set_scrollx(bg2_tilemap, 0, scroll); break;
-	case 0x23: invert_controls = data ? 0x00ff : 0x0000; break;
+	case 0x00: tilemap_set_scrolly(state->bg_tilemap, 0, scroll); break;
+	case 0x08: tilemap_set_scrollx(state->bg_tilemap, 0, scroll); break;
+	case 0x10: tilemap_set_scrolly(state->bg2_tilemap, 0, scroll); break;
+	case 0x18: tilemap_set_scrollx(state->bg2_tilemap, 0, scroll); break;
+	case 0x23: state->invert_controls = data ? 0x00ff : 0x0000; break;
 	case 0x28: coin_counter_w(space->machine, 0, data & 1); break;
 	case 0x29: coin_counter_w(space->machine, 1, data & 1); break;
 	case 0x30: flip_screen_set(space->machine, data & 0x01); break;
@@ -75,7 +76,8 @@
 
 static TILE_GET_INFO( get_bg_tile_info )
 {
-	int attr = prehisle_bg_videoram16[tile_index];
+	prehisle_state *state = machine->driver_data<prehisle_state>();
+	int attr = state->bg_videoram16[tile_index];
 	int code = attr & 0x7ff;
 	int color = attr >> 12;
 	int flags = (attr & 0x800) ? TILE_FLIPY : 0;
@@ -85,7 +87,8 @@
 
 static TILE_GET_INFO( get_fg_tile_info )
 {
-	int attr = machine->generic.videoram.u16[tile_index];
+	prehisle_state *state = machine->driver_data<prehisle_state>();
+	int attr = state->videoram[tile_index];
 	int code = attr & 0xfff;
 	int color = attr >> 12;
 
@@ -94,20 +97,22 @@
 
 VIDEO_START( prehisle )
 {
-	bg2_tilemap = tilemap_create(machine, get_bg2_tile_info, tilemap_scan_cols,
+	prehisle_state *state = machine->driver_data<prehisle_state>();
+
+	state->bg2_tilemap = tilemap_create(machine, get_bg2_tile_info, tilemap_scan_cols,
 		 16, 16, 1024, 32);
 
-	bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_cols,
+	state->bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_cols,
 		 16, 16, 256, 32);
 
-	fg_tilemap = tilemap_create(machine, get_fg_tile_info, tilemap_scan_rows,
+	state->fg_tilemap = tilemap_create(machine, get_fg_tile_info, tilemap_scan_rows,
 		 8, 8, 32, 32);
 
-	tilemap_set_transparent_pen(bg_tilemap, 15);
-	tilemap_set_transparent_pen(fg_tilemap, 15);
+	tilemap_set_transparent_pen(state->bg_tilemap, 15);
+	tilemap_set_transparent_pen(state->fg_tilemap, 15);
 
 	/* register for saving */
-	state_save_register_global(machine, invert_controls);
+	state_save_register_global(machine, state->invert_controls);
 }
 
 /* sprite layout
@@ -125,7 +130,8 @@
 */
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, int foreground )
 {
-	UINT16 *spriteram16 = machine->generic.spriteram.u16;
+	prehisle_state *state = machine->driver_data<prehisle_state>();
+	UINT16 *spriteram16 = state->spriteram;
 	int offs;
 
 	for (offs = 0; offs < 1024; offs += 4)
@@ -160,10 +166,12 @@
 
 VIDEO_UPDATE( prehisle )
 {
-	tilemap_draw(bitmap, cliprect, bg2_tilemap, 0, 0);
+	prehisle_state *state = screen->machine->driver_data<prehisle_state>();
+
+	tilemap_draw(bitmap, cliprect, state->bg2_tilemap, 0, 0);
 	draw_sprites(screen->machine, bitmap, cliprect, 0);
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
 	draw_sprites(screen->machine, bitmap, cliprect, 1);
-	tilemap_draw(bitmap, cliprect, fg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->fg_tilemap, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/psikyosh.c src/mame/video/psikyosh.c
--- src-old/mame/video/psikyosh.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/psikyosh.c	2010-08-21 15:25:58.000000000 -0700
@@ -438,14 +438,14 @@
 				cache_bitmap(tilemap_scanline, state, gfx, size, tilebank, alpha, last_bank);
 
 				/* zoomy and 'wibbly' effects - extract an entire row from tilemap */
-				profiler_mark_start(PROFILER_USER2);
+				g_profiler.start(PROFILER_USER2);
 				UINT32 tilemap_line[32 * 16];
 				UINT32 scr_line[64 * 8];
 				extract_scanline32(state->bg_bitmap, 0, tilemap_scanline, width, tilemap_line);
-				profiler_mark_end();
+				g_profiler.stop();
 
 				/* slow bit, needs optimising. apply scrollx and zoomx by assembling scanline from row */
-				profiler_mark_start(PROFILER_USER3);
+				g_profiler.start(PROFILER_USER3);
 				if(zoom) {
 					int step = state->bg_zoom[zoom];
 					int jj = 0x400 << 10; // ensure +ve for mod
@@ -459,10 +459,10 @@
 						scr_line[ii] = tilemap_line[(ii - scrollx + 0x400) % width];
 					}
 				}
-				profiler_mark_end();
+				g_profiler.stop();
 
 				/* blend line into output */
-				profiler_mark_start(PROFILER_USER4);
+				g_profiler.start(PROFILER_USER4);
 				if(alpha == 0xff) {
 					draw_scanline32_transpen(bitmap, 0, scanline, scr_width, scr_line);
 				}
@@ -472,7 +472,7 @@
 				else if (alpha < 0) {
 					draw_scanline32_argb(bitmap, 0, scanline, scr_width, scr_line);
 				}
-				profiler_mark_end();
+				g_profiler.stop();
 			}
 		}
 
@@ -542,7 +542,7 @@
 	if (!zoomx || !zoomy)
 		return;
 
-	profiler_mark_start(PROFILER_DRAWGFX);
+	g_profiler.start(PROFILER_DRAWGFX);
 
 	assert(dest_bmp->bpp == 32);
 
@@ -1065,7 +1065,7 @@
 			}
 		}
 	}
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -1203,7 +1203,7 @@
 
 	assert(bitmap->bpp == 32);
 
-	profiler_mark_start(PROFILER_USER8);
+	g_profiler.start(PROFILER_USER8);
 	for (y = cliprect->min_y; y <= cliprect->max_y; y += 1) {
 
 		dstline = BITMAP_ADDR32(bitmap, y, 0);
@@ -1212,7 +1212,7 @@
 		for (x = cliprect->min_x; x <= cliprect->max_x; x += 1)
 			dstline[x] = linefill[y] >> 8;
 	}
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -1231,7 +1231,7 @@
 		return;
 	}
 
-	profiler_mark_start(PROFILER_USER8);
+	g_profiler.start(PROFILER_USER8);
 	for (y = cliprect->min_y; y <= cliprect->max_y; y += 1) {
 
 		dstline = BITMAP_ADDR32(bitmap, y, 0);
@@ -1247,7 +1247,7 @@
 				dstline[x] = alpha_blend_r32(dstline[x], lineblend[y] >> 8, 2 * (lineblend[y] & 0x7f));
 		}
 	}
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -1342,7 +1342,7 @@
 
 VIDEO_EOF( psikyosh )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	buffer_spriteram32_w(space, 0, 0, 0xffffffff);
 }
 
diff -Nru src-old/mame/video/psx.c src/mame/video/psx.c
--- src-old/mame/video/psx.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/psx.c	2010-08-19 00:26:14.000000000 -0700
@@ -3922,7 +3922,7 @@
 
 void psx_gpu_reset( running_machine *machine )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	psx_gpu_w(space, 1, 0, 0xffffffff );
 }
diff -Nru src-old/mame/video/redalert.c src/mame/video/redalert.c
--- src-old/mame/video/redalert.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/redalert.c	2010-08-16 18:00:44.000000000 -0700
@@ -71,7 +71,7 @@
 
 	offs_t offs;
 	double scaler;
-	double bitmap_weight[1];
+	double bitmap_weight[2];
 	double charmap_rg_weights[3];
 	double charmap_b_weights[2];
 	double back_r_weight[1];
diff -Nru src-old/mame/video/segag80v.c src/mame/video/segag80v.c
--- src-old/mame/video/segag80v.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/segag80v.c	2010-08-13 01:54:21.000000000 -0700
@@ -5,7 +5,6 @@
 *************************************************************************/
 
 #include "emu.h"
-#include "avgdvg.h"
 #include "video/vector.h"
 #include "includes/segag80v.h"
 
@@ -16,6 +15,8 @@
 #define IRQ_CLOCK			(U34_CLOCK/0x1f788)	/* 40Hz interrupt */
 
 
+UINT8 *segag80v_vectorram;
+size_t segag80v_vectorram_size;
 static int min_x, min_y;
 
 
@@ -114,6 +115,7 @@
 	UINT8 *sintable = memory_region(machine, "proms");
 	double total_time = 1.0 / (double)IRQ_CLOCK;
 	UINT16 symaddr = 0;
+	UINT8 *vectorram = segag80v_vectorram;
 
 	vector_clear_list();
 
@@ -323,9 +325,9 @@
 
 ***************************************************************************/
 
-VIDEO_START( sega )
+VIDEO_START( segag80v )
 {
-	assert_always(vectorram_size != 0, "vectorram==0");
+	assert_always(segag80v_vectorram_size != 0, "segag80v_vectorram==0");
 
 	min_x =machine->primary_screen->visible_area().min_x;
 	min_y =machine->primary_screen->visible_area().min_y;
@@ -334,7 +336,7 @@
 }
 
 
-VIDEO_UPDATE( sega )
+VIDEO_UPDATE( segag80v )
 {
 	sega_generate_vector_list(screen->machine);
 	VIDEO_UPDATE_CALL(vector);
diff -Nru src-old/mame/video/segas32.c src/mame/video/segas32.c
--- src-old/mame/video/segas32.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/segas32.c	2010-08-21 15:25:58.000000000 -0700
@@ -433,7 +433,7 @@
 }
 
 
-static void common_paletteram_w(const address_space *space, int which, offs_t offset, UINT16 data, UINT16 mem_mask)
+static void common_paletteram_w(address_space *space, int which, offs_t offset, UINT16 data, UINT16 mem_mask)
 {
 	UINT16 value;
 	int convert;
@@ -1900,7 +1900,7 @@
 	int spritenum = 0;
 	UINT16 *sprite;
 
-	profiler_mark_start(PROFILER_USER2);
+	g_profiler.start(PROFILER_USER2);
 
 	logerror("----\n");
 
@@ -1971,7 +1971,7 @@
 		}
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
@@ -2460,9 +2460,9 @@
 	}
 
 	/* update the tilemaps */
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 	enablemask = update_tilemaps(*screen, cliprect);
-	profiler_mark_end();
+	g_profiler.stop();
 
 	/* debugging */
 #if QWERTY_LAYER_ENABLE
@@ -2475,9 +2475,9 @@
 #endif
 
 	/* do the mixing */
-	profiler_mark_start(PROFILER_USER3);
+	g_profiler.start(PROFILER_USER3);
 	mix_all_layers(0, 0, bitmap, cliprect, enablemask);
-	profiler_mark_end();
+	g_profiler.stop();
 
 	if (LOG_SPRITES && input_code_pressed(screen->machine, KEYCODE_L))
 	{
@@ -2640,9 +2640,9 @@
 	}
 
 	/* update the tilemaps */
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 	enablemask = update_tilemaps(*screen, cliprect);
-	profiler_mark_end();
+	g_profiler.stop();
 
 	/* debugging */
 #if QWERTY_LAYER_ENABLE
@@ -2655,9 +2655,9 @@
 #endif
 
 	/* do the mixing */
-	profiler_mark_start(PROFILER_USER3);
+	g_profiler.start(PROFILER_USER3);
 	mix_all_layers(((screen == left_screen) ? 0 : 1), 0, bitmap, cliprect, enablemask);
-	profiler_mark_end();
+	g_profiler.stop();
 
 if (PRINTF_MIXER_DATA)
 {
diff -Nru src-old/mame/video/shangha3.c src/mame/video/shangha3.c
--- src-old/mame/video/shangha3.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/shangha3.c	2010-08-21 15:25:58.000000000 -0700
@@ -116,7 +116,7 @@
 	int offs;
 
 
-	profiler_mark_start(PROFILER_VIDEO);
+	g_profiler.start(PROFILER_VIDEO);
 
 	for (offs = gfxlist_addr << 3;offs < shangha3_ram_size/2;offs += 16)
 	{
@@ -259,7 +259,7 @@
 		}
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 
diff -Nru src-old/mame/video/sidearms.c src/mame/video/sidearms.c
--- src-old/mame/video/sidearms.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/sidearms.c	2010-08-19 00:26:14.000000000 -0700
@@ -368,7 +368,7 @@
 
 VIDEO_EOF( sidearms )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space, 0, 0);
 }
diff -Nru src-old/mame/video/simpsons.c src/mame/video/simpsons.c
--- src-old/mame/video/simpsons.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/simpsons.c	2010-08-19 00:26:14.000000000 -0700
@@ -97,7 +97,7 @@
 void simpsons_video_banking( running_machine *machine, int bank )
 {
 	simpsons_state *state = machine->driver_data<simpsons_state>();
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	if (bank & 1)
 	{
diff -Nru src-old/mame/video/skydiver.c src/mame/video/skydiver.c
--- src-old/mame/video/skydiver.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/skydiver.c	2010-08-19 00:26:14.000000000 -0700
@@ -17,7 +17,7 @@
 
 MACHINE_RESET( skydiver )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* reset all latches */
 	skydiver_start_lamp_1_w(space, 0, 0);
diff -Nru src-old/mame/video/snes.c src/mame/video/snes.c
--- src-old/mame/video/snes.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/snes.c	2010-08-21 15:25:58.000000000 -0700
@@ -1508,7 +1508,7 @@
 	UINT16 prev_colour = 0;
 	int blurring = input_port_read_safe(machine, "OPTIONS", 0) & 0x01;
 
-	profiler_mark_start(PROFILER_VIDEO);
+	g_profiler.start(PROFILER_VIDEO);
 
 	if (snes_ppu.screen_disabled) /* screen is forced blank */
 		for (x = 0; x < SNES_SCR_WIDTH * 2; x++)
@@ -1556,7 +1556,7 @@
 #ifdef SNES_LAYER_DEBUG
 		if (snes_dbg_video(machine, curline))
 		{
-			profiler_mark_end();
+			g_profiler.stop();
 			return;
 		}
 
@@ -1654,7 +1654,7 @@
 		}
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
 
 VIDEO_START( snes )
@@ -2246,8 +2246,8 @@
 		case INIDISP:	/* Initial settings for screen */
 			if ((snes_ppu.screen_disabled & 0x80) && (!(data & 0x80))) //a 1->0 force blank transition causes a reset OAM address
 			{
-				memory_write_byte(space, OAMADDL, snes_ppu.oam.saved_address_low);
-				memory_write_byte(space, OAMADDH, snes_ppu.oam.saved_address_high);
+				space->write_byte(OAMADDL, snes_ppu.oam.saved_address_low);
+				space->write_byte(OAMADDH, snes_ppu.oam.saved_address_high);
 				snes_ppu.oam.first_sprite = snes_ppu.oam.priority_rotation ? (snes_ppu.oam.address >> 1) & 127 : 0;
 			}
 			snes_ppu.screen_disabled = data & 0x80;
diff -Nru src-old/mame/video/snk.c src/mame/video/snk.c
--- src-old/mame/video/snk.c	2010-06-27 23:40:44.000000000 -0700
+++ src/mame/video/snk.c	2010-08-26 20:55:49.000000000 -0700
@@ -22,23 +22,6 @@
 
 *******************************************************************************/
 
-UINT8 *snk_tx_videoram;
-UINT8 *snk_fg_videoram;
-UINT8 *snk_bg_videoram;
-
-static tilemap_t *tx_tilemap;
-static tilemap_t *fg_tilemap;
-static tilemap_t *bg_tilemap;
-static int fg_scrollx, fg_scrolly, bg_scrollx, bg_scrolly;
-static int sp16_scrollx, sp16_scrolly, sp32_scrollx, sp32_scrolly;
-static UINT8 sprite_split_point;
-static int num_sprites, yscroll_mask;
-static UINT32 bg_tile_offset;
-static UINT32 tx_tile_offset;
-static int is_psychos;
-
-static UINT8 empty_tile[16*16];
-static UINT8 drawmode_table[16];
 
 /**************************************************************************************/
 
@@ -88,28 +71,34 @@
 
 static TILE_GET_INFO( marvins_get_tx_tile_info )
 {
-	int code = snk_tx_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->tx_videoram[tile_index];
 	int color = code >> 5;
+
 	SET_TILE_INFO(0,
-			tx_tile_offset + code,
+			state->tx_tile_offset + code,
 			color,
 			tile_index & 0x400 ? TILE_FORCE_LAYER0 : 0);
 }
 
 static TILE_GET_INFO( ikari_get_tx_tile_info )
 {
-	int code = snk_tx_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->tx_videoram[tile_index];
+
 	SET_TILE_INFO(0,
-			tx_tile_offset + code,
+			state->tx_tile_offset + code,
 			0,
 			tile_index & 0x400 ? TILE_FORCE_LAYER0 : 0);
 }
 
 static TILE_GET_INFO( gwar_get_tx_tile_info )
 {
-	int code = snk_tx_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->tx_videoram[tile_index];
+
 	SET_TILE_INFO(0,
-			tx_tile_offset + code,
+			state->tx_tile_offset + code,
 			0,
 			0);
 }
@@ -117,7 +106,9 @@
 
 static TILE_GET_INFO( marvins_get_fg_tile_info )
 {
-	int code = snk_fg_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->fg_videoram[tile_index];
+
 	SET_TILE_INFO(1,
 			code,
 			0,
@@ -126,7 +117,9 @@
 
 static TILE_GET_INFO( marvins_get_bg_tile_info )
 {
-	int code = snk_bg_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->bg_videoram[tile_index];
+
 	SET_TILE_INFO(2,
 			code,
 			0,
@@ -136,18 +129,22 @@
 
 static TILE_GET_INFO( aso_get_bg_tile_info )
 {
-	int code = snk_bg_videoram[tile_index];
+	snk_state *state = machine->driver_data<snk_state>();
+	int code = state->bg_videoram[tile_index];
+
 	SET_TILE_INFO(1,
-			bg_tile_offset + code,
+			state->bg_tile_offset + code,
 			0,
 			0);
 }
 
 static TILE_GET_INFO( tnk3_get_bg_tile_info )
 {
-	int attr = snk_bg_videoram[2*tile_index+1];
-	int code = snk_bg_videoram[2*tile_index] | ((attr & 0x30) << 4);
+	snk_state *state = machine->driver_data<snk_state>();
+	int attr = state->bg_videoram[2*tile_index+1];
+	int code = state->bg_videoram[2*tile_index] | ((attr & 0x30) << 4);
 	int color = (attr & 0xf) ^ 8;
+
 	SET_TILE_INFO(1,
 			code,
 			color,
@@ -156,9 +153,11 @@
 
 static TILE_GET_INFO( ikari_get_bg_tile_info )
 {
-	int attr = snk_bg_videoram[2*tile_index+1];
-	int code = snk_bg_videoram[2*tile_index] | ((attr & 0x03) << 8);
+	snk_state *state = machine->driver_data<snk_state>();
+	int attr = state->bg_videoram[2*tile_index+1];
+	int code = state->bg_videoram[2*tile_index] | ((attr & 0x03) << 8);
 	int color = (attr & 0x70) >> 4;
+
 	SET_TILE_INFO(1,
 			code,
 			color,
@@ -167,11 +166,12 @@
 
 static TILE_GET_INFO( gwar_get_bg_tile_info )
 {
-	int attr = snk_bg_videoram[2*tile_index+1];
-	int code = snk_bg_videoram[2*tile_index] | ((attr & 0x0f) << 8);
+	snk_state *state = machine->driver_data<snk_state>();
+	int attr = state->bg_videoram[2*tile_index+1];
+	int code = state->bg_videoram[2*tile_index] | ((attr & 0x0f) << 8);
 	int color = (attr & 0xf0) >> 4;
 
-	if (is_psychos)	// psychos has a separate palette bank bit
+	if (state->is_psychos)	// psychos has a separate palette bank bit
 		color &= 7;
 
 	SET_TILE_INFO(1,
@@ -183,7 +183,7 @@
 	// (still call SET_TILE_INFO, otherwise problems might occur on boot when
 	// the tile data hasn't been initialised)
 	if (code >= machine->gfx[1]->total_elements)
-		tileinfo->pen_data = empty_tile;
+		tileinfo->pen_data = state->empty_tile;
 }
 
 
@@ -191,15 +191,16 @@
 
 static VIDEO_START( snk_3bpp_shadow )
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	int i;
 
 	if(!(machine->config->m_video_attributes & VIDEO_HAS_SHADOWS))
 		fatalerror("driver should use VIDEO_HAS_SHADOWS");
 
 	/* prepare shadow draw table */
-	for(i = 0; i <= 5; i++) drawmode_table[i] = DRAWMODE_SOURCE;
-	drawmode_table[6] = (machine->config->m_video_attributes & VIDEO_HAS_SHADOWS) ? DRAWMODE_SHADOW : DRAWMODE_SOURCE;
-	drawmode_table[7] = DRAWMODE_NONE;
+	for(i = 0; i <= 5; i++) state->drawmode_table[i] = DRAWMODE_SOURCE;
+	state->drawmode_table[6] = (machine->config->m_video_attributes & VIDEO_HAS_SHADOWS) ? DRAWMODE_SHADOW : DRAWMODE_SOURCE;
+	state->drawmode_table[7] = DRAWMODE_NONE;
 
 	for (i = 0x000;i < 0x400;i++)
 		machine->shadow_table[i] = i | 0x200;
@@ -207,15 +208,16 @@
 
 static VIDEO_START( snk_4bpp_shadow )
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	int i;
 
 	if(!(machine->config->m_video_attributes & VIDEO_HAS_SHADOWS))
 		fatalerror("driver should use VIDEO_HAS_SHADOWS");
 
 	/* prepare shadow draw table */
-	for(i = 0; i <= 13; i++) drawmode_table[i] = DRAWMODE_SOURCE;
-	drawmode_table[14] = DRAWMODE_SHADOW;
-	drawmode_table[15] = DRAWMODE_NONE;
+	for(i = 0; i <= 13; i++) state->drawmode_table[i] = DRAWMODE_SOURCE;
+	state->drawmode_table[14] = DRAWMODE_SHADOW;
+	state->drawmode_table[15] = DRAWMODE_NONE;
 
 	/* all palette entries are not affected by shadow sprites... */
 	for (i = 0x000;i < 0x400;i++)
@@ -228,145 +230,162 @@
 
 VIDEO_START( marvins )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(snk_3bpp_shadow);
 
-	tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
-	fg_tilemap = tilemap_create(machine, marvins_get_fg_tile_info, tilemap_scan_cols,    8, 8, 64, 32);
-	bg_tilemap = tilemap_create(machine, marvins_get_bg_tile_info, tilemap_scan_cols,    8, 8, 64, 32);
+	state->tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
+	state->fg_tilemap = tilemap_create(machine, marvins_get_fg_tile_info, tilemap_scan_cols,    8, 8, 64, 32);
+	state->bg_tilemap = tilemap_create(machine, marvins_get_bg_tile_info, tilemap_scan_cols,    8, 8, 64, 32);
 
-	tilemap_set_transparent_pen(tx_tilemap,15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
 
-	tilemap_set_transparent_pen(fg_tilemap,15);
-	tilemap_set_scrolldx(fg_tilemap, 15,  31);
-	tilemap_set_scrolldy(fg_tilemap,  8, -32);
+	tilemap_set_transparent_pen(state->fg_tilemap, 15);
+	tilemap_set_scrolldx(state->fg_tilemap, 15,  31);
+	tilemap_set_scrolldy(state->fg_tilemap,  8, -32);
 
-	tilemap_set_scrolldx(bg_tilemap, 15,  31);
-	tilemap_set_scrolldy(bg_tilemap,  8, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 15,  31);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32);
 
-	tx_tile_offset = 0;
+	state->tx_tile_offset = 0;
 }
 
 VIDEO_START( jcross )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(snk_3bpp_shadow);
 
-	tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
-	bg_tilemap = tilemap_create(machine, aso_get_bg_tile_info,     tilemap_scan_cols,    8, 8, 64, 64);
+	state->tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
+	state->bg_tilemap = tilemap_create(machine, aso_get_bg_tile_info,     tilemap_scan_cols,    8, 8, 64, 64);
 
-	tilemap_set_transparent_pen(tx_tilemap, 15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
 
-	tilemap_set_scrolldx(bg_tilemap, 15, 24);
-	tilemap_set_scrolldy(bg_tilemap,  8, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 15, 24);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32);
 
-	num_sprites = 25;
-	yscroll_mask = 0x1ff;
-	bg_tile_offset = 0;
-	tx_tile_offset = 0;
+	state->num_sprites = 25;
+	state->yscroll_mask = 0x1ff;
+	state->bg_tile_offset = 0;
+	state->tx_tile_offset = 0;
 }
 
 VIDEO_START( sgladiat )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(snk_3bpp_shadow);
 
-	tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
-	bg_tilemap = tilemap_create(machine, aso_get_bg_tile_info,     tilemap_scan_cols,    8, 8, 64, 32);
+	state->tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
+	state->bg_tilemap = tilemap_create(machine, aso_get_bg_tile_info,     tilemap_scan_cols,    8, 8, 64, 32);
 
-	tilemap_set_transparent_pen(tx_tilemap, 15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
 
-	tilemap_set_scrolldx(bg_tilemap, 15, 24);
-	tilemap_set_scrolldy(bg_tilemap,  8, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 15, 24);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32);
 
-	num_sprites = 25;
-	yscroll_mask = 0x0ff;
-	bg_tile_offset = 0;
-	tx_tile_offset = 0;
+	state->num_sprites = 25;
+	state->yscroll_mask = 0x0ff;
+	state->bg_tile_offset = 0;
+	state->tx_tile_offset = 0;
 }
 
 VIDEO_START( hal21 )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(jcross);
 
-	tilemap_set_scrolldy(bg_tilemap,  8, -32+256);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32+256);
 
-	num_sprites = 50;
-	yscroll_mask = 0x1ff;
+	state->num_sprites = 50;
+	state->yscroll_mask = 0x1ff;
 }
 
 VIDEO_START( aso )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(jcross);
 
-	tilemap_set_scrolldx(bg_tilemap, 15+256, 24+256);
+	tilemap_set_scrolldx(state->bg_tilemap, 15+256, 24+256);
 
-	num_sprites = 50;
-	yscroll_mask = 0x1ff;
+	state->num_sprites = 50;
+	state->yscroll_mask = 0x1ff;
 }
 
 
 VIDEO_START( tnk3 )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(snk_3bpp_shadow);
 
-	tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
-	bg_tilemap = tilemap_create(machine, tnk3_get_bg_tile_info,    tilemap_scan_cols,    8, 8, 64, 64);
+	state->tx_tilemap = tilemap_create(machine, marvins_get_tx_tile_info, marvins_tx_scan_cols, 8, 8, 36, 28);
+	state->bg_tilemap = tilemap_create(machine, tnk3_get_bg_tile_info,    tilemap_scan_cols,    8, 8, 64, 64);
 
-	tilemap_set_transparent_pen(tx_tilemap, 15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
 
-	tilemap_set_scrolldx(bg_tilemap, 15, 24);
-	tilemap_set_scrolldy(bg_tilemap,  8, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 15, 24);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32);
 
-	num_sprites = 50;
-	yscroll_mask = 0x1ff;
-	tx_tile_offset = 0;
+	state->num_sprites = 50;
+	state->yscroll_mask = 0x1ff;
+	state->tx_tile_offset = 0;
 }
 
 VIDEO_START( ikari )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(snk_3bpp_shadow);
 
-	tx_tilemap = tilemap_create(machine, ikari_get_tx_tile_info, marvins_tx_scan_cols,  8,  8, 36, 28);
-	bg_tilemap = tilemap_create(machine, ikari_get_bg_tile_info, tilemap_scan_cols,    16, 16, 32, 32);
+	state->tx_tilemap = tilemap_create(machine, ikari_get_tx_tile_info, marvins_tx_scan_cols,  8,  8, 36, 28);
+	state->bg_tilemap = tilemap_create(machine, ikari_get_bg_tile_info, tilemap_scan_cols,    16, 16, 32, 32);
 
-	tilemap_set_transparent_pen(tx_tilemap, 15);
-	tilemap_set_scrolldy(tx_tilemap, 8, 8);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
+	tilemap_set_scrolldy(state->tx_tilemap, 8, 8);
 
-	tilemap_set_scrolldx(bg_tilemap, 15, 24);
-	tilemap_set_scrolldy(bg_tilemap,  8, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 15, 24);
+	tilemap_set_scrolldy(state->bg_tilemap,  8, -32);
 
-	tx_tile_offset = 0;
+	state->tx_tile_offset = 0;
 }
 
 VIDEO_START( gwar )
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	int i;
 
 	/* prepare drawmode table */
-	for(i = 0; i <= 14; i++) drawmode_table[i] = DRAWMODE_SOURCE;
-	drawmode_table[15] = DRAWMODE_NONE;
+	for(i = 0; i <= 14; i++) state->drawmode_table[i] = DRAWMODE_SOURCE;
+	state->drawmode_table[15] = DRAWMODE_NONE;
 
-	memset(empty_tile,0xf,sizeof(empty_tile));
+	memset(state->empty_tile, 0xf, sizeof(state->empty_tile));
 
-	tx_tilemap = tilemap_create(machine, gwar_get_tx_tile_info, tilemap_scan_cols,  8,  8, 50, 32);
-	bg_tilemap = tilemap_create(machine, gwar_get_bg_tile_info, tilemap_scan_cols, 16, 16, 32, 32);
+	state->tx_tilemap = tilemap_create(machine, gwar_get_tx_tile_info, tilemap_scan_cols,  8,  8, 50, 32);
+	state->bg_tilemap = tilemap_create(machine, gwar_get_bg_tile_info, tilemap_scan_cols, 16, 16, 32, 32);
 
-	tilemap_set_transparent_pen(tx_tilemap, 15);
+	tilemap_set_transparent_pen(state->tx_tilemap, 15);
 
-	tilemap_set_scrolldx(bg_tilemap, 16, 143);
-	tilemap_set_scrolldy(bg_tilemap,  0, -32);
+	tilemap_set_scrolldx(state->bg_tilemap, 16, 143);
+	tilemap_set_scrolldy(state->bg_tilemap,  0, -32);
 
-	tx_tile_offset = 0;
+	state->tx_tile_offset = 0;
 
-	is_psychos = 0;
+	state->is_psychos = 0;
 }
 
 VIDEO_START( psychos )
 {
+	snk_state *state = machine->driver_data<snk_state>();
+
 	VIDEO_START_CALL(gwar);
-	is_psychos = 1;
+	state->is_psychos = 1;
 }
 
 VIDEO_START( tdfever )
@@ -379,79 +398,107 @@
 
 WRITE8_HANDLER( snk_tx_videoram_w )
 {
-	snk_tx_videoram[offset] = data;
-	tilemap_mark_tile_dirty(tx_tilemap, offset);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->tx_videoram[offset] = data;
+	tilemap_mark_tile_dirty(state->tx_tilemap, offset);
 }
 
 WRITE8_HANDLER( marvins_fg_videoram_w )
 {
-	snk_fg_videoram[offset] = data;
-	tilemap_mark_tile_dirty(fg_tilemap, offset);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->fg_videoram[offset] = data;
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset);
 }
 
 WRITE8_HANDLER( marvins_bg_videoram_w )
 {
-	snk_bg_videoram[offset] = data;
-	tilemap_mark_tile_dirty(bg_tilemap, offset);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_videoram[offset] = data;
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset);
 }
 
 WRITE8_HANDLER( snk_bg_videoram_w )
 {
-	snk_bg_videoram[offset] = data;
-	tilemap_mark_tile_dirty(bg_tilemap, offset >> 1);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_videoram[offset] = data;
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset >> 1);
 }
 
 
 WRITE8_HANDLER( snk_fg_scrollx_w )
 {
-	fg_scrollx = (fg_scrollx & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->fg_scrollx = (state->fg_scrollx & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_fg_scrolly_w )
 {
-	fg_scrolly = (fg_scrolly & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->fg_scrolly = (state->fg_scrolly & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_bg_scrollx_w )
 {
-	bg_scrollx = (bg_scrollx & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrollx = (state->bg_scrollx & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_bg_scrolly_w )
 {
-	bg_scrolly = (bg_scrolly & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrolly = (state->bg_scrolly & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_sp16_scrollx_w )
 {
-	sp16_scrollx = (sp16_scrollx & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp16_scrollx = (state->sp16_scrollx & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_sp16_scrolly_w )
 {
-	sp16_scrolly = (sp16_scrolly & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp16_scrolly = (state->sp16_scrolly & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_sp32_scrollx_w )
 {
-	sp32_scrollx = (sp32_scrollx & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp32_scrollx = (state->sp32_scrollx & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_sp32_scrolly_w )
 {
-	sp32_scrolly = (sp32_scrolly & ~0xff) | data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp32_scrolly = (state->sp32_scrolly & ~0xff) | data;
 }
 
 WRITE8_HANDLER( snk_sprite_split_point_w )
 {
-	sprite_split_point = data;
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sprite_split_point = data;
 }
 
 
 WRITE8_HANDLER( marvins_palette_bank_w )
 {
-	tilemap_set_palette_offset(bg_tilemap, data & 0x70);
-	tilemap_set_palette_offset(fg_tilemap, (data & 0x07) << 4);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	tilemap_set_palette_offset(state->bg_tilemap, data & 0x70);
+	tilemap_set_palette_offset(state->fg_tilemap, (data & 0x07) << 4);
 }
 
 WRITE8_HANDLER( marvins_flipscreen_w )
@@ -463,22 +510,26 @@
 
 WRITE8_HANDLER( sgladiat_flipscreen_w )
 {
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x80);
 
-	tilemap_set_palette_offset(bg_tilemap, ((data & 0xf) ^ 8) << 4);
+	tilemap_set_palette_offset(state->bg_tilemap, ((data & 0xf) ^ 8) << 4);
 
 	// other bits unknown
 }
 
 WRITE8_HANDLER( hal21_flipscreen_w )
 {
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x80);
 
-	tilemap_set_palette_offset(bg_tilemap, ((data & 0xf) ^ 8) << 4);
-	if (bg_tile_offset != ((data & 0x20) << 3))
+	tilemap_set_palette_offset(state->bg_tilemap, ((data & 0xf) ^ 8) << 4);
+	if (state->bg_tile_offset != ((data & 0x20) << 3))
 	{
-		bg_tile_offset = (data & 0x20) << 3;
-		tilemap_mark_all_tiles_dirty(bg_tilemap);
+		state->bg_tile_offset = (data & 0x20) << 3;
+		tilemap_mark_all_tiles_dirty(state->bg_tilemap);
 	}
 
 	// other bits unknown
@@ -486,23 +537,29 @@
 
 WRITE8_HANDLER( marvins_scroll_msb_w )
 {
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x04) << 6);
-	fg_scrollx =   (fg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x01) << 8);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x04) << 6);
+	state->fg_scrollx =   (state->fg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( jcross_scroll_msb_w )
 {
-	bg_scrolly =   (bg_scrolly   & 0xff) | ((data & 0x10) << 4);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x08) << 5);
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x01) << 8);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrolly =   (state->bg_scrolly   & 0xff) | ((data & 0x10) << 4);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x08) << 5);
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( sgladiat_scroll_msb_w )
 {
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x01) << 8);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( aso_videoattrs_w )
@@ -519,12 +576,14 @@
         -------X    scrollx MSB (sprites)
     */
 
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x20);
 
-	bg_scrolly =   (bg_scrolly   & 0xff) | ((data & 0x10) << 4);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x08) << 5);
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x01) << 8);
+	state->bg_scrolly =   (state->bg_scrolly   & 0xff) | ((data & 0x10) << 4);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x08) << 5);
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( tnk3_videoattrs_w )
@@ -541,42 +600,50 @@
         -------X    scrollx MSB (sprites)
     */
 
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x80);
 
-	if (tx_tile_offset != ((data & 0x40) << 2))
+	if (state->tx_tile_offset != ((data & 0x40) << 2))
 	{
-		tx_tile_offset = (data & 0x40) << 2;
-		tilemap_mark_all_tiles_dirty(tx_tilemap);
+		state->tx_tile_offset = (data & 0x40) << 2;
+		tilemap_mark_all_tiles_dirty(state->tx_tilemap);
 	}
 
-	bg_scrolly =   (bg_scrolly   & 0xff) | ((data & 0x10) << 4);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x08) << 5);
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x01) << 8);
+	state->bg_scrolly =   (state->bg_scrolly   & 0xff) | ((data & 0x10) << 4);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x08) << 5);
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( aso_bg_bank_w )
 {
-	tilemap_set_palette_offset(bg_tilemap, ((data & 0xf) ^ 8) << 4);
-	if (bg_tile_offset != ((data & 0x30) << 4))
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	tilemap_set_palette_offset(state->bg_tilemap, ((data & 0xf) ^ 8) << 4);
+	if (state->bg_tile_offset != ((data & 0x30) << 4))
 	{
-		bg_tile_offset = (data & 0x30) << 4;
-		tilemap_mark_all_tiles_dirty(bg_tilemap);
+		state->bg_tile_offset = (data & 0x30) << 4;
+		tilemap_mark_all_tiles_dirty(state->bg_tilemap);
 	}
 }
 
 WRITE8_HANDLER( ikari_bg_scroll_msb_w )
 {
-	bg_scrollx = (bg_scrollx & 0xff) | ((data & 0x02) << 7);
-	bg_scrolly = (bg_scrolly & 0xff) | ((data & 0x01) << 8);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->bg_scrollx = (state->bg_scrollx & 0xff) | ((data & 0x02) << 7);
+	state->bg_scrolly = (state->bg_scrolly & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( ikari_sp_scroll_msb_w )
 {
-	sp32_scrollx = (sp32_scrollx & 0xff) | ((data & 0x20) << 3);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x10) << 4);
-	sp32_scrolly = (sp32_scrolly & 0xff) | ((data & 0x08) << 5);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x04) << 6);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp32_scrollx = (state->sp32_scrollx & 0xff) | ((data & 0x20) << 3);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x10) << 4);
+	state->sp32_scrolly = (state->sp32_scrolly & 0xff) | ((data & 0x08) << 5);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x04) << 6);
 }
 
 WRITE8_HANDLER( ikari_unknown_video_w )
@@ -587,70 +654,84 @@
        hard flags test and the test grid.
        Changing palette bank is necessary to fix colors in test mode. */
 
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 if (data != 0x20 &&	// normal
 	data != 0x31 &&	// ikari test
 	data != 0xaa)	// victroad spurious during boot
 	popmessage("attrs %02x contact MAMEDEV", data);
 
-	tilemap_set_palette_offset(tx_tilemap, (data & 0x01) << 4);
-	if (tx_tile_offset != ((data & 0x10) << 4))
+	tilemap_set_palette_offset(state->tx_tilemap, (data & 0x01) << 4);
+	if (state->tx_tile_offset != ((data & 0x10) << 4))
 	{
-		tx_tile_offset = (data & 0x10) << 4;
-		tilemap_mark_all_tiles_dirty(tx_tilemap);
+		state->tx_tile_offset = (data & 0x10) << 4;
+		tilemap_mark_all_tiles_dirty(state->tx_tilemap);
 	}
 }
 
 WRITE8_HANDLER( gwar_tx_bank_w )
 {
-	tilemap_set_palette_offset(tx_tilemap, (data & 0xf) << 4);
-	if (tx_tile_offset != ((data & 0x30) << 4))
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	tilemap_set_palette_offset(state->tx_tilemap, (data & 0xf) << 4);
+	if (state->tx_tile_offset != ((data & 0x30) << 4))
 	{
-		tx_tile_offset = (data & 0x30) << 4;
-		tilemap_mark_all_tiles_dirty(tx_tilemap);
+		state->tx_tile_offset = (data & 0x30) << 4;
+		tilemap_mark_all_tiles_dirty(state->tx_tilemap);
 	}
 
-	if (is_psychos)
-		tilemap_set_palette_offset(bg_tilemap, (data & 0x80));
+	if (state->is_psychos)
+		tilemap_set_palette_offset(state->bg_tilemap, (data & 0x80));
 }
 
 WRITE8_HANDLER( gwar_videoattrs_w )
 {
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x04);
 
-	sp32_scrollx = (sp32_scrollx & 0xff) | ((data & 0x80) << 1);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x40) << 2);
-	sp32_scrolly = (sp32_scrolly & 0xff) | ((data & 0x20) << 3);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x10) << 4);
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	bg_scrolly =   (bg_scrolly   & 0xff) | ((data & 0x01) << 8);
+	state->sp32_scrollx = (state->sp32_scrollx & 0xff) | ((data & 0x80) << 1);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x40) << 2);
+	state->sp32_scrolly = (state->sp32_scrolly & 0xff) | ((data & 0x20) << 3);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x10) << 4);
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->bg_scrolly =   (state->bg_scrolly   & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( gwara_videoattrs_w )
 {
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	flip_screen_set(space->machine, data & 0x10);
 
-	bg_scrollx =   (bg_scrollx   & 0xff) | ((data & 0x02) << 7);
-	bg_scrolly =   (bg_scrolly   & 0xff) | ((data & 0x01) << 8);
+	state->bg_scrollx =   (state->bg_scrollx   & 0xff) | ((data & 0x02) << 7);
+	state->bg_scrolly =   (state->bg_scrolly   & 0xff) | ((data & 0x01) << 8);
 }
 
 WRITE8_HANDLER( gwara_sp_scroll_msb_w )
 {
-	sp32_scrollx = (sp32_scrollx & 0xff) | ((data & 0x20) << 3);
-	sp16_scrollx = (sp16_scrollx & 0xff) | ((data & 0x10) << 4);
-	sp32_scrolly = (sp32_scrolly & 0xff) | ((data & 0x08) << 5);
-	sp16_scrolly = (sp16_scrolly & 0xff) | ((data & 0x04) << 6);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp32_scrollx = (state->sp32_scrollx & 0xff) | ((data & 0x20) << 3);
+	state->sp16_scrollx = (state->sp16_scrollx & 0xff) | ((data & 0x10) << 4);
+	state->sp32_scrolly = (state->sp32_scrolly & 0xff) | ((data & 0x08) << 5);
+	state->sp16_scrolly = (state->sp16_scrolly & 0xff) | ((data & 0x04) << 6);
 }
 
 WRITE8_HANDLER( tdfever_sp_scroll_msb_w )
 {
-	sp32_scrolly = (sp32_scrolly & 0xff) | ((data & 0x80) << 1);
-	sp32_scrollx = (sp32_scrollx & 0xff) | ((data & 0x40) << 2);
+	snk_state *state = space->machine->driver_data<snk_state>();
+
+	state->sp32_scrolly = (state->sp32_scrolly & 0xff) | ((data & 0x80) << 1);
+	state->sp32_scrollx = (state->sp32_scrollx & 0xff) | ((data & 0x40) << 2);
 }
 
 WRITE8_HANDLER( tdfever_spriteram_w )
 {
+	snk_state *state = space->machine->driver_data<snk_state>();
+
 	/*  partial updates avoid flickers in the fsoccer radar. */
-	if (offset < 0x80 && space->machine->generic.spriteram.u8[offset] != data)
+	if (offset < 0x80 && state->spriteram[offset] != data)
 	{
 		int vpos = space->machine->primary_screen->vpos();
 
@@ -658,7 +739,7 @@
 			space->machine->primary_screen->update_partial(vpos - 1);
 	}
 
-	space->machine->generic.spriteram.u8[offset] = data;
+	state->spriteram[offset] = data;
 }
 
 /**************************************************************************************/
@@ -666,11 +747,12 @@
 static void marvins_draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect,
 		const int scrollx, const int scrolly, const int from, const int to)
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	const gfx_element *gfx = machine->gfx[3];
 	const UINT8 *source, *finish;
 
-	source = machine->generic.spriteram.u8 + from*4;
-	finish = machine->generic.spriteram.u8 + to*4;
+	source = state->spriteram + from*4;
+	finish = state->spriteram + to*4;
 
 	while( source<finish )
 	{
@@ -700,7 +782,7 @@
 			color,
 			flipx, flipy,
 			sx, sy,
-			drawmode_table, machine->shadow_table);
+			state->drawmode_table, machine->shadow_table);
 
 		source+=4;
 	}
@@ -709,7 +791,8 @@
 
 static void tnk3_draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, const int xscroll, const int yscroll)
 {
-	UINT8 *spriteram = machine->generic.spriteram.u8;
+	snk_state *state = machine->driver_data<snk_state>();
+	UINT8 *spriteram = state->spriteram;
 	const gfx_element *gfx = machine->gfx[2];
 	const int size = gfx->width;
 	int tile_number, attributes, color, sx, sy;
@@ -722,7 +805,7 @@
 	/* sgladiat and tnk3 have 512 tiles, bit 6 is bank and bit 5 is y-flip */
 	/* athena has 1024 tiles, bit 6 and bit 5 are bank */
 
-	for (offs = 0; offs < num_sprites*4; offs += 4)
+	for (offs = 0; offs < state->num_sprites*4; offs += 4)
 	{
 		tile_number = spriteram[offs+1];
 		attributes  = spriteram[offs+3];
@@ -757,16 +840,16 @@
 		}
 
 		sx &= 0x1ff;
-		sy &= yscroll_mask;	// sgladiat apparently has only 256 pixels of vertical scrolling range
+		sy &= state->yscroll_mask;	// sgladiat apparently has only 256 pixels of vertical scrolling range
 		if (sx > 512-size) sx -= 512;
-		if (sy > (yscroll_mask+1)-size) sy -= (yscroll_mask+1);
+		if (sy > (state->yscroll_mask+1)-size) sy -= (state->yscroll_mask+1);
 
 		drawgfx_transtable(bitmap,cliprect,gfx,
 				tile_number,
 				color,
 				xflip,yflip,
 				sx,sy,
-				drawmode_table, machine->shadow_table);
+				state->drawmode_table, machine->shadow_table);
 	}
 }
 
@@ -774,6 +857,7 @@
 static void ikari_draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect,
 		const int start, const int xscroll, const int yscroll, const UINT8 *source, const int gfxnum )
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	const gfx_element *gfx = machine->gfx[gfxnum];
 	const int size = gfx->width;
 	int tile_number, attributes, color, sx, sy;
@@ -812,7 +896,7 @@
 				color,
 				0,0,
 				sx,sy,
-				drawmode_table, machine->shadow_table);
+				state->drawmode_table, machine->shadow_table);
 	}
 }
 
@@ -845,6 +929,7 @@
 static void tdfever_draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect,
 		const int xscroll, const int yscroll, const UINT8 *source, const int gfxnum, const int hw_xflip, const int from, const int to )
 {
+	snk_state *state = machine->driver_data<snk_state>();
 	const gfx_element *gfx = machine->gfx[gfxnum];
 	const int size = gfx->width;
 	int tile_number, attributes, sx, sy, color;
@@ -899,7 +984,7 @@
 				color,
 				flipx,flipy,
 				sx,sy,
-				drawmode_table, machine->shadow_table);
+				state->drawmode_table, machine->shadow_table);
 	}
 }
 
@@ -907,16 +992,18 @@
 
 VIDEO_UPDATE( marvins )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, bg_scrollx);
-	tilemap_set_scrolly(bg_tilemap, 0, bg_scrolly);
-	tilemap_set_scrollx(fg_tilemap, 0, fg_scrollx);
-	tilemap_set_scrolly(fg_tilemap, 0, fg_scrolly);
-
-	tilemap_draw(bitmap,cliprect,bg_tilemap,0 ,0);
-	marvins_draw_sprites(screen->machine,bitmap,cliprect, sp16_scrollx, sp16_scrolly, 0, sprite_split_point>>2 );
-	tilemap_draw(bitmap,cliprect,fg_tilemap,0 ,0);
-	marvins_draw_sprites(screen->machine,bitmap,cliprect, sp16_scrollx, sp16_scrolly, sprite_split_point>>2, 25 );
-	tilemap_draw(bitmap,cliprect,tx_tilemap,0 ,0);
+	snk_state *state = screen->machine->driver_data<snk_state>();
+
+	tilemap_set_scrollx(state->bg_tilemap, 0, state->bg_scrollx);
+	tilemap_set_scrolly(state->bg_tilemap, 0, state->bg_scrolly);
+	tilemap_set_scrollx(state->fg_tilemap, 0, state->fg_scrollx);
+	tilemap_set_scrolly(state->fg_tilemap, 0, state->fg_scrolly);
+
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
+	marvins_draw_sprites(screen->machine, bitmap, cliprect, state->sp16_scrollx, state->sp16_scrolly, 0, state->sprite_split_point>>2);
+	tilemap_draw(bitmap, cliprect, state->fg_tilemap, 0, 0);
+	marvins_draw_sprites(screen->machine, bitmap, cliprect, state->sp16_scrollx, state->sp16_scrolly, state->sprite_split_point>>2, 25);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 
 	return 0;
 }
@@ -924,12 +1011,14 @@
 
 VIDEO_UPDATE( tnk3 )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, bg_scrollx);
-	tilemap_set_scrolly(bg_tilemap, 0, bg_scrolly);
+	snk_state *state = screen->machine->driver_data<snk_state>();
+
+	tilemap_set_scrollx(state->bg_tilemap, 0, state->bg_scrollx);
+	tilemap_set_scrolly(state->bg_tilemap, 0, state->bg_scrolly);
 
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
-	tnk3_draw_sprites(screen->machine, bitmap, cliprect, sp16_scrollx, sp16_scrolly);
-	tilemap_draw(bitmap, cliprect, tx_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
+	tnk3_draw_sprites(screen->machine, bitmap, cliprect, state->sp16_scrollx, state->sp16_scrolly);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 
 	return 0;
 }
@@ -937,32 +1026,36 @@
 
 VIDEO_UPDATE( ikari )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, bg_scrollx);
-	tilemap_set_scrolly(bg_tilemap, 0, bg_scrolly);
+	snk_state *state = screen->machine->driver_data<snk_state>();
 
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
+	tilemap_set_scrollx(state->bg_tilemap, 0, state->bg_scrollx);
+	tilemap_set_scrolly(state->bg_tilemap, 0, state->bg_scrolly);
 
-	ikari_draw_sprites(screen->machine, bitmap, cliprect,  0, sp16_scrollx, sp16_scrolly, screen->machine->generic.spriteram.u8 + 0x800, 2 );
-	ikari_draw_sprites(screen->machine, bitmap, cliprect,  0, sp32_scrollx, sp32_scrolly, screen->machine->generic.spriteram.u8,         3 );
-	ikari_draw_sprites(screen->machine, bitmap, cliprect, 25, sp16_scrollx, sp16_scrolly, screen->machine->generic.spriteram.u8 + 0x800, 2 );
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
 
-	tilemap_draw(bitmap, cliprect, tx_tilemap, 0, 0);
+	ikari_draw_sprites(screen->machine, bitmap, cliprect,  0, state->sp16_scrollx, state->sp16_scrolly, state->spriteram + 0x800, 2 );
+	ikari_draw_sprites(screen->machine, bitmap, cliprect,  0, state->sp32_scrollx, state->sp32_scrolly, state->spriteram,         3 );
+	ikari_draw_sprites(screen->machine, bitmap, cliprect, 25, state->sp16_scrollx, state->sp16_scrolly, state->spriteram + 0x800, 2 );
+
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 	return 0;
 }
 
 
 VIDEO_UPDATE( gwar )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, bg_scrollx);
-	tilemap_set_scrolly(bg_tilemap, 0, bg_scrolly);
+	snk_state *state = screen->machine->driver_data<snk_state>();
+
+	tilemap_set_scrollx(state->bg_tilemap, 0, state->bg_scrollx);
+	tilemap_set_scrolly(state->bg_tilemap, 0, state->bg_scrolly);
 
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
 
-	tdfever_draw_sprites(screen->machine, bitmap, cliprect, sp16_scrollx, sp16_scrolly, screen->machine->generic.spriteram.u8 + 0x800, 2, 0, 0, sprite_split_point );
-	tdfever_draw_sprites(screen->machine, bitmap, cliprect, sp32_scrollx, sp32_scrolly, screen->machine->generic.spriteram.u8,         3, 0, 0, 32 );
-	tdfever_draw_sprites(screen->machine, bitmap, cliprect, sp16_scrollx, sp16_scrolly, screen->machine->generic.spriteram.u8 + 0x800, 2, 0, sprite_split_point, 64 );
+	tdfever_draw_sprites(screen->machine, bitmap, cliprect, state->sp16_scrollx, state->sp16_scrolly, state->spriteram + 0x800, 2, 0, 0, state->sprite_split_point );
+	tdfever_draw_sprites(screen->machine, bitmap, cliprect, state->sp32_scrollx, state->sp32_scrolly, state->spriteram,         3, 0, 0, 32 );
+	tdfever_draw_sprites(screen->machine, bitmap, cliprect, state->sp16_scrollx, state->sp16_scrolly, state->spriteram + 0x800, 2, 0, state->sprite_split_point, 64 );
 
-	tilemap_draw(bitmap, cliprect, tx_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 
 	return 0;
 }
@@ -970,14 +1063,16 @@
 
 VIDEO_UPDATE( tdfever )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, bg_scrollx);
-	tilemap_set_scrolly(bg_tilemap, 0, bg_scrolly);
+	snk_state *state = screen->machine->driver_data<snk_state>();
+
+	tilemap_set_scrollx(state->bg_tilemap, 0, state->bg_scrollx);
+	tilemap_set_scrolly(state->bg_tilemap, 0, state->bg_scrolly);
 
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
 
-	tdfever_draw_sprites(screen->machine, bitmap, cliprect, sp32_scrollx, sp32_scrolly, screen->machine->generic.spriteram.u8, 2, 1, 0, 32 );
+	tdfever_draw_sprites(screen->machine, bitmap, cliprect, state->sp32_scrollx, state->sp32_scrolly, state->spriteram, 2, 1, 0, 32 );
 
-	tilemap_draw(bitmap, cliprect, tx_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 
 	return 0;
 }
diff -Nru src-old/mame/video/snk6502.c src/mame/video/snk6502.c
--- src-old/mame/video/snk6502.c	2010-06-27 23:40:44.000000000 -0700
+++ src/mame/video/snk6502.c	2010-08-26 20:55:49.000000000 -0700
@@ -10,19 +10,6 @@
 #include "includes/snk6502.h"
 
 
-UINT8 *snk6502_videoram;
-UINT8 *snk6502_colorram;
-UINT8 *snk6502_videoram2;
-UINT8 *snk6502_charram;
-
-static int charbank;
-static int backcolor;
-
-static tilemap_t *bg_tilemap;
-static tilemap_t *fg_tilemap;
-
-static rgb_t palette[64];
-
 #define TOTAL_COLORS(m,gfxn) ((m)->gfx[gfxn]->total_colors * (m)->gfx[gfxn]->color_granularity)
 #define COLOR(m,gfxn,offs) ((m)->config->m_gfxdecodeinfo[gfxn].color_codes_start + offs)
 
@@ -37,6 +24,7 @@
 ***************************************************************************/
 PALETTE_INIT( snk6502 )
 {
+	snk6502_state *state = machine->driver_data<snk6502_state>();
 	int i;
 
 	for (i = 0; i < machine->total_colors(); i++)
@@ -45,71 +33,79 @@
 
 		/* red component */
 
-        bit0 = (*color_prom >> 0) & 0x01;
-        bit1 = (*color_prom >> 1) & 0x01;
-        bit2 = (*color_prom >> 2) & 0x01;
+		bit0 = (*color_prom >> 0) & 0x01;
+		bit1 = (*color_prom >> 1) & 0x01;
+		bit2 = (*color_prom >> 2) & 0x01;
 
 		r = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
 		/* green component */
 
-        bit0 = (*color_prom >> 3) & 0x01;
-        bit1 = (*color_prom >> 4) & 0x01;
-        bit2 = (*color_prom >> 5) & 0x01;
+		bit0 = (*color_prom >> 3) & 0x01;
+		bit1 = (*color_prom >> 4) & 0x01;
+		bit2 = (*color_prom >> 5) & 0x01;
 
 		g = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
 		/* blue component */
 
 		bit0 = 0;
-        bit1 = (*color_prom >> 6) & 0x01;
-        bit2 = (*color_prom >> 7) & 0x01;
+		bit1 = (*color_prom >> 6) & 0x01;
+		bit2 = (*color_prom >> 7) & 0x01;
 
 		b = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
-		palette[i] = MAKE_RGB(r, g, b);
+		state->palette[i] = MAKE_RGB(r, g, b);
 
 		color_prom++;
 	}
 
-	backcolor = 0;	/* background color can be changed by the game */
+	state->backcolor = 0;	/* background color can be changed by the game */
 
 	for (i = 0; i < TOTAL_COLORS(machine,0); i++)
-		palette_set_color(machine, COLOR(machine, 0, i), palette[i]);
+		palette_set_color(machine, COLOR(machine, 0, i), state->palette[i]);
 
 	for (i = 0; i < TOTAL_COLORS(machine,1); i++)
 	{
 		if (i % 4 == 0)
-			palette_set_color(machine, COLOR(machine, 1, i), palette[4 * backcolor + 0x20]);
+			palette_set_color(machine, COLOR(machine, 1, i), state->palette[4 * state->backcolor + 0x20]);
 		else
-			palette_set_color(machine, COLOR(machine, 1, i), palette[i + 0x20]);
+			palette_set_color(machine, COLOR(machine, 1, i), state->palette[i + 0x20]);
 	}
 }
 
 WRITE8_HANDLER( snk6502_videoram_w )
 {
-	snk6502_videoram[offset] = data;
-	tilemap_mark_tile_dirty(bg_tilemap, offset);
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	state->videoram[offset] = data;
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset);
 }
 
 WRITE8_HANDLER( snk6502_videoram2_w )
 {
-	snk6502_videoram2[offset] = data;
-	tilemap_mark_tile_dirty(fg_tilemap, offset);
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	state->videoram2[offset] = data;
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset);
 }
 
 WRITE8_HANDLER( snk6502_colorram_w )
 {
-	snk6502_colorram[offset] = data;
-	tilemap_mark_tile_dirty(bg_tilemap, offset);
-	tilemap_mark_tile_dirty(fg_tilemap, offset);
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	state->colorram[offset] = data;
+	tilemap_mark_tile_dirty(state->bg_tilemap, offset);
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset);
 }
 
 WRITE8_HANDLER( snk6502_charram_w )
 {
-	if (snk6502_charram[offset] != data)
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	if (state->charram[offset] != data)
 	{
-		snk6502_charram[offset] = data;
+		state->charram[offset] = data;
 		gfx_element_mark_dirty(space->machine->gfx[0], (offset/8) % 256);
 	}
 }
@@ -117,27 +113,28 @@
 
 WRITE8_HANDLER( snk6502_flipscreen_w )
 {
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
 	int bank;
 
 	/* bits 0-2 select background color */
 
-	if (backcolor != (data & 7))
+	if (state->backcolor != (data & 7))
 	{
 		int i;
 
-		backcolor = data & 7;
+		state->backcolor = data & 7;
 
 		for (i = 0;i < 32;i += 4)
-			palette_set_color(space->machine, COLOR(space->machine, 1, i), palette[4 * backcolor + 0x20]);
+			palette_set_color(space->machine, COLOR(space->machine, 1, i), state->palette[4 * state->backcolor + 0x20]);
 	}
 
 	/* bit 3 selects char bank */
 
 	bank = (~data & 0x08) >> 3;
 
-	if (charbank != bank)
+	if (state->charbank != bank)
 	{
-		charbank = bank;
+		state->charbank = bank;
 		tilemap_mark_all_tiles_dirty_all(space->machine);
 	}
 
@@ -152,45 +149,66 @@
 
 WRITE8_HANDLER( snk6502_scrollx_w )
 {
-	tilemap_set_scrollx(bg_tilemap, 0, data);
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	tilemap_set_scrollx(state->bg_tilemap, 0, data);
 }
 
 WRITE8_HANDLER( snk6502_scrolly_w )
 {
-	tilemap_set_scrolly(bg_tilemap, 0, data);
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
+	tilemap_set_scrolly(state->bg_tilemap, 0, data);
 }
 
 
 static TILE_GET_INFO( get_bg_tile_info )
 {
-	int code = snk6502_videoram[tile_index] + 256 * charbank;
-	int color = (snk6502_colorram[tile_index] & 0x38) >> 3;
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+	int code = state->videoram[tile_index] + 256 * state->charbank;
+	int color = (state->colorram[tile_index] & 0x38) >> 3;
 
 	SET_TILE_INFO(1, code, color, 0);
 }
 
 static TILE_GET_INFO( get_fg_tile_info )
 {
-	int code = snk6502_videoram2[tile_index];
-	int color = snk6502_colorram[tile_index] & 0x07;
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+	int code = state->videoram2[tile_index];
+	int color = state->colorram[tile_index] & 0x07;
 
 	SET_TILE_INFO(0, code, color, 0);
 }
 
 VIDEO_START( snk6502 )
 {
-	bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
-	fg_tilemap = tilemap_create(machine, get_fg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	snk6502_state *state = machine->driver_data<snk6502_state>();
 
-	tilemap_set_transparent_pen(fg_tilemap, 0);
+	state->bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	state->fg_tilemap = tilemap_create(machine, get_fg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 
-	gfx_element_set_source(machine->gfx[0], snk6502_charram);
+	tilemap_set_transparent_pen(state->fg_tilemap, 0);
+
+	gfx_element_set_source(machine->gfx[0], state->charram);
+}
+
+VIDEO_START( pballoon )
+{
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+
+	VIDEO_START_CALL( snk6502 );
+
+	tilemap_set_scrolldy(state->bg_tilemap, -24, 0);
+	tilemap_set_scrolldy(state->fg_tilemap, -24, 0);
 }
 
+
 VIDEO_UPDATE( snk6502 )
 {
-	tilemap_draw(bitmap, cliprect, bg_tilemap, 0, 0);
-	tilemap_draw(bitmap, cliprect, fg_tilemap, 0, 0);
+	snk6502_state *state = screen->machine->driver_data<snk6502_state>();
+
+	tilemap_draw(bitmap, cliprect, state->bg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->fg_tilemap, 0, 0);
 	return 0;
 }
 
@@ -198,6 +216,7 @@
 
 PALETTE_INIT( satansat )
 {
+	snk6502_state *state = machine->driver_data<snk6502_state>();
 	int i;
 
 	for (i = 0; i < machine->total_colors(); i++)
@@ -206,44 +225,44 @@
 
 		/* red component */
 
-        bit0 = (*color_prom >> 0) & 0x01;
-        bit1 = (*color_prom >> 1) & 0x01;
-        bit2 = (*color_prom >> 2) & 0x01;
+		bit0 = (*color_prom >> 0) & 0x01;
+		bit1 = (*color_prom >> 1) & 0x01;
+		bit2 = (*color_prom >> 2) & 0x01;
 
 		r = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
 		/* green component */
 
-        bit0 = (*color_prom >> 3) & 0x01;
-        bit1 = (*color_prom >> 4) & 0x01;
-        bit2 = (*color_prom >> 5) & 0x01;
+		bit0 = (*color_prom >> 3) & 0x01;
+		bit1 = (*color_prom >> 4) & 0x01;
+		bit2 = (*color_prom >> 5) & 0x01;
 
 		g = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
 		/* blue component */
 
 		bit0 = 0;
-        bit1 = (*color_prom >> 6) & 0x01;
-        bit2 = (*color_prom >> 7) & 0x01;
+		bit1 = (*color_prom >> 6) & 0x01;
+		bit2 = (*color_prom >> 7) & 0x01;
 
 		b = 0x21 * bit0 + 0x47 * bit1 + 0x97 * bit2;
 
-		palette[i] = MAKE_RGB(r, g, b);
+		state->palette[i] = MAKE_RGB(r, g, b);
 
 		color_prom++;
 	}
 
-	backcolor = 0;	/* background color can be changed by the game */
+	state->backcolor = 0;	/* background color can be changed by the game */
 
 	for (i = 0; i < TOTAL_COLORS(machine,0); i++)
-		palette_set_color(machine, COLOR(machine, 0, i), palette[4 * (i % 4) + (i / 4)]);
+		palette_set_color(machine, COLOR(machine, 0, i), state->palette[4 * (i % 4) + (i / 4)]);
 
 	for (i = 0; i < TOTAL_COLORS(machine,1); i++)
 	{
 		if (i % 4 == 0)
-			palette_set_color(machine, COLOR(machine, 1, i), palette[backcolor + 0x10]);
+			palette_set_color(machine, COLOR(machine, 1, i), state->palette[state->backcolor + 0x10]);
 		else
-			palette_set_color(machine, COLOR(machine, 1, i), palette[4 * (i % 4) + (i / 4) + 0x10]);
+			palette_set_color(machine, COLOR(machine, 1, i), state->palette[4 * (i % 4) + (i / 4) + 0x10]);
 	}
 }
 
@@ -268,41 +287,47 @@
 
 WRITE8_HANDLER( satansat_backcolor_w )
 {
+	snk6502_state *state = space->machine->driver_data<snk6502_state>();
+
 	/* bits 0-1 select background color. Other bits unused. */
 
-	if (backcolor != (data & 0x03))
+	if (state->backcolor != (data & 0x03))
 	{
 		int i;
 
-		backcolor = data & 0x03;
+		state->backcolor = data & 0x03;
 
 		for (i = 0; i < 16; i += 4)
-			palette_set_color(space->machine, COLOR(space->machine, 1, i), palette[backcolor + 0x10]);
+			palette_set_color(space->machine, COLOR(space->machine, 1, i), state->palette[state->backcolor + 0x10]);
 	}
 }
 
 static TILE_GET_INFO( satansat_get_bg_tile_info )
 {
-	int code = snk6502_videoram[tile_index];
-	int color = (snk6502_colorram[tile_index] & 0x0c) >> 2;
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+	int code = state->videoram[tile_index];
+	int color = (state->colorram[tile_index] & 0x0c) >> 2;
 
 	SET_TILE_INFO(1, code, color, 0);
 }
 
 static TILE_GET_INFO( satansat_get_fg_tile_info )
 {
-	int code = snk6502_videoram2[tile_index];
-	int color = snk6502_colorram[tile_index] & 0x03;
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+	int code = state->videoram2[tile_index];
+	int color = state->colorram[tile_index] & 0x03;
 
 	SET_TILE_INFO(0, code, color, 0);
 }
 
 VIDEO_START( satansat )
 {
-	bg_tilemap = tilemap_create(machine, satansat_get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
-	fg_tilemap = tilemap_create(machine, satansat_get_fg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	snk6502_state *state = machine->driver_data<snk6502_state>();
+
+	state->bg_tilemap = tilemap_create(machine, satansat_get_bg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
+	state->fg_tilemap = tilemap_create(machine, satansat_get_fg_tile_info, tilemap_scan_rows, 8, 8, 32, 32);
 
-	tilemap_set_transparent_pen(fg_tilemap, 0);
+	tilemap_set_transparent_pen(state->fg_tilemap, 0);
 
-	gfx_element_set_source(machine->gfx[0], snk6502_charram);
+	gfx_element_set_source(machine->gfx[0], state->charram);
 }
diff -Nru src-old/mame/video/snk68.c src/mame/video/snk68.c
--- src-old/mame/video/snk68.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/snk68.c	2010-08-26 20:55:49.000000000 -0700
@@ -13,13 +13,8 @@
 ***************************************************************************/
 
 #include "emu.h"
+#include "includes/snk68.h"
 
-UINT16* pow_fg_videoram;
-
-static int sprite_flip_axis;
-static tilemap_t *fg_tilemap;
-static int flipscreen;
-static UINT32 fg_tile_offset;
 
 /***************************************************************************
 
@@ -29,15 +24,17 @@
 
 static TILE_GET_INFO( get_pow_tile_info )
 {
-	int tile = fg_tile_offset + (pow_fg_videoram[2*tile_index] & 0xff);
-	int color = pow_fg_videoram[2*tile_index+1] & 0x07;
+	snk68_state *state = machine->driver_data<snk68_state>();
+	int tile = state->fg_tile_offset + (state->pow_fg_videoram[2*tile_index] & 0xff);
+	int color = state->pow_fg_videoram[2*tile_index+1] & 0x07;
 
 	SET_TILE_INFO(0, tile, color, 0);
 }
 
 static TILE_GET_INFO( get_searchar_tile_info )
 {
-	int data = pow_fg_videoram[2*tile_index];
+	snk68_state *state = machine->driver_data<snk68_state>();
+	int data = state->pow_fg_videoram[2*tile_index];
 	int tile = data & 0x7ff;
 	int color = (data & 0x7000) >> 12;
 
@@ -55,23 +52,29 @@
 
 static void common_video_start(running_machine *machine)
 {
-	tilemap_set_transparent_pen(fg_tilemap,0);
+	snk68_state *state = machine->driver_data<snk68_state>();
+
+	tilemap_set_transparent_pen(state->fg_tilemap, 0);
 
-	tilemap_set_scrolldx(fg_tilemap, 0, machine->primary_screen->width() - 256);
-	tilemap_set_scrolldy(fg_tilemap, 0, machine->primary_screen->height() - 256);
+	tilemap_set_scrolldx(state->fg_tilemap, 0, machine->primary_screen->width() - 256);
+	tilemap_set_scrolldy(state->fg_tilemap, 0, machine->primary_screen->height() - 256);
 }
 
 VIDEO_START( pow )
 {
-	fg_tilemap = tilemap_create(machine, get_pow_tile_info,tilemap_scan_cols,8,8,32,32);
-	fg_tile_offset = 0;
+	snk68_state *state = machine->driver_data<snk68_state>();
+
+	state->fg_tilemap = tilemap_create(machine, get_pow_tile_info, tilemap_scan_cols, 8, 8, 32, 32);
+	state->fg_tile_offset = 0;
 
 	common_video_start(machine);
 }
 
 VIDEO_START( searchar )
 {
-	fg_tilemap = tilemap_create(machine, get_searchar_tile_info,tilemap_scan_cols,8,8,32,32);
+	snk68_state *state = machine->driver_data<snk68_state>();
+
+	state->fg_tilemap = tilemap_create(machine, get_searchar_tile_info, tilemap_scan_cols, 8, 8, 32, 32);
 
 	common_video_start(machine);
 }
@@ -84,17 +87,20 @@
 
 READ16_HANDLER( pow_spriteram_r )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
 	// streetsj expects the MSB of every 32-bit word to be FF. Presumably RAM
 	// exists only for 3 bytes out of 4 and the fourth is unmapped.
 	if (!(offset & 1))
-		return space->machine->generic.spriteram.u16[offset] | 0xff00;
+		return state->spriteram[offset] | 0xff00;
 	else
-		return space->machine->generic.spriteram.u16[offset];
+		return state->spriteram[offset];
 }
 
 WRITE16_HANDLER( pow_spriteram_w )
 {
-	UINT16 *spriteram16 = space->machine->generic.spriteram.u16;
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+	UINT16 *spriteram16 = state->spriteram;
 	UINT16 newword = spriteram16[offset];
 
 	if (!(offset & 1))
@@ -115,37 +121,44 @@
 
 READ16_HANDLER( pow_fg_videoram_r )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
 	// RAM is only 8-bit
-	return pow_fg_videoram[offset] | 0xff00;
+	return state->pow_fg_videoram[offset] | 0xff00;
 }
 
 WRITE16_HANDLER( pow_fg_videoram_w )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
 	data |= 0xff00;
-	COMBINE_DATA(&pow_fg_videoram[offset]);
-	tilemap_mark_tile_dirty(fg_tilemap, offset >> 1);
+	COMBINE_DATA(&state->pow_fg_videoram[offset]);
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset >> 1);
 }
 
 WRITE16_HANDLER( searchar_fg_videoram_w )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
+
 	// RAM is full 16-bit, though only half of it is used by the hardware
-	COMBINE_DATA(&pow_fg_videoram[offset]);
-	tilemap_mark_tile_dirty(fg_tilemap, offset >> 1);
+	COMBINE_DATA(&state->pow_fg_videoram[offset]);
+	tilemap_mark_tile_dirty(state->fg_tilemap, offset >> 1);
 }
 
 WRITE16_HANDLER( pow_flipscreen16_w )
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		flipscreen = data & 0x08;
-		tilemap_set_flip_all(space->machine, flipscreen ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
+		snk68_state *state = space->machine->driver_data<snk68_state>();
+		state->flipscreen = data & 0x08;
+		tilemap_set_flip_all(space->machine, state->flipscreen ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
 
-		sprite_flip_axis = data & 0x04;	// for streetsm? though might not be present on this board
+		state->sprite_flip_axis = data & 0x04;	// for streetsm? though might not be present on this board
 
-		if (fg_tile_offset != ((data & 0x70) << 4))
+		if (state->fg_tile_offset != ((data & 0x70) << 4))
 		{
-			fg_tile_offset = (data & 0x70) << 4;
-			tilemap_mark_all_tiles_dirty(fg_tilemap);
+			state->fg_tile_offset = (data & 0x70) << 4;
+			tilemap_mark_all_tiles_dirty(state->fg_tilemap);
 		}
 	}
 }
@@ -154,20 +167,23 @@
 {
 	if (ACCESSING_BITS_0_7)
 	{
-		flipscreen = data & 0x08;
-		tilemap_set_flip_all(space->machine, flipscreen ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
+		snk68_state *state = space->machine->driver_data<snk68_state>();
 
-		sprite_flip_axis = data & 0x04;
+		state->flipscreen = data & 0x08;
+		tilemap_set_flip_all(space->machine, state->flipscreen ? (TILEMAP_FLIPX | TILEMAP_FLIPY) : 0);
+
+		state->sprite_flip_axis = data & 0x04;
 	}
 }
 
 WRITE16_HANDLER( pow_paletteram16_word_w )
 {
+	snk68_state *state = space->machine->driver_data<snk68_state>();
 	UINT16 newword;
 	int r,g,b;
 
-	COMBINE_DATA(&space->machine->generic.paletteram.u16[offset]);
-	newword = space->machine->generic.paletteram.u16[offset];
+	COMBINE_DATA(&state->paletteram[offset]);
+	newword = state->paletteram[offset];
 
 	r = ((newword >> 7) & 0x1e) | ((newword >> 14) & 0x01);
 	g = ((newword >> 3) & 0x1e) | ((newword >> 13) & 0x01) ;
@@ -185,7 +201,10 @@
 
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, int group)
 {
-	UINT16 *spriteram16 = machine->generic.spriteram.u16;
+	snk68_state *state = machine->driver_data<snk68_state>();
+	UINT16 *spriteram16 = state->spriteram;
+	int flipscreen = state->flipscreen;
+	int sprite_flip_axis = state->sprite_flip_axis;
 	const UINT16* tiledata = &spriteram16[0x800*group];
 
 	// pow has 0x4000 tiles and independent x/y flipping
@@ -271,6 +290,8 @@
 
 VIDEO_UPDATE( pow )
 {
+	snk68_state *state = screen->machine->driver_data<snk68_state>();
+
 	bitmap_fill(bitmap, cliprect, 0x7ff);
 
 	/* This appears to be the correct priority order */
@@ -278,6 +299,6 @@
 	draw_sprites(screen->machine, bitmap, cliprect, 3);
 	draw_sprites(screen->machine, bitmap, cliprect, 1);
 
-	tilemap_draw(bitmap, cliprect, fg_tilemap, 0, 0);
+	tilemap_draw(bitmap, cliprect, state->fg_tilemap, 0, 0);
 	return 0;
 }
diff -Nru src-old/mame/video/srumbler.c src/mame/video/srumbler.c
--- src-old/mame/video/srumbler.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/srumbler.c	2010-08-19 00:26:14.000000000 -0700
@@ -170,7 +170,7 @@
 
 VIDEO_EOF( srumbler )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram_w(space,0,0);
 }
diff -Nru src-old/mame/video/stvvdp2.c src/mame/video/stvvdp2.c
--- src-old/mame/video/stvvdp2.c	2010-07-03 10:44:15.000000000 -0700
+++ src/mame/video/stvvdp2.c	2010-08-21 15:25:58.000000000 -0700
@@ -4912,7 +4912,7 @@
 		stv2_current_tilemap.window_control = 0;
 		fade_control = stv2_current_tilemap.fade_control;
 		stv2_current_tilemap.fade_control = 0;
-		profiler_mark_start(PROFILER_USER1);
+		g_profiler.start(PROFILER_USER1);
 		if ( LOG_VDP2 ) logerror( "Checking for cached RBG bitmap, cache_dirty = %d, memcmp() = %d\n", stv_rbg_cache_data.is_cache_dirty, memcmp(&stv_rbg_cache_data.layer_data[iRP-1],&stv2_current_tilemap,sizeof(stv2_current_tilemap)));
 		if ( (stv_rbg_cache_data.is_cache_dirty & iRP) ||
 			memcmp(&stv_rbg_cache_data.layer_data[iRP-1],&stv2_current_tilemap,sizeof(stv2_current_tilemap)) != 0 )
@@ -4931,7 +4931,7 @@
 				stv_rbg_cache_data.map_offset_max[iRP-1], stv_rbg_cache_data.tile_offset_min[iRP-1], stv_rbg_cache_data.tile_offset_max[iRP-1] );
 		}
 
-		profiler_mark_end();
+		g_profiler.stop();
 
 		stv2_current_tilemap.colour_calculation_enabled = colour_calculation_enabled;
 		if ( colour_calculation_enabled )
@@ -4952,9 +4952,9 @@
 
 		stv2_current_tilemap.fade_control = fade_control;
 
-		profiler_mark_start(PROFILER_USER2);
+		g_profiler.start(PROFILER_USER2);
 		stv_vdp2_copy_roz_bitmap(bitmap, stv_vdp2_roz_bitmap[iRP-1], &mycliprect, iRP, planesizex, planesizey, planerenderedsizex, planerenderedsizey );
-		profiler_mark_end();
+		g_profiler.stop();
 	}
 
 }
diff -Nru src-old/mame/video/taito_b.c src/mame/video/taito_b.c
--- src-old/mame/video/taito_b.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/taito_b.c	2010-08-21 15:25:58.000000000 -0700
@@ -28,7 +28,7 @@
 static void hitice_clear_pixel_bitmap( running_machine *machine )
 {
 	int i;
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	for (i = 0; i < 0x40000; i++)
 		hitice_pixelram_w(space, i, 0, 0xffff);
@@ -258,7 +258,7 @@
 	UINT8 video_control = tc0180vcu_get_videoctrl(state->tc0180vcu, 0);
 	UINT8 framebuffer_page = tc0180vcu_get_fb_page(state->tc0180vcu, 0);
 
-profiler_mark_start(PROFILER_USER1);
+g_profiler.start(PROFILER_USER1);
 
 	priority <<= 4;
 
@@ -266,7 +266,7 @@
 	{
 		if (priority)
 		{
-			profiler_mark_end();
+			g_profiler.stop();
 			return;
 		}
 
@@ -352,7 +352,7 @@
 			}
 		}
 	}
-profiler_mark_end();
+g_profiler.stop();
 }
 
 VIDEO_UPDATE( taitob )
diff -Nru src-old/mame/video/tia.c src/mame/video/tia.c
--- src-old/mame/video/tia.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/tia.c	2010-08-19 00:26:14.000000000 -0700
@@ -506,13 +506,13 @@
 }
 
 
-INLINE int current_x(const address_space *space)
+INLINE int current_x(address_space *space)
 {
 	return 3 * ((space->machine->firstcpu->total_cycles() - frame_cycles) % 76) - 68;
 }
 
 
-INLINE int current_y(const address_space *space)
+INLINE int current_y(address_space *space)
 {
 	return (space->machine->firstcpu->total_cycles() - frame_cycles) / 76;
 }
diff -Nru src-old/mame/video/tigeroad.c src/mame/video/tigeroad.c
--- src-old/mame/video/tigeroad.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/tigeroad.c	2010-08-19 00:26:14.000000000 -0700
@@ -165,7 +165,7 @@
 
 VIDEO_EOF( tigeroad )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	buffer_spriteram16_w(space, 0, 0, 0xffff);
 }
diff -Nru src-old/mame/video/toaplan1.c src/mame/video/toaplan1.c
--- src-old/mame/video/toaplan1.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/toaplan1.c	2010-08-30 08:20:58.000000000 -0700
@@ -129,55 +129,6 @@
 #define TOAPLAN1_SPRITERAM_SIZE      0x800	/* sprite ram */
 #define TOAPLAN1_SPRITESIZERAM_SIZE  0x80	/* sprite size ram */
 
-static UINT16 *pf4_tilevram16;	/*  ||  Drawn in this order */
-static UINT16 *pf3_tilevram16;	/*  ||  */
-static UINT16 *pf2_tilevram16;	/* \||/ */
-static UINT16 *pf1_tilevram16;	/*  \/  */
-
-static UINT16 *toaplan1_spritesizeram16;
-static UINT16 *toaplan1_buffered_spritesizeram16;
-
-size_t toaplan1_colorram1_size;
-size_t toaplan1_colorram2_size;
-UINT16 *toaplan1_colorram1;
-UINT16 *toaplan1_colorram2;
-
-static INT32 bcu_flipscreen;		/* Tile   controller flip flag */
-static INT32 fcu_flipscreen;		/* Sprite controller flip flag */
-
-static INT32 pf_voffs;
-static INT32 spriteram_offs;
-
-static INT32 pf1_scrollx;
-static INT32 pf1_scrolly;
-static INT32 pf2_scrollx;
-static INT32 pf2_scrolly;
-static INT32 pf3_scrollx;
-static INT32 pf3_scrolly;
-static INT32 pf4_scrollx;
-static INT32 pf4_scrolly;
-static INT32 scrollx_offs1;
-static INT32 scrollx_offs2;
-static INT32 scrollx_offs3;
-static INT32 scrollx_offs4;
-static INT32 scrolly_offs;
-
-
-#ifdef MAME_DEBUG
-static int display_pf1;
-static int display_pf2;
-static int display_pf3;
-static int display_pf4;
-static int displog;
-#endif
-
-static INT32 tiles_offsetx;
-static INT32 tiles_offsety;
-
-static int toaplan1_reset;		/* Hack! See toaplan1_bcu_control below */
-
-static tilemap_t *pf1_tilemap, *pf2_tilemap, *pf3_tilemap, *pf4_tilemap;
-
 
 /***************************************************************************
 
@@ -187,66 +138,70 @@
 
 static TILE_GET_INFO( get_pf1_tile_info )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
 	int color, tile_number, attrib;
 
-	tile_number = pf1_tilevram16[2*tile_index+1] & 0x7fff;
-	attrib = pf1_tilevram16[2*tile_index];
+	tile_number = state->pf1_tilevram16[2*tile_index+1] & 0x7fff;
+	attrib = state->pf1_tilevram16[2*tile_index];
 	color = attrib & 0x3f;
 	SET_TILE_INFO(
 			0,
 			tile_number,
 			color,
 			0);
-	if (pf1_tilevram16[2*tile_index+1] & 0x8000) tileinfo->category = 0;
-	else tileinfo->category = (attrib & 0xf000) >> 12;
+	if (state->pf1_tilevram16[2*tile_index+1] & 0x8000) tileinfo->pen_data = state->empty_tile;
+	tileinfo->category = (attrib & 0xf000) >> 12;
 }
 
 static TILE_GET_INFO( get_pf2_tile_info )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
 	int color, tile_number, attrib;
 
-	tile_number = pf2_tilevram16[2*tile_index+1] & 0x7fff;
-	attrib = pf2_tilevram16[2*tile_index];
+	tile_number = state->pf2_tilevram16[2*tile_index+1] & 0x7fff;
+	attrib = state->pf2_tilevram16[2*tile_index];
 	color = attrib & 0x3f;
 	SET_TILE_INFO(
 			0,
 			tile_number,
 			color,
 			0);
-	if (pf2_tilevram16[2*tile_index+1] & 0x8000) tileinfo->category = 0;
-	else tileinfo->category = (attrib & 0xf000) >> 12;
+	if (state->pf2_tilevram16[2*tile_index+1] & 0x8000) tileinfo->pen_data = state->empty_tile;
+	tileinfo->category = (attrib & 0xf000) >> 12;
 }
 
 static TILE_GET_INFO( get_pf3_tile_info )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
 	int color, tile_number, attrib;
 
-	tile_number = pf3_tilevram16[2*tile_index+1] & 0x7fff;
-	attrib = pf3_tilevram16[2*tile_index];
+	tile_number = state->pf3_tilevram16[2*tile_index+1] & 0x7fff;
+	attrib = state->pf3_tilevram16[2*tile_index];
 	color = attrib & 0x3f;
 	SET_TILE_INFO(
 			0,
 			tile_number,
 			color,
 			0);
-	if (pf3_tilevram16[2*tile_index+1] & 0x8000) tileinfo->category = 0;
-	else tileinfo->category = (attrib & 0xf000) >> 12;
+	if (state->pf3_tilevram16[2*tile_index+1] & 0x8000) tileinfo->pen_data = state->empty_tile;
+	tileinfo->category = (attrib & 0xf000) >> 12;
 }
 
 static TILE_GET_INFO( get_pf4_tile_info )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
 	int color, tile_number, attrib;
 
-	tile_number = pf4_tilevram16[2*tile_index+1] & 0x7fff;
-	attrib = pf4_tilevram16[2*tile_index];
+	tile_number = state->pf4_tilevram16[2*tile_index+1] & 0x7fff;
+	attrib = state->pf4_tilevram16[2*tile_index];
 	color = attrib & 0x3f;
 	SET_TILE_INFO(
 			0,
 			tile_number,
 			color,
 			0);
-	if (pf4_tilevram16[2*tile_index+1] & 0x8000) tileinfo->category = 0;
-	else tileinfo->category = (attrib & 0xf000) >> 12;
+	if (state->pf4_tilevram16[2*tile_index+1] & 0x8000) tileinfo->pen_data = state->empty_tile;
+	tileinfo->category = (attrib & 0xf000) >> 12;
 }
 
 /***************************************************************************
@@ -257,163 +212,177 @@
 
 static void toaplan1_create_tilemaps(running_machine *machine)
 {
-	pf1_tilemap = tilemap_create(machine, get_pf1_tile_info,tilemap_scan_rows,8,8,64,64);
-	pf2_tilemap = tilemap_create(machine, get_pf2_tile_info,tilemap_scan_rows,8,8,64,64);
-	pf3_tilemap = tilemap_create(machine, get_pf3_tile_info,tilemap_scan_rows,8,8,64,64);
-	pf4_tilemap = tilemap_create(machine, get_pf4_tile_info,tilemap_scan_rows,8,8,64,64);
-
-	tilemap_set_transparent_pen(pf1_tilemap,0);
-	tilemap_set_transparent_pen(pf2_tilemap,0);
-	tilemap_set_transparent_pen(pf3_tilemap,0);
-	tilemap_set_transparent_pen(pf4_tilemap,0);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state->pf1_tilemap = tilemap_create(machine, get_pf1_tile_info, tilemap_scan_rows, 8, 8, 64, 64);
+	state->pf2_tilemap = tilemap_create(machine, get_pf2_tile_info, tilemap_scan_rows, 8, 8, 64, 64);
+	state->pf3_tilemap = tilemap_create(machine, get_pf3_tile_info, tilemap_scan_rows, 8, 8, 64, 64);
+	state->pf4_tilemap = tilemap_create(machine, get_pf4_tile_info, tilemap_scan_rows, 8, 8, 64, 64);
+
+	tilemap_set_transparent_pen(state->pf1_tilemap, 0);
+	tilemap_set_transparent_pen(state->pf2_tilemap, 0);
+	tilemap_set_transparent_pen(state->pf3_tilemap, 0);
+	tilemap_set_transparent_pen(state->pf4_tilemap, 0);
+
+	memset(state->empty_tile, 0x00, sizeof(state->empty_tile));
 }
 
 
 static void toaplan1_paletteram_alloc(running_machine *machine)
 {
-	machine->generic.paletteram.u16 = auto_alloc_array(machine, UINT16, (toaplan1_colorram1_size + toaplan1_colorram2_size)/2);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	machine->generic.paletteram.u16 = auto_alloc_array(machine, UINT16, (state->colorram1_size + state->colorram2_size)/2);
+
+	state_save_register_global_pointer(machine, machine->generic.paletteram.u16, (state->colorram1_size + state->colorram2_size)/2);
 }
 
 static void toaplan1_vram_alloc(running_machine *machine)
 {
-	pf1_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
-	pf2_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
-	pf3_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
-	pf4_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state->pf1_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state->pf2_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state->pf3_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state->pf4_tilevram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_TILEVRAM_SIZE/2);
+
+	state_save_register_global_pointer(machine, state->pf1_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->pf2_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->pf3_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->pf4_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
 
 #ifdef MAME_DEBUG
-	display_pf1 = 1;
-	display_pf2 = 1;
-	display_pf3 = 1;
-	display_pf4 = 1;
-	displog = 0;
+	state->display_pf1 = 1;
+	state->display_pf2 = 1;
+	state->display_pf3 = 1;
+	state->display_pf4 = 1;
+	state->displog = 0;
 #endif
 }
 
 static void toaplan1_spritevram_alloc(running_machine *machine)
 {
-	machine->generic.spriteram.u16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITERAM_SIZE/2);
-	machine->generic.buffered_spriteram.u16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITERAM_SIZE/2);
-	toaplan1_spritesizeram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
-	toaplan1_buffered_spritesizeram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
-
-	machine->generic.spriteram_size = TOAPLAN1_SPRITERAM_SIZE;
-}
-
-static void toaplan1_set_scrolls(void)
-{
-	tilemap_set_scrollx(pf1_tilemap,0,(pf1_scrollx >> 7) - (tiles_offsetx - scrollx_offs1));
-	tilemap_set_scrollx(pf2_tilemap,0,(pf2_scrollx >> 7) - (tiles_offsetx - scrollx_offs2));
-	tilemap_set_scrollx(pf3_tilemap,0,(pf3_scrollx >> 7) - (tiles_offsetx - scrollx_offs3));
-	tilemap_set_scrollx(pf4_tilemap,0,(pf4_scrollx >> 7) - (tiles_offsetx - scrollx_offs4));
-	tilemap_set_scrolly(pf1_tilemap,0,(pf1_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-	tilemap_set_scrolly(pf2_tilemap,0,(pf2_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-	tilemap_set_scrolly(pf3_tilemap,0,(pf3_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-	tilemap_set_scrolly(pf4_tilemap,0,(pf4_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state->spriteram = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITERAM_SIZE/2);
+	state->buffered_spriteram = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITERAM_SIZE/2);
+	state->spritesizeram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
+	state->buffered_spritesizeram16 = auto_alloc_array_clear(machine, UINT16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
+
+	state_save_register_global_pointer(machine, state->spriteram, TOAPLAN1_SPRITERAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->buffered_spriteram, TOAPLAN1_SPRITERAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->buffered_spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
+
+	state->spriteram_size = TOAPLAN1_SPRITERAM_SIZE;
+}
+
+static void toaplan1_set_scrolls(running_machine *machine)
+{
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	tilemap_set_scrollx(state->pf1_tilemap, 0, (state->pf1_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs1));
+	tilemap_set_scrollx(state->pf2_tilemap, 0, (state->pf2_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs2));
+	tilemap_set_scrollx(state->pf3_tilemap, 0, (state->pf3_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs3));
+	tilemap_set_scrollx(state->pf4_tilemap, 0, (state->pf4_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs4));
+	tilemap_set_scrolly(state->pf1_tilemap, 0, (state->pf1_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+	tilemap_set_scrolly(state->pf2_tilemap, 0, (state->pf2_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+	tilemap_set_scrolly(state->pf3_tilemap, 0, (state->pf3_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+	tilemap_set_scrolly(state->pf4_tilemap, 0, (state->pf4_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 }
 
 static STATE_POSTLOAD( rallybik_flipscreen )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	rallybik_bcu_flipscreen_w(space, 0, bcu_flipscreen, 0xffff);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+
+	rallybik_bcu_flipscreen_w(space, 0, state->bcu_flipscreen, 0xffff);
 }
 
 static STATE_POSTLOAD( toaplan1_flipscreen )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	toaplan1_bcu_flipscreen_w(space, 0, bcu_flipscreen, 0xffff);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+
+	toaplan1_bcu_flipscreen_w(space, 0, state->bcu_flipscreen, 0xffff);
+}
+
+static void register_common(running_machine *machine)
+{
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	state_save_register_global(machine, state->scrollx_offs1);
+	state_save_register_global(machine, state->scrollx_offs2);
+	state_save_register_global(machine, state->scrollx_offs3);
+	state_save_register_global(machine, state->scrollx_offs4);
+	state_save_register_global(machine, state->scrolly_offs);
+
+	state_save_register_global(machine, state->bcu_flipscreen);
+	state_save_register_global(machine, state->fcu_flipscreen);
+	state_save_register_global(machine, state->reset);
+
+	state_save_register_global(machine, state->pf1_scrollx);
+	state_save_register_global(machine, state->pf1_scrolly);
+	state_save_register_global(machine, state->pf2_scrollx);
+	state_save_register_global(machine, state->pf2_scrolly);
+	state_save_register_global(machine, state->pf3_scrollx);
+	state_save_register_global(machine, state->pf3_scrolly);
+	state_save_register_global(machine, state->pf4_scrollx);
+	state_save_register_global(machine, state->pf4_scrolly);
+
+	state_save_register_global(machine, state->tiles_offsetx);
+	state_save_register_global(machine, state->tiles_offsety);
+	state_save_register_global(machine, state->pf_voffs);
+	state_save_register_global(machine, state->spriteram_offs);
 }
 
 
 VIDEO_START( rallybik )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	toaplan1_create_tilemaps(machine);
 	toaplan1_paletteram_alloc(machine);
 	toaplan1_vram_alloc(machine);
 
-	scrollx_offs1 = 0x00d + 6;
-	scrollx_offs2 = 0x00d + 4;
-	scrollx_offs3 = 0x00d + 2;
-	scrollx_offs4 = 0x00d + 0;
-	scrolly_offs  = 0x111;
-
-	bcu_flipscreen = -1;
-	toaplan1_reset = 0;
-
-	state_save_register_global_pointer(machine, machine->generic.paletteram.u16, (toaplan1_colorram1_size + toaplan1_colorram2_size)/2);
-	state_save_register_global_pointer(machine, pf1_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf2_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf3_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf4_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-
-	state_save_register_global(machine, scrollx_offs1);
-	state_save_register_global(machine, scrollx_offs2);
-	state_save_register_global(machine, scrollx_offs3);
-	state_save_register_global(machine, scrollx_offs4);
-	state_save_register_global(machine, scrolly_offs);
-	state_save_register_global(machine, bcu_flipscreen);
-	state_save_register_global(machine, pf1_scrollx);
-	state_save_register_global(machine, pf1_scrolly);
-	state_save_register_global(machine, pf2_scrollx);
-	state_save_register_global(machine, pf2_scrolly);
-	state_save_register_global(machine, pf3_scrollx);
-	state_save_register_global(machine, pf3_scrolly);
-	state_save_register_global(machine, pf4_scrollx);
-	state_save_register_global(machine, pf4_scrolly);
-	state_save_register_global(machine, tiles_offsetx);
-	state_save_register_global(machine, tiles_offsety);
-	state_save_register_global(machine, pf_voffs);
-	state_save_register_global(machine, spriteram_offs);
+	state->buffered_spriteram = auto_alloc_array_clear(machine, UINT16, state->spriteram_size/2);
+	state_save_register_global_pointer(machine, state->buffered_spriteram, state->spriteram_size/2);
+
+	state->scrollx_offs1 = 0x00d + 6;
+	state->scrollx_offs2 = 0x00d + 4;
+	state->scrollx_offs3 = 0x00d + 2;
+	state->scrollx_offs4 = 0x00d + 0;
+	state->scrolly_offs  = 0x111;
+
+	state->bcu_flipscreen = -1;
+	state->fcu_flipscreen = 0;
+	state->reset = 0;
+
+	register_common(machine);
 
 	state_save_register_postload(machine, rallybik_flipscreen, NULL);
 }
 
 VIDEO_START( toaplan1 )
 {
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	toaplan1_create_tilemaps(machine);
 	toaplan1_paletteram_alloc(machine);
 	toaplan1_vram_alloc(machine);
 	toaplan1_spritevram_alloc(machine);
 
-	scrollx_offs1 = 0x1ef + 6;
-	scrollx_offs2 = 0x1ef + 4;
-	scrollx_offs3 = 0x1ef + 2;
-	scrollx_offs4 = 0x1ef + 0;
-	scrolly_offs  = 0x101;
-
-	bcu_flipscreen = -1;
-	fcu_flipscreen = 0;
-	toaplan1_reset = 1;
-
-	state_save_register_global_pointer(machine, machine->generic.paletteram.u16, (toaplan1_colorram1_size + toaplan1_colorram2_size)/2);
-	state_save_register_global_pointer(machine, pf1_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf2_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf3_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, pf4_tilevram16, TOAPLAN1_TILEVRAM_SIZE/2);
-	state_save_register_global_pointer(machine, machine->generic.spriteram.u16, TOAPLAN1_SPRITERAM_SIZE/2);
-	state_save_register_global_pointer(machine, machine->generic.buffered_spriteram.u16, TOAPLAN1_SPRITERAM_SIZE/2);
-	state_save_register_global_pointer(machine, toaplan1_spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
-	state_save_register_global_pointer(machine, toaplan1_buffered_spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE/2);
-
-	state_save_register_global(machine, scrollx_offs1);
-	state_save_register_global(machine, scrollx_offs2);
-	state_save_register_global(machine, scrollx_offs3);
-	state_save_register_global(machine, scrollx_offs4);
-	state_save_register_global(machine, scrolly_offs);
-	state_save_register_global(machine, bcu_flipscreen);
-	state_save_register_global(machine, fcu_flipscreen);
-	state_save_register_global(machine, pf1_scrollx);
-	state_save_register_global(machine, pf1_scrolly);
-	state_save_register_global(machine, pf2_scrolly);
-	state_save_register_global(machine, pf2_scrollx);
-	state_save_register_global(machine, pf3_scrollx);
-	state_save_register_global(machine, pf3_scrolly);
-	state_save_register_global(machine, pf4_scrollx);
-	state_save_register_global(machine, pf4_scrolly);
-	state_save_register_global(machine, tiles_offsetx);
-	state_save_register_global(machine, tiles_offsety);
-	state_save_register_global(machine, pf_voffs);
-	state_save_register_global(machine, spriteram_offs);
+	state->scrollx_offs1 = 0x1ef + 6;
+	state->scrollx_offs2 = 0x1ef + 4;
+	state->scrollx_offs3 = 0x1ef + 2;
+	state->scrollx_offs4 = 0x1ef + 0;
+	state->scrolly_offs  = 0x101;
+
+	state->bcu_flipscreen = -1;
+	state->fcu_flipscreen = 0;
+	state->reset = 1;
+
+	register_common(machine);
 
 	state_save_register_postload(machine, toaplan1_flipscreen, NULL);
 }
@@ -432,74 +401,80 @@
 
 WRITE16_HANDLER( toaplan1_tile_offsets_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	if ( offset == 0 )
 	{
-		COMBINE_DATA(&tiles_offsetx);
-		logerror("Tiles_offsetx now = %08x\n",tiles_offsetx);
+		COMBINE_DATA(&state->tiles_offsetx);
+		logerror("Tiles_offsetx now = %08x\n", state->tiles_offsetx);
 	}
 	else
 	{
-		COMBINE_DATA(&tiles_offsety);
-		logerror("Tiles_offsety now = %08x\n",tiles_offsety);
+		COMBINE_DATA(&state->tiles_offsety);
+		logerror("Tiles_offsety now = %08x\n", state->tiles_offsety);
 	}
-	toaplan1_reset = 1;
-	toaplan1_set_scrolls();
+	state->reset = 1;
+	toaplan1_set_scrolls(space->machine);
 }
 
 WRITE16_HANDLER( rallybik_bcu_flipscreen_w )
 {
-	if (ACCESSING_BITS_0_7 && (data != bcu_flipscreen))
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	if (ACCESSING_BITS_0_7 && (data != state->bcu_flipscreen))
 	{
 		logerror("Setting BCU controller flipscreen port to %04x\n",data);
-		bcu_flipscreen = data & 0x01;		/* 0x0001 = flip, 0x0000 = no flip */
+		state->bcu_flipscreen = data & 0x01;		/* 0x0001 = flip, 0x0000 = no flip */
 		tilemap_set_flip_all(space->machine, (data ? (TILEMAP_FLIPY | TILEMAP_FLIPX) : 0));
-		if (bcu_flipscreen)
+		if (state->bcu_flipscreen)
 		{
-			scrollx_offs1 = 0x1c0 - 6;
-			scrollx_offs2 = 0x1c0 - 4;
-			scrollx_offs3 = 0x1c0 - 2;
-			scrollx_offs4 = 0x1c0 - 0;
-			scrolly_offs  = 0x0e8;
+			state->scrollx_offs1 = 0x1c0 - 6;
+			state->scrollx_offs2 = 0x1c0 - 4;
+			state->scrollx_offs3 = 0x1c0 - 2;
+			state->scrollx_offs4 = 0x1c0 - 0;
+			state->scrolly_offs  = 0x0e8;
 		}
 		else
 		{
-			scrollx_offs1 = 0x00d + 6;
-			scrollx_offs2 = 0x00d + 4;
-			scrollx_offs3 = 0x00d + 2;
-			scrollx_offs4 = 0x00d + 0;
-			scrolly_offs  = 0x111;
+			state->scrollx_offs1 = 0x00d + 6;
+			state->scrollx_offs2 = 0x00d + 4;
+			state->scrollx_offs3 = 0x00d + 2;
+			state->scrollx_offs4 = 0x00d + 0;
+			state->scrolly_offs  = 0x111;
 		}
-		toaplan1_set_scrolls();
+		toaplan1_set_scrolls(space->machine);
 	}
 }
 
 WRITE16_HANDLER( toaplan1_bcu_flipscreen_w )
 {
-	if (ACCESSING_BITS_0_7 && (data != bcu_flipscreen))
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	if (ACCESSING_BITS_0_7 && (data != state->bcu_flipscreen))
 	{
 		logerror("Setting BCU controller flipscreen port to %04x\n",data);
-		bcu_flipscreen = data & 0x01;		/* 0x0001 = flip, 0x0000 = no flip */
+		state->bcu_flipscreen = data & 0x01;		/* 0x0001 = flip, 0x0000 = no flip */
 		tilemap_set_flip_all(space->machine, (data ? (TILEMAP_FLIPY | TILEMAP_FLIPX) : 0));
-		if (bcu_flipscreen)
+		if (state->bcu_flipscreen)
 		{
 			const rectangle &visarea = space->machine->primary_screen->visible_area();
 
-			scrollx_offs1 = 0x151 - 6;
-			scrollx_offs2 = 0x151 - 4;
-			scrollx_offs3 = 0x151 - 2;
-			scrollx_offs4 = 0x151 - 0;
-			scrolly_offs  = 0x1ef;
-			scrolly_offs += ((visarea.max_y + 1) - ((visarea.max_y + 1) - visarea.min_y)) * 2;	/* Horizontal games are offset so adjust by +0x20 */
+			state->scrollx_offs1 = 0x151 - 6;
+			state->scrollx_offs2 = 0x151 - 4;
+			state->scrollx_offs3 = 0x151 - 2;
+			state->scrollx_offs4 = 0x151 - 0;
+			state->scrolly_offs  = 0x1ef;
+			state->scrolly_offs += ((visarea.max_y + 1) - ((visarea.max_y + 1) - visarea.min_y)) * 2;	/* Horizontal games are offset so adjust by +0x20 */
 		}
 		else
 		{
-			scrollx_offs1 = 0x1ef + 6;
-			scrollx_offs2 = 0x1ef + 4;
-			scrollx_offs3 = 0x1ef + 2;
-			scrollx_offs4 = 0x1ef + 0;
-			scrolly_offs  = 0x101;
+			state->scrollx_offs1 = 0x1ef + 6;
+			state->scrollx_offs2 = 0x1ef + 4;
+			state->scrollx_offs3 = 0x1ef + 2;
+			state->scrollx_offs4 = 0x1ef + 0;
+			state->scrolly_offs  = 0x101;
 		}
-		toaplan1_set_scrolls();
+		toaplan1_set_scrolls(space->machine);
 	}
 }
 
@@ -507,141 +482,170 @@
 {
 	if (ACCESSING_BITS_8_15)
 	{
+		toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 		logerror("Setting FCU controller flipscreen port to %04x\n",data);
-		fcu_flipscreen = data & 0x8000;	/* 0x8000 = flip, 0x0000 = no flip */
+		state->fcu_flipscreen = data & 0x8000;	/* 0x8000 = flip, 0x0000 = no flip */
 	}
 }
 
 READ16_HANDLER( toaplan1_spriteram_offs_r ) /// this aint really needed ?
 {
-	return spriteram_offs;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->spriteram_offs;
 }
 
 WRITE16_HANDLER( toaplan1_spriteram_offs_w )
 {
-	COMBINE_DATA(&spriteram_offs);
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	COMBINE_DATA(&state->spriteram_offs);
 }
 
 
 /* tile palette */
 READ16_HANDLER( toaplan1_colorram1_r )
 {
-	return toaplan1_colorram1[offset];
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->colorram1[offset];
 }
 
 WRITE16_HANDLER( toaplan1_colorram1_w )
 {
-	COMBINE_DATA(&toaplan1_colorram1[offset]);
-	paletteram16_xBBBBBGGGGGRRRRR_word_w(space,offset, data, mem_mask);
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	COMBINE_DATA(&state->colorram1[offset]);
+	paletteram16_xBBBBBGGGGGRRRRR_word_w(space, offset, data, mem_mask);
 }
 
 /* sprite palette */
 READ16_HANDLER( toaplan1_colorram2_r )
 {
-	return toaplan1_colorram2[offset];
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->colorram2[offset];
 }
 
 WRITE16_HANDLER( toaplan1_colorram2_w )
 {
-	COMBINE_DATA(&toaplan1_colorram2[offset]);
-	paletteram16_xBBBBBGGGGGRRRRR_word_w(space,offset+(toaplan1_colorram1_size/2), data, mem_mask);
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	COMBINE_DATA(&state->colorram2[offset]);
+	paletteram16_xBBBBBGGGGGRRRRR_word_w(space, offset+(state->colorram1_size/2), data, mem_mask);
 }
 
 READ16_HANDLER( toaplan1_spriteram16_r )
 {
-	return space->machine->generic.spriteram.u16[spriteram_offs & ((TOAPLAN1_SPRITERAM_SIZE/2)-1)];
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->spriteram[state->spriteram_offs & ((TOAPLAN1_SPRITERAM_SIZE/2)-1)];
 }
 
 WRITE16_HANDLER( toaplan1_spriteram16_w )
 {
-	COMBINE_DATA(&space->machine->generic.spriteram.u16[spriteram_offs & ((TOAPLAN1_SPRITERAM_SIZE/2)-1)]);
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	COMBINE_DATA(&state->spriteram[state->spriteram_offs & ((TOAPLAN1_SPRITERAM_SIZE/2)-1)]);
 
 #ifdef MAME_DEBUG
-	if (spriteram_offs >= (TOAPLAN1_SPRITERAM_SIZE/2))
+	if (state->spriteram_offs >= (TOAPLAN1_SPRITERAM_SIZE/2))
 	{
-		logerror("Sprite_RAM_word_w, %08x out of range !\n", spriteram_offs);
+		logerror("Sprite_RAM_word_w, %08x out of range !\n", state->spriteram_offs);
 		return;
 	}
 #endif
 
-	spriteram_offs++;
+	state->spriteram_offs++;
 }
 
 READ16_HANDLER( toaplan1_spritesizeram16_r )
 {
-	return toaplan1_spritesizeram16[spriteram_offs & ((TOAPLAN1_SPRITESIZERAM_SIZE/2)-1)];
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->spritesizeram16[state->spriteram_offs & ((TOAPLAN1_SPRITESIZERAM_SIZE/2)-1)];
 }
 
 WRITE16_HANDLER( toaplan1_spritesizeram16_w )
 {
-	COMBINE_DATA(&toaplan1_spritesizeram16[spriteram_offs & ((TOAPLAN1_SPRITESIZERAM_SIZE/2)-1)]);
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	COMBINE_DATA(&state->spritesizeram16[state->spriteram_offs & ((TOAPLAN1_SPRITESIZERAM_SIZE/2)-1)]);
 
 #ifdef MAME_DEBUG
-	if (spriteram_offs >= (TOAPLAN1_SPRITESIZERAM_SIZE/2))
+	if (state->spriteram_offs >= (TOAPLAN1_SPRITESIZERAM_SIZE/2))
 	{
-		logerror("Sprite_Size_RAM_word_w, %08x out of range !\n", spriteram_offs);
+		logerror("Sprite_Size_RAM_word_w, %08x out of range !\n", state->spriteram_offs);
 		return;
 	}
 #endif
 
-	spriteram_offs++;	/// really ? shouldn't happen on the sizeram
+	state->spriteram_offs++;	/// really ? shouldn't happen on the sizeram
 }
 
 
 
 WRITE16_HANDLER( toaplan1_bcu_control_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	logerror("BCU tile controller register:%02x now = %04x\n",offset,data);
 
 	/*** Hack for Zero Wing and OutZone, to reset the sound system on */
 	/*** soft resets. These two games don't have a sound reset port,  */
 	/*** unlike the other games */
 
-	if (toaplan1_unk_reset_port && toaplan1_reset)
+	if (state->unk_reset_port && state->reset)
 	{
-		toaplan1_reset = 0;
+		state->reset = 0;
 		toaplan1_reset_sound(space,0,0,0);
 	}
 }
 
 READ16_HANDLER( toaplan1_tileram_offs_r )
 {
-	return pf_voffs;
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
+	return state->pf_voffs;
 }
 
 WRITE16_HANDLER( toaplan1_tileram_offs_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	if (data >= 0x4000)
 		logerror("Hmmm, unknown video layer being selected (%08x)\n",data);
-	COMBINE_DATA(&pf_voffs);
+	COMBINE_DATA(&state->pf_voffs);
 }
 
 
 READ16_HANDLER( toaplan1_tileram16_r )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
 	offs_t vram_offset;
 	UINT16 video_data = 0;
 
-	switch (pf_voffs & 0xf000)	/* Locate Layer (PlayField) */
+	switch (state->pf_voffs & 0xf000)	/* Locate Layer (PlayField) */
 	{
 		case 0x0000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				video_data = pf1_tilevram16[vram_offset];
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				video_data = state->pf1_tilevram16[vram_offset];
 				break;
 		case 0x1000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				video_data = pf2_tilevram16[vram_offset];
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				video_data = state->pf2_tilevram16[vram_offset];
 				break;
 		case 0x2000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				video_data = pf3_tilevram16[vram_offset];
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				video_data = state->pf3_tilevram16[vram_offset];
 				break;
 		case 0x3000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				video_data = pf4_tilevram16[vram_offset];
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				video_data = state->pf4_tilevram16[vram_offset];
 				break;
 		default:
-				logerror("Hmmm, reading %04x from unknown playfield layer address %06x  Offset:%01x !!!\n",video_data,pf_voffs,offset);
+				logerror("Hmmm, reading %04x from unknown playfield layer address %06x  Offset:%01x !!!\n", video_data, state->pf_voffs, offset);
 				break;
 	}
 
@@ -662,32 +666,33 @@
 
 WRITE16_HANDLER( toaplan1_tileram16_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
 	offs_t vram_offset;
 
-	switch (pf_voffs & 0xf000)	/* Locate Layer (PlayField) */
+	switch (state->pf_voffs & 0xf000)	/* Locate Layer (PlayField) */
 	{
 		case 0x0000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				COMBINE_DATA(&pf1_tilevram16[vram_offset]);
-				tilemap_mark_tile_dirty(pf1_tilemap,vram_offset/2);
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				COMBINE_DATA(&state->pf1_tilevram16[vram_offset]);
+				tilemap_mark_tile_dirty(state->pf1_tilemap, vram_offset/2);
 				break;
 		case 0x1000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				COMBINE_DATA(&pf2_tilevram16[vram_offset]);
-				tilemap_mark_tile_dirty(pf2_tilemap,vram_offset/2);
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				COMBINE_DATA(&state->pf2_tilevram16[vram_offset]);
+				tilemap_mark_tile_dirty(state->pf2_tilemap, vram_offset/2);
 				break;
 		case 0x2000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				COMBINE_DATA(&pf3_tilevram16[vram_offset]);
-				tilemap_mark_tile_dirty(pf3_tilemap,vram_offset/2);
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				COMBINE_DATA(&state->pf3_tilevram16[vram_offset]);
+				tilemap_mark_tile_dirty(state->pf3_tilemap, vram_offset/2);
 				break;
 		case 0x3000:
-				vram_offset = ((pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
-				COMBINE_DATA(&pf4_tilevram16[vram_offset]);
-				tilemap_mark_tile_dirty(pf4_tilemap,vram_offset/2);
+				vram_offset = ((state->pf_voffs * 2) + offset) & ((TOAPLAN1_TILEVRAM_SIZE/2)-1);
+				COMBINE_DATA(&state->pf4_tilevram16[vram_offset]);
+				tilemap_mark_tile_dirty(state->pf4_tilemap, vram_offset/2);
 				break;
 		default:
-				logerror("Hmmm, writing %04x to unknown playfield layer address %06x  Offset:%01x\n",data,pf_voffs,offset);
+				logerror("Hmmm, writing %04x to unknown playfield layer address %06x  Offset:%01x\n", data, state->pf_voffs, offset);
 				break;
 	}
 }
@@ -696,18 +701,19 @@
 
 READ16_HANDLER( toaplan1_scroll_regs_r )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
 	UINT16 scroll = 0;
 
 	switch(offset)
 	{
-		case 00: scroll = pf1_scrollx; break;
-		case 01: scroll = pf1_scrolly; break;
-		case 02: scroll = pf2_scrollx; break;
-		case 03: scroll = pf2_scrolly; break;
-		case 04: scroll = pf3_scrollx; break;
-		case 05: scroll = pf3_scrolly; break;
-		case 06: scroll = pf4_scrollx; break;
-		case 07: scroll = pf4_scrolly; break;
+		case 00: scroll = state->pf1_scrollx; break;
+		case 01: scroll = state->pf1_scrolly; break;
+		case 02: scroll = state->pf2_scrollx; break;
+		case 03: scroll = state->pf2_scrolly; break;
+		case 04: scroll = state->pf3_scrollx; break;
+		case 05: scroll = state->pf3_scrolly; break;
+		case 06: scroll = state->pf4_scrollx; break;
+		case 07: scroll = state->pf4_scrolly; break;
 		default: logerror("Hmmm, reading unknown video scroll register (%08x) !!!\n",offset);
 				 break;
 	}
@@ -717,31 +723,33 @@
 
 WRITE16_HANDLER( toaplan1_scroll_regs_w )
 {
+	toaplan1_state *state = space->machine->driver_data<toaplan1_state>();
+
 	switch(offset)
 	{
-		case 00: COMBINE_DATA(&pf1_scrollx);		/* 1D3h */
-				 tilemap_set_scrollx(pf1_tilemap,0,(pf1_scrollx >> 7) - (tiles_offsetx - scrollx_offs1));
+		case 00: COMBINE_DATA(&state->pf1_scrollx);		/* 1D3h */
+				 tilemap_set_scrollx(state->pf1_tilemap, 0, (state->pf1_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs1));
 				 break;
-		case 01: COMBINE_DATA(&pf1_scrolly);		/* 1EBh */
-				 tilemap_set_scrolly(pf1_tilemap,0,(pf1_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		case 01: COMBINE_DATA(&state->pf1_scrolly);		/* 1EBh */
+				 tilemap_set_scrolly(state->pf1_tilemap, 0, (state->pf1_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 				 break;
-		case 02: COMBINE_DATA(&pf2_scrollx);		/* 1D5h */
-				 tilemap_set_scrollx(pf2_tilemap,0,(pf2_scrollx >> 7) - (tiles_offsetx - scrollx_offs2));
+		case 02: COMBINE_DATA(&state->pf2_scrollx);		/* 1D5h */
+				 tilemap_set_scrollx(state->pf2_tilemap, 0, (state->pf2_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs2));
 				 break;
-		case 03: COMBINE_DATA(&pf2_scrolly);		/* 1EBh */
-				 tilemap_set_scrolly(pf2_tilemap,0,(pf2_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		case 03: COMBINE_DATA(&state->pf2_scrolly);		/* 1EBh */
+				 tilemap_set_scrolly(state->pf2_tilemap, 0, (state->pf2_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 				 break;
-		case 04: COMBINE_DATA(&pf3_scrollx);		/* 1D7h */
-				 tilemap_set_scrollx(pf3_tilemap,0,(pf3_scrollx >> 7) - (tiles_offsetx - scrollx_offs3));
+		case 04: COMBINE_DATA(&state->pf3_scrollx);		/* 1D7h */
+				 tilemap_set_scrollx(state->pf3_tilemap, 0, (state->pf3_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs3));
 				 break;
-		case 05: COMBINE_DATA(&pf3_scrolly);		/* 1EBh */
-				 tilemap_set_scrolly(pf3_tilemap,0,(pf3_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		case 05: COMBINE_DATA(&state->pf3_scrolly);		/* 1EBh */
+				 tilemap_set_scrolly(state->pf3_tilemap, 0, (state->pf3_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 				 break;
-		case 06: COMBINE_DATA(&pf4_scrollx);		/* 1D9h */
-				 tilemap_set_scrollx(pf4_tilemap,0,(pf4_scrollx >> 7) - (tiles_offsetx - scrollx_offs4));
+		case 06: COMBINE_DATA(&state->pf4_scrollx);		/* 1D9h */
+				 tilemap_set_scrollx(state->pf4_tilemap, 0, (state->pf4_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs4));
 				 break;
-		case 07: COMBINE_DATA(&pf4_scrolly);		/* 1EBh */
-				 tilemap_set_scrolly(pf4_tilemap,0,(pf4_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		case 07: COMBINE_DATA(&state->pf4_scrolly);		/* 1EBh */
+				 tilemap_set_scrolly(state->pf4_tilemap, 0, (state->pf4_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 				 break;
 		default: logerror("Hmmm, writing %08x to unknown video scroll register (%08x) !!!\n",data ,offset);
 				 break;
@@ -754,20 +762,23 @@
 static void toaplan1_log_vram(running_machine *machine)
 {
 #ifdef MAME_DEBUG
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
 	if ( input_code_pressed(machine, KEYCODE_M) )
 	{
-		UINT16 *spriteram16 = machine->generic.spriteram.u16;
-		UINT16 *buffered_spriteram16 = machine->generic.buffered_spriteram.u16;
+		UINT16 *spriteram16 = state->spriteram;
+		UINT16 *buffered_spriteram16 = state->buffered_spriteram;
 		offs_t sprite_voffs;
 		while (input_code_pressed(machine, KEYCODE_M)) ;
-		if (toaplan1_spritesizeram16)			/* FCU controller */
+		if (state->spritesizeram16)			/* FCU controller */
 		{
 			int schar,sattr,sxpos,sypos,bschar,bsattr,bsxpos,bsypos;
-			UINT16 *size  = (UINT16 *)(toaplan1_spritesizeram16);
-			UINT16 *bsize = (UINT16 *)(toaplan1_buffered_spritesizeram16);
+			UINT16 *size  = (UINT16 *)(state->spritesizeram16);
+			UINT16 *bsize = (UINT16 *)(state->buffered_spritesizeram16);
 			logerror("Scrolls    PF1-X  PF1-Y     PF2-X  PF2-Y     PF3-X  PF3-Y     PF4-X  PF4-Y\n");
-			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",pf1_scrollx,pf1_scrolly,pf2_scrollx,pf2_scrolly,pf3_scrollx,pf3_scrolly,pf4_scrollx,pf4_scrolly);
-			for ( sprite_voffs = 0; sprite_voffs < (machine->generic.spriteram_size/2); sprite_voffs += 4 )
+			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",
+				state->pf1_scrollx, state->pf1_scrolly, state->pf2_scrollx, state->pf2_scrolly, state->pf3_scrollx, state->pf3_scrolly, state->pf4_scrollx, state->pf4_scrolly);
+			for ( sprite_voffs = 0; sprite_voffs < state->spriteram_size/2; sprite_voffs += 4 )
 			{
 				bschar = buffered_spriteram16[sprite_voffs];
 				bsattr = buffered_spriteram16[sprite_voffs + 1];
@@ -786,8 +797,9 @@
 		{
 			int schar,sattr,sxpos,sypos,bschar,bsattr,bsxpos,bsypos;
 			logerror("Scrolls    PF1-X  PF1-Y     PF2-X  PF2-Y     PF3-X  PF3-Y     PF4-X  PF4-Y\n");
-			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",pf1_scrollx,pf1_scrolly,pf2_scrollx,pf2_scrolly,pf3_scrollx,pf3_scrolly,pf4_scrollx,pf4_scrolly);
-			for ( sprite_voffs = 0; sprite_voffs < (machine->generic.spriteram_size/2); sprite_voffs += 4 )
+			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",
+				state->pf1_scrollx, state->pf1_scrolly, state->pf2_scrollx, state->pf2_scrolly, state->pf3_scrollx, state->pf3_scrolly, state->pf4_scrollx, state->pf4_scrolly);
+			for ( sprite_voffs = 0; sprite_voffs < state->spriteram_size/2; sprite_voffs += 4 )
 			{
 				bschar = buffered_spriteram16[sprite_voffs];
 				bsattr = buffered_spriteram16[sprite_voffs + 1];
@@ -806,14 +818,15 @@
 
 	if ( input_code_pressed(machine, KEYCODE_SLASH) )
 	{
-		UINT16 *size  = (UINT16 *)(toaplan1_spritesizeram16);
-		UINT16 *bsize = (UINT16 *)(toaplan1_buffered_spritesizeram16);
+		UINT16 *size  = (UINT16 *)(state->spritesizeram16);
+		UINT16 *bsize = (UINT16 *)(state->buffered_spritesizeram16);
 		offs_t offs;
 		while (input_code_pressed(machine, KEYCODE_SLASH)) ;
-		if (toaplan1_spritesizeram16)			/* FCU controller */
+		if (state->spritesizeram16)			/* FCU controller */
 		{
 			logerror("Scrolls    PF1-X  PF1-Y     PF2-X  PF2-Y     PF3-X  PF3-Y     PF4-X  PF4-Y\n");
-			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",pf1_scrollx,pf1_scrolly,pf2_scrollx,pf2_scrolly,pf3_scrollx,pf3_scrolly,pf4_scrollx,pf4_scrolly);
+			logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",
+				state->pf1_scrollx, state->pf1_scrolly, state->pf2_scrollx, state->pf2_scrolly, state->pf3_scrollx, state->pf3_scrolly, state->pf4_scrollx, state->pf4_scrolly);
 			for ( offs = 0; offs < (TOAPLAN1_SPRITESIZERAM_SIZE/2); offs +=4 )
 			{
 				logerror("SizeOffs:%04x   now:%04x %04x %04x %04x    next: %04x %04x %04x %04x\n", offs,
@@ -831,17 +844,18 @@
 		int tchar[5], tattr[5];
 		while (input_code_pressed(machine, KEYCODE_N)) ;	/* BCU controller */
 		logerror("Scrolls    PF1-X  PF1-Y     PF2-X  PF2-Y     PF3-X  PF3-Y     PF4-X  PF4-Y\n");
-		logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",pf1_scrollx,pf1_scrolly,pf2_scrollx,pf2_scrolly,pf3_scrollx,pf3_scrolly,pf4_scrollx,pf4_scrolly);
+		logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",
+			state->pf1_scrollx, state->pf1_scrolly, state->pf2_scrollx, state->pf2_scrolly, state->pf3_scrollx, state->pf3_scrolly, state->pf4_scrollx, state->pf4_scrolly);
 		for ( tile_voffs = 0; tile_voffs < (TOAPLAN1_TILEVRAM_SIZE/2); tile_voffs += 2 )
 		{
-			tchar[1] = pf1_tilevram16[tile_voffs + 1];
-			tattr[1] = pf1_tilevram16[tile_voffs];
-			tchar[2] = pf2_tilevram16[tile_voffs + 1];
-			tattr[2] = pf2_tilevram16[tile_voffs];
-			tchar[3] = pf3_tilevram16[tile_voffs + 1];
-			tattr[3] = pf3_tilevram16[tile_voffs];
-			tchar[4] = pf4_tilevram16[tile_voffs + 1];
-			tattr[4] = pf4_tilevram16[tile_voffs];
+			tchar[1] = state->pf1_tilevram16[tile_voffs + 1];
+			tattr[1] = state->pf1_tilevram16[tile_voffs];
+			tchar[2] = state->pf2_tilevram16[tile_voffs + 1];
+			tattr[2] = state->pf2_tilevram16[tile_voffs];
+			tchar[3] = state->pf3_tilevram16[tile_voffs + 1];
+			tattr[3] = state->pf3_tilevram16[tile_voffs];
+			tchar[4] = state->pf4_tilevram16[tile_voffs + 1];
+			tattr[4] = state->pf4_tilevram16[tile_voffs];
 //          logerror("PF3 offs:%04x   Tile:%04x  Attr:%04x\n", tile_voffs, tchar, tattr);
 			logerror("$(%04x)  Attr-Tile PF1:%04x-%04x  PF2:%04x-%04x  PF3:%04x-%04x  PF4:%04x-%04x\n", tile_voffs,
 									tattr[1], tchar[1],  tattr[2], tchar[2],
@@ -857,82 +871,83 @@
 	if ( input_code_pressed(machine, KEYCODE_E) )
 	{
 		while (input_code_pressed(machine, KEYCODE_E)) ;
-		displog += 1;
-		displog &= 1;
+		state->displog += 1;
+		state->displog &= 1;
 	}
-	if (displog)
+	if (state->displog)
 	{
 		logerror("Scrolls    PF1-X  PF1-Y     PF2-X  PF2-Y     PF3-X  PF3-Y     PF4-X  PF4-Y\n");
-		logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",pf1_scrollx,pf1_scrolly,pf2_scrollx,pf2_scrolly,pf3_scrollx,pf3_scrolly,pf4_scrollx,pf4_scrolly);
+		logerror("------>    #%04x  #%04x     #%04x  #%04x     #%04x  #%04x     #%04x  #%04x\n",
+			state->pf1_scrollx, state->pf1_scrolly, state->pf2_scrollx, state->pf2_scrolly, state->pf3_scrollx, state->pf3_scrolly, state->pf4_scrollx, state->pf4_scrolly);
 	}
 	if ( input_code_pressed(machine, KEYCODE_B) )
 	{
 //      while (input_code_pressed(machine, KEYCODE_B)) ;
-		scrollx_offs1 += 0x1; scrollx_offs2 += 0x1; scrollx_offs3 += 0x1; scrollx_offs4 += 0x1;
-		logerror("Scrollx_offs now = %08x\n",scrollx_offs4);
-		tilemap_set_scrollx(pf1_tilemap,0,(pf1_scrollx >> 7) - (tiles_offsetx - scrollx_offs1));
-		tilemap_set_scrollx(pf2_tilemap,0,(pf2_scrollx >> 7) - (tiles_offsetx - scrollx_offs2));
-		tilemap_set_scrollx(pf3_tilemap,0,(pf3_scrollx >> 7) - (tiles_offsetx - scrollx_offs3));
-		tilemap_set_scrollx(pf4_tilemap,0,(pf4_scrollx >> 7) - (tiles_offsetx - scrollx_offs4));
+		state->scrollx_offs1 += 0x1; state->scrollx_offs2 += 0x1; state->scrollx_offs3 += 0x1; state->scrollx_offs4 += 0x1;
+		logerror("Scrollx_offs now = %08x\n", state->scrollx_offs4);
+		tilemap_set_scrollx(state->pf1_tilemap, 0, (state->pf1_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs1));
+		tilemap_set_scrollx(state->pf2_tilemap, 0, (state->pf2_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs2));
+		tilemap_set_scrollx(state->pf3_tilemap, 0, (state->pf3_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs3));
+		tilemap_set_scrollx(state->pf4_tilemap, 0, (state->pf4_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs4));
 	}
 	if ( input_code_pressed(machine, KEYCODE_V) )
 	{
 //      while (input_code_pressed(machine, KEYCODE_V)) ;
-		scrollx_offs1 -= 0x1; scrollx_offs2 -= 0x1; scrollx_offs3 -= 0x1; scrollx_offs4 -= 0x1;
-		logerror("Scrollx_offs now = %08x\n",scrollx_offs4);
-		tilemap_set_scrollx(pf1_tilemap,0,(pf1_scrollx >> 7) - (tiles_offsetx - scrollx_offs1));
-		tilemap_set_scrollx(pf2_tilemap,0,(pf2_scrollx >> 7) - (tiles_offsetx - scrollx_offs2));
-		tilemap_set_scrollx(pf3_tilemap,0,(pf3_scrollx >> 7) - (tiles_offsetx - scrollx_offs3));
-		tilemap_set_scrollx(pf4_tilemap,0,(pf4_scrollx >> 7) - (tiles_offsetx - scrollx_offs4));
+		state->scrollx_offs1 -= 0x1; state->scrollx_offs2 -= 0x1; state->scrollx_offs3 -= 0x1; state->scrollx_offs4 -= 0x1;
+		logerror("Scrollx_offs now = %08x\n", state->scrollx_offs4);
+		tilemap_set_scrollx(state->pf1_tilemap, 0, (state->pf1_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs1));
+		tilemap_set_scrollx(state->pf2_tilemap, 0, (state->pf2_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs2));
+		tilemap_set_scrollx(state->pf3_tilemap, 0, (state->pf3_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs3));
+		tilemap_set_scrollx(state->pf4_tilemap, 0, (state->pf4_scrollx >> 7) - (state->tiles_offsetx - state->scrollx_offs4));
 	}
 	if ( input_code_pressed(machine, KEYCODE_C) )
 	{
 //      while (input_code_pressed(machine, KEYCODE_C)) ;
-		scrolly_offs += 0x1;
-		logerror("Scrolly_offs now = %08x\n",scrolly_offs);
-		tilemap_set_scrolly(pf1_tilemap,0,(pf1_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf2_tilemap,0,(pf2_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf3_tilemap,0,(pf3_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf4_tilemap,0,(pf4_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		state->scrolly_offs += 0x1;
+		logerror("Scrolly_offs now = %08x\n", state->scrolly_offs);
+		tilemap_set_scrolly(state->pf1_tilemap, 0, (state->pf1_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf2_tilemap, 0, (state->pf2_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf3_tilemap, 0, (state->pf3_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf4_tilemap, 0, (state->pf4_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 	}
 	if ( input_code_pressed(machine, KEYCODE_X) )
 	{
 //      while (input_code_pressed(machine, KEYCODE_X)) ;
-		scrolly_offs -= 0x1;
-		logerror("Scrolly_offs now = %08x\n",scrolly_offs);
-		tilemap_set_scrolly(pf1_tilemap,0,(pf1_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf2_tilemap,0,(pf2_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf3_tilemap,0,(pf3_scrolly >> 7) - (tiles_offsety - scrolly_offs));
-		tilemap_set_scrolly(pf4_tilemap,0,(pf4_scrolly >> 7) - (tiles_offsety - scrolly_offs));
+		state->scrolly_offs -= 0x1;
+		logerror("Scrolly_offs now = %08x\n", state->scrolly_offs);
+		tilemap_set_scrolly(state->pf1_tilemap, 0, (state->pf1_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf2_tilemap, 0, (state->pf2_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf3_tilemap, 0, (state->pf3_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
+		tilemap_set_scrolly(state->pf4_tilemap, 0, (state->pf4_scrolly >> 7) - (state->tiles_offsety - state->scrolly_offs));
 	}
 
 	if ( input_code_pressed(machine, KEYCODE_L) )		/* Turn Playfield 4 on/off */
 	{
 		while (input_code_pressed(machine, KEYCODE_L)) ;
-		display_pf4 += 1;
-		display_pf4 &= 1;
-		tilemap_set_enable(pf4_tilemap, display_pf4);
+		state->display_pf4 += 1;
+		state->display_pf4 &= 1;
+		tilemap_set_enable(state->pf4_tilemap, state->display_pf4);
 	}
 	if ( input_code_pressed(machine, KEYCODE_K) )		/* Turn Playfield 3 on/off */
 	{
 		while (input_code_pressed(machine, KEYCODE_K)) ;
-		display_pf3 += 1;
-		display_pf3 &= 1;
-		tilemap_set_enable(pf3_tilemap, display_pf3);
+		state->display_pf3 += 1;
+		state->display_pf3 &= 1;
+		tilemap_set_enable(state->pf3_tilemap, state->display_pf3);
 	}
 	if ( input_code_pressed(machine, KEYCODE_J) )		/* Turn Playfield 2 on/off */
 	{
 		while (input_code_pressed(machine, KEYCODE_J)) ;
-		display_pf2 += 1;
-		display_pf2 &= 1;
-		tilemap_set_enable(pf2_tilemap, display_pf2);
+		state->display_pf2 += 1;
+		state->display_pf2 &= 1;
+		tilemap_set_enable(state->pf2_tilemap, state->display_pf2);
 	}
 	if ( input_code_pressed(machine, KEYCODE_H) )		/* Turn Playfield 1 on/off */
 	{
 		while (input_code_pressed(machine, KEYCODE_H)) ;
-		display_pf1 += 1;
-		display_pf1 &= 1;
-		tilemap_set_enable(pf1_tilemap, display_pf1);
+		state->display_pf1 += 1;
+		state->display_pf1 &= 1;
+		tilemap_set_enable(state->pf1_tilemap, state->display_pf1);
 	}
 #endif
 }
@@ -1045,12 +1060,13 @@
 
 static void draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect )
 {
-	UINT16 *source = (UINT16 *)(machine->generic.buffered_spriteram.u16);
-	UINT16 *size   = (UINT16 *)(toaplan1_buffered_spritesizeram16);
-
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+	UINT16 *source = (UINT16 *)state->buffered_spriteram;
+	UINT16 *size   = (UINT16 *)state->buffered_spritesizeram16;
+	int fcu_flipscreen = state->fcu_flipscreen;
 	int offs;
 
-	for (offs = machine->generic.spriteram_size/2 - 4; offs >= 0; offs -= 4)
+	for (offs = state->spriteram_size/2 - 4; offs >= 0; offs -= 4)
 	{
 		if (!(source[offs] & 0x8000))
 		{
@@ -1112,10 +1128,11 @@
 
 static void rallybik_draw_sprites(running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect, int priority )
 {
-	UINT16 *buffered_spriteram16 = machine->generic.buffered_spriteram.u16;
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+	UINT16 *buffered_spriteram16 = state->buffered_spriteram;
 	int offs;
 
-	for (offs = 0; offs < (machine->generic.spriteram_size/2); offs += 4)
+	for (offs = 0; offs < state->spriteram_size/2; offs += 4)
 	{
 		int attrib, sx, sy, flipx, flipy;
 		int sprite, color;
@@ -1149,53 +1166,31 @@
 
 VIDEO_UPDATE( rallybik )
 {
+	toaplan1_state *state = screen->machine->driver_data<toaplan1_state>();
 	int priority;
 
 	toaplan1_log_vram(screen->machine);
 
-	bitmap_fill(bitmap,cliprect,0);
-
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,TILEMAP_DRAW_OPAQUE | 0,0);
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,TILEMAP_DRAW_OPAQUE | 1,0);
-
-	for (priority = 1; priority < 16; priority++)
-	{
-		tilemap_draw(bitmap,cliprect,pf4_tilemap,priority,0);
-		tilemap_draw(bitmap,cliprect,pf3_tilemap,priority,0);
-		tilemap_draw(bitmap,cliprect,pf2_tilemap,priority,0);
-		tilemap_draw(bitmap,cliprect,pf1_tilemap,priority,0);
-		rallybik_draw_sprites(screen->machine, bitmap,cliprect,priority << 8);
-	}
-	return 0;
-}
-
-VIDEO_UPDATE( toaplan1 )
-{
-	int priority;
-
-	toaplan1_log_vram(screen->machine);
-
-	bitmap_fill(screen->machine->priority_bitmap,cliprect,0);
 	bitmap_fill(bitmap,cliprect,0x120);
 
-	tilemap_draw(bitmap,cliprect,pf4_tilemap,TILEMAP_DRAW_OPAQUE,0);
-	for (priority = 8; priority < 16; priority++)
-		tilemap_draw(bitmap,cliprect,pf1_tilemap,TILEMAP_DRAW_OPAQUE | priority,0);
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, TILEMAP_DRAW_OPAQUE | 0, 0);
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, TILEMAP_DRAW_OPAQUE | 1, 0);
 
 	for (priority = 1; priority < 16; priority++)
 	{
-		tilemap_draw_primask(bitmap,cliprect,pf4_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf3_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf2_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf1_tilemap,priority,priority,0);
+		tilemap_draw(bitmap, cliprect, state->pf4_tilemap, priority, 0);
+		tilemap_draw(bitmap, cliprect, state->pf3_tilemap, priority, 0);
+		tilemap_draw(bitmap, cliprect, state->pf2_tilemap, priority, 0);
+		tilemap_draw(bitmap, cliprect, state->pf1_tilemap, priority, 0);
+		rallybik_draw_sprites(screen->machine, bitmap,cliprect,priority << 8);
 	}
 
-	draw_sprites(screen->machine, bitmap,cliprect);
 	return 0;
 }
 
-VIDEO_UPDATE( demonwld )
+VIDEO_UPDATE( toaplan1 )
 {
+	toaplan1_state *state = screen->machine->driver_data<toaplan1_state>();
 	int priority;
 
 	toaplan1_log_vram(screen->machine);
@@ -1203,22 +1198,22 @@
 	bitmap_fill(screen->machine->priority_bitmap,cliprect,0);
 	bitmap_fill(bitmap,cliprect,0x120);
 
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,TILEMAP_DRAW_OPAQUE | 0,0);
-	tilemap_draw(bitmap,cliprect,pf1_tilemap,TILEMAP_DRAW_OPAQUE | 1,0);
+// it's really correct?
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, TILEMAP_DRAW_OPAQUE | 0, 0);
+	tilemap_draw(bitmap, cliprect, state->pf1_tilemap, TILEMAP_DRAW_OPAQUE | 1, 0);
 
 	for (priority = 1; priority < 16; priority++)
 	{
-		tilemap_draw_primask(bitmap,cliprect,pf4_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf3_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf2_tilemap,priority,priority,0);
-		tilemap_draw_primask(bitmap,cliprect,pf1_tilemap,priority,priority,0);
+		tilemap_draw_primask(bitmap, cliprect, state->pf4_tilemap, priority, priority, 0);
+		tilemap_draw_primask(bitmap, cliprect, state->pf3_tilemap, priority, priority, 0);
+		tilemap_draw_primask(bitmap, cliprect, state->pf2_tilemap, priority, priority, 0);
+		tilemap_draw_primask(bitmap, cliprect, state->pf1_tilemap, priority, priority, 0);
 	}
 
-	draw_sprites(screen->machine, bitmap,cliprect);
+	draw_sprites(screen->machine, bitmap, cliprect);
 	return 0;
 }
 
-
 /****************************************************************************
     Spriteram is always 1 frame ahead, suggesting spriteram buffering.
     There are no CPU output registers that control this so we
@@ -1227,21 +1222,24 @@
 
 VIDEO_EOF( rallybik )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	buffer_spriteram16_w(space, 0, 0, 0xffff);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	memcpy(state->buffered_spriteram, state->spriteram, state->spriteram_size);
 }
 
 VIDEO_EOF( toaplan1 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	buffer_spriteram16_w(space, 0, 0, 0xffff);
-	memcpy(toaplan1_buffered_spritesizeram16, toaplan1_spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	memcpy(state->buffered_spriteram, state->spriteram, state->spriteram_size);
+	memcpy(state->buffered_spritesizeram16, state->spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE);
 }
 
 VIDEO_EOF( samesame )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
-	buffer_spriteram16_w(space, 0, 0, 0xffff);
-	memcpy(toaplan1_buffered_spritesizeram16, toaplan1_spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE);
+	toaplan1_state *state = machine->driver_data<toaplan1_state>();
+
+	memcpy(state->buffered_spriteram, state->spriteram, state->spriteram_size);
+	memcpy(state->buffered_spritesizeram16, state->spritesizeram16, TOAPLAN1_SPRITESIZERAM_SIZE);
 	cputag_set_input_line(machine, "maincpu", M68K_IRQ_2, HOLD_LINE);	/* Frame done */
 }
diff -Nru src-old/mame/video/toaplan2.c src/mame/video/toaplan2.c
--- src-old/mame/video/toaplan2.c	2010-08-11 21:24:53.000000000 -0700
+++ src/mame/video/toaplan2.c	2010-08-30 08:20:58.000000000 -0700
@@ -28,31 +28,8 @@
 
 #define RAIZING_TX_GFXRAM_SIZE  0x8000	/* GFX data decode RAM size */
 
-#define CPU_2_NONE		0x00
-#define CPU_2_Z80		0x5a
-#define CPU_2_HD647180	0xa5
-#define CPU_2_V25		0xff
 
 
-
-UINT16 *toaplan2_txvideoram16;		/* Video ram for extra text layer */
-UINT16 *toaplan2_txvideoram16_offs;	/* Text layer tile flip and positon ? */
-UINT16 *toaplan2_txscrollram16;		/* Text layer scroll ? */
-UINT16 *toaplan2_tx_gfxram16;			/* Text Layer RAM based tiles */
-UINT16 *raizing_tx_gfxram16;			/* Text Layer RAM based tiles (Batrider) */
-
-size_t toaplan2_tx_vram_size;		 /* 0x2000 Text layer RAM size */
-size_t toaplan2_tx_offs_vram_size;	 /* 0x200 Text layer tile flip and positon ? */
-size_t toaplan2_tx_scroll_vram_size; /* 0x200 Text layer scroll ? */
-size_t batrider_paletteram16_size;
-
-
-
-static int display_tx;
-static UINT8 tx_flip = 0;
-
-static tilemap_t *tx_tilemap;	/* Tilemap for extra-text-layer */
-
 /***************************************************************************
 
   Callbacks for the TileMap code
@@ -61,9 +38,10 @@
 
 static TILE_GET_INFO( get_text_tile_info )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	int color, tile_number, attrib;
 
-	attrib = toaplan2_txvideoram16[tile_index];
+	attrib = state->txvideoram16[tile_index];
 	tile_number = attrib & 0x3ff;
 	color = ((attrib >> 10) | 0x40) & 0x7f;
 	SET_TILE_INFO(
@@ -82,47 +60,66 @@
 
 static void truxton2_create_tx_tilemap(running_machine *machine)
 {
-	tx_tilemap = tilemap_create(machine, get_text_tile_info,tilemap_scan_rows,8,8,64,32);
-	tilemap_set_scroll_rows(tx_tilemap,8*32);	/* line scrolling */
-	tilemap_set_scroll_cols(tx_tilemap,1);
-	tilemap_set_transparent_pen(tx_tilemap,0);
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state->tx_tilemap = tilemap_create(machine, get_text_tile_info, tilemap_scan_rows, 8, 8, 64, 32);
+	tilemap_set_scroll_rows(state->tx_tilemap, 8*32);	/* line scrolling */
+	tilemap_set_scroll_cols(state->tx_tilemap, 1);
+	tilemap_set_transparent_pen(state->tx_tilemap, 0);
 }
 
 static void register_state_save(running_machine *machine)
 {
-	state_save_register_global(machine, tx_flip);
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
+	state_save_register_global(machine, state->tx_flip);
 }
 
 
 VIDEO_START( toaplan2 )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	int width = machine->primary_screen->width();
 	int height = machine->primary_screen->height();
 
 	/* cache the VDP device */
-	toaplan2_state *state = machine->driver_data<toaplan2_state>();
 	state->vdp0 = machine->device<gp9001vdp_device>("gp9001vdp0");
 	state->vdp1 = machine->device<gp9001vdp_device>("gp9001vdp1");
 
 	/* our current VDP implementation needs this bitmap to work with */
-	gp9001_custom_priority_bitmap = auto_bitmap_alloc(machine, width, height, BITMAP_FORMAT_INDEXED8);
+	state->custom_priority_bitmap = auto_bitmap_alloc(machine, width, height, BITMAP_FORMAT_INDEXED8);
+	state->displog = 0; // debug flag
 
-	gp9001_displog = 0; // debug flag
+	if (state->vdp0 != NULL)
+	{
+		state->secondary_render_bitmap = NULL;
+		state->vdp0->custom_priority_bitmap = state->custom_priority_bitmap;
+		state->vdp0->displog = &state->displog;
+	}
 
-	display_tx = 1;
+	if (state->vdp1 != NULL)
+	{
+		state->secondary_render_bitmap = auto_bitmap_alloc(machine, width, height, BITMAP_FORMAT_INDEXED16);
+		state->vdp1->custom_priority_bitmap = state->custom_priority_bitmap;
+		state->vdp1->displog = &state->displog;
+	}
+
+	state->display_tx = 1;
 
 	register_state_save(machine);
 }
 
 VIDEO_START( truxton2 )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
 	VIDEO_START_CALL( toaplan2 );
 
 	/* Create the Text tilemap for this game */
 	truxton2_create_tx_tilemap(machine);
 	if (machine->gfx[2]->srcdata == NULL)
-		gfx_element_set_source(machine->gfx[2], (UINT8 *)toaplan2_tx_gfxram16);
-	tilemap_set_scrolldx(tx_tilemap, 0x1d4 +1, 0x2a);
+		gfx_element_set_source(machine->gfx[2], (UINT8 *)state->tx_gfxram16);
+	tilemap_set_scrolldx(state->tx_tilemap, 0x1d4 +1, 0x2a);
 }
 
 VIDEO_START( fixeighb )
@@ -142,16 +139,18 @@
 	state->vdp0->extra_yoffset[2]=-15;
 	state->vdp0->extra_yoffset[3]=8;
 
-	tilemap_set_scrolldx(tx_tilemap, 0, 0);
+	tilemap_set_scrolldx(state->tx_tilemap, 0, 0);
 }
 
 VIDEO_START( bgaregga )
 {
+	toaplan2_state *state = machine->driver_data<toaplan2_state>();
+
 	VIDEO_START_CALL( toaplan2 );
 
 	/* Create the Text tilemap for this game */
 	truxton2_create_tx_tilemap(machine);
-	tilemap_set_scrolldx(tx_tilemap, 0x1d4, 0x2a);
+	tilemap_set_scrolldx(state->tx_tilemap, 0x1d4, 0x2a);
 }
 
 VIDEO_START( batrider )
@@ -162,11 +161,11 @@
 	state->vdp0->spriteram16_n = state->vdp0->spriteram16_new;
 
 	/* Create the Text tilemap for this game */
-	raizing_tx_gfxram16 = auto_alloc_array_clear(machine, UINT16, RAIZING_TX_GFXRAM_SIZE/2);
-	state_save_register_global_pointer(machine, raizing_tx_gfxram16, RAIZING_TX_GFXRAM_SIZE/2);
-	gfx_element_set_source(machine->gfx[2], (UINT8 *)raizing_tx_gfxram16);
+	state->tx_gfxram16 = auto_alloc_array_clear(machine, UINT16, RAIZING_TX_GFXRAM_SIZE/2);
+	state_save_register_global_pointer(machine, state->tx_gfxram16, RAIZING_TX_GFXRAM_SIZE/2);
+	gfx_element_set_source(machine->gfx[2], (UINT8 *)state->tx_gfxram16);
 	truxton2_create_tx_tilemap(machine);
-	tilemap_set_scrolldx(tx_tilemap, 0x1d4, 0x2a);
+	tilemap_set_scrolldx(state->tx_tilemap, 0x1d4, 0x2a);
 
 	/* Has special banking */
 	state->vdp0->gp9001_gfxrom_is_banked = 1;
@@ -174,20 +173,27 @@
 
 READ16_HANDLER( toaplan2_txvideoram16_r )
 {
-	return toaplan2_txvideoram16[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->txvideoram16[offset];
 }
 
 WRITE16_HANDLER( toaplan2_txvideoram16_w )
 {
-	COMBINE_DATA(&toaplan2_txvideoram16[offset]);
-	if (offset < (toaplan2_tx_vram_size/4))
-		tilemap_mark_tile_dirty(tx_tilemap,offset);
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	COMBINE_DATA(&state->txvideoram16[offset]);
+	if (offset < (state->tx_vram_size/4))
+		tilemap_mark_tile_dirty(state->tx_tilemap, offset);
 }
 
 READ16_HANDLER( toaplan2_txvideoram16_offs_r )
 {
-	return toaplan2_txvideoram16_offs[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->txvideoram16_offs[offset];
 }
+
 WRITE16_HANDLER( toaplan2_txvideoram16_offs_w )
 {
 	/* Besides containing flip, function of this RAM is still unknown */
@@ -195,7 +201,8 @@
 	/* Maybe specifies which line to draw text info (line number data is */
 	/*   opposite when flip bits are on) */
 
-	UINT16 oldword = toaplan2_txvideoram16_offs[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+	UINT16 oldword = state->txvideoram16_offs[offset];
 
 	if (oldword != data)
 	{
@@ -203,72 +210,84 @@
 		{
 			if (data & 0x8000)		/* Flip off */
 			{
-				tx_flip = 0;
-				tilemap_set_flip(tx_tilemap, tx_flip);
-				tilemap_set_scrolly(tx_tilemap, 0, 0);
+				state->tx_flip = 0;
+				tilemap_set_flip(state->tx_tilemap, state->tx_flip);
+				tilemap_set_scrolly(state->tx_tilemap, 0, 0);
 			}
 			else					/* Flip on */
 			{
-				tx_flip = (TILEMAP_FLIPY | TILEMAP_FLIPX);
-				tilemap_set_flip(tx_tilemap, tx_flip);
-				tilemap_set_scrolly(tx_tilemap, 0, -16);
+				state->tx_flip = (TILEMAP_FLIPY | TILEMAP_FLIPX);
+				tilemap_set_flip(state->tx_tilemap, state->tx_flip);
+				tilemap_set_scrolly(state->tx_tilemap, 0, -16);
 			}
 		}
-		COMBINE_DATA(&toaplan2_txvideoram16_offs[offset]);
+		COMBINE_DATA(&state->txvideoram16_offs[offset]);
 	}
 //  logerror("Writing %04x to text offs RAM offset %04x\n",data,offset);
 }
 
 READ16_HANDLER( toaplan2_txscrollram16_r )
 {
-	return toaplan2_txscrollram16[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->txscrollram16[offset];
 }
+
 WRITE16_HANDLER( toaplan2_txscrollram16_w )
 {
 	/*** Line-Scroll RAM for Text Layer ***/
 
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int data_tx = data;
 
-	tilemap_set_scrollx(tx_tilemap, offset, data_tx);
+	tilemap_set_scrollx(state->tx_tilemap, offset, data_tx);
 
 //  logerror("Writing %04x to text scroll RAM offset %04x\n",data,offset);
-	COMBINE_DATA(&toaplan2_txscrollram16[offset]);
+	COMBINE_DATA(&state->txscrollram16[offset]);
 }
 
 READ16_HANDLER( toaplan2_tx_gfxram16_r )
 {
-	return toaplan2_tx_gfxram16[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
+	return state->tx_gfxram16[offset];
 }
 
 WRITE16_HANDLER( toaplan2_tx_gfxram16_w )
 {
 	/*** Dynamic GFX decoding for Truxton 2 / FixEight ***/
 
-	UINT16 oldword = toaplan2_tx_gfxram16[offset];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+	UINT16 oldword = state->tx_gfxram16[offset];
 
 	if (oldword != data)
 	{
 		int code = offset/32;
-		COMBINE_DATA(&toaplan2_tx_gfxram16[offset]);
+		COMBINE_DATA(&state->tx_gfxram16[offset]);
 		gfx_element_mark_dirty(space->machine->gfx[2], code);
 	}
 }
 
 READ16_HANDLER( raizing_tx_gfxram16_r )
 {
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+
 	offset += 0x3400/2;
-	return raizing_tx_gfxram16[offset];
+	return state->tx_gfxram16[offset];
 }
+
 WRITE16_HANDLER( raizing_tx_gfxram16_w )
 {
 	/*** Dynamic Text GFX decoding for Batrider ***/
 
-	UINT16 oldword = raizing_tx_gfxram16[offset + (0x3400 / 2)];
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
+	UINT16 oldword;
 
+	offset += 0x3400/2;
+	oldword = state->tx_gfxram16[offset];
 	if (oldword != data)
 	{
-		offset += 0x3400/2;
-		COMBINE_DATA(&raizing_tx_gfxram16[offset]);
+		COMBINE_DATA(&state->tx_gfxram16[offset]);
 	}
 }
 
@@ -277,16 +296,17 @@
 	/*** Dynamic Text GFX decoding for Batrider ***/
 	/*** Only done once during start-up ***/
 
+	toaplan2_state *state = space->machine->driver_data<toaplan2_state>();
 	int code;
-	UINT16 *dest = (UINT16 *)raizing_tx_gfxram16;
+	UINT16 *dest = (UINT16 *)state->tx_gfxram16;
 
-	memcpy(dest, toaplan2_txvideoram16, toaplan2_tx_vram_size);
-	dest += (toaplan2_tx_vram_size/2);
-	memcpy(dest, space->machine->generic.paletteram.u16, batrider_paletteram16_size);
-	dest += (batrider_paletteram16_size/2);
-	memcpy(dest, toaplan2_txvideoram16_offs, toaplan2_tx_offs_vram_size);
-	dest += (toaplan2_tx_offs_vram_size/2);
-	memcpy(dest, toaplan2_txscrollram16, toaplan2_tx_scroll_vram_size);
+	memcpy(dest, state->txvideoram16, state->tx_vram_size);
+	dest += (state->tx_vram_size/2);
+	memcpy(dest, space->machine->generic.paletteram.u16, state->paletteram16_size);
+	dest += (state->paletteram16_size/2);
+	memcpy(dest, state->txvideoram16_offs, state->tx_offs_vram_size);
+	dest += (state->tx_offs_vram_size/2);
+	memcpy(dest, state->txscrollram16, state->tx_scroll_vram_size);
 
 	/* Decode text characters; force them to update immediately */
 	for (code = 0; code < 1024; code++)
@@ -308,11 +328,141 @@
 	}
 }
 
+// Dogyuun doesn't appear to require fancy mixing?
+VIDEO_UPDATE( toaplan2_dual )
+{
+	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
 
-VIDEO_UPDATE( toaplan2 )
+	if (state->vdp1)
+	{
+		gp9001_log_vram(state->vdp1, screen->machine);
+
+		bitmap_fill(bitmap,cliprect,0);
+		bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
+		state->vdp1->gp9001_render_vdp(screen->machine, bitmap, cliprect);
+	}
+	if (state->vdp0)
+	{
+		gp9001_log_vram(state->vdp0, screen->machine);
+
+	//  bitmap_fill(bitmap,cliprect,0);
+		bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
+		state->vdp0->gp9001_render_vdp(screen->machine, bitmap, cliprect);
+	}
+
+
+	return 0;
+}
+
+
+// renders to 2 bitmaps, and mixes output
+VIDEO_UPDATE( toaplan2_mixed )
 {
 	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
 
+//  bitmap_fill(bitmap,cliprect,0);
+//  bitmap_fill(gp9001_custom_priority_bitmap, cliprect, 0);
+
+	if (state->vdp0)
+	{
+		gp9001_log_vram(state->vdp0, screen->machine);
+
+		bitmap_fill(bitmap,cliprect,0);
+		bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
+		state->vdp0->gp9001_render_vdp(screen->machine, bitmap, cliprect);
+	}
+	if (state->vdp1)
+	{
+		gp9001_log_vram(state->vdp1, screen->machine);
+
+		bitmap_fill(state->secondary_render_bitmap,cliprect,0);
+		bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
+		state->vdp1->gp9001_render_vdp(screen->machine, state->secondary_render_bitmap, cliprect);
+	}
+
+
+	// key test places in batsugun
+	// level 2 - the two layers of clouds (will appear under background, or over ships if wrong)
+	// level 3 - the special effect 'layer' which should be under everything (will appear over background if wrong)
+	// level 4(?) - the large clouds (will obscure player if wrong)
+	// high score entry - letters will be missing if wrong
+	// end credits - various issues if wrong, clouds like level 2
+	//
+	// when implemented based directly on the PAL equation it doesn't work, however, my own equations roughly based
+	// on that do.
+	//
+
+	if (state->vdp0 && state->vdp1)
+	{
+		int width = screen->width();
+		int height = screen->height();
+		int y,x;
+		UINT16* src_vdp0; // output buffer of vdp0
+		UINT16* src_vdp1; // output buffer of vdp1
+
+		for (y=0;y<height;y++)
+		{
+			src_vdp0 = BITMAP_ADDR16(bitmap, y, 0);
+			src_vdp1 = BITMAP_ADDR16(state->secondary_render_bitmap, y, 0);
+
+			for (x=0;x<width;x++)
+			{
+				UINT16 GPU0_LUTaddr = src_vdp0[x];
+				UINT16 GPU1_LUTaddr = src_vdp1[x];
+
+				// these equations is derived from the PAL, but doesn't seem to work?
+
+				int COMPARISON = ((GPU0_LUTaddr & 0x0780) > (GPU1_LUTaddr & 0x0780));
+
+				// note: GPU1_LUTaddr & 0x000f - transparency check for vdp1? (gfx are 4bpp, the low 4 bits of the lookup would be the pixel data value)
+#if 0
+				int result =
+					     ((GPU0_LUTaddr & 0x0008) & !COMPARISON)
+					   | ((GPU0_LUTaddr & 0x0008) & !(GPU1_LUTaddr & 0x000f))
+					   | ((GPU0_LUTaddr & 0x0004) & !COMPARISON)
+					   | ((GPU0_LUTaddr & 0x0004) & !(GPU1_LUTaddr & 0x000f))
+					   | ((GPU0_LUTaddr & 0x0002) & !COMPARISON)
+					   | ((GPU0_LUTaddr & 0x0002) & !(GPU1_LUTaddr & 0x000f))
+					   | ((GPU0_LUTaddr & 0x0001) & !COMPARISON)
+					   | ((GPU0_LUTaddr & 0x0001) & !(GPU1_LUTaddr & 0x000f));
+
+				if (result) src_vdp0[x] = GPU0_LUTaddr;
+				else src_vdp0[x] = GPU1_LUTaddr;
+#endif
+				// this seems to work tho?
+				if (!(GPU1_LUTaddr & 0x000f))
+				{
+					src_vdp0[x] = GPU0_LUTaddr;
+				}
+				else
+				{
+					if (!(GPU0_LUTaddr & 0x000f))
+					{
+						src_vdp0[x] = GPU1_LUTaddr; // bg pen
+					}
+					else
+					{
+						if (COMPARISON)
+						{
+							src_vdp0[x] = GPU1_LUTaddr;
+						}
+						else
+						{
+							src_vdp0[x] = GPU0_LUTaddr;
+						}
+
+					}
+				}
+			}
+		}
+	}
+
+	return 0;
+}
+
+VIDEO_UPDATE( toaplan2 )
+{
+	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
 
 	if (state->vdp0)
 	{
@@ -323,7 +473,7 @@
 		if (screen == screen1)
 		{
 			bitmap_fill(bitmap,cliprect,0);
-			bitmap_fill(gp9001_custom_priority_bitmap, cliprect, 0);
+			bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
 			state->vdp0->gp9001_render_vdp(screen->machine, bitmap, cliprect);
 		}
 	}
@@ -339,7 +489,7 @@
 		if (screen == screen2)
 		{
 			bitmap_fill(bitmap,cliprect,0);
-			bitmap_fill(gp9001_custom_priority_bitmap, cliprect, 0);
+			bitmap_fill(state->custom_priority_bitmap, cliprect, 0);
 			state->vdp1->gp9001_render_vdp(screen->machine, bitmap, cliprect);
 		}
 	}
@@ -350,14 +500,18 @@
 
 VIDEO_UPDATE( truxton2 )
 {
+	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
+
 	VIDEO_UPDATE_CALL(toaplan2);
-	tilemap_draw(bitmap,cliprect,tx_tilemap,0,0);
+	tilemap_draw(bitmap, cliprect, state->tx_tilemap, 0, 0);
 	return 0;
 }
 
 
 VIDEO_UPDATE( batrider )
 {
+	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
+
 	VIDEO_UPDATE_CALL( toaplan2 );
 
 	int line;
@@ -373,36 +527,20 @@
 	for (line = 0; line < 256;line++)
 	{
 		clip.min_y = clip.max_y = line;
-		tilemap_set_scrolly(tx_tilemap,0,toaplan2_txvideoram16_offs[line&0xff]-line);
-		tilemap_draw(bitmap,&clip,tx_tilemap,0,0);
+		tilemap_set_scrolly(state->tx_tilemap, 0, state->txvideoram16_offs[line&0xff] - line);
+		tilemap_draw(bitmap, &clip, state->tx_tilemap, 0, 0);
 	}
 	return 0;
 }
 
 
 
-/* How do the dual VDP games mix? The internal mixing of each VDP chip is independent, if you view only a single
-   VDP then the priorities for that VDP are correct, however, it is completely unclear how the priorities of the
-   two VDPs should actually mix together, as a result these games are broken for now. */
 VIDEO_UPDATE( dogyuun )
 {
 #ifdef DUAL_SCREEN_VDPS
 	VIDEO_UPDATE_CALL( toaplan2 );
 #else
-	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
-
-	bitmap_fill(bitmap,cliprect,0);
-	bitmap_fill(gp9001_custom_priority_bitmap, cliprect, 0);
-
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->bg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->bg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->fg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->fg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->top_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->top_tilemap, toaplan2_primap1, batsugun_prienable0);
-
-	state->vdp1->draw_sprites(screen->machine,bitmap,cliprect, toaplan2_sprprimap1);
-	state->vdp0->draw_sprites(screen->machine,bitmap,cliprect, toaplan2_sprprimap1);
+	VIDEO_UPDATE_CALL( toaplan2_dual );
 #endif
 
 	return 0;
@@ -410,26 +548,10 @@
 
 VIDEO_UPDATE( batsugun )
 {
-	toaplan2_state *state = screen->machine->driver_data<toaplan2_state>();
-	state->vdp1->tile_limit = 0x1fff; // 0x2000-0x3fff seem to be for sprites only? (corruption on level 1 otherwise)
-
-
 #ifdef DUAL_SCREEN_VDPS
 	VIDEO_UPDATE_CALL( toaplan2 );
 #else
-	bitmap_fill(bitmap,cliprect,0);
-	bitmap_fill(gp9001_custom_priority_bitmap, cliprect, 0);
-
-
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->bg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->bg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->fg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->fg_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp1->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp1->top_tilemap, toaplan2_primap1, batsugun_prienable0);
-	state->vdp0->toaplan2_draw_custom_tilemap( screen->machine, bitmap, state->vdp0->top_tilemap, toaplan2_primap1, batsugun_prienable0);
-
-	state->vdp1->draw_sprites(screen->machine,bitmap,cliprect, toaplan2_sprprimap1);
-	state->vdp0->draw_sprites(screen->machine,bitmap,cliprect, toaplan2_sprprimap1);
+	VIDEO_UPDATE_CALL( toaplan2_mixed );
 #endif
 
 	return 0;
diff -Nru src-old/mame/video/trackfld.c src/mame/video/trackfld.c
--- src-old/mame/video/trackfld.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/trackfld.c	2010-08-30 08:20:58.000000000 -0700
@@ -179,8 +179,19 @@
 	trackfld_state *state = machine->driver_data<trackfld_state>();
 	state->bg_tilemap = tilemap_create(machine, get_bg_tile_info, tilemap_scan_rows, 8, 8, 64, 32);
 	tilemap_set_scroll_rows(state->bg_tilemap, 32);
+	state->sprites_gfx_banked = 0;
 }
 
+
+VIDEO_START( atlantol )
+{
+	trackfld_state *state = machine->driver_data<trackfld_state>();
+	VIDEO_START_CALL( trackfld );
+	state->sprites_gfx_banked = 1;
+}
+
+
+
 static void draw_sprites( running_machine *machine, bitmap_t *bitmap, const rectangle *cliprect )
 {
 	trackfld_state *state = machine->driver_data<trackfld_state>();
@@ -193,6 +204,8 @@
 		int attr = spriteram_2[offs];
 		int code = spriteram[offs + 1];
 		int color = attr & 0x0f;
+		if (!state->sprites_gfx_banked)
+			if (attr&1) code|=0x100; // extra tile# bit for the yiear conversion, trackfld doesn't have this many sprites so it will just get masked
 		int flipx = ~attr & 0x40;
 		int flipy = attr & 0x80;
 		int sx = spriteram[offs] - 1;
@@ -208,6 +221,14 @@
 		/* proving that this is a hardware related "feature" */
 		sy += 1;
 
+		// to fix the title screen in yieartf it would have to be like this, the same as yiear.c, this should be verified on the hw
+		//
+		//if (offs < 0x26)
+		//{
+		//  sy++;   /* fix title screen & garbage at the bottom of the screen */
+		//}
+
+
 		drawgfx_transmask(bitmap, cliprect,
 			machine->gfx[0],
 			code + state->sprite_bank1 + state->sprite_bank2, color,
@@ -225,6 +246,8 @@
 	}
 }
 
+
+
 VIDEO_UPDATE( trackfld )
 {
 	trackfld_state *state = screen->machine->driver_data<trackfld_state>();
@@ -241,3 +264,4 @@
 	draw_sprites(screen->machine, bitmap, cliprect);
 	return 0;
 }
+
diff -Nru src-old/mame/video/twin16.c src/mame/video/twin16.c
--- src-old/mame/video/twin16.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/twin16.c	2010-08-19 00:26:14.000000000 -0700
@@ -547,7 +547,7 @@
 		memcpy(twin16_sprite_buffer,&machine->generic.spriteram.u16[0x1800],0x800*sizeof(UINT16));
 	}
 	else {
-		const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+		address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 		buffer_spriteram16_w(space,0,0,0xffff);
 	}
 }
diff -Nru src-old/mame/video/twincobr.c src/mame/video/twincobr.c
--- src-old/mame/video/twincobr.c	2010-03-13 05:40:27.000000000 -0800
+++ src/mame/video/twincobr.c	2010-08-19 00:26:14.000000000 -0700
@@ -505,7 +505,7 @@
 
 VIDEO_EOF( toaplan0 )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 
 	/* Spriteram is always 1 frame ahead, suggesting spriteram buffering.
         There are no CPU output registers that control this so we
diff -Nru src-old/mame/video/vdc.c src/mame/video/vdc.c
--- src-old/mame/video/vdc.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/vdc.c	2010-08-19 00:26:14.000000000 -0700
@@ -1179,7 +1179,7 @@
 
 static void vpc_init( running_machine *machine )
 {
-	const address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
+	address_space *space = cputag_get_address_space(machine, "maincpu", ADDRESS_SPACE_PROGRAM);
 	vpc_w( space, 0, 0x11 );
 	vpc_w( space, 1, 0x11 );
 	vpc.window1.w = 0;
diff -Nru src-old/mame/video/vertigo.c src/mame/video/vertigo.c
--- src-old/mame/video/vertigo.c	2010-01-10 11:00:42.000000000 -0800
+++ src/mame/video/vertigo.c	2010-08-21 15:25:58.000000000 -0700
@@ -482,7 +482,7 @@
 
 	if (irq4) vector_clear_list();
 
-	profiler_mark_start(PROFILER_USER1);
+	g_profiler.start(PROFILER_USER1);
 
 	while (cycles--)
 	{
@@ -658,5 +658,5 @@
 		}
 	}
 
-	profiler_mark_end();
+	g_profiler.stop();
 }
diff -Nru src-old/mame/video/vrender0.c src/mame/video/vrender0.c
--- src-old/mame/video/vrender0.c	2010-07-07 12:27:01.000000000 -0700
+++ src/mame/video/vrender0.c	2010-08-19 01:27:05.000000000 -0700
@@ -397,13 +397,13 @@
 	TILENAME(16,1,2),
 };
 
-#define Packet(i) memory_read_word(space, PacketPtr + 2 * i)
+#define Packet(i) space->read_word(PacketPtr + 2 * i)
 
 //Returns TRUE if the operation was a flip (sync or async)
 int vrender0_ProcessPacket(running_device *device, UINT32 PacketPtr, UINT16 *Dest, UINT8 *TEXTURE)
 {
 	vr0video_state *vr0 = get_safe_token(device);
-	const address_space *space = cpu_get_address_space(vr0->cpu, ADDRESS_SPACE_PROGRAM);
+	address_space *space = cpu_get_address_space(vr0->cpu, ADDRESS_SPACE_PROGRAM);
 	UINT32 Dx = Packet(1) & 0x3ff;
 	UINT32 Dy = Packet(2) & 0x1ff;
 	UINT32 Endx = Packet(3) & 0x3ff;
diff -Nru src-old/mame/video/williams.c src/mame/video/williams.c
--- src-old/mame/video/williams.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/williams.c	2010-08-19 01:27:05.000000000 -0700
@@ -158,7 +158,7 @@
 static void blitter_init(running_machine *machine, int blitter_config, const UINT8 *remap_prom);
 static void create_palette_lookup(running_machine *machine);
 static TILE_GET_INFO( get_tile_info );
-static int blitter_core(const address_space *space, int sstart, int dstart, int w, int h, int data);
+static int blitter_core(address_space *space, int sstart, int dstart, int w, int h, int data);
 
 
 
@@ -603,10 +603,10 @@
  *
  *************************************/
 
-INLINE void blit_pixel(const address_space *space, int offset, int srcdata, int data, int mask, int solid)
+INLINE void blit_pixel(address_space *space, int offset, int srcdata, int data, int mask, int solid)
 {
 	/* always read from video RAM regardless of the bank setting */
-	int pix = (offset < 0xc000) ? williams_videoram[offset] : memory_read_byte(space, offset);
+	int pix = (offset < 0xc000) ? williams_videoram[offset] : space->read_byte(offset);
 
 	/* handle transparency */
 	if (data & 0x08)
@@ -626,11 +626,11 @@
 	/* note that we have to allow blits to non-video RAM (e.g. tileram) because those */
 	/* are not blocked by the window enable */
 	if (!williams_blitter_window_enable || offset < williams_blitter_clip_address || offset >= 0xc000)
-		memory_write_byte(space, offset, pix);
+		space->write_byte(offset, pix);
 }
 
 
-static int blitter_core(const address_space *space, int sstart, int dstart, int w, int h, int data)
+static int blitter_core(address_space *space, int sstart, int dstart, int w, int h, int data)
 {
 	int source, sxadv, syadv;
 	int dest, dxadv, dyadv;
@@ -666,7 +666,7 @@
 			/* loop over the width */
 			for (j = w; j > 0; j--)
 			{
-				blit_pixel(space, dest, blitter_remap[memory_read_byte(space, source)], data, keepmask, solid);
+				blit_pixel(space, dest, blitter_remap[space->read_byte(source)], data, keepmask, solid);
 				accesses += 2;
 
 				/* advance */
@@ -700,7 +700,7 @@
 			dest = dstart & 0xffff;
 
 			/* left edge case */
-			pixdata = blitter_remap[memory_read_byte(space, source)];
+			pixdata = blitter_remap[space->read_byte(source)];
 			blit_pixel(space, dest, (pixdata >> 4) & 0x0f, data, keepmask | 0xf0, solid);
 			accesses += 2;
 
@@ -710,7 +710,7 @@
 			/* loop over the width */
 			for (j = w - 1; j > 0; j--)
 			{
-				pixdata = (pixdata << 8) | blitter_remap[memory_read_byte(space, source)];
+				pixdata = (pixdata << 8) | blitter_remap[space->read_byte(source)];
 				blit_pixel(space, dest, (pixdata >> 4) & 0xff, data, keepmask, solid);
 				accesses += 2;
 
diff -Nru src-old/mame/video/zac2650.c src/mame/video/zac2650.c
--- src-old/mame/video/zac2650.c	2010-06-07 23:09:57.000000000 -0700
+++ src/mame/video/zac2650.c	2010-08-12 13:04:59.000000000 -0700
@@ -5,6 +5,7 @@
 /*************************************************************/
 
 #include "emu.h"
+#include "sound/s2636.h"
 
 UINT8 *zac2650_s2636_0_ram;
 static bitmap_t *spritebitmap;
@@ -38,6 +39,10 @@
 	zac2650_s2636_0_ram[offset] = data;
 	gfx_element_mark_dirty(space->machine->gfx[1], offset/8);
 	gfx_element_mark_dirty(space->machine->gfx[2], offset/8);
+	if (offset == 0xc7)
+	{
+		s2636_soundport_w(space->machine->device("s2636snd"), 0, data);
+	}
 }
 
 READ8_HANDLER( tinvader_port_0_r )
diff -Nru src-old/mame/video/zaxxon.c src/mame/video/zaxxon.c
--- src-old/mame/video/zaxxon.c	2010-08-04 08:37:08.000000000 -0700
+++ src/mame/video/zaxxon.c	2010-08-19 01:27:05.000000000 -0700
@@ -304,11 +304,11 @@
 		/* this is just a guess; the chip is hardwired to the spriteram */
 		while (count-- >= 0)
 		{
-			UINT8 daddr = memory_read_byte(space, saddr + 0) * 4;
-			spriteram[(daddr + 0) & 0xff] = memory_read_byte(space, saddr + 1);
-			spriteram[(daddr + 1) & 0xff] = memory_read_byte(space, saddr + 2);
-			spriteram[(daddr + 2) & 0xff] = memory_read_byte(space, saddr + 3);
-			spriteram[(daddr + 3) & 0xff] = memory_read_byte(space, saddr + 4);
+			UINT8 daddr = space->read_byte(saddr + 0) * 4;
+			spriteram[(daddr + 0) & 0xff] = space->read_byte(saddr + 1);
+			spriteram[(daddr + 1) & 0xff] = space->read_byte(saddr + 2);
+			spriteram[(daddr + 2) & 0xff] = space->read_byte(saddr + 3);
+			spriteram[(daddr + 3) & 0xff] = space->read_byte(saddr + 4);
 			saddr += 0x20;
 		}
 	}
diff -Nru src-old/osd/sdl/debugosx.m src/osd/sdl/debugosx.m
--- src-old/osd/sdl/debugosx.m	2010-07-06 20:31:58.000000000 -0700
+++ src/osd/sdl/debugosx.m	2010-08-19 00:26:14.000000000 -0700
@@ -878,7 +878,7 @@
 
 @implementation MAMEDisassemblyView
 
-- (device_debug::breakpoint *)findBreakpointAtAddress:(offs_t)address inAddressSpace:(const address_space *)space {
+- (device_debug::breakpoint *)findBreakpointAtAddress:(offs_t)address inAddressSpace:(address_space *)space {
 	device_debug			*cpuinfo = space->cpu->debug();
 	device_debug::breakpoint	*bp;
 	for (bp = cpuinfo->breakpoint_first(); (bp != NULL) && (address != bp->address()); bp = bp->next()) {}
@@ -1081,7 +1081,7 @@
 
 - (IBAction)debugToggleBreakpoint:(id)sender {
 	if (view->cursor_visible()) {
-		const address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
+		address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
 		if (!useConsole || (debug_cpu_get_visible_cpu(machine) == space->cpu)) {
 			offs_t				address = downcast<debug_view_disasm *>(view)->selected_address();
 			device_debug::breakpoint *bp = [self findBreakpointAtAddress:address inAddressSpace:space];
@@ -1107,7 +1107,7 @@
 
 - (IBAction)debugToggleBreakpointEnable:(id)sender {
 	if (view->cursor_visible()) {
-		const address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
+		address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
 		if (!useConsole || (debug_cpu_get_visible_cpu(machine) == space->cpu)) {
 			offs_t				address = downcast<debug_view_disasm *>(view)->selected_address();
 			device_debug::breakpoint *bp = [self findBreakpointAtAddress:address inAddressSpace:space];
@@ -1131,7 +1131,7 @@
 
 - (IBAction)debugRunToCursor:(id)sender {
 	if (view->cursor_visible()) {
-		const address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
+		address_space *space = downcast<const debug_view_disasm_source *>(view->source())->space();
 		if (debug_cpu_get_visible_cpu(machine) == space->cpu) {
 			offs_t address = downcast<debug_view_disasm *>(view)->selected_address();
 			if (useConsole) {
diff -Nru src-old/version.c src/version.c
--- src-old/version.c	2010-08-11 21:24:53.000000000 -0700
+++ src/version.c	2010-08-30 08:20:58.000000000 -0700
@@ -10,4 +10,4 @@
 ***************************************************************************/
 
 extern const char build_version[];
-const char build_version[] = "0.139u1 ("__DATE__")";
+const char build_version[] = "0.139u2 ("__DATE__")";
